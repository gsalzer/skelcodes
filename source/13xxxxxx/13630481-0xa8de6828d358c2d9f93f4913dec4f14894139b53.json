{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n   ____            __   __        __   _\r\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\r\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\r\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\r\n     /___/\r\n\r\n* Synthetix: migrations/Migration_Alkaid.sol\r\n*\r\n* Latest source (may be newer): https://github.com/Synthetixio/synthetix/blob/master/contracts/migrations/Migration_Alkaid.sol\r\n* Docs: https://docs.synthetix.io/contracts/migrations/Migration_Alkaid\r\n*\r\n* Contract Dependencies: \r\n*\t- BaseMigration\r\n*\t- EternalStorage\r\n*\t- ExchangeRates\r\n*\t- ExternStateToken\r\n*\t- IAddressResolver\r\n*\t- IERC20\r\n*\t- IExchangeRates\r\n*\t- IExchangeState\r\n*\t- IFeePool\r\n*\t- IIssuer\r\n*\t- IRewardEscrow\r\n*\t- IRewardsDistribution\r\n*\t- ISynth\r\n*\t- ISynthetixState\r\n*\t- ISystemSettings\r\n*\t- ISystemStatus\r\n*\t- LegacyOwned\r\n*\t- LimitedSetup\r\n*\t- MixinResolver\r\n*\t- MixinSystemSettings\r\n*\t- Owned\r\n*\t- Proxy\r\n*\t- Proxyable\r\n*\t- State\r\n*\t- Synth\r\n* Libraries: \r\n*\t- Migration_Alkaid_Supplemental\r\n*\t- SafeCast\r\n*\t- SafeDecimalMath\r\n*\t- SafeMath\r\n*\t- VestingEntries\r\n*\r\n* MIT License\r\n* ===========\r\n*\r\n* Copyright (c) 2021 Synthetix\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, including without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n* copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in all\r\n* copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n*/\r\n\r\n\r\n\r\npragma solidity ^0.5.16;\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/owned\r\ncontract Owned {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    constructor(address _owner) public {\r\n        require(_owner != address(0), \"Owner address cannot be 0\");\r\n        owner = _owner;\r\n        emit OwnerChanged(address(0), _owner);\r\n    }\r\n\r\n    function nominateNewOwner(address _owner) external onlyOwner {\r\n        nominatedOwner = _owner;\r\n        emit OwnerNominated(_owner);\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\r\n        emit OwnerChanged(owner, nominatedOwner);\r\n        owner = nominatedOwner;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        _onlyOwner();\r\n        _;\r\n    }\r\n\r\n    function _onlyOwner() private view {\r\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\r\n    }\r\n\r\n    event OwnerNominated(address newOwner);\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\r\ninterface IAddressResolver {\r\n    function getAddress(bytes32 name) external view returns (address);\r\n\r\n    function getSynth(bytes32 key) external view returns (address);\r\n\r\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\r\ninterface ISynth {\r\n    // Views\r\n    function currencyKey() external view returns (bytes32);\r\n\r\n    function transferableSynths(address account) external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function transferAndSettle(address to, uint value) external returns (bool);\r\n\r\n    function transferFromAndSettle(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) external returns (bool);\r\n\r\n    // Restricted: used internally to Synthetix\r\n    function burn(address account, uint amount) external;\r\n\r\n    function issue(address account, uint amount) external;\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/iissuer\r\ninterface IIssuer {\r\n    // Views\r\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\r\n\r\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\r\n\r\n    function availableSynthCount() external view returns (uint);\r\n\r\n    function availableSynths(uint index) external view returns (ISynth);\r\n\r\n    function canBurnSynths(address account) external view returns (bool);\r\n\r\n    function collateral(address account) external view returns (uint);\r\n\r\n    function collateralisationRatio(address issuer) external view returns (uint);\r\n\r\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\r\n        external\r\n        view\r\n        returns (uint cratio, bool anyRateIsInvalid);\r\n\r\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\r\n\r\n    function issuanceRatio() external view returns (uint);\r\n\r\n    function lastIssueEvent(address account) external view returns (uint);\r\n\r\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\r\n\r\n    function minimumStakeTime() external view returns (uint);\r\n\r\n    function remainingIssuableSynths(address issuer)\r\n        external\r\n        view\r\n        returns (\r\n            uint maxIssuable,\r\n            uint alreadyIssued,\r\n            uint totalSystemDebt\r\n        );\r\n\r\n    function synths(bytes32 currencyKey) external view returns (ISynth);\r\n\r\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory);\r\n\r\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\r\n\r\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint);\r\n\r\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\r\n        external\r\n        view\r\n        returns (uint transferable, bool anyRateIsInvalid);\r\n\r\n    // Restricted: used internally to Synthetix\r\n    function issueSynths(address from, uint amount) external;\r\n\r\n    function issueSynthsOnBehalf(\r\n        address issueFor,\r\n        address from,\r\n        uint amount\r\n    ) external;\r\n\r\n    function issueMaxSynths(address from) external;\r\n\r\n    function issueMaxSynthsOnBehalf(address issueFor, address from) external;\r\n\r\n    function burnSynths(address from, uint amount) external;\r\n\r\n    function burnSynthsOnBehalf(\r\n        address burnForAddress,\r\n        address from,\r\n        uint amount\r\n    ) external;\r\n\r\n    function burnSynthsToTarget(address from) external;\r\n\r\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external;\r\n\r\n    function burnForRedemption(\r\n        address deprecatedSynthProxy,\r\n        address account,\r\n        uint balance\r\n    ) external;\r\n\r\n    function liquidateDelinquentAccount(\r\n        address account,\r\n        uint susdAmount,\r\n        address liquidator\r\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\r\n}\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/mixinresolver\r\ncontract MixinResolver {\r\n    AddressResolver public resolver;\r\n\r\n    mapping(bytes32 => address) private addressCache;\r\n\r\n    constructor(address _resolver) internal {\r\n        resolver = AddressResolver(_resolver);\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\r\n        internal\r\n        pure\r\n        returns (bytes32[] memory combination)\r\n    {\r\n        combination = new bytes32[](first.length + second.length);\r\n\r\n        for (uint i = 0; i < first.length; i++) {\r\n            combination[i] = first[i];\r\n        }\r\n\r\n        for (uint j = 0; j < second.length; j++) {\r\n            combination[first.length + j] = second[j];\r\n        }\r\n    }\r\n\r\n    /* ========== PUBLIC FUNCTIONS ========== */\r\n\r\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\r\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\r\n\r\n    function rebuildCache() public {\r\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\r\n        // The resolver must call this function whenver it updates its state\r\n        for (uint i = 0; i < requiredAddresses.length; i++) {\r\n            bytes32 name = requiredAddresses[i];\r\n            // Note: can only be invoked once the resolver has all the targets needed added\r\n            address destination =\r\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\"Resolver missing target: \", name)));\r\n            addressCache[name] = destination;\r\n            emit CacheUpdated(name, destination);\r\n        }\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function isResolverCached() external view returns (bool) {\r\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\r\n        for (uint i = 0; i < requiredAddresses.length; i++) {\r\n            bytes32 name = requiredAddresses[i];\r\n            // false if our cache is invalid or if the resolver doesn't have the required address\r\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\r\n        address _foundAddress = addressCache[name];\r\n        require(_foundAddress != address(0), string(abi.encodePacked(\"Missing address: \", name)));\r\n        return _foundAddress;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event CacheUpdated(bytes32 name, address destination);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/addressresolver\r\ncontract AddressResolver is Owned, IAddressResolver {\r\n    mapping(bytes32 => address) public repository;\r\n\r\n    constructor(address _owner) public Owned(_owner) {}\r\n\r\n    /* ========== RESTRICTED FUNCTIONS ========== */\r\n\r\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\r\n        require(names.length == destinations.length, \"Input lengths must match\");\r\n\r\n        for (uint i = 0; i < names.length; i++) {\r\n            bytes32 name = names[i];\r\n            address destination = destinations[i];\r\n            repository[name] = destination;\r\n            emit AddressImported(name, destination);\r\n        }\r\n    }\r\n\r\n    /* ========= PUBLIC FUNCTIONS ========== */\r\n\r\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\r\n        for (uint i = 0; i < destinations.length; i++) {\r\n            destinations[i].rebuildCache();\r\n        }\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\r\n        for (uint i = 0; i < names.length; i++) {\r\n            if (repository[names[i]] != destinations[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getAddress(bytes32 name) external view returns (address) {\r\n        return repository[name];\r\n    }\r\n\r\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\r\n        address _foundAddress = repository[name];\r\n        require(_foundAddress != address(0), reason);\r\n        return _foundAddress;\r\n    }\r\n\r\n    function getSynth(bytes32 key) external view returns (address) {\r\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\r\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\r\n        return address(issuer.synths(key));\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event AddressImported(bytes32 name, address destination);\r\n}\r\n\r\n\r\ncontract BaseMigration is Owned {\r\n    address public deployer;\r\n\r\n    constructor(address _owner) internal Owned(_owner) {\r\n        deployer = msg.sender;\r\n    }\r\n\r\n    // safety value to return ownership (anyone can invoke)\r\n    function returnOwnership(address forContract) public {\r\n        bytes memory payload = abi.encodeWithSignature(\"nominateNewOwner(address)\", owner);\r\n\r\n        // solhint-disable avoid-low-level-calls\r\n        (bool success, ) = forContract.call(payload);\r\n\r\n        if (!success) {\r\n            // then try legacy way\r\n            bytes memory legacyPayload = abi.encodeWithSignature(\"nominateOwner(address)\", owner);\r\n\r\n            // solhint-disable avoid-low-level-calls\r\n            (bool legacySuccess, ) = forContract.call(legacyPayload);\r\n\r\n            require(legacySuccess, \"Legacy nomination failed\");\r\n        }\r\n    }\r\n\r\n    function _requireDeployer() private view {\r\n        require(msg.sender == deployer, \"Only the deployer can invoke this\");\r\n    }\r\n\r\n    modifier onlyDeployer() {\r\n        _requireDeployer();\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/iflexiblestorage\r\ninterface IFlexibleStorage {\r\n    // Views\r\n    function getUIntValue(bytes32 contractName, bytes32 record) external view returns (uint);\r\n\r\n    function getUIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (uint[] memory);\r\n\r\n    function getIntValue(bytes32 contractName, bytes32 record) external view returns (int);\r\n\r\n    function getIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (int[] memory);\r\n\r\n    function getAddressValue(bytes32 contractName, bytes32 record) external view returns (address);\r\n\r\n    function getAddressValues(bytes32 contractName, bytes32[] calldata records) external view returns (address[] memory);\r\n\r\n    function getBoolValue(bytes32 contractName, bytes32 record) external view returns (bool);\r\n\r\n    function getBoolValues(bytes32 contractName, bytes32[] calldata records) external view returns (bool[] memory);\r\n\r\n    function getBytes32Value(bytes32 contractName, bytes32 record) external view returns (bytes32);\r\n\r\n    function getBytes32Values(bytes32 contractName, bytes32[] calldata records) external view returns (bytes32[] memory);\r\n\r\n    // Mutative functions\r\n    function deleteUIntValue(bytes32 contractName, bytes32 record) external;\r\n\r\n    function deleteIntValue(bytes32 contractName, bytes32 record) external;\r\n\r\n    function deleteAddressValue(bytes32 contractName, bytes32 record) external;\r\n\r\n    function deleteBoolValue(bytes32 contractName, bytes32 record) external;\r\n\r\n    function deleteBytes32Value(bytes32 contractName, bytes32 record) external;\r\n\r\n    function setUIntValue(\r\n        bytes32 contractName,\r\n        bytes32 record,\r\n        uint value\r\n    ) external;\r\n\r\n    function setUIntValues(\r\n        bytes32 contractName,\r\n        bytes32[] calldata records,\r\n        uint[] calldata values\r\n    ) external;\r\n\r\n    function setIntValue(\r\n        bytes32 contractName,\r\n        bytes32 record,\r\n        int value\r\n    ) external;\r\n\r\n    function setIntValues(\r\n        bytes32 contractName,\r\n        bytes32[] calldata records,\r\n        int[] calldata values\r\n    ) external;\r\n\r\n    function setAddressValue(\r\n        bytes32 contractName,\r\n        bytes32 record,\r\n        address value\r\n    ) external;\r\n\r\n    function setAddressValues(\r\n        bytes32 contractName,\r\n        bytes32[] calldata records,\r\n        address[] calldata values\r\n    ) external;\r\n\r\n    function setBoolValue(\r\n        bytes32 contractName,\r\n        bytes32 record,\r\n        bool value\r\n    ) external;\r\n\r\n    function setBoolValues(\r\n        bytes32 contractName,\r\n        bytes32[] calldata records,\r\n        bool[] calldata values\r\n    ) external;\r\n\r\n    function setBytes32Value(\r\n        bytes32 contractName,\r\n        bytes32 record,\r\n        bytes32 value\r\n    ) external;\r\n\r\n    function setBytes32Values(\r\n        bytes32 contractName,\r\n        bytes32[] calldata records,\r\n        bytes32[] calldata values\r\n    ) external;\r\n}\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/mixinsystemsettings\r\ncontract MixinSystemSettings is MixinResolver {\r\n    bytes32 internal constant SETTING_CONTRACT_NAME = \"SystemSettings\";\r\n\r\n    bytes32 internal constant SETTING_WAITING_PERIOD_SECS = \"waitingPeriodSecs\";\r\n    bytes32 internal constant SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR = \"priceDeviationThresholdFactor\";\r\n    bytes32 internal constant SETTING_ISSUANCE_RATIO = \"issuanceRatio\";\r\n    bytes32 internal constant SETTING_FEE_PERIOD_DURATION = \"feePeriodDuration\";\r\n    bytes32 internal constant SETTING_TARGET_THRESHOLD = \"targetThreshold\";\r\n    bytes32 internal constant SETTING_LIQUIDATION_DELAY = \"liquidationDelay\";\r\n    bytes32 internal constant SETTING_LIQUIDATION_RATIO = \"liquidationRatio\";\r\n    bytes32 internal constant SETTING_LIQUIDATION_PENALTY = \"liquidationPenalty\";\r\n    bytes32 internal constant SETTING_RATE_STALE_PERIOD = \"rateStalePeriod\";\r\n    bytes32 internal constant SETTING_EXCHANGE_FEE_RATE = \"exchangeFeeRate\";\r\n    bytes32 internal constant SETTING_MINIMUM_STAKE_TIME = \"minimumStakeTime\";\r\n    bytes32 internal constant SETTING_AGGREGATOR_WARNING_FLAGS = \"aggregatorWarningFlags\";\r\n    bytes32 internal constant SETTING_TRADING_REWARDS_ENABLED = \"tradingRewardsEnabled\";\r\n    bytes32 internal constant SETTING_DEBT_SNAPSHOT_STALE_TIME = \"debtSnapshotStaleTime\";\r\n    bytes32 internal constant SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT = \"crossDomainDepositGasLimit\";\r\n    bytes32 internal constant SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT = \"crossDomainEscrowGasLimit\";\r\n    bytes32 internal constant SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT = \"crossDomainRewardGasLimit\";\r\n    bytes32 internal constant SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT = \"crossDomainWithdrawalGasLimit\";\r\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MAX_ETH = \"etherWrapperMaxETH\";\r\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MINT_FEE_RATE = \"etherWrapperMintFeeRate\";\r\n    bytes32 internal constant SETTING_ETHER_WRAPPER_BURN_FEE_RATE = \"etherWrapperBurnFeeRate\";\r\n    bytes32 internal constant SETTING_WRAPPER_MAX_TOKEN_AMOUNT = \"wrapperMaxTokens\";\r\n    bytes32 internal constant SETTING_WRAPPER_MINT_FEE_RATE = \"wrapperMintFeeRate\";\r\n    bytes32 internal constant SETTING_WRAPPER_BURN_FEE_RATE = \"wrapperBurnFeeRate\";\r\n    bytes32 internal constant SETTING_MIN_CRATIO = \"minCratio\";\r\n    bytes32 internal constant SETTING_NEW_COLLATERAL_MANAGER = \"newCollateralManager\";\r\n    bytes32 internal constant SETTING_INTERACTION_DELAY = \"interactionDelay\";\r\n    bytes32 internal constant SETTING_COLLAPSE_FEE_RATE = \"collapseFeeRate\";\r\n    bytes32 internal constant SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK = \"atomicMaxVolumePerBlock\";\r\n    bytes32 internal constant SETTING_ATOMIC_TWAP_WINDOW = \"atomicTwapWindow\";\r\n    bytes32 internal constant SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING = \"atomicEquivalentForDexPricing\";\r\n    bytes32 internal constant SETTING_ATOMIC_EXCHANGE_FEE_RATE = \"atomicExchangeFeeRate\";\r\n    bytes32 internal constant SETTING_ATOMIC_PRICE_BUFFER = \"atomicPriceBuffer\";\r\n    bytes32 internal constant SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = \"atomicVolConsiderationWindow\";\r\n    bytes32 internal constant SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD = \"atomicVolUpdateThreshold\";\r\n\r\n    bytes32 internal constant CONTRACT_FLEXIBLESTORAGE = \"FlexibleStorage\";\r\n\r\n    enum CrossDomainMessageGasLimits {Deposit, Escrow, Reward, Withdrawal}\r\n\r\n    constructor(address _resolver) internal MixinResolver(_resolver) {}\r\n\r\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\r\n        addresses = new bytes32[](1);\r\n        addresses[0] = CONTRACT_FLEXIBLESTORAGE;\r\n    }\r\n\r\n    function flexibleStorage() internal view returns (IFlexibleStorage) {\r\n        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));\r\n    }\r\n\r\n    function _getGasLimitSetting(CrossDomainMessageGasLimits gasLimitType) internal pure returns (bytes32) {\r\n        if (gasLimitType == CrossDomainMessageGasLimits.Deposit) {\r\n            return SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT;\r\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Escrow) {\r\n            return SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT;\r\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Reward) {\r\n            return SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT;\r\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Withdrawal) {\r\n            return SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT;\r\n        } else {\r\n            revert(\"Unknown gas limit type\");\r\n        }\r\n    }\r\n\r\n    function getCrossDomainMessageGasLimit(CrossDomainMessageGasLimits gasLimitType) internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, _getGasLimitSetting(gasLimitType));\r\n    }\r\n\r\n    function getTradingRewardsEnabled() internal view returns (bool) {\r\n        return flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME, SETTING_TRADING_REWARDS_ENABLED);\r\n    }\r\n\r\n    function getWaitingPeriodSecs() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_WAITING_PERIOD_SECS);\r\n    }\r\n\r\n    function getPriceDeviationThresholdFactor() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR);\r\n    }\r\n\r\n    function getIssuanceRatio() internal view returns (uint) {\r\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ISSUANCE_RATIO);\r\n    }\r\n\r\n    function getFeePeriodDuration() internal view returns (uint) {\r\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_FEE_PERIOD_DURATION);\r\n    }\r\n\r\n    function getTargetThreshold() internal view returns (uint) {\r\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_TARGET_THRESHOLD);\r\n    }\r\n\r\n    function getLiquidationDelay() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_DELAY);\r\n    }\r\n\r\n    function getLiquidationRatio() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_RATIO);\r\n    }\r\n\r\n    function getLiquidationPenalty() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_PENALTY);\r\n    }\r\n\r\n    function getRateStalePeriod() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_RATE_STALE_PERIOD);\r\n    }\r\n\r\n    function getExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE, currencyKey))\r\n            );\r\n    }\r\n\r\n    function getMinimumStakeTime() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MINIMUM_STAKE_TIME);\r\n    }\r\n\r\n    function getAggregatorWarningFlags() internal view returns (address) {\r\n        return flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME, SETTING_AGGREGATOR_WARNING_FLAGS);\r\n    }\r\n\r\n    function getDebtSnapshotStaleTime() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_DEBT_SNAPSHOT_STALE_TIME);\r\n    }\r\n\r\n    function getEtherWrapperMaxETH() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MAX_ETH);\r\n    }\r\n\r\n    function getEtherWrapperMintFeeRate() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MINT_FEE_RATE);\r\n    }\r\n\r\n    function getEtherWrapperBurnFeeRate() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_BURN_FEE_RATE);\r\n    }\r\n\r\n    function getWrapperMaxTokenAmount(address wrapper) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_WRAPPER_MAX_TOKEN_AMOUNT, wrapper))\r\n            );\r\n    }\r\n\r\n    function getWrapperMintFeeRate(address wrapper) internal view returns (int) {\r\n        return\r\n            flexibleStorage().getIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_WRAPPER_MINT_FEE_RATE, wrapper))\r\n            );\r\n    }\r\n\r\n    function getWrapperBurnFeeRate(address wrapper) internal view returns (int) {\r\n        return\r\n            flexibleStorage().getIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_WRAPPER_BURN_FEE_RATE, wrapper))\r\n            );\r\n    }\r\n\r\n    function getMinCratio(address collateral) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_MIN_CRATIO, collateral))\r\n            );\r\n    }\r\n\r\n    function getNewCollateralManager(address collateral) internal view returns (address) {\r\n        return\r\n            flexibleStorage().getAddressValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_NEW_COLLATERAL_MANAGER, collateral))\r\n            );\r\n    }\r\n\r\n    function getInteractionDelay(address collateral) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_INTERACTION_DELAY, collateral))\r\n            );\r\n    }\r\n\r\n    function getCollapseFeeRate(address collateral) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_COLLAPSE_FEE_RATE, collateral))\r\n            );\r\n    }\r\n\r\n    function getAtomicMaxVolumePerBlock() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK);\r\n    }\r\n\r\n    function getAtomicTwapWindow() internal view returns (uint) {\r\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_TWAP_WINDOW);\r\n    }\r\n\r\n    function getAtomicEquivalentForDexPricing(bytes32 currencyKey) internal view returns (address) {\r\n        return\r\n            flexibleStorage().getAddressValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING, currencyKey))\r\n            );\r\n    }\r\n\r\n    function getAtomicExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_ATOMIC_EXCHANGE_FEE_RATE, currencyKey))\r\n            );\r\n    }\r\n\r\n    function getAtomicPriceBuffer(bytes32 currencyKey) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_ATOMIC_PRICE_BUFFER, currencyKey))\r\n            );\r\n    }\r\n\r\n    function getAtomicVolatilityConsiderationWindow(bytes32 currencyKey) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW, currencyKey))\r\n            );\r\n    }\r\n\r\n    function getAtomicVolatilityUpdateThreshold(bytes32 currencyKey) internal view returns (uint) {\r\n        return\r\n            flexibleStorage().getUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD, currencyKey))\r\n            );\r\n    }\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/ierc20\r\ninterface IERC20 {\r\n    // ERC20 Optional Views\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    // Views\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) external returns (bool);\r\n\r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\r\ninterface IExchangeRates {\r\n    // Structs\r\n    struct RateAndUpdatedTime {\r\n        uint216 rate;\r\n        uint40 time;\r\n    }\r\n\r\n    // Views\r\n    function aggregators(bytes32 currencyKey) external view returns (address);\r\n\r\n    function aggregatorWarningFlags() external view returns (address);\r\n\r\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\r\n\r\n    function currentRoundForRate(bytes32 currencyKey) external view returns (uint);\r\n\r\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\r\n\r\n    function effectiveValue(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    ) external view returns (uint value);\r\n\r\n    function effectiveValueAndRates(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint value,\r\n            uint sourceRate,\r\n            uint destinationRate\r\n        );\r\n\r\n    function effectiveAtomicValueAndRates(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint value,\r\n            uint systemValue,\r\n            uint systemSourceRate,\r\n            uint systemDestinationRate\r\n        );\r\n\r\n    function effectiveValueAtRound(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        uint roundIdForSrc,\r\n        uint roundIdForDest\r\n    ) external view returns (uint value);\r\n\r\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\r\n\r\n    function getLastRoundIdBeforeElapsedSecs(\r\n        bytes32 currencyKey,\r\n        uint startingRoundId,\r\n        uint startingTimestamp,\r\n        uint timediff\r\n    ) external view returns (uint);\r\n\r\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\r\n\r\n    function oracle() external view returns (address);\r\n\r\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\r\n\r\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\r\n\r\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\r\n\r\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\r\n\r\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\r\n\r\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\r\n\r\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\r\n\r\n    function rateStalePeriod() external view returns (uint);\r\n\r\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(bytes32 currencyKey, uint numRounds)\r\n        external\r\n        view\r\n        returns (uint[] memory rates, uint[] memory times);\r\n\r\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\r\n        external\r\n        view\r\n        returns (uint[] memory rates, bool anyRateInvalid);\r\n\r\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\r\n\r\n    function synthTooVolatileForAtomicExchange(bytes32 currencyKey) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\r\nlibrary SafeDecimalMath {\r\n    using SafeMath for uint;\r\n\r\n    /* Number of decimal places in the representations. */\r\n    uint8 public constant decimals = 18;\r\n    uint8 public constant highPrecisionDecimals = 27;\r\n\r\n    /* The number representing 1.0. */\r\n    uint public constant UNIT = 10**uint(decimals);\r\n\r\n    /* The number representing 1.0 for higher fidelity numbers. */\r\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\r\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\r\n\r\n    /**\r\n     * @return Provides an interface to UNIT.\r\n     */\r\n    function unit() external pure returns (uint) {\r\n        return UNIT;\r\n    }\r\n\r\n    /**\r\n     * @return Provides an interface to PRECISE_UNIT.\r\n     */\r\n    function preciseUnit() external pure returns (uint) {\r\n        return PRECISE_UNIT;\r\n    }\r\n\r\n    /**\r\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\r\n     * decimals.\r\n     *\r\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\r\n     * so that product must be less than 2**256. As this is an integer division,\r\n     * the internal division always rounds down. This helps save on gas. Rounding\r\n     * is more expensive on gas.\r\n     */\r\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\r\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\r\n        return x.mul(y) / UNIT;\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely multiplying x and y, interpreting the operands\r\n     * as fixed-point decimals of the specified precision unit.\r\n     *\r\n     * @dev The operands should be in the form of a the specified unit factor which will be\r\n     * divided out after the product of x and y is evaluated, so that product must be\r\n     * less than 2**256.\r\n     *\r\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\r\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\r\n     * (eg. small fractions or percentages).\r\n     */\r\n    function _multiplyDecimalRound(\r\n        uint x,\r\n        uint y,\r\n        uint precisionUnit\r\n    ) private pure returns (uint) {\r\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\r\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\r\n\r\n        if (quotientTimesTen % 10 >= 5) {\r\n            quotientTimesTen += 10;\r\n        }\r\n\r\n        return quotientTimesTen / 10;\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely multiplying x and y, interpreting the operands\r\n     * as fixed-point decimals of a precise unit.\r\n     *\r\n     * @dev The operands should be in the precise unit factor which will be\r\n     * divided out after the product of x and y is evaluated, so that product must be\r\n     * less than 2**256.\r\n     *\r\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\r\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\r\n     * (eg. small fractions or percentages).\r\n     */\r\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\r\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely multiplying x and y, interpreting the operands\r\n     * as fixed-point decimals of a standard unit.\r\n     *\r\n     * @dev The operands should be in the standard unit factor which will be\r\n     * divided out after the product of x and y is evaluated, so that product must be\r\n     * less than 2**256.\r\n     *\r\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\r\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\r\n     * (eg. small fractions or percentages).\r\n     */\r\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\r\n        return _multiplyDecimalRound(x, y, UNIT);\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely dividing x and y. The return value is a high\r\n     * precision decimal.\r\n     *\r\n     * @dev y is divided after the product of x and the standard precision unit\r\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\r\n     * this is an integer division, the result is always rounded down.\r\n     * This helps save on gas. Rounding is more expensive on gas.\r\n     */\r\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\r\n        /* Reintroduce the UNIT factor that will be divided out by y. */\r\n        return x.mul(UNIT).div(y);\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely dividing x and y. The return value is as a rounded\r\n     * decimal in the precision unit specified in the parameter.\r\n     *\r\n     * @dev y is divided after the product of x and the specified precision unit\r\n     * is evaluated, so the product of x and the specified precision unit must\r\n     * be less than 2**256. The result is rounded to the nearest increment.\r\n     */\r\n    function _divideDecimalRound(\r\n        uint x,\r\n        uint y,\r\n        uint precisionUnit\r\n    ) private pure returns (uint) {\r\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\r\n\r\n        if (resultTimesTen % 10 >= 5) {\r\n            resultTimesTen += 10;\r\n        }\r\n\r\n        return resultTimesTen / 10;\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely dividing x and y. The return value is as a rounded\r\n     * standard precision decimal.\r\n     *\r\n     * @dev y is divided after the product of x and the standard precision unit\r\n     * is evaluated, so the product of x and the standard precision unit must\r\n     * be less than 2**256. The result is rounded to the nearest increment.\r\n     */\r\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\r\n        return _divideDecimalRound(x, y, UNIT);\r\n    }\r\n\r\n    /**\r\n     * @return The result of safely dividing x and y. The return value is as a rounded\r\n     * high precision decimal.\r\n     *\r\n     * @dev y is divided after the product of x and the high precision unit\r\n     * is evaluated, so the product of x and the high precision unit must\r\n     * be less than 2**256. The result is rounded to the nearest increment.\r\n     */\r\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\r\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\r\n    }\r\n\r\n    /**\r\n     * @dev Convert a standard decimal representation to a high precision one.\r\n     */\r\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\r\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\r\n    }\r\n\r\n    /**\r\n     * @dev Convert a high precision decimal to a standard decimal representation.\r\n     */\r\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\r\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\r\n\r\n        if (quotientTimesTen % 10 >= 5) {\r\n            quotientTimesTen += 10;\r\n        }\r\n\r\n        return quotientTimesTen / 10;\r\n    }\r\n\r\n    // Computes `a - b`, setting the value to 0 if b > a.\r\n    function floorsub(uint a, uint b) internal pure returns (uint) {\r\n        return b >= a ? 0 : a - b;\r\n    }\r\n\r\n    /* ---------- Utilities ---------- */\r\n    /*\r\n     * Absolute value of the input, returned as a signed number.\r\n     */\r\n    function signedAbs(int x) internal pure returns (int) {\r\n        return x < 0 ? -x : x;\r\n    }\r\n\r\n    /*\r\n     * Absolute value of the input, returned as an unsigned number.\r\n     */\r\n    function abs(int x) internal pure returns (uint) {\r\n        return uint(signedAbs(x));\r\n    }\r\n}\r\n\r\n\r\ninterface AggregatorInterface {\r\n  function latestAnswer() external view returns (int256);\r\n  function latestTimestamp() external view returns (uint256);\r\n  function latestRound() external view returns (uint256);\r\n  function getAnswer(uint256 roundId) external view returns (int256);\r\n  function getTimestamp(uint256 roundId) external view returns (uint256);\r\n\r\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\r\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\r\n}\r\n\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title The V2 & V3 Aggregator Interface\r\n * @notice Solidity V0.5 does not allow interfaces to inherit from other\r\n * interfaces so this contract is a combination of v0.5 AggregatorInterface.sol\r\n * and v0.5 AggregatorV3Interface.sol.\r\n */\r\ninterface AggregatorV2V3Interface {\r\n  //\r\n  // V2 Interface:\r\n  //\r\n  function latestAnswer() external view returns (int256);\r\n  function latestTimestamp() external view returns (uint256);\r\n  function latestRound() external view returns (uint256);\r\n  function getAnswer(uint256 roundId) external view returns (int256);\r\n  function getTimestamp(uint256 roundId) external view returns (uint256);\r\n\r\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\r\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\r\n\r\n  //\r\n  // V3 Interface:\r\n  //\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\n\r\ninterface FlagsInterface {\r\n  function getFlag(address) external view returns (bool);\r\n  function getFlags(address[] calldata) external view returns (bool[] memory);\r\n  function raiseFlag(address) external;\r\n  function raiseFlags(address[] calldata) external;\r\n  function lowerFlags(address[] calldata) external;\r\n  function setRaisingAccessController(address) external;\r\n}\r\n\r\n\r\ninterface IVirtualSynth {\r\n    // Views\r\n    function balanceOfUnderlying(address account) external view returns (uint);\r\n\r\n    function rate() external view returns (uint);\r\n\r\n    function readyToSettle() external view returns (bool);\r\n\r\n    function secsLeftInWaitingPeriod() external view returns (uint);\r\n\r\n    function settled() external view returns (bool);\r\n\r\n    function synth() external view returns (ISynth);\r\n\r\n    // Mutative functions\r\n    function settle(address account) external;\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/iexchanger\r\ninterface IExchanger {\r\n    // Views\r\n    function calculateAmountAfterSettlement(\r\n        address from,\r\n        bytes32 currencyKey,\r\n        uint amount,\r\n        uint refunded\r\n    ) external view returns (uint amountAfterSettlement);\r\n\r\n    function isSynthRateInvalid(bytes32 currencyKey) external view returns (bool);\r\n\r\n    function maxSecsLeftInWaitingPeriod(address account, bytes32 currencyKey) external view returns (uint);\r\n\r\n    function settlementOwing(address account, bytes32 currencyKey)\r\n        external\r\n        view\r\n        returns (\r\n            uint reclaimAmount,\r\n            uint rebateAmount,\r\n            uint numEntries\r\n        );\r\n\r\n    function hasWaitingPeriodOrSettlementOwing(address account, bytes32 currencyKey) external view returns (bool);\r\n\r\n    function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\r\n        external\r\n        view\r\n        returns (uint exchangeFeeRate);\r\n\r\n    function getAmountsForExchange(\r\n        uint sourceAmount,\r\n        bytes32 sourceCurrencyKey,\r\n        bytes32 destinationCurrencyKey\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint amountReceived,\r\n            uint fee,\r\n            uint exchangeFeeRate\r\n        );\r\n\r\n    function priceDeviationThresholdFactor() external view returns (uint);\r\n\r\n    function waitingPeriodSecs() external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function exchange(\r\n        address exchangeForAddress,\r\n        address from,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address destinationAddress,\r\n        bool virtualSynth,\r\n        address rewardAddress,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\r\n\r\n    function exchangeAtomically(\r\n        address from,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address destinationAddress,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived);\r\n\r\n    function settle(address from, bytes32 currencyKey)\r\n        external\r\n        returns (\r\n            uint reclaimed,\r\n            uint refunded,\r\n            uint numEntries\r\n        );\r\n\r\n    function resetLastExchangeRate(bytes32[] calldata currencyKeys) external;\r\n\r\n    function suspendSynthWithInvalidRate(bytes32 currencyKey) external;\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// Internal references\r\n// AggregatorInterface from Chainlink represents a decentralized pricing network for a single currency key\r\n\r\n// FlagsInterface from Chainlink addresses SIP-76\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/exchangerates\r\ncontract ExchangeRates is Owned, MixinSystemSettings, IExchangeRates {\r\n    using SafeMath for uint;\r\n    using SafeDecimalMath for uint;\r\n\r\n    bytes32 public constant CONTRACT_NAME = \"ExchangeRates\";\r\n\r\n    // Exchange rates and update times stored by currency code, e.g. 'SNX', or 'sUSD'\r\n    mapping(bytes32 => mapping(uint => RateAndUpdatedTime)) private _rates;\r\n\r\n    // The address of the oracle which pushes rate updates to this contract\r\n    address public oracle;\r\n\r\n    // Decentralized oracle networks that feed into pricing aggregators\r\n    mapping(bytes32 => AggregatorV2V3Interface) public aggregators;\r\n\r\n    mapping(bytes32 => uint8) public currencyKeyDecimals;\r\n\r\n    // List of aggregator keys for convenient iteration\r\n    bytes32[] public aggregatorKeys;\r\n\r\n    // Do not allow the oracle to submit times any further forward into the future than this constant.\r\n    uint private constant ORACLE_FUTURE_LIMIT = 10 minutes;\r\n\r\n    mapping(bytes32 => uint) public currentRoundForRate;\r\n\r\n    //\r\n    // ========== CONSTRUCTOR ==========\r\n\r\n    constructor(\r\n        address _owner,\r\n        address _oracle,\r\n        address _resolver,\r\n        bytes32[] memory _currencyKeys,\r\n        uint[] memory _newRates\r\n    ) public Owned(_owner) MixinSystemSettings(_resolver) {\r\n        require(_currencyKeys.length == _newRates.length, \"Currency key length and rate length must match.\");\r\n\r\n        oracle = _oracle;\r\n\r\n        // The sUSD rate is always 1 and is never stale.\r\n        _setRate(\"sUSD\", SafeDecimalMath.unit(), now);\r\n\r\n        internalUpdateRates(_currencyKeys, _newRates, now);\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    function setOracle(address _oracle) external onlyOwner {\r\n        oracle = _oracle;\r\n        emit OracleUpdated(oracle);\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    function updateRates(\r\n        bytes32[] calldata currencyKeys,\r\n        uint[] calldata newRates,\r\n        uint timeSent\r\n    ) external onlyOracle returns (bool) {\r\n        return internalUpdateRates(currencyKeys, newRates, timeSent);\r\n    }\r\n\r\n    function deleteRate(bytes32 currencyKey) external onlyOracle {\r\n        require(_getRate(currencyKey) > 0, \"Rate is zero\");\r\n\r\n        delete _rates[currencyKey][currentRoundForRate[currencyKey]];\r\n\r\n        currentRoundForRate[currencyKey]--;\r\n\r\n        emit RateDeleted(currencyKey);\r\n    }\r\n\r\n    function addAggregator(bytes32 currencyKey, address aggregatorAddress) external onlyOwner {\r\n        AggregatorV2V3Interface aggregator = AggregatorV2V3Interface(aggregatorAddress);\r\n        // This check tries to make sure that a valid aggregator is being added.\r\n        // It checks if the aggregator is an existing smart contract that has implemented `latestTimestamp` function.\r\n\r\n        require(aggregator.latestRound() >= 0, \"Given Aggregator is invalid\");\r\n        uint8 decimals = aggregator.decimals();\r\n        require(decimals <= 18, \"Aggregator decimals should be lower or equal to 18\");\r\n        if (address(aggregators[currencyKey]) == address(0)) {\r\n            aggregatorKeys.push(currencyKey);\r\n        }\r\n        aggregators[currencyKey] = aggregator;\r\n        currencyKeyDecimals[currencyKey] = decimals;\r\n        emit AggregatorAdded(currencyKey, address(aggregator));\r\n    }\r\n\r\n    function removeAggregator(bytes32 currencyKey) external onlyOwner {\r\n        address aggregator = address(aggregators[currencyKey]);\r\n        require(aggregator != address(0), \"No aggregator exists for key\");\r\n        delete aggregators[currencyKey];\r\n        delete currencyKeyDecimals[currencyKey];\r\n\r\n        bool wasRemoved = removeFromArray(currencyKey, aggregatorKeys);\r\n\r\n        if (wasRemoved) {\r\n            emit AggregatorRemoved(currencyKey, aggregator);\r\n        }\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory currencies) {\r\n        uint count = 0;\r\n        currencies = new bytes32[](aggregatorKeys.length);\r\n        for (uint i = 0; i < aggregatorKeys.length; i++) {\r\n            bytes32 currencyKey = aggregatorKeys[i];\r\n            if (address(aggregators[currencyKey]) == aggregator) {\r\n                currencies[count++] = currencyKey;\r\n            }\r\n        }\r\n    }\r\n\r\n    function rateStalePeriod() external view returns (uint) {\r\n        return getRateStalePeriod();\r\n    }\r\n\r\n    function aggregatorWarningFlags() external view returns (address) {\r\n        return getAggregatorWarningFlags();\r\n    }\r\n\r\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time) {\r\n        RateAndUpdatedTime memory rateAndTime = _getRateAndUpdatedTime(currencyKey);\r\n        return (rateAndTime.rate, rateAndTime.time);\r\n    }\r\n\r\n    function getLastRoundIdBeforeElapsedSecs(\r\n        bytes32 currencyKey,\r\n        uint startingRoundId,\r\n        uint startingTimestamp,\r\n        uint timediff\r\n    ) external view returns (uint) {\r\n        uint roundId = startingRoundId;\r\n        uint nextTimestamp = 0;\r\n        while (true) {\r\n            (, nextTimestamp) = _getRateAndTimestampAtRound(currencyKey, roundId + 1);\r\n            // if there's no new round, then the previous roundId was the latest\r\n            if (nextTimestamp == 0 || nextTimestamp > startingTimestamp + timediff) {\r\n                return roundId;\r\n            }\r\n            roundId++;\r\n        }\r\n        return roundId;\r\n    }\r\n\r\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint) {\r\n        return _getCurrentRoundId(currencyKey);\r\n    }\r\n\r\n    function effectiveValueAtRound(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        uint roundIdForSrc,\r\n        uint roundIdForDest\r\n    ) external view returns (uint value) {\r\n        // If there's no change in the currency, then just return the amount they gave us\r\n        if (sourceCurrencyKey == destinationCurrencyKey) return sourceAmount;\r\n\r\n        (uint srcRate, ) = _getRateAndTimestampAtRound(sourceCurrencyKey, roundIdForSrc);\r\n        (uint destRate, ) = _getRateAndTimestampAtRound(destinationCurrencyKey, roundIdForDest);\r\n        if (destRate == 0) {\r\n            // prevent divide-by 0 error (this can happen when roundIDs jump epochs due\r\n            // to aggregator upgrades)\r\n            return 0;\r\n        }\r\n        // Calculate the effective value by going from source -> USD -> destination\r\n        value = sourceAmount.multiplyDecimalRound(srcRate).divideDecimalRound(destRate);\r\n    }\r\n\r\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time) {\r\n        return _getRateAndTimestampAtRound(currencyKey, roundId);\r\n    }\r\n\r\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256) {\r\n        return _getUpdatedTime(currencyKey);\r\n    }\r\n\r\n    function lastRateUpdateTimesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory) {\r\n        uint[] memory lastUpdateTimes = new uint[](currencyKeys.length);\r\n\r\n        for (uint i = 0; i < currencyKeys.length; i++) {\r\n            lastUpdateTimes[i] = _getUpdatedTime(currencyKeys[i]);\r\n        }\r\n\r\n        return lastUpdateTimes;\r\n    }\r\n\r\n    function effectiveValue(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    ) external view returns (uint value) {\r\n        (value, , ) = _effectiveValueAndRates(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);\r\n    }\r\n\r\n    function effectiveValueAndRates(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint value,\r\n            uint sourceRate,\r\n            uint destinationRate\r\n        )\r\n    {\r\n        return _effectiveValueAndRates(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);\r\n    }\r\n\r\n    // SIP-120 Atomic exchanges\r\n    function effectiveAtomicValueAndRates(\r\n        bytes32,\r\n        uint,\r\n        bytes32\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint,\r\n            uint,\r\n            uint,\r\n            uint\r\n        )\r\n    {\r\n        _notImplemented();\r\n    }\r\n\r\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint) {\r\n        return _getRateAndUpdatedTime(currencyKey).rate;\r\n    }\r\n\r\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(bytes32 currencyKey, uint numRounds)\r\n        external\r\n        view\r\n        returns (uint[] memory rates, uint[] memory times)\r\n    {\r\n        rates = new uint[](numRounds);\r\n        times = new uint[](numRounds);\r\n\r\n        uint roundId = _getCurrentRoundId(currencyKey);\r\n        for (uint i = 0; i < numRounds; i++) {\r\n            // fetch the rate and treat is as current, so inverse limits if frozen will always be applied\r\n            // regardless of current rate\r\n            (rates[i], times[i]) = _getRateAndTimestampAtRound(currencyKey, roundId);\r\n\r\n            if (roundId == 0) {\r\n                // if we hit the last round, then return what we have\r\n                return (rates, times);\r\n            } else {\r\n                roundId--;\r\n            }\r\n        }\r\n    }\r\n\r\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory) {\r\n        uint[] memory _localRates = new uint[](currencyKeys.length);\r\n\r\n        for (uint i = 0; i < currencyKeys.length; i++) {\r\n            _localRates[i] = _getRate(currencyKeys[i]);\r\n        }\r\n\r\n        return _localRates;\r\n    }\r\n\r\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid) {\r\n        RateAndUpdatedTime memory rateAndTime = _getRateAndUpdatedTime(currencyKey);\r\n\r\n        if (currencyKey == \"sUSD\") {\r\n            return (rateAndTime.rate, false);\r\n        }\r\n        return (\r\n            rateAndTime.rate,\r\n            _rateIsStaleWithTime(getRateStalePeriod(), rateAndTime.time) ||\r\n                _rateIsFlagged(currencyKey, FlagsInterface(getAggregatorWarningFlags()))\r\n        );\r\n    }\r\n\r\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\r\n        external\r\n        view\r\n        returns (uint[] memory rates, bool anyRateInvalid)\r\n    {\r\n        rates = new uint[](currencyKeys.length);\r\n\r\n        uint256 _rateStalePeriod = getRateStalePeriod();\r\n\r\n        // fetch all flags at once\r\n        bool[] memory flagList = getFlagsForRates(currencyKeys);\r\n\r\n        for (uint i = 0; i < currencyKeys.length; i++) {\r\n            // do one lookup of the rate & time to minimize gas\r\n            RateAndUpdatedTime memory rateEntry = _getRateAndUpdatedTime(currencyKeys[i]);\r\n            rates[i] = rateEntry.rate;\r\n            if (!anyRateInvalid && currencyKeys[i] != \"sUSD\") {\r\n                anyRateInvalid = flagList[i] || _rateIsStaleWithTime(_rateStalePeriod, rateEntry.time);\r\n            }\r\n        }\r\n    }\r\n\r\n    function rateIsStale(bytes32 currencyKey) external view returns (bool) {\r\n        return _rateIsStale(currencyKey, getRateStalePeriod());\r\n    }\r\n\r\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool) {\r\n        return\r\n            _rateIsStale(currencyKey, getRateStalePeriod()) ||\r\n            _rateIsFlagged(currencyKey, FlagsInterface(getAggregatorWarningFlags()));\r\n    }\r\n\r\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool) {\r\n        return _rateIsFlagged(currencyKey, FlagsInterface(getAggregatorWarningFlags()));\r\n    }\r\n\r\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool) {\r\n        // Loop through each key and check whether the data point is stale.\r\n\r\n        uint256 _rateStalePeriod = getRateStalePeriod();\r\n        bool[] memory flagList = getFlagsForRates(currencyKeys);\r\n\r\n        for (uint i = 0; i < currencyKeys.length; i++) {\r\n            if (flagList[i] || _rateIsStale(currencyKeys[i], _rateStalePeriod)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function synthTooVolatileForAtomicExchange(bytes32) external view returns (bool) {\r\n        _notImplemented();\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    function getFlagsForRates(bytes32[] memory currencyKeys) internal view returns (bool[] memory flagList) {\r\n        FlagsInterface _flags = FlagsInterface(getAggregatorWarningFlags());\r\n\r\n        // fetch all flags at once\r\n        if (_flags != FlagsInterface(0)) {\r\n            address[] memory _aggregators = new address[](currencyKeys.length);\r\n\r\n            for (uint i = 0; i < currencyKeys.length; i++) {\r\n                _aggregators[i] = address(aggregators[currencyKeys[i]]);\r\n            }\r\n\r\n            flagList = _flags.getFlags(_aggregators);\r\n        } else {\r\n            flagList = new bool[](currencyKeys.length);\r\n        }\r\n    }\r\n\r\n    function _setRate(\r\n        bytes32 currencyKey,\r\n        uint256 rate,\r\n        uint256 time\r\n    ) internal {\r\n        // Note: this will effectively start the rounds at 1, which matches Chainlink's Agggregators\r\n        currentRoundForRate[currencyKey]++;\r\n\r\n        _rates[currencyKey][currentRoundForRate[currencyKey]] = RateAndUpdatedTime({\r\n            rate: uint216(rate),\r\n            time: uint40(time)\r\n        });\r\n    }\r\n\r\n    function internalUpdateRates(\r\n        bytes32[] memory currencyKeys,\r\n        uint[] memory newRates,\r\n        uint timeSent\r\n    ) internal returns (bool) {\r\n        require(currencyKeys.length == newRates.length, \"Currency key array length must match rates array length.\");\r\n        require(timeSent < (now + ORACLE_FUTURE_LIMIT), \"Time is too far into the future\");\r\n\r\n        // Loop through each key and perform update.\r\n        for (uint i = 0; i < currencyKeys.length; i++) {\r\n            bytes32 currencyKey = currencyKeys[i];\r\n\r\n            // Should not set any rate to zero ever, as no asset will ever be\r\n            // truely worthless and still valid. In this scenario, we should\r\n            // delete the rate and remove it from the system.\r\n            require(newRates[i] != 0, \"Zero is not a valid rate, please call deleteRate instead.\");\r\n            require(currencyKey != \"sUSD\", \"Rate of sUSD cannot be updated, it's always UNIT.\");\r\n\r\n            // We should only update the rate if it's at least the same age as the last rate we've got.\r\n            if (timeSent < _getUpdatedTime(currencyKey)) {\r\n                continue;\r\n            }\r\n\r\n            // Ok, go ahead with the update.\r\n            _setRate(currencyKey, newRates[i], timeSent);\r\n        }\r\n\r\n        emit RatesUpdated(currencyKeys, newRates);\r\n\r\n        return true;\r\n    }\r\n\r\n    function removeFromArray(bytes32 entry, bytes32[] storage array) internal returns (bool) {\r\n        for (uint i = 0; i < array.length; i++) {\r\n            if (array[i] == entry) {\r\n                delete array[i];\r\n\r\n                // Copy the last key into the place of the one we just deleted\r\n                // If there's only one key, this is array[0] = array[0].\r\n                // If we're deleting the last one, it's also a NOOP in the same way.\r\n                array[i] = array[array.length - 1];\r\n\r\n                // Decrease the size of the array by one.\r\n                array.length--;\r\n\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _formatAggregatorAnswer(bytes32 currencyKey, int256 rate) internal view returns (uint) {\r\n        require(rate >= 0, \"Negative rate not supported\");\r\n        if (currencyKeyDecimals[currencyKey] > 0) {\r\n            uint multiplier = 10**uint(SafeMath.sub(18, currencyKeyDecimals[currencyKey]));\r\n            return uint(uint(rate).mul(multiplier));\r\n        }\r\n        return uint(rate);\r\n    }\r\n\r\n    function _getRateAndUpdatedTime(bytes32 currencyKey) internal view returns (RateAndUpdatedTime memory) {\r\n        AggregatorV2V3Interface aggregator = aggregators[currencyKey];\r\n\r\n        if (aggregator != AggregatorV2V3Interface(0)) {\r\n            // this view from the aggregator is the most gas efficient but it can throw when there's no data,\r\n            // so let's call it low-level to suppress any reverts\r\n            bytes memory payload = abi.encodeWithSignature(\"latestRoundData()\");\r\n            // solhint-disable avoid-low-level-calls\r\n            (bool success, bytes memory returnData) = address(aggregator).staticcall(payload);\r\n\r\n            if (success) {\r\n                (, int256 answer, , uint256 updatedAt, ) =\r\n                    abi.decode(returnData, (uint80, int256, uint256, uint256, uint80));\r\n                return\r\n                    RateAndUpdatedTime({\r\n                        rate: uint216(_formatAggregatorAnswer(currencyKey, answer)),\r\n                        time: uint40(updatedAt)\r\n                    });\r\n            }\r\n        } else {\r\n            uint roundId = currentRoundForRate[currencyKey];\r\n            RateAndUpdatedTime memory entry = _rates[currencyKey][roundId];\r\n\r\n            return RateAndUpdatedTime({rate: uint216(entry.rate), time: entry.time});\r\n        }\r\n    }\r\n\r\n    function _getCurrentRoundId(bytes32 currencyKey) internal view returns (uint) {\r\n        AggregatorV2V3Interface aggregator = aggregators[currencyKey];\r\n\r\n        if (aggregator != AggregatorV2V3Interface(0)) {\r\n            return aggregator.latestRound();\r\n        } else {\r\n            return currentRoundForRate[currencyKey];\r\n        }\r\n    }\r\n\r\n    function _getRateAndTimestampAtRound(bytes32 currencyKey, uint roundId) internal view returns (uint rate, uint time) {\r\n        AggregatorV2V3Interface aggregator = aggregators[currencyKey];\r\n\r\n        if (aggregator != AggregatorV2V3Interface(0)) {\r\n            // this view from the aggregator is the most gas efficient but it can throw when there's no data,\r\n            // so let's call it low-level to suppress any reverts\r\n            bytes memory payload = abi.encodeWithSignature(\"getRoundData(uint80)\", roundId);\r\n            // solhint-disable avoid-low-level-calls\r\n            (bool success, bytes memory returnData) = address(aggregator).staticcall(payload);\r\n\r\n            if (success) {\r\n                (, int256 answer, , uint256 updatedAt, ) =\r\n                    abi.decode(returnData, (uint80, int256, uint256, uint256, uint80));\r\n                return (_formatAggregatorAnswer(currencyKey, answer), updatedAt);\r\n            }\r\n        } else {\r\n            RateAndUpdatedTime memory update = _rates[currencyKey][roundId];\r\n            return (update.rate, update.time);\r\n        }\r\n    }\r\n\r\n    function _getRate(bytes32 currencyKey) internal view returns (uint256) {\r\n        return _getRateAndUpdatedTime(currencyKey).rate;\r\n    }\r\n\r\n    function _getUpdatedTime(bytes32 currencyKey) internal view returns (uint256) {\r\n        return _getRateAndUpdatedTime(currencyKey).time;\r\n    }\r\n\r\n    function _effectiveValueAndRates(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint value,\r\n            uint sourceRate,\r\n            uint destinationRate\r\n        )\r\n    {\r\n        sourceRate = _getRate(sourceCurrencyKey);\r\n        // If there's no change in the currency, then just return the amount they gave us\r\n        if (sourceCurrencyKey == destinationCurrencyKey) {\r\n            destinationRate = sourceRate;\r\n            value = sourceAmount;\r\n        } else {\r\n            // Calculate the effective value by going from source -> USD -> destination\r\n            destinationRate = _getRate(destinationCurrencyKey);\r\n            // prevent divide-by 0 error (this happens if the dest is not a valid rate)\r\n            if (destinationRate > 0) {\r\n                value = sourceAmount.multiplyDecimalRound(sourceRate).divideDecimalRound(destinationRate);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _rateIsStale(bytes32 currencyKey, uint _rateStalePeriod) internal view returns (bool) {\r\n        // sUSD is a special case and is never stale (check before an SLOAD of getRateAndUpdatedTime)\r\n        if (currencyKey == \"sUSD\") return false;\r\n\r\n        return _rateIsStaleWithTime(_rateStalePeriod, _getUpdatedTime(currencyKey));\r\n    }\r\n\r\n    function _rateIsStaleWithTime(uint _rateStalePeriod, uint _time) internal view returns (bool) {\r\n        return _time.add(_rateStalePeriod) < now;\r\n    }\r\n\r\n    function _rateIsFlagged(bytes32 currencyKey, FlagsInterface flags) internal view returns (bool) {\r\n        // sUSD is a special case and is never invalid\r\n        if (currencyKey == \"sUSD\") return false;\r\n        address aggregator = address(aggregators[currencyKey]);\r\n        // when no aggregator or when the flags haven't been setup\r\n        if (aggregator == address(0) || flags == FlagsInterface(0)) {\r\n            return false;\r\n        }\r\n        return flags.getFlag(aggregator);\r\n    }\r\n\r\n    function _notImplemented() internal pure {\r\n        revert(\"Cannot be run on this layer\");\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyOracle {\r\n        _onlyOracle();\r\n        _;\r\n    }\r\n\r\n    function _onlyOracle() internal view {\r\n        require(msg.sender == oracle, \"Only the oracle can perform this action\");\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event OracleUpdated(address newOracle);\r\n    event RatesUpdated(bytes32[] currencyKeys, uint[] newRates);\r\n    event RateDeleted(bytes32 currencyKey);\r\n    event AggregatorAdded(bytes32 currencyKey, address aggregator);\r\n    event AggregatorRemoved(bytes32 currencyKey, address aggregator);\r\n}\r\n\r\n\r\n// https://sips.synthetix.io/sips/sip-120/\r\n// Uniswap V3 based DecPriceAggregator (unaudited) e.g. https://etherscan.io/address/0xf120f029ac143633d1942e48ae2dfa2036c5786c#code\r\n// https://github.com/sohkai/uniswap-v3-spot-twap-oracle\r\n//  inteface: https://github.com/sohkai/uniswap-v3-spot-twap-oracle/blob/8f9777a6160a089c99f39f2ee297119ee293bc4b/contracts/interfaces/IDexPriceAggregator.sol\r\n//  implementation: https://github.com/sohkai/uniswap-v3-spot-twap-oracle/blob/8f9777a6160a089c99f39f2ee297119ee293bc4b/contracts/DexPriceAggregatorUniswapV3.sol\r\ninterface IDexPriceAggregator {\r\n    function assetToAsset(\r\n        address tokenIn,\r\n        uint amountIn,\r\n        address tokenOut,\r\n        uint twapPeriod\r\n    ) external view returns (uint amountOut);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/exchangerateswithdexpricing\r\ncontract ExchangeRatesWithDexPricing is ExchangeRates {\r\n    bytes32 public constant CONTRACT_NAME = \"ExchangeRatesWithDexPricing\";\r\n\r\n    bytes32 internal constant SETTING_DEX_PRICE_AGGREGATOR = \"dexPriceAggregator\";\r\n\r\n    constructor(\r\n        address _owner,\r\n        address _oracle,\r\n        address _resolver,\r\n        bytes32[] memory _currencyKeys,\r\n        uint[] memory _newRates\r\n    ) public ExchangeRates(_owner, _oracle, _resolver, _currencyKeys, _newRates) {}\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    function setDexPriceAggregator(IDexPriceAggregator _dexPriceAggregator) external onlyOwner {\r\n        flexibleStorage().setAddressValue(\r\n            ExchangeRates.CONTRACT_NAME,\r\n            SETTING_DEX_PRICE_AGGREGATOR,\r\n            address(_dexPriceAggregator)\r\n        );\r\n        emit DexPriceAggregatorUpdated(address(_dexPriceAggregator));\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function dexPriceAggregator() public view returns (IDexPriceAggregator) {\r\n        return\r\n            IDexPriceAggregator(\r\n                flexibleStorage().getAddressValue(ExchangeRates.CONTRACT_NAME, SETTING_DEX_PRICE_AGGREGATOR)\r\n            );\r\n    }\r\n\r\n    function atomicTwapWindow() external view returns (uint) {\r\n        return getAtomicTwapWindow();\r\n    }\r\n\r\n    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {\r\n        return getAtomicEquivalentForDexPricing(currencyKey);\r\n    }\r\n\r\n    function atomicPriceBuffer(bytes32 currencyKey) external view returns (uint) {\r\n        return getAtomicPriceBuffer(currencyKey);\r\n    }\r\n\r\n    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {\r\n        return getAtomicVolatilityConsiderationWindow(currencyKey);\r\n    }\r\n\r\n    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {\r\n        return getAtomicVolatilityUpdateThreshold(currencyKey);\r\n    }\r\n\r\n    // SIP-120 Atomic exchanges\r\n    // Note that the returned systemValue, systemSourceRate, and systemDestinationRate are based on\r\n    // the current system rate, which may not be the atomic rate derived from value / sourceAmount\r\n    function effectiveAtomicValueAndRates(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint value,\r\n            uint systemValue,\r\n            uint systemSourceRate,\r\n            uint systemDestinationRate\r\n        )\r\n    {\r\n        IERC20 sourceEquivalent = IERC20(getAtomicEquivalentForDexPricing(sourceCurrencyKey));\r\n        require(address(sourceEquivalent) != address(0), \"No atomic equivalent for src\");\r\n\r\n        IERC20 destEquivalent = IERC20(getAtomicEquivalentForDexPricing(destinationCurrencyKey));\r\n        require(address(destEquivalent) != address(0), \"No atomic equivalent for dest\");\r\n\r\n        (systemValue, systemSourceRate, systemDestinationRate) = _effectiveValueAndRates(\r\n            sourceCurrencyKey,\r\n            sourceAmount,\r\n            destinationCurrencyKey\r\n        );\r\n        // Derive P_CLBUF from highest configured buffer between source and destination synth\r\n        uint sourceBuffer = getAtomicPriceBuffer(sourceCurrencyKey);\r\n        uint destBuffer = getAtomicPriceBuffer(destinationCurrencyKey);\r\n        uint priceBuffer = sourceBuffer > destBuffer ? sourceBuffer : destBuffer; // max\r\n        uint pClbufValue = systemValue.multiplyDecimal(SafeDecimalMath.unit().sub(priceBuffer));\r\n\r\n        // refactired due to stack too deep\r\n        uint pDexValue = _dexPriceDestinationValue(sourceEquivalent, destEquivalent, sourceAmount);\r\n\r\n        // Final value is minimum output between P_CLBUF and P_TWAP\r\n        value = pClbufValue < pDexValue ? pClbufValue : pDexValue; // min\r\n    }\r\n\r\n    function _dexPriceDestinationValue(\r\n        IERC20 sourceEquivalent,\r\n        IERC20 destEquivalent,\r\n        uint sourceAmount\r\n    ) internal view returns (uint) {\r\n        // Normalize decimals in case equivalent asset uses different decimals from internal unit\r\n        uint sourceAmountInEquivalent =\r\n            (sourceAmount.mul(10**uint(sourceEquivalent.decimals()))).div(SafeDecimalMath.unit());\r\n\r\n        uint twapWindow = getAtomicTwapWindow();\r\n        require(twapWindow != 0, \"Uninitialized atomic twap window\");\r\n\r\n        uint twapValueInEquivalent =\r\n            dexPriceAggregator().assetToAsset(\r\n                address(sourceEquivalent),\r\n                sourceAmountInEquivalent,\r\n                address(destEquivalent),\r\n                twapWindow\r\n            );\r\n        require(twapValueInEquivalent > 0, \"dex price returned 0\");\r\n\r\n        // Similar to source amount, normalize decimals back to internal unit for output amount\r\n        return (twapValueInEquivalent.mul(SafeDecimalMath.unit())).div(10**uint(destEquivalent.decimals()));\r\n    }\r\n\r\n    function synthTooVolatileForAtomicExchange(bytes32 currencyKey) external view returns (bool) {\r\n        // sUSD is a special case and is never volatile\r\n        if (currencyKey == \"sUSD\") return false;\r\n\r\n        uint considerationWindow = getAtomicVolatilityConsiderationWindow(currencyKey);\r\n        uint updateThreshold = getAtomicVolatilityUpdateThreshold(currencyKey);\r\n\r\n        if (considerationWindow == 0 || updateThreshold == 0) {\r\n            // If either volatility setting is not set, never judge an asset to be volatile\r\n            return false;\r\n        }\r\n\r\n        // Go back through the historical oracle update rounds to see if there have been more\r\n        // updates in the consideration window than the allowed threshold.\r\n        // If there have, consider the asset volatile--by assumption that many close-by oracle\r\n        // updates is a good proxy for price volatility.\r\n        uint considerationWindowStart = block.timestamp.sub(considerationWindow);\r\n        uint roundId = _getCurrentRoundId(currencyKey);\r\n        for (updateThreshold; updateThreshold > 0; updateThreshold--) {\r\n            (uint rate, uint time) = _getRateAndTimestampAtRound(currencyKey, roundId);\r\n            if (time != 0 && time < considerationWindowStart) {\r\n                // Round was outside consideration window so we can stop querying further rounds\r\n                return false;\r\n            } else if (rate == 0 || time == 0) {\r\n                // Either entire round or a rate inside consideration window was not available\r\n                // Consider the asset volatile\r\n                break;\r\n            }\r\n\r\n            if (roundId == 0) {\r\n                // Not enough historical data to continue further\r\n                // Consider the asset volatile\r\n                break;\r\n            }\r\n            roundId--;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event DexPriceAggregatorUpdated(address newDexPriceAggregator);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/state\r\ncontract State is Owned {\r\n    // the address of the contract that can modify variables\r\n    // this can only be changed by the owner of this contract\r\n    address public associatedContract;\r\n\r\n    constructor(address _associatedContract) internal {\r\n        // This contract is abstract, and thus cannot be instantiated directly\r\n        require(owner != address(0), \"Owner must be set\");\r\n\r\n        associatedContract = _associatedContract;\r\n        emit AssociatedContractUpdated(_associatedContract);\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    // Change the associated contract to a new address\r\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\r\n        associatedContract = _associatedContract;\r\n        emit AssociatedContractUpdated(_associatedContract);\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyAssociatedContract {\r\n        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event AssociatedContractUpdated(address associatedContract);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangestate\r\ninterface IExchangeState {\r\n    // Views\r\n    struct ExchangeEntry {\r\n        bytes32 src;\r\n        uint amount;\r\n        bytes32 dest;\r\n        uint amountReceived;\r\n        uint exchangeFeeRate;\r\n        uint timestamp;\r\n        uint roundIdForSrc;\r\n        uint roundIdForDest;\r\n    }\r\n\r\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint);\r\n\r\n    function getEntryAt(\r\n        address account,\r\n        bytes32 currencyKey,\r\n        uint index\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 src,\r\n            uint amount,\r\n            bytes32 dest,\r\n            uint amountReceived,\r\n            uint exchangeFeeRate,\r\n            uint timestamp,\r\n            uint roundIdForSrc,\r\n            uint roundIdForDest\r\n        );\r\n\r\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function appendExchangeEntry(\r\n        address account,\r\n        bytes32 src,\r\n        uint amount,\r\n        bytes32 dest,\r\n        uint amountReceived,\r\n        uint exchangeFeeRate,\r\n        uint timestamp,\r\n        uint roundIdForSrc,\r\n        uint roundIdForDest\r\n    ) external;\r\n\r\n    function removeEntries(address account, bytes32 currencyKey) external;\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/exchangestate\r\ncontract ExchangeState is Owned, State, IExchangeState {\r\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\r\n\r\n    uint public maxEntriesInQueue = 12;\r\n\r\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\r\n        maxEntriesInQueue = _maxEntriesInQueue;\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    function appendExchangeEntry(\r\n        address account,\r\n        bytes32 src,\r\n        uint amount,\r\n        bytes32 dest,\r\n        uint amountReceived,\r\n        uint exchangeFeeRate,\r\n        uint timestamp,\r\n        uint roundIdForSrc,\r\n        uint roundIdForDest\r\n    ) external onlyAssociatedContract {\r\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\r\n\r\n        exchanges[account][dest].push(\r\n            ExchangeEntry({\r\n                src: src,\r\n                amount: amount,\r\n                dest: dest,\r\n                amountReceived: amountReceived,\r\n                exchangeFeeRate: exchangeFeeRate,\r\n                timestamp: timestamp,\r\n                roundIdForSrc: roundIdForSrc,\r\n                roundIdForDest: roundIdForDest\r\n            })\r\n        );\r\n    }\r\n\r\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\r\n        delete exchanges[account][currencyKey];\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\r\n        return exchanges[account][currencyKey].length;\r\n    }\r\n\r\n    function getEntryAt(\r\n        address account,\r\n        bytes32 currencyKey,\r\n        uint index\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            bytes32 src,\r\n            uint amount,\r\n            bytes32 dest,\r\n            uint amountReceived,\r\n            uint exchangeFeeRate,\r\n            uint timestamp,\r\n            uint roundIdForSrc,\r\n            uint roundIdForDest\r\n        )\r\n    {\r\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\r\n        return (\r\n            entry.src,\r\n            entry.amount,\r\n            entry.dest,\r\n            entry.amountReceived,\r\n            entry.exchangeFeeRate,\r\n            entry.timestamp,\r\n            entry.roundIdForSrc,\r\n            entry.roundIdForDest\r\n        );\r\n    }\r\n\r\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\r\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\r\n        uint timestamp = 0;\r\n        for (uint i = 0; i < userEntries.length; i++) {\r\n            if (userEntries[i].timestamp > timestamp) {\r\n                timestamp = userEntries[i].timestamp;\r\n            }\r\n        }\r\n        return timestamp;\r\n    }\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/proxy\r\ncontract Proxy is Owned {\r\n    Proxyable public target;\r\n\r\n    constructor(address _owner) public Owned(_owner) {}\r\n\r\n    function setTarget(Proxyable _target) external onlyOwner {\r\n        target = _target;\r\n        emit TargetUpdated(_target);\r\n    }\r\n\r\n    function _emit(\r\n        bytes calldata callData,\r\n        uint numTopics,\r\n        bytes32 topic1,\r\n        bytes32 topic2,\r\n        bytes32 topic3,\r\n        bytes32 topic4\r\n    ) external onlyTarget {\r\n        uint size = callData.length;\r\n        bytes memory _callData = callData;\r\n\r\n        assembly {\r\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\r\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\r\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\r\n             * This means moving call_data across 32 bytes guarantees we correctly access\r\n             * the data itself. */\r\n            switch numTopics\r\n                case 0 {\r\n                    log0(add(_callData, 32), size)\r\n                }\r\n                case 1 {\r\n                    log1(add(_callData, 32), size, topic1)\r\n                }\r\n                case 2 {\r\n                    log2(add(_callData, 32), size, topic1, topic2)\r\n                }\r\n                case 3 {\r\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\r\n                }\r\n                case 4 {\r\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\r\n                }\r\n        }\r\n    }\r\n\r\n    // solhint-disable no-complex-fallback\r\n    function() external payable {\r\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\r\n        target.setMessageSender(msg.sender);\r\n\r\n        assembly {\r\n            let free_ptr := mload(0x40)\r\n            calldatacopy(free_ptr, 0, calldatasize)\r\n\r\n            /* We must explicitly forward ether to the underlying contract as well. */\r\n            let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\r\n            returndatacopy(free_ptr, 0, returndatasize)\r\n\r\n            if iszero(result) {\r\n                revert(free_ptr, returndatasize)\r\n            }\r\n            return(free_ptr, returndatasize)\r\n        }\r\n    }\r\n\r\n    modifier onlyTarget {\r\n        require(Proxyable(msg.sender) == target, \"Must be proxy target\");\r\n        _;\r\n    }\r\n\r\n    event TargetUpdated(Proxyable newTarget);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/proxyable\r\ncontract Proxyable is Owned {\r\n    // This contract should be treated like an abstract contract\r\n\r\n    /* The proxy this contract exists behind. */\r\n    Proxy public proxy;\r\n\r\n    /* The caller of the proxy, passed through to this contract.\r\n     * Note that every function using this member must apply the onlyProxy or\r\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\r\n    address public messageSender;\r\n\r\n    constructor(address payable _proxy) internal {\r\n        // This contract is abstract, and thus cannot be instantiated directly\r\n        require(owner != address(0), \"Owner must be set\");\r\n\r\n        proxy = Proxy(_proxy);\r\n        emit ProxyUpdated(_proxy);\r\n    }\r\n\r\n    function setProxy(address payable _proxy) external onlyOwner {\r\n        proxy = Proxy(_proxy);\r\n        emit ProxyUpdated(_proxy);\r\n    }\r\n\r\n    function setMessageSender(address sender) external onlyProxy {\r\n        messageSender = sender;\r\n    }\r\n\r\n    modifier onlyProxy {\r\n        _onlyProxy();\r\n        _;\r\n    }\r\n\r\n    function _onlyProxy() private view {\r\n        require(Proxy(msg.sender) == proxy, \"Only the proxy can call\");\r\n    }\r\n\r\n    modifier optionalProxy {\r\n        _optionalProxy();\r\n        _;\r\n    }\r\n\r\n    function _optionalProxy() private {\r\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\r\n            messageSender = msg.sender;\r\n        }\r\n    }\r\n\r\n    modifier optionalProxy_onlyOwner {\r\n        _optionalProxy_onlyOwner();\r\n        _;\r\n    }\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function _optionalProxy_onlyOwner() private {\r\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\r\n            messageSender = msg.sender;\r\n        }\r\n        require(messageSender == owner, \"Owner only function\");\r\n    }\r\n\r\n    event ProxyUpdated(address proxyAddress);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/limitedsetup\r\ncontract LimitedSetup {\r\n    uint public setupExpiryTime;\r\n\r\n    /**\r\n     * @dev LimitedSetup Constructor.\r\n     * @param setupDuration The time the setup period will last for.\r\n     */\r\n    constructor(uint setupDuration) internal {\r\n        setupExpiryTime = now + setupDuration;\r\n    }\r\n\r\n    modifier onlyDuringSetup {\r\n        require(now < setupExpiryTime, \"Can only perform this action during setup\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/ifeepool\r\ninterface IFeePool {\r\n    // Views\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function FEE_ADDRESS() external view returns (address);\r\n\r\n    function feesAvailable(address account) external view returns (uint, uint);\r\n\r\n    function feePeriodDuration() external view returns (uint);\r\n\r\n    function isFeesClaimable(address account) external view returns (bool);\r\n\r\n    function targetThreshold() external view returns (uint);\r\n\r\n    function totalFeesAvailable() external view returns (uint);\r\n\r\n    function totalRewardsAvailable() external view returns (uint);\r\n\r\n    // Mutative Functions\r\n    function claimFees() external returns (bool);\r\n\r\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\r\n\r\n    function closeCurrentFeePeriod() external;\r\n\r\n    // Restricted: used internally to Synthetix\r\n    function appendAccountIssuanceRecord(\r\n        address account,\r\n        uint lockedAmount,\r\n        uint debtEntryIndex\r\n    ) external;\r\n\r\n    function recordFeePaid(uint sUSDAmount) external;\r\n\r\n    function setRewardsToDistribute(uint amount) external;\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/isystemstatus\r\ninterface ISystemStatus {\r\n    struct Status {\r\n        bool canSuspend;\r\n        bool canResume;\r\n    }\r\n\r\n    struct Suspension {\r\n        bool suspended;\r\n        // reason is an integer code,\r\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\r\n        uint248 reason;\r\n    }\r\n\r\n    // Views\r\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\r\n\r\n    function requireSystemActive() external view;\r\n\r\n    function requireIssuanceActive() external view;\r\n\r\n    function requireExchangeActive() external view;\r\n\r\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\r\n\r\n    function requireSynthActive(bytes32 currencyKey) external view;\r\n\r\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\r\n\r\n    function systemSuspension() external view returns (bool suspended, uint248 reason);\r\n\r\n    function issuanceSuspension() external view returns (bool suspended, uint248 reason);\r\n\r\n    function exchangeSuspension() external view returns (bool suspended, uint248 reason);\r\n\r\n    function synthExchangeSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\r\n\r\n    function synthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\r\n\r\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\r\n        external\r\n        view\r\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons);\r\n\r\n    function getSynthSuspensions(bytes32[] calldata synths)\r\n        external\r\n        view\r\n        returns (bool[] memory suspensions, uint256[] memory reasons);\r\n\r\n    // Restricted functions\r\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external;\r\n\r\n    function updateAccessControl(\r\n        bytes32 section,\r\n        address account,\r\n        bool canSuspend,\r\n        bool canResume\r\n    ) external;\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetix\r\ninterface ISynthetix {\r\n    // Views\r\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\r\n\r\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\r\n\r\n    function availableSynthCount() external view returns (uint);\r\n\r\n    function availableSynths(uint index) external view returns (ISynth);\r\n\r\n    function collateral(address account) external view returns (uint);\r\n\r\n    function collateralisationRatio(address issuer) external view returns (uint);\r\n\r\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\r\n\r\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\r\n\r\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\r\n\r\n    function remainingIssuableSynths(address issuer)\r\n        external\r\n        view\r\n        returns (\r\n            uint maxIssuable,\r\n            uint alreadyIssued,\r\n            uint totalSystemDebt\r\n        );\r\n\r\n    function synths(bytes32 currencyKey) external view returns (ISynth);\r\n\r\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\r\n\r\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);\r\n\r\n    function totalIssuedSynthsExcludeOtherCollateral(bytes32 currencyKey) external view returns (uint);\r\n\r\n    function transferableSynthetix(address account) external view returns (uint transferable);\r\n\r\n    // Mutative Functions\r\n    function burnSynths(uint amount) external;\r\n\r\n    function burnSynthsOnBehalf(address burnForAddress, uint amount) external;\r\n\r\n    function burnSynthsToTarget() external;\r\n\r\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\r\n\r\n    function exchange(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeOnBehalf(\r\n        address exchangeForAddress,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeWithTracking(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address rewardAddress,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeWithTrackingForInitiator(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address rewardAddress,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeOnBehalfWithTracking(\r\n        address exchangeForAddress,\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        address rewardAddress,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived);\r\n\r\n    function exchangeWithVirtual(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\r\n\r\n    function exchangeAtomically(\r\n        bytes32 sourceCurrencyKey,\r\n        uint sourceAmount,\r\n        bytes32 destinationCurrencyKey,\r\n        bytes32 trackingCode\r\n    ) external returns (uint amountReceived);\r\n\r\n    function issueMaxSynths() external;\r\n\r\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\r\n\r\n    function issueSynths(uint amount) external;\r\n\r\n    function issueSynthsOnBehalf(address issueForAddress, uint amount) external;\r\n\r\n    function mint() external returns (bool);\r\n\r\n    function settle(bytes32 currencyKey)\r\n        external\r\n        returns (\r\n            uint reclaimed,\r\n            uint refunded,\r\n            uint numEntries\r\n        );\r\n\r\n    // Liquidations\r\n    function liquidateDelinquentAccount(address account, uint susdAmount) external returns (bool);\r\n\r\n    // Restricted Functions\r\n\r\n    function mintSecondary(address account, uint amount) external;\r\n\r\n    function mintSecondaryRewards(uint amount) external;\r\n\r\n    function burnSecondary(address account, uint amount) external;\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/feepoolstate\r\ncontract FeePoolState is Owned, LimitedSetup {\r\n    using SafeMath for uint;\r\n    using SafeDecimalMath for uint;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    uint8 public constant FEE_PERIOD_LENGTH = 6;\r\n\r\n    address public feePool;\r\n\r\n    // The IssuanceData activity that's happened in a fee period.\r\n    struct IssuanceData {\r\n        uint debtPercentage;\r\n        uint debtEntryIndex;\r\n    }\r\n\r\n    // The IssuanceData activity that's happened in a fee period.\r\n    mapping(address => IssuanceData[FEE_PERIOD_LENGTH]) public accountIssuanceLedger;\r\n\r\n    constructor(address _owner, IFeePool _feePool) public Owned(_owner) LimitedSetup(6 weeks) {\r\n        feePool = address(_feePool);\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    /**\r\n     * @notice set the FeePool contract as it is the only authority to be able to call\r\n     * appendAccountIssuanceRecord with the onlyFeePool modifer\r\n     * @dev Must be set by owner when FeePool logic is upgraded\r\n     */\r\n    function setFeePool(IFeePool _feePool) external onlyOwner {\r\n        feePool = address(_feePool);\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    /**\r\n     * @notice Get an accounts issuanceData for\r\n     * @param account users account\r\n     * @param index Index in the array to retrieve. Upto FEE_PERIOD_LENGTH\r\n     */\r\n    function getAccountsDebtEntry(address account, uint index)\r\n        public\r\n        view\r\n        returns (uint debtPercentage, uint debtEntryIndex)\r\n    {\r\n        require(index < FEE_PERIOD_LENGTH, \"index exceeds the FEE_PERIOD_LENGTH\");\r\n\r\n        debtPercentage = accountIssuanceLedger[account][index].debtPercentage;\r\n        debtEntryIndex = accountIssuanceLedger[account][index].debtEntryIndex;\r\n    }\r\n\r\n    /**\r\n     * @notice Find the oldest debtEntryIndex for the corresponding closingDebtIndex\r\n     * @param account users account\r\n     * @param closingDebtIndex the last periods debt index on close\r\n     */\r\n    function applicableIssuanceData(address account, uint closingDebtIndex) external view returns (uint, uint) {\r\n        IssuanceData[FEE_PERIOD_LENGTH] memory issuanceData = accountIssuanceLedger[account];\r\n\r\n        // We want to use the user's debtEntryIndex at when the period closed\r\n        // Find the oldest debtEntryIndex for the corresponding closingDebtIndex\r\n        for (uint i = 0; i < FEE_PERIOD_LENGTH; i++) {\r\n            if (closingDebtIndex >= issuanceData[i].debtEntryIndex) {\r\n                return (issuanceData[i].debtPercentage, issuanceData[i].debtEntryIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Logs an accounts issuance data in the current fee period which is then stored historically\r\n     * @param account Message.Senders account address\r\n     * @param debtRatio Debt of this account as a percentage of the global debt.\r\n     * @param debtEntryIndex The index in the global debt ledger. synthetix.synthetixState().issuanceData(account)\r\n     * @param currentPeriodStartDebtIndex The startingDebtIndex of the current fee period\r\n     * @dev onlyFeePool to call me on synthetix.issue() & synthetix.burn() calls to store the locked SNX\r\n     * per fee period so we know to allocate the correct proportions of fees and rewards per period\r\n      accountIssuanceLedger[account][0] has the latest locked amount for the current period. This can be update as many time\r\n      accountIssuanceLedger[account][1-2] has the last locked amount for a previous period they minted or burned\r\n     */\r\n    function appendAccountIssuanceRecord(\r\n        address account,\r\n        uint debtRatio,\r\n        uint debtEntryIndex,\r\n        uint currentPeriodStartDebtIndex\r\n    ) external onlyFeePool {\r\n        // Is the current debtEntryIndex within this fee period\r\n        if (accountIssuanceLedger[account][0].debtEntryIndex < currentPeriodStartDebtIndex) {\r\n            // If its older then shift the previous IssuanceData entries periods down to make room for the new one.\r\n            issuanceDataIndexOrder(account);\r\n        }\r\n\r\n        // Always store the latest IssuanceData entry at [0]\r\n        accountIssuanceLedger[account][0].debtPercentage = debtRatio;\r\n        accountIssuanceLedger[account][0].debtEntryIndex = debtEntryIndex;\r\n    }\r\n\r\n    /**\r\n     * @notice Pushes down the entire array of debt ratios per fee period\r\n     */\r\n    function issuanceDataIndexOrder(address account) private {\r\n        for (uint i = FEE_PERIOD_LENGTH - 2; i < FEE_PERIOD_LENGTH; i--) {\r\n            uint next = i + 1;\r\n            accountIssuanceLedger[account][next].debtPercentage = accountIssuanceLedger[account][i].debtPercentage;\r\n            accountIssuanceLedger[account][next].debtEntryIndex = accountIssuanceLedger[account][i].debtEntryIndex;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Import issuer data from synthetixState.issuerData on FeePeriodClose() block #\r\n     * @dev Only callable by the contract owner, and only for 6 weeks after deployment.\r\n     * @param accounts Array of issuing addresses\r\n     * @param ratios Array of debt ratios\r\n     * @param periodToInsert The Fee Period to insert the historical records into\r\n     * @param feePeriodCloseIndex An accounts debtEntryIndex is valid when within the fee peroid,\r\n     * since the input ratio will be an average of the pervious periods it just needs to be\r\n     * > recentFeePeriods[periodToInsert].startingDebtIndex\r\n     * < recentFeePeriods[periodToInsert - 1].startingDebtIndex\r\n     */\r\n    function importIssuerData(\r\n        address[] calldata accounts,\r\n        uint[] calldata ratios,\r\n        uint periodToInsert,\r\n        uint feePeriodCloseIndex\r\n    ) external onlyOwner onlyDuringSetup {\r\n        require(accounts.length == ratios.length, \"Length mismatch\");\r\n\r\n        for (uint i = 0; i < accounts.length; i++) {\r\n            accountIssuanceLedger[accounts[i]][periodToInsert].debtPercentage = ratios[i];\r\n            accountIssuanceLedger[accounts[i]][periodToInsert].debtEntryIndex = feePeriodCloseIndex;\r\n            emit IssuanceDebtRatioEntry(accounts[i], ratios[i], feePeriodCloseIndex);\r\n        }\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyFeePool {\r\n        require(msg.sender == address(feePool), \"Only the FeePool contract can perform this action\");\r\n        _;\r\n    }\r\n\r\n    /* ========== Events ========== */\r\n    event IssuanceDebtRatioEntry(address indexed account, uint debtRatio, uint feePeriodCloseIndex);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/eternalstorage\r\n/**\r\n * @notice  This contract is based on the code available from this blog\r\n * https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88/\r\n * Implements support for storing a keccak256 key and value pairs. It is the more flexible\r\n * and extensible option. This ensures data schema changes can be implemented without\r\n * requiring upgrades to the storage contract.\r\n */\r\ncontract EternalStorage is Owned, State {\r\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\r\n\r\n    /* ========== DATA TYPES ========== */\r\n    mapping(bytes32 => uint) internal UIntStorage;\r\n    mapping(bytes32 => string) internal StringStorage;\r\n    mapping(bytes32 => address) internal AddressStorage;\r\n    mapping(bytes32 => bytes) internal BytesStorage;\r\n    mapping(bytes32 => bytes32) internal Bytes32Storage;\r\n    mapping(bytes32 => bool) internal BooleanStorage;\r\n    mapping(bytes32 => int) internal IntStorage;\r\n\r\n    // UIntStorage;\r\n    function getUIntValue(bytes32 record) external view returns (uint) {\r\n        return UIntStorage[record];\r\n    }\r\n\r\n    function setUIntValue(bytes32 record, uint value) external onlyAssociatedContract {\r\n        UIntStorage[record] = value;\r\n    }\r\n\r\n    function deleteUIntValue(bytes32 record) external onlyAssociatedContract {\r\n        delete UIntStorage[record];\r\n    }\r\n\r\n    // StringStorage\r\n    function getStringValue(bytes32 record) external view returns (string memory) {\r\n        return StringStorage[record];\r\n    }\r\n\r\n    function setStringValue(bytes32 record, string calldata value) external onlyAssociatedContract {\r\n        StringStorage[record] = value;\r\n    }\r\n\r\n    function deleteStringValue(bytes32 record) external onlyAssociatedContract {\r\n        delete StringStorage[record];\r\n    }\r\n\r\n    // AddressStorage\r\n    function getAddressValue(bytes32 record) external view returns (address) {\r\n        return AddressStorage[record];\r\n    }\r\n\r\n    function setAddressValue(bytes32 record, address value) external onlyAssociatedContract {\r\n        AddressStorage[record] = value;\r\n    }\r\n\r\n    function deleteAddressValue(bytes32 record) external onlyAssociatedContract {\r\n        delete AddressStorage[record];\r\n    }\r\n\r\n    // BytesStorage\r\n    function getBytesValue(bytes32 record) external view returns (bytes memory) {\r\n        return BytesStorage[record];\r\n    }\r\n\r\n    function setBytesValue(bytes32 record, bytes calldata value) external onlyAssociatedContract {\r\n        BytesStorage[record] = value;\r\n    }\r\n\r\n    function deleteBytesValue(bytes32 record) external onlyAssociatedContract {\r\n        delete BytesStorage[record];\r\n    }\r\n\r\n    // Bytes32Storage\r\n    function getBytes32Value(bytes32 record) external view returns (bytes32) {\r\n        return Bytes32Storage[record];\r\n    }\r\n\r\n    function setBytes32Value(bytes32 record, bytes32 value) external onlyAssociatedContract {\r\n        Bytes32Storage[record] = value;\r\n    }\r\n\r\n    function deleteBytes32Value(bytes32 record) external onlyAssociatedContract {\r\n        delete Bytes32Storage[record];\r\n    }\r\n\r\n    // BooleanStorage\r\n    function getBooleanValue(bytes32 record) external view returns (bool) {\r\n        return BooleanStorage[record];\r\n    }\r\n\r\n    function setBooleanValue(bytes32 record, bool value) external onlyAssociatedContract {\r\n        BooleanStorage[record] = value;\r\n    }\r\n\r\n    function deleteBooleanValue(bytes32 record) external onlyAssociatedContract {\r\n        delete BooleanStorage[record];\r\n    }\r\n\r\n    // IntStorage\r\n    function getIntValue(bytes32 record) external view returns (int) {\r\n        return IntStorage[record];\r\n    }\r\n\r\n    function setIntValue(bytes32 record, int value) external onlyAssociatedContract {\r\n        IntStorage[record] = value;\r\n    }\r\n\r\n    function deleteIntValue(bytes32 record) external onlyAssociatedContract {\r\n        delete IntStorage[record];\r\n    }\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/feepooleternalstorage\r\ncontract FeePoolEternalStorage is EternalStorage, LimitedSetup {\r\n    bytes32 internal constant LAST_FEE_WITHDRAWAL = \"last_fee_withdrawal\";\r\n\r\n    constructor(address _owner, address _feePool) public EternalStorage(_owner, _feePool) LimitedSetup(6 weeks) {}\r\n\r\n    function importFeeWithdrawalData(address[] calldata accounts, uint[] calldata feePeriodIDs)\r\n        external\r\n        onlyOwner\r\n        onlyDuringSetup\r\n    {\r\n        require(accounts.length == feePeriodIDs.length, \"Length mismatch\");\r\n\r\n        for (uint8 i = 0; i < accounts.length; i++) {\r\n            this.setUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, accounts[i])), feePeriodIDs[i]);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetixstate\r\ninterface ISynthetixState {\r\n    // Views\r\n    function debtLedger(uint index) external view returns (uint);\r\n\r\n    function issuanceData(address account) external view returns (uint initialDebtOwnership, uint debtEntryIndex);\r\n\r\n    function debtLedgerLength() external view returns (uint);\r\n\r\n    function hasIssued(address account) external view returns (bool);\r\n\r\n    function lastDebtLedgerEntry() external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function incrementTotalIssuerCount() external;\r\n\r\n    function decrementTotalIssuerCount() external;\r\n\r\n    function setCurrentIssuanceData(address account, uint initialDebtOwnership) external;\r\n\r\n    function appendDebtLedgerValue(uint value) external;\r\n\r\n    function clearIssuanceData(address account) external;\r\n}\r\n\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary VestingEntries {\r\n    struct VestingEntry {\r\n        uint64 endTime;\r\n        uint256 escrowAmount;\r\n    }\r\n    struct VestingEntryWithID {\r\n        uint64 endTime;\r\n        uint256 escrowAmount;\r\n        uint256 entryID;\r\n    }\r\n}\r\n\r\ninterface IRewardEscrowV2 {\r\n    // Views\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    function numVestingEntries(address account) external view returns (uint);\r\n\r\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\r\n\r\n    function totalVestedAccountBalance(address account) external view returns (uint);\r\n\r\n    function getVestingQuantity(address account, uint256[] calldata entryIDs) external view returns (uint);\r\n\r\n    function getVestingSchedules(\r\n        address account,\r\n        uint256 index,\r\n        uint256 pageSize\r\n    ) external view returns (VestingEntries.VestingEntryWithID[] memory);\r\n\r\n    function getAccountVestingEntryIDs(\r\n        address account,\r\n        uint256 index,\r\n        uint256 pageSize\r\n    ) external view returns (uint256[] memory);\r\n\r\n    function getVestingEntryClaimable(address account, uint256 entryID) external view returns (uint);\r\n\r\n    function getVestingEntry(address account, uint256 entryID) external view returns (uint64, uint256);\r\n\r\n    // Mutative functions\r\n    function vest(uint256[] calldata entryIDs) external;\r\n\r\n    function createEscrowEntry(\r\n        address beneficiary,\r\n        uint256 deposit,\r\n        uint256 duration\r\n    ) external;\r\n\r\n    function appendVestingEntry(\r\n        address account,\r\n        uint256 quantity,\r\n        uint256 duration\r\n    ) external;\r\n\r\n    function migrateVestingSchedule(address _addressToMigrate) external;\r\n\r\n    function migrateAccountEscrowBalances(\r\n        address[] calldata accounts,\r\n        uint256[] calldata escrowBalances,\r\n        uint256[] calldata vestedBalances\r\n    ) external;\r\n\r\n    // Account Merging\r\n    function startMergingWindow() external;\r\n\r\n    function mergeAccount(address accountToMerge, uint256[] calldata entryIDs) external;\r\n\r\n    function nominateAccountToMerge(address account) external;\r\n\r\n    function accountMergingIsOpen() external view returns (bool);\r\n\r\n    // L2 Migration\r\n    function importVestingEntries(\r\n        address account,\r\n        uint256 escrowedAmount,\r\n        VestingEntries.VestingEntry[] calldata vestingEntries\r\n    ) external;\r\n\r\n    // Return amount of SNX transfered to SynthetixBridgeToOptimism deposit contract\r\n    function burnForMigration(address account, uint256[] calldata entryIDs)\r\n        external\r\n        returns (uint256 escrowedAccountBalance, VestingEntries.VestingEntry[] memory vestingEntries);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/idelegateapprovals\r\ninterface IDelegateApprovals {\r\n    // Views\r\n    function canBurnFor(address authoriser, address delegate) external view returns (bool);\r\n\r\n    function canIssueFor(address authoriser, address delegate) external view returns (bool);\r\n\r\n    function canClaimFor(address authoriser, address delegate) external view returns (bool);\r\n\r\n    function canExchangeFor(address authoriser, address delegate) external view returns (bool);\r\n\r\n    // Mutative\r\n    function approveAllDelegatePowers(address delegate) external;\r\n\r\n    function removeAllDelegatePowers(address delegate) external;\r\n\r\n    function approveBurnOnBehalf(address delegate) external;\r\n\r\n    function removeBurnOnBehalf(address delegate) external;\r\n\r\n    function approveIssueOnBehalf(address delegate) external;\r\n\r\n    function removeIssueOnBehalf(address delegate) external;\r\n\r\n    function approveClaimOnBehalf(address delegate) external;\r\n\r\n    function removeClaimOnBehalf(address delegate) external;\r\n\r\n    function approveExchangeOnBehalf(address delegate) external;\r\n\r\n    function removeExchangeOnBehalf(address delegate) external;\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/irewardsdistribution\r\ninterface IRewardsDistribution {\r\n    // Structs\r\n    struct DistributionData {\r\n        address destination;\r\n        uint amount;\r\n    }\r\n\r\n    // Views\r\n    function authority() external view returns (address);\r\n\r\n    function distributions(uint index) external view returns (address destination, uint amount); // DistributionData\r\n\r\n    function distributionsLength() external view returns (uint);\r\n\r\n    // Mutative Functions\r\n    function distributeRewards(uint amount) external returns (bool);\r\n}\r\n\r\n\r\ninterface ICollateralManager {\r\n    // Manager information\r\n    function hasCollateral(address collateral) external view returns (bool);\r\n\r\n    function isSynthManaged(bytes32 currencyKey) external view returns (bool);\r\n\r\n    // State information\r\n    function long(bytes32 synth) external view returns (uint amount);\r\n\r\n    function short(bytes32 synth) external view returns (uint amount);\r\n\r\n    function totalLong() external view returns (uint susdValue, bool anyRateIsInvalid);\r\n\r\n    function totalShort() external view returns (uint susdValue, bool anyRateIsInvalid);\r\n\r\n    function getBorrowRate() external view returns (uint borrowRate, bool anyRateIsInvalid);\r\n\r\n    function getShortRate(bytes32 synth) external view returns (uint shortRate, bool rateIsInvalid);\r\n\r\n    function getRatesAndTime(uint index)\r\n        external\r\n        view\r\n        returns (\r\n            uint entryRate,\r\n            uint lastRate,\r\n            uint lastUpdated,\r\n            uint newIndex\r\n        );\r\n\r\n    function getShortRatesAndTime(bytes32 currency, uint index)\r\n        external\r\n        view\r\n        returns (\r\n            uint entryRate,\r\n            uint lastRate,\r\n            uint lastUpdated,\r\n            uint newIndex\r\n        );\r\n\r\n    function exceedsDebtLimit(uint amount, bytes32 currency) external view returns (bool canIssue, bool anyRateIsInvalid);\r\n\r\n    function areSynthsAndCurrenciesSet(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function areShortableSynthsSet(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    // Loans\r\n    function getNewLoanId() external returns (uint id);\r\n\r\n    // Manager mutative\r\n    function addCollaterals(address[] calldata collaterals) external;\r\n\r\n    function removeCollaterals(address[] calldata collaterals) external;\r\n\r\n    function addSynths(bytes32[] calldata synthNamesInResolver, bytes32[] calldata synthKeys) external;\r\n\r\n    function removeSynths(bytes32[] calldata synths, bytes32[] calldata synthKeys) external;\r\n\r\n    function addShortableSynths(bytes32[] calldata requiredSynthNamesInResolver, bytes32[] calldata synthKeys) external;\r\n\r\n    function removeShortableSynths(bytes32[] calldata synths) external;\r\n\r\n    // State mutative\r\n\r\n    function incrementLongs(bytes32 synth, uint amount) external;\r\n\r\n    function decrementLongs(bytes32 synth, uint amount) external;\r\n\r\n    function incrementShorts(bytes32 synth, uint amount) external;\r\n\r\n    function decrementShorts(bytes32 synth, uint amount) external;\r\n\r\n    function accrueInterest(\r\n        uint interestIndex,\r\n        bytes32 currency,\r\n        bool isShort\r\n    ) external returns (uint difference, uint index);\r\n\r\n    function updateBorrowRatesCollateral(uint rate) external;\r\n\r\n    function updateShortRatesCollateral(bytes32 currency, uint rate) external;\r\n}\r\n\r\n\r\ninterface IWETH {\r\n    // ERC20 Optional Views\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    // Views\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) external returns (bool);\r\n\r\n    // WETH-specific functions.\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint amount) external;\r\n\r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Deposit(address indexed to, uint amount);\r\n    event Withdrawal(address indexed to, uint amount);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/ietherwrapper\r\ncontract IEtherWrapper {\r\n    function mint(uint amount) external;\r\n\r\n    function burn(uint amount) external;\r\n\r\n    function distributeFees() external;\r\n\r\n    function capacity() external view returns (uint);\r\n\r\n    function getReserves() external view returns (uint);\r\n\r\n    function totalIssuedSynths() external view returns (uint);\r\n\r\n    function calculateMintFee(uint amount) public view returns (uint);\r\n\r\n    function calculateBurnFee(uint amount) public view returns (uint);\r\n\r\n    function maxETH() public view returns (uint256);\r\n\r\n    function mintFeeRate() public view returns (uint256);\r\n\r\n    function burnFeeRate() public view returns (uint256);\r\n\r\n    function weth() public view returns (IWETH);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/iwrapperfactory\r\ninterface IWrapperFactory {\r\n    function isWrapper(address possibleWrapper) external view returns (bool);\r\n\r\n    function createWrapper(\r\n        IERC20 token,\r\n        bytes32 currencyKey,\r\n        bytes32 synthContractName\r\n    ) external returns (address);\r\n\r\n    function distributeFees() external;\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/feepool\r\ncontract FeePool is Owned, Proxyable, LimitedSetup, MixinSystemSettings, IFeePool {\r\n    using SafeMath for uint;\r\n    using SafeDecimalMath for uint;\r\n\r\n    bytes32 public constant CONTRACT_NAME = \"FeePool\";\r\n\r\n    // Where fees are pooled in sUSD.\r\n    address public constant FEE_ADDRESS = 0xfeEFEEfeefEeFeefEEFEEfEeFeefEEFeeFEEFEeF;\r\n\r\n    // sUSD currencyKey. Fees stored and paid in sUSD\r\n    bytes32 private sUSD = \"sUSD\";\r\n\r\n    // This struct represents the issuance activity that's happened in a fee period.\r\n    struct FeePeriod {\r\n        uint64 feePeriodId;\r\n        uint64 startingDebtIndex;\r\n        uint64 startTime;\r\n        uint feesToDistribute;\r\n        uint feesClaimed;\r\n        uint rewardsToDistribute;\r\n        uint rewardsClaimed;\r\n    }\r\n\r\n    // A staker(mintr) can claim from the previous fee period (7 days) only.\r\n    // Fee Periods stored and managed from [0], such that [0] is always\r\n    // the current active fee period which is not claimable until the\r\n    // public function closeCurrentFeePeriod() is called closing the\r\n    // current weeks collected fees. [1] is last weeks feeperiod\r\n    uint8 public constant FEE_PERIOD_LENGTH = 2;\r\n\r\n    FeePeriod[FEE_PERIOD_LENGTH] private _recentFeePeriods;\r\n    uint256 private _currentFeePeriod;\r\n\r\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\r\n\r\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\r\n    bytes32 private constant CONTRACT_SYNTHETIX = \"Synthetix\";\r\n    bytes32 private constant CONTRACT_FEEPOOLSTATE = \"FeePoolState\";\r\n    bytes32 private constant CONTRACT_FEEPOOLETERNALSTORAGE = \"FeePoolEternalStorage\";\r\n    bytes32 private constant CONTRACT_EXCHANGER = \"Exchanger\";\r\n    bytes32 private constant CONTRACT_ISSUER = \"Issuer\";\r\n    bytes32 private constant CONTRACT_SYNTHETIXSTATE = \"SynthetixState\";\r\n    bytes32 private constant CONTRACT_REWARDESCROW_V2 = \"RewardEscrowV2\";\r\n    bytes32 private constant CONTRACT_DELEGATEAPPROVALS = \"DelegateApprovals\";\r\n    bytes32 private constant CONTRACT_COLLATERALMANAGER = \"CollateralManager\";\r\n    bytes32 private constant CONTRACT_REWARDSDISTRIBUTION = \"RewardsDistribution\";\r\n    bytes32 private constant CONTRACT_ETHER_WRAPPER = \"EtherWrapper\";\r\n    bytes32 private constant CONTRACT_WRAPPER_FACTORY = \"WrapperFactory\";\r\n\r\n    /* ========== ETERNAL STORAGE CONSTANTS ========== */\r\n\r\n    bytes32 private constant LAST_FEE_WITHDRAWAL = \"last_fee_withdrawal\";\r\n\r\n    constructor(\r\n        address payable _proxy,\r\n        address _owner,\r\n        address _resolver\r\n    ) public Owned(_owner) Proxyable(_proxy) LimitedSetup(3 weeks) MixinSystemSettings(_resolver) {\r\n        // Set our initial fee period\r\n        _recentFeePeriodsStorage(0).feePeriodId = 1;\r\n        _recentFeePeriodsStorage(0).startTime = uint64(now);\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\r\n        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();\r\n        bytes32[] memory newAddresses = new bytes32[](13);\r\n        newAddresses[0] = CONTRACT_SYSTEMSTATUS;\r\n        newAddresses[1] = CONTRACT_SYNTHETIX;\r\n        newAddresses[2] = CONTRACT_FEEPOOLSTATE;\r\n        newAddresses[3] = CONTRACT_FEEPOOLETERNALSTORAGE;\r\n        newAddresses[4] = CONTRACT_EXCHANGER;\r\n        newAddresses[5] = CONTRACT_ISSUER;\r\n        newAddresses[6] = CONTRACT_SYNTHETIXSTATE;\r\n        newAddresses[7] = CONTRACT_REWARDESCROW_V2;\r\n        newAddresses[8] = CONTRACT_DELEGATEAPPROVALS;\r\n        newAddresses[9] = CONTRACT_REWARDSDISTRIBUTION;\r\n        newAddresses[10] = CONTRACT_COLLATERALMANAGER;\r\n        newAddresses[11] = CONTRACT_WRAPPER_FACTORY;\r\n        newAddresses[12] = CONTRACT_ETHER_WRAPPER;\r\n        addresses = combineArrays(existingAddresses, newAddresses);\r\n    }\r\n\r\n    function systemStatus() internal view returns (ISystemStatus) {\r\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\r\n    }\r\n\r\n    function synthetix() internal view returns (ISynthetix) {\r\n        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));\r\n    }\r\n\r\n    function feePoolState() internal view returns (FeePoolState) {\r\n        return FeePoolState(requireAndGetAddress(CONTRACT_FEEPOOLSTATE));\r\n    }\r\n\r\n    function feePoolEternalStorage() internal view returns (FeePoolEternalStorage) {\r\n        return FeePoolEternalStorage(requireAndGetAddress(CONTRACT_FEEPOOLETERNALSTORAGE));\r\n    }\r\n\r\n    function exchanger() internal view returns (IExchanger) {\r\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\r\n    }\r\n\r\n    function collateralManager() internal view returns (ICollateralManager) {\r\n        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));\r\n    }\r\n\r\n    function issuer() internal view returns (IIssuer) {\r\n        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));\r\n    }\r\n\r\n    function synthetixState() internal view returns (ISynthetixState) {\r\n        return ISynthetixState(requireAndGetAddress(CONTRACT_SYNTHETIXSTATE));\r\n    }\r\n\r\n    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {\r\n        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));\r\n    }\r\n\r\n    function delegateApprovals() internal view returns (IDelegateApprovals) {\r\n        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));\r\n    }\r\n\r\n    function rewardsDistribution() internal view returns (IRewardsDistribution) {\r\n        return IRewardsDistribution(requireAndGetAddress(CONTRACT_REWARDSDISTRIBUTION));\r\n    }\r\n\r\n    function etherWrapper() internal view returns (IEtherWrapper) {\r\n        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));\r\n    }\r\n\r\n    function wrapperFactory() internal view returns (IWrapperFactory) {\r\n        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));\r\n    }\r\n\r\n    function issuanceRatio() external view returns (uint) {\r\n        return getIssuanceRatio();\r\n    }\r\n\r\n    function feePeriodDuration() external view returns (uint) {\r\n        return getFeePeriodDuration();\r\n    }\r\n\r\n    function targetThreshold() external view returns (uint) {\r\n        return getTargetThreshold();\r\n    }\r\n\r\n    function recentFeePeriods(uint index)\r\n        external\r\n        view\r\n        returns (\r\n            uint64 feePeriodId,\r\n            uint64 startingDebtIndex,\r\n            uint64 startTime,\r\n            uint feesToDistribute,\r\n            uint feesClaimed,\r\n            uint rewardsToDistribute,\r\n            uint rewardsClaimed\r\n        )\r\n    {\r\n        FeePeriod memory feePeriod = _recentFeePeriodsStorage(index);\r\n        return (\r\n            feePeriod.feePeriodId,\r\n            feePeriod.startingDebtIndex,\r\n            feePeriod.startTime,\r\n            feePeriod.feesToDistribute,\r\n            feePeriod.feesClaimed,\r\n            feePeriod.rewardsToDistribute,\r\n            feePeriod.rewardsClaimed\r\n        );\r\n    }\r\n\r\n    function _recentFeePeriodsStorage(uint index) internal view returns (FeePeriod storage) {\r\n        return _recentFeePeriods[(_currentFeePeriod + index) % FEE_PERIOD_LENGTH];\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Logs an accounts issuance data per fee period\r\n     * @param account Message.Senders account address\r\n     * @param debtRatio Debt percentage this account has locked after minting or burning their synth\r\n     * @param debtEntryIndex The index in the global debt ledger. synthetixState.issuanceData(account)\r\n     * @dev onlyIssuer to call me on synthetix.issue() & synthetix.burn() calls to store the locked SNX\r\n     * per fee period so we know to allocate the correct proportions of fees and rewards per period\r\n     */\r\n    function appendAccountIssuanceRecord(\r\n        address account,\r\n        uint debtRatio,\r\n        uint debtEntryIndex\r\n    ) external onlyIssuerAndSynthetixState {\r\n        feePoolState().appendAccountIssuanceRecord(\r\n            account,\r\n            debtRatio,\r\n            debtEntryIndex,\r\n            _recentFeePeriodsStorage(0).startingDebtIndex\r\n        );\r\n\r\n        emitIssuanceDebtRatioEntry(account, debtRatio, debtEntryIndex, _recentFeePeriodsStorage(0).startingDebtIndex);\r\n    }\r\n\r\n    /**\r\n     * @notice The Exchanger contract informs us when fees are paid.\r\n     * @param amount susd amount in fees being paid.\r\n     */\r\n    function recordFeePaid(uint amount) external onlyInternalContracts {\r\n        // Keep track off fees in sUSD in the open fee pool period.\r\n        _recentFeePeriodsStorage(0).feesToDistribute = _recentFeePeriodsStorage(0).feesToDistribute.add(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice The RewardsDistribution contract informs us how many SNX rewards are sent to RewardEscrow to be claimed.\r\n     */\r\n    function setRewardsToDistribute(uint amount) external {\r\n        address rewardsAuthority = address(rewardsDistribution());\r\n        require(messageSender == rewardsAuthority || msg.sender == rewardsAuthority, \"Caller is not rewardsAuthority\");\r\n        // Add the amount of SNX rewards to distribute on top of any rolling unclaimed amount\r\n        _recentFeePeriodsStorage(0).rewardsToDistribute = _recentFeePeriodsStorage(0).rewardsToDistribute.add(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Close the current fee period and start a new one.\r\n     */\r\n    function closeCurrentFeePeriod() external issuanceActive {\r\n        require(getFeePeriodDuration() > 0, \"Fee Period Duration not set\");\r\n        require(_recentFeePeriodsStorage(0).startTime <= (now - getFeePeriodDuration()), \"Too early to close fee period\");\r\n\r\n        etherWrapper().distributeFees();\r\n        wrapperFactory().distributeFees();\r\n\r\n        // Note:  when FEE_PERIOD_LENGTH = 2, periodClosing is the current period & periodToRollover is the last open claimable period\r\n        FeePeriod storage periodClosing = _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 2);\r\n        FeePeriod storage periodToRollover = _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 1);\r\n\r\n        // Any unclaimed fees from the last period in the array roll back one period.\r\n        // Because of the subtraction here, they're effectively proportionally redistributed to those who\r\n        // have already claimed from the old period, available in the new period.\r\n        // The subtraction is important so we don't create a ticking time bomb of an ever growing\r\n        // number of fees that can never decrease and will eventually overflow at the end of the fee pool.\r\n        _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 2).feesToDistribute = periodToRollover\r\n            .feesToDistribute\r\n            .sub(periodToRollover.feesClaimed)\r\n            .add(periodClosing.feesToDistribute);\r\n        _recentFeePeriodsStorage(FEE_PERIOD_LENGTH - 2).rewardsToDistribute = periodToRollover\r\n            .rewardsToDistribute\r\n            .sub(periodToRollover.rewardsClaimed)\r\n            .add(periodClosing.rewardsToDistribute);\r\n\r\n        // Shift the previous fee periods across to make room for the new one.\r\n        _currentFeePeriod = _currentFeePeriod.add(FEE_PERIOD_LENGTH).sub(1).mod(FEE_PERIOD_LENGTH);\r\n\r\n        // Clear the first element of the array to make sure we don't have any stale values.\r\n        delete _recentFeePeriods[_currentFeePeriod];\r\n\r\n        // Open up the new fee period.\r\n        // Increment periodId from the recent closed period feePeriodId\r\n        _recentFeePeriodsStorage(0).feePeriodId = uint64(uint256(_recentFeePeriodsStorage(1).feePeriodId).add(1));\r\n        _recentFeePeriodsStorage(0).startingDebtIndex = uint64(synthetixState().debtLedgerLength());\r\n        _recentFeePeriodsStorage(0).startTime = uint64(now);\r\n\r\n        emitFeePeriodClosed(_recentFeePeriodsStorage(1).feePeriodId);\r\n    }\r\n\r\n    /**\r\n     * @notice Claim fees for last period when available or not already withdrawn.\r\n     */\r\n    function claimFees() external issuanceActive optionalProxy returns (bool) {\r\n        return _claimFees(messageSender);\r\n    }\r\n\r\n    /**\r\n     * @notice Delegated claimFees(). Call from the deletegated address\r\n     * and the fees will be sent to the claimingForAddress.\r\n     * approveClaimOnBehalf() must be called first to approve the deletage address\r\n     * @param claimingForAddress The account you are claiming fees for\r\n     */\r\n    function claimOnBehalf(address claimingForAddress) external issuanceActive optionalProxy returns (bool) {\r\n        require(delegateApprovals().canClaimFor(claimingForAddress, messageSender), \"Not approved to claim on behalf\");\r\n\r\n        return _claimFees(claimingForAddress);\r\n    }\r\n\r\n    function _claimFees(address claimingAddress) internal returns (bool) {\r\n        uint rewardsPaid = 0;\r\n        uint feesPaid = 0;\r\n        uint availableFees;\r\n        uint availableRewards;\r\n\r\n        // Address won't be able to claim fees if it is too far below the target c-ratio.\r\n        // It will need to burn synths then try claiming again.\r\n        (bool feesClaimable, bool anyRateIsInvalid) = _isFeesClaimableAndAnyRatesInvalid(claimingAddress);\r\n\r\n        require(feesClaimable, \"C-Ratio below penalty threshold\");\r\n\r\n        require(!anyRateIsInvalid, \"A synth or SNX rate is invalid\");\r\n\r\n        // Get the claimingAddress available fees and rewards\r\n        (availableFees, availableRewards) = feesAvailable(claimingAddress);\r\n\r\n        require(\r\n            availableFees > 0 || availableRewards > 0,\r\n            \"No fees or rewards available for period, or fees already claimed\"\r\n        );\r\n\r\n        // Record the address has claimed for this period\r\n        _setLastFeeWithdrawal(claimingAddress, _recentFeePeriodsStorage(1).feePeriodId);\r\n\r\n        if (availableFees > 0) {\r\n            // Record the fee payment in our recentFeePeriods\r\n            feesPaid = _recordFeePayment(availableFees);\r\n\r\n            // Send them their fees\r\n            _payFees(claimingAddress, feesPaid);\r\n        }\r\n\r\n        if (availableRewards > 0) {\r\n            // Record the reward payment in our recentFeePeriods\r\n            rewardsPaid = _recordRewardPayment(availableRewards);\r\n\r\n            // Send them their rewards\r\n            _payRewards(claimingAddress, rewardsPaid);\r\n        }\r\n\r\n        emitFeesClaimed(claimingAddress, feesPaid, rewardsPaid);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Admin function to import the FeePeriod data from the previous contract\r\n     */\r\n    function importFeePeriod(\r\n        uint feePeriodIndex,\r\n        uint feePeriodId,\r\n        uint startingDebtIndex,\r\n        uint startTime,\r\n        uint feesToDistribute,\r\n        uint feesClaimed,\r\n        uint rewardsToDistribute,\r\n        uint rewardsClaimed\r\n    ) public optionalProxy_onlyOwner onlyDuringSetup {\r\n        require(startingDebtIndex <= synthetixState().debtLedgerLength(), \"Cannot import bad data\");\r\n\r\n        _recentFeePeriods[_currentFeePeriod.add(feePeriodIndex).mod(FEE_PERIOD_LENGTH)] = FeePeriod({\r\n            feePeriodId: uint64(feePeriodId),\r\n            startingDebtIndex: uint64(startingDebtIndex),\r\n            startTime: uint64(startTime),\r\n            feesToDistribute: feesToDistribute,\r\n            feesClaimed: feesClaimed,\r\n            rewardsToDistribute: rewardsToDistribute,\r\n            rewardsClaimed: rewardsClaimed\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @notice Record the fee payment in our recentFeePeriods.\r\n     * @param sUSDAmount The amount of fees priced in sUSD.\r\n     */\r\n    function _recordFeePayment(uint sUSDAmount) internal returns (uint) {\r\n        // Don't assign to the parameter\r\n        uint remainingToAllocate = sUSDAmount;\r\n\r\n        uint feesPaid;\r\n        // Start at the oldest period and record the amount, moving to newer periods\r\n        // until we've exhausted the amount.\r\n        // The condition checks for overflow because we're going to 0 with an unsigned int.\r\n        for (uint i = FEE_PERIOD_LENGTH - 1; i < FEE_PERIOD_LENGTH; i--) {\r\n            uint feesAlreadyClaimed = _recentFeePeriodsStorage(i).feesClaimed;\r\n            uint delta = _recentFeePeriodsStorage(i).feesToDistribute.sub(feesAlreadyClaimed);\r\n\r\n            if (delta > 0) {\r\n                // Take the smaller of the amount left to claim in the period and the amount we need to allocate\r\n                uint amountInPeriod = delta < remainingToAllocate ? delta : remainingToAllocate;\r\n\r\n                _recentFeePeriodsStorage(i).feesClaimed = feesAlreadyClaimed.add(amountInPeriod);\r\n                remainingToAllocate = remainingToAllocate.sub(amountInPeriod);\r\n                feesPaid = feesPaid.add(amountInPeriod);\r\n\r\n                // No need to continue iterating if we've recorded the whole amount;\r\n                if (remainingToAllocate == 0) return feesPaid;\r\n\r\n                // We've exhausted feePeriods to distribute and no fees remain in last period\r\n                // User last to claim would in this scenario have their remainder slashed\r\n                if (i == 0 && remainingToAllocate > 0) {\r\n                    remainingToAllocate = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        return feesPaid;\r\n    }\r\n\r\n    /**\r\n     * @notice Record the reward payment in our recentFeePeriods.\r\n     * @param snxAmount The amount of SNX tokens.\r\n     */\r\n    function _recordRewardPayment(uint snxAmount) internal returns (uint) {\r\n        // Don't assign to the parameter\r\n        uint remainingToAllocate = snxAmount;\r\n\r\n        uint rewardPaid;\r\n\r\n        // Start at the oldest period and record the amount, moving to newer periods\r\n        // until we've exhausted the amount.\r\n        // The condition checks for overflow because we're going to 0 with an unsigned int.\r\n        for (uint i = FEE_PERIOD_LENGTH - 1; i < FEE_PERIOD_LENGTH; i--) {\r\n            uint toDistribute =\r\n                _recentFeePeriodsStorage(i).rewardsToDistribute.sub(_recentFeePeriodsStorage(i).rewardsClaimed);\r\n\r\n            if (toDistribute > 0) {\r\n                // Take the smaller of the amount left to claim in the period and the amount we need to allocate\r\n                uint amountInPeriod = toDistribute < remainingToAllocate ? toDistribute : remainingToAllocate;\r\n\r\n                _recentFeePeriodsStorage(i).rewardsClaimed = _recentFeePeriodsStorage(i).rewardsClaimed.add(amountInPeriod);\r\n                remainingToAllocate = remainingToAllocate.sub(amountInPeriod);\r\n                rewardPaid = rewardPaid.add(amountInPeriod);\r\n\r\n                // No need to continue iterating if we've recorded the whole amount;\r\n                if (remainingToAllocate == 0) return rewardPaid;\r\n\r\n                // We've exhausted feePeriods to distribute and no rewards remain in last period\r\n                // User last to claim would in this scenario have their remainder slashed\r\n                // due to rounding up of PreciseDecimal\r\n                if (i == 0 && remainingToAllocate > 0) {\r\n                    remainingToAllocate = 0;\r\n                }\r\n            }\r\n        }\r\n        return rewardPaid;\r\n    }\r\n\r\n    /**\r\n     * @notice Send the fees to claiming address.\r\n     * @param account The address to send the fees to.\r\n     * @param sUSDAmount The amount of fees priced in sUSD.\r\n     */\r\n    function _payFees(address account, uint sUSDAmount) internal notFeeAddress(account) {\r\n        // Grab the sUSD Synth\r\n        ISynth sUSDSynth = issuer().synths(sUSD);\r\n\r\n        // NOTE: we do not control the FEE_ADDRESS so it is not possible to do an\r\n        // ERC20.approve() transaction to allow this feePool to call ERC20.transferFrom\r\n        // to the accounts address\r\n\r\n        // Burn the source amount\r\n        sUSDSynth.burn(FEE_ADDRESS, sUSDAmount);\r\n\r\n        // Mint their new synths\r\n        sUSDSynth.issue(account, sUSDAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Send the rewards to claiming address - will be locked in rewardEscrow.\r\n     * @param account The address to send the fees to.\r\n     * @param snxAmount The amount of SNX.\r\n     */\r\n    function _payRewards(address account, uint snxAmount) internal notFeeAddress(account) {\r\n        /* Escrow the tokens for 1 year. */\r\n        uint escrowDuration = 52 weeks;\r\n\r\n        // Record vesting entry for claiming address and amount\r\n        // SNX already minted to rewardEscrow balance\r\n        rewardEscrowV2().appendVestingEntry(account, snxAmount, escrowDuration);\r\n    }\r\n\r\n    /**\r\n     * @notice The total fees available in the system to be withdrawnn in sUSD\r\n     */\r\n    function totalFeesAvailable() external view returns (uint) {\r\n        uint totalFees = 0;\r\n\r\n        // Fees in fee period [0] are not yet available for withdrawal\r\n        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {\r\n            totalFees = totalFees.add(_recentFeePeriodsStorage(i).feesToDistribute);\r\n            totalFees = totalFees.sub(_recentFeePeriodsStorage(i).feesClaimed);\r\n        }\r\n\r\n        return totalFees;\r\n    }\r\n\r\n    /**\r\n     * @notice The total SNX rewards available in the system to be withdrawn\r\n     */\r\n    function totalRewardsAvailable() external view returns (uint) {\r\n        uint totalRewards = 0;\r\n\r\n        // Rewards in fee period [0] are not yet available for withdrawal\r\n        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {\r\n            totalRewards = totalRewards.add(_recentFeePeriodsStorage(i).rewardsToDistribute);\r\n            totalRewards = totalRewards.sub(_recentFeePeriodsStorage(i).rewardsClaimed);\r\n        }\r\n\r\n        return totalRewards;\r\n    }\r\n\r\n    /**\r\n     * @notice The fees available to be withdrawn by a specific account, priced in sUSD\r\n     * @dev Returns two amounts, one for fees and one for SNX rewards\r\n     */\r\n    function feesAvailable(address account) public view returns (uint, uint) {\r\n        // Add up the fees\r\n        uint[2][FEE_PERIOD_LENGTH] memory userFees = feesByPeriod(account);\r\n\r\n        uint totalFees = 0;\r\n        uint totalRewards = 0;\r\n\r\n        // Fees & Rewards in fee period [0] are not yet available for withdrawal\r\n        for (uint i = 1; i < FEE_PERIOD_LENGTH; i++) {\r\n            totalFees = totalFees.add(userFees[i][0]);\r\n            totalRewards = totalRewards.add(userFees[i][1]);\r\n        }\r\n\r\n        // And convert totalFees to sUSD\r\n        // Return totalRewards as is in SNX amount\r\n        return (totalFees, totalRewards);\r\n    }\r\n\r\n    function _isFeesClaimableAndAnyRatesInvalid(address account) internal view returns (bool, bool) {\r\n        // Threshold is calculated from ratio % above the target ratio (issuanceRatio).\r\n        //  0  <  10%:   Claimable\r\n        // 10% > above:  Unable to claim\r\n        (uint ratio, bool anyRateIsInvalid) = issuer().collateralisationRatioAndAnyRatesInvalid(account);\r\n        uint targetRatio = getIssuanceRatio();\r\n\r\n        // Claimable if collateral ratio below target ratio\r\n        if (ratio < targetRatio) {\r\n            return (true, anyRateIsInvalid);\r\n        }\r\n\r\n        // Calculate the threshold for collateral ratio before fees can't be claimed.\r\n        uint ratio_threshold = targetRatio.multiplyDecimal(SafeDecimalMath.unit().add(getTargetThreshold()));\r\n\r\n        // Not claimable if collateral ratio above threshold\r\n        if (ratio > ratio_threshold) {\r\n            return (false, anyRateIsInvalid);\r\n        }\r\n\r\n        return (true, anyRateIsInvalid);\r\n    }\r\n\r\n    function isFeesClaimable(address account) external view returns (bool feesClaimable) {\r\n        (feesClaimable, ) = _isFeesClaimableAndAnyRatesInvalid(account);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates fees by period for an account, priced in sUSD\r\n     * @param account The address you want to query the fees for\r\n     */\r\n    function feesByPeriod(address account) public view returns (uint[2][FEE_PERIOD_LENGTH] memory results) {\r\n        // What's the user's debt entry index and the debt they owe to the system at current feePeriod\r\n        uint userOwnershipPercentage;\r\n        uint debtEntryIndex;\r\n        FeePoolState _feePoolState = feePoolState();\r\n\r\n        (userOwnershipPercentage, debtEntryIndex) = _feePoolState.getAccountsDebtEntry(account, 0);\r\n\r\n        // If they don't have any debt ownership and they never minted, they don't have any fees.\r\n        // User ownership can reduce to 0 if user burns all synths,\r\n        // however they could have fees applicable for periods they had minted in before so we check debtEntryIndex.\r\n        if (debtEntryIndex == 0 && userOwnershipPercentage == 0) {\r\n            uint[2][FEE_PERIOD_LENGTH] memory nullResults;\r\n            return nullResults;\r\n        }\r\n\r\n        // The [0] fee period is not yet ready to claim, but it is a fee period that they can have\r\n        // fees owing for, so we need to report on it anyway.\r\n        uint feesFromPeriod;\r\n        uint rewardsFromPeriod;\r\n        (feesFromPeriod, rewardsFromPeriod) = _feesAndRewardsFromPeriod(0, userOwnershipPercentage, debtEntryIndex);\r\n\r\n        results[0][0] = feesFromPeriod;\r\n        results[0][1] = rewardsFromPeriod;\r\n\r\n        // Retrieve user's last fee claim by periodId\r\n        uint lastFeeWithdrawal = getLastFeeWithdrawal(account);\r\n\r\n        // Go through our fee periods from the oldest feePeriod[FEE_PERIOD_LENGTH - 1] and figure out what we owe them.\r\n        // Condition checks for periods > 0\r\n        for (uint i = FEE_PERIOD_LENGTH - 1; i > 0; i--) {\r\n            uint next = i - 1;\r\n            uint nextPeriodStartingDebtIndex = _recentFeePeriodsStorage(next).startingDebtIndex;\r\n\r\n            // We can skip the period, as no debt minted during period (next period's startingDebtIndex is still 0)\r\n            if (nextPeriodStartingDebtIndex > 0 && lastFeeWithdrawal < _recentFeePeriodsStorage(i).feePeriodId) {\r\n                // We calculate a feePeriod's closingDebtIndex by looking at the next feePeriod's startingDebtIndex\r\n                // we can use the most recent issuanceData[0] for the current feePeriod\r\n                // else find the applicableIssuanceData for the feePeriod based on the StartingDebtIndex of the period\r\n                uint closingDebtIndex = uint256(nextPeriodStartingDebtIndex).sub(1);\r\n\r\n                // Gas optimisation - to reuse debtEntryIndex if found new applicable one\r\n                // if applicable is 0,0 (none found) we keep most recent one from issuanceData[0]\r\n                // return if userOwnershipPercentage = 0)\r\n                (userOwnershipPercentage, debtEntryIndex) = _feePoolState.applicableIssuanceData(account, closingDebtIndex);\r\n\r\n                (feesFromPeriod, rewardsFromPeriod) = _feesAndRewardsFromPeriod(i, userOwnershipPercentage, debtEntryIndex);\r\n\r\n                results[i][0] = feesFromPeriod;\r\n                results[i][1] = rewardsFromPeriod;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice ownershipPercentage is a high precision decimals uint based on\r\n     * wallet's debtPercentage. Gives a precise amount of the feesToDistribute\r\n     * for fees in the period. Precision factor is removed before results are\r\n     * returned.\r\n     * @dev The reported fees owing for the current period [0] are just a\r\n     * running balance until the fee period closes\r\n     */\r\n    function _feesAndRewardsFromPeriod(\r\n        uint period,\r\n        uint ownershipPercentage,\r\n        uint debtEntryIndex\r\n    ) internal view returns (uint, uint) {\r\n        // If it's zero, they haven't issued, and they have no fees OR rewards.\r\n        if (ownershipPercentage == 0) return (0, 0);\r\n\r\n        uint debtOwnershipForPeriod = ownershipPercentage;\r\n\r\n        // If period has closed we want to calculate debtPercentage for the period\r\n        if (period > 0) {\r\n            uint closingDebtIndex = uint256(_recentFeePeriodsStorage(period - 1).startingDebtIndex).sub(1);\r\n            debtOwnershipForPeriod = _effectiveDebtRatioForPeriod(closingDebtIndex, ownershipPercentage, debtEntryIndex);\r\n        }\r\n\r\n        // Calculate their percentage of the fees / rewards in this period\r\n        // This is a high precision integer.\r\n        uint feesFromPeriod = _recentFeePeriodsStorage(period).feesToDistribute.multiplyDecimal(debtOwnershipForPeriod);\r\n\r\n        uint rewardsFromPeriod =\r\n            _recentFeePeriodsStorage(period).rewardsToDistribute.multiplyDecimal(debtOwnershipForPeriod);\r\n\r\n        return (feesFromPeriod.preciseDecimalToDecimal(), rewardsFromPeriod.preciseDecimalToDecimal());\r\n    }\r\n\r\n    function _effectiveDebtRatioForPeriod(\r\n        uint closingDebtIndex,\r\n        uint ownershipPercentage,\r\n        uint debtEntryIndex\r\n    ) internal view returns (uint) {\r\n        // Figure out their global debt percentage delta at end of fee Period.\r\n        // This is a high precision integer.\r\n        ISynthetixState _synthetixState = synthetixState();\r\n        uint feePeriodDebtOwnership =\r\n            _synthetixState\r\n                .debtLedger(closingDebtIndex)\r\n                .divideDecimalRoundPrecise(_synthetixState.debtLedger(debtEntryIndex))\r\n                .multiplyDecimalRoundPrecise(ownershipPercentage);\r\n\r\n        return feePeriodDebtOwnership;\r\n    }\r\n\r\n    function effectiveDebtRatioForPeriod(address account, uint period) external view returns (uint) {\r\n        require(period != 0, \"Current period is not closed yet\");\r\n        require(period < FEE_PERIOD_LENGTH, \"Exceeds the FEE_PERIOD_LENGTH\");\r\n\r\n        // If the period being checked is uninitialised then return 0. This is only at the start of the system.\r\n        if (_recentFeePeriodsStorage(period - 1).startingDebtIndex == 0) return 0;\r\n\r\n        uint closingDebtIndex = uint256(_recentFeePeriodsStorage(period - 1).startingDebtIndex).sub(1);\r\n\r\n        uint ownershipPercentage;\r\n        uint debtEntryIndex;\r\n        (ownershipPercentage, debtEntryIndex) = feePoolState().applicableIssuanceData(account, closingDebtIndex);\r\n\r\n        // internal function will check closingDebtIndex has corresponding debtLedger entry\r\n        return _effectiveDebtRatioForPeriod(closingDebtIndex, ownershipPercentage, debtEntryIndex);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the feePeriodID of the last claim this account made\r\n     * @param _claimingAddress account to check the last fee period ID claim for\r\n     * @return uint of the feePeriodID this account last claimed\r\n     */\r\n    function getLastFeeWithdrawal(address _claimingAddress) public view returns (uint) {\r\n        return feePoolEternalStorage().getUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, _claimingAddress)));\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the collateral ratio before user is blocked from claiming.\r\n     */\r\n    function getPenaltyThresholdRatio() public view returns (uint) {\r\n        return getIssuanceRatio().multiplyDecimal(SafeDecimalMath.unit().add(getTargetThreshold()));\r\n    }\r\n\r\n    /**\r\n     * @notice Set the feePeriodID of the last claim this account made\r\n     * @param _claimingAddress account to set the last feePeriodID claim for\r\n     * @param _feePeriodID the feePeriodID this account claimed fees for\r\n     */\r\n    function _setLastFeeWithdrawal(address _claimingAddress, uint _feePeriodID) internal {\r\n        feePoolEternalStorage().setUIntValue(\r\n            keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, _claimingAddress)),\r\n            _feePeriodID\r\n        );\r\n    }\r\n\r\n    /* ========== Modifiers ========== */\r\n    modifier onlyInternalContracts {\r\n        bool isExchanger = msg.sender == address(exchanger());\r\n        bool isSynth = issuer().synthsByAddress(msg.sender) != bytes32(0);\r\n        bool isCollateral = collateralManager().hasCollateral(msg.sender);\r\n        bool isEtherWrapper = msg.sender == address(etherWrapper());\r\n        bool isWrapper = msg.sender == address(wrapperFactory());\r\n\r\n        require(isExchanger || isSynth || isCollateral || isEtherWrapper || isWrapper, \"Only Internal Contracts\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyIssuerAndSynthetixState {\r\n        bool isIssuer = msg.sender == address(issuer());\r\n        bool isSynthetixState = msg.sender == address(synthetixState());\r\n        require(isIssuer || isSynthetixState, \"Issuer and SynthetixState only\");\r\n        _;\r\n    }\r\n\r\n    modifier notFeeAddress(address account) {\r\n        require(account != FEE_ADDRESS, \"Fee address not allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier issuanceActive() {\r\n        systemStatus().requireIssuanceActive();\r\n        _;\r\n    }\r\n\r\n    /* ========== Proxy Events ========== */\r\n\r\n    event IssuanceDebtRatioEntry(\r\n        address indexed account,\r\n        uint debtRatio,\r\n        uint debtEntryIndex,\r\n        uint feePeriodStartingDebtIndex\r\n    );\r\n    bytes32 private constant ISSUANCEDEBTRATIOENTRY_SIG =\r\n        keccak256(\"IssuanceDebtRatioEntry(address,uint256,uint256,uint256)\");\r\n\r\n    function emitIssuanceDebtRatioEntry(\r\n        address account,\r\n        uint debtRatio,\r\n        uint debtEntryIndex,\r\n        uint feePeriodStartingDebtIndex\r\n    ) internal {\r\n        proxy._emit(\r\n            abi.encode(debtRatio, debtEntryIndex, feePeriodStartingDebtIndex),\r\n            2,\r\n            ISSUANCEDEBTRATIOENTRY_SIG,\r\n            bytes32(uint256(uint160(account))),\r\n            0,\r\n            0\r\n        );\r\n    }\r\n\r\n    event FeePeriodClosed(uint feePeriodId);\r\n    bytes32 private constant FEEPERIODCLOSED_SIG = keccak256(\"FeePeriodClosed(uint256)\");\r\n\r\n    function emitFeePeriodClosed(uint feePeriodId) internal {\r\n        proxy._emit(abi.encode(feePeriodId), 1, FEEPERIODCLOSED_SIG, 0, 0, 0);\r\n    }\r\n\r\n    event FeesClaimed(address account, uint sUSDAmount, uint snxRewards);\r\n    bytes32 private constant FEESCLAIMED_SIG = keccak256(\"FeesClaimed(address,uint256,uint256)\");\r\n\r\n    function emitFeesClaimed(\r\n        address account,\r\n        uint sUSDAmount,\r\n        uint snxRewards\r\n    ) internal {\r\n        proxy._emit(abi.encode(account, sUSDAmount, snxRewards), 1, FEESCLAIMED_SIG, 0, 0, 0);\r\n    }\r\n}\r\n\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value < 2**128, \"SafeCast: value doesn't fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value < 2**64, \"SafeCast: value doesn't fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value < 2**32, \"SafeCast: value doesn't fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value < 2**16, \"SafeCast: value doesn't fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value < 2**8, \"SafeCast: value doesn't fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/ihasbalance\r\ninterface IHasBalance {\r\n    // Views\r\n    function balanceOf(address account) external view returns (uint);\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/iliquidations\r\ninterface ILiquidations {\r\n    // Views\r\n    function isOpenForLiquidation(address account) external view returns (bool);\r\n\r\n    function getLiquidationDeadlineForAccount(address account) external view returns (uint);\r\n\r\n    function isLiquidationDeadlinePassed(address account) external view returns (bool);\r\n\r\n    function liquidationDelay() external view returns (uint);\r\n\r\n    function liquidationRatio() external view returns (uint);\r\n\r\n    function liquidationPenalty() external view returns (uint);\r\n\r\n    function calculateAmountToFixCollateral(uint debtBalance, uint collateral) external view returns (uint);\r\n\r\n    // Mutative Functions\r\n    function flagAccountForLiquidation(address account) external;\r\n\r\n    // Restricted: used internally to Synthetix\r\n    function removeAccountInLiquidation(address account) external;\r\n\r\n    function checkAndRemoveAccountInLiquidation(address account) external;\r\n}\r\n\r\n\r\ninterface ISynthRedeemer {\r\n    // Rate of redemption - 0 for none\r\n    function redemptions(address synthProxy) external view returns (uint redeemRate);\r\n\r\n    // sUSD balance of deprecated token holder\r\n    function balanceOf(IERC20 synthProxy, address account) external view returns (uint balanceOfInsUSD);\r\n\r\n    // Full sUSD supply of token\r\n    function totalSupply(IERC20 synthProxy) external view returns (uint totalSupplyInsUSD);\r\n\r\n    function redeem(IERC20 synthProxy) external;\r\n\r\n    function redeemAll(IERC20[] calldata synthProxies) external;\r\n\r\n    function redeemPartial(IERC20 synthProxy, uint amountOfSynth) external;\r\n\r\n    // Restricted to Issuer\r\n    function deprecate(IERC20 synthProxy, uint rateToRedeem) external;\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// Internal references\r\n\r\n\r\ninterface IProxy {\r\n    function target() external view returns (address);\r\n}\r\n\r\ninterface IIssuerInternalDebtCache {\r\n    function updateCachedSynthDebtWithRate(bytes32 currencyKey, uint currencyRate) external;\r\n\r\n    function updateCachedSynthDebtsWithRates(bytes32[] calldata currencyKeys, uint[] calldata currencyRates) external;\r\n\r\n    function updateDebtCacheValidity(bool currentlyInvalid) external;\r\n\r\n    function totalNonSnxBackedDebt() external view returns (uint excludedDebt, bool isInvalid);\r\n\r\n    function cacheInfo()\r\n        external\r\n        view\r\n        returns (\r\n            uint cachedDebt,\r\n            uint timestamp,\r\n            bool isInvalid,\r\n            bool isStale\r\n        );\r\n\r\n    function updateCachedsUSDDebt(int amount) external;\r\n}\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/issuer\r\ncontract Issuer is Owned, MixinSystemSettings, IIssuer {\r\n    using SafeMath for uint;\r\n    using SafeDecimalMath for uint;\r\n\r\n    bytes32 public constant CONTRACT_NAME = \"Issuer\";\r\n\r\n    // Available Synths which can be used with the system\r\n    ISynth[] public availableSynths;\r\n    mapping(bytes32 => ISynth) public synths;\r\n    mapping(address => bytes32) public synthsByAddress;\r\n\r\n    /* ========== ENCODED NAMES ========== */\r\n\r\n    bytes32 internal constant sUSD = \"sUSD\";\r\n    bytes32 internal constant sETH = \"sETH\";\r\n    bytes32 internal constant SNX = \"SNX\";\r\n\r\n    // Flexible storage names\r\n\r\n    bytes32 internal constant LAST_ISSUE_EVENT = \"lastIssueEvent\";\r\n\r\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\r\n\r\n    bytes32 private constant CONTRACT_SYNTHETIX = \"Synthetix\";\r\n    bytes32 private constant CONTRACT_EXCHANGER = \"Exchanger\";\r\n    bytes32 private constant CONTRACT_EXRATES = \"ExchangeRates\";\r\n    bytes32 private constant CONTRACT_SYNTHETIXSTATE = \"SynthetixState\";\r\n    bytes32 private constant CONTRACT_FEEPOOL = \"FeePool\";\r\n    bytes32 private constant CONTRACT_DELEGATEAPPROVALS = \"DelegateApprovals\";\r\n    bytes32 private constant CONTRACT_COLLATERALMANAGER = \"CollateralManager\";\r\n    bytes32 private constant CONTRACT_REWARDESCROW_V2 = \"RewardEscrowV2\";\r\n    bytes32 private constant CONTRACT_SYNTHETIXESCROW = \"SynthetixEscrow\";\r\n    bytes32 private constant CONTRACT_LIQUIDATIONS = \"Liquidations\";\r\n    bytes32 private constant CONTRACT_DEBTCACHE = \"DebtCache\";\r\n    bytes32 private constant CONTRACT_SYNTHREDEEMER = \"SynthRedeemer\";\r\n\r\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {}\r\n\r\n    /* ========== VIEWS ========== */\r\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\r\n        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();\r\n        bytes32[] memory newAddresses = new bytes32[](12);\r\n        newAddresses[0] = CONTRACT_SYNTHETIX;\r\n        newAddresses[1] = CONTRACT_EXCHANGER;\r\n        newAddresses[2] = CONTRACT_EXRATES;\r\n        newAddresses[3] = CONTRACT_SYNTHETIXSTATE;\r\n        newAddresses[4] = CONTRACT_FEEPOOL;\r\n        newAddresses[5] = CONTRACT_DELEGATEAPPROVALS;\r\n        newAddresses[6] = CONTRACT_REWARDESCROW_V2;\r\n        newAddresses[7] = CONTRACT_SYNTHETIXESCROW;\r\n        newAddresses[8] = CONTRACT_LIQUIDATIONS;\r\n        newAddresses[9] = CONTRACT_DEBTCACHE;\r\n        newAddresses[10] = CONTRACT_COLLATERALMANAGER;\r\n        newAddresses[11] = CONTRACT_SYNTHREDEEMER;\r\n        return combineArrays(existingAddresses, newAddresses);\r\n    }\r\n\r\n    function synthetix() internal view returns (ISynthetix) {\r\n        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));\r\n    }\r\n\r\n    function exchanger() internal view returns (IExchanger) {\r\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\r\n    }\r\n\r\n    function exchangeRates() internal view returns (IExchangeRates) {\r\n        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));\r\n    }\r\n\r\n    function synthetixState() internal view returns (ISynthetixState) {\r\n        return ISynthetixState(requireAndGetAddress(CONTRACT_SYNTHETIXSTATE));\r\n    }\r\n\r\n    function feePool() internal view returns (IFeePool) {\r\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));\r\n    }\r\n\r\n    function liquidations() internal view returns (ILiquidations) {\r\n        return ILiquidations(requireAndGetAddress(CONTRACT_LIQUIDATIONS));\r\n    }\r\n\r\n    function delegateApprovals() internal view returns (IDelegateApprovals) {\r\n        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));\r\n    }\r\n\r\n    function collateralManager() internal view returns (ICollateralManager) {\r\n        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));\r\n    }\r\n\r\n    function rewardEscrowV2() internal view returns (IRewardEscrowV2) {\r\n        return IRewardEscrowV2(requireAndGetAddress(CONTRACT_REWARDESCROW_V2));\r\n    }\r\n\r\n    function synthetixEscrow() internal view returns (IHasBalance) {\r\n        return IHasBalance(requireAndGetAddress(CONTRACT_SYNTHETIXESCROW));\r\n    }\r\n\r\n    function debtCache() internal view returns (IIssuerInternalDebtCache) {\r\n        return IIssuerInternalDebtCache(requireAndGetAddress(CONTRACT_DEBTCACHE));\r\n    }\r\n\r\n    function synthRedeemer() internal view returns (ISynthRedeemer) {\r\n        return ISynthRedeemer(requireAndGetAddress(CONTRACT_SYNTHREDEEMER));\r\n    }\r\n\r\n    function issuanceRatio() external view returns (uint) {\r\n        return getIssuanceRatio();\r\n    }\r\n\r\n    function _availableCurrencyKeysWithOptionalSNX(bool withSNX) internal view returns (bytes32[] memory) {\r\n        bytes32[] memory currencyKeys = new bytes32[](availableSynths.length + (withSNX ? 1 : 0));\r\n\r\n        for (uint i = 0; i < availableSynths.length; i++) {\r\n            currencyKeys[i] = synthsByAddress[address(availableSynths[i])];\r\n        }\r\n\r\n        if (withSNX) {\r\n            currencyKeys[availableSynths.length] = SNX;\r\n        }\r\n\r\n        return currencyKeys;\r\n    }\r\n\r\n    // Returns the total value of the debt pool in currency specified by `currencyKey`.\r\n    // To return only the SNX-backed debt, set `excludeCollateral` to true.\r\n    function _totalIssuedSynths(bytes32 currencyKey, bool excludeCollateral)\r\n        internal\r\n        view\r\n        returns (uint totalIssued, bool anyRateIsInvalid)\r\n    {\r\n        (uint debt, , bool cacheIsInvalid, bool cacheIsStale) = debtCache().cacheInfo();\r\n        anyRateIsInvalid = cacheIsInvalid || cacheIsStale;\r\n\r\n        IExchangeRates exRates = exchangeRates();\r\n\r\n        // Add total issued synths from non snx collateral back into the total if not excluded\r\n        if (!excludeCollateral) {\r\n            (uint nonSnxDebt, bool invalid) = debtCache().totalNonSnxBackedDebt();\r\n            debt = debt.add(nonSnxDebt);\r\n            anyRateIsInvalid = anyRateIsInvalid || invalid;\r\n        }\r\n\r\n        if (currencyKey == sUSD) {\r\n            return (debt, anyRateIsInvalid);\r\n        }\r\n\r\n        (uint currencyRate, bool currencyRateInvalid) = exRates.rateAndInvalid(currencyKey);\r\n        return (debt.divideDecimalRound(currencyRate), anyRateIsInvalid || currencyRateInvalid);\r\n    }\r\n\r\n    function _debtBalanceOfAndTotalDebt(address _issuer, bytes32 currencyKey)\r\n        internal\r\n        view\r\n        returns (\r\n            uint debtBalance,\r\n            uint totalSystemValue,\r\n            bool anyRateIsInvalid\r\n        )\r\n    {\r\n        ISynthetixState state = synthetixState();\r\n\r\n        // What was their initial debt ownership?\r\n        (uint initialDebtOwnership, uint debtEntryIndex) = state.issuanceData(_issuer);\r\n\r\n        // What's the total value of the system excluding ETH backed synths in their requested currency?\r\n        (totalSystemValue, anyRateIsInvalid) = _totalIssuedSynths(currencyKey, true);\r\n\r\n        // If it's zero, they haven't issued, and they have no debt.\r\n        // Note: it's more gas intensive to put this check here rather than before _totalIssuedSynths\r\n        // if they have 0 SNX, but it's a necessary trade-off\r\n        if (initialDebtOwnership == 0) return (0, totalSystemValue, anyRateIsInvalid);\r\n\r\n        // Figure out the global debt percentage delta from when they entered the system.\r\n        // This is a high precision integer of 27 (1e27) decimals.\r\n        uint currentDebtOwnership =\r\n            state\r\n                .lastDebtLedgerEntry()\r\n                .divideDecimalRoundPrecise(state.debtLedger(debtEntryIndex))\r\n                .multiplyDecimalRoundPrecise(initialDebtOwnership);\r\n\r\n        // Their debt balance is their portion of the total system value.\r\n        uint highPrecisionBalance =\r\n            totalSystemValue.decimalToPreciseDecimal().multiplyDecimalRoundPrecise(currentDebtOwnership);\r\n\r\n        // Convert back into 18 decimals (1e18)\r\n        debtBalance = highPrecisionBalance.preciseDecimalToDecimal();\r\n    }\r\n\r\n    function _canBurnSynths(address account) internal view returns (bool) {\r\n        return now >= _lastIssueEvent(account).add(getMinimumStakeTime());\r\n    }\r\n\r\n    function _lastIssueEvent(address account) internal view returns (uint) {\r\n        //  Get the timestamp of the last issue this account made\r\n        return flexibleStorage().getUIntValue(CONTRACT_NAME, keccak256(abi.encodePacked(LAST_ISSUE_EVENT, account)));\r\n    }\r\n\r\n    function _remainingIssuableSynths(address _issuer)\r\n        internal\r\n        view\r\n        returns (\r\n            uint maxIssuable,\r\n            uint alreadyIssued,\r\n            uint totalSystemDebt,\r\n            bool anyRateIsInvalid\r\n        )\r\n    {\r\n        (alreadyIssued, totalSystemDebt, anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(_issuer, sUSD);\r\n        (uint issuable, bool isInvalid) = _maxIssuableSynths(_issuer);\r\n        maxIssuable = issuable;\r\n        anyRateIsInvalid = anyRateIsInvalid || isInvalid;\r\n\r\n        if (alreadyIssued >= maxIssuable) {\r\n            maxIssuable = 0;\r\n        } else {\r\n            maxIssuable = maxIssuable.sub(alreadyIssued);\r\n        }\r\n    }\r\n\r\n    function _snxToUSD(uint amount, uint snxRate) internal pure returns (uint) {\r\n        return amount.multiplyDecimalRound(snxRate);\r\n    }\r\n\r\n    function _usdToSnx(uint amount, uint snxRate) internal pure returns (uint) {\r\n        return amount.divideDecimalRound(snxRate);\r\n    }\r\n\r\n    function _maxIssuableSynths(address _issuer) internal view returns (uint, bool) {\r\n        // What is the value of their SNX balance in sUSD\r\n        (uint snxRate, bool isInvalid) = exchangeRates().rateAndInvalid(SNX);\r\n        uint destinationValue = _snxToUSD(_collateral(_issuer), snxRate);\r\n\r\n        // They're allowed to issue up to issuanceRatio of that value\r\n        return (destinationValue.multiplyDecimal(getIssuanceRatio()), isInvalid);\r\n    }\r\n\r\n    function _collateralisationRatio(address _issuer) internal view returns (uint, bool) {\r\n        uint totalOwnedSynthetix = _collateral(_issuer);\r\n\r\n        (uint debtBalance, , bool anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(_issuer, SNX);\r\n\r\n        // it's more gas intensive to put this check here if they have 0 SNX, but it complies with the interface\r\n        if (totalOwnedSynthetix == 0) return (0, anyRateIsInvalid);\r\n\r\n        return (debtBalance.divideDecimalRound(totalOwnedSynthetix), anyRateIsInvalid);\r\n    }\r\n\r\n    function _collateral(address account) internal view returns (uint) {\r\n        uint balance = IERC20(address(synthetix())).balanceOf(account);\r\n\r\n        if (address(synthetixEscrow()) != address(0)) {\r\n            balance = balance.add(synthetixEscrow().balanceOf(account));\r\n        }\r\n\r\n        if (address(rewardEscrowV2()) != address(0)) {\r\n            balance = balance.add(rewardEscrowV2().balanceOf(account));\r\n        }\r\n\r\n        return balance;\r\n    }\r\n\r\n    function minimumStakeTime() external view returns (uint) {\r\n        return getMinimumStakeTime();\r\n    }\r\n\r\n    function canBurnSynths(address account) external view returns (bool) {\r\n        return _canBurnSynths(account);\r\n    }\r\n\r\n    function availableCurrencyKeys() external view returns (bytes32[] memory) {\r\n        return _availableCurrencyKeysWithOptionalSNX(false);\r\n    }\r\n\r\n    function availableSynthCount() external view returns (uint) {\r\n        return availableSynths.length;\r\n    }\r\n\r\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid) {\r\n        (, anyRateInvalid) = exchangeRates().ratesAndInvalidForCurrencies(_availableCurrencyKeysWithOptionalSNX(true));\r\n    }\r\n\r\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint totalIssued) {\r\n        (totalIssued, ) = _totalIssuedSynths(currencyKey, excludeOtherCollateral);\r\n    }\r\n\r\n    function lastIssueEvent(address account) external view returns (uint) {\r\n        return _lastIssueEvent(account);\r\n    }\r\n\r\n    function collateralisationRatio(address _issuer) external view returns (uint cratio) {\r\n        (cratio, ) = _collateralisationRatio(_issuer);\r\n    }\r\n\r\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\r\n        external\r\n        view\r\n        returns (uint cratio, bool anyRateIsInvalid)\r\n    {\r\n        return _collateralisationRatio(_issuer);\r\n    }\r\n\r\n    function collateral(address account) external view returns (uint) {\r\n        return _collateral(account);\r\n    }\r\n\r\n    function debtBalanceOf(address _issuer, bytes32 currencyKey) external view returns (uint debtBalance) {\r\n        ISynthetixState state = synthetixState();\r\n\r\n        // What was their initial debt ownership?\r\n        (uint initialDebtOwnership, ) = state.issuanceData(_issuer);\r\n\r\n        // If it's zero, they haven't issued, and they have no debt.\r\n        if (initialDebtOwnership == 0) return 0;\r\n\r\n        (debtBalance, , ) = _debtBalanceOfAndTotalDebt(_issuer, currencyKey);\r\n    }\r\n\r\n    function remainingIssuableSynths(address _issuer)\r\n        external\r\n        view\r\n        returns (\r\n            uint maxIssuable,\r\n            uint alreadyIssued,\r\n            uint totalSystemDebt\r\n        )\r\n    {\r\n        (maxIssuable, alreadyIssued, totalSystemDebt, ) = _remainingIssuableSynths(_issuer);\r\n    }\r\n\r\n    function maxIssuableSynths(address _issuer) external view returns (uint) {\r\n        (uint maxIssuable, ) = _maxIssuableSynths(_issuer);\r\n        return maxIssuable;\r\n    }\r\n\r\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\r\n        external\r\n        view\r\n        returns (uint transferable, bool anyRateIsInvalid)\r\n    {\r\n        // How many SNX do they have, excluding escrow?\r\n        // Note: We're excluding escrow here because we're interested in their transferable amount\r\n        // and escrowed SNX are not transferable.\r\n\r\n        // How many of those will be locked by the amount they've issued?\r\n        // Assuming issuance ratio is 20%, then issuing 20 SNX of value would require\r\n        // 100 SNX to be locked in their wallet to maintain their collateralisation ratio\r\n        // The locked synthetix value can exceed their balance.\r\n        uint debtBalance;\r\n        (debtBalance, , anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(account, SNX);\r\n        uint lockedSynthetixValue = debtBalance.divideDecimalRound(getIssuanceRatio());\r\n\r\n        // If we exceed the balance, no SNX are transferable, otherwise the difference is.\r\n        if (lockedSynthetixValue >= balance) {\r\n            transferable = 0;\r\n        } else {\r\n            transferable = balance.sub(lockedSynthetixValue);\r\n        }\r\n    }\r\n\r\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory) {\r\n        uint numKeys = currencyKeys.length;\r\n        ISynth[] memory addresses = new ISynth[](numKeys);\r\n\r\n        for (uint i = 0; i < numKeys; i++) {\r\n            addresses[i] = synths[currencyKeys[i]];\r\n        }\r\n\r\n        return addresses;\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    function _addSynth(ISynth synth) internal {\r\n        bytes32 currencyKey = synth.currencyKey();\r\n        require(synths[currencyKey] == ISynth(0), \"Synth exists\");\r\n        require(synthsByAddress[address(synth)] == bytes32(0), \"Synth address already exists\");\r\n\r\n        availableSynths.push(synth);\r\n        synths[currencyKey] = synth;\r\n        synthsByAddress[address(synth)] = currencyKey;\r\n\r\n        emit SynthAdded(currencyKey, address(synth));\r\n    }\r\n\r\n    function addSynth(ISynth synth) external onlyOwner {\r\n        _addSynth(synth);\r\n        // Invalidate the cache to force a snapshot to be recomputed. If a synth were to be added\r\n        // back to the system and it still somehow had cached debt, this would force the value to be\r\n        // updated.\r\n        debtCache().updateDebtCacheValidity(true);\r\n    }\r\n\r\n    function addSynths(ISynth[] calldata synthsToAdd) external onlyOwner {\r\n        uint numSynths = synthsToAdd.length;\r\n        for (uint i = 0; i < numSynths; i++) {\r\n            _addSynth(synthsToAdd[i]);\r\n        }\r\n\r\n        // Invalidate the cache to force a snapshot to be recomputed.\r\n        debtCache().updateDebtCacheValidity(true);\r\n    }\r\n\r\n    function _removeSynth(bytes32 currencyKey) internal {\r\n        address synthToRemove = address(synths[currencyKey]);\r\n        require(synthToRemove != address(0), \"Synth does not exist\");\r\n        require(currencyKey != sUSD, \"Cannot remove synth\");\r\n\r\n        uint synthSupply = IERC20(synthToRemove).totalSupply();\r\n\r\n        if (synthSupply > 0) {\r\n            (uint amountOfsUSD, uint rateToRedeem, ) =\r\n                exchangeRates().effectiveValueAndRates(currencyKey, synthSupply, \"sUSD\");\r\n            require(rateToRedeem > 0, \"Cannot remove synth to redeem without rate\");\r\n            ISynthRedeemer _synthRedeemer = synthRedeemer();\r\n            synths[sUSD].issue(address(_synthRedeemer), amountOfsUSD);\r\n            // ensure the debt cache is aware of the new sUSD issued\r\n            debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amountOfsUSD));\r\n            _synthRedeemer.deprecate(IERC20(address(Proxyable(address(synthToRemove)).proxy())), rateToRedeem);\r\n        }\r\n\r\n        // Remove the synth from the availableSynths array.\r\n        for (uint i = 0; i < availableSynths.length; i++) {\r\n            if (address(availableSynths[i]) == synthToRemove) {\r\n                delete availableSynths[i];\r\n\r\n                // Copy the last synth into the place of the one we just deleted\r\n                // If there's only one synth, this is synths[0] = synths[0].\r\n                // If we're deleting the last one, it's also a NOOP in the same way.\r\n                availableSynths[i] = availableSynths[availableSynths.length - 1];\r\n\r\n                // Decrease the size of the array by one.\r\n                availableSynths.length--;\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        // And remove it from the synths mapping\r\n        delete synthsByAddress[synthToRemove];\r\n        delete synths[currencyKey];\r\n\r\n        emit SynthRemoved(currencyKey, synthToRemove);\r\n    }\r\n\r\n    function removeSynth(bytes32 currencyKey) external onlyOwner {\r\n        // Remove its contribution from the debt pool snapshot, and\r\n        // invalidate the cache to force a new snapshot.\r\n        IIssuerInternalDebtCache cache = debtCache();\r\n        cache.updateCachedSynthDebtWithRate(currencyKey, 0);\r\n        cache.updateDebtCacheValidity(true);\r\n\r\n        _removeSynth(currencyKey);\r\n    }\r\n\r\n    function removeSynths(bytes32[] calldata currencyKeys) external onlyOwner {\r\n        uint numKeys = currencyKeys.length;\r\n\r\n        // Remove their contributions from the debt pool snapshot, and\r\n        // invalidate the cache to force a new snapshot.\r\n        IIssuerInternalDebtCache cache = debtCache();\r\n        uint[] memory zeroRates = new uint[](numKeys);\r\n        cache.updateCachedSynthDebtsWithRates(currencyKeys, zeroRates);\r\n        cache.updateDebtCacheValidity(true);\r\n\r\n        for (uint i = 0; i < numKeys; i++) {\r\n            _removeSynth(currencyKeys[i]);\r\n        }\r\n    }\r\n\r\n    function issueSynths(address from, uint amount) external onlySynthetix {\r\n        _issueSynths(from, amount, false);\r\n    }\r\n\r\n    function issueMaxSynths(address from) external onlySynthetix {\r\n        _issueSynths(from, 0, true);\r\n    }\r\n\r\n    function issueSynthsOnBehalf(\r\n        address issueForAddress,\r\n        address from,\r\n        uint amount\r\n    ) external onlySynthetix {\r\n        _requireCanIssueOnBehalf(issueForAddress, from);\r\n        _issueSynths(issueForAddress, amount, false);\r\n    }\r\n\r\n    function issueMaxSynthsOnBehalf(address issueForAddress, address from) external onlySynthetix {\r\n        _requireCanIssueOnBehalf(issueForAddress, from);\r\n        _issueSynths(issueForAddress, 0, true);\r\n    }\r\n\r\n    function burnSynths(address from, uint amount) external onlySynthetix {\r\n        _voluntaryBurnSynths(from, amount, false);\r\n    }\r\n\r\n    function burnSynthsOnBehalf(\r\n        address burnForAddress,\r\n        address from,\r\n        uint amount\r\n    ) external onlySynthetix {\r\n        _requireCanBurnOnBehalf(burnForAddress, from);\r\n        _voluntaryBurnSynths(burnForAddress, amount, false);\r\n    }\r\n\r\n    function burnSynthsToTarget(address from) external onlySynthetix {\r\n        _voluntaryBurnSynths(from, 0, true);\r\n    }\r\n\r\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external onlySynthetix {\r\n        _requireCanBurnOnBehalf(burnForAddress, from);\r\n        _voluntaryBurnSynths(burnForAddress, 0, true);\r\n    }\r\n\r\n    function burnForRedemption(\r\n        address deprecatedSynthProxy,\r\n        address account,\r\n        uint balance\r\n    ) external onlySynthRedeemer {\r\n        ISynth(IProxy(deprecatedSynthProxy).target()).burn(account, balance);\r\n    }\r\n\r\n    function liquidateDelinquentAccount(\r\n        address account,\r\n        uint susdAmount,\r\n        address liquidator\r\n    ) external onlySynthetix returns (uint totalRedeemed, uint amountToLiquidate) {\r\n        // Ensure waitingPeriod and sUSD balance is settled as burning impacts the size of debt pool\r\n        require(!exchanger().hasWaitingPeriodOrSettlementOwing(liquidator, sUSD), \"sUSD needs to be settled\");\r\n\r\n        // Check account is liquidation open\r\n        require(liquidations().isOpenForLiquidation(account), \"Account not open for liquidation\");\r\n\r\n        // require liquidator has enough sUSD\r\n        require(IERC20(address(synths[sUSD])).balanceOf(liquidator) >= susdAmount, \"Not enough sUSD\");\r\n\r\n        uint liquidationPenalty = liquidations().liquidationPenalty();\r\n\r\n        // What is their debt in sUSD?\r\n        (uint debtBalance, uint totalDebtIssued, bool anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(account, sUSD);\r\n        (uint snxRate, bool snxRateInvalid) = exchangeRates().rateAndInvalid(SNX);\r\n        _requireRatesNotInvalid(anyRateIsInvalid || snxRateInvalid);\r\n\r\n        uint collateralForAccount = _collateral(account);\r\n        uint amountToFixRatio =\r\n            liquidations().calculateAmountToFixCollateral(debtBalance, _snxToUSD(collateralForAccount, snxRate));\r\n\r\n        // Cap amount to liquidate to repair collateral ratio based on issuance ratio\r\n        amountToLiquidate = amountToFixRatio < susdAmount ? amountToFixRatio : susdAmount;\r\n\r\n        // what's the equivalent amount of snx for the amountToLiquidate?\r\n        uint snxRedeemed = _usdToSnx(amountToLiquidate, snxRate);\r\n\r\n        // Add penalty\r\n        totalRedeemed = snxRedeemed.multiplyDecimal(SafeDecimalMath.unit().add(liquidationPenalty));\r\n\r\n        // if total SNX to redeem is greater than account's collateral\r\n        // account is under collateralised, liquidate all collateral and reduce sUSD to burn\r\n        if (totalRedeemed > collateralForAccount) {\r\n            // set totalRedeemed to all transferable collateral\r\n            totalRedeemed = collateralForAccount;\r\n\r\n            // whats the equivalent sUSD to burn for all collateral less penalty\r\n            amountToLiquidate = _snxToUSD(\r\n                collateralForAccount.divideDecimal(SafeDecimalMath.unit().add(liquidationPenalty)),\r\n                snxRate\r\n            );\r\n        }\r\n\r\n        // burn sUSD from messageSender (liquidator) and reduce account's debt\r\n        _burnSynths(account, liquidator, amountToLiquidate, debtBalance, totalDebtIssued);\r\n\r\n        // Remove liquidation flag if amount liquidated fixes ratio\r\n        if (amountToLiquidate == amountToFixRatio) {\r\n            // Remove liquidation\r\n            liquidations().removeAccountInLiquidation(account);\r\n        }\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    function _requireRatesNotInvalid(bool anyRateIsInvalid) internal pure {\r\n        require(!anyRateIsInvalid, \"A synth or SNX rate is invalid\");\r\n    }\r\n\r\n    function _requireCanIssueOnBehalf(address issueForAddress, address from) internal view {\r\n        require(delegateApprovals().canIssueFor(issueForAddress, from), \"Not approved to act on behalf\");\r\n    }\r\n\r\n    function _requireCanBurnOnBehalf(address burnForAddress, address from) internal view {\r\n        require(delegateApprovals().canBurnFor(burnForAddress, from), \"Not approved to act on behalf\");\r\n    }\r\n\r\n    function _issueSynths(\r\n        address from,\r\n        uint amount,\r\n        bool issueMax\r\n    ) internal {\r\n        (uint maxIssuable, uint existingDebt, uint totalSystemDebt, bool anyRateIsInvalid) = _remainingIssuableSynths(from);\r\n        _requireRatesNotInvalid(anyRateIsInvalid);\r\n\r\n        if (!issueMax) {\r\n            require(amount <= maxIssuable, \"Amount too large\");\r\n        } else {\r\n            amount = maxIssuable;\r\n        }\r\n\r\n        // Keep track of the debt they're about to create\r\n        _addToDebtRegister(from, amount, existingDebt, totalSystemDebt);\r\n\r\n        // record issue timestamp\r\n        _setLastIssueEvent(from);\r\n\r\n        // Create their synths\r\n        synths[sUSD].issue(from, amount);\r\n\r\n        // Account for the issued debt in the cache\r\n        debtCache().updateCachedsUSDDebt(SafeCast.toInt256(amount));\r\n\r\n        // Store their locked SNX amount to determine their fee % for the period\r\n        _appendAccountIssuanceRecord(from);\r\n    }\r\n\r\n    function _burnSynths(\r\n        address debtAccount,\r\n        address burnAccount,\r\n        uint amount,\r\n        uint existingDebt,\r\n        uint totalDebtIssued\r\n    ) internal returns (uint amountBurnt) {\r\n        // liquidation requires sUSD to be already settled / not in waiting period\r\n\r\n        // If they're trying to burn more debt than they actually owe, rather than fail the transaction, let's just\r\n        // clear their debt and leave them be.\r\n        amountBurnt = existingDebt < amount ? existingDebt : amount;\r\n\r\n        // Remove liquidated debt from the ledger\r\n        _removeFromDebtRegister(debtAccount, amountBurnt, existingDebt, totalDebtIssued);\r\n\r\n        // synth.burn does a safe subtraction on balance (so it will revert if there are not enough synths).\r\n        synths[sUSD].burn(burnAccount, amountBurnt);\r\n\r\n        // Account for the burnt debt in the cache.\r\n        debtCache().updateCachedsUSDDebt(-SafeCast.toInt256(amountBurnt));\r\n\r\n        // Store their debtRatio against a fee period to determine their fee/rewards % for the period\r\n        _appendAccountIssuanceRecord(debtAccount);\r\n    }\r\n\r\n    // If burning to target, `amount` is ignored, and the correct quantity of sUSD is burnt to reach the target\r\n    // c-ratio, allowing fees to be claimed. In this case, pending settlements will be skipped as the user\r\n    // will still have debt remaining after reaching their target.\r\n    function _voluntaryBurnSynths(\r\n        address from,\r\n        uint amount,\r\n        bool burnToTarget\r\n    ) internal {\r\n        if (!burnToTarget) {\r\n            // If not burning to target, then burning requires that the minimum stake time has elapsed.\r\n            require(_canBurnSynths(from), \"Minimum stake time not reached\");\r\n            // First settle anything pending into sUSD as burning or issuing impacts the size of the debt pool\r\n            (, uint refunded, uint numEntriesSettled) = exchanger().settle(from, sUSD);\r\n            if (numEntriesSettled > 0) {\r\n                amount = exchanger().calculateAmountAfterSettlement(from, sUSD, amount, refunded);\r\n            }\r\n        }\r\n\r\n        (uint existingDebt, uint totalSystemValue, bool anyRateIsInvalid) = _debtBalanceOfAndTotalDebt(from, sUSD);\r\n        (uint maxIssuableSynthsForAccount, bool snxRateInvalid) = _maxIssuableSynths(from);\r\n        _requireRatesNotInvalid(anyRateIsInvalid || snxRateInvalid);\r\n        require(existingDebt > 0, \"No debt to forgive\");\r\n\r\n        if (burnToTarget) {\r\n            amount = existingDebt.sub(maxIssuableSynthsForAccount);\r\n        }\r\n\r\n        uint amountBurnt = _burnSynths(from, from, amount, existingDebt, totalSystemValue);\r\n\r\n        // Check and remove liquidation if existingDebt after burning is <= maxIssuableSynths\r\n        // Issuance ratio is fixed so should remove any liquidations\r\n        if (existingDebt.sub(amountBurnt) <= maxIssuableSynthsForAccount) {\r\n            liquidations().removeAccountInLiquidation(from);\r\n        }\r\n    }\r\n\r\n    function _setLastIssueEvent(address account) internal {\r\n        // Set the timestamp of the last issueSynths\r\n        flexibleStorage().setUIntValue(\r\n            CONTRACT_NAME,\r\n            keccak256(abi.encodePacked(LAST_ISSUE_EVENT, account)),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function _appendAccountIssuanceRecord(address from) internal {\r\n        uint initialDebtOwnership;\r\n        uint debtEntryIndex;\r\n        (initialDebtOwnership, debtEntryIndex) = synthetixState().issuanceData(from);\r\n        feePool().appendAccountIssuanceRecord(from, initialDebtOwnership, debtEntryIndex);\r\n    }\r\n\r\n    function _addToDebtRegister(\r\n        address from,\r\n        uint amount,\r\n        uint existingDebt,\r\n        uint totalDebtIssued\r\n    ) internal {\r\n        ISynthetixState state = synthetixState();\r\n\r\n        // What will the new total be including the new value?\r\n        uint newTotalDebtIssued = amount.add(totalDebtIssued);\r\n\r\n        // What is their percentage (as a high precision int) of the total debt?\r\n        uint debtPercentage = amount.divideDecimalRoundPrecise(newTotalDebtIssued);\r\n\r\n        // And what effect does this percentage change have on the global debt holding of other issuers?\r\n        // The delta specifically needs to not take into account any existing debt as it's already\r\n        // accounted for in the delta from when they issued previously.\r\n        // The delta is a high precision integer.\r\n        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);\r\n\r\n        // And what does their debt ownership look like including this previous stake?\r\n        if (existingDebt > 0) {\r\n            debtPercentage = amount.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);\r\n        } else {\r\n            // If they have no debt, they're a new issuer; record this.\r\n            state.incrementTotalIssuerCount();\r\n        }\r\n\r\n        // Save the debt entry parameters\r\n        state.setCurrentIssuanceData(from, debtPercentage);\r\n\r\n        // And if we're the first, push 1 as there was no effect to any other holders, otherwise push\r\n        // the change for the rest of the debt holders. The debt ledger holds high precision integers.\r\n        if (state.debtLedgerLength() > 0) {\r\n            state.appendDebtLedgerValue(state.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta));\r\n        } else {\r\n            state.appendDebtLedgerValue(SafeDecimalMath.preciseUnit());\r\n        }\r\n    }\r\n\r\n    function _removeFromDebtRegister(\r\n        address from,\r\n        uint debtToRemove,\r\n        uint existingDebt,\r\n        uint totalDebtIssued\r\n    ) internal {\r\n        ISynthetixState state = synthetixState();\r\n\r\n        // What will the new total after taking out the withdrawn amount\r\n        uint newTotalDebtIssued = totalDebtIssued.sub(debtToRemove);\r\n\r\n        uint delta = 0;\r\n\r\n        // What will the debt delta be if there is any debt left?\r\n        // Set delta to 0 if no more debt left in system after user\r\n        if (newTotalDebtIssued > 0) {\r\n            // What is the percentage of the withdrawn debt (as a high precision int) of the total debt after?\r\n            uint debtPercentage = debtToRemove.divideDecimalRoundPrecise(newTotalDebtIssued);\r\n\r\n            // And what effect does this percentage change have on the global debt holding of other issuers?\r\n            // The delta specifically needs to not take into account any existing debt as it's already\r\n            // accounted for in the delta from when they issued previously.\r\n            delta = SafeDecimalMath.preciseUnit().add(debtPercentage);\r\n        }\r\n\r\n        // Are they exiting the system, or are they just decreasing their debt position?\r\n        if (debtToRemove == existingDebt) {\r\n            state.setCurrentIssuanceData(from, 0);\r\n            state.decrementTotalIssuerCount();\r\n        } else {\r\n            // What percentage of the debt will they be left with?\r\n            uint newDebt = existingDebt.sub(debtToRemove);\r\n            uint newDebtPercentage = newDebt.divideDecimalRoundPrecise(newTotalDebtIssued);\r\n\r\n            // Store the debt percentage and debt ledger as high precision integers\r\n            state.setCurrentIssuanceData(from, newDebtPercentage);\r\n        }\r\n\r\n        // Update our cumulative ledger. This is also a high precision integer.\r\n        state.appendDebtLedgerValue(state.lastDebtLedgerEntry().multiplyDecimalRoundPrecise(delta));\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    function _onlySynthetix() internal view {\r\n        require(msg.sender == address(synthetix()), \"Issuer: Only the synthetix contract can perform this action\");\r\n    }\r\n\r\n    modifier onlySynthetix() {\r\n        _onlySynthetix(); // Use an internal function to save code size.\r\n        _;\r\n    }\r\n\r\n    function _onlySynthRedeemer() internal view {\r\n        require(msg.sender == address(synthRedeemer()), \"Issuer: Only the SynthRedeemer contract can perform this action\");\r\n    }\r\n\r\n    modifier onlySynthRedeemer() {\r\n        _onlySynthRedeemer();\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event SynthAdded(bytes32 currencyKey, address synth);\r\n    event SynthRemoved(bytes32 currencyKey, address synth);\r\n}\r\n\r\n\r\ncontract LegacyOwned {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    constructor(address _owner) public {\r\n        owner = _owner;\r\n    }\r\n\r\n    function nominateOwner(address _owner) external onlyOwner {\r\n        nominatedOwner = _owner;\r\n        emit OwnerNominated(_owner);\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        require(msg.sender == nominatedOwner);\r\n        emit OwnerChanged(owner, nominatedOwner);\r\n        owner = nominatedOwner;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    event OwnerNominated(address newOwner);\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n}\r\n\r\n\r\ncontract LegacyTokenState is LegacyOwned {\r\n    // the address of the contract that can modify balances and allowances\r\n    // this can only be changed by the owner of this contract\r\n    address public associatedContract;\r\n\r\n    // ERC20 fields.\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    constructor(address _owner, address _associatedContract) public LegacyOwned(_owner) {\r\n        associatedContract = _associatedContract;\r\n        emit AssociatedContractUpdated(_associatedContract);\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    // Change the associated contract to a new address\r\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\r\n        associatedContract = _associatedContract;\r\n        emit AssociatedContractUpdated(_associatedContract);\r\n    }\r\n\r\n    function setAllowance(\r\n        address tokenOwner,\r\n        address spender,\r\n        uint value\r\n    ) external onlyAssociatedContract {\r\n        allowance[tokenOwner][spender] = value;\r\n    }\r\n\r\n    function setBalanceOf(address account, uint value) external onlyAssociatedContract {\r\n        balanceOf[account] = value;\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyAssociatedContract {\r\n        require(msg.sender == associatedContract);\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event AssociatedContractUpdated(address _associatedContract);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/tokenstate\r\ncontract TokenState is Owned, State {\r\n    /* ERC20 fields. */\r\n    mapping(address => uint) public balanceOf;\r\n    mapping(address => mapping(address => uint)) public allowance;\r\n\r\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    /**\r\n     * @notice Set ERC20 allowance.\r\n     * @dev Only the associated contract may call this.\r\n     * @param tokenOwner The authorising party.\r\n     * @param spender The authorised party.\r\n     * @param value The total value the authorised party may spend on the\r\n     * authorising party's behalf.\r\n     */\r\n    function setAllowance(\r\n        address tokenOwner,\r\n        address spender,\r\n        uint value\r\n    ) external onlyAssociatedContract {\r\n        allowance[tokenOwner][spender] = value;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the balance in a given account\r\n     * @dev Only the associated contract may call this.\r\n     * @param account The account whose value to set.\r\n     * @param value The new balance of the given account.\r\n     */\r\n    function setBalanceOf(address account, uint value) external onlyAssociatedContract {\r\n        balanceOf[account] = value;\r\n    }\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/externstatetoken\r\ncontract ExternStateToken is Owned, Proxyable {\r\n    using SafeMath for uint;\r\n    using SafeDecimalMath for uint;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    /* Stores balances and allowances. */\r\n    TokenState public tokenState;\r\n\r\n    /* Other ERC20 fields. */\r\n    string public name;\r\n    string public symbol;\r\n    uint public totalSupply;\r\n    uint8 public decimals;\r\n\r\n    constructor(\r\n        address payable _proxy,\r\n        TokenState _tokenState,\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint _totalSupply,\r\n        uint8 _decimals,\r\n        address _owner\r\n    ) public Owned(_owner) Proxyable(_proxy) {\r\n        tokenState = _tokenState;\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n        totalSupply = _totalSupply;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    /**\r\n     * @notice Returns the ERC20 allowance of one party to spend on behalf of another.\r\n     * @param owner The party authorising spending of their funds.\r\n     * @param spender The party spending tokenOwner's funds.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint) {\r\n        return tokenState.allowance(owner, spender);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the ERC20 token balance of a given account.\r\n     */\r\n    function balanceOf(address account) external view returns (uint) {\r\n        return tokenState.balanceOf(account);\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Set the address of the TokenState contract.\r\n     * @dev This can be used to \"pause\" transfer functionality, by pointing the tokenState at 0x000..\r\n     * as balances would be unreachable.\r\n     */\r\n    function setTokenState(TokenState _tokenState) external optionalProxy_onlyOwner {\r\n        tokenState = _tokenState;\r\n        emitTokenStateUpdated(address(_tokenState));\r\n    }\r\n\r\n    function _internalTransfer(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) internal returns (bool) {\r\n        /* Disallow transfers to irretrievable-addresses. */\r\n        require(to != address(0) && to != address(this) && to != address(proxy), \"Cannot transfer to this address\");\r\n\r\n        // Insufficient balance will be handled by the safe subtraction.\r\n        tokenState.setBalanceOf(from, tokenState.balanceOf(from).sub(value));\r\n        tokenState.setBalanceOf(to, tokenState.balanceOf(to).add(value));\r\n\r\n        // Emit a standard ERC20 transfer event\r\n        emitTransfer(from, to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Perform an ERC20 token transfer. Designed to be called by transfer functions possessing\r\n     * the onlyProxy or optionalProxy modifiers.\r\n     */\r\n    function _transferByProxy(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) internal returns (bool) {\r\n        return _internalTransfer(from, to, value);\r\n    }\r\n\r\n    /*\r\n     * @dev Perform an ERC20 token transferFrom. Designed to be called by transferFrom functions\r\n     * possessing the optionalProxy or optionalProxy modifiers.\r\n     */\r\n    function _transferFromByProxy(\r\n        address sender,\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) internal returns (bool) {\r\n        /* Insufficient allowance will be handled by the safe subtraction. */\r\n        tokenState.setAllowance(from, sender, tokenState.allowance(from, sender).sub(value));\r\n        return _internalTransfer(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @notice Approves spender to transfer on the message sender's behalf.\r\n     */\r\n    function approve(address spender, uint value) public optionalProxy returns (bool) {\r\n        address sender = messageSender;\r\n\r\n        tokenState.setAllowance(sender, spender, value);\r\n        emitApproval(sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n    function addressToBytes32(address input) internal pure returns (bytes32) {\r\n        return bytes32(uint256(uint160(input)));\r\n    }\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    bytes32 internal constant TRANSFER_SIG = keccak256(\"Transfer(address,address,uint256)\");\r\n\r\n    function emitTransfer(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) internal {\r\n        proxy._emit(abi.encode(value), 3, TRANSFER_SIG, addressToBytes32(from), addressToBytes32(to), 0);\r\n    }\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    bytes32 internal constant APPROVAL_SIG = keccak256(\"Approval(address,address,uint256)\");\r\n\r\n    function emitApproval(\r\n        address owner,\r\n        address spender,\r\n        uint value\r\n    ) internal {\r\n        proxy._emit(abi.encode(value), 3, APPROVAL_SIG, addressToBytes32(owner), addressToBytes32(spender), 0);\r\n    }\r\n\r\n    event TokenStateUpdated(address newTokenState);\r\n    bytes32 internal constant TOKENSTATEUPDATED_SIG = keccak256(\"TokenStateUpdated(address)\");\r\n\r\n    function emitTokenStateUpdated(address newTokenState) internal {\r\n        proxy._emit(abi.encode(newTokenState), 1, TOKENSTATEUPDATED_SIG, 0, 0, 0);\r\n    }\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/synth\r\ncontract Synth is Owned, IERC20, ExternStateToken, MixinResolver, ISynth {\r\n    bytes32 public constant CONTRACT_NAME = \"Synth\";\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    // Currency key which identifies this Synth to the Synthetix system\r\n    bytes32 public currencyKey;\r\n\r\n    uint8 public constant DECIMALS = 18;\r\n\r\n    // Where fees are pooled in sUSD\r\n    address public constant FEE_ADDRESS = 0xfeEFEEfeefEeFeefEEFEEfEeFeefEEFeeFEEFEeF;\r\n\r\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\r\n\r\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\r\n    bytes32 private constant CONTRACT_EXCHANGER = \"Exchanger\";\r\n    bytes32 private constant CONTRACT_ISSUER = \"Issuer\";\r\n    bytes32 private constant CONTRACT_FEEPOOL = \"FeePool\";\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor(\r\n        address payable _proxy,\r\n        TokenState _tokenState,\r\n        string memory _tokenName,\r\n        string memory _tokenSymbol,\r\n        address _owner,\r\n        bytes32 _currencyKey,\r\n        uint _totalSupply,\r\n        address _resolver\r\n    )\r\n        public\r\n        ExternStateToken(_proxy, _tokenState, _tokenName, _tokenSymbol, _totalSupply, DECIMALS, _owner)\r\n        MixinResolver(_resolver)\r\n    {\r\n        require(_proxy != address(0), \"_proxy cannot be 0\");\r\n        require(_owner != address(0), \"_owner cannot be 0\");\r\n\r\n        currencyKey = _currencyKey;\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    function transfer(address to, uint value) public optionalProxy returns (bool) {\r\n        _ensureCanTransfer(messageSender, value);\r\n\r\n        // transfers to FEE_ADDRESS will be exchanged into sUSD and recorded as fee\r\n        if (to == FEE_ADDRESS) {\r\n            return _transferToFeeAddress(to, value);\r\n        }\r\n\r\n        // transfers to 0x address will be burned\r\n        if (to == address(0)) {\r\n            return _internalBurn(messageSender, value);\r\n        }\r\n\r\n        return super._internalTransfer(messageSender, to, value);\r\n    }\r\n\r\n    function transferAndSettle(address to, uint value) public optionalProxy returns (bool) {\r\n        // Exchanger.settle ensures synth is active\r\n        (, , uint numEntriesSettled) = exchanger().settle(messageSender, currencyKey);\r\n\r\n        // Save gas instead of calling transferableSynths\r\n        uint balanceAfter = value;\r\n\r\n        if (numEntriesSettled > 0) {\r\n            balanceAfter = tokenState.balanceOf(messageSender);\r\n        }\r\n\r\n        // Reduce the value to transfer if balance is insufficient after reclaimed\r\n        value = value > balanceAfter ? balanceAfter : value;\r\n\r\n        return super._internalTransfer(messageSender, to, value);\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) public optionalProxy returns (bool) {\r\n        _ensureCanTransfer(from, value);\r\n\r\n        return _internalTransferFrom(from, to, value);\r\n    }\r\n\r\n    function transferFromAndSettle(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) public optionalProxy returns (bool) {\r\n        // Exchanger.settle() ensures synth is active\r\n        (, , uint numEntriesSettled) = exchanger().settle(from, currencyKey);\r\n\r\n        // Save gas instead of calling transferableSynths\r\n        uint balanceAfter = value;\r\n\r\n        if (numEntriesSettled > 0) {\r\n            balanceAfter = tokenState.balanceOf(from);\r\n        }\r\n\r\n        // Reduce the value to transfer if balance is insufficient after reclaimed\r\n        value = value >= balanceAfter ? balanceAfter : value;\r\n\r\n        return _internalTransferFrom(from, to, value);\r\n    }\r\n\r\n    /**\r\n     * @notice _transferToFeeAddress function\r\n     * non-sUSD synths are exchanged into sUSD via synthInitiatedExchange\r\n     * notify feePool to record amount as fee paid to feePool */\r\n    function _transferToFeeAddress(address to, uint value) internal returns (bool) {\r\n        uint amountInUSD;\r\n\r\n        // sUSD can be transferred to FEE_ADDRESS directly\r\n        if (currencyKey == \"sUSD\") {\r\n            amountInUSD = value;\r\n            super._internalTransfer(messageSender, to, value);\r\n        } else {\r\n            // else exchange synth into sUSD and send to FEE_ADDRESS\r\n            (amountInUSD, ) = exchanger().exchange(\r\n                messageSender,\r\n                messageSender,\r\n                currencyKey,\r\n                value,\r\n                \"sUSD\",\r\n                FEE_ADDRESS,\r\n                false,\r\n                address(0),\r\n                bytes32(0)\r\n            );\r\n        }\r\n\r\n        // Notify feePool to record sUSD to distribute as fees\r\n        feePool().recordFeePaid(amountInUSD);\r\n\r\n        return true;\r\n    }\r\n\r\n    function issue(address account, uint amount) external onlyInternalContracts {\r\n        _internalIssue(account, amount);\r\n    }\r\n\r\n    function burn(address account, uint amount) external onlyInternalContracts {\r\n        _internalBurn(account, amount);\r\n    }\r\n\r\n    function _internalIssue(address account, uint amount) internal {\r\n        tokenState.setBalanceOf(account, tokenState.balanceOf(account).add(amount));\r\n        totalSupply = totalSupply.add(amount);\r\n        emitTransfer(address(0), account, amount);\r\n        emitIssued(account, amount);\r\n    }\r\n\r\n    function _internalBurn(address account, uint amount) internal returns (bool) {\r\n        tokenState.setBalanceOf(account, tokenState.balanceOf(account).sub(amount));\r\n        totalSupply = totalSupply.sub(amount);\r\n        emitTransfer(account, address(0), amount);\r\n        emitBurned(account, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    // Allow owner to set the total supply on import.\r\n    function setTotalSupply(uint amount) external optionalProxy_onlyOwner {\r\n        totalSupply = amount;\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    // Note: use public visibility so that it can be invoked in a subclass\r\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\r\n        addresses = new bytes32[](4);\r\n        addresses[0] = CONTRACT_SYSTEMSTATUS;\r\n        addresses[1] = CONTRACT_EXCHANGER;\r\n        addresses[2] = CONTRACT_ISSUER;\r\n        addresses[3] = CONTRACT_FEEPOOL;\r\n    }\r\n\r\n    function systemStatus() internal view returns (ISystemStatus) {\r\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\r\n    }\r\n\r\n    function feePool() internal view returns (IFeePool) {\r\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));\r\n    }\r\n\r\n    function exchanger() internal view returns (IExchanger) {\r\n        return IExchanger(requireAndGetAddress(CONTRACT_EXCHANGER));\r\n    }\r\n\r\n    function issuer() internal view returns (IIssuer) {\r\n        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));\r\n    }\r\n\r\n    function _ensureCanTransfer(address from, uint value) internal view {\r\n        require(exchanger().maxSecsLeftInWaitingPeriod(from, currencyKey) == 0, \"Cannot transfer during waiting period\");\r\n        require(transferableSynths(from) >= value, \"Insufficient balance after any settlement owing\");\r\n        systemStatus().requireSynthActive(currencyKey);\r\n    }\r\n\r\n    function transferableSynths(address account) public view returns (uint) {\r\n        (uint reclaimAmount, , ) = exchanger().settlementOwing(account, currencyKey);\r\n\r\n        // Note: ignoring rebate amount here because a settle() is required in order to\r\n        // allow the transfer to actually work\r\n\r\n        uint balance = tokenState.balanceOf(account);\r\n\r\n        if (reclaimAmount > balance) {\r\n            return 0;\r\n        } else {\r\n            return balance.sub(reclaimAmount);\r\n        }\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    function _internalTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint value\r\n    ) internal returns (bool) {\r\n        // Skip allowance update in case of infinite allowance\r\n        if (tokenState.allowance(from, messageSender) != uint(-1)) {\r\n            // Reduce the allowance by the amount we're transferring.\r\n            // The safeSub call will handle an insufficient allowance.\r\n            tokenState.setAllowance(from, messageSender, tokenState.allowance(from, messageSender).sub(value));\r\n        }\r\n\r\n        return super._internalTransfer(from, to, value);\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyInternalContracts() {\r\n        bool isFeePool = msg.sender == address(feePool());\r\n        bool isExchanger = msg.sender == address(exchanger());\r\n        bool isIssuer = msg.sender == address(issuer());\r\n\r\n        require(isFeePool || isExchanger || isIssuer, \"Only FeePool, Exchanger or Issuer contracts allowed\");\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n    event Issued(address indexed account, uint value);\r\n    bytes32 private constant ISSUED_SIG = keccak256(\"Issued(address,uint256)\");\r\n\r\n    function emitIssued(address account, uint value) internal {\r\n        proxy._emit(abi.encode(value), 2, ISSUED_SIG, addressToBytes32(account), 0, 0);\r\n    }\r\n\r\n    event Burned(address indexed account, uint value);\r\n    bytes32 private constant BURNED_SIG = keccak256(\"Burned(address,uint256)\");\r\n\r\n    function emitBurned(address account, uint value) internal {\r\n        proxy._emit(abi.encode(value), 2, BURNED_SIG, addressToBytes32(account), 0, 0);\r\n    }\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/multicollateralsynth\r\ncontract MultiCollateralSynth is Synth {\r\n    bytes32 public constant CONTRACT_NAME = \"MultiCollateralSynth\";\r\n\r\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\r\n\r\n    bytes32 private constant CONTRACT_COLLATERALMANAGER = \"CollateralManager\";\r\n    bytes32 private constant CONTRACT_ETHER_WRAPPER = \"EtherWrapper\";\r\n    bytes32 private constant CONTRACT_WRAPPER_FACTORY = \"WrapperFactory\";\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor(\r\n        address payable _proxy,\r\n        TokenState _tokenState,\r\n        string memory _tokenName,\r\n        string memory _tokenSymbol,\r\n        address _owner,\r\n        bytes32 _currencyKey,\r\n        uint _totalSupply,\r\n        address _resolver\r\n    ) public Synth(_proxy, _tokenState, _tokenName, _tokenSymbol, _owner, _currencyKey, _totalSupply, _resolver) {}\r\n\r\n    /* ========== VIEWS ======================= */\r\n\r\n    function collateralManager() internal view returns (ICollateralManager) {\r\n        return ICollateralManager(requireAndGetAddress(CONTRACT_COLLATERALMANAGER));\r\n    }\r\n\r\n    function etherWrapper() internal view returns (IEtherWrapper) {\r\n        return IEtherWrapper(requireAndGetAddress(CONTRACT_ETHER_WRAPPER));\r\n    }\r\n\r\n    function wrapperFactory() internal view returns (IWrapperFactory) {\r\n        return IWrapperFactory(requireAndGetAddress(CONTRACT_WRAPPER_FACTORY));\r\n    }\r\n\r\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\r\n        bytes32[] memory existingAddresses = Synth.resolverAddressesRequired();\r\n        bytes32[] memory newAddresses = new bytes32[](3);\r\n        newAddresses[0] = CONTRACT_COLLATERALMANAGER;\r\n        newAddresses[1] = CONTRACT_ETHER_WRAPPER;\r\n        newAddresses[2] = CONTRACT_WRAPPER_FACTORY;\r\n        addresses = combineArrays(existingAddresses, newAddresses);\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Function that allows multi Collateral to issue a certain number of synths from an account.\r\n     * @param account Account to issue synths to\r\n     * @param amount Number of synths\r\n     */\r\n    function issue(address account, uint amount) external onlyInternalContracts {\r\n        super._internalIssue(account, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Function that allows multi Collateral to burn a certain number of synths from an account.\r\n     * @param account Account to burn synths from\r\n     * @param amount Number of synths\r\n     */\r\n    function burn(address account, uint amount) external onlyInternalContracts {\r\n        super._internalBurn(account, amount);\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    // Contracts directly interacting with multiCollateralSynth or wrapper to issue and burn\r\n    modifier onlyInternalContracts() {\r\n        bool isFeePool = msg.sender == address(feePool());\r\n        bool isExchanger = msg.sender == address(exchanger());\r\n        bool isIssuer = msg.sender == address(issuer());\r\n        bool isEtherWrapper = msg.sender == address(etherWrapper());\r\n        bool isWrapper = wrapperFactory().isWrapper(msg.sender);\r\n        bool isMultiCollateral = collateralManager().hasCollateral(msg.sender);\r\n\r\n        require(\r\n            isFeePool || isExchanger || isIssuer || isEtherWrapper || isWrapper || isMultiCollateral,\r\n            \"Only FeePool, Exchanger, Issuer, Wrapper, or MultiCollateral contracts allowed\"\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/proxyerc20\r\ncontract ProxyERC20 is Proxy, IERC20 {\r\n    constructor(address _owner) public Proxy(_owner) {}\r\n\r\n    // ------------- ERC20 Details ------------- //\r\n\r\n    function name() public view returns (string memory) {\r\n        // Immutable static call from target contract\r\n        return IERC20(address(target)).name();\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        // Immutable static call from target contract\r\n        return IERC20(address(target)).symbol();\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        // Immutable static call from target contract\r\n        return IERC20(address(target)).decimals();\r\n    }\r\n\r\n    // ------------- ERC20 Interface ------------- //\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        // Immutable static call from target contract\r\n        return IERC20(address(target)).totalSupply();\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param account The address to query the balance of.\r\n     * @return An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        // Immutable static call from target contract\r\n        return IERC20(address(target)).balanceOf(account);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        // Immutable static call from target contract\r\n        return IERC20(address(target)).allowance(owner, spender);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified address\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\r\n        target.setMessageSender(msg.sender);\r\n\r\n        // Forward the ERC20 call to the target contract\r\n        IERC20(address(target)).transfer(to, value);\r\n\r\n        // Event emitting will occur via Synthetix.Proxy._emit()\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\r\n        target.setMessageSender(msg.sender);\r\n\r\n        // Forward the ERC20 call to the target contract\r\n        IERC20(address(target)).approve(spender, value);\r\n\r\n        // Event emitting will occur via Synthetix.Proxy._emit()\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) public returns (bool) {\r\n        // Mutable state call requires the proxy to tell the target who the msg.sender is.\r\n        target.setMessageSender(msg.sender);\r\n\r\n        // Forward the ERC20 call to the target contract\r\n        IERC20(address(target)).transferFrom(from, to, value);\r\n\r\n        // Event emitting will occur via Synthetix.Proxy._emit()\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/irewardescrow\r\ninterface IRewardEscrow {\r\n    // Views\r\n    function balanceOf(address account) external view returns (uint);\r\n\r\n    function numVestingEntries(address account) external view returns (uint);\r\n\r\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\r\n\r\n    function totalVestedAccountBalance(address account) external view returns (uint);\r\n\r\n    function getVestingScheduleEntry(address account, uint index) external view returns (uint[2] memory);\r\n\r\n    function getNextVestingIndex(address account) external view returns (uint);\r\n\r\n    // Mutative functions\r\n    function appendVestingEntry(address account, uint quantity) external;\r\n\r\n    function vest() external;\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/rewardescrow\r\ncontract RewardEscrow is Owned, IRewardEscrow {\r\n    using SafeMath for uint;\r\n\r\n    /* The corresponding Synthetix contract. */\r\n    ISynthetix public synthetix;\r\n\r\n    IFeePool public feePool;\r\n\r\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\r\n     * These are the times at which each given quantity of SNX vests. */\r\n    mapping(address => uint[2][]) public vestingSchedules;\r\n\r\n    /* An account's total escrowed synthetix balance to save recomputing this for fee extraction purposes. */\r\n    mapping(address => uint) public totalEscrowedAccountBalance;\r\n\r\n    /* An account's total vested reward synthetix. */\r\n    mapping(address => uint) public totalVestedAccountBalance;\r\n\r\n    /* The total remaining escrowed balance, for verifying the actual synthetix balance of this contract against. */\r\n    uint public totalEscrowedBalance;\r\n\r\n    uint internal constant TIME_INDEX = 0;\r\n    uint internal constant QUANTITY_INDEX = 1;\r\n\r\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules.\r\n     * There are 5 years of the supply schedule */\r\n    uint public constant MAX_VESTING_ENTRIES = 52 * 5;\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor(\r\n        address _owner,\r\n        ISynthetix _synthetix,\r\n        IFeePool _feePool\r\n    ) public Owned(_owner) {\r\n        synthetix = _synthetix;\r\n        feePool = _feePool;\r\n    }\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    /**\r\n     * @notice set the synthetix contract address as we need to transfer SNX when the user vests\r\n     */\r\n    function setSynthetix(ISynthetix _synthetix) external onlyOwner {\r\n        synthetix = _synthetix;\r\n        emit SynthetixUpdated(address(_synthetix));\r\n    }\r\n\r\n    /**\r\n     * @notice set the FeePool contract as it is the only authority to be able to call\r\n     * appendVestingEntry with the onlyFeePool modifer\r\n     */\r\n    function setFeePool(IFeePool _feePool) external onlyOwner {\r\n        feePool = _feePool;\r\n        emit FeePoolUpdated(address(_feePool));\r\n    }\r\n\r\n    /* ========== VIEW FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\r\n     */\r\n    function balanceOf(address account) public view returns (uint) {\r\n        return totalEscrowedAccountBalance[account];\r\n    }\r\n\r\n    function _numVestingEntries(address account) internal view returns (uint) {\r\n        return vestingSchedules[account].length;\r\n    }\r\n\r\n    /**\r\n     * @notice The number of vesting dates in an account's schedule.\r\n     */\r\n    function numVestingEntries(address account) external view returns (uint) {\r\n        return vestingSchedules[account].length;\r\n    }\r\n\r\n    /**\r\n     * @notice Get a particular schedule entry for an account.\r\n     * @return A pair of uints: (timestamp, synthetix quantity).\r\n     */\r\n    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2] memory) {\r\n        return vestingSchedules[account][index];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the time at which a given schedule entry will vest.\r\n     */\r\n    function getVestingTime(address account, uint index) public view returns (uint) {\r\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the quantity of SNX associated with a given schedule entry.\r\n     */\r\n    function getVestingQuantity(address account, uint index) public view returns (uint) {\r\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\r\n    }\r\n\r\n    /**\r\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\r\n     */\r\n    function getNextVestingIndex(address account) public view returns (uint) {\r\n        uint len = _numVestingEntries(account);\r\n        for (uint i = 0; i < len; i++) {\r\n            if (getVestingTime(account, i) != 0) {\r\n                return i;\r\n            }\r\n        }\r\n        return len;\r\n    }\r\n\r\n    /**\r\n     * @notice Obtain the next schedule entry that will vest for a given user.\r\n     * @return A pair of uints: (timestamp, synthetix quantity). */\r\n    function getNextVestingEntry(address account) public view returns (uint[2] memory) {\r\n        uint index = getNextVestingIndex(account);\r\n        if (index == _numVestingEntries(account)) {\r\n            return [uint(0), 0];\r\n        }\r\n        return getVestingScheduleEntry(account, index);\r\n    }\r\n\r\n    /**\r\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\r\n     */\r\n    function getNextVestingTime(address account) external view returns (uint) {\r\n        return getNextVestingEntry(account)[TIME_INDEX];\r\n    }\r\n\r\n    /**\r\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\r\n     */\r\n    function getNextVestingQuantity(address account) external view returns (uint) {\r\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\r\n    }\r\n\r\n    /**\r\n     * @notice return the full vesting schedule entries vest for a given user.\r\n     * @dev For DApps to display the vesting schedule for the\r\n     * inflationary supply over 5 years. Solidity cant return variable length arrays\r\n     * so this is returning pairs of data. Vesting Time at [0] and quantity at [1] and so on\r\n     */\r\n    function checkAccountSchedule(address account) public view returns (uint[520] memory) {\r\n        uint[520] memory _result;\r\n        uint schedules = _numVestingEntries(account);\r\n        for (uint i = 0; i < schedules; i++) {\r\n            uint[2] memory pair = getVestingScheduleEntry(account, i);\r\n            _result[i * 2] = pair[0];\r\n            _result[i * 2 + 1] = pair[1];\r\n        }\r\n        return _result;\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    function _appendVestingEntry(address account, uint quantity) internal {\r\n        /* No empty or already-passed vesting entries allowed. */\r\n        require(quantity != 0, \"Quantity cannot be zero\");\r\n\r\n        /* There must be enough balance in the contract to provide for the vesting entry. */\r\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\r\n        require(\r\n            totalEscrowedBalance <= IERC20(address(synthetix)).balanceOf(address(this)),\r\n            \"Must be enough balance in the contract to provide for the vesting entry\"\r\n        );\r\n\r\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\r\n        uint scheduleLength = vestingSchedules[account].length;\r\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \"Vesting schedule is too long\");\r\n\r\n        /* Escrow the tokens for 1 year. */\r\n        uint time = now + 52 weeks;\r\n\r\n        if (scheduleLength == 0) {\r\n            totalEscrowedAccountBalance[account] = quantity;\r\n        } else {\r\n            /* Disallow adding new vested SNX earlier than the last one.\r\n             * Since entries are only appended, this means that no vesting date can be repeated. */\r\n            require(\r\n                getVestingTime(account, scheduleLength - 1) < time,\r\n                \"Cannot add new vested entries earlier than the last one\"\r\n            );\r\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);\r\n        }\r\n\r\n        vestingSchedules[account].push([time, quantity]);\r\n\r\n        emit VestingEntryCreated(account, now, quantity);\r\n    }\r\n\r\n    /**\r\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\r\n     * @dev A call to this should accompany a previous successful call to synthetix.transfer(rewardEscrow, amount),\r\n     * to ensure that when the funds are withdrawn, there is enough balance.\r\n     * Note; although this function could technically be used to produce unbounded\r\n     * arrays, it's only withinn the 4 year period of the weekly inflation schedule.\r\n     * @param account The account to append a new vesting entry to.\r\n     * @param quantity The quantity of SNX that will be escrowed.\r\n     */\r\n    function appendVestingEntry(address account, uint quantity) external onlyFeePool {\r\n        _appendVestingEntry(account, quantity);\r\n    }\r\n\r\n    /**\r\n     * @notice Allow a user to withdraw any SNX in their schedule that have vested.\r\n     */\r\n    function vest() external {\r\n        uint numEntries = _numVestingEntries(msg.sender);\r\n        uint total;\r\n        for (uint i = 0; i < numEntries; i++) {\r\n            uint time = getVestingTime(msg.sender, i);\r\n            /* The list is sorted; when we reach the first future time, bail out. */\r\n            if (time > now) {\r\n                break;\r\n            }\r\n            uint qty = getVestingQuantity(msg.sender, i);\r\n            if (qty > 0) {\r\n                vestingSchedules[msg.sender][i] = [0, 0];\r\n                total = total.add(qty);\r\n            }\r\n        }\r\n\r\n        if (total != 0) {\r\n            totalEscrowedBalance = totalEscrowedBalance.sub(total);\r\n            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);\r\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);\r\n            IERC20(address(synthetix)).transfer(msg.sender, total);\r\n            emit Vested(msg.sender, now, total);\r\n        }\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyFeePool() {\r\n        bool isFeePool = msg.sender == address(feePool);\r\n\r\n        require(isFeePool, \"Only the FeePool contracts can perform this action\");\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event SynthetixUpdated(address newSynthetix);\r\n\r\n    event FeePoolUpdated(address newFeePool);\r\n\r\n    event Vested(address indexed beneficiary, uint time, uint value);\r\n\r\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Libraires\r\n\r\n\r\n// Internal references\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/rewardsdistribution\r\ncontract RewardsDistribution is Owned, IRewardsDistribution {\r\n    using SafeMath for uint;\r\n    using SafeDecimalMath for uint;\r\n\r\n    /**\r\n     * @notice Authorised address able to call distributeRewards\r\n     */\r\n    address public authority;\r\n\r\n    /**\r\n     * @notice Address of the Synthetix ProxyERC20\r\n     */\r\n    address public synthetixProxy;\r\n\r\n    /**\r\n     * @notice Address of the RewardEscrow contract\r\n     */\r\n    address public rewardEscrow;\r\n\r\n    /**\r\n     * @notice Address of the FeePoolProxy\r\n     */\r\n    address public feePoolProxy;\r\n\r\n    /**\r\n     * @notice An array of addresses and amounts to send\r\n     */\r\n    DistributionData[] public distributions;\r\n\r\n    /**\r\n     * @dev _authority maybe the underlying synthetix contract.\r\n     * Remember to set the authority on a synthetix upgrade\r\n     */\r\n    constructor(\r\n        address _owner,\r\n        address _authority,\r\n        address _synthetixProxy,\r\n        address _rewardEscrow,\r\n        address _feePoolProxy\r\n    ) public Owned(_owner) {\r\n        authority = _authority;\r\n        synthetixProxy = _synthetixProxy;\r\n        rewardEscrow = _rewardEscrow;\r\n        feePoolProxy = _feePoolProxy;\r\n    }\r\n\r\n    // ========== EXTERNAL SETTERS ==========\r\n\r\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\r\n        synthetixProxy = _synthetixProxy;\r\n    }\r\n\r\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\r\n        rewardEscrow = _rewardEscrow;\r\n    }\r\n\r\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\r\n        feePoolProxy = _feePoolProxy;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the address of the contract authorised to call distributeRewards()\r\n     * @param _authority Address of the authorised calling contract.\r\n     */\r\n    function setAuthority(address _authority) external onlyOwner {\r\n        authority = _authority;\r\n    }\r\n\r\n    // ========== EXTERNAL FUNCTIONS ==========\r\n\r\n    /**\r\n     * @notice Adds a Rewards DistributionData struct to the distributions\r\n     * array. Any entries here will be iterated and rewards distributed to\r\n     * each address when tokens are sent to this contract and distributeRewards()\r\n     * is called by the autority.\r\n     * @param destination An address to send rewards tokens too\r\n     * @param amount The amount of rewards tokens to send\r\n     */\r\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\r\n        require(destination != address(0), \"Cant add a zero address\");\r\n        require(amount != 0, \"Cant add a zero amount\");\r\n\r\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\r\n        distributions.push(rewardsDistribution);\r\n\r\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Deletes a RewardDistribution from the distributions\r\n     * so it will no longer be included in the call to distributeRewards()\r\n     * @param index The index of the DistributionData to delete\r\n     */\r\n    function removeRewardDistribution(uint index) external onlyOwner {\r\n        require(index <= distributions.length - 1, \"index out of bounds\");\r\n\r\n        // shift distributions indexes across\r\n        for (uint i = index; i < distributions.length - 1; i++) {\r\n            distributions[i] = distributions[i + 1];\r\n        }\r\n        distributions.length--;\r\n\r\n        // Since this function must shift all later entries down to fill the\r\n        // gap from the one it removed, it could in principle consume an\r\n        // unbounded amount of gas. However, the number of entries will\r\n        // presumably always be very low.\r\n    }\r\n\r\n    /**\r\n     * @notice Edits a RewardDistribution in the distributions array.\r\n     * @param index The index of the DistributionData to edit\r\n     * @param destination The destination address. Send the same address to keep or different address to change it.\r\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\r\n     */\r\n    function editRewardDistribution(\r\n        uint index,\r\n        address destination,\r\n        uint amount\r\n    ) external onlyOwner returns (bool) {\r\n        require(index <= distributions.length - 1, \"index out of bounds\");\r\n\r\n        distributions[index].destination = destination;\r\n        distributions[index].amount = amount;\r\n\r\n        return true;\r\n    }\r\n\r\n    function distributeRewards(uint amount) external returns (bool) {\r\n        require(amount > 0, \"Nothing to distribute\");\r\n        require(msg.sender == authority, \"Caller is not authorised\");\r\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\r\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\r\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\r\n        require(\r\n            IERC20(synthetixProxy).balanceOf(address(this)) >= amount,\r\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\r\n        );\r\n\r\n        uint remainder = amount;\r\n\r\n        // Iterate the array of distributions sending the configured amounts\r\n        for (uint i = 0; i < distributions.length; i++) {\r\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\r\n                remainder = remainder.sub(distributions[i].amount);\r\n\r\n                // Transfer the SNX\r\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\r\n\r\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\r\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\r\n\r\n                // solhint-disable avoid-low-level-calls\r\n                (bool success, ) = distributions[i].destination.call(payload);\r\n\r\n                if (!success) {\r\n                    // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\r\n                }\r\n            }\r\n        }\r\n\r\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\r\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\r\n\r\n        // Tell the FeePool how much it has to distribute to the stakers\r\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\r\n\r\n        emit RewardsDistributed(amount);\r\n        return true;\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    /**\r\n     * @notice Retrieve the length of the distributions array\r\n     */\r\n    function distributionsLength() external view returns (uint) {\r\n        return distributions.length;\r\n    }\r\n\r\n    /* ========== Events ========== */\r\n\r\n    event RewardDistributionAdded(uint index, address destination, uint amount);\r\n    event RewardsDistributed(uint amount);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/synthetixstate\r\ncontract SynthetixState is Owned, State, ISynthetixState {\r\n    using SafeMath for uint;\r\n    using SafeDecimalMath for uint;\r\n\r\n    // A struct for handing values associated with an individual user's debt position\r\n    struct IssuanceData {\r\n        // Percentage of the total debt owned at the time\r\n        // of issuance. This number is modified by the global debt\r\n        // delta array. You can figure out a user's exit price and\r\n        // collateralisation ratio using a combination of their initial\r\n        // debt and the slice of global debt delta which applies to them.\r\n        uint initialDebtOwnership;\r\n        // This lets us know when (in relative terms) the user entered\r\n        // the debt pool so we can calculate their exit price and\r\n        // collateralistion ratio\r\n        uint debtEntryIndex;\r\n    }\r\n\r\n    // Issued synth balances for individual fee entitlements and exit price calculations\r\n    mapping(address => IssuanceData) public issuanceData;\r\n\r\n    // The total count of people that have outstanding issued synths in any flavour\r\n    uint public totalIssuerCount;\r\n\r\n    // Global debt pool tracking\r\n    uint[] public debtLedger;\r\n\r\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\r\n\r\n    /* ========== SETTERS ========== */\r\n\r\n    /**\r\n     * @notice Set issuance data for an address\r\n     * @dev Only the associated contract may call this.\r\n     * @param account The address to set the data for.\r\n     * @param initialDebtOwnership The initial debt ownership for this address.\r\n     */\r\n    function setCurrentIssuanceData(address account, uint initialDebtOwnership) external onlyAssociatedContract {\r\n        issuanceData[account].initialDebtOwnership = initialDebtOwnership;\r\n        issuanceData[account].debtEntryIndex = debtLedger.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Clear issuance data for an address\r\n     * @dev Only the associated contract may call this.\r\n     * @param account The address to clear the data for.\r\n     */\r\n    function clearIssuanceData(address account) external onlyAssociatedContract {\r\n        delete issuanceData[account];\r\n    }\r\n\r\n    /**\r\n     * @notice Increment the total issuer count\r\n     * @dev Only the associated contract may call this.\r\n     */\r\n    function incrementTotalIssuerCount() external onlyAssociatedContract {\r\n        totalIssuerCount = totalIssuerCount.add(1);\r\n    }\r\n\r\n    /**\r\n     * @notice Decrement the total issuer count\r\n     * @dev Only the associated contract may call this.\r\n     */\r\n    function decrementTotalIssuerCount() external onlyAssociatedContract {\r\n        totalIssuerCount = totalIssuerCount.sub(1);\r\n    }\r\n\r\n    /**\r\n     * @notice Append a value to the debt ledger\r\n     * @dev Only the associated contract may call this.\r\n     * @param value The new value to be added to the debt ledger.\r\n     */\r\n    function appendDebtLedgerValue(uint value) external onlyAssociatedContract {\r\n        debtLedger.push(value);\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    /**\r\n     * @notice Retrieve the length of the debt ledger array\r\n     */\r\n    function debtLedgerLength() external view returns (uint) {\r\n        return debtLedger.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve the most recent entry from the debt ledger\r\n     */\r\n    function lastDebtLedgerEntry() external view returns (uint) {\r\n        return debtLedger[debtLedger.length - 1];\r\n    }\r\n\r\n    /**\r\n     * @notice Query whether an account has issued and has an outstanding debt balance\r\n     * @param account The address to query for\r\n     */\r\n    function hasIssued(address account) external view returns (bool) {\r\n        return issuanceData[account].initialDebtOwnership > 0;\r\n    }\r\n}\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/interfaces/isystemsettings\r\ninterface ISystemSettings {\r\n    // Views\r\n    function waitingPeriodSecs() external view returns (uint);\r\n\r\n    function priceDeviationThresholdFactor() external view returns (uint);\r\n\r\n    function issuanceRatio() external view returns (uint);\r\n\r\n    function feePeriodDuration() external view returns (uint);\r\n\r\n    function targetThreshold() external view returns (uint);\r\n\r\n    function liquidationDelay() external view returns (uint);\r\n\r\n    function liquidationRatio() external view returns (uint);\r\n\r\n    function liquidationPenalty() external view returns (uint);\r\n\r\n    function rateStalePeriod() external view returns (uint);\r\n\r\n    function exchangeFeeRate(bytes32 currencyKey) external view returns (uint);\r\n\r\n    function minimumStakeTime() external view returns (uint);\r\n\r\n    function debtSnapshotStaleTime() external view returns (uint);\r\n\r\n    function aggregatorWarningFlags() external view returns (address);\r\n\r\n    function tradingRewardsEnabled() external view returns (bool);\r\n\r\n    function wrapperMaxTokenAmount(address wrapper) external view returns (uint);\r\n\r\n    function wrapperMintFeeRate(address wrapper) external view returns (int);\r\n\r\n    function wrapperBurnFeeRate(address wrapper) external view returns (int);\r\n\r\n    function etherWrapperMaxETH() external view returns (uint);\r\n\r\n    function etherWrapperMintFeeRate() external view returns (uint);\r\n\r\n    function etherWrapperBurnFeeRate() external view returns (uint);\r\n\r\n    function minCratio(address collateral) external view returns (uint);\r\n\r\n    function collateralManager(address collateral) external view returns (address);\r\n\r\n    function interactionDelay(address collateral) external view returns (uint);\r\n\r\n    function atomicMaxVolumePerBlock() external view returns (uint);\r\n\r\n    function atomicTwapWindow() external view returns (uint);\r\n\r\n    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address);\r\n\r\n    function atomicExchangeFeeRate(bytes32 currencyKey) external view returns (uint);\r\n\r\n    function atomicPriceBuffer(bytes32 currencyKey) external view returns (uint);\r\n\r\n    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint);\r\n\r\n    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// Libraries\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/systemsettings\r\ncontract SystemSettings is Owned, MixinSystemSettings, ISystemSettings {\r\n    using SafeMath for uint;\r\n    using SafeDecimalMath for uint;\r\n\r\n    bytes32 public constant CONTRACT_NAME = \"SystemSettings\";\r\n\r\n    // No more synths may be issued than the value of SNX backing them.\r\n    uint public constant MAX_ISSUANCE_RATIO = 1e18;\r\n\r\n    // The fee period must be between 1 day and 60 days.\r\n    uint public constant MIN_FEE_PERIOD_DURATION = 1 days;\r\n    uint public constant MAX_FEE_PERIOD_DURATION = 60 days;\r\n\r\n    uint public constant MAX_TARGET_THRESHOLD = 50;\r\n\r\n    uint public constant MAX_LIQUIDATION_RATIO = 1e18; // 100% issuance ratio\r\n\r\n    uint public constant MAX_LIQUIDATION_PENALTY = 1e18 / 4; // Max 25% liquidation penalty / bonus\r\n\r\n    uint public constant RATIO_FROM_TARGET_BUFFER = 2e18; // 200% - mininimum buffer between issuance ratio and liquidation ratio\r\n\r\n    uint public constant MAX_LIQUIDATION_DELAY = 30 days;\r\n    uint public constant MIN_LIQUIDATION_DELAY = 1 days;\r\n\r\n    // Exchange fee may not exceed 10%.\r\n    uint public constant MAX_EXCHANGE_FEE_RATE = 1e18 / 10;\r\n\r\n    // Minimum Stake time may not exceed 1 weeks.\r\n    uint public constant MAX_MINIMUM_STAKE_TIME = 1 weeks;\r\n\r\n    uint public constant MAX_CROSS_DOMAIN_GAS_LIMIT = 8e6;\r\n    uint public constant MIN_CROSS_DOMAIN_GAS_LIMIT = 3e6;\r\n\r\n    int public constant MAX_WRAPPER_MINT_FEE_RATE = 1e18;\r\n    int public constant MAX_WRAPPER_BURN_FEE_RATE = 1e18;\r\n\r\n    // Atomic block volume limit is encoded as uint192.\r\n    uint public constant MAX_ATOMIC_VOLUME_PER_BLOCK = uint192(-1);\r\n\r\n    // TWAP window must be between 1 min and 1 day.\r\n    uint public constant MIN_ATOMIC_TWAP_WINDOW = 60;\r\n    uint public constant MAX_ATOMIC_TWAP_WINDOW = 86400;\r\n\r\n    // Volatility consideration window must be between 1 min and 1 day.\r\n    uint public constant MIN_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = 60;\r\n    uint public constant MAX_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = 86400;\r\n\r\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {}\r\n\r\n    // ========== VIEWS ==========\r\n\r\n    // SIP-37 Fee Reclamation\r\n    // The number of seconds after an exchange is executed that must be waited\r\n    // before settlement.\r\n    function waitingPeriodSecs() external view returns (uint) {\r\n        return getWaitingPeriodSecs();\r\n    }\r\n\r\n    // SIP-65 Decentralized Circuit Breaker\r\n    // The factor amount expressed in decimal format\r\n    // E.g. 3e18 = factor 3, meaning movement up to 3x and above or down to 1/3x and below\r\n    function priceDeviationThresholdFactor() external view returns (uint) {\r\n        return getPriceDeviationThresholdFactor();\r\n    }\r\n\r\n    // The raio of collateral\r\n    // Expressed in 18 decimals. So 800% cratio is 100/800 = 0.125 (0.125e18)\r\n    function issuanceRatio() external view returns (uint) {\r\n        return getIssuanceRatio();\r\n    }\r\n\r\n    // How long a fee period lasts at a minimum. It is required for\r\n    // anyone to roll over the periods, so they are not guaranteed\r\n    // to roll over at exactly this duration, but the contract enforces\r\n    // that they cannot roll over any quicker than this duration.\r\n    function feePeriodDuration() external view returns (uint) {\r\n        return getFeePeriodDuration();\r\n    }\r\n\r\n    // Users are unable to claim fees if their collateralisation ratio drifts out of target threshold\r\n    function targetThreshold() external view returns (uint) {\r\n        return getTargetThreshold();\r\n    }\r\n\r\n    // SIP-15 Liquidations\r\n    // liquidation time delay after address flagged (seconds)\r\n    function liquidationDelay() external view returns (uint) {\r\n        return getLiquidationDelay();\r\n    }\r\n\r\n    // SIP-15 Liquidations\r\n    // issuance ratio when account can be flagged for liquidation (with 18 decimals), e.g 0.5 issuance ratio\r\n    // when flag means 1/0.5 = 200% cratio\r\n    function liquidationRatio() external view returns (uint) {\r\n        return getLiquidationRatio();\r\n    }\r\n\r\n    // SIP-15 Liquidations\r\n    // penalty taken away from target of liquidation (with 18 decimals). E.g. 10% is 0.1e18\r\n    function liquidationPenalty() external view returns (uint) {\r\n        return getLiquidationPenalty();\r\n    }\r\n\r\n    // How long will the ExchangeRates contract assume the rate of any asset is correct\r\n    function rateStalePeriod() external view returns (uint) {\r\n        return getRateStalePeriod();\r\n    }\r\n\r\n    function exchangeFeeRate(bytes32 currencyKey) external view returns (uint) {\r\n        return getExchangeFeeRate(currencyKey);\r\n    }\r\n\r\n    function minimumStakeTime() external view returns (uint) {\r\n        return getMinimumStakeTime();\r\n    }\r\n\r\n    function debtSnapshotStaleTime() external view returns (uint) {\r\n        return getDebtSnapshotStaleTime();\r\n    }\r\n\r\n    function aggregatorWarningFlags() external view returns (address) {\r\n        return getAggregatorWarningFlags();\r\n    }\r\n\r\n    // SIP-63 Trading incentives\r\n    // determines if Exchanger records fee entries in TradingRewards\r\n    function tradingRewardsEnabled() external view returns (bool) {\r\n        return getTradingRewardsEnabled();\r\n    }\r\n\r\n    function crossDomainMessageGasLimit(CrossDomainMessageGasLimits gasLimitType) external view returns (uint) {\r\n        return getCrossDomainMessageGasLimit(gasLimitType);\r\n    }\r\n\r\n    // SIP 112: ETH Wrappr\r\n    // The maximum amount of ETH held by the EtherWrapper.\r\n    function etherWrapperMaxETH() external view returns (uint) {\r\n        return getEtherWrapperMaxETH();\r\n    }\r\n\r\n    // SIP 112: ETH Wrappr\r\n    // The fee for depositing ETH into the EtherWrapper.\r\n    function etherWrapperMintFeeRate() external view returns (uint) {\r\n        return getEtherWrapperMintFeeRate();\r\n    }\r\n\r\n    // SIP 112: ETH Wrappr\r\n    // The fee for burning sETH and releasing ETH from the EtherWrapper.\r\n    function etherWrapperBurnFeeRate() external view returns (uint) {\r\n        return getEtherWrapperBurnFeeRate();\r\n    }\r\n\r\n    // SIP 182: Wrapper Factory\r\n    // The maximum amount of token held by the Wrapper.\r\n    function wrapperMaxTokenAmount(address wrapper) external view returns (uint) {\r\n        return getWrapperMaxTokenAmount(wrapper);\r\n    }\r\n\r\n    // SIP 182: Wrapper Factory\r\n    // The fee for depositing token into the Wrapper.\r\n    function wrapperMintFeeRate(address wrapper) external view returns (int) {\r\n        return getWrapperMintFeeRate(wrapper);\r\n    }\r\n\r\n    // SIP 182: Wrapper Factory\r\n    // The fee for burning synth and releasing token from the Wrapper.\r\n    function wrapperBurnFeeRate(address wrapper) external view returns (int) {\r\n        return getWrapperBurnFeeRate(wrapper);\r\n    }\r\n\r\n    function minCratio(address collateral) external view returns (uint) {\r\n        return getMinCratio(collateral);\r\n    }\r\n\r\n    function collateralManager(address collateral) external view returns (address) {\r\n        return getNewCollateralManager(collateral);\r\n    }\r\n\r\n    function interactionDelay(address collateral) external view returns (uint) {\r\n        return getInteractionDelay(collateral);\r\n    }\r\n\r\n    function collapseFeeRate(address collateral) external view returns (uint) {\r\n        return getCollapseFeeRate(collateral);\r\n    }\r\n\r\n    // SIP-120 Atomic exchanges\r\n    // max allowed volume per block for atomic exchanges\r\n    function atomicMaxVolumePerBlock() external view returns (uint) {\r\n        return getAtomicMaxVolumePerBlock();\r\n    }\r\n\r\n    // SIP-120 Atomic exchanges\r\n    // time window (in seconds) for TWAP prices when considered for atomic exchanges\r\n    function atomicTwapWindow() external view returns (uint) {\r\n        return getAtomicTwapWindow();\r\n    }\r\n\r\n    // SIP-120 Atomic exchanges\r\n    // equivalent asset to use for a synth when considering external prices for atomic exchanges\r\n    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {\r\n        return getAtomicEquivalentForDexPricing(currencyKey);\r\n    }\r\n\r\n    // SIP-120 Atomic exchanges\r\n    // fee rate override for atomic exchanges into a synth\r\n    function atomicExchangeFeeRate(bytes32 currencyKey) external view returns (uint) {\r\n        return getAtomicExchangeFeeRate(currencyKey);\r\n    }\r\n\r\n    // SIP-120 Atomic exchanges\r\n    // price dampener for chainlink prices when considered for atomic exchanges\r\n    function atomicPriceBuffer(bytes32 currencyKey) external view returns (uint) {\r\n        return getAtomicPriceBuffer(currencyKey);\r\n    }\r\n\r\n    // SIP-120 Atomic exchanges\r\n    // consideration window for determining synth volatility\r\n    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {\r\n        return getAtomicVolatilityConsiderationWindow(currencyKey);\r\n    }\r\n\r\n    // SIP-120 Atomic exchanges\r\n    // update threshold for determining synth volatility\r\n    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {\r\n        return getAtomicVolatilityUpdateThreshold(currencyKey);\r\n    }\r\n\r\n    // ========== RESTRICTED ==========\r\n\r\n    function setCrossDomainMessageGasLimit(CrossDomainMessageGasLimits _gasLimitType, uint _crossDomainMessageGasLimit)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _crossDomainMessageGasLimit >= MIN_CROSS_DOMAIN_GAS_LIMIT &&\r\n                _crossDomainMessageGasLimit <= MAX_CROSS_DOMAIN_GAS_LIMIT,\r\n            \"Out of range xDomain gasLimit\"\r\n        );\r\n        flexibleStorage().setUIntValue(\r\n            SETTING_CONTRACT_NAME,\r\n            _getGasLimitSetting(_gasLimitType),\r\n            _crossDomainMessageGasLimit\r\n        );\r\n        emit CrossDomainMessageGasLimitChanged(_gasLimitType, _crossDomainMessageGasLimit);\r\n    }\r\n\r\n    function setTradingRewardsEnabled(bool _tradingRewardsEnabled) external onlyOwner {\r\n        flexibleStorage().setBoolValue(SETTING_CONTRACT_NAME, SETTING_TRADING_REWARDS_ENABLED, _tradingRewardsEnabled);\r\n        emit TradingRewardsEnabled(_tradingRewardsEnabled);\r\n    }\r\n\r\n    function setWaitingPeriodSecs(uint _waitingPeriodSecs) external onlyOwner {\r\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_WAITING_PERIOD_SECS, _waitingPeriodSecs);\r\n        emit WaitingPeriodSecsUpdated(_waitingPeriodSecs);\r\n    }\r\n\r\n    function setPriceDeviationThresholdFactor(uint _priceDeviationThresholdFactor) external onlyOwner {\r\n        flexibleStorage().setUIntValue(\r\n            SETTING_CONTRACT_NAME,\r\n            SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR,\r\n            _priceDeviationThresholdFactor\r\n        );\r\n        emit PriceDeviationThresholdUpdated(_priceDeviationThresholdFactor);\r\n    }\r\n\r\n    function setIssuanceRatio(uint _issuanceRatio) external onlyOwner {\r\n        require(_issuanceRatio <= MAX_ISSUANCE_RATIO, \"New issuance ratio cannot exceed MAX_ISSUANCE_RATIO\");\r\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_ISSUANCE_RATIO, _issuanceRatio);\r\n        emit IssuanceRatioUpdated(_issuanceRatio);\r\n    }\r\n\r\n    function setFeePeriodDuration(uint _feePeriodDuration) external onlyOwner {\r\n        require(_feePeriodDuration >= MIN_FEE_PERIOD_DURATION, \"value < MIN_FEE_PERIOD_DURATION\");\r\n        require(_feePeriodDuration <= MAX_FEE_PERIOD_DURATION, \"value > MAX_FEE_PERIOD_DURATION\");\r\n\r\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_FEE_PERIOD_DURATION, _feePeriodDuration);\r\n\r\n        emit FeePeriodDurationUpdated(_feePeriodDuration);\r\n    }\r\n\r\n    function setTargetThreshold(uint _percent) external onlyOwner {\r\n        require(_percent <= MAX_TARGET_THRESHOLD, \"Threshold too high\");\r\n\r\n        uint _targetThreshold = _percent.mul(SafeDecimalMath.unit()).div(100);\r\n\r\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_TARGET_THRESHOLD, _targetThreshold);\r\n\r\n        emit TargetThresholdUpdated(_targetThreshold);\r\n    }\r\n\r\n    function setLiquidationDelay(uint time) external onlyOwner {\r\n        require(time <= MAX_LIQUIDATION_DELAY, \"Must be less than 30 days\");\r\n        require(time >= MIN_LIQUIDATION_DELAY, \"Must be greater than 1 day\");\r\n\r\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_DELAY, time);\r\n\r\n        emit LiquidationDelayUpdated(time);\r\n    }\r\n\r\n    // The collateral / issuance ratio ( debt / collateral ) is higher when there is less collateral backing their debt\r\n    // Upper bound liquidationRatio is 1 + penalty (100% + 10% = 110%) to allow collateral value to cover debt and liquidation penalty\r\n    function setLiquidationRatio(uint _liquidationRatio) external onlyOwner {\r\n        require(\r\n            _liquidationRatio <= MAX_LIQUIDATION_RATIO.divideDecimal(SafeDecimalMath.unit().add(getLiquidationPenalty())),\r\n            \"liquidationRatio > MAX_LIQUIDATION_RATIO / (1 + penalty)\"\r\n        );\r\n\r\n        // MIN_LIQUIDATION_RATIO is a product of target issuance ratio * RATIO_FROM_TARGET_BUFFER\r\n        // Ensures that liquidation ratio is set so that there is a buffer between the issuance ratio and liquidation ratio.\r\n        uint MIN_LIQUIDATION_RATIO = getIssuanceRatio().multiplyDecimal(RATIO_FROM_TARGET_BUFFER);\r\n        require(_liquidationRatio >= MIN_LIQUIDATION_RATIO, \"liquidationRatio < MIN_LIQUIDATION_RATIO\");\r\n\r\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_RATIO, _liquidationRatio);\r\n\r\n        emit LiquidationRatioUpdated(_liquidationRatio);\r\n    }\r\n\r\n    function setLiquidationPenalty(uint penalty) external onlyOwner {\r\n        require(penalty <= MAX_LIQUIDATION_PENALTY, \"penalty > MAX_LIQUIDATION_PENALTY\");\r\n\r\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_PENALTY, penalty);\r\n\r\n        emit LiquidationPenaltyUpdated(penalty);\r\n    }\r\n\r\n    function setRateStalePeriod(uint period) external onlyOwner {\r\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_RATE_STALE_PERIOD, period);\r\n\r\n        emit RateStalePeriodUpdated(period);\r\n    }\r\n\r\n    function setExchangeFeeRateForSynths(bytes32[] calldata synthKeys, uint256[] calldata exchangeFeeRates)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(synthKeys.length == exchangeFeeRates.length, \"Array lengths dont match\");\r\n        for (uint i = 0; i < synthKeys.length; i++) {\r\n            require(exchangeFeeRates[i] <= MAX_EXCHANGE_FEE_RATE, \"MAX_EXCHANGE_FEE_RATE exceeded\");\r\n            flexibleStorage().setUIntValue(\r\n                SETTING_CONTRACT_NAME,\r\n                keccak256(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE, synthKeys[i])),\r\n                exchangeFeeRates[i]\r\n            );\r\n            emit ExchangeFeeUpdated(synthKeys[i], exchangeFeeRates[i]);\r\n        }\r\n    }\r\n\r\n    function setMinimumStakeTime(uint _seconds) external onlyOwner {\r\n        require(_seconds <= MAX_MINIMUM_STAKE_TIME, \"stake time exceed maximum 1 week\");\r\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_MINIMUM_STAKE_TIME, _seconds);\r\n        emit MinimumStakeTimeUpdated(_seconds);\r\n    }\r\n\r\n    function setDebtSnapshotStaleTime(uint _seconds) external onlyOwner {\r\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_DEBT_SNAPSHOT_STALE_TIME, _seconds);\r\n        emit DebtSnapshotStaleTimeUpdated(_seconds);\r\n    }\r\n\r\n    function setAggregatorWarningFlags(address _flags) external onlyOwner {\r\n        require(_flags != address(0), \"Valid address must be given\");\r\n        flexibleStorage().setAddressValue(SETTING_CONTRACT_NAME, SETTING_AGGREGATOR_WARNING_FLAGS, _flags);\r\n        emit AggregatorWarningFlagsUpdated(_flags);\r\n    }\r\n\r\n    function setEtherWrapperMaxETH(uint _maxETH) external onlyOwner {\r\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MAX_ETH, _maxETH);\r\n        emit EtherWrapperMaxETHUpdated(_maxETH);\r\n    }\r\n\r\n    function setEtherWrapperMintFeeRate(uint _rate) external onlyOwner {\r\n        require(_rate <= uint(MAX_WRAPPER_MINT_FEE_RATE), \"rate > MAX_WRAPPER_MINT_FEE_RATE\");\r\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MINT_FEE_RATE, _rate);\r\n        emit EtherWrapperMintFeeRateUpdated(_rate);\r\n    }\r\n\r\n    function setEtherWrapperBurnFeeRate(uint _rate) external onlyOwner {\r\n        require(_rate <= uint(MAX_WRAPPER_BURN_FEE_RATE), \"rate > MAX_WRAPPER_BURN_FEE_RATE\");\r\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_BURN_FEE_RATE, _rate);\r\n        emit EtherWrapperBurnFeeRateUpdated(_rate);\r\n    }\r\n\r\n    function setWrapperMaxTokenAmount(address _wrapper, uint _maxTokenAmount) external onlyOwner {\r\n        flexibleStorage().setUIntValue(\r\n            SETTING_CONTRACT_NAME,\r\n            keccak256(abi.encodePacked(SETTING_WRAPPER_MAX_TOKEN_AMOUNT, _wrapper)),\r\n            _maxTokenAmount\r\n        );\r\n        emit WrapperMaxTokenAmountUpdated(_wrapper, _maxTokenAmount);\r\n    }\r\n\r\n    function setWrapperMintFeeRate(address _wrapper, int _rate) external onlyOwner {\r\n        require(_rate <= MAX_WRAPPER_MINT_FEE_RATE, \"rate > MAX_WRAPPER_MINT_FEE_RATE\");\r\n        require(_rate >= -MAX_WRAPPER_MINT_FEE_RATE, \"rate < -MAX_WRAPPER_MINT_FEE_RATE\");\r\n\r\n        // if mint rate is negative, burn fee rate should be positive and at least equal in magnitude\r\n        // otherwise risk of flash loan attack\r\n        if (_rate < 0) {\r\n            require(-_rate <= getWrapperBurnFeeRate(_wrapper), \"-rate > wrapperBurnFeeRate\");\r\n        }\r\n\r\n        flexibleStorage().setIntValue(\r\n            SETTING_CONTRACT_NAME,\r\n            keccak256(abi.encodePacked(SETTING_WRAPPER_MINT_FEE_RATE, _wrapper)),\r\n            _rate\r\n        );\r\n        emit WrapperMintFeeRateUpdated(_wrapper, _rate);\r\n    }\r\n\r\n    function setWrapperBurnFeeRate(address _wrapper, int _rate) external onlyOwner {\r\n        require(_rate <= MAX_WRAPPER_BURN_FEE_RATE, \"rate > MAX_WRAPPER_BURN_FEE_RATE\");\r\n        require(_rate >= -MAX_WRAPPER_BURN_FEE_RATE, \"rate < -MAX_WRAPPER_BURN_FEE_RATE\");\r\n\r\n        // if burn rate is negative, burn fee rate should be negative and at least equal in magnitude\r\n        // otherwise risk of flash loan attack\r\n        if (_rate < 0) {\r\n            require(-_rate <= getWrapperMintFeeRate(_wrapper), \"-rate > wrapperMintFeeRate\");\r\n        }\r\n\r\n        flexibleStorage().setIntValue(\r\n            SETTING_CONTRACT_NAME,\r\n            keccak256(abi.encodePacked(SETTING_WRAPPER_BURN_FEE_RATE, _wrapper)),\r\n            _rate\r\n        );\r\n        emit WrapperBurnFeeRateUpdated(_wrapper, _rate);\r\n    }\r\n\r\n    function setMinCratio(address _collateral, uint _minCratio) external onlyOwner {\r\n        require(_minCratio >= SafeDecimalMath.unit(), \"Cratio must be above 1\");\r\n        flexibleStorage().setUIntValue(\r\n            SETTING_CONTRACT_NAME,\r\n            keccak256(abi.encodePacked(SETTING_MIN_CRATIO, _collateral)),\r\n            _minCratio\r\n        );\r\n        emit MinCratioRatioUpdated(_minCratio);\r\n    }\r\n\r\n    function setCollateralManager(address _collateral, address _newCollateralManager) external onlyOwner {\r\n        flexibleStorage().setAddressValue(\r\n            SETTING_CONTRACT_NAME,\r\n            keccak256(abi.encodePacked(SETTING_NEW_COLLATERAL_MANAGER, _collateral)),\r\n            _newCollateralManager\r\n        );\r\n        emit CollateralManagerUpdated(_newCollateralManager);\r\n    }\r\n\r\n    function setInteractionDelay(address _collateral, uint _interactionDelay) external onlyOwner {\r\n        require(_interactionDelay <= SafeDecimalMath.unit() * 3600, \"Max 1 hour\");\r\n        flexibleStorage().setUIntValue(\r\n            SETTING_CONTRACT_NAME,\r\n            keccak256(abi.encodePacked(SETTING_INTERACTION_DELAY, _collateral)),\r\n            _interactionDelay\r\n        );\r\n        emit InteractionDelayUpdated(_interactionDelay);\r\n    }\r\n\r\n    function setCollapseFeeRate(address _collateral, uint _collapseFeeRate) external onlyOwner {\r\n        flexibleStorage().setUIntValue(\r\n            SETTING_CONTRACT_NAME,\r\n            keccak256(abi.encodePacked(SETTING_COLLAPSE_FEE_RATE, _collateral)),\r\n            _collapseFeeRate\r\n        );\r\n        emit CollapseFeeRateUpdated(_collapseFeeRate);\r\n    }\r\n\r\n    function setAtomicMaxVolumePerBlock(uint _maxVolume) external onlyOwner {\r\n        require(_maxVolume <= MAX_ATOMIC_VOLUME_PER_BLOCK, \"Atomic max volume exceed maximum uint192\");\r\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK, _maxVolume);\r\n        emit AtomicMaxVolumePerBlockUpdated(_maxVolume);\r\n    }\r\n\r\n    function setAtomicTwapWindow(uint _window) external onlyOwner {\r\n        require(_window >= MIN_ATOMIC_TWAP_WINDOW, \"Atomic twap window under minimum 1 min\");\r\n        require(_window <= MAX_ATOMIC_TWAP_WINDOW, \"Atomic twap window exceed maximum 1 day\");\r\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_TWAP_WINDOW, _window);\r\n        emit AtomicTwapWindowUpdated(_window);\r\n    }\r\n\r\n    function setAtomicEquivalentForDexPricing(bytes32 _currencyKey, address _equivalent) external onlyOwner {\r\n        require(_equivalent != address(0), \"Atomic equivalent is 0 address\");\r\n        flexibleStorage().setAddressValue(\r\n            SETTING_CONTRACT_NAME,\r\n            keccak256(abi.encodePacked(SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING, _currencyKey)),\r\n            _equivalent\r\n        );\r\n        emit AtomicEquivalentForDexPricingUpdated(_currencyKey, _equivalent);\r\n    }\r\n\r\n    function setAtomicExchangeFeeRate(bytes32 _currencyKey, uint256 _exchangeFeeRate) external onlyOwner {\r\n        require(_exchangeFeeRate <= MAX_EXCHANGE_FEE_RATE, \"MAX_EXCHANGE_FEE_RATE exceeded\");\r\n        flexibleStorage().setUIntValue(\r\n            SETTING_CONTRACT_NAME,\r\n            keccak256(abi.encodePacked(SETTING_ATOMIC_EXCHANGE_FEE_RATE, _currencyKey)),\r\n            _exchangeFeeRate\r\n        );\r\n        emit AtomicExchangeFeeUpdated(_currencyKey, _exchangeFeeRate);\r\n    }\r\n\r\n    function setAtomicPriceBuffer(bytes32 _currencyKey, uint _buffer) external onlyOwner {\r\n        flexibleStorage().setUIntValue(\r\n            SETTING_CONTRACT_NAME,\r\n            keccak256(abi.encodePacked(SETTING_ATOMIC_PRICE_BUFFER, _currencyKey)),\r\n            _buffer\r\n        );\r\n        emit AtomicPriceBufferUpdated(_currencyKey, _buffer);\r\n    }\r\n\r\n    function setAtomicVolatilityConsiderationWindow(bytes32 _currencyKey, uint _window) external onlyOwner {\r\n        if (_window != 0) {\r\n            require(\r\n                _window >= MIN_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,\r\n                \"Atomic volatility consideration window under minimum 1 min\"\r\n            );\r\n            require(\r\n                _window <= MAX_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,\r\n                \"Atomic volatility consideration window exceed maximum 1 day\"\r\n            );\r\n        }\r\n        flexibleStorage().setUIntValue(\r\n            SETTING_CONTRACT_NAME,\r\n            keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW, _currencyKey)),\r\n            _window\r\n        );\r\n        emit AtomicVolatilityConsiderationWindowUpdated(_currencyKey, _window);\r\n    }\r\n\r\n    function setAtomicVolatilityUpdateThreshold(bytes32 _currencyKey, uint _threshold) external onlyOwner {\r\n        flexibleStorage().setUIntValue(\r\n            SETTING_CONTRACT_NAME,\r\n            keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD, _currencyKey)),\r\n            _threshold\r\n        );\r\n        emit AtomicVolatilityUpdateThresholdUpdated(_currencyKey, _threshold);\r\n    }\r\n\r\n    // ========== EVENTS ==========\r\n    event CrossDomainMessageGasLimitChanged(CrossDomainMessageGasLimits gasLimitType, uint newLimit);\r\n    event TradingRewardsEnabled(bool enabled);\r\n    event WaitingPeriodSecsUpdated(uint waitingPeriodSecs);\r\n    event PriceDeviationThresholdUpdated(uint threshold);\r\n    event IssuanceRatioUpdated(uint newRatio);\r\n    event FeePeriodDurationUpdated(uint newFeePeriodDuration);\r\n    event TargetThresholdUpdated(uint newTargetThreshold);\r\n    event LiquidationDelayUpdated(uint newDelay);\r\n    event LiquidationRatioUpdated(uint newRatio);\r\n    event LiquidationPenaltyUpdated(uint newPenalty);\r\n    event RateStalePeriodUpdated(uint rateStalePeriod);\r\n    event ExchangeFeeUpdated(bytes32 synthKey, uint newExchangeFeeRate);\r\n    event MinimumStakeTimeUpdated(uint minimumStakeTime);\r\n    event DebtSnapshotStaleTimeUpdated(uint debtSnapshotStaleTime);\r\n    event AggregatorWarningFlagsUpdated(address flags);\r\n    event EtherWrapperMaxETHUpdated(uint maxETH);\r\n    event EtherWrapperMintFeeRateUpdated(uint rate);\r\n    event EtherWrapperBurnFeeRateUpdated(uint rate);\r\n    event WrapperMaxTokenAmountUpdated(address wrapper, uint maxTokenAmount);\r\n    event WrapperMintFeeRateUpdated(address wrapper, int rate);\r\n    event WrapperBurnFeeRateUpdated(address wrapper, int rate);\r\n    event MinCratioRatioUpdated(uint minCratio);\r\n    event CollateralManagerUpdated(address newCollateralManager);\r\n    event InteractionDelayUpdated(uint interactionDelay);\r\n    event CollapseFeeRateUpdated(uint collapseFeeRate);\r\n    event AtomicMaxVolumePerBlockUpdated(uint newMaxVolume);\r\n    event AtomicTwapWindowUpdated(uint newWindow);\r\n    event AtomicEquivalentForDexPricingUpdated(bytes32 synthKey, address equivalent);\r\n    event AtomicExchangeFeeUpdated(bytes32 synthKey, uint newExchangeFeeRate);\r\n    event AtomicPriceBufferUpdated(bytes32 synthKey, uint newBuffer);\r\n    event AtomicVolatilityConsiderationWindowUpdated(bytes32 synthKey, uint newVolatilityConsiderationWindow);\r\n    event AtomicVolatilityUpdateThresholdUpdated(bytes32 synthKey, uint newVolatilityUpdateThreshold);\r\n}\r\n\r\n\r\n// Inheritance\r\n\r\n\r\n// https://docs.synthetix.io/contracts/source/contracts/systemstatus\r\ncontract SystemStatus is Owned, ISystemStatus {\r\n    mapping(bytes32 => mapping(address => Status)) public accessControl;\r\n\r\n    uint248 public constant SUSPENSION_REASON_UPGRADE = 1;\r\n\r\n    bytes32 public constant SECTION_SYSTEM = \"System\";\r\n    bytes32 public constant SECTION_ISSUANCE = \"Issuance\";\r\n    bytes32 public constant SECTION_EXCHANGE = \"Exchange\";\r\n    bytes32 public constant SECTION_SYNTH_EXCHANGE = \"SynthExchange\";\r\n    bytes32 public constant SECTION_SYNTH = \"Synth\";\r\n\r\n    Suspension public systemSuspension;\r\n\r\n    Suspension public issuanceSuspension;\r\n\r\n    Suspension public exchangeSuspension;\r\n\r\n    mapping(bytes32 => Suspension) public synthExchangeSuspension;\r\n\r\n    mapping(bytes32 => Suspension) public synthSuspension;\r\n\r\n    constructor(address _owner) public Owned(_owner) {}\r\n\r\n    /* ========== VIEWS ========== */\r\n    function requireSystemActive() external view {\r\n        _internalRequireSystemActive();\r\n    }\r\n\r\n    function requireIssuanceActive() external view {\r\n        // Issuance requires the system be active\r\n        _internalRequireSystemActive();\r\n\r\n        // and issuance itself of course\r\n        _internalRequireIssuanceActive();\r\n    }\r\n\r\n    function requireExchangeActive() external view {\r\n        // Exchanging requires the system be active\r\n        _internalRequireSystemActive();\r\n\r\n        // and exchanging itself of course\r\n        _internalRequireExchangeActive();\r\n    }\r\n\r\n    function requireSynthExchangeActive(bytes32 currencyKey) external view {\r\n        // Synth exchange and transfer requires the system be active\r\n        _internalRequireSystemActive();\r\n        _internalRequireSynthExchangeActive(currencyKey);\r\n    }\r\n\r\n    function requireSynthActive(bytes32 currencyKey) external view {\r\n        // Synth exchange and transfer requires the system be active\r\n        _internalRequireSystemActive();\r\n        _internalRequireSynthActive(currencyKey);\r\n    }\r\n\r\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view {\r\n        // Synth exchange and transfer requires the system be active\r\n        _internalRequireSystemActive();\r\n        _internalRequireSynthActive(sourceCurrencyKey);\r\n        _internalRequireSynthActive(destinationCurrencyKey);\r\n    }\r\n\r\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view {\r\n        // Synth exchange and transfer requires the system be active\r\n        _internalRequireSystemActive();\r\n\r\n        // and exchanging must be active\r\n        _internalRequireExchangeActive();\r\n\r\n        // and the synth exchanging between the synths must be active\r\n        _internalRequireSynthExchangeActive(sourceCurrencyKey);\r\n        _internalRequireSynthExchangeActive(destinationCurrencyKey);\r\n\r\n        // and finally, the synths cannot be suspended\r\n        _internalRequireSynthActive(sourceCurrencyKey);\r\n        _internalRequireSynthActive(destinationCurrencyKey);\r\n    }\r\n\r\n    function isSystemUpgrading() external view returns (bool) {\r\n        return systemSuspension.suspended && systemSuspension.reason == SUSPENSION_REASON_UPGRADE;\r\n    }\r\n\r\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\r\n        external\r\n        view\r\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons)\r\n    {\r\n        exchangeSuspensions = new bool[](synths.length);\r\n        reasons = new uint256[](synths.length);\r\n\r\n        for (uint i = 0; i < synths.length; i++) {\r\n            exchangeSuspensions[i] = synthExchangeSuspension[synths[i]].suspended;\r\n            reasons[i] = synthExchangeSuspension[synths[i]].reason;\r\n        }\r\n    }\r\n\r\n    function getSynthSuspensions(bytes32[] calldata synths)\r\n        external\r\n        view\r\n        returns (bool[] memory suspensions, uint256[] memory reasons)\r\n    {\r\n        suspensions = new bool[](synths.length);\r\n        reasons = new uint256[](synths.length);\r\n\r\n        for (uint i = 0; i < synths.length; i++) {\r\n            suspensions[i] = synthSuspension[synths[i]].suspended;\r\n            reasons[i] = synthSuspension[synths[i]].reason;\r\n        }\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n    function updateAccessControl(\r\n        bytes32 section,\r\n        address account,\r\n        bool canSuspend,\r\n        bool canResume\r\n    ) external onlyOwner {\r\n        _internalUpdateAccessControl(section, account, canSuspend, canResume);\r\n    }\r\n\r\n    function updateAccessControls(\r\n        bytes32[] calldata sections,\r\n        address[] calldata accounts,\r\n        bool[] calldata canSuspends,\r\n        bool[] calldata canResumes\r\n    ) external onlyOwner {\r\n        require(\r\n            sections.length == accounts.length &&\r\n                accounts.length == canSuspends.length &&\r\n                canSuspends.length == canResumes.length,\r\n            \"Input array lengths must match\"\r\n        );\r\n        for (uint i = 0; i < sections.length; i++) {\r\n            _internalUpdateAccessControl(sections[i], accounts[i], canSuspends[i], canResumes[i]);\r\n        }\r\n    }\r\n\r\n    function suspendSystem(uint256 reason) external {\r\n        _requireAccessToSuspend(SECTION_SYSTEM);\r\n        systemSuspension.suspended = true;\r\n        systemSuspension.reason = uint248(reason);\r\n        emit SystemSuspended(systemSuspension.reason);\r\n    }\r\n\r\n    function resumeSystem() external {\r\n        _requireAccessToResume(SECTION_SYSTEM);\r\n        systemSuspension.suspended = false;\r\n        emit SystemResumed(uint256(systemSuspension.reason));\r\n        systemSuspension.reason = 0;\r\n    }\r\n\r\n    function suspendIssuance(uint256 reason) external {\r\n        _requireAccessToSuspend(SECTION_ISSUANCE);\r\n        issuanceSuspension.suspended = true;\r\n        issuanceSuspension.reason = uint248(reason);\r\n        emit IssuanceSuspended(reason);\r\n    }\r\n\r\n    function resumeIssuance() external {\r\n        _requireAccessToResume(SECTION_ISSUANCE);\r\n        issuanceSuspension.suspended = false;\r\n        emit IssuanceResumed(uint256(issuanceSuspension.reason));\r\n        issuanceSuspension.reason = 0;\r\n    }\r\n\r\n    function suspendExchange(uint256 reason) external {\r\n        _requireAccessToSuspend(SECTION_EXCHANGE);\r\n        exchangeSuspension.suspended = true;\r\n        exchangeSuspension.reason = uint248(reason);\r\n        emit ExchangeSuspended(reason);\r\n    }\r\n\r\n    function resumeExchange() external {\r\n        _requireAccessToResume(SECTION_EXCHANGE);\r\n        exchangeSuspension.suspended = false;\r\n        emit ExchangeResumed(uint256(exchangeSuspension.reason));\r\n        exchangeSuspension.reason = 0;\r\n    }\r\n\r\n    function suspendSynthExchange(bytes32 currencyKey, uint256 reason) external {\r\n        bytes32[] memory currencyKeys = new bytes32[](1);\r\n        currencyKeys[0] = currencyKey;\r\n        _internalSuspendSynthExchange(currencyKeys, reason);\r\n    }\r\n\r\n    function suspendSynthsExchange(bytes32[] calldata currencyKeys, uint256 reason) external {\r\n        _internalSuspendSynthExchange(currencyKeys, reason);\r\n    }\r\n\r\n    function resumeSynthExchange(bytes32 currencyKey) external {\r\n        bytes32[] memory currencyKeys = new bytes32[](1);\r\n        currencyKeys[0] = currencyKey;\r\n        _internalResumeSynthsExchange(currencyKeys);\r\n    }\r\n\r\n    function resumeSynthsExchange(bytes32[] calldata currencyKeys) external {\r\n        _internalResumeSynthsExchange(currencyKeys);\r\n    }\r\n\r\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external {\r\n        bytes32[] memory currencyKeys = new bytes32[](1);\r\n        currencyKeys[0] = currencyKey;\r\n        _internalSuspendSynths(currencyKeys, reason);\r\n    }\r\n\r\n    function suspendSynths(bytes32[] calldata currencyKeys, uint256 reason) external {\r\n        _internalSuspendSynths(currencyKeys, reason);\r\n    }\r\n\r\n    function resumeSynth(bytes32 currencyKey) external {\r\n        bytes32[] memory currencyKeys = new bytes32[](1);\r\n        currencyKeys[0] = currencyKey;\r\n        _internalResumeSynths(currencyKeys);\r\n    }\r\n\r\n    function resumeSynths(bytes32[] calldata currencyKeys) external {\r\n        _internalResumeSynths(currencyKeys);\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    function _requireAccessToSuspend(bytes32 section) internal view {\r\n        require(accessControl[section][msg.sender].canSuspend, \"Restricted to access control list\");\r\n    }\r\n\r\n    function _requireAccessToResume(bytes32 section) internal view {\r\n        require(accessControl[section][msg.sender].canResume, \"Restricted to access control list\");\r\n    }\r\n\r\n    function _internalRequireSystemActive() internal view {\r\n        require(\r\n            !systemSuspension.suspended,\r\n            systemSuspension.reason == SUSPENSION_REASON_UPGRADE\r\n                ? \"Synthetix is suspended, upgrade in progress... please stand by\"\r\n                : \"Synthetix is suspended. Operation prohibited\"\r\n        );\r\n    }\r\n\r\n    function _internalRequireIssuanceActive() internal view {\r\n        require(!issuanceSuspension.suspended, \"Issuance is suspended. Operation prohibited\");\r\n    }\r\n\r\n    function _internalRequireExchangeActive() internal view {\r\n        require(!exchangeSuspension.suspended, \"Exchange is suspended. Operation prohibited\");\r\n    }\r\n\r\n    function _internalRequireSynthExchangeActive(bytes32 currencyKey) internal view {\r\n        require(!synthExchangeSuspension[currencyKey].suspended, \"Synth exchange suspended. Operation prohibited\");\r\n    }\r\n\r\n    function _internalRequireSynthActive(bytes32 currencyKey) internal view {\r\n        require(!synthSuspension[currencyKey].suspended, \"Synth is suspended. Operation prohibited\");\r\n    }\r\n\r\n    function _internalSuspendSynths(bytes32[] memory currencyKeys, uint256 reason) internal {\r\n        _requireAccessToSuspend(SECTION_SYNTH);\r\n        for (uint i = 0; i < currencyKeys.length; i++) {\r\n            bytes32 currencyKey = currencyKeys[i];\r\n            synthSuspension[currencyKey].suspended = true;\r\n            synthSuspension[currencyKey].reason = uint248(reason);\r\n            emit SynthSuspended(currencyKey, reason);\r\n        }\r\n    }\r\n\r\n    function _internalResumeSynths(bytes32[] memory currencyKeys) internal {\r\n        _requireAccessToResume(SECTION_SYNTH);\r\n        for (uint i = 0; i < currencyKeys.length; i++) {\r\n            bytes32 currencyKey = currencyKeys[i];\r\n            emit SynthResumed(currencyKey, uint256(synthSuspension[currencyKey].reason));\r\n            delete synthSuspension[currencyKey];\r\n        }\r\n    }\r\n\r\n    function _internalSuspendSynthExchange(bytes32[] memory currencyKeys, uint256 reason) internal {\r\n        _requireAccessToSuspend(SECTION_SYNTH_EXCHANGE);\r\n        for (uint i = 0; i < currencyKeys.length; i++) {\r\n            bytes32 currencyKey = currencyKeys[i];\r\n            synthExchangeSuspension[currencyKey].suspended = true;\r\n            synthExchangeSuspension[currencyKey].reason = uint248(reason);\r\n            emit SynthExchangeSuspended(currencyKey, reason);\r\n        }\r\n    }\r\n\r\n    function _internalResumeSynthsExchange(bytes32[] memory currencyKeys) internal {\r\n        _requireAccessToResume(SECTION_SYNTH_EXCHANGE);\r\n        for (uint i = 0; i < currencyKeys.length; i++) {\r\n            bytes32 currencyKey = currencyKeys[i];\r\n            emit SynthExchangeResumed(currencyKey, uint256(synthExchangeSuspension[currencyKey].reason));\r\n            delete synthExchangeSuspension[currencyKey];\r\n        }\r\n    }\r\n\r\n    function _internalUpdateAccessControl(\r\n        bytes32 section,\r\n        address account,\r\n        bool canSuspend,\r\n        bool canResume\r\n    ) internal {\r\n        require(\r\n            section == SECTION_SYSTEM ||\r\n                section == SECTION_ISSUANCE ||\r\n                section == SECTION_EXCHANGE ||\r\n                section == SECTION_SYNTH_EXCHANGE ||\r\n                section == SECTION_SYNTH,\r\n            \"Invalid section supplied\"\r\n        );\r\n        accessControl[section][account].canSuspend = canSuspend;\r\n        accessControl[section][account].canResume = canResume;\r\n        emit AccessControlUpdated(section, account, canSuspend, canResume);\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event SystemSuspended(uint256 reason);\r\n    event SystemResumed(uint256 reason);\r\n\r\n    event IssuanceSuspended(uint256 reason);\r\n    event IssuanceResumed(uint256 reason);\r\n\r\n    event ExchangeSuspended(uint256 reason);\r\n    event ExchangeResumed(uint256 reason);\r\n\r\n    event SynthExchangeSuspended(bytes32 currencyKey, uint256 reason);\r\n    event SynthExchangeResumed(bytes32 currencyKey, uint256 reason);\r\n\r\n    event SynthSuspended(bytes32 currencyKey, uint256 reason);\r\n    event SynthResumed(bytes32 currencyKey, uint256 reason);\r\n\r\n    event AccessControlUpdated(bytes32 indexed section, address indexed account, bool canSuspend, bool canResume);\r\n}\r\n\r\n\r\ninterface ISynthetixNamedContract {\r\n    // solhint-disable func-name-mixedcase\r\n    function CONTRACT_NAME() external view returns (bytes32);\r\n}\r\n\r\n// solhint-disable contract-name-camelcase\r\nlibrary Migration_Alkaid_Supplemental {\r\n    // https://etherscan.io/address/0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\r\n    address public constant OWNER = 0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\r\n\r\n    // ----------------------------\r\n    // EXISTING SYNTHETIX CONTRACTS\r\n    // ----------------------------\r\n\r\n    // https://etherscan.io/address/0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83\r\n    AddressResolver public constant addressresolver_i = AddressResolver(0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83);\r\n    // https://etherscan.io/address/0xb440DD674e1243644791a4AdfE3A2AbB0A92d309\r\n    Proxy public constant proxyfeepool_i = Proxy(0xb440DD674e1243644791a4AdfE3A2AbB0A92d309);\r\n    // https://etherscan.io/address/0xC9DFff5fA5605fd94F8B7927b892F2B57391e8bB\r\n    FeePoolEternalStorage public constant feepooleternalstorage_i =\r\n        FeePoolEternalStorage(0xC9DFff5fA5605fd94F8B7927b892F2B57391e8bB);\r\n    // https://etherscan.io/address/0x11164F6a47C3f8472D19b9aDd516Fc780cb7Ee02\r\n    FeePoolState public constant feepoolstate_i = FeePoolState(0x11164F6a47C3f8472D19b9aDd516Fc780cb7Ee02);\r\n    // https://etherscan.io/address/0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F\r\n    Proxy public constant proxysynthetix_i = Proxy(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F);\r\n    // https://etherscan.io/address/0x545973f28950f50fc6c7F52AAb4Ad214A27C0564\r\n    ExchangeState public constant exchangestate_i = ExchangeState(0x545973f28950f50fc6c7F52AAb4Ad214A27C0564);\r\n    // https://etherscan.io/address/0x1c86B3CDF2a60Ae3a574f7f71d44E2C50BDdB87E\r\n    SystemStatus public constant systemstatus_i = SystemStatus(0x1c86B3CDF2a60Ae3a574f7f71d44E2C50BDdB87E);\r\n    // https://etherscan.io/address/0x5b1b5fEa1b99D83aD479dF0C222F0492385381dD\r\n    LegacyTokenState public constant tokenstatesynthetix_i = LegacyTokenState(0x5b1b5fEa1b99D83aD479dF0C222F0492385381dD);\r\n    // https://etherscan.io/address/0x4b9Ca5607f1fF8019c1C6A3c2f0CC8de622D5B82\r\n    SynthetixState public constant synthetixstate_i = SynthetixState(0x4b9Ca5607f1fF8019c1C6A3c2f0CC8de622D5B82);\r\n    // https://etherscan.io/address/0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F\r\n    RewardEscrow public constant rewardescrow_i = RewardEscrow(0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F);\r\n    // https://etherscan.io/address/0x29C295B046a73Cde593f21f63091B072d407e3F2\r\n    RewardsDistribution public constant rewardsdistribution_i =\r\n        RewardsDistribution(0x29C295B046a73Cde593f21f63091B072d407e3F2);\r\n    // https://etherscan.io/address/0xc398406FFfBEd5B0680e706634490062CB1DB579\r\n    FeePool public constant feepool_i = FeePool(0xc398406FFfBEd5B0680e706634490062CB1DB579);\r\n    // https://etherscan.io/address/0x6d9296Df2ad52F174bF671f555d78628bEBa7752\r\n    ExchangeRatesWithDexPricing public constant exchangerates_i =\r\n        ExchangeRatesWithDexPricing(0x6d9296Df2ad52F174bF671f555d78628bEBa7752);\r\n    // https://etherscan.io/address/0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA\r\n    MultiCollateralSynth public constant synthsusd_i = MultiCollateralSynth(0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA);\r\n    // https://etherscan.io/address/0x05a9CBe762B36632b3594DA4F082340E0e5343e8\r\n    TokenState public constant tokenstatesusd_i = TokenState(0x05a9CBe762B36632b3594DA4F082340E0e5343e8);\r\n    // https://etherscan.io/address/0x57Ab1ec28D129707052df4dF418D58a2D46d5f51\r\n    Proxy public constant proxysusd_i = Proxy(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51);\r\n    // https://etherscan.io/address/0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0\r\n    MultiCollateralSynth public constant synthseur_i = MultiCollateralSynth(0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0);\r\n    // https://etherscan.io/address/0x6568D9e750fC44AF00f857885Dfb8281c00529c4\r\n    TokenState public constant tokenstateseur_i = TokenState(0x6568D9e750fC44AF00f857885Dfb8281c00529c4);\r\n    // https://etherscan.io/address/0xD71eCFF9342A5Ced620049e616c5035F1dB98620\r\n    ProxyERC20 public constant proxyseur_i = ProxyERC20(0xD71eCFF9342A5Ced620049e616c5035F1dB98620);\r\n    // https://etherscan.io/address/0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A\r\n    MultiCollateralSynth public constant synthsjpy_i = MultiCollateralSynth(0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A);\r\n    // https://etherscan.io/address/0x4dFACfB15514C21c991ff75Bc7Bf6Fb1F98361ed\r\n    TokenState public constant tokenstatesjpy_i = TokenState(0x4dFACfB15514C21c991ff75Bc7Bf6Fb1F98361ed);\r\n    // https://etherscan.io/address/0xF6b1C627e95BFc3c1b4c9B825a032Ff0fBf3e07d\r\n    ProxyERC20 public constant proxysjpy_i = ProxyERC20(0xF6b1C627e95BFc3c1b4c9B825a032Ff0fBf3e07d);\r\n    // https://etherscan.io/address/0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827\r\n    MultiCollateralSynth public constant synthsaud_i = MultiCollateralSynth(0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827);\r\n    // https://etherscan.io/address/0xCb29D2cf2C65d3Be1d00F07f3441390432D55203\r\n    TokenState public constant tokenstatesaud_i = TokenState(0xCb29D2cf2C65d3Be1d00F07f3441390432D55203);\r\n    // https://etherscan.io/address/0xF48e200EAF9906362BB1442fca31e0835773b8B4\r\n    ProxyERC20 public constant proxysaud_i = ProxyERC20(0xF48e200EAF9906362BB1442fca31e0835773b8B4);\r\n    // https://etherscan.io/address/0xde3892383965FBa6eC434bE6350F85f140098708\r\n    MultiCollateralSynth public constant synthsgbp_i = MultiCollateralSynth(0xde3892383965FBa6eC434bE6350F85f140098708);\r\n    // https://etherscan.io/address/0x7e88D19A79b291cfE5696d496055f7e57F537A75\r\n    TokenState public constant tokenstatesgbp_i = TokenState(0x7e88D19A79b291cfE5696d496055f7e57F537A75);\r\n    // https://etherscan.io/address/0x97fe22E7341a0Cd8Db6F6C021A24Dc8f4DAD855F\r\n    ProxyERC20 public constant proxysgbp_i = ProxyERC20(0x97fe22E7341a0Cd8Db6F6C021A24Dc8f4DAD855F);\r\n    // https://etherscan.io/address/0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D\r\n    MultiCollateralSynth public constant synthschf_i = MultiCollateralSynth(0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D);\r\n    // https://etherscan.io/address/0x52496fE8a4feaEFe14d9433E00D48E6929c13deC\r\n    TokenState public constant tokenstateschf_i = TokenState(0x52496fE8a4feaEFe14d9433E00D48E6929c13deC);\r\n    // https://etherscan.io/address/0x0F83287FF768D1c1e17a42F44d644D7F22e8ee1d\r\n    ProxyERC20 public constant proxyschf_i = ProxyERC20(0x0F83287FF768D1c1e17a42F44d644D7F22e8ee1d);\r\n    // https://etherscan.io/address/0xe2f532c389deb5E42DCe53e78A9762949A885455\r\n    MultiCollateralSynth public constant synthskrw_i = MultiCollateralSynth(0xe2f532c389deb5E42DCe53e78A9762949A885455);\r\n    // https://etherscan.io/address/0x93B6e9FbBd2c32a0DC3C2B943B7C3CBC2fE23730\r\n    TokenState public constant tokenstateskrw_i = TokenState(0x93B6e9FbBd2c32a0DC3C2B943B7C3CBC2fE23730);\r\n    // https://etherscan.io/address/0x269895a3dF4D73b077Fc823dD6dA1B95f72Aaf9B\r\n    ProxyERC20 public constant proxyskrw_i = ProxyERC20(0x269895a3dF4D73b077Fc823dD6dA1B95f72Aaf9B);\r\n    // https://etherscan.io/address/0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353\r\n    MultiCollateralSynth public constant synthsbtc_i = MultiCollateralSynth(0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353);\r\n    // https://etherscan.io/address/0x4F6296455F8d754c19821cF1EC8FeBF2cD456E67\r\n    TokenState public constant tokenstatesbtc_i = TokenState(0x4F6296455F8d754c19821cF1EC8FeBF2cD456E67);\r\n    // https://etherscan.io/address/0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6\r\n    ProxyERC20 public constant proxysbtc_i = ProxyERC20(0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6);\r\n    // https://etherscan.io/address/0xc70B42930BD8D30A79B55415deC3be60827559f7\r\n    MultiCollateralSynth public constant synthseth_i = MultiCollateralSynth(0xc70B42930BD8D30A79B55415deC3be60827559f7);\r\n    // https://etherscan.io/address/0x34A5ef81d18F3a305aE9C2d7DF42beef4c79031c\r\n    TokenState public constant tokenstateseth_i = TokenState(0x34A5ef81d18F3a305aE9C2d7DF42beef4c79031c);\r\n    // https://etherscan.io/address/0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb\r\n    ProxyERC20 public constant proxyseth_i = ProxyERC20(0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb);\r\n    // https://etherscan.io/address/0x3FFE35c3d412150C3B91d3E22eBA60E16030C608\r\n    MultiCollateralSynth public constant synthslink_i = MultiCollateralSynth(0x3FFE35c3d412150C3B91d3E22eBA60E16030C608);\r\n    // https://etherscan.io/address/0x577D4a7395c6A5f46d9981a5F83fa7294926aBB0\r\n    TokenState public constant tokenstateslink_i = TokenState(0x577D4a7395c6A5f46d9981a5F83fa7294926aBB0);\r\n    // https://etherscan.io/address/0xbBC455cb4F1B9e4bFC4B73970d360c8f032EfEE6\r\n    ProxyERC20 public constant proxyslink_i = ProxyERC20(0xbBC455cb4F1B9e4bFC4B73970d360c8f032EfEE6);\r\n    // https://etherscan.io/address/0x8f9fa817200F5B95f9572c8Acf2b31410C00335a\r\n    MultiCollateralSynth public constant synthsada_i = MultiCollateralSynth(0x8f9fa817200F5B95f9572c8Acf2b31410C00335a);\r\n    // https://etherscan.io/address/0x9956c5019a24fbd5B506AD070b771577bAc5c343\r\n    TokenState public constant tokenstatesada_i = TokenState(0x9956c5019a24fbd5B506AD070b771577bAc5c343);\r\n    // https://etherscan.io/address/0xe36E2D3c7c34281FA3bC737950a68571736880A1\r\n    ProxyERC20 public constant proxysada_i = ProxyERC20(0xe36E2D3c7c34281FA3bC737950a68571736880A1);\r\n    // https://etherscan.io/address/0x0705F0716b12a703d4F8832Ec7b97C61771f0361\r\n    MultiCollateralSynth public constant synthsaave_i = MultiCollateralSynth(0x0705F0716b12a703d4F8832Ec7b97C61771f0361);\r\n    // https://etherscan.io/address/0x9BcED8A8E3Ad81c9b146FFC880358f734A06f7c0\r\n    TokenState public constant tokenstatesaave_i = TokenState(0x9BcED8A8E3Ad81c9b146FFC880358f734A06f7c0);\r\n    // https://etherscan.io/address/0xd2dF355C19471c8bd7D8A3aa27Ff4e26A21b4076\r\n    ProxyERC20 public constant proxysaave_i = ProxyERC20(0xd2dF355C19471c8bd7D8A3aa27Ff4e26A21b4076);\r\n    // https://etherscan.io/address/0xfA60918C4417b64E722ca15d79C751c1f24Ab995\r\n    MultiCollateralSynth public constant synthsdot_i = MultiCollateralSynth(0xfA60918C4417b64E722ca15d79C751c1f24Ab995);\r\n    // https://etherscan.io/address/0x73B1a2643507Cd30F11Dfcf2D974f4373E5BC077\r\n    TokenState public constant tokenstatesdot_i = TokenState(0x73B1a2643507Cd30F11Dfcf2D974f4373E5BC077);\r\n    // https://etherscan.io/address/0x1715AC0743102BF5Cd58EfBB6Cf2dC2685d967b6\r\n    ProxyERC20 public constant proxysdot_i = ProxyERC20(0x1715AC0743102BF5Cd58EfBB6Cf2dC2685d967b6);\r\n    // https://etherscan.io/address/0xe59dFC746D566EB40F92ed0B162004e24E3AC932\r\n    MultiCollateralSynth public constant synthsdefi_i = MultiCollateralSynth(0xe59dFC746D566EB40F92ed0B162004e24E3AC932);\r\n    // https://etherscan.io/address/0x7Ac2D37098a65B0f711CFfA3be635F1E6aCacFaB\r\n    TokenState public constant tokenstatesdefi_i = TokenState(0x7Ac2D37098a65B0f711CFfA3be635F1E6aCacFaB);\r\n    // https://etherscan.io/address/0xe1aFe1Fd76Fd88f78cBf599ea1846231B8bA3B6B\r\n    ProxyERC20 public constant proxysdefi_i = ProxyERC20(0xe1aFe1Fd76Fd88f78cBf599ea1846231B8bA3B6B);\r\n    // https://etherscan.io/address/0xC2F1F551bfAd1E9A3b4816513bFd41d77f40F915\r\n    Issuer public constant issuer_i = Issuer(0xC2F1F551bfAd1E9A3b4816513bFd41d77f40F915);\r\n    // https://etherscan.io/address/0xb6B476C41Ea01930e6abE1f44b96800de0404c98\r\n    SystemSettings public constant systemsettings_i = SystemSettings(0xb6B476C41Ea01930e6abE1f44b96800de0404c98);\r\n\r\n    // ----------------------------------\r\n    // NEW CONTRACTS DEPLOYED TO BE ADDED\r\n    // ----------------------------------\r\n\r\n    // https://etherscan.io/address/0xb6B476C41Ea01930e6abE1f44b96800de0404c98\r\n    address public constant new_SystemSettings_contract = 0xb6B476C41Ea01930e6abE1f44b96800de0404c98;\r\n    // https://etherscan.io/address/0x6d9296Df2ad52F174bF671f555d78628bEBa7752\r\n    address public constant new_ExchangeRates_contract = 0x6d9296Df2ad52F174bF671f555d78628bEBa7752;\r\n    // https://etherscan.io/address/0xc398406FFfBEd5B0680e706634490062CB1DB579\r\n    address public constant new_FeePool_contract = 0xc398406FFfBEd5B0680e706634490062CB1DB579;\r\n    // https://etherscan.io/address/0xDC01020857afbaE65224CfCeDb265d1216064c59\r\n    address public constant new_Synthetix_contract = 0xDC01020857afbaE65224CfCeDb265d1216064c59;\r\n    // https://etherscan.io/address/0x9D5551Cd3425Dd4585c3E7Eb7E4B98902222521E\r\n    address public constant new_DebtCache_contract = 0x9D5551Cd3425Dd4585c3E7Eb7E4B98902222521E;\r\n    // https://etherscan.io/address/0x2A417C61B8062363e4ff50900779463b45d235f6\r\n    address public constant new_Exchanger_contract = 0x2A417C61B8062363e4ff50900779463b45d235f6;\r\n    // https://etherscan.io/address/0xC2F1F551bfAd1E9A3b4816513bFd41d77f40F915\r\n    address public constant new_Issuer_contract = 0xC2F1F551bfAd1E9A3b4816513bFd41d77f40F915;\r\n    // https://etherscan.io/address/0x0a6956d554485a43494D69Eca78C5103511a8fEb\r\n    address public constant new_WrapperFactory_contract = 0x0a6956d554485a43494D69Eca78C5103511a8fEb;\r\n    // https://etherscan.io/address/0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA\r\n    address public constant new_SynthsUSD_contract = 0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA;\r\n    // https://etherscan.io/address/0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0\r\n    address public constant new_SynthsEUR_contract = 0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0;\r\n    // https://etherscan.io/address/0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A\r\n    address public constant new_SynthsJPY_contract = 0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A;\r\n    // https://etherscan.io/address/0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827\r\n    address public constant new_SynthsAUD_contract = 0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827;\r\n    // https://etherscan.io/address/0xde3892383965FBa6eC434bE6350F85f140098708\r\n    address public constant new_SynthsGBP_contract = 0xde3892383965FBa6eC434bE6350F85f140098708;\r\n    // https://etherscan.io/address/0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D\r\n    address public constant new_SynthsCHF_contract = 0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D;\r\n    // https://etherscan.io/address/0xe2f532c389deb5E42DCe53e78A9762949A885455\r\n    address public constant new_SynthsKRW_contract = 0xe2f532c389deb5E42DCe53e78A9762949A885455;\r\n    // https://etherscan.io/address/0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353\r\n    address public constant new_SynthsBTC_contract = 0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353;\r\n    // https://etherscan.io/address/0xc70B42930BD8D30A79B55415deC3be60827559f7\r\n    address public constant new_SynthsETH_contract = 0xc70B42930BD8D30A79B55415deC3be60827559f7;\r\n    // https://etherscan.io/address/0x3FFE35c3d412150C3B91d3E22eBA60E16030C608\r\n    address public constant new_SynthsLINK_contract = 0x3FFE35c3d412150C3B91d3E22eBA60E16030C608;\r\n    // https://etherscan.io/address/0x8f9fa817200F5B95f9572c8Acf2b31410C00335a\r\n    address public constant new_SynthsADA_contract = 0x8f9fa817200F5B95f9572c8Acf2b31410C00335a;\r\n    // https://etherscan.io/address/0x0705F0716b12a703d4F8832Ec7b97C61771f0361\r\n    address public constant new_SynthsAAVE_contract = 0x0705F0716b12a703d4F8832Ec7b97C61771f0361;\r\n    // https://etherscan.io/address/0xfA60918C4417b64E722ca15d79C751c1f24Ab995\r\n    address public constant new_SynthsDOT_contract = 0xfA60918C4417b64E722ca15d79C751c1f24Ab995;\r\n    // https://etherscan.io/address/0xe59dFC746D566EB40F92ed0B162004e24E3AC932\r\n    address public constant new_SynthsDEFI_contract = 0xe59dFC746D566EB40F92ed0B162004e24E3AC932;\r\n\r\n    function require_check() external {\r\n        require(\r\n            ISynthetixNamedContract(new_SystemSettings_contract).CONTRACT_NAME() == \"SystemSettings\",\r\n            \"Invalid contract supplied for SystemSettings\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_ExchangeRates_contract).CONTRACT_NAME() == \"ExchangeRatesWithDexPricing\",\r\n            \"Invalid contract supplied for ExchangeRates\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_FeePool_contract).CONTRACT_NAME() == \"FeePool\",\r\n            \"Invalid contract supplied for FeePool\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_Synthetix_contract).CONTRACT_NAME() == \"Synthetix\",\r\n            \"Invalid contract supplied for Synthetix\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_DebtCache_contract).CONTRACT_NAME() == \"DebtCache\",\r\n            \"Invalid contract supplied for DebtCache\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_Exchanger_contract).CONTRACT_NAME() == \"ExchangerWithFeeRecAlternatives\",\r\n            \"Invalid contract supplied for Exchanger\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_Issuer_contract).CONTRACT_NAME() == \"Issuer\",\r\n            \"Invalid contract supplied for Issuer\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_WrapperFactory_contract).CONTRACT_NAME() == \"WrapperFactory\",\r\n            \"Invalid contract supplied for WrapperFactory\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_SynthsUSD_contract).CONTRACT_NAME() == \"MultiCollateralSynth\",\r\n            \"Invalid contract supplied for SynthsUSD\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_SynthsEUR_contract).CONTRACT_NAME() == \"MultiCollateralSynth\",\r\n            \"Invalid contract supplied for SynthsEUR\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_SynthsJPY_contract).CONTRACT_NAME() == \"MultiCollateralSynth\",\r\n            \"Invalid contract supplied for SynthsJPY\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_SynthsAUD_contract).CONTRACT_NAME() == \"MultiCollateralSynth\",\r\n            \"Invalid contract supplied for SynthsAUD\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_SynthsGBP_contract).CONTRACT_NAME() == \"MultiCollateralSynth\",\r\n            \"Invalid contract supplied for SynthsGBP\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_SynthsCHF_contract).CONTRACT_NAME() == \"MultiCollateralSynth\",\r\n            \"Invalid contract supplied for SynthsCHF\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_SynthsKRW_contract).CONTRACT_NAME() == \"MultiCollateralSynth\",\r\n            \"Invalid contract supplied for SynthsKRW\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_SynthsBTC_contract).CONTRACT_NAME() == \"MultiCollateralSynth\",\r\n            \"Invalid contract supplied for SynthsBTC\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_SynthsETH_contract).CONTRACT_NAME() == \"MultiCollateralSynth\",\r\n            \"Invalid contract supplied for SynthsETH\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_SynthsLINK_contract).CONTRACT_NAME() == \"MultiCollateralSynth\",\r\n            \"Invalid contract supplied for SynthsLINK\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_SynthsADA_contract).CONTRACT_NAME() == \"MultiCollateralSynth\",\r\n            \"Invalid contract supplied for SynthsADA\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_SynthsAAVE_contract).CONTRACT_NAME() == \"MultiCollateralSynth\",\r\n            \"Invalid contract supplied for SynthsAAVE\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_SynthsDOT_contract).CONTRACT_NAME() == \"MultiCollateralSynth\",\r\n            \"Invalid contract supplied for SynthsDOT\"\r\n        );\r\n        require(\r\n            ISynthetixNamedContract(new_SynthsDEFI_contract).CONTRACT_NAME() == \"MultiCollateralSynth\",\r\n            \"Invalid contract supplied for SynthsDEFI\"\r\n        );\r\n    }\r\n\r\n    function addressresolver_importAddresses_0() external {\r\n        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](22);\r\n        addressresolver_importAddresses_names_0_0[0] = bytes32(\"SystemSettings\");\r\n        addressresolver_importAddresses_names_0_0[1] = bytes32(\"ExchangeRates\");\r\n        addressresolver_importAddresses_names_0_0[2] = bytes32(\"FeePool\");\r\n        addressresolver_importAddresses_names_0_0[3] = bytes32(\"Synthetix\");\r\n        addressresolver_importAddresses_names_0_0[4] = bytes32(\"DebtCache\");\r\n        addressresolver_importAddresses_names_0_0[5] = bytes32(\"Exchanger\");\r\n        addressresolver_importAddresses_names_0_0[6] = bytes32(\"Issuer\");\r\n        addressresolver_importAddresses_names_0_0[7] = bytes32(\"WrapperFactory\");\r\n        addressresolver_importAddresses_names_0_0[8] = bytes32(\"SynthsUSD\");\r\n        addressresolver_importAddresses_names_0_0[9] = bytes32(\"SynthsEUR\");\r\n        addressresolver_importAddresses_names_0_0[10] = bytes32(\"SynthsJPY\");\r\n        addressresolver_importAddresses_names_0_0[11] = bytes32(\"SynthsAUD\");\r\n        addressresolver_importAddresses_names_0_0[12] = bytes32(\"SynthsGBP\");\r\n        addressresolver_importAddresses_names_0_0[13] = bytes32(\"SynthsCHF\");\r\n        addressresolver_importAddresses_names_0_0[14] = bytes32(\"SynthsKRW\");\r\n        addressresolver_importAddresses_names_0_0[15] = bytes32(\"SynthsBTC\");\r\n        addressresolver_importAddresses_names_0_0[16] = bytes32(\"SynthsETH\");\r\n        addressresolver_importAddresses_names_0_0[17] = bytes32(\"SynthsLINK\");\r\n        addressresolver_importAddresses_names_0_0[18] = bytes32(\"SynthsADA\");\r\n        addressresolver_importAddresses_names_0_0[19] = bytes32(\"SynthsAAVE\");\r\n        addressresolver_importAddresses_names_0_0[20] = bytes32(\"SynthsDOT\");\r\n        addressresolver_importAddresses_names_0_0[21] = bytes32(\"SynthsDEFI\");\r\n        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](22);\r\n        addressresolver_importAddresses_destinations_0_1[0] = address(new_SystemSettings_contract);\r\n        addressresolver_importAddresses_destinations_0_1[1] = address(new_ExchangeRates_contract);\r\n        addressresolver_importAddresses_destinations_0_1[2] = address(new_FeePool_contract);\r\n        addressresolver_importAddresses_destinations_0_1[3] = address(new_Synthetix_contract);\r\n        addressresolver_importAddresses_destinations_0_1[4] = address(new_DebtCache_contract);\r\n        addressresolver_importAddresses_destinations_0_1[5] = address(new_Exchanger_contract);\r\n        addressresolver_importAddresses_destinations_0_1[6] = address(new_Issuer_contract);\r\n        addressresolver_importAddresses_destinations_0_1[7] = address(new_WrapperFactory_contract);\r\n        addressresolver_importAddresses_destinations_0_1[8] = address(new_SynthsUSD_contract);\r\n        addressresolver_importAddresses_destinations_0_1[9] = address(new_SynthsEUR_contract);\r\n        addressresolver_importAddresses_destinations_0_1[10] = address(new_SynthsJPY_contract);\r\n        addressresolver_importAddresses_destinations_0_1[11] = address(new_SynthsAUD_contract);\r\n        addressresolver_importAddresses_destinations_0_1[12] = address(new_SynthsGBP_contract);\r\n        addressresolver_importAddresses_destinations_0_1[13] = address(new_SynthsCHF_contract);\r\n        addressresolver_importAddresses_destinations_0_1[14] = address(new_SynthsKRW_contract);\r\n        addressresolver_importAddresses_destinations_0_1[15] = address(new_SynthsBTC_contract);\r\n        addressresolver_importAddresses_destinations_0_1[16] = address(new_SynthsETH_contract);\r\n        addressresolver_importAddresses_destinations_0_1[17] = address(new_SynthsLINK_contract);\r\n        addressresolver_importAddresses_destinations_0_1[18] = address(new_SynthsADA_contract);\r\n        addressresolver_importAddresses_destinations_0_1[19] = address(new_SynthsAAVE_contract);\r\n        addressresolver_importAddresses_destinations_0_1[20] = address(new_SynthsDOT_contract);\r\n        addressresolver_importAddresses_destinations_0_1[21] = address(new_SynthsDEFI_contract);\r\n        addressresolver_i.importAddresses(\r\n            addressresolver_importAddresses_names_0_0,\r\n            addressresolver_importAddresses_destinations_0_1\r\n        );\r\n    }\r\n\r\n    function addressresolver_rebuildCaches_1() external {\r\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_1_0 = new MixinResolver[](20);\r\n        addressresolver_rebuildCaches_destinations_1_0[0] = MixinResolver(new_SystemSettings_contract);\r\n        addressresolver_rebuildCaches_destinations_1_0[1] = MixinResolver(0xAD95C918af576c82Df740878C3E983CBD175daB6);\r\n        addressresolver_rebuildCaches_destinations_1_0[2] = MixinResolver(new_DebtCache_contract);\r\n        addressresolver_rebuildCaches_destinations_1_0[3] = MixinResolver(new_Exchanger_contract);\r\n        addressresolver_rebuildCaches_destinations_1_0[4] = MixinResolver(new_Issuer_contract);\r\n        addressresolver_rebuildCaches_destinations_1_0[5] = MixinResolver(0xC1AAE9d18bBe386B102435a8632C8063d31e747C);\r\n        addressresolver_rebuildCaches_destinations_1_0[6] = MixinResolver(0x067e398605E84F2D0aEEC1806e62768C5110DCc6);\r\n        addressresolver_rebuildCaches_destinations_1_0[7] = MixinResolver(0x5c8344bcdC38F1aB5EB5C1d4a35DdEeA522B5DfA);\r\n        addressresolver_rebuildCaches_destinations_1_0[8] = MixinResolver(0xaa03aB31b55DceEeF845C8d17890CC61cD98eD04);\r\n        addressresolver_rebuildCaches_destinations_1_0[9] = MixinResolver(0x1F2c3a1046c32729862fcB038369696e3273a516);\r\n        addressresolver_rebuildCaches_destinations_1_0[10] = MixinResolver(new_ExchangeRates_contract);\r\n        addressresolver_rebuildCaches_destinations_1_0[11] = MixinResolver(0xDA4eF8520b1A57D7d63f1E249606D1A459698876);\r\n        addressresolver_rebuildCaches_destinations_1_0[12] = MixinResolver(new_WrapperFactory_contract);\r\n        addressresolver_rebuildCaches_destinations_1_0[13] = MixinResolver(new_SynthsUSD_contract);\r\n        addressresolver_rebuildCaches_destinations_1_0[14] = MixinResolver(new_SynthsEUR_contract);\r\n        addressresolver_rebuildCaches_destinations_1_0[15] = MixinResolver(new_SynthsJPY_contract);\r\n        addressresolver_rebuildCaches_destinations_1_0[16] = MixinResolver(new_SynthsAUD_contract);\r\n        addressresolver_rebuildCaches_destinations_1_0[17] = MixinResolver(new_SynthsGBP_contract);\r\n        addressresolver_rebuildCaches_destinations_1_0[18] = MixinResolver(new_SynthsCHF_contract);\r\n        addressresolver_rebuildCaches_destinations_1_0[19] = MixinResolver(new_SynthsKRW_contract);\r\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_1_0);\r\n    }\r\n\r\n    function addressresolver_rebuildCaches_2() internal {\r\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_2_0 = new MixinResolver[](13);\r\n        addressresolver_rebuildCaches_destinations_2_0[0] = MixinResolver(new_SynthsBTC_contract);\r\n        addressresolver_rebuildCaches_destinations_2_0[1] = MixinResolver(new_SynthsETH_contract);\r\n        addressresolver_rebuildCaches_destinations_2_0[2] = MixinResolver(new_SynthsLINK_contract);\r\n        addressresolver_rebuildCaches_destinations_2_0[3] = MixinResolver(new_SynthsADA_contract);\r\n        addressresolver_rebuildCaches_destinations_2_0[4] = MixinResolver(new_SynthsAAVE_contract);\r\n        addressresolver_rebuildCaches_destinations_2_0[5] = MixinResolver(new_SynthsDOT_contract);\r\n        addressresolver_rebuildCaches_destinations_2_0[6] = MixinResolver(new_SynthsDEFI_contract);\r\n        addressresolver_rebuildCaches_destinations_2_0[7] = MixinResolver(new_FeePool_contract);\r\n        addressresolver_rebuildCaches_destinations_2_0[8] = MixinResolver(0x62922670313bf6b41C580143d1f6C173C5C20019);\r\n        addressresolver_rebuildCaches_destinations_2_0[9] = MixinResolver(0xCd9D4988C0AE61887B075bA77f08cbFAd2b65068);\r\n        addressresolver_rebuildCaches_destinations_2_0[10] = MixinResolver(new_Synthetix_contract);\r\n        addressresolver_rebuildCaches_destinations_2_0[11] = MixinResolver(0xe533139Af961c9747356D947838c98451015e234);\r\n        addressresolver_rebuildCaches_destinations_2_0[12] = MixinResolver(0x7A3d898b717e50a96fd8b232E9d15F0A547A7eeb);\r\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_2_0);\r\n    }\r\n\r\n    function importFeePeriod_0() external {\r\n        // https://etherscan.io/address/0x510adfDF6E7554C571b7Cd9305Ce91473610015e;\r\n        FeePool existingFeePool = FeePool(0x510adfDF6E7554C571b7Cd9305Ce91473610015e);\r\n        // https://etherscan.io/address/0xc398406FFfBEd5B0680e706634490062CB1DB579;\r\n        FeePool newFeePool = FeePool(0xc398406FFfBEd5B0680e706634490062CB1DB579);\r\n        (\r\n            uint64 feePeriodId_0,\r\n            uint64 startingDebtIndex_0,\r\n            uint64 startTime_0,\r\n            uint feesToDistribute_0,\r\n            uint feesClaimed_0,\r\n            uint rewardsToDistribute_0,\r\n            uint rewardsClaimed_0\r\n        ) = existingFeePool.recentFeePeriods(0);\r\n        newFeePool.importFeePeriod(\r\n            0,\r\n            feePeriodId_0,\r\n            startingDebtIndex_0,\r\n            startTime_0,\r\n            feesToDistribute_0,\r\n            feesClaimed_0,\r\n            rewardsToDistribute_0,\r\n            rewardsClaimed_0\r\n        );\r\n    }\r\n\r\n    function importFeePeriod_1() external {\r\n        // https://etherscan.io/address/0x510adfDF6E7554C571b7Cd9305Ce91473610015e;\r\n        FeePool existingFeePool = FeePool(0x510adfDF6E7554C571b7Cd9305Ce91473610015e);\r\n        // https://etherscan.io/address/0xc398406FFfBEd5B0680e706634490062CB1DB579;\r\n        FeePool newFeePool = FeePool(0xc398406FFfBEd5B0680e706634490062CB1DB579);\r\n        (\r\n            uint64 feePeriodId_1,\r\n            uint64 startingDebtIndex_1,\r\n            uint64 startTime_1,\r\n            uint feesToDistribute_1,\r\n            uint feesClaimed_1,\r\n            uint rewardsToDistribute_1,\r\n            uint rewardsClaimed_1\r\n        ) = existingFeePool.recentFeePeriods(1);\r\n        newFeePool.importFeePeriod(\r\n            1,\r\n            feePeriodId_1,\r\n            startingDebtIndex_1,\r\n            startTime_1,\r\n            feesToDistribute_1,\r\n            feesClaimed_1,\r\n            rewardsToDistribute_1,\r\n            rewardsClaimed_1\r\n        );\r\n    }\r\n\r\n    function copyTotalSupplyFrom_sUSD() external {\r\n        // https://etherscan.io/address/0x967968963517AFDC9b8Ccc9AD6649bC507E83a7b;\r\n        Synth existingSynth = Synth(0x967968963517AFDC9b8Ccc9AD6649bC507E83a7b);\r\n        // https://etherscan.io/address/0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA;\r\n        Synth newSynth = Synth(0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA);\r\n        newSynth.setTotalSupply(existingSynth.totalSupply());\r\n    }\r\n\r\n    function copyTotalSupplyFrom_sEUR() external {\r\n        // https://etherscan.io/address/0xC61b352fCc311Ae6B0301459A970150005e74b3E;\r\n        Synth existingSynth = Synth(0xC61b352fCc311Ae6B0301459A970150005e74b3E);\r\n        // https://etherscan.io/address/0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0;\r\n        Synth newSynth = Synth(0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0);\r\n        newSynth.setTotalSupply(existingSynth.totalSupply());\r\n    }\r\n\r\n    function copyTotalSupplyFrom_sJPY() external {\r\n        // https://etherscan.io/address/0x388fD1A8a7d36e03eFA1ab100a1c5159a3A3d427;\r\n        Synth existingSynth = Synth(0x388fD1A8a7d36e03eFA1ab100a1c5159a3A3d427);\r\n        // https://etherscan.io/address/0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A;\r\n        Synth newSynth = Synth(0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A);\r\n        newSynth.setTotalSupply(existingSynth.totalSupply());\r\n    }\r\n\r\n    function copyTotalSupplyFrom_sAUD() external {\r\n        // https://etherscan.io/address/0x37B648a07476F4941D3D647f81118AFd55fa8a04;\r\n        Synth existingSynth = Synth(0x37B648a07476F4941D3D647f81118AFd55fa8a04);\r\n        // https://etherscan.io/address/0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827;\r\n        Synth newSynth = Synth(0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827);\r\n        newSynth.setTotalSupply(existingSynth.totalSupply());\r\n    }\r\n\r\n    function copyTotalSupplyFrom_sGBP() external {\r\n        // https://etherscan.io/address/0xEF285D339c91aDf1dD7DE0aEAa6250805FD68258;\r\n        Synth existingSynth = Synth(0xEF285D339c91aDf1dD7DE0aEAa6250805FD68258);\r\n        // https://etherscan.io/address/0xde3892383965FBa6eC434bE6350F85f140098708;\r\n        Synth newSynth = Synth(0xde3892383965FBa6eC434bE6350F85f140098708);\r\n        newSynth.setTotalSupply(existingSynth.totalSupply());\r\n    }\r\n\r\n    function copyTotalSupplyFrom_sCHF() external {\r\n        // https://etherscan.io/address/0xcf9bB94b5d65589039607BA66e3DAC686d3eFf01;\r\n        Synth existingSynth = Synth(0xcf9bB94b5d65589039607BA66e3DAC686d3eFf01);\r\n        // https://etherscan.io/address/0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D;\r\n        Synth newSynth = Synth(0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D);\r\n        newSynth.setTotalSupply(existingSynth.totalSupply());\r\n    }\r\n\r\n    function copyTotalSupplyFrom_sKRW() external {\r\n        // https://etherscan.io/address/0xCeC4e038371d32212C6Dcdf36Fdbcb6F8a34C6d8;\r\n        Synth existingSynth = Synth(0xCeC4e038371d32212C6Dcdf36Fdbcb6F8a34C6d8);\r\n        // https://etherscan.io/address/0xe2f532c389deb5E42DCe53e78A9762949A885455;\r\n        Synth newSynth = Synth(0xe2f532c389deb5E42DCe53e78A9762949A885455);\r\n        newSynth.setTotalSupply(existingSynth.totalSupply());\r\n    }\r\n\r\n    function copyTotalSupplyFrom_sBTC() external {\r\n        // https://etherscan.io/address/0xC8a5f06858a1B49A7F703EacD433A1444a5e5bd9;\r\n        Synth existingSynth = Synth(0xC8a5f06858a1B49A7F703EacD433A1444a5e5bd9);\r\n        // https://etherscan.io/address/0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353;\r\n        Synth newSynth = Synth(0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353);\r\n        newSynth.setTotalSupply(existingSynth.totalSupply());\r\n    }\r\n\r\n    function copyTotalSupplyFrom_sETH() external {\r\n        // https://etherscan.io/address/0xCFA46B4923c0E75B7b84E9FBde70ED26feFefBf6;\r\n        Synth existingSynth = Synth(0xCFA46B4923c0E75B7b84E9FBde70ED26feFefBf6);\r\n        // https://etherscan.io/address/0xc70B42930BD8D30A79B55415deC3be60827559f7;\r\n        Synth newSynth = Synth(0xc70B42930BD8D30A79B55415deC3be60827559f7);\r\n        newSynth.setTotalSupply(existingSynth.totalSupply());\r\n    }\r\n\r\n    function copyTotalSupplyFrom_sLINK() external {\r\n        // https://etherscan.io/address/0xcd980Fc5CcdAe62B18A52b83eC64200121A929db;\r\n        Synth existingSynth = Synth(0xcd980Fc5CcdAe62B18A52b83eC64200121A929db);\r\n        // https://etherscan.io/address/0x3FFE35c3d412150C3B91d3E22eBA60E16030C608;\r\n        Synth newSynth = Synth(0x3FFE35c3d412150C3B91d3E22eBA60E16030C608);\r\n        newSynth.setTotalSupply(existingSynth.totalSupply());\r\n    }\r\n\r\n    function copyTotalSupplyFrom_sADA() external {\r\n        // https://etherscan.io/address/0xC22e51FA362654ea453B4018B616ef6f6ab3b779;\r\n        Synth existingSynth = Synth(0xC22e51FA362654ea453B4018B616ef6f6ab3b779);\r\n        // https://etherscan.io/address/0x8f9fa817200F5B95f9572c8Acf2b31410C00335a;\r\n        Synth newSynth = Synth(0x8f9fa817200F5B95f9572c8Acf2b31410C00335a);\r\n        newSynth.setTotalSupply(existingSynth.totalSupply());\r\n    }\r\n\r\n    function copyTotalSupplyFrom_sAAVE() external {\r\n        // https://etherscan.io/address/0xaB38249f4f56Ef868F6b5E01D9cFa26B952c1270;\r\n        Synth existingSynth = Synth(0xaB38249f4f56Ef868F6b5E01D9cFa26B952c1270);\r\n        // https://etherscan.io/address/0x0705F0716b12a703d4F8832Ec7b97C61771f0361;\r\n        Synth newSynth = Synth(0x0705F0716b12a703d4F8832Ec7b97C61771f0361);\r\n        newSynth.setTotalSupply(existingSynth.totalSupply());\r\n    }\r\n\r\n    function copyTotalSupplyFrom_sDOT() external {\r\n        // https://etherscan.io/address/0xfD0435A588BF5c5a6974BA19Fa627b772833d4eb;\r\n        Synth existingSynth = Synth(0xfD0435A588BF5c5a6974BA19Fa627b772833d4eb);\r\n        // https://etherscan.io/address/0xfA60918C4417b64E722ca15d79C751c1f24Ab995;\r\n        Synth newSynth = Synth(0xfA60918C4417b64E722ca15d79C751c1f24Ab995);\r\n        newSynth.setTotalSupply(existingSynth.totalSupply());\r\n    }\r\n\r\n    function copyTotalSupplyFrom_sDEFI() external {\r\n        // https://etherscan.io/address/0x46A7Af405093B27DA6DeF193C508Bd9240A255FA;\r\n        Synth existingSynth = Synth(0x46A7Af405093B27DA6DeF193C508Bd9240A255FA);\r\n        // https://etherscan.io/address/0xe59dFC746D566EB40F92ed0B162004e24E3AC932;\r\n        Synth newSynth = Synth(0xe59dFC746D566EB40F92ed0B162004e24E3AC932);\r\n        newSynth.setTotalSupply(existingSynth.totalSupply());\r\n    }\r\n\r\n    function issuer_addSynths_105() external {\r\n        ISynth[] memory issuer_addSynths_synthsToAdd_105_0 = new ISynth[](14);\r\n        issuer_addSynths_synthsToAdd_105_0[0] = ISynth(new_SynthsUSD_contract);\r\n        issuer_addSynths_synthsToAdd_105_0[1] = ISynth(new_SynthsEUR_contract);\r\n        issuer_addSynths_synthsToAdd_105_0[2] = ISynth(new_SynthsJPY_contract);\r\n        issuer_addSynths_synthsToAdd_105_0[3] = ISynth(new_SynthsAUD_contract);\r\n        issuer_addSynths_synthsToAdd_105_0[4] = ISynth(new_SynthsGBP_contract);\r\n        issuer_addSynths_synthsToAdd_105_0[5] = ISynth(new_SynthsCHF_contract);\r\n        issuer_addSynths_synthsToAdd_105_0[6] = ISynth(new_SynthsKRW_contract);\r\n        issuer_addSynths_synthsToAdd_105_0[7] = ISynth(new_SynthsBTC_contract);\r\n        issuer_addSynths_synthsToAdd_105_0[8] = ISynth(new_SynthsETH_contract);\r\n        issuer_addSynths_synthsToAdd_105_0[9] = ISynth(new_SynthsLINK_contract);\r\n        issuer_addSynths_synthsToAdd_105_0[10] = ISynth(new_SynthsADA_contract);\r\n        issuer_addSynths_synthsToAdd_105_0[11] = ISynth(new_SynthsAAVE_contract);\r\n        issuer_addSynths_synthsToAdd_105_0[12] = ISynth(new_SynthsDOT_contract);\r\n        issuer_addSynths_synthsToAdd_105_0[13] = ISynth(new_SynthsDEFI_contract);\r\n        issuer_i.addSynths(issuer_addSynths_synthsToAdd_105_0);\r\n    }\r\n}\r\n\r\n// solhint-disable contract-name-camelcase\r\ncontract Migration_Alkaid is BaseMigration {\r\n    // https://etherscan.io/address/0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\r\n    address public constant OWNER = 0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\r\n\r\n    // ----------------------------\r\n    // EXISTING SYNTHETIX CONTRACTS\r\n    // ----------------------------\r\n\r\n    // https://etherscan.io/address/0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83\r\n    AddressResolver public constant addressresolver_i = AddressResolver(0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83);\r\n    // https://etherscan.io/address/0xb440DD674e1243644791a4AdfE3A2AbB0A92d309\r\n    Proxy public constant proxyfeepool_i = Proxy(0xb440DD674e1243644791a4AdfE3A2AbB0A92d309);\r\n    // https://etherscan.io/address/0xC9DFff5fA5605fd94F8B7927b892F2B57391e8bB\r\n    FeePoolEternalStorage public constant feepooleternalstorage_i =\r\n        FeePoolEternalStorage(0xC9DFff5fA5605fd94F8B7927b892F2B57391e8bB);\r\n    // https://etherscan.io/address/0x11164F6a47C3f8472D19b9aDd516Fc780cb7Ee02\r\n    FeePoolState public constant feepoolstate_i = FeePoolState(0x11164F6a47C3f8472D19b9aDd516Fc780cb7Ee02);\r\n    // https://etherscan.io/address/0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F\r\n    Proxy public constant proxysynthetix_i = Proxy(0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F);\r\n    // https://etherscan.io/address/0x545973f28950f50fc6c7F52AAb4Ad214A27C0564\r\n    ExchangeState public constant exchangestate_i = ExchangeState(0x545973f28950f50fc6c7F52AAb4Ad214A27C0564);\r\n    // https://etherscan.io/address/0x1c86B3CDF2a60Ae3a574f7f71d44E2C50BDdB87E\r\n    SystemStatus public constant systemstatus_i = SystemStatus(0x1c86B3CDF2a60Ae3a574f7f71d44E2C50BDdB87E);\r\n    // https://etherscan.io/address/0x5b1b5fEa1b99D83aD479dF0C222F0492385381dD\r\n    LegacyTokenState public constant tokenstatesynthetix_i = LegacyTokenState(0x5b1b5fEa1b99D83aD479dF0C222F0492385381dD);\r\n    // https://etherscan.io/address/0x4b9Ca5607f1fF8019c1C6A3c2f0CC8de622D5B82\r\n    SynthetixState public constant synthetixstate_i = SynthetixState(0x4b9Ca5607f1fF8019c1C6A3c2f0CC8de622D5B82);\r\n    // https://etherscan.io/address/0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F\r\n    RewardEscrow public constant rewardescrow_i = RewardEscrow(0xb671F2210B1F6621A2607EA63E6B2DC3e2464d1F);\r\n    // https://etherscan.io/address/0x29C295B046a73Cde593f21f63091B072d407e3F2\r\n    RewardsDistribution public constant rewardsdistribution_i =\r\n        RewardsDistribution(0x29C295B046a73Cde593f21f63091B072d407e3F2);\r\n    // https://etherscan.io/address/0xc398406FFfBEd5B0680e706634490062CB1DB579\r\n    FeePool public constant feepool_i = FeePool(0xc398406FFfBEd5B0680e706634490062CB1DB579);\r\n    // https://etherscan.io/address/0x6d9296Df2ad52F174bF671f555d78628bEBa7752\r\n    ExchangeRatesWithDexPricing public constant exchangerates_i =\r\n        ExchangeRatesWithDexPricing(0x6d9296Df2ad52F174bF671f555d78628bEBa7752);\r\n    // https://etherscan.io/address/0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA\r\n    MultiCollateralSynth public constant synthsusd_i = MultiCollateralSynth(0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA);\r\n    // https://etherscan.io/address/0x05a9CBe762B36632b3594DA4F082340E0e5343e8\r\n    TokenState public constant tokenstatesusd_i = TokenState(0x05a9CBe762B36632b3594DA4F082340E0e5343e8);\r\n    // https://etherscan.io/address/0x57Ab1ec28D129707052df4dF418D58a2D46d5f51\r\n    Proxy public constant proxysusd_i = Proxy(0x57Ab1ec28D129707052df4dF418D58a2D46d5f51);\r\n    // https://etherscan.io/address/0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0\r\n    MultiCollateralSynth public constant synthseur_i = MultiCollateralSynth(0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0);\r\n    // https://etherscan.io/address/0x6568D9e750fC44AF00f857885Dfb8281c00529c4\r\n    TokenState public constant tokenstateseur_i = TokenState(0x6568D9e750fC44AF00f857885Dfb8281c00529c4);\r\n    // https://etherscan.io/address/0xD71eCFF9342A5Ced620049e616c5035F1dB98620\r\n    ProxyERC20 public constant proxyseur_i = ProxyERC20(0xD71eCFF9342A5Ced620049e616c5035F1dB98620);\r\n    // https://etherscan.io/address/0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A\r\n    MultiCollateralSynth public constant synthsjpy_i = MultiCollateralSynth(0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A);\r\n    // https://etherscan.io/address/0x4dFACfB15514C21c991ff75Bc7Bf6Fb1F98361ed\r\n    TokenState public constant tokenstatesjpy_i = TokenState(0x4dFACfB15514C21c991ff75Bc7Bf6Fb1F98361ed);\r\n    // https://etherscan.io/address/0xF6b1C627e95BFc3c1b4c9B825a032Ff0fBf3e07d\r\n    ProxyERC20 public constant proxysjpy_i = ProxyERC20(0xF6b1C627e95BFc3c1b4c9B825a032Ff0fBf3e07d);\r\n    // https://etherscan.io/address/0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827\r\n    MultiCollateralSynth public constant synthsaud_i = MultiCollateralSynth(0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827);\r\n    // https://etherscan.io/address/0xCb29D2cf2C65d3Be1d00F07f3441390432D55203\r\n    TokenState public constant tokenstatesaud_i = TokenState(0xCb29D2cf2C65d3Be1d00F07f3441390432D55203);\r\n    // https://etherscan.io/address/0xF48e200EAF9906362BB1442fca31e0835773b8B4\r\n    ProxyERC20 public constant proxysaud_i = ProxyERC20(0xF48e200EAF9906362BB1442fca31e0835773b8B4);\r\n    // https://etherscan.io/address/0xde3892383965FBa6eC434bE6350F85f140098708\r\n    MultiCollateralSynth public constant synthsgbp_i = MultiCollateralSynth(0xde3892383965FBa6eC434bE6350F85f140098708);\r\n    // https://etherscan.io/address/0x7e88D19A79b291cfE5696d496055f7e57F537A75\r\n    TokenState public constant tokenstatesgbp_i = TokenState(0x7e88D19A79b291cfE5696d496055f7e57F537A75);\r\n    // https://etherscan.io/address/0x97fe22E7341a0Cd8Db6F6C021A24Dc8f4DAD855F\r\n    ProxyERC20 public constant proxysgbp_i = ProxyERC20(0x97fe22E7341a0Cd8Db6F6C021A24Dc8f4DAD855F);\r\n    // https://etherscan.io/address/0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D\r\n    MultiCollateralSynth public constant synthschf_i = MultiCollateralSynth(0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D);\r\n    // https://etherscan.io/address/0x52496fE8a4feaEFe14d9433E00D48E6929c13deC\r\n    TokenState public constant tokenstateschf_i = TokenState(0x52496fE8a4feaEFe14d9433E00D48E6929c13deC);\r\n    // https://etherscan.io/address/0x0F83287FF768D1c1e17a42F44d644D7F22e8ee1d\r\n    ProxyERC20 public constant proxyschf_i = ProxyERC20(0x0F83287FF768D1c1e17a42F44d644D7F22e8ee1d);\r\n    // https://etherscan.io/address/0xe2f532c389deb5E42DCe53e78A9762949A885455\r\n    MultiCollateralSynth public constant synthskrw_i = MultiCollateralSynth(0xe2f532c389deb5E42DCe53e78A9762949A885455);\r\n    // https://etherscan.io/address/0x93B6e9FbBd2c32a0DC3C2B943B7C3CBC2fE23730\r\n    TokenState public constant tokenstateskrw_i = TokenState(0x93B6e9FbBd2c32a0DC3C2B943B7C3CBC2fE23730);\r\n    // https://etherscan.io/address/0x269895a3dF4D73b077Fc823dD6dA1B95f72Aaf9B\r\n    ProxyERC20 public constant proxyskrw_i = ProxyERC20(0x269895a3dF4D73b077Fc823dD6dA1B95f72Aaf9B);\r\n    // https://etherscan.io/address/0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353\r\n    MultiCollateralSynth public constant synthsbtc_i = MultiCollateralSynth(0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353);\r\n    // https://etherscan.io/address/0x4F6296455F8d754c19821cF1EC8FeBF2cD456E67\r\n    TokenState public constant tokenstatesbtc_i = TokenState(0x4F6296455F8d754c19821cF1EC8FeBF2cD456E67);\r\n    // https://etherscan.io/address/0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6\r\n    ProxyERC20 public constant proxysbtc_i = ProxyERC20(0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6);\r\n    // https://etherscan.io/address/0xc70B42930BD8D30A79B55415deC3be60827559f7\r\n    MultiCollateralSynth public constant synthseth_i = MultiCollateralSynth(0xc70B42930BD8D30A79B55415deC3be60827559f7);\r\n    // https://etherscan.io/address/0x34A5ef81d18F3a305aE9C2d7DF42beef4c79031c\r\n    TokenState public constant tokenstateseth_i = TokenState(0x34A5ef81d18F3a305aE9C2d7DF42beef4c79031c);\r\n    // https://etherscan.io/address/0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb\r\n    ProxyERC20 public constant proxyseth_i = ProxyERC20(0x5e74C9036fb86BD7eCdcb084a0673EFc32eA31cb);\r\n    // https://etherscan.io/address/0x3FFE35c3d412150C3B91d3E22eBA60E16030C608\r\n    MultiCollateralSynth public constant synthslink_i = MultiCollateralSynth(0x3FFE35c3d412150C3B91d3E22eBA60E16030C608);\r\n    // https://etherscan.io/address/0x577D4a7395c6A5f46d9981a5F83fa7294926aBB0\r\n    TokenState public constant tokenstateslink_i = TokenState(0x577D4a7395c6A5f46d9981a5F83fa7294926aBB0);\r\n    // https://etherscan.io/address/0xbBC455cb4F1B9e4bFC4B73970d360c8f032EfEE6\r\n    ProxyERC20 public constant proxyslink_i = ProxyERC20(0xbBC455cb4F1B9e4bFC4B73970d360c8f032EfEE6);\r\n    // https://etherscan.io/address/0x8f9fa817200F5B95f9572c8Acf2b31410C00335a\r\n    MultiCollateralSynth public constant synthsada_i = MultiCollateralSynth(0x8f9fa817200F5B95f9572c8Acf2b31410C00335a);\r\n    // https://etherscan.io/address/0x9956c5019a24fbd5B506AD070b771577bAc5c343\r\n    TokenState public constant tokenstatesada_i = TokenState(0x9956c5019a24fbd5B506AD070b771577bAc5c343);\r\n    // https://etherscan.io/address/0xe36E2D3c7c34281FA3bC737950a68571736880A1\r\n    ProxyERC20 public constant proxysada_i = ProxyERC20(0xe36E2D3c7c34281FA3bC737950a68571736880A1);\r\n    // https://etherscan.io/address/0x0705F0716b12a703d4F8832Ec7b97C61771f0361\r\n    MultiCollateralSynth public constant synthsaave_i = MultiCollateralSynth(0x0705F0716b12a703d4F8832Ec7b97C61771f0361);\r\n    // https://etherscan.io/address/0x9BcED8A8E3Ad81c9b146FFC880358f734A06f7c0\r\n    TokenState public constant tokenstatesaave_i = TokenState(0x9BcED8A8E3Ad81c9b146FFC880358f734A06f7c0);\r\n    // https://etherscan.io/address/0xd2dF355C19471c8bd7D8A3aa27Ff4e26A21b4076\r\n    ProxyERC20 public constant proxysaave_i = ProxyERC20(0xd2dF355C19471c8bd7D8A3aa27Ff4e26A21b4076);\r\n    // https://etherscan.io/address/0xfA60918C4417b64E722ca15d79C751c1f24Ab995\r\n    MultiCollateralSynth public constant synthsdot_i = MultiCollateralSynth(0xfA60918C4417b64E722ca15d79C751c1f24Ab995);\r\n    // https://etherscan.io/address/0x73B1a2643507Cd30F11Dfcf2D974f4373E5BC077\r\n    TokenState public constant tokenstatesdot_i = TokenState(0x73B1a2643507Cd30F11Dfcf2D974f4373E5BC077);\r\n    // https://etherscan.io/address/0x1715AC0743102BF5Cd58EfBB6Cf2dC2685d967b6\r\n    ProxyERC20 public constant proxysdot_i = ProxyERC20(0x1715AC0743102BF5Cd58EfBB6Cf2dC2685d967b6);\r\n    // https://etherscan.io/address/0xe59dFC746D566EB40F92ed0B162004e24E3AC932\r\n    MultiCollateralSynth public constant synthsdefi_i = MultiCollateralSynth(0xe59dFC746D566EB40F92ed0B162004e24E3AC932);\r\n    // https://etherscan.io/address/0x7Ac2D37098a65B0f711CFfA3be635F1E6aCacFaB\r\n    TokenState public constant tokenstatesdefi_i = TokenState(0x7Ac2D37098a65B0f711CFfA3be635F1E6aCacFaB);\r\n    // https://etherscan.io/address/0xe1aFe1Fd76Fd88f78cBf599ea1846231B8bA3B6B\r\n    ProxyERC20 public constant proxysdefi_i = ProxyERC20(0xe1aFe1Fd76Fd88f78cBf599ea1846231B8bA3B6B);\r\n    // https://etherscan.io/address/0xC2F1F551bfAd1E9A3b4816513bFd41d77f40F915\r\n    Issuer public constant issuer_i = Issuer(0xC2F1F551bfAd1E9A3b4816513bFd41d77f40F915);\r\n    // https://etherscan.io/address/0xb6B476C41Ea01930e6abE1f44b96800de0404c98\r\n    SystemSettings public constant systemsettings_i = SystemSettings(0xb6B476C41Ea01930e6abE1f44b96800de0404c98);\r\n\r\n    // ----------------------------------\r\n    // NEW CONTRACTS DEPLOYED TO BE ADDED\r\n    // ----------------------------------\r\n\r\n    // https://etherscan.io/address/0xb6B476C41Ea01930e6abE1f44b96800de0404c98\r\n    address public constant new_SystemSettings_contract = 0xb6B476C41Ea01930e6abE1f44b96800de0404c98;\r\n    // https://etherscan.io/address/0x6d9296Df2ad52F174bF671f555d78628bEBa7752\r\n    address public constant new_ExchangeRates_contract = 0x6d9296Df2ad52F174bF671f555d78628bEBa7752;\r\n    // https://etherscan.io/address/0xc398406FFfBEd5B0680e706634490062CB1DB579\r\n    address public constant new_FeePool_contract = 0xc398406FFfBEd5B0680e706634490062CB1DB579;\r\n    // https://etherscan.io/address/0xDC01020857afbaE65224CfCeDb265d1216064c59\r\n    address public constant new_Synthetix_contract = 0xDC01020857afbaE65224CfCeDb265d1216064c59;\r\n    // https://etherscan.io/address/0x9D5551Cd3425Dd4585c3E7Eb7E4B98902222521E\r\n    address public constant new_DebtCache_contract = 0x9D5551Cd3425Dd4585c3E7Eb7E4B98902222521E;\r\n    // https://etherscan.io/address/0x2A417C61B8062363e4ff50900779463b45d235f6\r\n    address public constant new_Exchanger_contract = 0x2A417C61B8062363e4ff50900779463b45d235f6;\r\n    // https://etherscan.io/address/0xC2F1F551bfAd1E9A3b4816513bFd41d77f40F915\r\n    address public constant new_Issuer_contract = 0xC2F1F551bfAd1E9A3b4816513bFd41d77f40F915;\r\n    // https://etherscan.io/address/0x0a6956d554485a43494D69Eca78C5103511a8fEb\r\n    address public constant new_WrapperFactory_contract = 0x0a6956d554485a43494D69Eca78C5103511a8fEb;\r\n    // https://etherscan.io/address/0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA\r\n    address public constant new_SynthsUSD_contract = 0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA;\r\n    // https://etherscan.io/address/0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0\r\n    address public constant new_SynthsEUR_contract = 0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0;\r\n    // https://etherscan.io/address/0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A\r\n    address public constant new_SynthsJPY_contract = 0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A;\r\n    // https://etherscan.io/address/0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827\r\n    address public constant new_SynthsAUD_contract = 0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827;\r\n    // https://etherscan.io/address/0xde3892383965FBa6eC434bE6350F85f140098708\r\n    address public constant new_SynthsGBP_contract = 0xde3892383965FBa6eC434bE6350F85f140098708;\r\n    // https://etherscan.io/address/0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D\r\n    address public constant new_SynthsCHF_contract = 0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D;\r\n    // https://etherscan.io/address/0xe2f532c389deb5E42DCe53e78A9762949A885455\r\n    address public constant new_SynthsKRW_contract = 0xe2f532c389deb5E42DCe53e78A9762949A885455;\r\n    // https://etherscan.io/address/0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353\r\n    address public constant new_SynthsBTC_contract = 0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353;\r\n    // https://etherscan.io/address/0xc70B42930BD8D30A79B55415deC3be60827559f7\r\n    address public constant new_SynthsETH_contract = 0xc70B42930BD8D30A79B55415deC3be60827559f7;\r\n    // https://etherscan.io/address/0x3FFE35c3d412150C3B91d3E22eBA60E16030C608\r\n    address public constant new_SynthsLINK_contract = 0x3FFE35c3d412150C3B91d3E22eBA60E16030C608;\r\n    // https://etherscan.io/address/0x8f9fa817200F5B95f9572c8Acf2b31410C00335a\r\n    address public constant new_SynthsADA_contract = 0x8f9fa817200F5B95f9572c8Acf2b31410C00335a;\r\n    // https://etherscan.io/address/0x0705F0716b12a703d4F8832Ec7b97C61771f0361\r\n    address public constant new_SynthsAAVE_contract = 0x0705F0716b12a703d4F8832Ec7b97C61771f0361;\r\n    // https://etherscan.io/address/0xfA60918C4417b64E722ca15d79C751c1f24Ab995\r\n    address public constant new_SynthsDOT_contract = 0xfA60918C4417b64E722ca15d79C751c1f24Ab995;\r\n    // https://etherscan.io/address/0xe59dFC746D566EB40F92ed0B162004e24E3AC932\r\n    address public constant new_SynthsDEFI_contract = 0xe59dFC746D566EB40F92ed0B162004e24E3AC932;\r\n\r\n    constructor() public BaseMigration(OWNER) {}\r\n\r\n    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {\r\n        contracts = new address[](57);\r\n        contracts[0] = address(addressresolver_i);\r\n        contracts[1] = address(proxyfeepool_i);\r\n        contracts[2] = address(feepooleternalstorage_i);\r\n        contracts[3] = address(feepoolstate_i);\r\n        contracts[4] = address(proxysynthetix_i);\r\n        contracts[5] = address(exchangestate_i);\r\n        contracts[6] = address(systemstatus_i);\r\n        contracts[7] = address(tokenstatesynthetix_i);\r\n        contracts[8] = address(synthetixstate_i);\r\n        contracts[9] = address(rewardescrow_i);\r\n        contracts[10] = address(rewardsdistribution_i);\r\n        contracts[11] = address(feepool_i);\r\n        contracts[12] = address(exchangerates_i);\r\n        contracts[13] = address(synthsusd_i);\r\n        contracts[14] = address(tokenstatesusd_i);\r\n        contracts[15] = address(proxysusd_i);\r\n        contracts[16] = address(synthseur_i);\r\n        contracts[17] = address(tokenstateseur_i);\r\n        contracts[18] = address(proxyseur_i);\r\n        contracts[19] = address(synthsjpy_i);\r\n        contracts[20] = address(tokenstatesjpy_i);\r\n        contracts[21] = address(proxysjpy_i);\r\n        contracts[22] = address(synthsaud_i);\r\n        contracts[23] = address(tokenstatesaud_i);\r\n        contracts[24] = address(proxysaud_i);\r\n        contracts[25] = address(synthsgbp_i);\r\n        contracts[26] = address(tokenstatesgbp_i);\r\n        contracts[27] = address(proxysgbp_i);\r\n        contracts[28] = address(synthschf_i);\r\n        contracts[29] = address(tokenstateschf_i);\r\n        contracts[30] = address(proxyschf_i);\r\n        contracts[31] = address(synthskrw_i);\r\n        contracts[32] = address(tokenstateskrw_i);\r\n        contracts[33] = address(proxyskrw_i);\r\n        contracts[34] = address(synthsbtc_i);\r\n        contracts[35] = address(tokenstatesbtc_i);\r\n        contracts[36] = address(proxysbtc_i);\r\n        contracts[37] = address(synthseth_i);\r\n        contracts[38] = address(tokenstateseth_i);\r\n        contracts[39] = address(proxyseth_i);\r\n        contracts[40] = address(synthslink_i);\r\n        contracts[41] = address(tokenstateslink_i);\r\n        contracts[42] = address(proxyslink_i);\r\n        contracts[43] = address(synthsada_i);\r\n        contracts[44] = address(tokenstatesada_i);\r\n        contracts[45] = address(proxysada_i);\r\n        contracts[46] = address(synthsaave_i);\r\n        contracts[47] = address(tokenstatesaave_i);\r\n        contracts[48] = address(proxysaave_i);\r\n        contracts[49] = address(synthsdot_i);\r\n        contracts[50] = address(tokenstatesdot_i);\r\n        contracts[51] = address(proxysdot_i);\r\n        contracts[52] = address(synthsdefi_i);\r\n        contracts[53] = address(tokenstatesdefi_i);\r\n        contracts[54] = address(proxysdefi_i);\r\n        contracts[55] = address(issuer_i);\r\n        contracts[56] = address(systemsettings_i);\r\n    }\r\n\r\n    function migrate(address currentOwner) external onlyDeployer {\r\n        require(owner == currentOwner, \"Only the assigned owner can be re-assigned when complete\");\r\n\r\n        Migration_Alkaid_Supplemental.require_check();\r\n\r\n        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes\r\n        acceptAll();\r\n\r\n        // MIGRATION\r\n        // Import all new contracts into the address resolver;\r\n        Migration_Alkaid_Supplemental.addressresolver_importAddresses_0();\r\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;\r\n        Migration_Alkaid_Supplemental.addressresolver_rebuildCaches_1();\r\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;\r\n        Migration_Alkaid_Supplemental.addressresolver_rebuildCaches_2();\r\n        // Ensure the ProxyFeePool contract has the correct FeePool target set;\r\n        proxyfeepool_i.setTarget(Proxyable(new_FeePool_contract));\r\n        // Ensure the FeePool contract can write to its EternalStorage;\r\n        feepooleternalstorage_i.setAssociatedContract(new_FeePool_contract);\r\n        // Ensure the FeePool contract can write to its State;\r\n        feepoolstate_i.setFeePool(IFeePool(new_FeePool_contract));\r\n        // Ensure the SNX proxy has the correct Synthetix target set;\r\n        proxysynthetix_i.setTarget(Proxyable(new_Synthetix_contract));\r\n        // Ensure the Exchanger contract can write to its State;\r\n        exchangestate_i.setAssociatedContract(new_Exchanger_contract);\r\n        // Ensure the Exchanger contract can suspend synths - see SIP-65;\r\n        systemstatus_i.updateAccessControl(\"Synth\", new_Exchanger_contract, true, false);\r\n        // Ensure the Synthetix contract can write to its TokenState contract;\r\n        tokenstatesynthetix_i.setAssociatedContract(new_Synthetix_contract);\r\n        // Ensure that Synthetix can write to its State contract;\r\n        synthetixstate_i.setAssociatedContract(new_Issuer_contract);\r\n        // Ensure the legacy RewardEscrow contract is connected to the Synthetix contract;\r\n        rewardescrow_i.setSynthetix(ISynthetix(new_Synthetix_contract));\r\n        // Ensure the legacy RewardEscrow contract is connected to the FeePool contract;\r\n        rewardescrow_i.setFeePool(IFeePool(new_FeePool_contract));\r\n        // Ensure the RewardsDistribution has Synthetix set as its authority for distribution;\r\n        rewardsdistribution_i.setAuthority(new_Synthetix_contract);\r\n        // Import fee period from existing fee pool at index 0;\r\n        Migration_Alkaid_Supplemental.importFeePeriod_0();\r\n        // Import fee period from existing fee pool at index 1;\r\n        Migration_Alkaid_Supplemental.importFeePeriod_1();\r\n        // Ensure the ExchangeRates contract has the standalone feed for SNX;\r\n        exchangerates_i.addAggregator(\"SNX\", 0xDC3EA94CD0AC27d9A86C180091e7f78C683d3699);\r\n        // Ensure the ExchangeRates contract has the standalone feed for ETH;\r\n        exchangerates_i.addAggregator(\"ETH\", 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n        // Ensure the ExchangeRates contract has the standalone feed for sXTZ (see SCCP-139);\r\n        exchangerates_i.addAggregator(\"sXTZ\", 0x5239a625dEb44bF3EeAc2CD5366ba24b8e9DB63F);\r\n        // Ensure the ExchangeRates contract has the standalone feed for sRUNE (see SCCP-139);\r\n        exchangerates_i.addAggregator(\"sRUNE\", 0x48731cF7e84dc94C5f84577882c14Be11a5B7456);\r\n        // Ensure the ExchangeRates contract has the standalone feed for sYFI (see SCCP-139);\r\n        exchangerates_i.addAggregator(\"sYFI\", 0xA027702dbb89fbd58938e4324ac03B58d812b0E1);\r\n        // Ensure the ExchangeRates contract has the standalone feed for sCRV (see SCCP-139);\r\n        exchangerates_i.addAggregator(\"sCRV\", 0xCd627aA160A6fA45Eb793D19Ef54f5062F20f33f);\r\n        // Ensure the ExchangeRates contract has the standalone feed for sUNI (see SCCP-139);\r\n        exchangerates_i.addAggregator(\"sUNI\", 0x553303d460EE0afB37EdFf9bE42922D8FF63220e);\r\n        // Ensure the ExchangeRates contract has the standalone feed for sXRP (see SCCP-139);\r\n        exchangerates_i.addAggregator(\"sXRP\", 0xCed2660c6Dd1Ffd856A5A82C67f3482d88C50b12);\r\n        // Ensure the ExchangeRates contract has the standalone feed for sBNB (see SCCP-139);\r\n        exchangerates_i.addAggregator(\"sBNB\", 0x14e613AC84a31f709eadbdF89C6CC390fDc9540A);\r\n        // Ensure the ExchangeRates contract has the standalone feed for sXAU (see SCCP-139);\r\n        exchangerates_i.addAggregator(\"sXAU\", 0x214eD9Da11D2fbe465a6fc601a91E62EbEc1a0D6);\r\n        // Ensure the new synth has the totalSupply from the previous one;\r\n        Migration_Alkaid_Supplemental.copyTotalSupplyFrom_sUSD();\r\n        // Ensure the sUSD synth can write to its TokenState;\r\n        tokenstatesusd_i.setAssociatedContract(new_SynthsUSD_contract);\r\n        // Ensure the sUSD synth Proxy is correctly connected to the Synth;\r\n        proxysusd_i.setTarget(Proxyable(new_SynthsUSD_contract));\r\n        // Ensure the new synth has the totalSupply from the previous one;\r\n        Migration_Alkaid_Supplemental.copyTotalSupplyFrom_sEUR();\r\n        // Ensure the sEUR synth can write to its TokenState;\r\n        tokenstateseur_i.setAssociatedContract(new_SynthsEUR_contract);\r\n        // Ensure the sEUR synth Proxy is correctly connected to the Synth;\r\n        proxyseur_i.setTarget(Proxyable(new_SynthsEUR_contract));\r\n        // Ensure the ExchangeRates contract has the feed for sEUR;\r\n        exchangerates_i.addAggregator(\"sEUR\", 0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\r\n        // Ensure the new synth has the totalSupply from the previous one;\r\n        Migration_Alkaid_Supplemental.copyTotalSupplyFrom_sJPY();\r\n        // Ensure the sJPY synth can write to its TokenState;\r\n        tokenstatesjpy_i.setAssociatedContract(new_SynthsJPY_contract);\r\n        // Ensure the sJPY synth Proxy is correctly connected to the Synth;\r\n        proxysjpy_i.setTarget(Proxyable(new_SynthsJPY_contract));\r\n        // Ensure the ExchangeRates contract has the feed for sJPY;\r\n        exchangerates_i.addAggregator(\"sJPY\", 0xBcE206caE7f0ec07b545EddE332A47C2F75bbeb3);\r\n        // Ensure the new synth has the totalSupply from the previous one;\r\n        Migration_Alkaid_Supplemental.copyTotalSupplyFrom_sAUD();\r\n        // Ensure the sAUD synth can write to its TokenState;\r\n        tokenstatesaud_i.setAssociatedContract(new_SynthsAUD_contract);\r\n        // Ensure the sAUD synth Proxy is correctly connected to the Synth;\r\n        proxysaud_i.setTarget(Proxyable(new_SynthsAUD_contract));\r\n        // Ensure the ExchangeRates contract has the feed for sAUD;\r\n        exchangerates_i.addAggregator(\"sAUD\", 0x77F9710E7d0A19669A13c055F62cd80d313dF022);\r\n        // Ensure the new synth has the totalSupply from the previous one;\r\n        Migration_Alkaid_Supplemental.copyTotalSupplyFrom_sGBP();\r\n        // Ensure the sGBP synth can write to its TokenState;\r\n        tokenstatesgbp_i.setAssociatedContract(new_SynthsGBP_contract);\r\n        // Ensure the sGBP synth Proxy is correctly connected to the Synth;\r\n        proxysgbp_i.setTarget(Proxyable(new_SynthsGBP_contract));\r\n        // Ensure the ExchangeRates contract has the feed for sGBP;\r\n        exchangerates_i.addAggregator(\"sGBP\", 0x5c0Ab2d9b5a7ed9f470386e82BB36A3613cDd4b5);\r\n        // Ensure the new synth has the totalSupply from the previous one;\r\n        Migration_Alkaid_Supplemental.copyTotalSupplyFrom_sCHF();\r\n        // Ensure the sCHF synth can write to its TokenState;\r\n        tokenstateschf_i.setAssociatedContract(new_SynthsCHF_contract);\r\n        // Ensure the sCHF synth Proxy is correctly connected to the Synth;\r\n        proxyschf_i.setTarget(Proxyable(new_SynthsCHF_contract));\r\n        // Ensure the ExchangeRates contract has the feed for sCHF;\r\n        exchangerates_i.addAggregator(\"sCHF\", 0x449d117117838fFA61263B61dA6301AA2a88B13A);\r\n        // Ensure the new synth has the totalSupply from the previous one;\r\n        Migration_Alkaid_Supplemental.copyTotalSupplyFrom_sKRW();\r\n        // Ensure the sKRW synth can write to its TokenState;\r\n        tokenstateskrw_i.setAssociatedContract(new_SynthsKRW_contract);\r\n        // Ensure the sKRW synth Proxy is correctly connected to the Synth;\r\n        proxyskrw_i.setTarget(Proxyable(new_SynthsKRW_contract));\r\n        // Ensure the ExchangeRates contract has the feed for sKRW;\r\n        exchangerates_i.addAggregator(\"sKRW\", 0x01435677FB11763550905594A16B645847C1d0F3);\r\n        // Ensure the new synth has the totalSupply from the previous one;\r\n        Migration_Alkaid_Supplemental.copyTotalSupplyFrom_sBTC();\r\n        // Ensure the sBTC synth can write to its TokenState;\r\n        tokenstatesbtc_i.setAssociatedContract(new_SynthsBTC_contract);\r\n        // Ensure the sBTC synth Proxy is correctly connected to the Synth;\r\n        proxysbtc_i.setTarget(Proxyable(new_SynthsBTC_contract));\r\n        // Ensure the ExchangeRates contract has the feed for sBTC;\r\n        exchangerates_i.addAggregator(\"sBTC\", 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);\r\n        // Ensure the new synth has the totalSupply from the previous one;\r\n        Migration_Alkaid_Supplemental.copyTotalSupplyFrom_sETH();\r\n        // Ensure the sETH synth can write to its TokenState;\r\n        tokenstateseth_i.setAssociatedContract(new_SynthsETH_contract);\r\n        // Ensure the sETH synth Proxy is correctly connected to the Synth;\r\n        proxyseth_i.setTarget(Proxyable(new_SynthsETH_contract));\r\n        // Ensure the ExchangeRates contract has the feed for sETH;\r\n        exchangerates_i.addAggregator(\"sETH\", 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n        // Ensure the new synth has the totalSupply from the previous one;\r\n        Migration_Alkaid_Supplemental.copyTotalSupplyFrom_sLINK();\r\n        // Ensure the sLINK synth can write to its TokenState;\r\n        tokenstateslink_i.setAssociatedContract(new_SynthsLINK_contract);\r\n        // Ensure the sLINK synth Proxy is correctly connected to the Synth;\r\n        proxyslink_i.setTarget(Proxyable(new_SynthsLINK_contract));\r\n        // Ensure the ExchangeRates contract has the feed for sLINK;\r\n        exchangerates_i.addAggregator(\"sLINK\", 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c);\r\n        // Ensure the new synth has the totalSupply from the previous one;\r\n        Migration_Alkaid_Supplemental.copyTotalSupplyFrom_sADA();\r\n        // Ensure the sADA synth can write to its TokenState;\r\n        tokenstatesada_i.setAssociatedContract(new_SynthsADA_contract);\r\n        // Ensure the sADA synth Proxy is correctly connected to the Synth;\r\n        proxysada_i.setTarget(Proxyable(new_SynthsADA_contract));\r\n        // Ensure the ExchangeRates contract has the feed for sADA;\r\n        exchangerates_i.addAggregator(\"sADA\", 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55);\r\n        // Ensure the new synth has the totalSupply from the previous one;\r\n        Migration_Alkaid_Supplemental.copyTotalSupplyFrom_sAAVE();\r\n        // Ensure the sAAVE synth can write to its TokenState;\r\n        tokenstatesaave_i.setAssociatedContract(new_SynthsAAVE_contract);\r\n        // Ensure the sAAVE synth Proxy is correctly connected to the Synth;\r\n        proxysaave_i.setTarget(Proxyable(new_SynthsAAVE_contract));\r\n        // Ensure the ExchangeRates contract has the feed for sAAVE;\r\n        exchangerates_i.addAggregator(\"sAAVE\", 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9);\r\n        // Ensure the new synth has the totalSupply from the previous one;\r\n        Migration_Alkaid_Supplemental.copyTotalSupplyFrom_sDOT();\r\n        // Ensure the sDOT synth can write to its TokenState;\r\n        tokenstatesdot_i.setAssociatedContract(new_SynthsDOT_contract);\r\n        // Ensure the sDOT synth Proxy is correctly connected to the Synth;\r\n        proxysdot_i.setTarget(Proxyable(new_SynthsDOT_contract));\r\n        // Ensure the ExchangeRates contract has the feed for sDOT;\r\n        exchangerates_i.addAggregator(\"sDOT\", 0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734);\r\n        // Ensure the new synth has the totalSupply from the previous one;\r\n        Migration_Alkaid_Supplemental.copyTotalSupplyFrom_sDEFI();\r\n        // Ensure the sDEFI synth can write to its TokenState;\r\n        tokenstatesdefi_i.setAssociatedContract(new_SynthsDEFI_contract);\r\n        // Ensure the sDEFI synth Proxy is correctly connected to the Synth;\r\n        proxysdefi_i.setTarget(Proxyable(new_SynthsDEFI_contract));\r\n        // Ensure the ExchangeRates contract has the feed for sDEFI;\r\n        exchangerates_i.addAggregator(\"sDEFI\", 0xa8E875F94138B0C5b51d1e1d5dE35bbDdd28EA87);\r\n        // Add synths to the Issuer contract - batch 1;\r\n        Migration_Alkaid_Supplemental.issuer_addSynths_105();\r\n        // SIP-120 Set max atomic volume per block (in USD amounts);\r\n        systemsettings_i.setAtomicMaxVolumePerBlock(200000000000000000000000);\r\n        // SIP-120 Set the TWAP window for atomic swaps;\r\n        systemsettings_i.setAtomicTwapWindow(1800);\r\n        // SIP-120 Set the equivalent token - used in uniswap pools - corresponding to this synth;\r\n        systemsettings_i.setAtomicEquivalentForDexPricing(\"sUSD\", 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n        // SIP-120 Set the equivalent token - used in uniswap pools - corresponding to this synth;\r\n        systemsettings_i.setAtomicEquivalentForDexPricing(\"sETH\", 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n        // SIP-120 Set the equivalent token - used in uniswap pools - corresponding to this synth;\r\n        systemsettings_i.setAtomicEquivalentForDexPricing(\"sBTC\", 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\r\n        // SIP-120 Set the exchange fee rate for swapping atomically into this synth;\r\n        systemsettings_i.setAtomicExchangeFeeRate(\"sETH\", 3000000000000000);\r\n        // SIP-120 Set the exchange fee rate for swapping atomically into this synth;\r\n        systemsettings_i.setAtomicExchangeFeeRate(\"sBTC\", 3000000000000000);\r\n        // SIP-120 Set the exchange fee rate for swapping atomically into this synth;\r\n        systemsettings_i.setAtomicExchangeFeeRate(\"sUSD\", 3000000000000000);\r\n        // SIP-120 Set the price buffer applied to the base chainlink rate when comparing atomically;\r\n        systemsettings_i.setAtomicPriceBuffer(\"sETH\", 1500000000000000);\r\n        // SIP-120 Set the price buffer applied to the base chainlink rate when comparing atomically;\r\n        systemsettings_i.setAtomicPriceBuffer(\"sBTC\", 1500000000000000);\r\n        // SIP-120 Set the atomic volatility window for this synth (in seconds);\r\n        systemsettings_i.setAtomicVolatilityConsiderationWindow(\"sETH\", 600);\r\n        // SIP-120 Set the atomic volatility window for this synth (in seconds);\r\n        systemsettings_i.setAtomicVolatilityConsiderationWindow(\"sBTC\", 600);\r\n        // SIP-120 Set the atomic volatility count for this synth during the volatility window;\r\n        systemsettings_i.setAtomicVolatilityUpdateThreshold(\"sETH\", 3);\r\n        // SIP-120 Set the atomic volatility count for this synth during the volatility window;\r\n        systemsettings_i.setAtomicVolatilityUpdateThreshold(\"sBTC\", 3);\r\n        // SIP-120 Set the DEX price aggregator (uniswap TWAP oracle reader);\r\n        exchangerates_i.setDexPriceAggregator(IDexPriceAggregator(0xf120F029Ac143633d1942e48aE2Dfa2036C5786c));\r\n        // Ensure the CollateralShort contract has an interaction delay of zero on the OVM;\r\n        systemsettings_i.setInteractionDelay(0x1F2c3a1046c32729862fcB038369696e3273a516, 3600);\r\n        // Ensure the CollateralShort contract has its service fee set for collapsing loans (SIP-135);\r\n        systemsettings_i.setCollapseFeeRate(0x1F2c3a1046c32729862fcB038369696e3273a516, 0);\r\n\r\n        // NOMINATE OWNERSHIP back to owner for aforementioned contracts\r\n        nominateAll();\r\n    }\r\n\r\n    function acceptAll() internal {\r\n        address[] memory contracts = contractsRequiringOwnership();\r\n        for (uint i = 0; i < contracts.length; i++) {\r\n            Owned(contracts[i]).acceptOwnership();\r\n        }\r\n    }\r\n\r\n    function nominateAll() internal {\r\n        address[] memory contracts = contractsRequiringOwnership();\r\n        for (uint i = 0; i < contracts.length; i++) {\r\n            returnOwnership(contracts[i]);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"OWNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressresolver_i\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractsRequiringOwnership\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangerates_i\",\"outputs\":[{\"internalType\":\"contract ExchangeRatesWithDexPricing\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangestate_i\",\"outputs\":[{\"internalType\":\"contract ExchangeState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feepool_i\",\"outputs\":[{\"internalType\":\"contract FeePool\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feepooleternalstorage_i\",\"outputs\":[{\"internalType\":\"contract FeePoolEternalStorage\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feepoolstate_i\",\"outputs\":[{\"internalType\":\"contract FeePoolState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuer_i\",\"outputs\":[{\"internalType\":\"contract Issuer\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_DebtCache_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_ExchangeRates_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Exchanger_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_FeePool_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Issuer_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Synthetix_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsAAVE_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsADA_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsAUD_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsBTC_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsCHF_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsDEFI_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsDOT_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsETH_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsEUR_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsGBP_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsJPY_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsKRW_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsLINK_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SynthsUSD_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SystemSettings_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_WrapperFactory_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyfeepool_i\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysaave_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysada_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysaud_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysbtc_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyschf_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysdefi_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysdot_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyseth_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyseur_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysgbp_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysjpy_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyskrw_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxyslink_i\",\"outputs\":[{\"internalType\":\"contract ProxyERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysusd_i\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxysynthetix_i\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"forContract\",\"type\":\"address\"}],\"name\":\"returnOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardescrow_i\",\"outputs\":[{\"internalType\":\"contract RewardEscrow\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsdistribution_i\",\"outputs\":[{\"internalType\":\"contract RewardsDistribution\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthetixstate_i\",\"outputs\":[{\"internalType\":\"contract SynthetixState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsaave_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsada_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsaud_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsbtc_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthschf_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsdefi_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsdot_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthseth_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthseur_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsgbp_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsjpy_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthskrw_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthslink_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"synthsusd_i\",\"outputs\":[{\"internalType\":\"contract MultiCollateralSynth\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemsettings_i\",\"outputs\":[{\"internalType\":\"contract SystemSettings\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemstatus_i\",\"outputs\":[{\"internalType\":\"contract SystemStatus\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesaave_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesada_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesaud_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesbtc_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateschf_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesdefi_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesdot_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateseth_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateseur_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesgbp_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesjpy_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateskrw_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstateslink_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesusd_i\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenstatesynthetix_i\",\"outputs\":[{\"internalType\":\"contract LegacyTokenState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Migration_Alkaid","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"Migration_Alkaid_Supplemental:6efd217b5fa2b2eddf9edb07b9e501f99d7efdc0","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://7669ccdb4c6189080a589f3b7bc7bdea38a8c93d32bb76aee4a92eb6bb94c7ca"}]}