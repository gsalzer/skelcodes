{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @title PawnFloorOracle\r\n * @dev Stores and retrieves floor prices for a nft collection\r\n */\r\ncontract PawnFloorOracle  {\r\n    address public collection;\r\n    address public underwriter;\r\n    uint256 public lastUpdate;\r\n    uint256 public floor;\r\n    \r\n    event FloorChange(uint256 price, address underwriter, bool sale);\r\n    \r\n    constructor(address collection_) payable {\r\n        collection = collection_;\r\n    }\r\n    \r\n    modifier lastTransferAtLeast69Minutes() {\r\n        require(block.timestamp - timeSinceLastUpdate() > 69 minutes);\r\n        _;\r\n    }\r\n    \r\n    function timeSinceLastUpdate() public view returns (uint256) {\r\n        return block.timestamp - lastUpdate;\r\n    }\r\n    \r\n    function sellFloor(uint256 tokenId) public {\r\n        IERC721 c = IERC721(collection);\r\n        require(msg.sender == c.ownerOf(tokenId), \"not the owner\");\r\n        c.safeTransferFrom(msg.sender, underwriter, tokenId);\r\n        payable(msg.sender).transfer(floor);\r\n        underwriter = 0x0000000000000000000000000000000000000000;\r\n        floor = 0;\r\n        lastUpdate = block.timestamp;\r\n        emit FloorChange(floor, underwriter, true);\r\n    }\r\n    \r\n     /**\r\n     * @dev withdraw money \r\n     */\r\n    function withdraw() public lastTransferAtLeast69Minutes {\r\n        require(msg.sender == underwriter, \"only underwriter can withdraw their eth\");\r\n        payable(msg.sender).transfer(floor);\r\n        underwriter = 0x0000000000000000000000000000000000000000;\r\n        floor = 0;\r\n        lastUpdate = block.timestamp;\r\n        emit FloorChange(floor, underwriter, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Change the current price of this oracle up or down\r\n     */\r\n    function updateFloor() public payable {\r\n        require(floor != msg.value && msg.value != 0, \"invalid update\");\r\n        if (floor == 0) {\r\n            underwriter = tx.origin;\r\n            floor = msg.value;\r\n            lastUpdate = block.timestamp;\r\n            emit FloorChange(floor, underwriter, false);\r\n        } else {\r\n            require(block.timestamp - timeSinceLastUpdate() > 69 seconds, \"not enough time elapsed\");\r\n            if (msg.value > floor) {\r\n                require(payable(underwriter).send(address(this).balance), \"old underwriter payout failed\");\r\n                floor = msg.value;\r\n                underwriter = tx.origin;\r\n                lastUpdate = block.timestamp;\r\n                emit FloorChange(floor, underwriter, false);\r\n            } else if (msg.value < floor) {\r\n                require(underwriter == tx.origin, \"only underwriter can lower floor\");\r\n                payable(tx.origin).transfer(floor);\r\n                floor = msg.value;\r\n                lastUpdate = block.timestamp;\r\n                emit FloorChange(floor, underwriter, false);\r\n            }\r\n        }\r\n    }\r\n    \r\n    fallback() external payable {\r\n\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract PawnFloorOracleFactory {\r\n    \r\n    mapping(address=>address) public oracles;\r\n    \r\n    constructor() {\r\n        \r\n    }\r\n    \r\n    function addOracle(address collection) public payable {\r\n        require(oracles[collection] == 0x0000000000000000000000000000000000000000, \"already exists\");\r\n        require(msg.value > 0, \"non zero oracle\");\r\n        PawnFloorOracle fo = new PawnFloorOracle(collection);\r\n        fo.updateFloor{value: msg.value}();\r\n        oracles[collection] = address(fo);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"addOracle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"oracles\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PawnFloorOracleFactory","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"400","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://aa2ce36890c061f95c727e04b2e561c684a8040327fa399705d323531a46f9d0"}]}