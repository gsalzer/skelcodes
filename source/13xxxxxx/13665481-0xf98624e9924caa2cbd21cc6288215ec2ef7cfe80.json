{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Controller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport \\\"./TellorStaking.sol\\\";\\nimport \\\"./interfaces/IController.sol\\\";\\nimport \\\"./Transition.sol\\\";\\nimport \\\"./Getters.sol\\\";\\n\\n/**\\n @author Tellor Inc.\\n @title Controller\\n @dev This is the Controller contract which defines the functionality for\\n * changing contract addresses, as well as minting and migrating tokens\\n*/\\ncontract Controller is TellorStaking, Transition, Getters {\\n    // Events\\n    event NewContractAddress(address _newContract, string _contractName);\\n\\n    // Functions\\n    /**\\n     * @dev Saves new Tellor contract addresses. Available to Transition init function after fork vote\\n     * @param _governance is the address of the Governance contract\\n     * @param _oracle is the address of the Oracle contract\\n     * @param _treasury is the address of the Treasury contract\\n     */\\n    constructor(\\n        address _governance,\\n        address _oracle,\\n        address _treasury\\n    ) Transition(_governance, _oracle, _treasury) {}\\n\\n    /**\\n     * @dev Changes Controller contract to a new address\\n     * Note: this function is only callable by the Governance contract.\\n     * @param _newController is the address of the new Controller contract\\n     */\\n    function changeControllerContract(address _newController) external {\\n        require(\\n            msg.sender == addresses[_GOVERNANCE_CONTRACT],\\n            \\\"Only the Governance contract can change the Controller contract address\\\"\\n        );\\n        require(_isValid(_newController));\\n        addresses[_TELLOR_CONTRACT] = _newController; //name _TELLOR_CONTRACT is hardcoded in\\n        assembly {\\n            sstore(_EIP_SLOT, _newController)\\n        }\\n        emit NewContractAddress(_newController, \\\"Controller\\\");\\n    }\\n\\n    /**\\n     * @dev Changes Governance contract to a new address\\n     * Note: this function is only callable by the Governance contract.\\n     * @param _newGovernance is the address of the new Governance contract\\n     */\\n    function changeGovernanceContract(address _newGovernance) external {\\n        require(\\n            msg.sender == addresses[_GOVERNANCE_CONTRACT],\\n            \\\"Only the Governance contract can change the Governance contract address\\\"\\n        );\\n        require(_isValid(_newGovernance));\\n        addresses[_GOVERNANCE_CONTRACT] = _newGovernance;\\n        emit NewContractAddress(_newGovernance, \\\"Governance\\\");\\n    }\\n\\n    /**\\n     * @dev Changes Oracle contract to a new address\\n     * Note: this function is only callable by the Governance contract.\\n     * @param _newOracle is the address of the new Oracle contract\\n     */\\n    function changeOracleContract(address _newOracle) external {\\n        require(\\n            msg.sender == addresses[_GOVERNANCE_CONTRACT],\\n            \\\"Only the Governance contract can change the Oracle contract address\\\"\\n        );\\n        require(_isValid(_newOracle));\\n        addresses[_ORACLE_CONTRACT] = _newOracle;\\n        emit NewContractAddress(_newOracle, \\\"Oracle\\\");\\n    }\\n\\n    /**\\n     * @dev Changes Treasury contract to a new address\\n     * Note: this function is only callable by the Governance contract.\\n     * @param _newTreasury is the address of the new Treasury contract\\n     */\\n    function changeTreasuryContract(address _newTreasury) external {\\n        require(\\n            msg.sender == addresses[_GOVERNANCE_CONTRACT],\\n            \\\"Only the Governance contract can change the Treasury contract address\\\"\\n        );\\n        require(_isValid(_newTreasury));\\n        addresses[_TREASURY_CONTRACT] = _newTreasury;\\n        emit NewContractAddress(_newTreasury, \\\"Treasury\\\");\\n    }\\n\\n    /**\\n     * @dev Changes a uint for a specific target index\\n     * Note: this function is only callable by the Governance contract.\\n     * @param _target is the index of the uint to change\\n     * @param _amount is the amount to change the given uint to\\n     */\\n    function changeUint(bytes32 _target, uint256 _amount) external {\\n        require(\\n            msg.sender == addresses[_GOVERNANCE_CONTRACT],\\n            \\\"Only the Governance contract can change the uint\\\"\\n        );\\n        uints[_target] = _amount;\\n    }\\n\\n    /**\\n     * @dev Mints tokens of the sender from the old contract to the sender\\n     */\\n    function migrate() external {\\n        require(!migrated[msg.sender], \\\"Already migrated\\\");\\n        _doMint(\\n            msg.sender,\\n            IController(addresses[_OLD_TELLOR]).balanceOf(msg.sender)\\n        );\\n        migrated[msg.sender] = true;\\n    }\\n\\n    /**\\n     * @dev Mints TRB to a given receiver address\\n     * @param _receiver is the address that will receive the minted tokens\\n     * @param _amount is the amount of tokens that will be minted to the _receiver address\\n     */\\n    function mint(address _receiver, uint256 _amount) external {\\n        require(\\n            msg.sender == addresses[_GOVERNANCE_CONTRACT] ||\\n                msg.sender == addresses[_TREASURY_CONTRACT] ||\\n                msg.sender == TELLOR_ADDRESS,\\n            \\\"Only governance, treasury, or master can mint tokens\\\"\\n        );\\n        _doMint(_receiver, _amount);\\n    }\\n\\n    /**\\n     * @dev Used during the upgrade process to verify valid Tellor Contracts\\n     */\\n    function verify() external pure returns (uint256) {\\n        return 9999;\\n    }\\n\\n    /**\\n     * @dev Used during the upgrade process to verify valid Tellor Contracts and ensure\\n     * they have the right signature\\n     * @param _contract is the address of the Tellor contract to verify\\n     * @return bool of whether or not the address is a valid Tellor contract\\n     */\\n    function _isValid(address _contract) internal returns (bool) {\\n        (bool _success, bytes memory _data) = address(_contract).call(\\n            abi.encodeWithSelector(0xfc735e99, \\\"\\\") // verify() signature\\n        );\\n        require(\\n            _success && abi.decode(_data, (uint256)) > 9000, // An arbitrary number to ensure that the contract is valid\\n            \\\"New contract is invalid\\\"\\n        );\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TellorStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport \\\"./Token.sol\\\";\\nimport \\\"./interfaces/IGovernance.sol\\\";\\n\\n/**\\n @author Tellor Inc.\\n @title TellorStaking\\n @dev This is the TellorStaking contract which defines the functionality for\\n * updating staking statuses for reporters, including depositing and withdrawing\\n * stakes.\\n*/\\ncontract TellorStaking is Token {\\n    // Events\\n    event NewStaker(address _staker);\\n    event StakeWithdrawRequested(address _staker);\\n    event StakeWithdrawn(address _staker);\\n\\n    // Functions\\n    /**\\n     * @dev Changes staking status of a reporter\\n     * Note: this function is only callable by the Governance contract.\\n     * @param _reporter is the address of the reporter to change staking status for\\n     * @param _status is the new status of the reporter\\n     */\\n    function changeStakingStatus(address _reporter, uint256 _status) external {\\n        require(\\n            IGovernance(addresses[_GOVERNANCE_CONTRACT])\\n                .isApprovedGovernanceContract(msg.sender),\\n            \\\"Only approved governance contract can change staking status\\\"\\n        );\\n        StakeInfo storage stakes = stakerDetails[_reporter];\\n        stakes.currentStatus = _status;\\n    }\\n\\n    /**\\n     * @dev Allows a reporter to submit stake\\n     */\\n    function depositStake() external {\\n        // Ensure staker has enough balance to stake\\n        require(\\n            balances[msg.sender][balances[msg.sender].length - 1].value >=\\n                uints[_STAKE_AMOUNT],\\n            \\\"Balance is lower than stake amount\\\"\\n        );\\n        // Ensure staker is currently either not staked or locked for withdraw.\\n        // Note that slashed reporters cannot stake again from a slashed address.\\n        require(\\n            stakerDetails[msg.sender].currentStatus == 0 ||\\n                stakerDetails[msg.sender].currentStatus == 2,\\n            \\\"Reporter is in the wrong state\\\"\\n        );\\n        // Increment number of stakers, create new staker, and update dispute fee\\n        uints[_STAKE_COUNT] += 1;\\n        stakerDetails[msg.sender] = StakeInfo({\\n            currentStatus: 1,\\n            startDate: block.timestamp // This resets their stake start date to now\\n        });\\n        emit NewStaker(msg.sender);\\n        IGovernance(addresses[_GOVERNANCE_CONTRACT]).updateMinDisputeFee();\\n    }\\n\\n    /**\\n     * @dev Allows a reporter to request to withdraw their stake\\n     */\\n    function requestStakingWithdraw() external {\\n        // Ensures reporter is already staked\\n        StakeInfo storage stakes = stakerDetails[msg.sender];\\n        require(stakes.currentStatus == 1, \\\"Reporter is not staked\\\");\\n        // Change status to reflect withdraw request and updates start date for staking\\n        stakes.currentStatus = 2;\\n        stakes.startDate = block.timestamp;\\n        // Update number of stakers and dispute fee\\n        uints[_STAKE_COUNT] -= 1;\\n        IGovernance(addresses[_GOVERNANCE_CONTRACT]).updateMinDisputeFee();\\n        emit StakeWithdrawRequested(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Slashes a reporter and transfers their stake amount to their disputer\\n     * Note: this function is only callable by the Governance contract.\\n     * @param _reporter is the address of the reporter being slashed\\n     * @param _disputer is the address of the disputer receiving the reporter's stake\\n     */\\n    function slashReporter(address _reporter, address _disputer) external {\\n        require(\\n            IGovernance(addresses[_GOVERNANCE_CONTRACT])\\n                .isApprovedGovernanceContract(msg.sender),\\n            \\\"Only approved governance contract can slash reporter\\\"\\n        );\\n        stakerDetails[_reporter].currentStatus = 5; // Change status of reporter to slashed\\n        // Transfer stake amount of reporter has a balance bigger than the stake amount\\n        if (balanceOf(_reporter) >= uints[_STAKE_AMOUNT]) {\\n            _doTransfer(_reporter, _disputer, uints[_STAKE_AMOUNT]);\\n        }\\n        // Else, transfer all of the reporter's balance\\n        else if (balanceOf(_reporter) > 0) {\\n            _doTransfer(_reporter, _disputer, balanceOf(_reporter));\\n        }\\n    }\\n\\n    /**\\n     * @dev Withdraws a reporter's stake\\n     */\\n    function withdrawStake() external {\\n        StakeInfo storage _s = stakerDetails[msg.sender];\\n        // Ensure reporter is locked and that enough time has passed\\n        require(block.timestamp - _s.startDate >= 7 days, \\\"7 days didn't pass\\\");\\n        require(_s.currentStatus == 2, \\\"Reporter not locked for withdrawal\\\");\\n        _s.currentStatus = 0; // Updates status to withdrawn\\n        emit StakeWithdrawn(msg.sender);\\n    }\\n\\n    /**GETTERS**/\\n    /**\\n     * @dev Allows users to retrieve all information about a staker\\n     * @param _staker address of staker inquiring about\\n     * @return uint current state of staker\\n     * @return uint startDate of staking\\n     */\\n    function getStakerInfo(address _staker)\\n        external\\n        view\\n        returns (uint256, uint256)\\n    {\\n        return (\\n            stakerDetails[_staker].currentStatus,\\n            stakerDetails[_staker].startDate\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.3;\\r\\n\\r\\ninterface IController{\\r\\n    function addresses(bytes32) external returns(address);\\r\\n    function uints(bytes32) external returns(uint256);\\r\\n    function burn(uint256 _amount) external;\\r\\n    function changeDeity(address _newDeity) external;\\r\\n    function changeOwner(address _newOwner) external;\\r\\n    function changeTellorContract(address _tContract) external;\\r\\n    function changeControllerContract(address _newController) external;\\r\\n    function changeGovernanceContract(address _newGovernance) external;\\r\\n    function changeOracleContract(address _newOracle) external;\\r\\n    function changeTreasuryContract(address _newTreasury) external;\\r\\n    function changeUint(bytes32 _target, uint256 _amount) external;\\r\\n    function migrate() external;\\r\\n    function mint(address _reciever, uint256 _amount) external;\\r\\n    function init() external;\\r\\n    function getDisputeIdByDisputeHash(bytes32 _hash) external view returns (uint256);\\r\\n    function getLastNewValueById(uint256 _requestId) external view returns (uint256, bool);\\r\\n    function retrieveData(uint256 _requestId, uint256 _timestamp) external view returns (uint256);\\r\\n    function getNewValueCountbyRequestId(uint256 _requestId) external view returns (uint256);\\r\\n    function getAddressVars(bytes32 _data) external view returns (address);\\r\\n    function getUintVar(bytes32 _data) external view returns (uint256);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function allowance(address _user, address _spender) external view  returns (uint256);\\r\\n    function allowedToTrade(address _user, uint256 _amount) external view returns (bool);\\r\\n    function approve(address _spender, uint256 _amount) external returns (bool);\\r\\n    function approveAndTransferFrom(address _from, address _to, uint256 _amount) external returns(bool);\\r\\n    function balanceOf(address _user) external view returns (uint256);\\r\\n    function balanceOfAt(address _user, uint256 _blockNumber)external view returns (uint256);\\r\\n    function transfer(address _to, uint256 _amount)external returns (bool success);\\r\\n    function transferFrom(address _from,address _to,uint256 _amount) external returns (bool success) ;\\r\\n    function depositStake() external;\\r\\n    function requestStakingWithdraw() external;\\r\\n    function withdrawStake() external;\\r\\n    function changeStakingStatus(address _reporter, uint _status) external;\\r\\n    function slashReporter(address _reporter, address _disputer) external;\\r\\n    function getStakerInfo(address _staker) external view returns (uint256, uint256);\\r\\n    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index) external view returns (uint256);\\r\\n    function getNewCurrentVariables()external view returns (bytes32 _c,uint256[5] memory _r,uint256 _d,uint256 _t);\\r\\n    //in order to call fallback function\\r\\n    function beginDispute(uint256 _requestId, uint256 _timestamp,uint256 _minerIndex) external;\\r\\n    function unlockDisputeFee(uint256 _disputeId) external;\\r\\n    function vote(uint256 _disputeId, bool _supportsDispute) external;\\r\\n    function tallyVotes(uint256 _disputeId) external;\\r\\n    //test functions\\r\\n    function tipQuery(uint,uint,bytes memory) external;\\r\\n    function getNewVariablesOnDeck() external view returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Transition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport \\\"./tellor3/TellorStorage.sol\\\";\\nimport \\\"./TellorVars.sol\\\";\\nimport \\\"./interfaces/IOracle.sol\\\";\\nimport \\\"./interfaces/IController.sol\\\";\\n\\n/**\\n @author Tellor Inc.\\n @title Transition\\n* @dev The Transition contract links to the Oracle contract and\\n* allows parties (like Liquity) to continue to use the master\\n* address to access values. All parties should be reading values\\n* through this address\\n*/\\ncontract Transition is TellorStorage, TellorVars {\\n    // Functions\\n    /**\\n     * @dev Saves new Tellor contract addresses. Available to init function after fork vote\\n     * @param _governance is the address of the Governance contract\\n     * @param _oracle is the address of the Oracle contract\\n     * @param _treasury is the address of the Treasury contract\\n     */\\n    constructor(\\n        address _governance,\\n        address _oracle,\\n        address _treasury\\n    ) {\\n        require(_governance != address(0), \\\"must set governance address\\\");\\n        addresses[_GOVERNANCE_CONTRACT] = _governance;\\n        addresses[_ORACLE_CONTRACT] = _oracle;\\n        addresses[_TREASURY_CONTRACT] = _treasury;\\n    }\\n\\n    /**\\n     * @dev Runs once Tellor is migrated over. Changes the underlying storage.\\n     */\\n    function init() external {\\n        require(\\n            addresses[_GOVERNANCE_CONTRACT] == address(0),\\n            \\\"Only good once\\\"\\n        );\\n        // Set state amount, switch time, and minimum dispute fee\\n        uints[_STAKE_AMOUNT] = 100e18;\\n        uints[_SWITCH_TIME] = block.timestamp;\\n        uints[_MINIMUM_DISPUTE_FEE] = 10e18;\\n        // Define contract addresses\\n        Transition _controller = Transition(addresses[_TELLOR_CONTRACT]);\\n        addresses[_GOVERNANCE_CONTRACT] = _controller.addresses(\\n            _GOVERNANCE_CONTRACT\\n        );\\n        addresses[_ORACLE_CONTRACT] = _controller.addresses(_ORACLE_CONTRACT);\\n        addresses[_TREASURY_CONTRACT] = _controller.addresses(\\n            _TREASURY_CONTRACT\\n        );\\n        // Mint to oracle, parachute, and team operating grant contracts\\n        IController(TELLOR_ADDRESS).mint(\\n            addresses[_ORACLE_CONTRACT],\\n            105120e18\\n        );\\n        IController(TELLOR_ADDRESS).mint(\\n            0xAa304E98f47D4a6a421F3B1cC12581511dD69C55,\\n            105120e18\\n        );\\n        IController(TELLOR_ADDRESS).mint(\\n            0x83eB2094072f6eD9F57d3F19f54820ee0BaE6084,\\n            18201e18\\n        );\\n    }\\n\\n    //Getters\\n    /**\\n     * @dev Allows users to access the number of decimals\\n     */\\n    function decimals() external pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev Allows Tellor to read data from the addressVars mapping\\n     * @param _data is the keccak256(\\\"variable_name\\\") of the variable that is being accessed.\\n     * These are examples of how the variables are saved within other functions:\\n     * addressVars[keccak256(\\\"_owner\\\")]\\n     * addressVars[keccak256(\\\"tellorContract\\\")]\\n     * @return address of the requested variable\\n     */\\n    function getAddressVars(bytes32 _data) external view returns (address) {\\n        return addresses[_data];\\n    }\\n\\n    /**\\n     * @dev Gets all dispute variables\\n     * @param _disputeId to look up\\n     * @return bytes32 hash of dispute\\n     * bool executed where true if it has been voted on\\n     * bool disputeVotePassed\\n     * bool isPropFork true if the dispute is a proposed fork\\n     * address of reportedMiner\\n     * address of reportingParty\\n     * address of proposedForkAddress\\n     * uint256 of requestId\\n     * uint256 of timestamp\\n     * uint256 of value\\n     * uint256 of minExecutionDate\\n     * uint256 of numberOfVotes\\n     * uint256 of blocknumber\\n     * uint256 of minerSlot\\n     * uint256 of quorum\\n     * uint256 of fee\\n     * int256 count of the current tally\\n     */\\n    function getAllDisputeVars(uint256 _disputeId)\\n        external\\n        view\\n        returns (\\n            bytes32,\\n            bool,\\n            bool,\\n            bool,\\n            address,\\n            address,\\n            address,\\n            uint256[9] memory,\\n            int256\\n        )\\n    {\\n        Dispute storage disp = disputesById[_disputeId];\\n        return (\\n            disp.hash,\\n            disp.executed,\\n            disp.disputeVotePassed,\\n            disp.isPropFork,\\n            disp.reportedMiner,\\n            disp.reportingParty,\\n            disp.proposedForkAddress,\\n            [\\n                disp.disputeUintVars[_REQUEST_ID],\\n                disp.disputeUintVars[_TIMESTAMP],\\n                disp.disputeUintVars[_VALUE],\\n                disp.disputeUintVars[_MIN_EXECUTION_DATE],\\n                disp.disputeUintVars[_NUM_OF_VOTES],\\n                disp.disputeUintVars[_BLOCK_NUMBER],\\n                disp.disputeUintVars[_MINER_SLOT],\\n                disp.disputeUintVars[keccak256(\\\"quorum\\\")],\\n                disp.disputeUintVars[_FEE]\\n            ],\\n            disp.tally\\n        );\\n    }\\n\\n    /**\\n     * @dev Gets id if a given hash has been disputed\\n     * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId,_timestamp));\\n     * @return uint256 disputeId\\n     */\\n    function getDisputeIdByDisputeHash(bytes32 _hash)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return disputeIdByDisputeHash[_hash];\\n    }\\n\\n    /**\\n     * @dev Checks for uint variables in the disputeUintVars mapping based on the disputeId\\n     * @param _disputeId is the dispute id;\\n     * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\") where variable_name is\\n     * the variables/strings used to save the data in the mapping. The variables names are\\n     * commented out under the disputeUintVars under the Dispute struct\\n     * @return uint256 value for the bytes32 data submitted\\n     */\\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return disputesById[_disputeId].disputeUintVars[_data];\\n    }\\n\\n    /**\\n     * @dev Returns the latest value for a specific request ID.\\n     * @param _requestId the requestId to look up\\n     * @return uint256 of the value of the latest value of the request ID\\n     * @return bool of whether or not the value was successfully retrieved\\n     */\\n    function getLastNewValueById(uint256 _requestId)\\n        external\\n        view\\n        returns (uint256, bool)\\n    {\\n        // Try the new contract first\\n        uint256 _timeCount = IOracle(addresses[_ORACLE_CONTRACT])\\n            .getTimestampCountById(bytes32(_requestId));\\n        if (_timeCount != 0) {\\n            // If timestamps for the ID exist, there is value, so return the value\\n            return (\\n                retrieveData(\\n                    _requestId,\\n                    IOracle(addresses[_ORACLE_CONTRACT])\\n                        .getReportTimestampByIndex(\\n                            bytes32(_requestId),\\n                            _timeCount - 1\\n                        )\\n                ),\\n                true\\n            );\\n        } else {\\n            // Else, look at old value + timestamps since mining has not started\\n            Request storage _request = requestDetails[_requestId];\\n            if (_request.requestTimestamps.length != 0) {\\n                return (\\n                    retrieveData(\\n                        _requestId,\\n                        _request.requestTimestamps[\\n                            _request.requestTimestamps.length - 1\\n                        ]\\n                    ),\\n                    true\\n                );\\n            } else {\\n                return (0, false);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Function is solely for the parachute contract\\n     */\\n    function getNewCurrentVariables()\\n        external\\n        view\\n        returns (\\n            bytes32 _c,\\n            uint256[5] memory _r,\\n            uint256 _diff,\\n            uint256 _tip\\n        )\\n    {\\n        _r = [uint256(1), uint256(1), uint256(1), uint256(1), uint256(1)];\\n        _diff = 0;\\n        _tip = 0;\\n        _c = keccak256(\\n            abi.encode(\\n                IOracle(addresses[_ORACLE_CONTRACT]).getTimeOfLastNewValue()\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Counts the number of values that have been submitted for the request.\\n     * @param _requestId the requestId to look up\\n     * @return uint256 count of the number of values received for the requestId\\n     */\\n    function getNewValueCountbyRequestId(uint256 _requestId)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        // Defaults to new one, but will give old value if new mining has not started\\n        uint256 _val = IOracle(addresses[_ORACLE_CONTRACT])\\n            .getTimestampCountById(bytes32(_requestId));\\n        if (_val > 0) {\\n            return _val;\\n        } else {\\n            return requestDetails[_requestId].requestTimestamps.length;\\n        }\\n    }\\n\\n    /**\\n     * @dev Gets the timestamp for the value based on their index\\n     * @param _requestId is the requestId to look up\\n     * @param _index is the value index to look up\\n     * @return uint256 timestamp\\n     */\\n    function getTimestampbyRequestIDandIndex(uint256 _requestId, uint256 _index)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        // Try new contract first, but give old timestamp if new mining has not started\\n        try\\n            IOracle(addresses[_ORACLE_CONTRACT]).getReportTimestampByIndex(\\n                bytes32(_requestId),\\n                _index\\n            )\\n        returns (uint256 _val) {\\n            return _val;\\n        } catch {\\n            return requestDetails[_requestId].requestTimestamps[_index];\\n        }\\n    }\\n\\n    /**\\n     * @dev Getter for the variables saved under the TellorStorageStruct uints variable\\n     * @param _data the variable to pull from the mapping. _data = keccak256(\\\"variable_name\\\")\\n     * where variable_name is the variables/strings used to save the data in the mapping.\\n     * The variables names in the TellorVariables contract\\n     * @return uint256 of specified variable\\n     */\\n    function getUintVar(bytes32 _data) external view returns (uint256) {\\n        return uints[_data];\\n    }\\n\\n    /**\\n     * @dev Getter for if the party is migrated\\n     * @param _addy address of party\\n     * @return bool if the party is migrated\\n     */\\n    function isMigrated(address _addy) external view returns (bool) {\\n        return migrated[_addy];\\n    }\\n\\n    /**\\n     * @dev Allows users to access the token's name\\n     */\\n    function name() external pure returns (string memory) {\\n        return \\\"Tellor Tributes\\\";\\n    }\\n\\n    /**\\n     * @dev Retrieve value from oracle based on timestamp\\n     * @param _requestId being requested\\n     * @param _timestamp to retrieve data/value from\\n     * @return uint256 value for timestamp submitted\\n     */\\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (_timestamp < uints[_SWITCH_TIME]) {\\n            return requestDetails[_requestId].finalValues[_timestamp];\\n        }\\n        return\\n            _sliceUint(\\n                IOracle(addresses[_ORACLE_CONTRACT]).getValueByTimestamp(\\n                    bytes32(_requestId),\\n                    _timestamp\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Allows users to access the token's symbol\\n     */\\n    function symbol() external pure returns (string memory) {\\n        return \\\"TRB\\\";\\n    }\\n\\n    /**\\n     * @dev Getter for the total_supply of tokens\\n     * @return uint256 total supply\\n     */\\n    function totalSupply() external view returns (uint256) {\\n        return uints[_TOTAL_SUPPLY];\\n    }\\n\\n    /**\\n     * @dev Allows Tellor X to fallback to the old Tellor if there are current open disputes\\n     * (or disputes on old Tellor values)\\n     */\\n    fallback() external {\\n        address _addr = 0x2754da26f634E04b26c4deCD27b3eb144Cf40582; // Main Tellor address (Harcode this in?)\\n        // Obtain function header from msg.data\\n        bytes4 _function;\\n        for (uint256 i = 0; i < 4; i++) {\\n            _function |= bytes4(msg.data[i] & 0xFF) >> (i * 8);\\n        }\\n        // Ensure that the function is allowed and related to disputes, voting, and dispute fees\\n        require(\\n            _function ==\\n                bytes4(\\n                    bytes32(keccak256(\\\"beginDispute(uint256,uint256,uint256)\\\"))\\n                ) ||\\n                _function == bytes4(bytes32(keccak256(\\\"vote(uint256,bool)\\\"))) ||\\n                _function ==\\n                bytes4(bytes32(keccak256(\\\"tallyVotes(uint256)\\\"))) ||\\n                _function ==\\n                bytes4(bytes32(keccak256(\\\"unlockDisputeFee(uint256)\\\"))),\\n            \\\"function should be allowed\\\"\\n        ); //should autolock out after a week (no disputes can begin past a week)\\n        // Calls the function in msg.data from main Tellor address\\n        (bool _result, ) = _addr.delegatecall(msg.data);\\n        assembly {\\n            returndatacopy(0, 0, returndatasize())\\n            switch _result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    // Internal\\n    /**\\n     * @dev Utilized to help slice a bytes variable into a uint\\n     * @param _b is the bytes variable to be sliced\\n     * @return _x of the sliced uint256\\n     */\\n    function _sliceUint(bytes memory _b) public pure returns (uint256 _x) {\\n        uint256 _number = 0;\\n        for (uint256 _i = 0; _i < _b.length; _i++) {\\n            _number = _number * 2**8;\\n            _number = _number + uint8(_b[_i]);\\n        }\\n        return _number;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Getters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport \\\"./tellor3/TellorStorage.sol\\\";\\nimport \\\"./TellorVars.sol\\\";\\nimport \\\"./interfaces/IOracle.sol\\\";\\n\\n/**\\n @author Tellor Inc.\\n @title Getters\\n* @dev The Getters contract links to the Oracle contract and\\n* allows parties to continue to use the master\\n* address to access bytes values. All parties should be reading values\\n* through this address\\n*/\\ncontract Getters is TellorStorage, TellorVars {\\n    // Functions\\n    /**\\n     * @dev Counts the number of values that have been submitted for the request.\\n     * @param _queryId the id to look up\\n     * @return uint256 count of the number of values received for the id\\n     */\\n    function getNewValueCountbyQueryId(bytes32 _queryId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return (\\n            IOracle(addresses[_ORACLE_CONTRACT]).getTimestampCountById(_queryId)\\n        );\\n    }\\n\\n    /**\\n     * @dev Gets the timestamp for the value based on their index\\n     * @param _queryId is the id to look up\\n     * @param _index is the value index to look up\\n     * @return uint256 timestamp\\n     */\\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return (\\n            IOracle(addresses[_ORACLE_CONTRACT]).getReportTimestampByIndex(\\n                _queryId,\\n                _index\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Retrieve value from oracle based on timestamp\\n     * @param _queryId being requested\\n     * @param _timestamp to retrieve data/value from\\n     * @return bytes value for timestamp submitted\\n     */\\n    function retrieveData(bytes32 _queryId, uint256 _timestamp)\\n        public\\n        view\\n        returns (bytes memory)\\n    {\\n        return (\\n            IOracle(addresses[_ORACLE_CONTRACT]).getValueByTimestamp(\\n                _queryId,\\n                _timestamp\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport \\\"./tellor3/TellorStorage.sol\\\";\\nimport \\\"./TellorVars.sol\\\";\\nimport \\\"./interfaces/IGovernance.sol\\\";\\n\\n/**\\n @author Tellor Inc.\\n @title Token\\n @dev Contains the methods related to transfers and ERC20, its storage\\n * and hashes of tellor variables that are used to save gas on transactions.\\n*/\\ncontract Token is TellorStorage, TellorVars {\\n    // Events\\n    event Approval(\\n        address indexed _owner,\\n        address indexed _spender,\\n        uint256 _value\\n    ); // ERC20 Approval event\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value); // ERC20 Transfer Event\\n\\n    // Functions\\n    /**\\n     * @dev Getter function for remaining spender balance\\n     * @param _user address of party with the balance\\n     * @param _spender address of spender of parties said balance\\n     * @return uint256 Returns the remaining allowance of tokens granted to the _spender from the _user\\n     */\\n    function allowance(address _user, address _spender)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _allowances[_user][_spender];\\n    }\\n\\n    /**\\n     * @dev This function returns whether or not a given user is allowed to trade a given amount\\n     * and removing the staked amount from their balance if they are staked\\n     * @param _user address of user\\n     * @param _amount to check if the user can spend\\n     * @return bool true if they are allowed to spend the amount being checked\\n     */\\n    function allowedToTrade(address _user, uint256 _amount)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        if (\\n            stakerDetails[_user].currentStatus != 0 &&\\n            stakerDetails[_user].currentStatus < 5\\n        ) {\\n            // Subtracts the stakeAmount from balance if the _user is staked\\n            return (balanceOf(_user) - uints[_STAKE_AMOUNT] >= _amount);\\n        }\\n        return (balanceOf(_user) >= _amount); // Else, check if balance is greater than amount they want to spend\\n    }\\n\\n    /**\\n     * @dev This function approves a _spender an _amount of tokens to use\\n     * @param _spender address\\n     * @param _amount amount the spender is being approved for\\n     * @return bool true if spender approved successfully\\n     */\\n    function approve(address _spender, uint256 _amount)\\n        external\\n        returns (bool)\\n    {\\n        require(_spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowances[msg.sender][_spender] = _amount;\\n        emit Approval(msg.sender, _spender, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev This function approves a transfer of _amount tokens from _from to _to\\n     * @param _from is the address the tokens will be transferred from\\n     * @param _to is the address the tokens will be transferred to\\n     * @param _amount is the number of tokens to transfer\\n     * @return bool true if spender approved successfully\\n     */\\n    function approveAndTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) external returns (bool) {\\n        require(\\n            (IGovernance(addresses[_GOVERNANCE_CONTRACT])\\n                .isApprovedGovernanceContract(msg.sender) ||\\n                msg.sender == addresses[_TREASURY_CONTRACT] ||\\n                msg.sender == addresses[_ORACLE_CONTRACT]),\\n            \\\"Only the Governance, Treasury, or Oracle Contract can approve and transfer tokens\\\"\\n        );\\n        _doTransfer(_from, _to, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Gets balance of owner specified\\n     * @param _user is the owner address used to look up the balance\\n     * @return uint256 Returns the balance associated with the passed in _user\\n     */\\n    function balanceOf(address _user) public view returns (uint256) {\\n        return balanceOfAt(_user, block.number);\\n    }\\n\\n    /**\\n     * @dev Queries the balance of _user at a specific _blockNumber\\n     * @param _user The address from which the balance will be retrieved\\n     * @param _blockNumber The block number when the balance is queried\\n     * @return uint256 The balance at _blockNumber specified\\n     */\\n    function balanceOfAt(address _user, uint256 _blockNumber)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        TellorStorage.Checkpoint[] storage checkpoints = balances[_user];\\n        if (\\n            checkpoints.length == 0 || checkpoints[0].fromBlock > _blockNumber\\n        ) {\\n            return 0;\\n        } else {\\n            if (_blockNumber >= checkpoints[checkpoints.length - 1].fromBlock)\\n                return checkpoints[checkpoints.length - 1].value;\\n            // Binary search of the value in the array\\n            uint256 _min = 0;\\n            uint256 _max = checkpoints.length - 2;\\n            while (_max > _min) {\\n                uint256 _mid = (_max + _min + 1) / 2;\\n                if (checkpoints[_mid].fromBlock == _blockNumber) {\\n                    return checkpoints[_mid].value;\\n                } else if (checkpoints[_mid].fromBlock < _blockNumber) {\\n                    _min = _mid;\\n                } else {\\n                    _max = _mid - 1;\\n                }\\n            }\\n            return checkpoints[_min].value;\\n        }\\n    }\\n\\n    /**\\n     * @dev Burns an amount of tokens\\n     * @param _amount is the amount of tokens to burn\\n     */\\n    function burn(uint256 _amount) external {\\n        _doBurn(msg.sender, _amount);\\n    }\\n\\n    /**\\n     * @dev Allows for a transfer of tokens to _to\\n     * @param _to The address to send tokens to\\n     * @param _amount The amount of tokens to send\\n     * @return success whether the transfer was successful\\n     */\\n    function transfer(address _to, uint256 _amount)\\n        external\\n        returns (bool success)\\n    {\\n        _doTransfer(msg.sender, _to, _amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Send _amount tokens to _to from _from on the condition it\\n     * is approved by _from\\n     * @param _from The address holding the tokens being transferred\\n     * @param _to The address of the recipient\\n     * @param _amount The amount of tokens to be transferred\\n     * @return success whether the transfer was successful\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) external returns (bool success) {\\n        require(\\n            _allowances[_from][msg.sender] >= _amount,\\n            \\\"Allowance is wrong\\\"\\n        );\\n        _allowances[_from][msg.sender] -= _amount;\\n        _doTransfer(_from, _to, _amount);\\n        return true;\\n    }\\n\\n    // Internal\\n    /**\\n     * @dev Helps burn TRB Tokens\\n     * @param _from is the address to burn or remove TRB amount\\n     * @param _amount is the amount of TRB to burn\\n     */\\n    function _doBurn(address _from, uint256 _amount) internal {\\n        // Ensure that amount of balance are valid\\n        if (_amount == 0) return;\\n        require(\\n            allowedToTrade(_from, _amount),\\n            \\\"Should have sufficient balance to trade\\\"\\n        );\\n        uint128 _previousBalance = uint128(balanceOf(_from));\\n        uint128 _sizedAmount = uint128(_amount);\\n        // Update total supply and balance of _from\\n        _updateBalanceAtNow(_from, _previousBalance - _sizedAmount);\\n        uints[_TOTAL_SUPPLY] -= _amount;\\n    }\\n\\n    /**\\n     * @dev Helps mint new TRB\\n     * @param _to is the address to send minted amount to\\n     * @param _amount is the amount of TRB to send\\n     */\\n    function _doMint(address _to, uint256 _amount) internal {\\n        // Ensure to address and mint amount are valid\\n        require(_amount != 0, \\\"Tried to mint non-positive amount\\\");\\n        require(_to != address(0), \\\"Receiver is 0 address\\\");\\n        uint128 _previousBalance = uint128(balanceOf(_to));\\n        uint128 _sizedAmount = uint128(_amount);\\n        // Update total supply and balance of _to address\\n        uints[_TOTAL_SUPPLY] += _amount;\\n        _updateBalanceAtNow(_to, _previousBalance + _sizedAmount);\\n        emit Transfer(address(0), _to, _amount);\\n    }\\n\\n    /**\\n     * @dev Completes transfers by updating the balances on the current block number\\n     * and ensuring the amount does not contain tokens staked for reporting\\n     * @param _from address to transfer from\\n     * @param _to address to transfer to\\n     * @param _amount to transfer\\n     */\\n    function _doTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) internal {\\n        // Ensure user has a correct balance and to address\\n        require(_amount != 0, \\\"Tried to send non-positive amount\\\");\\n        require(_to != address(0), \\\"Receiver is 0 address\\\");\\n        require(\\n            allowedToTrade(_from, _amount),\\n            \\\"Should have sufficient balance to trade\\\"\\n        );\\n        // Update balance of _from address\\n        uint128 _previousBalance = uint128(balanceOf(_from));\\n        uint128 _sizedAmount = uint128(_amount);\\n        _updateBalanceAtNow(_from, _previousBalance - _sizedAmount);\\n        // Update balance of _to address\\n        _previousBalance = uint128(balanceOf(_to));\\n        _updateBalanceAtNow(_to, _previousBalance + _sizedAmount);\\n        emit Transfer(_from, _to, _amount);\\n    }\\n\\n    /**\\n     * @dev Updates balance checkpoint for from and to on the current block number via doTransfer\\n     * @param _user is the address whose balance is updated\\n     * @param _value is the new balance\\n     */\\n    function _updateBalanceAtNow(address _user, uint128 _value) internal {\\n        Checkpoint[] storage checkpoints = balances[_user];\\n        // Checks if no checkpoints exist, or if checkpoint block is not current block\\n        if (\\n            checkpoints.length == 0 ||\\n            checkpoints[checkpoints.length - 1].fromBlock != block.number\\n        ) {\\n            // If yes, push a new checkpoint into the array\\n            checkpoints.push(\\n                TellorStorage.Checkpoint({\\n                    fromBlock: uint128(block.number),\\n                    value: _value\\n                })\\n            );\\n        } else {\\n            // Else, update old checkpoint\\n            TellorStorage.Checkpoint storage oldCheckPoint = checkpoints[\\n                checkpoints.length - 1\\n            ];\\n            oldCheckPoint.value = _value;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.3;\\r\\n\\r\\ninterface IGovernance{\\r\\n    enum VoteResult {FAILED,PASSED,INVALID}\\r\\n    function setApprovedFunction(bytes4 _func, bool _val) external;\\r\\n    function beginDispute(bytes32 _queryId,uint256 _timestamp) external;\\r\\n    function delegate(address _delegate) external;\\r\\n    function delegateOfAt(address _user, uint256 _blockNumber) external view returns (address);\\r\\n    function executeVote(uint256 _disputeId) external;\\r\\n    function proposeVote(address _contract,bytes4 _function, bytes calldata _data, uint256 _timestamp) external;\\r\\n    function tallyVotes(uint256 _disputeId) external;\\r\\n    function updateMinDisputeFee() external;\\r\\n    function verify() external pure returns(uint);\\r\\n    function vote(uint256 _disputeId, bool _supports, bool _invalidQuery) external;\\r\\n    function voteFor(address[] calldata _addys,uint256 _disputeId, bool _supports, bool _invalidQuery) external;\\r\\n    function getDelegateInfo(address _holder) external view returns(address,uint);\\r\\n    function isApprovedGovernanceContract(address _contract) external view returns(bool);\\r\\n    function isFunctionApproved(bytes4 _func) external view returns(bool);\\r\\n    function getVoteCount() external view returns(uint256);\\r\\n    function getVoteRounds(bytes32 _hash) external view returns(uint256[] memory);\\r\\n    function getVoteInfo(uint256 _disputeId) external view returns(bytes32,uint256[8] memory,bool[2] memory,VoteResult,bytes memory,bytes4,address[2] memory);\\r\\n    function getDisputeInfo(uint256 _disputeId) external view returns(uint256,uint256,bytes memory, address);\\r\\n    function getOpenDisputesOnId(uint256 _queryId) external view returns(uint256);\\r\\n    function didVote(uint256 _disputeId, address _voter) external view returns(bool);\\r\\n    //testing\\r\\n    function testMin(uint256 a, uint256 b) external pure returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/tellor3/TellorStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.4;\\n\\n/**\\n  @author Tellor Inc.\\n  @title TellorStorage\\n  @dev Contains all the variables/structs used by Tellor\\n*/\\ncontract TellorStorage {\\n    //Internal struct for use in proof-of-work submission\\n    struct Details {\\n        uint256 value;\\n        address miner;\\n    }\\n    struct Dispute {\\n        bytes32 hash; //unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\\n        int256 tally; //current tally of votes for - against measure\\n        bool executed; //is the dispute settled\\n        bool disputeVotePassed; //did the vote pass?\\n        bool isPropFork; //true for fork proposal NEW\\n        address reportedMiner; //miner who submitted the 'bad value' will get disputeFee if dispute vote fails\\n        address reportingParty; //miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\\n        address proposedForkAddress; //new fork address (if fork proposal)\\n        mapping(bytes32 => uint256) disputeUintVars;\\n        mapping(address => bool) voted; //mapping of address to whether or not they voted\\n    }\\n    struct StakeInfo {\\n        uint256 currentStatus; //0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute 4=ReadyForUnlocking 5=Unlocked\\n        uint256 startDate; //stake start date\\n    }\\n    //Internal struct to allow balances to be queried by blocknumber for voting purposes\\n    struct Checkpoint {\\n        uint128 fromBlock; // fromBlock is the block number that the value was generated from\\n        uint128 value; // value is the amount of tokens at a specific block number\\n    }\\n    struct Request {\\n        uint256[] requestTimestamps; //array of all newValueTimestamps requested\\n        mapping(bytes32 => uint256) apiUintVars;\\n        mapping(uint256 => uint256) minedBlockNum; //[apiId][minedTimestamp]=>block.number\\n        //This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\\n        mapping(uint256 => uint256) finalValues;\\n        mapping(uint256 => bool) inDispute; //checks if API id is in dispute or finalized.\\n        mapping(uint256 => address[5]) minersByValue;\\n        mapping(uint256 => uint256[5]) valuesByTimestamp;\\n    }\\n    uint256[51] requestQ; //uint50 array of the top50 requests by payment amount\\n    uint256[] public newValueTimestamps; //array of all timestamps requested\\n    //This is a boolean that tells you if a given challenge has been completed by a given miner\\n    mapping(uint256 => uint256) requestIdByTimestamp; //minedTimestamp to apiId\\n    mapping(uint256 => uint256) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\\n    mapping(uint256 => Dispute) public disputesById; //disputeId=> Dispute details\\n    mapping(bytes32 => uint256) public requestIdByQueryHash; // api bytes32 gets an id = to count of requests array\\n    mapping(bytes32 => uint256) public disputeIdByDisputeHash; //maps a hash to an ID for each dispute\\n    mapping(bytes32 => mapping(address => bool)) public minersByChallenge;\\n    Details[5] public currentMiners; //This struct is for organizing the five mined values to find the median\\n    mapping(address => StakeInfo) stakerDetails; //mapping from a persons address to their staking info\\n    mapping(uint256 => Request) requestDetails;\\n    mapping(bytes32 => uint256) public uints;\\n    mapping(bytes32 => address) public addresses;\\n    mapping(bytes32 => bytes32) public bytesVars;\\n    //ERC20 storage\\n    mapping(address => Checkpoint[]) public balances;\\n    mapping(address => mapping(address => uint256)) public _allowances;\\n    //Migration storage\\n    mapping(address => bool) public migrated;\\n}\\n\\n\\n\\n\\n\"\r\n    },\r\n    \"contracts/TellorVars.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.3;\\n\\nimport \\\"./tellor3/TellorVariables.sol\\\";\\n\\n/**\\n @author Tellor Inc.\\n @title TellorVariables\\n @dev Helper contract to store hashes of variables.\\n * For each of the bytes32 constants, the values are equal to\\n * keccak256([VARIABLE NAME])\\n*/\\ncontract TellorVars is TellorVariables {\\n    // Storage\\n    address constant TELLOR_ADDRESS =\\n        0x88dF592F8eb5D7Bd38bFeF7dEb0fBc02cf3778a0; // Address of main Tellor Contract\\n    // Hashes for each pertinent contract\\n    bytes32 constant _GOVERNANCE_CONTRACT =\\n        0xefa19baa864049f50491093580c5433e97e8d5e41f8db1a61108b4fa44cacd93;\\n    bytes32 constant _ORACLE_CONTRACT =\\n        0xfa522e460446113e8fd353d7fa015625a68bc0369712213a42e006346440891e;\\n    bytes32 constant _TREASURY_CONTRACT =\\n        0x1436a1a60dca0ebb2be98547e57992a0fa082eb479e7576303cbd384e934f1fa;\\n    bytes32 constant _SWITCH_TIME =\\n        0x6c0e91a96227393eb6e42b88e9a99f7c5ebd588098b549c949baf27ac9509d8f;\\n    bytes32 constant _MINIMUM_DISPUTE_FEE =\\n        0x7335d16d7e7f6cb9f532376441907fe76aa2ea267285c82892601f4755ed15f0;\\n}\\n\"\r\n    },\r\n    \"contracts/tellor3/TellorVariables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.4;\\n\\n/**\\n @author Tellor Inc.\\n @title TellorVariables\\n @dev Helper contract to store hashes of variables\\n*/\\ncontract TellorVariables {\\n    bytes32 constant _BLOCK_NUMBER =\\n        0x4b4cefd5ced7569ef0d091282b4bca9c52a034c56471a6061afd1bf307a2de7c; //keccak256(\\\"_BLOCK_NUMBER\\\");\\n    bytes32 constant _CURRENT_CHALLENGE =\\n        0xd54702836c9d21d0727ffacc3e39f57c92b5ae0f50177e593bfb5ec66e3de280; //keccak256(\\\"_CURRENT_CHALLENGE\\\");\\n    bytes32 constant _CURRENT_REQUESTID =\\n        0xf5126bb0ac211fbeeac2c0e89d4c02ac8cadb2da1cfb27b53c6c1f4587b48020; //keccak256(\\\"_CURRENT_REQUESTID\\\");\\n    bytes32 constant _CURRENT_REWARD =\\n        0xd415862fd27fb74541e0f6f725b0c0d5b5fa1f22367d9b78ec6f61d97d05d5f8; //keccak256(\\\"_CURRENT_REWARD\\\");\\n    bytes32 constant _CURRENT_TOTAL_TIPS =\\n        0x09659d32f99e50ac728058418d38174fe83a137c455ff1847e6fb8e15f78f77a; //keccak256(\\\"_CURRENT_TOTAL_TIPS\\\");\\n    bytes32 constant _DEITY =\\n        0x5fc094d10c65bc33cc842217b2eccca0191ff24148319da094e540a559898961; //keccak256(\\\"_DEITY\\\");\\n    bytes32 constant _DIFFICULTY =\\n        0xf758978fc1647996a3d9992f611883adc442931dc49488312360acc90601759b; //keccak256(\\\"_DIFFICULTY\\\");\\n    bytes32 constant _DISPUTE_COUNT =\\n        0x310199159a20c50879ffb440b45802138b5b162ec9426720e9dd3ee8bbcdb9d7; //keccak256(\\\"_DISPUTE_COUNT\\\");\\n    bytes32 constant _DISPUTE_FEE =\\n        0x675d2171f68d6f5545d54fb9b1fb61a0e6897e6188ca1cd664e7c9530d91ecfc; //keccak256(\\\"_DISPUTE_FEE\\\");\\n    bytes32 constant _DISPUTE_ROUNDS =\\n        0x6ab2b18aafe78fd59c6a4092015bddd9fcacb8170f72b299074f74d76a91a923; //keccak256(\\\"_DISPUTE_ROUNDS\\\");\\n    bytes32 constant _EXTENSION =\\n        0x2b2a1c876f73e67ebc4f1b08d10d54d62d62216382e0f4fd16c29155818207a4; //keccak256(\\\"_EXTENSION\\\");\\n    bytes32 constant _FEE =\\n        0x1da95f11543c9b03927178e07951795dfc95c7501a9d1cf00e13414ca33bc409; //keccak256(\\\"_FEE\\\");\\n    bytes32 constant _FORK_EXECUTED =\\n        0xda571dfc0b95cdc4a3835f5982cfdf36f73258bee7cb8eb797b4af8b17329875; //keccak256(\\\"_FORK_EXECUTED\\\");\\n    bytes32 constant _LOCK =\\n        0xd051321aa26ce60d202f153d0c0e67687e975532ab88ce92d84f18e39895d907;\\n    bytes32 constant _MIGRATOR =\\n        0xc6b005d45c4c789dfe9e2895b51df4336782c5ff6bd59a5c5c9513955aa06307; //keccak256(\\\"_MIGRATOR\\\");\\n    bytes32 constant _MIN_EXECUTION_DATE =\\n        0x46f7d53798d31923f6952572c6a19ad2d1a8238d26649c2f3493a6d69e425d28; //keccak256(\\\"_MIN_EXECUTION_DATE\\\");\\n    bytes32 constant _MINER_SLOT =\\n        0x6de96ee4d33a0617f40a846309c8759048857f51b9d59a12d3c3786d4778883d; //keccak256(\\\"_MINER_SLOT\\\");\\n    bytes32 constant _NUM_OF_VOTES =\\n        0x1da378694063870452ce03b189f48e04c1aa026348e74e6c86e10738514ad2c4; //keccak256(\\\"_NUM_OF_VOTES\\\");\\n    bytes32 constant _OLD_TELLOR =\\n        0x56e0987db9eaec01ed9e0af003a0fd5c062371f9d23722eb4a3ebc74f16ea371; //keccak256(\\\"_OLD_TELLOR\\\");\\n    bytes32 constant _ORIGINAL_ID =\\n        0xed92b4c1e0a9e559a31171d487ecbec963526662038ecfa3a71160bd62fb8733; //keccak256(\\\"_ORIGINAL_ID\\\");\\n    bytes32 constant _OWNER =\\n        0x7a39905194de50bde334d18b76bbb36dddd11641d4d50b470cb837cf3bae5def; //keccak256(\\\"_OWNER\\\");\\n    bytes32 constant _PAID =\\n        0x29169706298d2b6df50a532e958b56426de1465348b93650fca42d456eaec5fc; //keccak256(\\\"_PAID\\\");\\n    bytes32 constant _PENDING_OWNER =\\n        0x7ec081f029b8ac7e2321f6ae8c6a6a517fda8fcbf63cabd63dfffaeaafa56cc0; //keccak256(\\\"_PENDING_OWNER\\\");\\n    bytes32 constant _REQUEST_COUNT =\\n        0x3f8b5616fa9e7f2ce4a868fde15c58b92e77bc1acd6769bf1567629a3dc4c865; //keccak256(\\\"_REQUEST_COUNT\\\");\\n    bytes32 constant _REQUEST_ID =\\n        0x9f47a2659c3d32b749ae717d975e7962959890862423c4318cf86e4ec220291f; //keccak256(\\\"_REQUEST_ID\\\");\\n    bytes32 constant _REQUEST_Q_POSITION =\\n        0xf68d680ab3160f1aa5d9c3a1383c49e3e60bf3c0c031245cbb036f5ce99afaa1; //keccak256(\\\"_REQUEST_Q_POSITION\\\");\\n    bytes32 constant _SLOT_PROGRESS =\\n        0xdfbec46864bc123768f0d134913175d9577a55bb71b9b2595fda21e21f36b082; //keccak256(\\\"_SLOT_PROGRESS\\\");\\n    bytes32 constant _STAKE_AMOUNT =\\n        0x5d9fadfc729fd027e395e5157ef1b53ef9fa4a8f053043c5f159307543e7cc97; //keccak256(\\\"_STAKE_AMOUNT\\\");\\n    bytes32 constant _STAKE_COUNT =\\n        0x10c168823622203e4057b65015ff4d95b4c650b308918e8c92dc32ab5a0a034b; //keccak256(\\\"_STAKE_COUNT\\\");\\n    bytes32 constant _T_BLOCK =\\n        0xf3b93531fa65b3a18680d9ea49df06d96fbd883c4889dc7db866f8b131602dfb; //keccak256(\\\"_T_BLOCK\\\");\\n    bytes32 constant _TALLY_DATE =\\n        0xf9e1ae10923bfc79f52e309baf8c7699edb821f91ef5b5bd07be29545917b3a6; //keccak256(\\\"_TALLY_DATE\\\");\\n    bytes32 constant _TARGET_MINERS =\\n        0x0b8561044b4253c8df1d9ad9f9ce2e0f78e4bd42b2ed8dd2e909e85f750f3bc1; //keccak256(\\\"_TARGET_MINERS\\\");\\n    bytes32 constant _TELLOR_CONTRACT =\\n        0x0f1293c916694ac6af4daa2f866f0448d0c2ce8847074a7896d397c961914a08; //keccak256(\\\"_TELLOR_CONTRACT\\\");\\n    bytes32 constant _TELLOR_GETTERS =\\n        0xabd9bea65759494fe86471c8386762f989e1f2e778949e94efa4a9d1c4b3545a; //keccak256(\\\"_TELLOR_GETTERS\\\");\\n    bytes32 constant _TIME_OF_LAST_NEW_VALUE =\\n        0x2c8b528fbaf48aaf13162a5a0519a7ad5a612da8ff8783465c17e076660a59f1; //keccak256(\\\"_TIME_OF_LAST_NEW_VALUE\\\");\\n    bytes32 constant _TIME_TARGET =\\n        0xd4f87b8d0f3d3b7e665df74631f6100b2695daa0e30e40eeac02172e15a999e1; //keccak256(\\\"_TIME_TARGET\\\");\\n    bytes32 constant _TIMESTAMP =\\n        0x2f9328a9c75282bec25bb04befad06926366736e0030c985108445fa728335e5; //keccak256(\\\"_TIMESTAMP\\\");\\n    bytes32 constant _TOTAL_SUPPLY =\\n        0xe6148e7230ca038d456350e69a91b66968b222bfac9ebfbea6ff0a1fb7380160; //keccak256(\\\"_TOTAL_SUPPLY\\\");\\n    bytes32 constant _TOTAL_TIP =\\n        0x1590276b7f31dd8e2a06f9a92867333eeb3eddbc91e73b9833e3e55d8e34f77d; //keccak256(\\\"_TOTAL_TIP\\\");\\n    bytes32 constant _VALUE =\\n        0x9147231ab14efb72c38117f68521ddef8de64f092c18c69dbfb602ffc4de7f47; //keccak256(\\\"_VALUE\\\");\\n    bytes32 constant _EIP_SLOT =\\n        0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.3;\\r\\n\\r\\ninterface IOracle{\\r\\n    function getReportTimestampByIndex(bytes32 _queryId, uint256 _index) external view returns(uint256);\\r\\n    function getValueByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(bytes memory);\\r\\n    function getBlockNumberByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(uint256);\\r\\n    function getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(address);\\r\\n    function getReporterLastTimestamp(address _reporter) external view returns(uint256);\\r\\n    function reportingLock() external view returns(uint256);\\r\\n    function removeValue(bytes32 _queryId, uint256 _timestamp) external;\\r\\n    function getReportsSubmittedByAddress(address _reporter) external view returns(uint256);\\r\\n    function getTipsByUser(address _user) external view returns(uint256);\\r\\n    function tipQuery(bytes32 _queryId, uint256 _tip, bytes memory _queryData) external;\\r\\n    function submitValue(bytes32 _queryId, bytes calldata _value, uint256 _nonce, bytes memory _queryData) external;\\r\\n    function burnTips() external;\\r\\n    function verify() external pure returns(uint);\\r\\n    function changeReportingLock(uint256 _newReportingLock) external;\\r\\n    function changeTimeBasedReward(uint256 _newTimeBasedReward) external;\\r\\n    function getTipsById(bytes32 _queryId) external view returns(uint256);\\r\\n    function getTimestampCountById(bytes32 _queryId) external view returns(uint256);\\r\\n    function getTimestampIndexByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(uint256);\\r\\n    function getCurrentValue(bytes32 _queryId) external view returns(bytes memory);\\r\\n    function getTimeOfLastNewValue() external view returns(uint256);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 300\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_contractName\",\"type\":\"string\"}],\"name\":\"NewContractAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"NewStaker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"StakeWithdrawRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"StakeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_allowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_b\",\"type\":\"bytes\"}],\"name\":\"_sliceUint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_x\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"allowedToTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approveAndTransferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"fromBlock\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"bytesVars\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"changeControllerContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGovernance\",\"type\":\"address\"}],\"name\":\"changeGovernanceContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOracle\",\"type\":\"address\"}],\"name\":\"changeOracleContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reporter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_status\",\"type\":\"uint256\"}],\"name\":\"changeStakingStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTreasury\",\"type\":\"address\"}],\"name\":\"changeTreasuryContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_target\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"changeUint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"currentMiners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"disputeIdByDisputeHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"disputesById\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"int256\",\"name\":\"tally\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disputeVotePassed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPropFork\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"reportedMiner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reportingParty\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposedForkAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getAddressVars\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"}],\"name\":\"getAllDisputeVars\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[9]\",\"name\":\"\",\"type\":\"uint256[9]\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"getDisputeIdByDisputeHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getDisputeUintVars\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getLastNewValueById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNewCurrentVariables\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_c\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[5]\",\"name\":\"_r\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256\",\"name\":\"_diff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tip\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"}],\"name\":\"getNewValueCountbyQueryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getNewValueCountbyRequestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getStakerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTimestampbyQueryIdandIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTimestampbyRequestIDandIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getUintVar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"}],\"name\":\"isMigrated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"migrated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minersByChallenge\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"newValueTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"requestIdByQueryHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestStakingWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"retrieveData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"retrieveData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reporter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_disputer\",\"type\":\"address\"}],\"name\":\"slashReporter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"uints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Controller","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"300","ConstructorArguments":"00000000000000000000000051d4088d4eee00ae4c55f46e0673e9997121db00000000000000000000000000e8218cacb0a5421bc6409e498d9f8cc8869945ea0000000000000000000000003b0f3eaefaac9f8f7fde406919eceb5270fe0607","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}