{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/producers/crowdfunds/crowdfund-with-editions/CrowdfundWithEditionsLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {CrowdfundWithEditionsStorage} from \\\"./CrowdfundWithEditionsStorage.sol\\\";\\nimport {ERC20} from \\\"../../../external/ERC20.sol\\\";\\nimport {ICrowdfundWithEditions} from \\\"./interface/ICrowdfundWithEditions.sol\\\";\\nimport {ITreasuryConfig} from \\\"../../../interface/ITreasuryConfig.sol\\\";\\n\\n/**\\n * @title CrowdfundWithEditionsLogic\\n * @author MirrorXYZ\\n *\\n * Crowdfund the creation of NFTs by issuing ERC20 tokens that\\n * can be redeemed for the underlying value of the NFT once sold.\\n */\\ncontract CrowdfundWithEditionsLogic is CrowdfundWithEditionsStorage, ERC20 {\\n    // ============ Events ============\\n\\n    event ReceivedERC721(uint256 tokenId, address sender);\\n    event Contribution(address contributor, uint256 amount);\\n    event ContributionForEdition(\\n        address contributor,\\n        uint256 amount,\\n        uint256 editionId,\\n        uint256 tokenId\\n    );\\n\\n    event FundingClosed(uint256 amountRaised, uint256 creatorAllocation);\\n    event BidAccepted(uint256 amount);\\n    event Redeemed(address contributor, uint256 amount);\\n    event Withdrawal(uint256 amount, uint256 fee);\\n\\n    // ============ Modifiers ============\\n\\n    /**\\n     * @dev Modifier to check whether the `msg.sender` is the operator.\\n     * If it is, it will run the function. Otherwise, it will revert.\\n     */\\n    modifier onlyOperator() {\\n        require(msg.sender == operator);\\n        _;\\n    }\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(reentrancy_status != REENTRANCY_ENTERED, \\\"Reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        reentrancy_status = REENTRANCY_ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        reentrancy_status = REENTRANCY_NOT_ENTERED;\\n    }\\n\\n    // ============ Crowdfunding Methods ============\\n\\n    /**\\n     * @notice Mints tokens for the sender propotional to the\\n     *  amount of ETH sent in the transaction.\\n     * @dev Emits the Contribution event.\\n     */\\n    function contribute(\\n        address payable backer,\\n        uint256 editionId,\\n        uint256 amount\\n    ) external payable nonReentrant {\\n        _contribute(backer, editionId, amount);\\n    }\\n\\n    /**\\n     * @notice Burns the sender's tokens and redeems underlying ETH.\\n     * @dev Emits the Redeemed event.\\n     */\\n    function redeem(uint256 tokenAmount) external nonReentrant {\\n        // Prevent backers from accidently redeeming when balance is 0.\\n        require(\\n            address(this).balance > 0,\\n            \\\"Crowdfund: No ETH available to redeem\\\"\\n        );\\n        // Check\\n        require(\\n            balanceOf[msg.sender] >= tokenAmount,\\n            \\\"Crowdfund: Insufficient balance\\\"\\n        );\\n        require(status == Status.TRADING, \\\"Crowdfund: Funding must be trading\\\");\\n        // Effect\\n        uint256 redeemable = redeemableFromTokens(tokenAmount);\\n        _burn(msg.sender, tokenAmount);\\n        // Safe version of transfer.\\n        sendValue(payable(msg.sender), redeemable);\\n        emit Redeemed(msg.sender, redeemable);\\n    }\\n\\n    /**\\n     * @notice Returns the amount of ETH that is redeemable for tokenAmount.\\n     */\\n    function redeemableFromTokens(uint256 tokenAmount)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return (tokenAmount * address(this).balance) / totalSupply;\\n    }\\n\\n    function valueToTokens(uint256 value) public pure returns (uint256 tokens) {\\n        tokens = value * TOKEN_SCALE;\\n    }\\n\\n    function tokensToValue(uint256 tokenAmount)\\n        internal\\n        pure\\n        returns (uint256 value)\\n    {\\n        value = tokenAmount / TOKEN_SCALE;\\n    }\\n\\n    // ============ Operator Methods ============\\n\\n    /**\\n     * @notice Transfers all funds to operator, and mints tokens for the operator.\\n     *  Updates status to TRADING.\\n     * @dev Emits the FundingClosed event.\\n     */\\n    function closeFunding() external onlyOperator nonReentrant {\\n        require(status == Status.FUNDING, \\\"Crowdfund: Funding must be open\\\");\\n        // Close funding status, move to tradable.\\n        status = Status.TRADING;\\n        // Mint the operator a percent of the total supply.\\n        uint256 operatorTokens = (operatorPercent * totalSupply) /\\n            (100 - operatorPercent);\\n        _mint(operator, operatorTokens);\\n        // Announce that funding has been closed.\\n        emit FundingClosed(address(this).balance, operatorTokens);\\n\\n        _withdraw();\\n    }\\n\\n    /**\\n     * @notice Operator can change the funding recipient.\\n     */\\n    function changeFundingRecipient(address payable newFundingRecipient)\\n        public\\n        onlyOperator\\n    {\\n        fundingRecipient = newFundingRecipient;\\n    }\\n\\n    function withdraw() public {\\n        _withdraw();\\n    }\\n\\n    function computeFee(uint256 amount, uint256 feePercentage_)\\n        public\\n        pure\\n        returns (uint256 fee)\\n    {\\n        fee = (feePercentage_ * amount) / (100 * 100);\\n    }\\n\\n    // ============ Utility Methods ============\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance >= amount,\\n            \\\"Address: insufficient balance\\\"\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(\\n            success,\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n\\n    // ============ Edition Methods ============\\n\\n    function buyEdition(\\n        uint256 amount,\\n        uint256 editionId,\\n        address recipient\\n    ) internal returns (uint256) {\\n        // Check that the sender is paying the correct amount.\\n        require(\\n            amount >= ICrowdfundWithEditions(editions).editionPrice(editionId),\\n            \\\"Unable purchase edition with available amount\\\"\\n        );\\n        // We don't need to transfer the value to the NFT contract here,\\n        // since that contract trusts this one to check before minting.\\n        // I.E. this contract has minting privileges.\\n        return\\n            ICrowdfundWithEditions(editions).buyEdition(editionId, recipient);\\n    }\\n\\n    // ============ Internal Methods  ============\\n    function _contribute(\\n        address payable backer,\\n        uint256 editionId,\\n        uint256 amount\\n    ) private {\\n        require(status == Status.FUNDING, \\\"Crowdfund: Funding must be open\\\");\\n        require(amount == msg.value, \\\"Crowdfund: Amount is not value sent\\\");\\n        // This first case is the happy path, so we will keep it efficient.\\n        // The balance, which includes the current contribution, is less than or equal to cap.\\n        if (address(this).balance <= fundingCap) {\\n            // Mint equity for the contributor.\\n            _mint(backer, valueToTokens(amount));\\n\\n            // Editions start at 1, so a \\\"0\\\" edition means the user wants to contribute without\\n            // purchasing a token.\\n            if (editionId > 0) {\\n                emit ContributionForEdition(\\n                    backer,\\n                    amount,\\n                    editionId,\\n                    buyEdition(amount, editionId, backer)\\n                );\\n            } else {\\n                emit Contribution(backer, amount);\\n            }\\n        } else {\\n            // Compute the balance of the crowdfund before the contribution was made.\\n            uint256 startAmount = address(this).balance - amount;\\n            // If that amount was already greater than the funding cap, then we should revert immediately.\\n            require(\\n                startAmount < fundingCap,\\n                \\\"Crowdfund: Funding cap already reached\\\"\\n            );\\n            // Otherwise, the contribution helped us reach the funding cap. We should\\n            // take what we can until the funding cap is reached, and refund the rest.\\n            uint256 eligibleAmount = fundingCap - startAmount;\\n            // Otherwise, we process the contribution as if it were the minimal amount.\\n            _mint(backer, valueToTokens(eligibleAmount));\\n\\n            if (editionId > 0) {\\n                emit ContributionForEdition(\\n                    backer,\\n                    eligibleAmount,\\n                    editionId,\\n                    // Attempt to purchase edition with eligible amount.\\n                    buyEdition(eligibleAmount, editionId, backer)\\n                );\\n            } else {\\n                emit Contribution(backer, eligibleAmount);\\n            }\\n            // Refund the sender with their contribution (e.g. 2.5 minus the diff - e.g. 1.5 = 1 ETH)\\n            sendValue(backer, amount - eligibleAmount);\\n        }\\n    }\\n\\n    function _withdraw() internal {\\n        uint256 fee = feePercentage;\\n\\n        emit Withdrawal(\\n            address(this).balance,\\n            computeFee(address(this).balance, fee)\\n        );\\n\\n        // Transfer the fee to the treasury.\\n        sendValue(\\n            ITreasuryConfig(treasuryConfig).treasury(),\\n            computeFee(address(this).balance, fee)\\n        );\\n        // Transfer available balance to the fundingRecipient.\\n        sendValue(fundingRecipient, address(this).balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/producers/crowdfunds/crowdfund-with-editions/CrowdfundWithEditionsStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title CrowdfundWithEditionsStorage\\n * @author MirrorXYZ\\n */\\ncontract CrowdfundWithEditionsStorage {\\n    /**\\n     * @notice The two states that this contract can exist in.\\n     * \\\"FUNDING\\\" allows contributors to add funds.\\n     */\\n    enum Status {\\n        FUNDING,\\n        TRADING\\n    }\\n\\n    // ============ Constants ============\\n\\n    /// @notice The factor by which ETH contributions will multiply into crowdfund tokens.\\n    uint16 internal constant TOKEN_SCALE = 1000;\\n\\n    // ============ Reentrancy ============\\n\\n    /// @notice Reentrancy constants.\\n    uint256 internal constant REENTRANCY_NOT_ENTERED = 1;\\n    uint256 internal constant REENTRANCY_ENTERED = 2;\\n\\n    /// @notice Current reentrancy status -- used by the modifier.\\n    uint256 internal reentrancy_status;\\n\\n    /// @notice The operator has a special role to change contract status.\\n    address payable public operator;\\n\\n    /// @notice Receives the funds when calling withdraw. Operator can configure.\\n    address payable public fundingRecipient;\\n\\n    /// @notice Treasury configuration.\\n    address public treasuryConfig;\\n\\n    /// @notice We add a hard cap to prevent raising more funds than deemed reasonable.\\n    uint256 public fundingCap;\\n\\n    /// @notice Fee percentage that the crowdfund pays to the treasury.\\n    uint256 public feePercentage;\\n\\n    /// @notice The operator takes some equity in the tokens, represented by this percent.\\n    uint256 public operatorPercent;\\n\\n    // ============ Mutable Storage ============\\n\\n    /// @notice Represents the current state of the campaign.\\n    Status public status;\\n\\n    // ============ Tiered Campaigns ============\\n\\n    /// @notice Address of the editions contract to purchase from.\\n    address public editions;\\n}\\n\"\r\n    },\r\n    \"contracts/external/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n// import {ERC20Storage} from \\\"./ERC20Storage.sol\\\";\\nimport {IERC20, IERC20Events} from \\\"./interface/IERC20.sol\\\";\\n\\n/**\\n * @title ERC20 Implementation.\\n * @author MirrorXYZ\\n */\\ncontract ERC20 is IERC20, IERC20Events {\\n    // ============ ERC20 Attributes ============\\n    /// @notice EIP-20 token name for this token\\n    string public override name;\\n\\n    /// @notice EIP-20 token symbol for this token\\n    string public override symbol;\\n\\n    /// @notice EIP-20 token decimals for this token\\n    uint8 public constant override decimals = 18;\\n\\n    // ============ Mutable ERC20 Storage ============\\n    /// @notice EIP-20 total number of tokens in circulation\\n    uint256 public override totalSupply;\\n\\n    /// @notice EIP-20 official record of token balances for each account\\n    mapping(address => uint256) public override balanceOf;\\n\\n    /// @notice EIP-20 allowance amounts on behalf of others\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    /**\\n     * @notice Initialize and assign total supply when using\\n     * proxy pattern. Only callable during contract deployment.\\n     * @param totalSupply_ is the initial token supply\\n     * @param to_ is the address that will hold the initial token supply\\n     */\\n    function initialize(uint256 totalSupply_, address to_) external {\\n        // Ensure that this function is only callable during contract construction.\\n        assembly {\\n            if extcodesize(address()) {\\n                revert(0, 0)\\n            }\\n        }\\n\\n        totalSupply = totalSupply_;\\n        balanceOf[to_] = totalSupply_;\\n        emit Transfer(address(0), to_, totalSupply_);\\n    }\\n\\n    // ============ ERC20 Spec ============\\n\\n    /**\\n     * @dev Function to increase allowance of tokens.\\n     * @param spender The address that will receive an allowance increase.\\n     * @param value The amount of tokens to increase allowance.\\n     */\\n    function approve(address spender, uint256 value)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to transfer tokens.\\n     * @param to The address that will receive the tokens.\\n     * @param value The amount of tokens to transfer.\\n     */\\n    function transfer(address to, uint256 value)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Function to transfer an accounts tokens. Sender of txn must be approved.\\n     * @param from The address that will transfer tokens.\\n     * @param to The address that will receive the tokens.\\n     * @param value The amount of tokens to transfer.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external override returns (bool) {\\n        require(\\n            allowance[from][msg.sender] >= value,\\n            \\\"transfer amount exceeds spender allowance\\\"\\n        );\\n\\n        allowance[from][msg.sender] = allowance[from][msg.sender] - value;\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    // ============ Private Utils ============\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply + value;\\n        balanceOf[to] = balanceOf[to] + value;\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] = balanceOf[from] - value;\\n        totalSupply = totalSupply - value;\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(balanceOf[from] >= value, \\\"transfer amount exceeds balance\\\");\\n\\n        balanceOf[from] = balanceOf[from] - value;\\n        balanceOf[to] = balanceOf[to] + value;\\n\\n        emit Transfer(from, to, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/producers/crowdfunds/crowdfund-with-editions/interface/ICrowdfundWithEditions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ICrowdfundWithEditions {\\n    struct Edition {\\n        // The maximum number of tokens that can be sold.\\n        uint256 quantity;\\n        // The price at which each token will be sold, in ETH.\\n        uint256 price;\\n        // The account that will receive sales revenue.\\n        address payable fundingRecipient;\\n        // The number of tokens sold so far.\\n        uint256 numSold;\\n        bytes32 contentHash;\\n    }\\n\\n    struct EditionTier {\\n        // The maximum number of tokens that can be sold.\\n        uint256 quantity;\\n        // The price at which each token will be sold, in ETH.\\n        uint256 price;\\n        bytes32 contentHash;\\n    }\\n\\n    function buyEdition(uint256 editionId, address recipient)\\n        external\\n        payable\\n        returns (uint256 tokenId);\\n\\n    function editionPrice(uint256 editionId) external view returns (uint256);\\n\\n    function createEditions(\\n        EditionTier[] memory tier,\\n        // The account that should receive the revenue.\\n        address payable fundingRecipient,\\n        address minter\\n    ) external;\\n\\n    function contractURI() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ITreasuryConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ITreasuryConfig {\\n    function treasury() external returns (address payable);\\n\\n    function distributionModel() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/external/interface/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IERC20 {\\n    /// @notice EIP-20 token name for this token\\n    function name() external returns (string calldata);\\n\\n    /// @notice EIP-20 token symbol for this token\\n    function symbol() external returns (string calldata);\\n\\n    /// @notice EIP-20 token decimals for this token\\n    function decimals() external returns (uint8);\\n\\n    /// @notice EIP-20 total number of tokens in circulation\\n    function totalSupply() external returns (uint256);\\n\\n    /// @notice EIP-20 official record of token balances for each account\\n    function balanceOf(address account) external returns (uint256);\\n\\n    /// @notice EIP-20 allowance amounts on behalf of others\\n    function allowance(address owner, address spender)\\n        external\\n        returns (uint256);\\n\\n    /// @notice EIP-20 approves _spender_ to transfer up to _value_ multiple times\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /// @notice EIP-20 transfer _value_ to _to_ from _msg.sender_\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /// @notice EIP-20 transfer _value_ to _to_ from _from_\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\\ninterface IERC20Events {\\n    /// @notice EIP-20 Mint event\\n    event Mint(address indexed to, uint256 amount);\\n\\n    /// @notice EIP-20 approval event\\n    event Approval(\\n        address indexed from,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    /// @notice EIP-20 transfer event\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BidAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Contribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"editionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ContributionForEdition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountRaised\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"creatorAllocation\",\"type\":\"uint256\"}],\"name\":\"FundingClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ReceivedERC721\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newFundingRecipient\",\"type\":\"address\"}],\"name\":\"changeFundingRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeFunding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePercentage_\",\"type\":\"uint256\"}],\"name\":\"computeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"backer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"editionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"contribute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"editions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundingCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundingRecipient\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"redeemableFromTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"enum CrowdfundWithEditionsStorage.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"valueToTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CrowdfundWithEditionsLogic","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}