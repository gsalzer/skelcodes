{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts@4.3.2/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.3.2/token/ERC1155/utils/ERC1155Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] memory,\\n        uint256[] memory,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.3.2/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.3.2/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.3.2/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.3.2/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@4.3.2/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/zuz_vault/ZUZVault_v1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.2;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts@4.3.2/token/ERC721/utils/ERC721Holder.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts@4.3.2/token/ERC1155/utils/ERC1155Holder.sol\\\";\\r\\n\\r\\ninterface IERC20 {\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function transferFrom(\\r\\n        address sender, address recipient, uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IERC721 {\\r\\n    function safeTransferFrom(\\r\\n        address from, address to, uint256 tokenId\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ninterface IERC1155 {\\r\\n    function safeTransferFrom(\\r\\n        address from, address to, uint256 id, uint256 amount, bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\\r\\n\\r\\ncontract owned {\\r\\n    address public manager;\\r\\n    address public feeRecipient;\\r\\n    bytes32 public currentSecretKey;\\r\\n\\r\\n    constructor() {\\r\\n        manager = msg.sender;\\r\\n\\t\\tfeeRecipient = msg.sender;\\r\\n    }\\r\\n    \\r\\n   modifier onlyManager() {\\r\\n        require(msg.sender == manager, \\\"Only Manager can execute this function\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    function changeVaultManager(address _newManager)  public onlyManager {\\r\\n        manager = _newManager;\\r\\n    }\\r\\n        \\r\\n    event changeSecretKeyValue(string indexed value);\\r\\n    function changeSecretKey (string memory _newSecretKey) public onlyManager {\\r\\n        currentSecretKey = keccak256(abi.encodePacked(_newSecretKey));\\r\\n        emit changeSecretKeyValue(\\\"Secret Key Changed.\\\");\\r\\n    }\\r\\n    \\r\\n    function changeFeeRecipient(address _newFeeRecipient) public onlyManager {\\r\\n        feeRecipient = _newFeeRecipient;\\r\\n    }\\r\\n    function withdrawCollectedETH() public onlyManager {\\r\\n        (bool success, ) = feeRecipient.call{value: address(this).balance}(\\\"\\\");\\r\\n        require(success, \\\"Failed to send Ether\\\");\\r\\n    }\\r\\n    \\r\\n}\\r\\n\\r\\ncontract ZUZVaultV1 is owned, ERC721Holder, ERC1155Holder {\\r\\n    \\r\\n    struct TokenInfo {\\r\\n        address tokenAddress;\\r\\n        address tokenOwner;\\r\\n        string tokenType;\\r\\n        bool isLiquidityToken;\\r\\n        uint tokenId;\\r\\n        uint tokenAmount;\\r\\n        uint lockTime;\\r\\n        uint unlockTime;\\r\\n        bool withdrawn;\\r\\n    }\\r\\n    uint256 public lastDepositId;\\r\\n    mapping (uint256 => TokenInfo) public TokenInfoTable;\\r\\n    mapping (address => uint[]) public depositsByCurrentUser;\\r\\n    mapping (address => mapping(address => uint)) public totalTokensLockedByUser;\\r\\n\\r\\n    \\r\\n    function lockTokens(\\r\\n        address _tokenAddress, string memory _tokenType, \\r\\n        bool _isLiquidityToken, uint _tokenId, uint256 _tokenAmount, uint _percentFee,\\r\\n        string memory _paymentMethod, address _serviceFeeToken, uint _serviceFee,\\r\\n        uint _unlockTime,string memory _secretKey\\r\\n    ) public payable {\\r\\n        require(currentSecretKey == keccak256(abi.encodePacked(_secretKey)), \\\"Secure Key is wrong\\\");\\r\\n  \\r\\n        uint fiftyYears = block.timestamp + 1576800000;\\r\\n        require(_unlockTime < fiftyYears, 'Maximum lock period is 50 years');\\r\\n        \\r\\n        // take service fee\\r\\n        if(_percentFee > 0) IERC20(_tokenAddress).transferFrom(msg.sender, feeRecipient, _percentFee);\\r\\n        if(keccak256(abi.encodePacked(_paymentMethod)) ==  keccak256(abi.encodePacked(\\\"eth\\\"))) {\\r\\n            require(msg.value >= _serviceFee, \\\"Service Fee in ETH is less than required\\\");\\r\\n        }\\r\\n        else if(keccak256(abi.encodePacked(_paymentMethod)) ==  keccak256(abi.encodePacked(\\\"other\\\"))) {\\r\\n            IERC20(_serviceFeeToken).transferFrom(msg.sender, feeRecipient, _serviceFee);\\r\\n        }\\r\\n        else {\\r\\n            require(false, \\\"Unknown Payment method used\\\");\\r\\n        }\\r\\n    \\r\\n        \\r\\n        // put tokens and userDetails into the locker\\r\\n        if(keccak256(abi.encodePacked(_tokenType)) ==  keccak256(abi.encodePacked(\\\"erc20\\\"))) {\\r\\n            IERC20(_tokenAddress).transferFrom(msg.sender, address(this), _tokenAmount);\\r\\n        }\\r\\n        else if(keccak256(abi.encodePacked(_tokenType)) ==  keccak256(abi.encodePacked(\\\"erc721\\\"))) {\\r\\n            IERC721(_tokenAddress).safeTransferFrom(msg.sender, address(this), _tokenId);\\r\\n        }\\r\\n        else if(keccak256(abi.encodePacked(_tokenType)) ==  keccak256(abi.encodePacked(\\\"erc1155\\\"))) {\\r\\n             IERC1155(_tokenAddress).safeTransferFrom(\\r\\n                msg.sender, address(this), _tokenId, _tokenAmount, '0x'\\r\\n            );\\r\\n        }\\r\\n        else {\\r\\n            require(false, \\\"TokenType is not supported\\\");\\r\\n        }\\r\\n        \\r\\n        totalTokensLockedByUser[msg.sender][_tokenAddress] += _tokenAmount;\\r\\n        \\r\\n        uint _id = ++lastDepositId;\\r\\n        TokenInfoTable[_id].tokenAddress = _tokenAddress;\\r\\n        TokenInfoTable[_id].tokenOwner = msg.sender;\\r\\n        TokenInfoTable[_id].tokenType = _tokenType;\\r\\n        TokenInfoTable[_id].isLiquidityToken = _isLiquidityToken;\\r\\n        TokenInfoTable[_id].tokenId = _tokenId;\\r\\n        TokenInfoTable[_id].tokenAmount = _tokenAmount;\\r\\n        TokenInfoTable[_id].lockTime = block.timestamp;\\r\\n        TokenInfoTable[_id].unlockTime = _unlockTime;\\r\\n        TokenInfoTable[_id].withdrawn = false;\\r\\n        \\r\\n        depositsByCurrentUser[msg.sender].push(_id);\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function withdrawTokens(uint _id) public {\\r\\n        require(msg.sender == TokenInfoTable[_id].tokenOwner, 'Only Token Owner can withdraw tokens');\\r\\n        require(block.timestamp >= TokenInfoTable[_id].unlockTime, 'Unlock time is still in future');\\r\\n        require(TokenInfoTable[_id].withdrawn == false, 'Tokens are already withdrawn');\\r\\n        \\r\\n        // give back tokens to the user\\r\\n        string memory _tokenType = TokenInfoTable[_id].tokenType;\\r\\n        if(keccak256(abi.encodePacked(_tokenType)) ==  keccak256(abi.encodePacked(\\\"erc20\\\"))) {\\r\\n            IERC20(TokenInfoTable[_id].tokenAddress).transfer(TokenInfoTable[_id].tokenOwner, TokenInfoTable[_id].tokenAmount);\\r\\n        }\\r\\n        else if(keccak256(abi.encodePacked(_tokenType)) ==  keccak256(abi.encodePacked(\\\"erc721\\\"))) {\\r\\n            IERC721(TokenInfoTable[_id].tokenAddress).safeTransferFrom(address(this), TokenInfoTable[_id].tokenOwner, TokenInfoTable[_id].tokenId);\\r\\n        }\\r\\n        else if(keccak256(abi.encodePacked(_tokenType)) ==  keccak256(abi.encodePacked(\\\"erc1155\\\"))) {\\r\\n            IERC1155(TokenInfoTable[_id].tokenAddress).safeTransferFrom(\\r\\n                address(this), TokenInfoTable[_id].tokenOwner, TokenInfoTable[_id].tokenId, TokenInfoTable[_id].tokenAmount, '0x'\\r\\n            );\\r\\n        }\\r\\n        TokenInfoTable[_id].withdrawn = true;\\r\\n        \\r\\n        //update balance in address\\r\\n        totalTokensLockedByUser[TokenInfoTable[_id].tokenOwner][TokenInfoTable[_id].tokenAddress] -= TokenInfoTable[_id].tokenAmount;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    /*get total token balance by address*/\\r\\n    function getTokenBalanceByAddress(address _userAddress, address _tokenAddress) view public returns (uint)\\r\\n    {\\r\\n       return totalTokensLockedByUser[_userAddress][_tokenAddress];\\r\\n    }\\r\\n    \\r\\n    /*get getDepositDetails*/\\r\\n    function getDepositDetails(uint256 _id) view public returns (TokenInfo memory)\\r\\n    {\\r\\n        return TokenInfoTable[_id];\\r\\n    }\\r\\n    \\r\\n    /*get DepositsByUserAddress*/\\r\\n    function getDepositsByUserAddress(address _currentUser) view public returns (uint[] memory)\\r\\n    {\\r\\n        return depositsByCurrentUser[_currentUser];\\r\\n    }\\r\\n}\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"changeSecretKeyValue\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TokenInfoTable\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenType\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isLiquidityToken\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withdrawn\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFeeRecipient\",\"type\":\"address\"}],\"name\":\"changeFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newSecretKey\",\"type\":\"string\"}],\"name\":\"changeSecretKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newManager\",\"type\":\"address\"}],\"name\":\"changeVaultManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSecretKey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositsByCurrentUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getDepositDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"tokenType\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isLiquidityToken\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withdrawn\",\"type\":\"bool\"}],\"internalType\":\"struct ZUZVaultV1.TokenInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_currentUser\",\"type\":\"address\"}],\"name\":\"getDepositsByUserAddress\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokenBalanceByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDepositId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_tokenType\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_isLiquidityToken\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentFee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_paymentMethod\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_serviceFeeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_serviceFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unlockTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_secretKey\",\"type\":\"string\"}],\"name\":\"lockTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalTokensLockedByUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawCollectedETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ZUZVaultV1","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}