{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"DebtLocker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity =0.8.7;\\n\\ninterface IAuctioneerLike {\\n\\n    function getExpectedAmount(uint256 swapAmount_) external view returns (uint256 expectedAmount_);\\n\\n}\\n\\ninterface IERC20Like {\\n\\n    function approve(address spender_, uint256 amount_) external returns (bool success_);\\n\\n    function balanceOf(address account_) external view returns (uint256 balanceOf_);\\n\\n    function decimals() external view returns (uint8 decimals_);\\n\\n    function transfer(address recipient_, uint256 amount_) external returns (bool success_);\\n\\n    function transferFrom(address owner_, address recipient_, uint256 amount_) external returns (bool success_);\\n\\n}\\n\\ninterface IMapleGlobalsLike {\\n\\n   function getLatestPrice(address asset_) external view returns (uint256 price_);\\n\\n   function protocolPaused() external view returns (bool protocolPaused_);\\n\\n}\\n\\ninterface IMapleLoanLike {\\n\\n    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external;\\n\\n    function claimableFunds() external view returns (uint256 claimableFunds_);\\n\\n    function collateralAsset() external view returns (address collateralAsset_);\\n\\n    function fundsAsset() external view returns (address fundsAsset_);\\n\\n    function principal() external view returns (uint256 principal_);\\n\\n    function claimFunds(uint256 amount_, address destination_) external;\\n\\n    function repossess(address destination_) external returns (uint256 collateralAssetAmount_, uint256 fundsAssetAmount_);\\n\\n}\\n\\ninterface IMapleProxyFactoryLike {\\n\\n    function upgradeInstance(uint256 toVersion_, bytes calldata arguments_) external;\\n\\n}\\n\\ninterface IPoolFactoryLike {\\n\\n    function globals() external pure returns (address globals_);\\n\\n}\\n\\ninterface IPoolLike {\\n\\n    function poolDelegate() external view returns (address poolDelegate_);\\n\\n    function superFactory() external view returns (address superFactory_);\\n\\n}\\n\\n/// @title Small Library to standardize erc20 token interactions.\\nlibrary ERC20Helper {\\n\\n    /**************************/\\n    /*** Internal Functions ***/\\n    /**************************/\\n\\n    function transfer(address token_, address to_, uint256 amount_) internal returns (bool success_) {\\n        return _call(token_, abi.encodeWithSelector(IERC20Like.transfer.selector, to_, amount_));\\n    }\\n\\n    function transferFrom(address token_, address from_, address to_, uint256 amount_) internal returns (bool success_) {\\n        return _call(token_, abi.encodeWithSelector(IERC20Like.transferFrom.selector, from_, to_, amount_));\\n    }\\n\\n    function approve(address token_, address spender_, uint256 amount_) internal returns (bool success_) {\\n        // If setting approval to zero fails, return false.\\n        if (!_call(token_, abi.encodeWithSelector(IERC20Like.approve.selector, spender_, uint256(0)))) return false;\\n\\n        // If `amount_` is zero, return true as the previous step already did this.\\n        if (amount_ == uint256(0)) return true;\\n\\n        // Return the result of setting the approval to `amount_`.\\n        return _call(token_, abi.encodeWithSelector(IERC20Like.approve.selector, spender_, amount_));\\n    }\\n\\n    function _call(address token_, bytes memory data_) private returns (bool success_) {\\n        if (token_.code.length == uint256(0)) return false;\\n\\n        bytes memory returnData;\\n        ( success_, returnData ) = token_.call(data_);\\n\\n        return success_ && (returnData.length == uint256(0) || abi.decode(returnData, (bool)));\\n    }\\n\\n}\\n\\ninterface ILiquidator {\\n\\n    /**\\n     * @dev   Auctioneer was set.\\n     * @param auctioneer_ Address of the auctioneer.\\n     */\\n    event AuctioneerSet(address auctioneer_);\\n\\n    /**\\n     * @dev   Funds were withdrawn from the liquidator.\\n     * @param token_       Address of the token that was withdrawn.\\n     * @param destination_ Address of where tokens were sent.\\n     * @param amount_      Amount of tokens that were sent.\\n     */\\n    event FundsPulled(address token_, address destination_, uint256 amount_);\\n\\n    /**\\n     * @dev   Portion of collateral was liquidated.\\n     * @param swapAmount_     Amount of collateralAsset that was liquidated.\\n     * @param returnedAmount_ Amount of fundsAsset that was returned.\\n     */\\n    event PortionLiquidated(uint256 swapAmount_, uint256 returnedAmount_);\\n\\n    /**\\n     * @dev Getter function that returns `collateralAsset`.\\n     */\\n    function collateralAsset() external view returns (address collateralAsset_);\\n\\n    /**\\n     * @dev Getter function that returns `destination` - address that liquidated funds are sent to.\\n     */\\n    function destination() external view returns (address destination_);\\n\\n    /**\\n     * @dev Getter function that returns `auctioneer`.\\n     */\\n    function auctioneer() external view returns (address auctioneer_);\\n\\n    /**\\n     * @dev Getter function that returns `fundsAsset`.\\n     */\\n    function fundsAsset() external view returns (address fundsAsset_);\\n\\n    /**\\n     * @dev Getter function that returns `globals`.\\n     */\\n    function globals() external view returns (address);\\n\\n    /**\\n     * @dev Getter function that returns `owner`.\\n     */\\n    function owner() external view returns (address owner_);\\n\\n    /**\\n     * @dev   Set the auctioneer contract address, which is used to pull the `getExpectedAmount`.\\n     *        Can only be set by `owner`.\\n     * @param auctioneer_ The auctioneer contract address.\\n     */\\n    function setAuctioneer(address auctioneer_) external;\\n\\n    /**\\n     * @dev   Pulls a specified amount of ERC-20 tokens from the contract.\\n     *        Can only be called by `owner`.\\n     * @param token_       The ERC-20 token contract address.\\n     * @param destination_ The destination of the transfer.\\n     * @param amount_      The amount to transfer.\\n     */\\n    function pullFunds(address token_, address destination_, uint256 amount_) external;\\n\\n    /**\\n     * @dev    Returns the expected amount to be returned from a flash loan given a certain amount of `collateralAsset`.\\n     * @param  swapAmount_     Amount of `collateralAsset` to be flash-borrowed.\\n     * @return expectedAmount_ Amount of `fundsAsset` that must be returned in the same transaction.\\n     */\\n    function getExpectedAmount(uint256 swapAmount_) external returns (uint256 expectedAmount_);\\n\\n    /**\\n     * @dev   Flash loan function that:\\n     *        1. Transfers a specified amount of `collateralAsset` to `msg.sender`.\\n     *        2. Performs an arbitrary call to `msg.sender`, to trigger logic necessary to get `fundsAsset` (e.g., AMM swap).\\n     *        3. Performs a `transferFrom`, taking the corresponding amount of `fundsAsset` from the user.\\n     *        If the required amount of `fundsAsset` is not returned in step 3, the entire transaction reverts.\\n     * @param swapAmount_      Amount of `collateralAsset` that is to be borrowed in the flash loan.\\n     * @param maxReturnAmount_ Max amount of `fundsAsset` that can be returned to the liquidator contract.\\n     * @param data_            ABI-encoded arguments to be used in the low-level call to perform step 2.\\n     */\\n    function liquidatePortion(uint256 swapAmount_, uint256 maxReturnAmount_, bytes calldata data_) external;\\n\\n}\\n\\ncontract Liquidator is ILiquidator {\\n\\n    uint256 private constant NOT_LOCKED = uint256(0);\\n    uint256 private constant LOCKED     = uint256(1);\\n\\n    uint256 internal _locked;\\n\\n    address public override immutable collateralAsset;\\n    address public override immutable destination;\\n    address public override immutable fundsAsset;\\n    address public override immutable globals;\\n    address public override immutable owner;\\n\\n    address public override auctioneer;\\n\\n    /*****************/\\n    /*** Modifiers ***/\\n    /*****************/\\n\\n    modifier whenProtocolNotPaused() {\\n        require(!IMapleGlobalsLike(globals).protocolPaused(), \\\"LIQ:PROTOCOL_PAUSED\\\");\\n        _;\\n    }\\n\\n    modifier lock() {\\n        require(_locked == NOT_LOCKED, \\\"LIQ:LOCKED\\\");\\n        _locked = LOCKED;\\n        _;\\n        _locked = NOT_LOCKED;\\n    }\\n\\n    /**\\n     * @param owner_           The address of an account that will have administrative privileges on this contract.\\n     * @param collateralAsset_ The address of the collateral asset being liquidated.\\n     * @param fundsAsset_      The address of the funds asset.\\n     * @param auctioneer_      The address of an Auctioneer.\\n     * @param destination_     The address to send funds asset after liquidation.\\n     * @param globals_         The address of a Maple Globals contract.\\n     */\\n    constructor(address owner_, address collateralAsset_, address fundsAsset_, address auctioneer_, address destination_, address globals_) {\\n        require((owner           = owner_)           != address(0), \\\"LIQ:C:INVALID_OWNER\\\");\\n        require((collateralAsset = collateralAsset_) != address(0), \\\"LIQ:C:INVALID_COL_ASSET\\\");\\n        require((fundsAsset      = fundsAsset_)      != address(0), \\\"LIQ:C:INVALID_FUNDS_ASSET\\\");\\n        require((destination     = destination_)     != address(0), \\\"LIQ:C:INVALID_DEST\\\");\\n\\n        require(!IMapleGlobalsLike(globals = globals_).protocolPaused(), \\\"LIQ:C:INVALID_GLOBALS\\\");\\n\\n        // NOTE: Auctioneer of zero is valid, since it is starting the contract off in a paused state.\\n        auctioneer = auctioneer_;\\n    }\\n\\n    function setAuctioneer(address auctioneer_) external override {\\n        require(msg.sender == owner, \\\"LIQ:SA:NOT_OWNER\\\");\\n\\n        emit AuctioneerSet(auctioneer = auctioneer_);\\n    }\\n\\n    function pullFunds(address token_, address destination_, uint256 amount_) external override {\\n        require(msg.sender == owner, \\\"LIQ:PF:NOT_OWNER\\\");\\n\\n        emit FundsPulled(token_, destination_, amount_);\\n\\n        require(ERC20Helper.transfer(token_, destination_, amount_), \\\"LIQ:PF:TRANSFER\\\");\\n    }\\n\\n    function getExpectedAmount(uint256 swapAmount_) public view override returns (uint256 expectedAmount_) {\\n        return IAuctioneerLike(auctioneer).getExpectedAmount(swapAmount_);\\n    }\\n\\n    function liquidatePortion(uint256 collateralAmount_, uint256 maxReturnAmount_, bytes calldata data_) external override whenProtocolNotPaused lock {\\n        // Transfer a requested amount of collateralAsset to the borrwer.\\n        require(ERC20Helper.transfer(collateralAsset, msg.sender, collateralAmount_), \\\"LIQ:LP:TRANSFER\\\");\\n\\n        // Perform a low-level call to msg.sender, allowing a swap strategy to be executed with the transferred collateral.\\n        msg.sender.call(data_);\\n\\n        // Calculate the amount of fundsAsset required based on the amount of collateralAsset borrowed.\\n        uint256 returnAmount = getExpectedAmount(collateralAmount_);\\n        require(returnAmount <= maxReturnAmount_, \\\"LIQ:LP:MAX_RETURN_EXCEEDED\\\");\\n\\n        emit PortionLiquidated(collateralAmount_, returnAmount);\\n\\n        // Pull required amount of fundsAsset from the borrower, if this amount of funds cannot be recovered atomically, revert.\\n        require(ERC20Helper.transferFrom(fundsAsset, msg.sender, destination, returnAmount), \\\"LIQ:LP:TRANSFER_FROM\\\");\\n    }\\n\\n}\\n\\n/// @title An implementation that is to be proxied, must implement IProxied.\\ninterface IProxied {\\n\\n    /**\\n     *  @dev The address of the proxy factory.\\n     */\\n    function factory() external view returns (address factory_);\\n\\n    /**\\n     *  @dev The address of the implementation contract being proxied.\\n     */\\n    function implementation() external view returns (address implementation_);\\n\\n    /**\\n     *  @dev   Modifies the proxy's implementation address.\\n     *  @param newImplementation_ The address of an implementation contract.\\n     */\\n    function setImplementation(address newImplementation_) external;\\n\\n    /**\\n     *  @dev   Modifies the proxy's storage by delegate-calling a migrator contract with some arguments.\\n     *         Access control logic critical since caller can force a selfdestruct via a malicious `migrator_` which is delegatecalled.\\n     *  @param migrator_  The address of a migrator contract.\\n     *  @param arguments_ Some encoded arguments to use for the migration.\\n     */\\n    function migrate(address migrator_, bytes calldata arguments_) external;\\n\\n}\\n\\n/// @title A Maple implementation that is to be proxied, must implement IMapleProxied.\\ninterface IMapleProxied is IProxied {\\n\\n    /**\\n     *  @dev   The instance was upgraded.\\n     *  @param toVersion_ The new version of the loan.\\n     *  @param arguments_ The upgrade arguments, if any.\\n     */\\n    event Upgraded(uint256 toVersion_, bytes arguments_);\\n\\n    /**\\n     *  @dev   Upgrades a contract implementation to a specific version.\\n     *         Access control logic critical since caller can force a selfdestruct via a malicious `migrator_` which is delegatecalled.\\n     *  @param toVersion_ The version to upgrade to.\\n     *  @param arguments_ Some encoded arguments to use for the upgrade.\\n     */\\n    function upgrade(uint256 toVersion_, bytes calldata arguments_) external;\\n\\n}\\n\\n/// @title DebtLocker interacts with Loans on behalf of PoolV1.\\ninterface IDebtLocker is IMapleProxied {\\n\\n    /**************/\\n    /*** Events ***/\\n    /**************/\\n\\n    /**\\n     * @dev   Emitted when `setAllowedSlippage` is called.\\n     * @param newSlippage_ New value for `allowedSlippage`.\\n     */\\n    event AllowedSlippageSet(uint256 newSlippage_);\\n\\n    /**\\n     * @dev   Emitted when `setAuctioneer` is called.\\n     * @param newAuctioneer_ New value for `auctioneer` in Liquidator.\\n     */\\n    event AuctioneerSet(address newAuctioneer_);\\n\\n    /**\\n     * @dev   Emitted when `fundsToCapture` is set.\\n     * @param amount_ The amount of funds that will be captured next claim.\\n     */\\n    event FundsToCaptureSet(uint256 amount_);\\n\\n    /**\\n     * @dev Emitted when `stopLiquidation` is called.\\n     */\\n    event LiquidationStopped();\\n\\n    /**\\n     * @dev   Emitted when `setMinRatio` is called.\\n     * @param newMinRatio_ New value for `minRatio`.\\n     */\\n    event MinRatioSet(uint256 newMinRatio_);\\n\\n    /*****************/\\n    /*** Functions ***/\\n    /*****************/\\n\\n    /**\\n     * @dev   Accept the new loan terms and trigger a refinance.\\n     * @param refinancer_ The address of the refinancer contract.\\n     * @param calls_      The array of encoded data that are to be executed as delegatecalls by the refinancer.\\n     * @param amount_     The amount of `fundsAsset` that is to be sent to the Loan as part of the transaction.\\n     */\\n    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external;\\n\\n    /**\\n     *  @dev    Claims funds to send to Pool. Handles funds from payments and liquidations.\\n     *          Only the Pool can call this function.\\n     *  @return details_\\n     *              [0] => Total Claimed.\\n     *              [1] => Interest Claimed.\\n     *              [2] => Principal Claimed.\\n     *              [3] => Pool Delegate Fees Claimed.\\n     *              [4] => Excess Returned Claimed.\\n     *              [5] => Amount Recovered (from Liquidation).\\n     *              [6] => Default Suffered.\\n     */\\n    function claim() external returns (uint256[7] memory details_);\\n\\n    /**\\n     * @dev   Allows the poolDelegate to pull some funds from liquidator contract.\\n     * @param liquidator_  The liquidator to which pull funds from.\\n     * @param token_       The token address of the funds.\\n     * @param destination_ The destination address of captured funds.\\n     * @param amount_      The amount to pull.\\n     */\\n    function pullFundsFromLiquidator(address liquidator_, address token_, address destination_, uint256 amount_) external;\\n\\n    /**\\n     * @dev Returns the address of the Pool Delegate that has control of the DebtLocker.\\n     */\\n    function poolDelegate() external view returns (address poolDelegate_);\\n\\n    /**\\n     * @dev Repossesses funds and collateral from a loan and transfers them to the Liquidator.\\n     */\\n    function triggerDefault() external;\\n\\n    /**\\n     * @dev   Sets the allowed slippage for auctioneer (used to determine expected amount to be returned in flash loan).\\n     * @param allowedSlippage_ Basis points representation of allowed percent slippage from market price.\\n     */\\n    function setAllowedSlippage(uint256 allowedSlippage_) external;\\n\\n    /**\\n     * @dev   Sets the auctioneer contract for the liquidator.\\n     * @param auctioneer_ Address of auctioneer contract.\\n     */\\n    function setAuctioneer(address auctioneer_) external;\\n\\n    /**\\n     * @dev   Sets the minimum \\\"price\\\" for auctioneer (used to determine expected amount to be returned in flash loan).\\n     * @param minRatio_ Price in fundsAsset precision (e.g., 10 * 10 ** 6 for $10 price for USDC).\\n     */\\n    function setMinRatio(uint256 minRatio_) external;\\n\\n    /**\\n     * @dev    Returns the expected amount to be returned to the liquidator during a flash borrower liquidation.\\n     * @param  swapAmount_   Amount of collateralAsset being swapped.\\n     * @return returnAmount_ Amount of fundsAsset that must be returned in the same transaction.\\n     */\\n    function getExpectedAmount(uint256 swapAmount_) external view returns (uint256 returnAmount_);\\n\\n    /**\\n     * @dev   Returns the expected amount to be returned to the liquidator during a flash borrower liquidation.\\n     * @param amount_ The amount of funds that should be captured next claim.\\n     */\\n    function setFundsToCapture(uint256 amount_) external;\\n\\n    /**\\n     * @dev Called by the PoolDelegate in case of a DoS, where a user transfers small amounts of collateralAsset into the Liquidator\\n     *      to make `_isLiquidationActive` remain true.\\n     *      CALLING THIS MAY RESULT IN RECOGNIZED LOSSES IN POOL ACCOUNTING. CONSULT MAPLE TEAM FOR GUIDANCE.\\n     */\\n    function stopLiquidation() external;\\n\\n    /*************/\\n    /*** State ***/\\n    /*************/\\n\\n    /**\\n     * @dev The Loan contract this locker is holding tokens for.\\n     */\\n    function loan() external view returns (address loan_);\\n\\n    /**\\n     * @dev The address of the liquidator.\\n     */\\n    function liquidator() external view returns (address liquidator_);\\n\\n    /**\\n     * @dev The owner of this Locker (the Pool).\\n     */\\n    function pool() external view returns (address pool_);\\n\\n    /**\\n     * @dev The maximum slippage allowed during liquidations.\\n     */\\n    function allowedSlippage() external view returns (uint256 allowedSlippage_);\\n\\n    /**\\n     * @dev The amount in funds asset recovered during liquidations.\\n     */\\n    function amountRecovered() external view returns (uint256 amountRecovered_);\\n\\n    /**\\n     * @dev The minimum exchange ration between funds asset and collateral asset.\\n     */\\n    function minRatio() external view returns (uint256 minRatio_);\\n\\n    /**\\n     * @dev Returns the principal that was present at the time of last claim.\\n     */\\n    function principalRemainingAtLastClaim() external view returns (uint256 principalRemainingAtLastClaim_);\\n\\n    /**\\n     * @dev Returns if the funds have been repossessed.\\n     */\\n    function repossessed() external view returns (bool repossessed_);\\n\\n    /**\\n     * @dev Returns the amount of funds that will be captured next claim.\\n     */\\n    function fundsToCapture() external view returns (uint256 fundsToCapture_);\\n\\n}\\n\\n/// @title DebtLockerStorage maps the storage layout of a DebtLocker.\\ncontract DebtLockerStorage {\\n\\n    address internal _liquidator;\\n    address internal _loan;\\n    address internal _pool;\\n\\n    bool internal _repossessed;\\n\\n    uint256 internal _allowedSlippage;\\n    uint256 internal _amountRecovered;\\n    uint256 internal _fundsToCapture;\\n    uint256 internal _minRatio;\\n    uint256 internal _principalRemainingAtLastClaim;\\n\\n}\\n\\nabstract contract SlotManipulatable {\\n\\n    function _getReferenceTypeSlot(bytes32 slot_, bytes32 key_) internal pure returns (bytes32 value_) {\\n        return keccak256(abi.encodePacked(key_, slot_));\\n    }\\n\\n    function _getSlotValue(bytes32 slot_) internal view returns (bytes32 value_) {\\n        assembly {\\n            value_ := sload(slot_)\\n        }\\n    }\\n\\n    function _setSlotValue(bytes32 slot_, bytes32 value_) internal {\\n        assembly {\\n            sstore(slot_, value_)\\n        }\\n    }\\n\\n}\\n\\n/// @title An implementation that is to be proxied, will need ProxiedInternals.\\nabstract contract ProxiedInternals is SlotManipulatable {\\n\\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.factory') - 1`.\\n    bytes32 private constant FACTORY_SLOT = bytes32(0x7a45a402e4cb6e08ebc196f20f66d5d30e67285a2a8aa80503fa409e727a4af1);\\n\\n    /// @dev Storage slot with the address of the current factory. `keccak256('eip1967.proxy.implementation') - 1`.\\n    bytes32 private constant IMPLEMENTATION_SLOT = bytes32(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc);\\n\\n    /// @dev Delegatecalls to a migrator contract to manipulate storage during an initialization or migration.\\n    function _migrate(address migrator_, bytes calldata arguments_) internal virtual returns (bool success_) {\\n        uint256 size;\\n\\n        assembly {\\n            size := extcodesize(migrator_)\\n        }\\n\\n        if (size == uint256(0)) return false;\\n\\n        ( success_, ) = migrator_.delegatecall(arguments_);\\n    }\\n\\n    /// @dev Sets the factory address in storage.\\n    function _setFactory(address factory_) internal virtual returns (bool success_) {\\n        _setSlotValue(FACTORY_SLOT, bytes32(uint256(uint160(factory_))));\\n        return true;\\n    }\\n\\n    /// @dev Sets the implementation address in storage.\\n    function _setImplementation(address implementation_) internal virtual returns (bool success_) {\\n        _setSlotValue(IMPLEMENTATION_SLOT, bytes32(uint256(uint160(implementation_))));\\n        return true;\\n    }\\n\\n    /// @dev Returns the factory address.\\n    function _factory() internal view virtual returns (address factory_) {\\n        return address(uint160(uint256(_getSlotValue(FACTORY_SLOT))));\\n    }\\n\\n    /// @dev Returns the implementation address.\\n    function _implementation() internal view virtual returns (address implementation_) {\\n        return address(uint160(uint256(_getSlotValue(IMPLEMENTATION_SLOT))));\\n    }\\n\\n}\\n\\n/// @title A Maple implementation that is to be proxied, will need MapleProxiedInternals.\\nabstract contract MapleProxiedInternals is ProxiedInternals {}\\n\\n/// @title DebtLocker interacts with Loans on behalf of PoolV1.\\ncontract DebtLocker is IDebtLocker, DebtLockerStorage, MapleProxiedInternals {\\n\\n    /*****************/\\n    /*** Modifiers ***/\\n    /*****************/\\n\\n    modifier whenProtocolNotPaused() {\\n        require(!IMapleGlobalsLike(_getGlobals()).protocolPaused(), \\\"DL:PROTOCOL_PAUSED\\\");\\n        _;\\n    }\\n\\n    /********************************/\\n    /*** Administrative Functions ***/\\n    /********************************/\\n\\n    function migrate(address migrator_, bytes calldata arguments_) external override {\\n        require(msg.sender == _factory(),        \\\"DL:M:NOT_FACTORY\\\");\\n        require(_migrate(migrator_, arguments_), \\\"DL:M:FAILED\\\");\\n    }\\n\\n    function setImplementation(address newImplementation_) external override {\\n        require(msg.sender == _factory(),               \\\"DL:SI:NOT_FACTORY\\\");\\n        require(_setImplementation(newImplementation_), \\\"DL:SI:FAILED\\\");\\n    }\\n\\n    function upgrade(uint256 toVersion_, bytes calldata arguments_) external override {\\n        require(msg.sender == _getPoolDelegate(), \\\"DL:U:NOT_POOL_DELEGATE\\\");\\n\\n        emit Upgraded(toVersion_, arguments_);\\n\\n        IMapleProxyFactoryLike(_factory()).upgradeInstance(toVersion_, arguments_);\\n    }\\n\\n    /*******************************/\\n    /*** Pool Delegate Functions ***/\\n    /*******************************/\\n\\n    function acceptNewTerms(address refinancer_, bytes[] calldata calls_, uint256 amount_) external override whenProtocolNotPaused {\\n        require(msg.sender == _getPoolDelegate(), \\\"DL:ANT:NOT_PD\\\");\\n\\n        address loanAddress = _loan;\\n\\n        require(\\n            (IMapleLoanLike(loanAddress).claimableFunds() + _fundsToCapture == uint256(0)) &&\\n            (IMapleLoanLike(loanAddress).principal() == _principalRemainingAtLastClaim),\\n            \\\"DL:ANT:NEED_TO_CLAIM\\\"\\n        );\\n\\n        require(\\n            amount_ == uint256(0) || ERC20Helper.transfer(IMapleLoanLike(loanAddress).fundsAsset(), loanAddress, amount_),\\n            \\\"DL:ANT:TRANSFER_FAILED\\\"\\n        );\\n\\n        IMapleLoanLike(loanAddress).acceptNewTerms(refinancer_, calls_, uint256(0));\\n\\n        // NOTE: This must be set after accepting the new terms, which affects the loan principal.\\n        _principalRemainingAtLastClaim = IMapleLoanLike(loanAddress).principal();\\n    }\\n\\n    function claim() external override whenProtocolNotPaused returns (uint256[7] memory details_) {\\n        require(msg.sender == _pool, \\\"DL:C:NOT_POOL\\\");\\n\\n        return _repossessed ? _handleClaimOfRepossessed(msg.sender, _loan) : _handleClaim(msg.sender, _loan);\\n    }\\n\\n    function pullFundsFromLiquidator(address liquidator_, address token_, address destination_, uint256 amount_) external override {\\n        require(msg.sender == _getPoolDelegate(), \\\"DL:SA:NOT_PD\\\");\\n\\n        Liquidator(liquidator_).pullFunds(token_, destination_, amount_);\\n    }\\n\\n    function setAllowedSlippage(uint256 allowedSlippage_) external override whenProtocolNotPaused {\\n        require(msg.sender == _getPoolDelegate(),    \\\"DL:SAS:NOT_PD\\\");\\n        require(allowedSlippage_ <= uint256(10_000), \\\"DL:SAS:INVALID_SLIPPAGE\\\");\\n\\n        emit AllowedSlippageSet(_allowedSlippage = allowedSlippage_);\\n    }\\n\\n    function setAuctioneer(address auctioneer_) external override whenProtocolNotPaused {\\n        require(msg.sender == _getPoolDelegate(), \\\"DL:SA:NOT_PD\\\");\\n\\n        emit AuctioneerSet(auctioneer_);\\n\\n        Liquidator(_liquidator).setAuctioneer(auctioneer_);\\n    }\\n\\n    function setFundsToCapture(uint256 amount_) override external whenProtocolNotPaused {\\n        require(msg.sender == _getPoolDelegate(), \\\"DL:SFTC:NOT_PD\\\");\\n\\n        emit FundsToCaptureSet(_fundsToCapture = amount_);\\n    }\\n\\n    function setMinRatio(uint256 minRatio_) external override whenProtocolNotPaused {\\n        require(msg.sender == _getPoolDelegate(), \\\"DL:SMR:NOT_PD\\\");\\n\\n        emit MinRatioSet(_minRatio = minRatio_);\\n    }\\n\\n    // Pool delegate can prematurely stop liquidation when there's still significant amount to be liquidated.\\n    function stopLiquidation() external override {\\n        require(msg.sender == _getPoolDelegate(), \\\"DL:SL:NOT_PD\\\");\\n\\n        _liquidator = address(0);\\n\\n        emit LiquidationStopped();\\n    }\\n\\n    function triggerDefault() external override whenProtocolNotPaused {\\n        require(msg.sender == _pool, \\\"DL:TD:NOT_POOL\\\");\\n\\n        address loanAddress = _loan;\\n\\n        require(\\n            (IMapleLoanLike(loanAddress).claimableFunds() == uint256(0)) &&\\n            (IMapleLoanLike(loanAddress).principal() == _principalRemainingAtLastClaim),\\n            \\\"DL:TD:NEED_TO_CLAIM\\\"\\n        );\\n\\n        _repossessed = true;\\n\\n        // Ensure that principal is always up to date, claim function will clear out all payments, but on refinance we need to ensure that\\n        // accounting is updated properly when principal is updated and there are no claimable funds.\\n\\n        // Repossess collateral and funds from Loan.\\n        ( uint256 collateralAssetAmount, ) = IMapleLoanLike(loanAddress).repossess(address(this));\\n\\n        address collateralAsset = IMapleLoanLike(loanAddress).collateralAsset();\\n        address fundsAsset      = IMapleLoanLike(loanAddress).fundsAsset();\\n\\n        if (collateralAsset == fundsAsset || collateralAssetAmount == uint256(0)) return;\\n\\n        // Deploy Liquidator contract and transfer collateral.\\n        require(\\n            ERC20Helper.transfer(\\n                collateralAsset,\\n                _liquidator = address(new Liquidator(address(this), collateralAsset, fundsAsset, address(this), address(this), _getGlobals())),\\n                collateralAssetAmount\\n            ),\\n            \\\"DL:TD:TRANSFER\\\"\\n       );\\n    }\\n\\n    /**************************/\\n    /*** Internal Functions ***/\\n    /**************************/\\n\\n    function _handleClaim(address pool_, address loan_) internal returns (uint256[7] memory details_) {\\n        // Get loan state variables needed\\n        uint256 claimableFunds = IMapleLoanLike(loan_).claimableFunds();\\n\\n        require(claimableFunds > uint256(0), \\\"DL:HC:NOTHING_TO_CLAIM\\\");\\n\\n        // Send funds to pool\\n        IMapleLoanLike(loan_).claimFunds(claimableFunds, pool_);\\n\\n        uint256 currentPrincipalRemaining = IMapleLoanLike(loan_).principal();\\n\\n        // Determine how much of `claimableFunds` is principal\\n        uint256 principalPortion = _principalRemainingAtLastClaim - currentPrincipalRemaining;\\n\\n        // Update state variables\\n        _principalRemainingAtLastClaim = currentPrincipalRemaining;\\n\\n        // Set return values\\n        // Note: All fees get deducted and transferred during `loan.fundLoan()` that omits the need to\\n        // return the fees distribution to the pool.\\n        details_[0] = claimableFunds;\\n        details_[1] = claimableFunds - principalPortion;\\n        details_[2] = principalPortion;\\n\\n        uint256 amountOfFundsToCapture = _fundsToCapture;\\n\\n        if (amountOfFundsToCapture > uint256(0)) {\\n            details_[0] += amountOfFundsToCapture;\\n            details_[2] += amountOfFundsToCapture;\\n\\n            _fundsToCapture = uint256(0);\\n\\n            require(ERC20Helper.transfer(IMapleLoanLike(loan_).fundsAsset(), pool_, amountOfFundsToCapture), \\\"DL:HC:CAPTURE_FAILED\\\");\\n        }\\n    }\\n\\n    function _handleClaimOfRepossessed(address pool_, address loan_) internal returns (uint256[7] memory details_) {\\n        require(!_isLiquidationActive(), \\\"DL:HCOR:LIQ_NOT_FINISHED\\\");\\n\\n        address fundsAsset       = IMapleLoanLike(loan_).fundsAsset();\\n        uint256 principalToCover = _principalRemainingAtLastClaim;      // Principal remaining at time of liquidation\\n        uint256 fundsCaptured    = _fundsToCapture;\\n\\n        // Funds recovered from liquidation and any unclaimed previous payment amounts\\n        uint256 recoveredFunds = IERC20Like(fundsAsset).balanceOf(address(this)) - fundsCaptured;\\n\\n        uint256 totalClaimed = recoveredFunds + fundsCaptured;\\n\\n        // If `recoveredFunds` is greater than `principalToCover`, the remaining amount is treated as interest in the context of the pool.\\n        // If `recoveredFunds` is less than `principalToCover`, the difference is registered as a shortfall.\\n        details_[0] = totalClaimed;\\n        details_[1] = recoveredFunds > principalToCover ? recoveredFunds - principalToCover : uint256(0);\\n        details_[2] = fundsCaptured;\\n        details_[5] = recoveredFunds > principalToCover ? principalToCover : recoveredFunds;\\n        details_[6] = principalToCover > recoveredFunds ? principalToCover - recoveredFunds : uint256(0);\\n\\n        _fundsToCapture = uint256(0);\\n        _repossessed    = false;\\n\\n        require(ERC20Helper.transfer(fundsAsset, pool_, totalClaimed), \\\"DL:HCOR:TRANSFER\\\");\\n    }\\n\\n    /**********************/\\n    /*** View Functions ***/\\n    /**********************/\\n\\n    function allowedSlippage() external view override returns (uint256 allowedSlippage_) {\\n        return _allowedSlippage;\\n    }\\n\\n    function amountRecovered() external view override returns (uint256 amountRecovered_) {\\n        return _amountRecovered;\\n    }\\n\\n    function factory() external view override returns (address factory_) {\\n        return _factory();\\n    }\\n\\n    function fundsToCapture() external view override returns (uint256 fundsToCapture_) {\\n        return _fundsToCapture;\\n    }\\n\\n    function getExpectedAmount(uint256 swapAmount_) external view override whenProtocolNotPaused returns (uint256 returnAmount_) {\\n        address loanAddress     = _loan;\\n        address collateralAsset = IMapleLoanLike(loanAddress).collateralAsset();\\n        address fundsAsset      = IMapleLoanLike(loanAddress).fundsAsset();\\n        address globals         = _getGlobals();\\n\\n        uint8 collateralAssetDecimals = IERC20Like(collateralAsset).decimals();\\n\\n        uint256 oracleAmount =\\n            swapAmount_\\n                * IMapleGlobalsLike(globals).getLatestPrice(collateralAsset)  // Convert from `fromAsset` value.\\n                * uint256(10) ** uint256(IERC20Like(fundsAsset).decimals())   // Convert to `toAsset` decimal precision.\\n                * (uint256(10_000) - _allowedSlippage)                        // Multiply by allowed slippage basis points\\n                / IMapleGlobalsLike(globals).getLatestPrice(fundsAsset)       // Convert to `toAsset` value.\\n                / uint256(10) ** uint256(collateralAssetDecimals)             // Convert from `fromAsset` decimal precision.\\n                / uint256(10_000);                                            // Divide basis points for slippage.\\n\\n        uint256 minRatioAmount = (swapAmount_ * _minRatio) / (uint256(10) ** collateralAssetDecimals);\\n\\n        return oracleAmount > minRatioAmount ? oracleAmount : minRatioAmount;\\n    }\\n\\n    function implementation() external view override returns (address implementation_) {\\n        return _implementation();\\n    }\\n\\n    function liquidator() external view override returns (address liquidator_) {\\n        return _liquidator;\\n    }\\n\\n    function loan() external view override returns (address loan_) {\\n        return _loan;\\n    }\\n\\n    function minRatio() external view override returns (uint256 minRatio_) {\\n        return _minRatio;\\n    }\\n\\n    function pool() external view override returns (address pool_) {\\n        return _pool;\\n    }\\n\\n    function poolDelegate() external override view returns (address poolDelegate_) {\\n        return _getPoolDelegate();\\n    }\\n\\n    function principalRemainingAtLastClaim() external view override returns (uint256 principalRemainingAtLastClaim_) {\\n        return _principalRemainingAtLastClaim;\\n    }\\n\\n    function repossessed() external view override returns (bool repossessed_) {\\n        return _repossessed;\\n    }\\n\\n    /*******************************/\\n    /*** Internal View Functions ***/\\n    /*******************************/\\n\\n    function _getGlobals() internal view returns (address globals_) {\\n        return IPoolFactoryLike(IPoolLike(_pool).superFactory()).globals();\\n    }\\n\\n    function _getPoolDelegate() internal view returns(address poolDelegate_) {\\n        return IPoolLike(_pool).poolDelegate();\\n    }\\n\\n    function _isLiquidationActive() internal view returns (bool isActive_) {\\n        address liquidatorAddress = _liquidator;\\n\\n        return (liquidatorAddress != address(0)) && (IERC20Like(IMapleLoanLike(_loan).collateralAsset()).balanceOf(liquidatorAddress) != uint256(0));\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSlippage_\",\"type\":\"uint256\"}],\"name\":\"AllowedSlippageSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAuctioneer_\",\"type\":\"address\"}],\"name\":\"AuctioneerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"FundsToCaptureSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LiquidationStopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinRatio_\",\"type\":\"uint256\"}],\"name\":\"MinRatioSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toVersion_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"arguments_\",\"type\":\"bytes\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"refinancer_\",\"type\":\"address\"},{\"internalType\":\"bytes[]\",\"name\":\"calls_\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"acceptNewTerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowedSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"allowedSlippage_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountRecovered\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountRecovered_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256[7]\",\"name\":\"details_\",\"type\":\"uint256[7]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundsToCapture\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fundsToCapture_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapAmount_\",\"type\":\"uint256\"}],\"name\":\"getExpectedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"liquidator_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loan\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"loan_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"migrator_\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"arguments_\",\"type\":\"bytes\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minRatio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolDelegate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"poolDelegate_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"principalRemainingAtLastClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principalRemainingAtLastClaim_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidator_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destination_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"pullFundsFromLiquidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"repossessed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"repossessed_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"allowedSlippage_\",\"type\":\"uint256\"}],\"name\":\"setAllowedSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"auctioneer_\",\"type\":\"address\"}],\"name\":\"setAuctioneer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"setFundsToCapture\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation_\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minRatio_\",\"type\":\"uint256\"}],\"name\":\"setMinRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopLiquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"triggerDefault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"toVersion_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"arguments_\",\"type\":\"bytes\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DebtLocker","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"none"}]}