{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MerkleDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport \\\"./interfaces/IMerkleDistributor.sol\\\";\\n\\ncontract MerkleDistributor is IMerkleDistributor {\\n    address private immutable _token;\\n    address private immutable _governance;\\n    bytes32 private immutable _merkleRoot;\\n    uint256 private immutable _unlockTimestamp;\\n    uint256 private immutable _clawbackTimestamp;\\n    uint256 private immutable _amountToClaim;\\n\\n    mapping(bytes32 => bool) private _claimed;\\n\\n    error ClaimLocked();\\n    error ClawbackLocked();\\n    error AlreadyClaimed();\\n    error InvalidProof();\\n    error NotGovernance();\\n    error NotGovernanceOrSelf();\\n    error ClawbackFailed();\\n    error ClaimFailed();\\n\\n    modifier unlocked() {\\n        if (block.timestamp < _unlockTimestamp) revert ClaimLocked();\\n        _;\\n    }\\n\\n    modifier clawbackAllowed() {\\n        if (block.timestamp < _clawbackTimestamp) revert ClawbackLocked();\\n        _;\\n    }\\n\\n    modifier notClaimed(uint256 index, address account) {\\n        if (isClaimed(index, account)) revert AlreadyClaimed();\\n        _;\\n    }\\n\\n    modifier validProof(\\n        uint256 index,\\n        address account,\\n        bytes32[] memory merkleProof\\n    ) {\\n        bool result = verifyMerkleProof(\\n            index,\\n            account,\\n            merkleProof\\n        );\\n        if (!result) revert InvalidProof();\\n        _;\\n    }\\n\\n    modifier isGovernance() {\\n        if (msg.sender != _governance) revert NotGovernance();\\n        _;\\n    }\\n\\n    constructor(\\n        address token_,\\n        uint256 amountToClaim_,\\n        bytes32 merkleRoot_,\\n        address governance_,\\n        uint256 unlockTimestamp_,\\n        uint256 clawbackTimestamp_\\n    ) {\\n        _token = token_;\\n        _amountToClaim = amountToClaim_;\\n        _merkleRoot = merkleRoot_;\\n        _governance = governance_;\\n        _unlockTimestamp = unlockTimestamp_;\\n        _clawbackTimestamp = clawbackTimestamp_;\\n    }\\n\\n    // Claim the given amount of the token to self. Reverts if the inputs are invalid.\\n    function claim(\\n        uint256 index,\\n        bytes32[] calldata merkleProof\\n    )\\n        external\\n        override\\n        unlocked\\n    {\\n        _claim(index, msg.sender, merkleProof);\\n    }\\n\\n    // Claim the given amount of the token to the given address. Reverts if the inputs are invalid.\\n    function claimByGovernance(\\n        uint256 index,\\n        address account,\\n        bytes32[] calldata merkleProof\\n    )\\n        external\\n        override\\n        isGovernance\\n        unlocked\\n    {\\n        _claim(index, account, merkleProof);\\n    }\\n\\n    // Clawback the given amount of the token to the given address.\\n    function clawback()\\n        external\\n        override\\n        isGovernance\\n        clawbackAllowed\\n    {\\n        emit Clawback();\\n\\n        uint256 balance = IERC20(_token).balanceOf(address(this));\\n        bool result = IERC20(_token).transfer(_governance, balance);\\n        if (!result) revert ClawbackFailed();\\n    }\\n\\n    // Returns the address of the token distributed by this contract.\\n    function token() external view override returns (address) {\\n        return _token;\\n    }\\n\\n    // Returns the amount of the token distributed by this contract.\\n    function amountToClaim() external view override returns (uint256) {\\n        return _amountToClaim;\\n    }\\n\\n    // Returns the merkle root of the merkle tree containing account balances available to claim.\\n    function merkleRoot() external view override returns (bytes32) {\\n        return _merkleRoot;\\n    }\\n\\n    // Returns the unlock block timestamp\\n    function unlockTimestamp() external view override returns (uint256) {\\n        return _unlockTimestamp;\\n    }\\n\\n    // Returns the clawback block timestamp\\n    function clawbackTimestamp() external view override returns (uint256) {\\n        return _clawbackTimestamp;\\n    }\\n\\n    // Returns true if the index has been marked claimed.\\n    function isClaimed(uint256 index, address account) public view override returns (bool) {\\n        return _claimed[_node(index, account)] == true;\\n    }\\n\\n    // Verify the merkle proof.\\n    function verifyMerkleProof(\\n        uint256 index,\\n        address account,\\n        bytes32[] memory merkleProof\\n    )\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        bytes32 node = _node(index, account);\\n        return MerkleProof.verify(merkleProof, _merkleRoot, node);\\n    }\\n\\n    function _claim(\\n        uint256 index,\\n        address account,\\n        bytes32[] memory merkleProof\\n    )\\n        private\\n        notClaimed(index, account)\\n        validProof(index, account, merkleProof)\\n    {\\n        // Mark it claimed and send the token.\\n        _setClaimed(index, account);\\n        emit Claimed(index, account);\\n\\n        bool result = IERC20(_token).transfer(account, _amountToClaim);\\n        if (!result) revert ClaimFailed();\\n    }\\n\\n    function _setClaimed(uint256 index, address account) private {\\n        _claimed[_node(index, account)] = true;\\n    }\\n\\n    function _node(uint256 index, address account) private pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(index, account));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n        return computedHash;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMerkleDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.7;\\n\\n// Allows anyone to claim a token if they exist in a merkle root.\\ninterface IMerkleDistributor {\\n    // This event is triggered whenever a call to #claim succeeds.\\n    event Claimed(uint256 index, address account);\\n\\n    // This event is triggered whenever a call to #clawback succeeds\\n    event Clawback();\\n\\n    // Claim the given amount of the token to self. Reverts if the inputs are invalid.\\n    function claim(\\n        uint256 index,\\n        bytes32[] calldata merkleProof\\n    )\\n        external;\\n    \\n    // Claim the given amount of the token to the given address. Reverts if the inputs are invalid.\\n    function claimByGovernance(\\n        uint256 index,\\n        address account,\\n        bytes32[] calldata merkleProof\\n    ) external;\\n\\n    // Clawback the given amount of the token to the given address.\\n    function clawback() external;\\n\\n    // Returns the address of the token distributed by this contract.\\n    function token() external view returns (address);\\n\\n    // Returns the amount of the token distributed by this contract.\\n    function amountToClaim() external view returns (uint256);\\n\\n    // Returns the merkle root of the merkle tree containing account balances available to claim.\\n    function merkleRoot() external view returns (bytes32);\\n\\n    // Returns true if the index has been marked claimed.\\n    function isClaimed(uint256 index, address account) external view returns (bool);\\n\\n    // Returns the unlock block timestamp\\n    function unlockTimestamp() external view returns (uint256);\\n\\n    // Returns the clawback block timestamp\\n    function clawbackTimestamp() external view returns (uint256);\\n\\n    // Verify the merkle proof.\\n    function verifyMerkleProof(\\n        uint256 index,\\n        address account,\\n        bytes32[] calldata merkleProof\\n    )\\n        external\\n        view\\n        returns (bool);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToClaim_\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"governance_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unlockTimestamp_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"clawbackTimestamp_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ClaimFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ClaimLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ClawbackFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ClawbackLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotGovernance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotGovernanceOrSelf\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Clawback\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"amountToClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claimByGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clawback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clawbackTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyMerkleProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MerkleDistributor","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000019042021329fddcfbea5f934fb5b2670c91f7d2000000000000000000000000000000000000000000000000000000000009896807f8123d54d7d223706d7739938912368d0d5534abe1b845f8a9d004c5a07ee57000000000000000000000000dfe5b72647f738d61323a630ba43e5f22141033900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000061e20e80","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}