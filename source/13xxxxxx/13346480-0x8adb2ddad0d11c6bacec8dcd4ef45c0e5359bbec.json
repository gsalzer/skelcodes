{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity >0.8.0 <0.9.0;\r\n\r\ncontract Forwarder {\r\n\r\n    address payable immutable public destinationAddress;\r\n    event Created(bytes32 salt, address indexed forwarder);\r\n    event Forwarded(address addr, uint256 quantity);\r\n\r\n    constructor(address payable destination) {\r\n        destinationAddress = destination;\r\n        destination.transfer(address(this).balance);\r\n        emit Forwarded(address(this), address(this).balance);\r\n    }\r\n\r\n    // EIP-1167\r\n    function derivate(bytes32 salt) external returns (address result) {\r\n        bytes20 targetBytes = bytes20(address(this));\r\n        assembly {\r\n            let bs := mload(0x40)\r\n            mstore(bs, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(bs, 0x14), targetBytes)\r\n            mstore(add(bs, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n\r\n            let encoded_data := add(0x20, bs) // load initialization code.\r\n            let encoded_size := mload(bs)     // load the init code's length.\r\n\r\n            result := create2(0, bs, 0x37, salt)\r\n        }\r\n\r\n        emit Created(salt, result);\r\n    }\r\n\r\n    // Auto forward all incoming ethers\r\n    receive() external payable {\r\n        flush();\r\n    }\r\n\r\n    // Manually require to forward ethers when the forwarder has been derivated after assets have been received on the contract address\r\n    function flush() public {\r\n        // destinationAddress.transfer(address(this).balance);\r\n        destinationAddress.call{value: address(this).balance}(\"\");\r\n        emit Forwarded(address(this), address(this).balance);\r\n    }\r\n\r\n    // Forward ERC20 tokens from a given contract address\r\n    function flushTokens(address tokenContractAddress) public {\r\n        ERC20Interface instance = ERC20Interface(tokenContractAddress);\r\n        uint256 forwarderBalance = instance.balanceOf(address(this));\r\n        if (forwarderBalance == 0) {\r\n            return;\r\n        }\r\n\r\n        instance.transfer(destinationAddress, forwarderBalance);\r\n        emit Forwarded(tokenContractAddress, forwarderBalance);\r\n    }\r\n\r\n    // Forward only a given quantity of ERC20 tokens from a the provided contract address \r\n    function flushTokensQuantity(address tokenContractAddress, uint256 quantity) public {\r\n        ERC20Interface instance = ERC20Interface(tokenContractAddress);\r\n        instance.transfer(destinationAddress, quantity);\r\n        emit Forwarded(tokenContractAddress, quantity);\r\n    }\r\n\r\n    // Forward all ethers present on this contract and all ERC20 tokens from a given contract address\r\n    function flushTokensAndBalance(address tokenContractAddress) public {\r\n        flush();\r\n        flushTokens(tokenContractAddress);\r\n    }\r\n\r\n    function requireCall(address dest, bytes memory data) public returns (bool, bytes memory) {\r\n        require(msg.sender == destinationAddress);\r\n        return dest.call(data);\r\n    }\r\n}\r\n\r\ninterface ERC20Interface {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"Forwarded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"derivate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destinationAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flush\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"}],\"name\":\"flushTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"}],\"name\":\"flushTokensAndBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"flushTokensQuantity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dest\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"requireCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Forwarder","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000097603ffc856715c3af8de998259e71f8693c5ae1","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://52987616643fa5a99157ba17b13e6c18344689738d834c9c0d6b38264e943fa4"}]}