{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/facets/ConcurrentCanExecFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport {BFacetOwner} from \\\"./base/BFacetOwner.sol\\\";\\nimport {LibConcurrentCanExec} from \\\"../libraries/LibConcurrentCanExec.sol\\\";\\n\\ncontract ConcurrentCanExecFacet is BFacetOwner {\\n    function setSlotLength(uint256 _slotLength) external onlyOwner {\\n        LibConcurrentCanExec.setSlotLength(_slotLength);\\n    }\\n\\n    function slotLength() external view returns (uint256) {\\n        return LibConcurrentCanExec.slotLength();\\n    }\\n\\n    function concurrentCanExec(uint256 _buffer) external view returns (bool) {\\n        return LibConcurrentCanExec.concurrentCanExec(_buffer);\\n    }\\n\\n    function getCurrentExecutorIndex()\\n        external\\n        view\\n        returns (uint256 executorIndex, uint256 remainingBlocksInSlot)\\n    {\\n        return\\n            LibConcurrentCanExec.getCurrentExecutorIndexAtBlock(block.number);\\n    }\\n\\n    function currentExecutor()\\n        external\\n        view\\n        returns (\\n            address executor,\\n            uint256 executorIndex,\\n            uint256 remainingBlocksInSlot\\n        )\\n    {\\n        return LibConcurrentCanExec.currentExecutor();\\n    }\\n\\n    function mySlotStatus(uint256 _buffer)\\n        external\\n        view\\n        returns (LibConcurrentCanExec.SlotStatus)\\n    {\\n        return LibConcurrentCanExec.mySlotStatus(_buffer);\\n    }\\n\\n    function calcExecutorIndex(\\n        uint256 _currentBlock,\\n        uint256 _blocksPerSlot,\\n        uint256 _numberOfExecutors\\n    )\\n        external\\n        pure\\n        returns (uint256 executorIndex, uint256 remainingBlocksInSlot)\\n    {\\n        return\\n            LibConcurrentCanExec.calcExecutorIndex(\\n                _currentBlock,\\n                _blocksPerSlot,\\n                _numberOfExecutors\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/facets/base/BFacetOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport {LibDiamond} from \\\"../../libraries/standard/LibDiamond.sol\\\";\\n\\nabstract contract BFacetOwner {\\n    modifier onlyOwner() {\\n        LibDiamond.enforceIsContractOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/interfaces/standard/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/libraries/LibConcurrentCanExec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport {LibExecutor} from \\\"./LibExecutor.sol\\\";\\n\\nlibrary LibConcurrentCanExec {\\n    using LibExecutor for address;\\n\\n    enum SlotStatus {\\n        Open,\\n        Closing,\\n        Closed\\n    }\\n\\n    struct ConcurrentExecStorage {\\n        uint256 slotLength;\\n    }\\n\\n    bytes32 private constant _CONCURRENT_EXEC_STORAGE_POSITION =\\n        keccak256(\\\"gelato.diamond.concurrentexec.storage\\\");\\n\\n    function setSlotLength(uint256 _slotLength) internal {\\n        concurrentExecStorage().slotLength = _slotLength;\\n    }\\n\\n    function slotLength() internal view returns (uint256) {\\n        return concurrentExecStorage().slotLength;\\n    }\\n\\n    function concurrentCanExec(uint256 _buffer) internal view returns (bool) {\\n        return\\n            msg.sender.canExec() && LibExecutor.numberOfExecutors() == 1\\n                ? true\\n                : mySlotStatus(_buffer) == LibConcurrentCanExec.SlotStatus.Open;\\n    }\\n\\n    function getCurrentExecutorIndexAtBlock(uint256 _currentBlock)\\n        internal\\n        view\\n        returns (uint256 executorIndex, uint256 remainingBlocksInSlot)\\n    {\\n        uint256 numberOfExecutors = LibExecutor.numberOfExecutors();\\n        uint256 currentSlotLength = slotLength();\\n        require(\\n            numberOfExecutors > 0,\\n            \\\"LibConcurrentCanExec.getCurrentExecutorIndex: 0 executors\\\"\\n        );\\n        require(\\n            currentSlotLength > 0,\\n            \\\"LibConcurrentCanExec.getCurrentExecutorIndex: 0 slotLength\\\"\\n        );\\n\\n        return\\n            calcExecutorIndex(\\n                _currentBlock,\\n                currentSlotLength,\\n                numberOfExecutors\\n            );\\n    }\\n\\n    function currentExecutor()\\n        internal\\n        view\\n        returns (\\n            address executor,\\n            uint256 executorIndex,\\n            uint256 remainingBlocksInSlot\\n        )\\n    {\\n        (executorIndex, remainingBlocksInSlot) = getCurrentExecutorIndexAtBlock(\\n            block.number\\n        );\\n        executor = LibExecutor.executorAt(executorIndex);\\n    }\\n\\n    function mySlotStatus(uint256 _buffer) internal view returns (SlotStatus) {\\n        require(\\n            _buffer < slotLength(),\\n            \\\"LibConcurrentCanExec.mySlotStatus: invalid _buffer\\\"\\n        );\\n\\n        (\\n            uint256 executorIndex,\\n            uint256 remainingBlocksInSlot\\n        ) = getCurrentExecutorIndexAtBlock(block.number);\\n\\n        address executor = LibExecutor.executorAt(executorIndex);\\n\\n        // The next executor should be able to exec if the previous executor's\\n        // slot has 0 remaining blocks\\n        if (msg.sender != executor) {\\n            if (remainingBlocksInSlot == 0) {\\n                (uint256 nextExecutorIndex, ) = getCurrentExecutorIndexAtBlock(\\n                    block.number + 1\\n                );\\n\\n                address nextExecutor = LibExecutor.executorAt(\\n                    nextExecutorIndex\\n                );\\n\\n                if (msg.sender == nextExecutor) return SlotStatus.Open;\\n                return SlotStatus.Closed; // msg.sender not nextExecutor\\n            }\\n\\n            // Current Executor has remaining blocks in slot\\n            return SlotStatus.Closed;\\n        }\\n\\n        return\\n            remainingBlocksInSlot <= _buffer\\n                ? SlotStatus.Closing\\n                : SlotStatus.Open;\\n    }\\n\\n    // Example: blocksPerSlot = 3, numberOfExecutors = 2\\n    //\\n    // Block number          0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | ...\\n    //                      ---------------------------------------------\\n    // slotIndex             0 | 0 | 0 | 1 | 1 | 1 | 2 | 2 | 2 | 3 | ...\\n    //                      ---------------------------------------------\\n    // executorIndex         0 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 1 | ...\\n    // remainingBlocksInSlot 2 | 1 | 0 | 2 | 1 | 0 | 2 | 1 | 0 | 2 | ...\\n    //\\n\\n    function calcExecutorIndex(\\n        uint256 _currentBlock,\\n        uint256 _blocksPerSlot,\\n        uint256 _numberOfExecutors\\n    )\\n        internal\\n        pure\\n        returns (uint256 executorIndex, uint256 remainingBlocksInSlot)\\n    {\\n        uint256 slotIndex = _currentBlock / _blocksPerSlot;\\n        return (\\n            slotIndex % _numberOfExecutors,\\n            (slotIndex + 1) * _blocksPerSlot - _currentBlock - 1\\n        );\\n    }\\n\\n    function concurrentExecStorage()\\n        internal\\n        pure\\n        returns (ConcurrentExecStorage storage ces)\\n    {\\n        bytes32 position = _CONCURRENT_EXEC_STORAGE_POSITION;\\n        assembly {\\n            ces.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/libraries/LibExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport {\\n    EnumerableSet\\n} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\nlibrary LibExecutor {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    struct ExecutorStorage {\\n        EnumerableSet.AddressSet executors;\\n        uint256 gasMargin;\\n        EnumerableSet.AddressSet bundleExecutors;\\n    }\\n\\n    bytes32 private constant _EXECUTOR_STORAGE_POSITION =\\n        keccak256(\\\"gelato.diamond.executor.storage\\\");\\n\\n    function addExecutor(address _executor) internal returns (bool) {\\n        return executorStorage().executors.add(_executor);\\n    }\\n\\n    function addBundleExecutor(address _bundleExecutor)\\n        internal\\n        returns (bool)\\n    {\\n        return executorStorage().bundleExecutors.add(_bundleExecutor);\\n    }\\n\\n    function removeExecutor(address _executor) internal returns (bool) {\\n        return executorStorage().executors.remove(_executor);\\n    }\\n\\n    function removeBundleExecutor(address _bundleExecutor)\\n        internal\\n        returns (bool)\\n    {\\n        return executorStorage().bundleExecutors.remove(_bundleExecutor);\\n    }\\n\\n    function setGasMargin(uint256 _gasMargin) internal {\\n        executorStorage().gasMargin = _gasMargin;\\n    }\\n\\n    function canExec(address _executor) internal view returns (bool) {\\n        return isExecutor(_executor);\\n    }\\n\\n    function isExecutor(address _executor) internal view returns (bool) {\\n        return executorStorage().executors.contains(_executor);\\n    }\\n\\n    function isBundleExecutor(address _bundleExecutor)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return executorStorage().bundleExecutors.contains(_bundleExecutor);\\n    }\\n\\n    function executorAt(uint256 _index) internal view returns (address) {\\n        return executorStorage().executors.at(_index);\\n    }\\n\\n    function bundleExecutorAt(uint256 _index) internal view returns (address) {\\n        return executorStorage().bundleExecutors.at(_index);\\n    }\\n\\n    function executors() internal view returns (address[] memory executors_) {\\n        uint256 length = numberOfExecutors();\\n        executors_ = new address[](length);\\n        for (uint256 i; i < length; i++) executors_[i] = executorAt(i);\\n    }\\n\\n    function bundleExecutors()\\n        internal\\n        view\\n        returns (address[] memory bundleExecutors_)\\n    {\\n        uint256 length = numberOfBundleExecutors();\\n        bundleExecutors_ = new address[](length);\\n        for (uint256 i; i < length; i++)\\n            bundleExecutors_[i] = bundleExecutorAt(i);\\n    }\\n\\n    function numberOfExecutors() internal view returns (uint256) {\\n        return executorStorage().executors.length();\\n    }\\n\\n    function numberOfBundleExecutors() internal view returns (uint256) {\\n        return executorStorage().bundleExecutors.length();\\n    }\\n\\n    function gasMargin() internal view returns (uint256) {\\n        return executorStorage().gasMargin;\\n    }\\n\\n    function executorStorage()\\n        internal\\n        pure\\n        returns (ExecutorStorage storage es)\\n    {\\n        bytes32 position = _EXECUTOR_STORAGE_POSITION;\\n        assembly {\\n            es.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/diamond/libraries/standard/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n// solhint-disable max-line-length\\n// https://github.com/mudgen/diamond-3/blob/b009cd08b7822bad727bbcc47aa1b50d8b50f7f0/contracts/libraries/LibDiamond.sol#L1\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport \\\"../../interfaces/standard/IDiamondCut.sol\\\";\\n\\n// Custom due to incorrect string casting (non UTF-8 formatted)\\nimport {GelatoBytes} from \\\"../../../lib/GelatoBytes.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function isContractOwner(address _guy) internal view returns (bool) {\\n        return _guy == contractOwner();\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(\\n            msg.sender == diamondStorage().contractOwner,\\n            \\\"LibDiamond: Must be contract owner\\\"\\n        );\\n    }\\n\\n    event DiamondCut(\\n        IDiamondCut.FacetCut[] _diamondCut,\\n        address _init,\\n        bytes _calldata\\n    );\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (\\n            uint256 facetIndex;\\n            facetIndex < _diamondCut.length;\\n            facetIndex++\\n        ) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(\\n            _functionSelectors.length > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        DiamondStorage storage ds = diamondStorage();\\n        // uint16 selectorCount = uint16(diamondStorage().selectors.length);\\n        require(\\n            _facetAddress != address(0),\\n            \\\"LibDiamondCut: Add facet can't be address(0)\\\"\\n        );\\n        uint16 selectorPosition = uint16(\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n        );\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            enforceHasContractCode(\\n                _facetAddress,\\n                \\\"LibDiamondCut: New facet has no code\\\"\\n            );\\n            ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition = uint16(ds.facetAddresses.length);\\n            ds.facetAddresses.push(_facetAddress);\\n        }\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            require(\\n                oldFacetAddress == address(0),\\n                \\\"LibDiamondCut: Can't add function that already exists\\\"\\n            );\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\\n                selector\\n            );\\n            ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress = _facetAddress;\\n            ds\\n                .selectorToFacetAndPosition[selector]\\n                .functionSelectorPosition = selectorPosition;\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(\\n            _functionSelectors.length > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        DiamondStorage storage ds = diamondStorage();\\n        require(\\n            _facetAddress != address(0),\\n            \\\"LibDiamondCut: Add facet can't be address(0)\\\"\\n        );\\n        uint16 selectorPosition = uint16(\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n        );\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            enforceHasContractCode(\\n                _facetAddress,\\n                \\\"LibDiamondCut: New facet has no code\\\"\\n            );\\n            ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition = uint16(ds.facetAddresses.length);\\n            ds.facetAddresses.push(_facetAddress);\\n        }\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            require(\\n                oldFacetAddress != _facetAddress,\\n                \\\"LibDiamondCut: Can't replace function with same function\\\"\\n            );\\n            removeFunction(oldFacetAddress, selector);\\n            // add function\\n            ds\\n                .selectorToFacetAndPosition[selector]\\n                .functionSelectorPosition = selectorPosition;\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\\n                selector\\n            );\\n            ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress = _facetAddress;\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(\\n            _functionSelectors.length > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(\\n            _facetAddress == address(0),\\n            \\\"LibDiamondCut: Remove facet address must be address(0)\\\"\\n        );\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            removeFunction(oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function removeFunction(address _facetAddress, bytes4 _selector) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(\\n            _facetAddress != address(0),\\n            \\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\n        );\\n        // an immutable function is a function defined directly in a diamond\\n        require(\\n            _facetAddress != address(this),\\n            \\\"LibDiamondCut: Can't remove immutable function\\\"\\n        );\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds\\n            .selectorToFacetAndPosition[_selector]\\n            .functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds\\n            .facetFunctionSelectors[_facetAddress]\\n            .functionSelectors\\n            .length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\\n                    selectorPosition\\n                ] = lastSelector;\\n            ds\\n                .selectorToFacetAndPosition[lastSelector]\\n                .functionSelectorPosition = uint16(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[\\n                    lastFacetAddressPosition\\n                ];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds\\n                    .facetFunctionSelectors[lastFacetAddress]\\n                    .facetAddressPosition = uint16(facetAddressPosition);\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata)\\n        internal\\n    {\\n        if (_init == address(0)) {\\n            require(\\n                _calldata.length == 0,\\n                \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\"\\n            );\\n        } else {\\n            require(\\n                _calldata.length > 0,\\n                \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\"\\n            );\\n            if (_init != address(this)) {\\n                enforceHasContractCode(\\n                    _init,\\n                    \\\"LibDiamondCut: _init address has no code\\\"\\n                );\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    GelatoBytes.revertWithError(error, \\\"LibDiamondCut:_init:\\\");\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(\\n        address _contract,\\n        string memory _errorMessage\\n    ) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/GelatoBytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.10;\\n\\nlibrary GelatoBytes {\\n    function calldataSliceSelector(bytes calldata _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function memorySliceSelector(bytes memory _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function revertWithError(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\\n            } else {\\n                revert(\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"))\\n                );\\n            }\\n        } else {\\n            revert(\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"))\\n            );\\n        }\\n    }\\n\\n    function returnError(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                return string(abi.encodePacked(_tracingInfo, string(_bytes)));\\n            } else {\\n                return\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"));\\n            }\\n        } else {\\n            return\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"));\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currentBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blocksPerSlot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numberOfExecutors\",\"type\":\"uint256\"}],\"name\":\"calcExecutorIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"executorIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingBlocksInSlot\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buffer\",\"type\":\"uint256\"}],\"name\":\"concurrentCanExec\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"executorIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingBlocksInSlot\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentExecutorIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"executorIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingBlocksInSlot\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buffer\",\"type\":\"uint256\"}],\"name\":\"mySlotStatus\",\"outputs\":[{\"internalType\":\"enum LibConcurrentCanExec.SlotStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slotLength\",\"type\":\"uint256\"}],\"name\":\"setSlotLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slotLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ConcurrentCanExecFacet","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}