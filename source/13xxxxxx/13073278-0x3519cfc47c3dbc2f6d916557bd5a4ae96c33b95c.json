{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AutoGamma.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport {GammaOperator} from \\\"./GammaOperator.sol\\\";\\nimport {IAutoGamma} from \\\"./interfaces/IAutoGamma.sol\\\";\\nimport {IUniswapRouter} from \\\"./interfaces/IUniswapRouter.sol\\\";\\nimport {IPokeMe} from \\\"./interfaces/IPokeMe.sol\\\";\\nimport {ITaskTreasury} from \\\"./interfaces/ITaskTreasury.sol\\\";\\nimport {IResolver} from \\\"./interfaces/IResolver.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @author Willy Shen\\n/// @title Opyn Gamma Automatic Redeemer\\n/// @notice An automatic redeemer for Gamma otoken holders and writers\\ncontract AutoGamma is IAutoGamma, GammaOperator {\\n    using SafeERC20 for IERC20;\\n\\n    Order[] public orders;\\n\\n    IUniswapRouter public uniRouter;\\n    IPokeMe public automator;\\n    ITaskTreasury public automatorTreasury;\\n    bool public isAutomatorEnabled;\\n\\n    mapping(address => mapping(address => bool)) public uniPair;\\n\\n    // fee in 1/10.000: 1% = 100, 0.01% = 1\\n    uint256 public redeemFee = 100;\\n    uint256 public settleFee = 15;\\n\\n    /**\\n     * @notice only automator or owner\\n     */\\n    modifier onlyAuthorized() {\\n        require(\\n            msg.sender == address(automator) || msg.sender == owner(),\\n            \\\"AutoGamma::onlyAuthorized: Only automator or owner\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(\\n        address _gammaAddressBook,\\n        address _uniRouter,\\n        address _automator,\\n        address _automatorTreasury\\n    ) GammaOperator(_gammaAddressBook) {\\n        uniRouter = IUniswapRouter(_uniRouter);\\n        automator = IPokeMe(_automator);\\n        automatorTreasury = ITaskTreasury(_automatorTreasury);\\n        isAutomatorEnabled = false;\\n    }\\n\\n    /**\\n     * @notice tell automator to start executing orders\\n     * @param _resolver the address of automation resolver\\n     * @dev automator will start calling resolver to fetch and execute processable orders\\n     */\\n    function startAutomator(address _resolver) public onlyOwner {\\n        require(\\n            !isAutomatorEnabled,\\n            \\\"AutoGamma::startAutomator: already started\\\"\\n        );\\n        isAutomatorEnabled = true;\\n        automator.createTask(\\n            address(this),\\n            bytes4(0x895f7952), //processOrders selector\\n            _resolver,\\n            abi.encodeWithSelector(IResolver.getProcessableOrders.selector)\\n        );\\n    }\\n\\n    /**\\n     * @notice tell automator to stop executing orders\\n     */\\n    function stopAutomator() public onlyOwner {\\n        require(\\n            isAutomatorEnabled,\\n            \\\"AutoGamma::stopAutomator: already stopped\\\"\\n        );\\n        isAutomatorEnabled = false;\\n        automator.cancelTask(\\n            automator.getTaskId(\\n                address(this),\\n                address(this),\\n                bytes4(0x895f7952) //processOrders selector\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice create automation order\\n     * @param _otoken the address of otoken (only holders)\\n     * @param _amount amount of otoken (only holders)\\n     * @param _vaultId the id of specific vault to settle (only writers)\\n     * @param _toToken token address for custom token settlement\\n     */\\n    function createOrder(\\n        address _otoken,\\n        uint256 _amount,\\n        uint256 _vaultId,\\n        address _toToken\\n    ) public override {\\n        uint256 fee;\\n        bool isSeller;\\n        if (_otoken == address(0)) {\\n            require(\\n                _amount == 0,\\n                \\\"AutoGamma::createOrder: Amount must be 0 when creating settlement order\\\"\\n            );\\n            fee = settleFee;\\n            isSeller = true;\\n        } else {\\n            require(\\n                isWhitelistedOtoken(_otoken),\\n                \\\"AutoGamma::createOrder: Otoken not whitelisted\\\"\\n            );\\n            fee = redeemFee;\\n        }\\n\\n        if (_toToken != address(0)) {\\n            address payoutToken;\\n            if (isSeller) {\\n                address otoken = getVaultOtoken(msg.sender, _vaultId);\\n                payoutToken = getOtokenCollateral(otoken);\\n            } else {\\n                payoutToken = getOtokenCollateral(_otoken);\\n            }\\n            require(\\n                payoutToken != _toToken,\\n                \\\"AutoGamma::createOrder: same settlement token and collateral\\\"\\n            );\\n            require(\\n                uniPair[payoutToken][_toToken],\\n                \\\"AutoGamma::createOrder: settlement token not allowed\\\"\\n            );\\n        }\\n\\n        uint256 orderId = orders.length;\\n\\n        Order memory order;\\n        order.owner = msg.sender;\\n        order.otoken = _otoken;\\n        order.amount = _amount;\\n        order.vaultId = _vaultId;\\n        order.isSeller = isSeller;\\n        order.fee = fee;\\n        order.toToken = _toToken;\\n        orders.push(order);\\n\\n        emit OrderCreated(orderId, msg.sender, _otoken);\\n    }\\n\\n    /**\\n     * @notice cancel automation order\\n     * @param _orderId the id of specific order to be cancelled\\n     */\\n    function cancelOrder(uint256 _orderId) public override {\\n        Order storage order = orders[_orderId];\\n        require(\\n            order.owner == msg.sender,\\n            \\\"AutoGamma::cancelOrder: Sender is not order owner\\\"\\n        );\\n        require(\\n            !order.finished,\\n            \\\"AutoGamma::cancelOrder: Order is already finished\\\"\\n        );\\n\\n        order.finished = true;\\n        emit OrderFinished(_orderId, true);\\n    }\\n\\n    /**\\n     * @notice check if processing order is profitable\\n     * @param _orderId the id of specific order to be processed\\n     * @return true if settling vault / redeeming returns more than 0 amount\\n     */\\n    function shouldProcessOrder(uint256 _orderId)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        Order memory order = orders[_orderId];\\n        if (order.finished) return false;\\n\\n        if (order.isSeller) {\\n            bool shouldSettle = shouldSettleVault(order.owner, order.vaultId);\\n            if (!shouldSettle) return false;\\n        } else {\\n            bool shouldRedeem = shouldRedeemOtoken(\\n                order.owner,\\n                order.otoken,\\n                order.amount\\n            );\\n            if (!shouldRedeem) return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice process an order\\n     * @dev only automator allowed\\n     * @param _orderId the id of specific order to process\\n     */\\n    function processOrder(uint256 _orderId, ProcessOrderArgs calldata orderArgs)\\n        public\\n        override\\n        onlyAuthorized\\n    {\\n        Order storage order = orders[_orderId];\\n        require(\\n            shouldProcessOrder(_orderId),\\n            \\\"AutoGamma::processOrder: Order should not be processed\\\"\\n        );\\n        order.finished = true;\\n\\n        address payoutToken;\\n        uint256 payoutAmount;\\n        if (order.isSeller) {\\n            (payoutToken, payoutAmount) = settleVault(\\n                order.owner,\\n                order.vaultId\\n            );\\n        } else {\\n            (payoutToken, payoutAmount) = redeemOtoken(\\n                order.owner,\\n                order.otoken,\\n                order.amount\\n            );\\n        }\\n\\n        // minus fee\\n        payoutAmount = payoutAmount - ((order.fee * payoutAmount) / 10000);\\n\\n        if (order.toToken == address(0)) {\\n            IERC20(payoutToken).safeTransfer(order.owner, payoutAmount);\\n        } else {\\n            require(\\n                payoutToken == orderArgs.swapPath[0] &&\\n                    order.toToken == orderArgs.swapPath[1],\\n                \\\"AutoGamma::processOrder: Invalid swap path\\\"\\n            );\\n            require(\\n                uniPair[payoutToken][order.toToken],\\n                \\\"AutoGamma::processOrder: token pair not allowed\\\"\\n            );\\n\\n            IERC20(payoutToken).approve(address(uniRouter), payoutAmount);\\n            uint256[] memory amounts = swap(\\n                payoutAmount,\\n                orderArgs.swapAmountOutMin,\\n                orderArgs.swapPath\\n            );\\n            IERC20(order.toToken).safeTransfer(order.owner, amounts[1]);\\n        }\\n\\n        emit OrderFinished(_orderId, false);\\n    }\\n\\n    /**\\n     * @notice process multiple orders\\n     * @param _orderIds array of order ids to process\\n     */\\n    function processOrders(\\n        uint256[] calldata _orderIds,\\n        ProcessOrderArgs[] calldata _orderArgs\\n    ) public override {\\n        require(\\n            _orderIds.length == _orderArgs.length,\\n            \\\"AutoGamma::processOrders: Params lengths must be same\\\"\\n        );\\n        for (uint256 i = 0; i < _orderIds.length; i++) {\\n            processOrder(_orderIds[i], _orderArgs[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice withdraw funds from automator\\n     * @param _token address of token to withdraw\\n     * @param _amount amount of token to withdraw\\n     */\\n    function withdrawFund(address _token, uint256 _amount) public onlyOwner {\\n        automatorTreasury.withdrawFunds(payable(this), _token, _amount);\\n    }\\n\\n    /**\\n     * @notice uniswap token swap\\n     * @param _amountIn amount of token to swap\\n     * @param _amountOutMin minimal amount of token to receive\\n     * @param _path token pair to swap\\n     * @return amounts amount of each tokens being swapped\\n     */\\n    function swap(\\n        uint256 _amountIn,\\n        uint256 _amountOutMin,\\n        address[] calldata _path\\n    ) internal returns (uint256[] memory amounts) {\\n        return\\n            IUniswapRouter(uniRouter).swapExactTokensForTokens(\\n                _amountIn,\\n                _amountOutMin,\\n                _path,\\n                address(this),\\n                block.timestamp\\n            );\\n    }\\n\\n    /**\\n     * @notice allow token pair for swap\\n     * @param _token0 first token\\n     * @param _token1 second token\\n     */\\n    function allowPair(address _token0, address _token1) public onlyOwner {\\n        require(\\n            !uniPair[_token0][_token1],\\n            \\\"AutoGamma::allowPair: already allowed\\\"\\n        );\\n        uniPair[_token0][_token1] = true;\\n        uniPair[_token1][_token0] = true;\\n    }\\n\\n    /**\\n     * @notice disallow token pair for swap\\n     * @param _token0 first token\\n     * @param _token1 second token\\n     */\\n    function disallowPair(address _token0, address _token1) public onlyOwner {\\n        require(\\n            uniPair[_token0][_token1],\\n            \\\"AutoGamma::allowPair: already disallowed\\\"\\n        );\\n        uniPair[_token0][_token1] = false;\\n        uniPair[_token1][_token0] = false;\\n    }\\n\\n    function setUniRouter(address _uniRouter) public onlyOwner {\\n        uniRouter = IUniswapRouter(_uniRouter);\\n    }\\n\\n    function setAutomator(address _automator) public onlyOwner {\\n        automator = IPokeMe(_automator);\\n    }\\n\\n    function setAutomatorTreasury(address _automatorTreasury) public onlyOwner {\\n        automatorTreasury = ITaskTreasury(_automatorTreasury);\\n    }\\n\\n    function setRedeemFee(uint256 _redeemFee) public onlyOwner {\\n        redeemFee = _redeemFee;\\n    }\\n\\n    function setSettleFee(uint256 _settleFee) public onlyOwner {\\n        settleFee = _settleFee;\\n    }\\n\\n    function getOrdersLength() public view override returns (uint256) {\\n        return orders.length;\\n    }\\n\\n    function getOrders() public view override returns (Order[] memory) {\\n        return orders;\\n    }\\n\\n    function getOrder(uint256 _orderId)\\n        public\\n        view\\n        override\\n        returns (Order memory)\\n    {\\n        return orders[_orderId];\\n    }\\n\\n    function isPairAllowed(address _token0, address _token1)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return uniPair[_token0][_token1];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GammaOperator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport {IAddressBook} from \\\"./interfaces/IAddressBook.sol\\\";\\nimport {IGammaController} from \\\"./interfaces/IGammaController.sol\\\";\\nimport {IWhitelist} from \\\"./interfaces/IWhitelist.sol\\\";\\nimport {IMarginCalculator} from \\\"./interfaces/IMarginCalculator.sol\\\";\\nimport {Actions} from \\\"./external/OpynActions.sol\\\";\\nimport {MarginVault} from \\\"./external/OpynVault.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IOtoken} from \\\"./interfaces/IOtoken.sol\\\";\\n\\n/// @author Willy Shen\\n/// @title Gamma Operator\\n/// @notice Opyn Gamma protocol adapter for redeeming otokens and settling vaults\\ncontract GammaOperator is Ownable {\\n    using SafeERC20 for IERC20;\\n\\n    // Gamma Protocol contracts\\n    IAddressBook public addressBook;\\n    IGammaController public controller;\\n    IWhitelist public whitelist;\\n    IMarginCalculator public calculator;\\n\\n    /**\\n     * @dev fetch Gamma contracts from address book\\n     * @param _addressBook Gamma Address Book address\\n     */\\n    constructor(address _addressBook) {\\n        setAddressBook(_addressBook);\\n        refreshConfig();\\n    }\\n\\n    /**\\n     * @notice redeem otoken on behalf of owner\\n     * @param _owner owner address\\n     * @param _otoken otoken address\\n     * @param _amount amount of otoken\\n     */\\n    function redeemOtoken(\\n        address _owner,\\n        address _otoken,\\n        uint256 _amount\\n    ) internal returns (address payoutToken, uint256 payoutAmount) {\\n        uint256 actualAmount = getRedeemableAmount(_owner, _otoken, _amount);\\n\\n        IERC20(_otoken).safeTransferFrom(_owner, address(this), actualAmount);\\n\\n        Actions.ActionArgs memory action;\\n        action.actionType = Actions.ActionType.Redeem;\\n        action.secondAddress = address(this);\\n        action.asset = _otoken;\\n        action.amount = _amount;\\n\\n        Actions.ActionArgs[] memory actions = new Actions.ActionArgs[](1);\\n        actions[0] = action;\\n\\n        payoutToken = IOtoken(_otoken).collateralAsset();\\n\\n        uint256 startAmount = IERC20(payoutToken).balanceOf(address(this));\\n        controller.operate(actions);\\n        uint256 endAmount = IERC20(payoutToken).balanceOf(address(this));\\n\\n        payoutAmount = endAmount - startAmount;\\n    }\\n\\n    /**\\n     * @notice settle vault on behalf of owner\\n     * @param _owner owner address\\n     * @param _vaultId vaultId to settle\\n     */\\n    function settleVault(address _owner, uint256 _vaultId)\\n        internal\\n        returns (address payoutToken, uint256 payoutAmount)\\n    {\\n        Actions.ActionArgs memory action;\\n        action.actionType = Actions.ActionType.SettleVault;\\n        action.owner = _owner;\\n        action.vaultId = _vaultId;\\n        action.secondAddress = address(this);\\n\\n        Actions.ActionArgs[] memory actions = new Actions.ActionArgs[](1);\\n        actions[0] = action;\\n\\n        MarginVault.Vault memory vault = getVault(_owner, _vaultId);\\n        address otoken = getVaultOtokenByVault(vault);\\n        payoutToken = IOtoken(otoken).collateralAsset();\\n\\n        uint256 startAmount = IERC20(payoutToken).balanceOf(address(this));\\n        controller.operate(actions);\\n        uint256 endAmount = IERC20(payoutToken).balanceOf(address(this));\\n\\n        payoutAmount = endAmount - startAmount;\\n    }\\n\\n    /**\\n     * @notice return if otoken should be redeemed\\n     * @param _owner owner address\\n     * @param _otoken otoken address\\n     * @param _amount amount of otoken\\n     * @return true if otoken has expired and payout is greater than zero\\n     */\\n    function shouldRedeemOtoken(\\n        address _owner,\\n        address _otoken,\\n        uint256 _amount\\n    ) public view returns (bool) {\\n        uint256 actualAmount = getRedeemableAmount(_owner, _otoken, _amount);\\n        try this.getRedeemPayout(_otoken, actualAmount) returns (\\n            uint256 payout\\n        ) {\\n            if (payout == 0) return false;\\n        } catch {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice return if vault should be settled\\n     * @param _owner owner address\\n     * @param _vaultId vaultId to settle\\n     * @return true if vault can be settled, contract is operator of owner,\\n     *          and excess collateral is greater than zero\\n     */\\n    function shouldSettleVault(address _owner, uint256 _vaultId)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        (\\n            MarginVault.Vault memory vault,\\n            uint256 typeVault,\\n\\n        ) = getVaultWithDetails(_owner, _vaultId);\\n\\n        (uint256 payout, bool isValidVault) = getExcessCollateral(\\n            vault,\\n            typeVault\\n        );\\n        if (!isValidVault || payout == 0) return false;\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice set Gamma Address Book\\n     * @param _address Address Book address\\n     */\\n    function setAddressBook(address _address) public onlyOwner {\\n        require(\\n            _address != address(0),\\n            \\\"GammaOperator::setAddressBook: Address must not be zero\\\"\\n        );\\n        addressBook = IAddressBook(_address);\\n    }\\n\\n    /**\\n     * @notice transfer operator profit\\n     * @param _token address token to transfer\\n     * @param _amount amount of token to transfer\\n     * @param _to transfer destination\\n     */\\n    function harvest(\\n        address _token,\\n        uint256 _amount,\\n        address _to\\n    ) public onlyOwner {\\n        if (_token == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\\n            (bool success, ) = _to.call{value: _amount}(\\\"\\\");\\n            require(success, \\\"GammaOperator::harvest: ETH transfer failed\\\");\\n        } else {\\n            IERC20(_token).safeTransfer(_to, _amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice refresh Gamma contracts' addresses\\n     */\\n    function refreshConfig() public {\\n        address _controller = addressBook.getController();\\n        controller = IGammaController(_controller);\\n\\n        address _whitelist = addressBook.getWhitelist();\\n        whitelist = IWhitelist(_whitelist);\\n\\n        address _calculator = addressBook.getMarginCalculator();\\n        calculator = IMarginCalculator(_calculator);\\n    }\\n\\n    /**\\n     * @notice get an oToken's payout in the collateral asset\\n     * @param _otoken otoken address\\n     * @param _amount amount of otoken to redeem\\n     */\\n    function getRedeemPayout(address _otoken, uint256 _amount)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return controller.getPayout(_otoken, _amount);\\n    }\\n\\n    /**\\n     * @notice get amount of otoken that can be redeemed\\n     * @param _owner owner address\\n     * @param _otoken otoken address\\n     * @param _amount amount of otoken\\n     * @return amount of otoken the contract can transferFrom owner\\n     */\\n    function getRedeemableAmount(\\n        address _owner,\\n        address _otoken,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        uint256 ownerBalance = IERC20(_otoken).balanceOf(_owner);\\n        uint256 allowance = IERC20(_otoken).allowance(_owner, address(this));\\n        uint256 spendable = min(ownerBalance, allowance);\\n        return min(_amount, spendable);\\n    }\\n\\n    /**\\n     * @notice return details of a specific vault\\n     * @param _owner owner address\\n     * @param _vaultId vaultId\\n     * @return vault struct and vault type and the latest timestamp when the vault was updated\\n     */\\n    function getVaultWithDetails(address _owner, uint256 _vaultId)\\n        public\\n        view\\n        returns (\\n            MarginVault.Vault memory,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return controller.getVaultWithDetails(_owner, _vaultId);\\n    }\\n\\n    /**\\n     * @notice return a specific vault\\n     * @param _owner owner address\\n     * @param _vaultId vaultId\\n     * @return vault struct\\n     */\\n    function getVault(address _owner, uint256 _vaultId)\\n        public\\n        view\\n        returns (MarginVault.Vault memory)\\n    {\\n        return controller.getVault(_owner, _vaultId);\\n    }\\n\\n    /**\\n     * @notice return the otoken from specific vault\\n     * @param _vault id of specific vault\\n     * @return otoken address\\n     */\\n    function getVaultOtokenByVault(MarginVault.Vault memory _vault)\\n        public\\n        pure\\n        returns (address)\\n    {\\n        bool hasShort = isNotEmpty(_vault.shortOtokens);\\n        bool hasLong = isNotEmpty(_vault.longOtokens);\\n\\n        assert(hasShort || hasLong);\\n\\n        return hasShort ? _vault.shortOtokens[0] : _vault.longOtokens[0];\\n    }\\n\\n    /**\\n     * @notice return the otoken from specific vault\\n     * @param _owner owner address\\n     * @param _vaultId id of specific vault\\n     * @return otoken address\\n     */\\n    function getVaultOtoken(address _owner, uint256 _vaultId)\\n        public\\n        view\\n        returns (address)\\n    {\\n        MarginVault.Vault memory vault = getVault(_owner, _vaultId);\\n        return getVaultOtokenByVault(vault);\\n    }\\n\\n    /**\\n     * @notice return the collateral asset of a specific otoken\\n     * @param _otoken otoken address\\n     * @return collateral address\\n     */\\n    function getOtokenCollateral(address _otoken)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return IOtoken(_otoken).collateralAsset();\\n    }\\n\\n    /**\\n     * @notice return amount of collateral that can be removed from a vault\\n     * @param _vault vault struct\\n     * @param _typeVault vault type\\n     * @return excess amount and true if excess is greater than zero\\n     */\\n    function getExcessCollateral(\\n        MarginVault.Vault memory _vault,\\n        uint256 _typeVault\\n    ) public view returns (uint256, bool) {\\n        return calculator.getExcessCollateral(_vault, _typeVault);\\n    }\\n\\n    /**\\n     * @notice return if otoken is ready to be settled\\n     * @param _otoken otoken address\\n     * @return true if settlement is allowed\\n     */\\n    function isSettlementAllowed(address _otoken) public view returns (bool) {\\n        return controller.isSettlementAllowed(_otoken);\\n    }\\n\\n    /**\\n     * @notice return if this contract is Gamma operator of an address\\n     * @param _owner owner address\\n     * @return true if address(this) is operator of _owner\\n     */\\n    function isOperatorOf(address _owner) public view returns (bool) {\\n        return controller.isOperator(_owner, address(this));\\n    }\\n\\n    /**\\n     * @notice return if otoken is whitelisted on Gamma\\n     * @param _otoken otoken address\\n     * @return true if isWhitelistedOtoken returns true for _otoken\\n     */\\n    function isWhitelistedOtoken(address _otoken) public view returns (bool) {\\n        return whitelist.isWhitelistedOtoken(_otoken);\\n    }\\n\\n    /**\\n     * @param _otoken otoken address\\n     * @return true if otoken has expired and settlement is allowed\\n     */\\n    function hasExpiredAndSettlementAllowed(address _otoken)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        bool hasExpired = block.timestamp >= IOtoken(_otoken).expiryTimestamp();\\n        if (!hasExpired) return false;\\n\\n        bool isAllowed = isSettlementAllowed(_otoken);\\n        if (!isAllowed) return false;\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice return if specific vault exist\\n     * @param _owner owner address\\n     * @param _vaultId vaultId to check\\n     * @return true if vault exist for owner\\n     */\\n    function isValidVaultId(address _owner, uint256 _vaultId)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        uint256 vaultCounter = controller.getAccountVaultCounter(_owner);\\n        return ((_vaultId > 0) && (_vaultId <= vaultCounter));\\n    }\\n\\n    /**\\n     * @notice return if array is not empty\\n     * @param _array array of address to check\\n     * @return true if array length is grreater than zero & first element isn't address zero\\n     */\\n    function isNotEmpty(address[] memory _array) private pure returns (bool) {\\n        return (_array.length > 0) && (_array[0] != address(0));\\n    }\\n\\n    /**\\n     * @notice return the lowest number\\n     * @param a first number\\n     * @param b second number\\n     * @return the lowest uint256\\n     */\\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a > b ? b : a;\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAutoGamma.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\ninterface IAutoGamma {\\n    struct Order {\\n        // address of user\\n        address owner;\\n        // address of otoken to redeem\\n        address otoken;\\n        // amount of otoken to redeem\\n        uint256 amount;\\n        // vaultId of vault to settle\\n        uint256 vaultId;\\n        // true if settle vault order, else redeem otoken\\n        bool isSeller;\\n        // convert proceed to token if not address(0)\\n        address toToken;\\n        // fee in 1/10.000\\n        uint256 fee;\\n        // true if order is already processed\\n        bool finished;\\n    }\\n\\n    struct ProcessOrderArgs {\\n        // minimal swap output amount to prevent manipulation\\n        uint256 swapAmountOutMin;\\n        // swap path\\n        address[] swapPath;\\n    }\\n\\n    event OrderCreated(\\n        uint256 indexed orderId,\\n        address indexed owner,\\n        address indexed otoken\\n    );\\n    event OrderFinished(uint256 indexed orderId, bool indexed cancelled);\\n\\n    function createOrder(\\n        address _otoken,\\n        uint256 _amount,\\n        uint256 _vaultId,\\n        address _toToken\\n    ) external;\\n\\n    function cancelOrder(uint256 _orderId) external;\\n\\n    function shouldProcessOrder(uint256 _orderId) external view returns (bool);\\n\\n    function processOrder(uint256 _orderId, ProcessOrderArgs calldata _orderArg)\\n        external;\\n\\n    function processOrders(\\n        uint256[] calldata _orderIds,\\n        ProcessOrderArgs[] calldata _orderArgs\\n    ) external;\\n\\n    function getOrdersLength() external view returns (uint256);\\n\\n    function getOrders() external view returns (Order[] memory);\\n\\n    function getOrder(uint256 _orderId) external view returns (Order memory);\\n\\n    function isPairAllowed(address _token0, address _token1)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IUniswapRouter {\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function getAmountsOut(uint256 amountIn, address[] memory path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPokeMe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IPokeMe {\\n    function createTask(\\n        address _execAddress,\\n        bytes4 _execSelector,\\n        address _resolverAddress,\\n        bytes calldata _resolverData\\n    ) external;\\n\\n    function cancelTask(bytes32 _taskId) external;\\n\\n    // function withdrawFunds(uint256 _amount) external;\\n\\n    function getTaskId(\\n        address _taskCreator,\\n        address _execAddress,\\n        bytes4 _selector\\n    ) external pure returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITaskTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface ITaskTreasury {\\n    function withdrawFunds(\\n        address payable _receiver,\\n        address _token,\\n        uint256 _amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IResolver {\\n    function getProcessableOrders()\\n        external\\n        returns (bool canExec, bytes memory execPayload);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAddressBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IAddressBook {\\n    function getOtokenImpl() external view returns (address);\\n\\n    function getOtokenFactory() external view returns (address);\\n\\n    function getWhitelist() external view returns (address);\\n\\n    function getController() external view returns (address);\\n\\n    function getOracle() external view returns (address);\\n\\n    function getMarginPool() external view returns (address);\\n\\n    function getMarginCalculator() external view returns (address);\\n\\n    function getLiquidationManager() external view returns (address);\\n\\n    function getAddress(bytes32 _id) external view returns (address);\\n\\n    /* Setters */\\n\\n    function setOtokenImpl(address _otokenImpl) external;\\n\\n    function setOtokenFactory(address _factory) external;\\n\\n    function setOracleImpl(address _otokenImpl) external;\\n\\n    function setWhitelist(address _whitelist) external;\\n\\n    function setController(address _controller) external;\\n\\n    function setMarginPool(address _marginPool) external;\\n\\n    function setMarginCalculator(address _calculator) external;\\n\\n    function setLiquidationManager(address _liquidationManager) external;\\n\\n    function setAddress(bytes32 _id, address _newImpl) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGammaController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {Actions} from \\\"../external/OpynActions.sol\\\";\\nimport {MarginVault} from \\\"../external/OpynVault.sol\\\";\\n\\ninterface IGammaController {\\n    function operate(Actions.ActionArgs[] memory _actions) external;\\n\\n    function isSettlementAllowed(address _otoken) external view returns (bool);\\n\\n    function isOperator(address _owner, address _operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function getPayout(address _otoken, uint256 _amount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getVaultWithDetails(address _owner, uint256 _vaultId)\\n        external\\n        view\\n        returns (\\n            MarginVault.Vault memory,\\n            uint256,\\n            uint256\\n        );\\n\\n    function getVault(address _owner, uint256 _vaultId)\\n        external\\n        view\\n        returns (MarginVault.Vault memory);\\n\\n    function getAccountVaultCounter(address _accountOwner)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IWhitelist {\\n    function isWhitelistedOtoken(address _otoken) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMarginCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\nimport {MarginVault} from \\\"../external/OpynVault.sol\\\";\\n\\ninterface IMarginCalculator {\\n    function getExcessCollateral(\\n        MarginVault.Vault calldata _vault,\\n        uint256 _vaultType\\n    ) external view returns (uint256 netValue, bool isExcess);\\n}\\n\"\r\n    },\r\n    \"contracts/external/OpynActions.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: UNLICENSED\\n */\\npragma solidity 0.8.0;\\n\\n/**\\n * @title Actions\\n * @author Opyn Team\\n * @notice A library that provides a ActionArgs struct, sub types of Action structs, and functions to parse ActionArgs into specific Actions.\\n */\\nlibrary Actions {\\n    // possible actions that can be performed\\n    enum ActionType {\\n        OpenVault,\\n        MintShortOption,\\n        BurnShortOption,\\n        DepositLongOption,\\n        WithdrawLongOption,\\n        DepositCollateral,\\n        WithdrawCollateral,\\n        SettleVault,\\n        Redeem,\\n        Call,\\n        Liquidate\\n    }\\n\\n    struct ActionArgs {\\n        // type of action that is being performed on the system\\n        ActionType actionType;\\n        // address of the account owner\\n        address owner;\\n        // address which we move assets from or to (depending on the action type)\\n        address secondAddress;\\n        // asset that is to be transfered\\n        address asset;\\n        // index of the vault that is to be modified (if any)\\n        uint256 vaultId;\\n        // amount of asset that is to be transfered\\n        uint256 amount;\\n        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\\n        uint256 index;\\n        // any other data that needs to be passed in for arbitrary function calls\\n        bytes data;\\n    }\\n\\n    struct MintArgs {\\n        // address of the account owner\\n        address owner;\\n        // index of the vault from which the asset will be minted\\n        uint256 vaultId;\\n        // address to which we transfer the minted oTokens\\n        address to;\\n        // oToken that is to be minted\\n        address otoken;\\n        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\\n        uint256 index;\\n        // amount of oTokens that is to be minted\\n        uint256 amount;\\n    }\\n\\n    struct BurnArgs {\\n        // address of the account owner\\n        address owner;\\n        // index of the vault from which the oToken will be burned\\n        uint256 vaultId;\\n        // address from which we transfer the oTokens\\n        address from;\\n        // oToken that is to be burned\\n        address otoken;\\n        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\\n        uint256 index;\\n        // amount of oTokens that is to be burned\\n        uint256 amount;\\n    }\\n\\n    struct OpenVaultArgs {\\n        // address of the account owner\\n        address owner;\\n        // vault id to create\\n        uint256 vaultId;\\n        // vault type, 0 for spread/max loss and 1 for naked margin vault\\n        uint256 vaultType;\\n    }\\n\\n    struct DepositArgs {\\n        // address of the account owner\\n        address owner;\\n        // index of the vault to which the asset will be added\\n        uint256 vaultId;\\n        // address from which we transfer the asset\\n        address from;\\n        // asset that is to be deposited\\n        address asset;\\n        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\\n        uint256 index;\\n        // amount of asset that is to be deposited\\n        uint256 amount;\\n    }\\n\\n    struct RedeemArgs {\\n        // address to which we pay out the oToken proceeds\\n        address receiver;\\n        // oToken that is to be redeemed\\n        address otoken;\\n        // amount of oTokens that is to be redeemed\\n        uint256 amount;\\n    }\\n\\n    struct WithdrawArgs {\\n        // address of the account owner\\n        address owner;\\n        // index of the vault from which the asset will be withdrawn\\n        uint256 vaultId;\\n        // address to which we transfer the asset\\n        address to;\\n        // asset that is to be withdrawn\\n        address asset;\\n        // each vault can hold multiple short / long / collateral assets but we are restricting the scope to only 1 of each in this version\\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\\n        uint256 index;\\n        // amount of asset that is to be withdrawn\\n        uint256 amount;\\n    }\\n\\n    struct SettleVaultArgs {\\n        // address of the account owner\\n        address owner;\\n        // index of the vault to which is to be settled\\n        uint256 vaultId;\\n        // address to which we transfer the remaining collateral\\n        address to;\\n    }\\n\\n    struct LiquidateArgs {\\n        // address of the vault owner to liquidate\\n        address owner;\\n        // address of the liquidated collateral receiver\\n        address receiver;\\n        // vault id to liquidate\\n        uint256 vaultId;\\n        // amount of debt(otoken) to repay\\n        uint256 amount;\\n        // chainlink round id\\n        uint256 roundId;\\n    }\\n\\n    struct CallArgs {\\n        // address of the callee contract\\n        address callee;\\n        // data field for external calls\\n        bytes data;\\n    }\\n\\n    /**\\n     * @notice parses the passed in action arguments to get the arguments for an open vault action\\n     * @param _args general action arguments structure\\n     * @return arguments for a open vault action\\n     */\\n    function _parseOpenVaultArgs(ActionArgs memory _args)\\n        internal\\n        pure\\n        returns (OpenVaultArgs memory)\\n    {\\n        require(\\n            _args.actionType == ActionType.OpenVault,\\n            \\\"Actions: can only parse arguments for open vault actions\\\"\\n        );\\n        require(\\n            _args.owner != address(0),\\n            \\\"Actions: cannot open vault for an invalid account\\\"\\n        );\\n\\n        // if not _args.data included, vault type will be 0 by default\\n        uint256 vaultType;\\n\\n        if (_args.data.length == 32) {\\n            // decode vault type from _args.data\\n            vaultType = abi.decode(_args.data, (uint256));\\n        }\\n\\n        // for now we only have 2 vault types\\n        require(\\n            vaultType < 2,\\n            \\\"Actions: cannot open vault with an invalid type\\\"\\n        );\\n\\n        return\\n            OpenVaultArgs({\\n                owner: _args.owner,\\n                vaultId: _args.vaultId,\\n                vaultType: vaultType\\n            });\\n    }\\n\\n    /**\\n     * @notice parses the passed in action arguments to get the arguments for a mint action\\n     * @param _args general action arguments structure\\n     * @return arguments for a mint action\\n     */\\n    function _parseMintArgs(ActionArgs memory _args)\\n        internal\\n        pure\\n        returns (MintArgs memory)\\n    {\\n        require(\\n            _args.actionType == ActionType.MintShortOption,\\n            \\\"Actions: can only parse arguments for mint actions\\\"\\n        );\\n        require(\\n            _args.owner != address(0),\\n            \\\"Actions: cannot mint from an invalid account\\\"\\n        );\\n\\n        return\\n            MintArgs({\\n                owner: _args.owner,\\n                vaultId: _args.vaultId,\\n                to: _args.secondAddress,\\n                otoken: _args.asset,\\n                index: _args.index,\\n                amount: _args.amount\\n            });\\n    }\\n\\n    /**\\n     * @notice parses the passed in action arguments to get the arguments for a burn action\\n     * @param _args general action arguments structure\\n     * @return arguments for a burn action\\n     */\\n    function _parseBurnArgs(ActionArgs memory _args)\\n        internal\\n        pure\\n        returns (BurnArgs memory)\\n    {\\n        require(\\n            _args.actionType == ActionType.BurnShortOption,\\n            \\\"Actions: can only parse arguments for burn actions\\\"\\n        );\\n        require(\\n            _args.owner != address(0),\\n            \\\"Actions: cannot burn from an invalid account\\\"\\n        );\\n\\n        return\\n            BurnArgs({\\n                owner: _args.owner,\\n                vaultId: _args.vaultId,\\n                from: _args.secondAddress,\\n                otoken: _args.asset,\\n                index: _args.index,\\n                amount: _args.amount\\n            });\\n    }\\n\\n    /**\\n     * @notice parses the passed in action arguments to get the arguments for a deposit action\\n     * @param _args general action arguments structure\\n     * @return arguments for a deposit action\\n     */\\n    function _parseDepositArgs(ActionArgs memory _args)\\n        internal\\n        pure\\n        returns (DepositArgs memory)\\n    {\\n        require(\\n            (_args.actionType == ActionType.DepositLongOption) ||\\n                (_args.actionType == ActionType.DepositCollateral),\\n            \\\"Actions: can only parse arguments for deposit actions\\\"\\n        );\\n        require(\\n            _args.owner != address(0),\\n            \\\"Actions: cannot deposit to an invalid account\\\"\\n        );\\n\\n        return\\n            DepositArgs({\\n                owner: _args.owner,\\n                vaultId: _args.vaultId,\\n                from: _args.secondAddress,\\n                asset: _args.asset,\\n                index: _args.index,\\n                amount: _args.amount\\n            });\\n    }\\n\\n    /**\\n     * @notice parses the passed in action arguments to get the arguments for a withdraw action\\n     * @param _args general action arguments structure\\n     * @return arguments for a withdraw action\\n     */\\n    function _parseWithdrawArgs(ActionArgs memory _args)\\n        internal\\n        pure\\n        returns (WithdrawArgs memory)\\n    {\\n        require(\\n            (_args.actionType == ActionType.WithdrawLongOption) ||\\n                (_args.actionType == ActionType.WithdrawCollateral),\\n            \\\"Actions: can only parse arguments for withdraw actions\\\"\\n        );\\n        require(\\n            _args.owner != address(0),\\n            \\\"Actions: cannot withdraw from an invalid account\\\"\\n        );\\n        require(\\n            _args.secondAddress != address(0),\\n            \\\"Actions: cannot withdraw to an invalid account\\\"\\n        );\\n\\n        return\\n            WithdrawArgs({\\n                owner: _args.owner,\\n                vaultId: _args.vaultId,\\n                to: _args.secondAddress,\\n                asset: _args.asset,\\n                index: _args.index,\\n                amount: _args.amount\\n            });\\n    }\\n\\n    /**\\n     * @notice parses the passed in action arguments to get the arguments for an redeem action\\n     * @param _args general action arguments structure\\n     * @return arguments for a redeem action\\n     */\\n    function _parseRedeemArgs(ActionArgs memory _args)\\n        internal\\n        pure\\n        returns (RedeemArgs memory)\\n    {\\n        require(\\n            _args.actionType == ActionType.Redeem,\\n            \\\"Actions: can only parse arguments for redeem actions\\\"\\n        );\\n        require(\\n            _args.secondAddress != address(0),\\n            \\\"Actions: cannot redeem to an invalid account\\\"\\n        );\\n\\n        return\\n            RedeemArgs({\\n                receiver: _args.secondAddress,\\n                otoken: _args.asset,\\n                amount: _args.amount\\n            });\\n    }\\n\\n    /**\\n     * @notice parses the passed in action arguments to get the arguments for a settle vault action\\n     * @param _args general action arguments structure\\n     * @return arguments for a settle vault action\\n     */\\n    function _parseSettleVaultArgs(ActionArgs memory _args)\\n        internal\\n        pure\\n        returns (SettleVaultArgs memory)\\n    {\\n        require(\\n            _args.actionType == ActionType.SettleVault,\\n            \\\"Actions: can only parse arguments for settle vault actions\\\"\\n        );\\n        require(\\n            _args.owner != address(0),\\n            \\\"Actions: cannot settle vault for an invalid account\\\"\\n        );\\n        require(\\n            _args.secondAddress != address(0),\\n            \\\"Actions: cannot withdraw payout to an invalid account\\\"\\n        );\\n\\n        return\\n            SettleVaultArgs({\\n                owner: _args.owner,\\n                vaultId: _args.vaultId,\\n                to: _args.secondAddress\\n            });\\n    }\\n\\n    function _parseLiquidateArgs(ActionArgs memory _args)\\n        internal\\n        pure\\n        returns (LiquidateArgs memory)\\n    {\\n        require(\\n            _args.actionType == ActionType.Liquidate,\\n            \\\"Actions: can only parse arguments for liquidate action\\\"\\n        );\\n        require(\\n            _args.owner != address(0),\\n            \\\"Actions: cannot liquidate vault for an invalid account owner\\\"\\n        );\\n        require(\\n            _args.secondAddress != address(0),\\n            \\\"Actions: cannot send collateral to an invalid account\\\"\\n        );\\n        require(\\n            _args.data.length == 32,\\n            \\\"Actions: cannot parse liquidate action with no round id\\\"\\n        );\\n\\n        // decode chainlink round id from _args.data\\n        uint256 roundId = abi.decode(_args.data, (uint256));\\n\\n        return\\n            LiquidateArgs({\\n                owner: _args.owner,\\n                receiver: _args.secondAddress,\\n                vaultId: _args.vaultId,\\n                amount: _args.amount,\\n                roundId: roundId\\n            });\\n    }\\n\\n    /**\\n     * @notice parses the passed in action arguments to get the arguments for a call action\\n     * @param _args general action arguments structure\\n     * @return arguments for a call action\\n     */\\n    function _parseCallArgs(ActionArgs memory _args)\\n        internal\\n        pure\\n        returns (CallArgs memory)\\n    {\\n        require(\\n            _args.actionType == ActionType.Call,\\n            \\\"Actions: can only parse arguments for call actions\\\"\\n        );\\n        require(\\n            _args.secondAddress != address(0),\\n            \\\"Actions: target address cannot be address(0)\\\"\\n        );\\n\\n        return CallArgs({callee: _args.secondAddress, data: _args.data});\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/OpynVault.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: UNLICENSED\\n */\\npragma solidity 0.8.0;\\n\\n/**\\n * @title MarginVault\\n * @author Opyn Team\\n * @notice A library that provides the Controller with a Vault struct and the functions that manipulate vaults.\\n * Vaults describe discrete position combinations of long options, short options, and collateral assets that a user can have.\\n */\\nlibrary MarginVault {\\n    // vault is a struct of 6 arrays that describe a position a user has, a user can have multiple vaults.\\n    struct Vault {\\n        // addresses of oTokens a user has shorted (i.e. written) against this vault\\n        address[] shortOtokens;\\n        // addresses of oTokens a user has bought and deposited in this vault\\n        // user can be long oTokens without opening a vault (e.g. by buying on a DEX)\\n        // generally, long oTokens will be 'deposited' in vaults to act as collateral in order to write oTokens against (i.e. in spreads)\\n        address[] longOtokens;\\n        // addresses of other ERC-20s a user has deposited as collateral in this vault\\n        address[] collateralAssets;\\n        // quantity of oTokens minted/written for each oToken address in shortOtokens\\n        uint256[] shortAmounts;\\n        // quantity of oTokens owned and held in the vault for each oToken address in longOtokens\\n        uint256[] longAmounts;\\n        // quantity of ERC-20 deposited as collateral in the vault for each ERC-20 address in collateralAssets\\n        uint256[] collateralAmounts;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOtoken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.0;\\n\\ninterface IOtoken {\\n    function addressBook() external view returns (address);\\n\\n    function underlyingAsset() external view returns (address);\\n\\n    function strikeAsset() external view returns (address);\\n\\n    function collateralAsset() external view returns (address);\\n\\n    function strikePrice() external view returns (uint256);\\n\\n    function expiryTimestamp() external view returns (uint256);\\n\\n    function isPut() external view returns (bool);\\n\\n    function init(\\n        address _addressBook,\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        address _collateralAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiry,\\n        bool _isPut\\n    ) external;\\n\\n    function getOtokenDetails()\\n        external\\n        view\\n        returns (\\n            address,\\n            address,\\n            address,\\n            uint256,\\n            uint256,\\n            bool\\n        );\\n\\n    function mintOtoken(address account, uint256 amount) external;\\n\\n    function burnOtoken(address account, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gammaAddressBook\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_automator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_automatorTreasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"otoken\",\"type\":\"address\"}],\"name\":\"OrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"cancelled\",\"type\":\"bool\"}],\"name\":\"OrderFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addressBook\",\"outputs\":[{\"internalType\":\"contract IAddressBook\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"}],\"name\":\"allowPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"automator\",\"outputs\":[{\"internalType\":\"contract IPokeMe\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"automatorTreasury\",\"outputs\":[{\"internalType\":\"contract ITaskTreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculator\",\"outputs\":[{\"internalType\":\"contract IMarginCalculator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IGammaController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_otoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_toToken\",\"type\":\"address\"}],\"name\":\"createOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"}],\"name\":\"disallowPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"shortOtokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"longOtokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"collateralAssets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shortAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"longAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"collateralAmounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct MarginVault.Vault\",\"name\":\"_vault\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_typeVault\",\"type\":\"uint256\"}],\"name\":\"getExcessCollateral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"}],\"name\":\"getOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"otoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSeller\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"}],\"internalType\":\"struct IAutoGamma.Order\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"otoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSeller\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"}],\"internalType\":\"struct IAutoGamma.Order[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOrdersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_otoken\",\"type\":\"address\"}],\"name\":\"getOtokenCollateral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_otoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getRedeemPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_otoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getRedeemableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"}],\"name\":\"getVault\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"shortOtokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"longOtokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"collateralAssets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shortAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"longAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"collateralAmounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct MarginVault.Vault\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"}],\"name\":\"getVaultOtoken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"shortOtokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"longOtokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"collateralAssets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shortAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"longAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"collateralAmounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct MarginVault.Vault\",\"name\":\"_vault\",\"type\":\"tuple\"}],\"name\":\"getVaultOtokenByVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"}],\"name\":\"getVaultWithDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"shortOtokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"longOtokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"collateralAssets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shortAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"longAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"collateralAmounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct MarginVault.Vault\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_otoken\",\"type\":\"address\"}],\"name\":\"hasExpiredAndSettlementAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isAutomatorEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"isOperatorOf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"}],\"name\":\"isPairAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_otoken\",\"type\":\"address\"}],\"name\":\"isSettlementAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"}],\"name\":\"isValidVaultId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_otoken\",\"type\":\"address\"}],\"name\":\"isWhitelistedOtoken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"otoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSeller\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"swapAmountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"swapPath\",\"type\":\"address[]\"}],\"internalType\":\"struct IAutoGamma.ProcessOrderArgs\",\"name\":\"orderArgs\",\"type\":\"tuple\"}],\"name\":\"processOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_orderIds\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"swapAmountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"swapPath\",\"type\":\"address[]\"}],\"internalType\":\"struct IAutoGamma.ProcessOrderArgs[]\",\"name\":\"_orderArgs\",\"type\":\"tuple[]\"}],\"name\":\"processOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refreshConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setAddressBook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_automator\",\"type\":\"address\"}],\"name\":\"setAutomator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_automatorTreasury\",\"type\":\"address\"}],\"name\":\"setAutomatorTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_redeemFee\",\"type\":\"uint256\"}],\"name\":\"setRedeemFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_settleFee\",\"type\":\"uint256\"}],\"name\":\"setSettleFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniRouter\",\"type\":\"address\"}],\"name\":\"setUniRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"}],\"name\":\"shouldProcessOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_otoken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"shouldRedeemOtoken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_vaultId\",\"type\":\"uint256\"}],\"name\":\"shouldSettleVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"startAutomator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopAutomator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"uniPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"contract IWhitelist\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"AutoGamma","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001e31f2dcbad4dc572004eae6355fb18f9615cbe40000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d00000000000000000000000089a26d08c26e00ce935a775ba74a984ad346679b00000000000000000000000066e2f69df68c8f56837142be2e8c290efe76da9f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}