{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/brokerV2_utils/TokenDetArrayLib.sol\r\n\r\npragma solidity ^0.5.6;\r\npragma experimental ABIEncoderV2;\r\n\r\n// librray for TokenDets\r\nlibrary TokenDetArrayLib {\r\n    // Using for array of strcutres for storing mintable address and token id\r\n    using TokenDetArrayLib for TokenDets;\r\n\r\n    struct TokenDet {\r\n        address NFTAddress;\r\n        uint256 tokenID;\r\n    }\r\n\r\n    // custom type array TokenDets\r\n    struct TokenDets {\r\n        TokenDet[] array;\r\n    }\r\n\r\n    function addTokenDet(\r\n        TokenDets storage self,\r\n        TokenDet memory _tokenDet\r\n        // address _mintableAddress,\r\n        // uint256 _tokenID\r\n    ) public {\r\n        if (!self.exists(_tokenDet)) {\r\n            self.array.push(_tokenDet);\r\n        }\r\n    }\r\n\r\n    function getIndexByTokenDet(\r\n        TokenDets storage self,\r\n        TokenDet memory _tokenDet\r\n    ) internal view returns (uint256, bool) {\r\n        uint256 index;\r\n        bool tokenExists = false;\r\n        for (uint256 i = 0; i < self.array.length; i++) {\r\n            if (\r\n                self.array[i].NFTAddress == _tokenDet.NFTAddress &&\r\n                self.array[i].tokenID == _tokenDet.tokenID \r\n            ) {\r\n                index = i;\r\n                tokenExists = true;\r\n                break;\r\n            }\r\n        }\r\n        return (index, tokenExists);\r\n    }\r\n\r\n    function removeTokenDet(\r\n        TokenDets storage self,\r\n        TokenDet memory _tokenDet\r\n    ) internal returns (bool) {\r\n        (uint256 i, bool tokenExists) = self.getIndexByTokenDet(_tokenDet);\r\n        if (tokenExists == true) {\r\n            self.array[i] = self.array[self.array.length - 1];\r\n            self.array.pop();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function exists(\r\n        TokenDets storage self,\r\n        TokenDet memory _tokenDet\r\n    ) internal view returns (bool) {\r\n        for (uint256 i = 0; i < self.array.length; i++) {\r\n            if (\r\n                self.array[i].NFTAddress == _tokenDet.NFTAddress &&\r\n                self.array[i].tokenID == _tokenDet.tokenID\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n// File: contracts/brokerV2_utils/Ownable.sol\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    // event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        // address msgSender = _msgSender();\r\n        _owner = msg.sender;\r\n        // emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        // emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/brokerV2_utils/ERC20Addresses.sol\r\n\r\n\r\n\r\n// library for erc20address array \r\nlibrary ERC20Addresses {\r\n    using ERC20Addresses for erc20Addresses;\r\n\r\n    struct erc20Addresses {\r\n        address[] array;\r\n    }\r\n\r\n    function addERC20Tokens(erc20Addresses storage self, address erc20address)\r\n        external\r\n    {\r\n        self.array.push(erc20address);\r\n    }\r\n\r\n    function getIndexByERC20Token(\r\n        erc20Addresses storage self,\r\n        address _ercTokenAddress\r\n    ) internal view returns (uint256, bool) {\r\n        uint256 index;\r\n        bool exists;\r\n\r\n        for (uint256 i = 0; i < self.array.length; i++) {\r\n            if (self.array[i] == _ercTokenAddress) {\r\n                index = i;\r\n                exists = true;\r\n\r\n                break;\r\n            }\r\n        }\r\n        return (index, exists);\r\n    }\r\n\r\n    function removeERC20Token(\r\n        erc20Addresses storage self,\r\n        address _ercTokenAddress\r\n    ) internal {\r\n        if (self.array.length > 1){\r\n            for (uint256 i = 0; i < self.array.length; i++) {\r\n                    if (\r\n                        self.array[i] == _ercTokenAddress \r\n                    ) {\r\n                        delete self.array[i];\r\n                    }\r\n                }\r\n        }\r\n        else{\r\n            self.array.length = 0;\r\n        }\r\n    }\r\n    function exists(\r\n        erc20Addresses storage self,\r\n        address _ercTokenAddress\r\n    ) internal view returns (bool) {\r\n        for (uint256 i = 0; i < self.array.length; i++) {\r\n            if (\r\n                self.array[i] == _ercTokenAddress \r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n// File: contracts/brokerV2_utils/Storage.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IERC20 {\r\n    \r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ncontract IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) public returns (bytes4);\r\n}\r\n\r\ncontract ERC721Holder is IERC721Receiver {\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes memory\r\n    ) public returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\ncontract IMintableToken {\r\n\r\n    // Required methods\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n\r\n    function royalities(uint256 _tokenId) public view returns (uint256);\r\n\r\n    function creators(uint256 _tokenId) public view returns (address payable);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public;\r\n\r\n    function getApproved(uint256 tokenId)\r\n        public\r\n        view\r\n        returns (address operator);\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\ncontract Storage is Ownable {\r\n    using TokenDetArrayLib for TokenDetArrayLib.TokenDets;\r\n    using ERC20Addresses for ERC20Addresses.erc20Addresses;\r\n    // address owner;\r\n    uint16 public brokerage;\r\n    mapping(address => mapping(uint256 => bool)) tokenOpenForSale;\r\n    mapping(address => TokenDetArrayLib.TokenDets) tokensForSalePerUser;\r\n    TokenDetArrayLib.TokenDets fixedPriceTokens;\r\n    TokenDetArrayLib.TokenDets auctionTokens;\r\n\r\n    //auction type :\r\n    // 1 : only direct buy\r\n    // 2 : only bid\r\n    // 3 : both buy and bid\r\n\r\n    struct auction {\r\n        address payable lastOwner;\r\n        uint256 currentBid;\r\n        address payable highestBidder;\r\n        uint256 auctionType;\r\n        uint256 startingPrice;\r\n        uint256 buyPrice;\r\n        bool buyer;\r\n        uint256 startingTime;\r\n        uint256 closingTime;\r\n        address erc20Token;\r\n    }\r\n\r\n    mapping(address => mapping(uint256 => auction)) public auctions;\r\n\r\n    TokenDetArrayLib.TokenDets tokensForSale;\r\n    ERC20Addresses.erc20Addresses erc20TokensArray;\r\n\r\n    function getErc20Tokens()\r\n        public\r\n        view\r\n        returns (ERC20Addresses.erc20Addresses memory)\r\n    {\r\n        return erc20TokensArray;\r\n    }\r\n\r\n    function getTokensForSale()\r\n        public\r\n        view\r\n        returns (TokenDetArrayLib.TokenDet[] memory)\r\n    {\r\n        return tokensForSale.array;\r\n    }\r\n\r\n    function getFixedPriceTokensForSale()\r\n        public\r\n        view\r\n        returns (TokenDetArrayLib.TokenDet[] memory)\r\n    {\r\n        return fixedPriceTokens.array;\r\n    }\r\n\r\n    function getAuctionTokensForSale()\r\n        public\r\n        view\r\n        returns (TokenDetArrayLib.TokenDet[] memory)\r\n    {\r\n        return auctionTokens.array;\r\n    }\r\n\r\n    function getTokensForSalePerUser(address _user)\r\n        public\r\n        view\r\n        returns (TokenDetArrayLib.TokenDet[] memory)\r\n    {\r\n        return tokensForSalePerUser[_user].array;\r\n    }\r\n\r\n    function setBrokerage(uint16 _brokerage) public onlyOwner {\r\n        brokerage = _brokerage;\r\n    }\r\n}\r\n\r\n// File: contracts/brokerV2_utils/BrokerModifiers.sol\r\n\r\n\r\n\r\ncontract BrokerModifiers is Storage {\r\n    modifier erc20Allowed(address _erc20Token) {\r\n        if (_erc20Token != address(0)) {\r\n            require(\r\n                erc20TokensArray.exists(_erc20Token),\r\n                \"ERC20 not allowed\"\r\n            );\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onSaleOnly(uint256 tokenID, address _mintableToken) {\r\n        require(\r\n            tokenOpenForSale[_mintableToken][tokenID] == true,\r\n            \"Token Not For Sale\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier activeAuction(uint256 tokenID, address _mintableToken) {\r\n        require(\r\n            block.timestamp < auctions[_mintableToken][tokenID].closingTime,\r\n            \"Auction Time Over!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier auctionOnly(uint256 tokenID, address _mintableToken) {\r\n        require(\r\n            auctions[_mintableToken][tokenID].auctionType != 1,\r\n            \"Auction Not For Bid\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier flatSaleOnly(uint256 tokenID, address _mintableToken) {\r\n        require(\r\n            auctions[_mintableToken][tokenID].auctionType != 2,\r\n            \"Auction for Bid only!\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier tokenOwnerOnlly(uint256 tokenID, address _mintableToken) {\r\n        // Sender will be owner only if no have bidded on auction.\r\n        require(\r\n            IMintableToken(_mintableToken).ownerOf(tokenID) == msg.sender,\r\n            \"You must be owner and Token should not have any bid\"\r\n        );\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/BrokerV2.sol\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract BrokerV2 is ERC721Holder, BrokerModifiers {\r\n    // events\r\n    event Bid(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        address bidder,\r\n        uint256 amouont,\r\n        uint256 time,\r\n        address ERC20Address\r\n    );\r\n    event Buy(\r\n        address indexed collection,\r\n        uint256 tokenId,\r\n        address indexed seller,\r\n        address indexed buyer,\r\n        uint256 amount,\r\n        uint256 time,\r\n        address ERC20Address\r\n    );\r\n    event Collect(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        address buyer,\r\n        address collector,\r\n        uint256 time,\r\n        address ERC20Address\r\n    );\r\n    event OnSale(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        uint256 auctionType,\r\n        uint256 amount,\r\n        uint256 time,\r\n        address ERC20Address\r\n    );\r\n    event PriceUpdated(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        uint256 auctionType,\r\n        uint256 oldAmount,\r\n        uint256 amount,\r\n        uint256 time,\r\n        address ERC20Address\r\n    );\r\n    event OffSale(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        uint256 time,\r\n        address ERC20Address\r\n    );\r\n\r\n    mapping(address => uint256) brokerageBalance;\r\n\r\n    constructor(uint16 _brokerage) public {\r\n        brokerage = _brokerage;\r\n        transferOwnership(msg.sender);\r\n    }\r\n\r\n    function addERC20TokenPayment(address _erc20Token) public onlyOwner {\r\n        erc20TokensArray.addERC20Tokens(_erc20Token);\r\n    }\r\n\r\n    function removeERC20TokenPayment(address _erc20Token)\r\n        public\r\n        erc20Allowed(_erc20Token)\r\n        onlyOwner\r\n    {\r\n\r\n        erc20TokensArray.removeERC20Token(_erc20Token);\r\n    }\r\n\r\n    function bid(\r\n        uint256 tokenID,\r\n        address _mintableToken,\r\n        uint256 amount\r\n    )\r\n        public\r\n        payable\r\n        onSaleOnly(tokenID, _mintableToken)\r\n        activeAuction(tokenID, _mintableToken)\r\n    {\r\n        IMintableToken Token = IMintableToken(_mintableToken);\r\n\r\n        auction memory _auction = auctions[_mintableToken][tokenID];\r\n\r\n        if (_auction.erc20Token == address(0)) {\r\n            require(\r\n                msg.value > _auction.currentBid,\r\n                \"Insufficient bidding amount.\"\r\n            );\r\n\r\n            if (_auction.buyer == true) {\r\n                _auction.highestBidder.transfer(_auction.currentBid);\r\n            }\r\n        } else {\r\n            IERC20 erc20Token = IERC20(_auction.erc20Token);\r\n            require(\r\n                erc20Token.allowance(msg.sender, address(this)) >= amount,\r\n                \"Allowance is less than amount sent for bidding.\"\r\n            );\r\n            require(\r\n                amount > _auction.currentBid,\r\n                \"Insufficient bidding amount.\"\r\n            );\r\n            erc20Token.transferFrom(msg.sender, address(this), amount);\r\n\r\n            if (_auction.buyer == true) {\r\n                erc20Token.transfer(\r\n                    _auction.highestBidder,\r\n                    _auction.currentBid\r\n                );\r\n            }\r\n        }\r\n\r\n        _auction.currentBid = _auction.erc20Token == address(0)\r\n            ? msg.value\r\n            : amount;\r\n\r\n        Token.safeTransferFrom(Token.ownerOf(tokenID), address(this), tokenID);\r\n        _auction.buyer = true;\r\n        _auction.highestBidder = msg.sender;\r\n\r\n        auctions[_mintableToken][tokenID] = _auction;\r\n\r\n        // Bid event\r\n        emit Bid(\r\n            _mintableToken,\r\n            tokenID,\r\n            _auction.lastOwner,\r\n            _auction.highestBidder,\r\n            _auction.currentBid,\r\n            block.timestamp,\r\n            _auction.erc20Token\r\n        );\r\n    }\r\n    // Collect Function are use to collect funds and NFT from Broker\r\n    function collect(uint256 tokenID, address _mintableToken)\r\n        public\r\n    {\r\n        IMintableToken Token = IMintableToken(_mintableToken);\r\n        auction memory _auction = auctions[_mintableToken][tokenID];\r\n        TokenDetArrayLib.TokenDet memory _tokenDet = TokenDetArrayLib.TokenDet(_mintableToken,tokenID);\r\n\r\n        require(\r\n            block.timestamp > _auction.closingTime,\r\n            \"Auction Not Over!\"\r\n        );\r\n\r\n        address payable lastOwner2 = _auction.lastOwner;\r\n        uint256 royalities = Token.royalities(tokenID);\r\n        address payable creator = Token.creators(tokenID);\r\n\r\n        uint256 royality = (royalities * _auction.currentBid) / 10000;\r\n        uint256 brokerageAmount = (brokerage * _auction.currentBid) / 10000;\r\n\r\n        // uint256 lastOwner_funds = ((10000 - royalities - brokerage) *\r\n        //     _auction.currentBid) / 10000;\r\n\r\n        uint256 lastOwner_funds = _auction.currentBid - royality - brokerageAmount;\r\n        \r\n        if (_auction.buyer == true) {\r\n            if (_auction.erc20Token == address(0)) {\r\n                creator.transfer(royality);\r\n                lastOwner2.transfer(lastOwner_funds);\r\n            } else {\r\n                IERC20 erc20Token = IERC20(_auction.erc20Token);\r\n                // transfer royalitiy to creator\r\n                erc20Token.transfer(creator, royality);\r\n                erc20Token.transfer(lastOwner2, lastOwner_funds);\r\n            }\r\n            brokerageBalance[_auction.erc20Token] += brokerageAmount;\r\n            tokenOpenForSale[_mintableToken][tokenID] = false;\r\n            Token.safeTransferFrom(\r\n                Token.ownerOf(tokenID),\r\n                _auction.highestBidder,\r\n                tokenID\r\n            );\r\n\r\n            // Buy event\r\n            emit Buy(\r\n                _tokenDet.NFTAddress,\r\n                _tokenDet.tokenID,\r\n                lastOwner2,\r\n                _auction.highestBidder,\r\n                _auction.currentBid,\r\n                block.timestamp,\r\n                _auction.erc20Token\r\n            );\r\n        }\r\n\r\n        // Collect event\r\n        emit Collect(\r\n            _tokenDet.NFTAddress,\r\n            _tokenDet.tokenID,\r\n            lastOwner2,\r\n            _auction.highestBidder,\r\n            msg.sender,\r\n            block.timestamp,\r\n            _auction.erc20Token\r\n        );\r\n\r\n        tokensForSale.removeTokenDet(_tokenDet);\r\n\r\n        tokensForSalePerUser[lastOwner2].removeTokenDet(_tokenDet);\r\n        auctionTokens.removeTokenDet(_tokenDet);\r\n        delete auctions[_mintableToken][tokenID];\r\n    }\r\n\r\n    function buy(uint256 tokenID, address _mintableToken)\r\n        public\r\n        payable\r\n        onSaleOnly(tokenID, _mintableToken)\r\n        flatSaleOnly(tokenID, _mintableToken)\r\n    {\r\n        IMintableToken Token = IMintableToken(_mintableToken);\r\n        auction memory _auction = auctions[_mintableToken][tokenID];\r\n        TokenDetArrayLib.TokenDet memory _tokenDet = TokenDetArrayLib.TokenDet(_mintableToken,tokenID);\r\n        \r\n        address payable lastOwner2 = _auction.lastOwner;\r\n        uint256 royalities = Token.royalities(tokenID);\r\n        address payable creator = Token.creators(tokenID);\r\n        uint256 royality = (royalities * _auction.buyPrice) / 10000;\r\n        uint256 brokerageAmount = (brokerage * _auction.buyPrice) / 10000;\r\n\r\n        uint256 lastOwner_funds = _auction.buyPrice - royality - brokerageAmount;\r\n\r\n        if (_auction.erc20Token == address(0)) {\r\n            require(msg.value >= _auction.buyPrice, \"Insufficient Payment\");\r\n\r\n            creator.transfer(royality);\r\n            lastOwner2.transfer(lastOwner_funds);\r\n\r\n\r\n        } else {\r\n            IERC20 erc20Token = IERC20(_auction.erc20Token);\r\n            require(\r\n                erc20Token.allowance(msg.sender, address(this)) >=\r\n                    _auction.buyPrice,\r\n                \"Insufficient spent allowance \"\r\n            );\r\n            // transfer royalitiy to creator\r\n            erc20Token.transferFrom(msg.sender, creator, royality);\r\n            // transfer brokerage amount to broker\r\n            erc20Token.transferFrom(msg.sender, address(this), brokerageAmount);\r\n            // transfer remaining  amount to lastOwner\r\n            erc20Token.transferFrom(msg.sender, lastOwner2, lastOwner_funds);\r\n        }\r\n        brokerageBalance[_auction.erc20Token] += brokerageAmount;\r\n\r\n        tokenOpenForSale[_tokenDet.NFTAddress][_tokenDet.tokenID] = false;\r\n        // _auction.buyer = true;\r\n        // _auction.highestBidder = msg.sender;\r\n        // _auction.currentBid = _auction.buyPrice;\r\n\r\n        Token.safeTransferFrom(\r\n            Token.ownerOf(_tokenDet.tokenID),\r\n            // _auction.highestBidder,/\r\n            msg.sender,\r\n            _tokenDet.tokenID\r\n        );\r\n\r\n        // Buy event\r\n        emit Buy(\r\n            _tokenDet.NFTAddress,\r\n            _tokenDet.tokenID,\r\n            lastOwner2,\r\n            msg.sender,\r\n            _auction.buyPrice,\r\n            block.timestamp,\r\n            _auction.erc20Token\r\n        );\r\n\r\n        tokensForSale.removeTokenDet(_tokenDet);\r\n        tokensForSalePerUser[lastOwner2].removeTokenDet(_tokenDet);\r\n\r\n        fixedPriceTokens.removeTokenDet(_tokenDet);\r\n        delete auctions[_tokenDet.NFTAddress][_tokenDet.tokenID];\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        msg.sender.transfer(brokerageBalance[address(0)]);\r\n        brokerageBalance[address(0)] = 0;\r\n    }\r\n\r\n    function withdrawERC20(address _erc20Token) public onlyOwner {\r\n        require(\r\n            erc20TokensArray.exists(_erc20Token),\r\n            \"This erc20token payment not allowed\"\r\n        );\r\n        IERC20 erc20Token = IERC20(_erc20Token);\r\n        erc20Token.transfer(msg.sender, brokerageBalance[_erc20Token]);\r\n        brokerageBalance[_erc20Token] = 0;\r\n    }\r\n\r\n    function putOnSale(\r\n        uint256 _tokenID,\r\n        uint256 _startingPrice,\r\n        uint256 _auctionType,\r\n        uint256 _buyPrice,\r\n        uint256 _duration,\r\n        address _mintableToken,\r\n        address _erc20Token\r\n    )\r\n        public\r\n        erc20Allowed(_erc20Token)\r\n        tokenOwnerOnlly(_tokenID, _mintableToken)\r\n    {\r\n        IMintableToken Token = IMintableToken(_mintableToken);\r\n\r\n        require(\r\n            Token.getApproved(_tokenID) == address(this),\r\n            \"Broker Not approved\"\r\n        );\r\n        auction memory _auction = auctions[_mintableToken][_tokenID];\r\n\r\n        // Allow to put on sale to already on sale NFT \\\r\n        // only if it was on auction and have 0 bids and auction is over\r\n        if (tokenOpenForSale[_mintableToken][_tokenID] == true) {\r\n            require(\r\n                _auction.auctionType == 2 &&\r\n                    _auction.buyer == false &&\r\n                    block.timestamp > _auction.closingTime,\r\n                \"This NFT is already on sale.\"\r\n            );\r\n        }\r\n\r\n        auction memory newAuction = auction(\r\n            msg.sender,\r\n            _startingPrice,\r\n            address(0),\r\n            _auctionType,\r\n            _startingPrice,\r\n            _buyPrice,\r\n            false,\r\n            block.timestamp,\r\n            block.timestamp + _duration,\r\n            _erc20Token\r\n        );\r\n        auctions[_mintableToken][_tokenID] = newAuction;\r\n        TokenDetArrayLib.TokenDet memory _tokenDet = TokenDetArrayLib.TokenDet(_mintableToken, _tokenID);\r\n\r\n        // Store data in all mappings if adding fresh token on sale\r\n        if (tokenOpenForSale[_tokenDet.NFTAddress][_tokenDet.tokenID] == false) {\r\n            tokenOpenForSale[_tokenDet.NFTAddress][_tokenDet.tokenID] = true;\r\n\r\n            tokensForSale.addTokenDet(_tokenDet);\r\n            tokensForSalePerUser[msg.sender].addTokenDet(_tokenDet);\r\n\r\n            // Add token to fixedPrice on Timed list\r\n            if (_auctionType == 1) {\r\n                fixedPriceTokens.addTokenDet(_tokenDet);\r\n            } else if (_auctionType == 2) {\r\n                auctionTokens.addTokenDet(_tokenDet);\r\n            }\r\n        }\r\n\r\n        // OnSale event\r\n        emit OnSale(\r\n            _tokenDet.NFTAddress,\r\n            _tokenDet.tokenID,\r\n            msg.sender,\r\n            _auctionType,\r\n            newAuction.auctionType == 1 ? newAuction.buyPrice : newAuction.startingPrice,\r\n            block.timestamp,\r\n            newAuction.erc20Token\r\n        );\r\n    }\r\n\r\n    function updatePrice(\r\n        uint256 tokenID,\r\n        address _mintableToken,\r\n        uint256 _newPrice,\r\n        address _erc20Token\r\n    )\r\n        public\r\n        onSaleOnly(tokenID, _mintableToken)\r\n        erc20Allowed(_erc20Token)\r\n        tokenOwnerOnlly(tokenID, _mintableToken)\r\n    {\r\n        // IMintableToken Token = IMintableToken(_mintableToken);\r\n        auction memory _auction = auctions[_mintableToken][tokenID];\r\n\r\n        if (_auction.auctionType == 2) {\r\n            require(\r\n                block.timestamp < _auction.closingTime,\r\n                \"Auction Time Over!\"\r\n            );\r\n        }\r\n        emit PriceUpdated(\r\n            _mintableToken,\r\n            tokenID,\r\n            _auction.lastOwner,\r\n            _auction.auctionType,\r\n            _auction.auctionType == 1\r\n                ? _auction.buyPrice\r\n                : _auction.startingPrice,\r\n            _newPrice,\r\n            block.timestamp,\r\n            _auction.erc20Token\r\n        );\r\n        // Update Price\r\n        if (_auction.auctionType == 1) {\r\n            _auction.buyPrice = _newPrice;\r\n        } else {\r\n            _auction.startingPrice = _newPrice;\r\n            _auction.currentBid = _newPrice;\r\n        }\r\n        _auction.erc20Token = _erc20Token;\r\n        auctions[_mintableToken][tokenID] = _auction;\r\n    }\r\n\r\n    function putSaleOff(uint256 tokenID, address _mintableToken)\r\n        public\r\n        tokenOwnerOnlly(tokenID, _mintableToken)\r\n    {\r\n        // IMintableToken Token = IMintableToken(_mintableToken);\r\n        auction memory _auction = auctions[_mintableToken][tokenID];\r\n        TokenDetArrayLib.TokenDet memory _tokenDet = TokenDetArrayLib.TokenDet(_mintableToken,tokenID);\r\n        tokenOpenForSale[_mintableToken][tokenID] = false;\r\n\r\n        // OffSale event\r\n        emit OffSale(\r\n            _mintableToken,\r\n            tokenID,\r\n            msg.sender,\r\n            block.timestamp,\r\n            _auction.erc20Token\r\n        );\r\n\r\n        tokensForSale.removeTokenDet(_tokenDet);\r\n\r\n        tokensForSalePerUser[msg.sender].removeTokenDet(_tokenDet);\r\n        // Remove token from list\r\n        if (_auction.auctionType == 1) {\r\n            fixedPriceTokens.removeTokenDet(_tokenDet);\r\n        } else if (_auction.auctionType == 2) {\r\n            auctionTokens.removeTokenDet(_tokenDet);\r\n        }\r\n        delete auctions[_mintableToken][tokenID];\r\n    }\r\n\r\n    function getOnSaleStatus(address _mintableToken, uint256 tokenID)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return tokenOpenForSale[_mintableToken][tokenID];\r\n    }\r\n}","ABI":"[]","ContractName":"TokenDetArrayLib","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://6636be90cd6206abb42a59df992d424919e3c5f58922023db1096f00bf07c03a"}]}