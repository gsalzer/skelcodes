{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/mining/PremiaMiningProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// For further clarification please see https://license.premia.legal\\n\\npragma solidity ^0.8.0;\\n\\nimport {ProxyUpgradeableOwnable} from \\\"../ProxyUpgradeableOwnable.sol\\\";\\nimport {PremiaMiningStorage} from \\\"./PremiaMiningStorage.sol\\\";\\n\\ncontract PremiaMiningProxy is ProxyUpgradeableOwnable {\\n    constructor(address implementation, uint256 premiaPerBlock)\\n        ProxyUpgradeableOwnable(implementation)\\n    {\\n        PremiaMiningStorage.layout().premiaPerBlock = premiaPerBlock;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ProxyUpgradeableOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// For further clarification please see https://license.premia.legal\\n\\npragma solidity ^0.8.0;\\n\\nimport {Proxy} from \\\"@solidstate/contracts/proxy/Proxy.sol\\\";\\nimport {SafeOwnable, OwnableStorage} from \\\"@solidstate/contracts/access/SafeOwnable.sol\\\";\\nimport {ProxyUpgradeableOwnableStorage} from \\\"./ProxyUpgradeableOwnableStorage.sol\\\";\\n\\ncontract ProxyUpgradeableOwnable is Proxy, SafeOwnable {\\n    using ProxyUpgradeableOwnableStorage for ProxyUpgradeableOwnableStorage.Layout;\\n    using OwnableStorage for OwnableStorage.Layout;\\n\\n    constructor(address implementation) {\\n        OwnableStorage.layout().setOwner(msg.sender);\\n        ProxyUpgradeableOwnableStorage.layout().implementation = implementation;\\n    }\\n\\n    receive() external payable {}\\n\\n    /**\\n     * @inheritdoc Proxy\\n     */\\n    function _getImplementation() internal view override returns (address) {\\n        return ProxyUpgradeableOwnableStorage.layout().implementation;\\n    }\\n\\n    /**\\n     * @notice get address of implementation contract\\n     * @return implementation address\\n     */\\n    function getImplementation() external view returns (address) {\\n        return _getImplementation();\\n    }\\n\\n    /**\\n     * @notice set address of implementation contract\\n     * @param implementation address of the new implementation\\n     */\\n    function setImplementation(address implementation) external onlyOwner {\\n        ProxyUpgradeableOwnableStorage.layout().implementation = implementation;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/mining/PremiaMiningStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// For further clarification please see https://license.premia.legal\\n\\npragma solidity ^0.8.0;\\n\\nlibrary PremiaMiningStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256(\\\"premia.contracts.storage.PremiaMining\\\");\\n\\n    // Info of each pool.\\n    struct PoolInfo {\\n        uint256 allocPoint; // How many allocation points assigned to this pool. PREMIA to distribute per block.\\n        uint256 lastRewardBlock; // Last block number that PREMIA distribution occurs.\\n        uint256 accPremiaPerShare; // Accumulated PREMIA per share, times 1e12. See below.\\n    }\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        uint256 reward; // Total allocated unclaimed reward\\n        uint256 rewardDebt; // Reward debt. See explanation below.\\n        //\\n        // We do some fancy math here. Basically, any point in time, the amount of PREMIA\\n        // entitled to a user but is pending to be distributed is:\\n        //\\n        //   pending reward = (user.amount * pool.accPremiaPerShare) - user.rewardDebt\\n        //\\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\\n        //   1. The pool's `accPremiaPerShare` (and `lastRewardBlock`) gets updated.\\n        //   2. User receives the pending reward sent to his/her address.\\n        //   3. User's `amount` gets updated.\\n        //   4. User's `rewardDebt` gets updated.\\n    }\\n\\n    struct Layout {\\n        // Total PREMIA left to distribute\\n        uint256 premiaAvailable;\\n        // Amount of premia per block distributed\\n        uint256 premiaPerBlock;\\n        // pool -> isCallPool -> PoolInfo\\n        mapping(address => mapping(bool => PoolInfo)) poolInfo;\\n        // pool -> isCallPool -> user -> UserInfo\\n        mapping(address => mapping(bool => mapping(address => UserInfo))) userInfo;\\n        // Total allocation points. Must be the sum of all allocation points in all pools.\\n        uint256 totalAllocPoint;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { AddressUtils } from '../utils/AddressUtils.sol';\\n\\n/**\\n * @title Base proxy contract\\n */\\nabstract contract Proxy {\\n    using AddressUtils for address;\\n\\n    /**\\n     * @notice delegate all calls to implementation contract\\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\\n     * @dev memory location in use by assembly may be unsafe in other contexts\\n     */\\n    fallback() external payable virtual {\\n        address implementation = _getImplementation();\\n\\n        require(\\n            implementation.isContract(),\\n            'Proxy: implementation must be contract'\\n        );\\n\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(\\n                gas(),\\n                implementation,\\n                0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice get logic implementation address\\n     * @return implementation address\\n     */\\n    function _getImplementation() internal virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/SafeOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { Ownable, OwnableStorage } from './Ownable.sol';\\nimport { SafeOwnableInternal } from './SafeOwnableInternal.sol';\\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\\n\\n/**\\n * @title Ownership access control based on ERC173 with ownership transfer safety check\\n */\\nabstract contract SafeOwnable is Ownable, SafeOwnableInternal {\\n    using OwnableStorage for OwnableStorage.Layout;\\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\\n\\n    function nomineeOwner() public view virtual returns (address) {\\n        return SafeOwnableStorage.layout().nomineeOwner;\\n    }\\n\\n    /**\\n     * @inheritdoc Ownable\\n     * @dev ownership transfer must be accepted by beneficiary before transfer is complete\\n     */\\n    function transferOwnership(address account)\\n        public\\n        virtual\\n        override\\n        onlyOwner\\n    {\\n        SafeOwnableStorage.layout().setNomineeOwner(account);\\n    }\\n\\n    /**\\n     * @notice accept transfer of contract ownership\\n     */\\n    function acceptOwnership() public virtual onlyNomineeOwner {\\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\\n        emit OwnershipTransferred(l.owner, msg.sender);\\n        l.setOwner(msg.sender);\\n        SafeOwnableStorage.layout().setNomineeOwner(address(0));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ProxyUpgradeableOwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// For further clarification please see https://license.premia.legal\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ProxyUpgradeableOwnableStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256(\\\"premia.contracts.storage.ProxyUpgradeableOwnable\\\");\\n\\n    struct Layout {\\n        address implementation;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary AddressUtils {\\n    function toString(address account) internal pure returns (string memory) {\\n        bytes32 value = bytes32(uint256(uint160(account)));\\n        bytes memory alphabet = '0123456789abcdef';\\n        bytes memory chars = new bytes(42);\\n\\n        chars[0] = '0';\\n        chars[1] = 'x';\\n\\n        for (uint256 i = 0; i < 20; i++) {\\n            chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\\n            chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\\n        }\\n\\n        return string(chars);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        require(success, 'AddressUtils: failed to send value');\\n    }\\n\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            'AddressUtils: insufficient balance for call'\\n        );\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        require(\\n            isContract(target),\\n            'AddressUtils: function call to non-contract'\\n        );\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC173 } from './IERC173.sol';\\nimport { OwnableInternal } from './OwnableInternal.sol';\\nimport { OwnableStorage } from './OwnableStorage.sol';\\n\\n/**\\n * @title Ownership access control based on ERC173\\n */\\nabstract contract Ownable is IERC173, OwnableInternal {\\n    using OwnableStorage for OwnableStorage.Layout;\\n\\n    /**\\n     * @inheritdoc IERC173\\n     */\\n    function owner() public view virtual override returns (address) {\\n        return OwnableStorage.layout().owner;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC173\\n     */\\n    function transferOwnership(address account)\\n        public\\n        virtual\\n        override\\n        onlyOwner\\n    {\\n        OwnableStorage.layout().setOwner(account);\\n        emit OwnershipTransferred(msg.sender, account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/SafeOwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\\n\\nabstract contract SafeOwnableInternal {\\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\\n\\n    modifier onlyNomineeOwner() {\\n        require(\\n            msg.sender == SafeOwnableStorage.layout().nomineeOwner,\\n            'SafeOwnable: sender must be nominee owner'\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/SafeOwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary SafeOwnableStorage {\\n    struct Layout {\\n        address nomineeOwner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.SafeOwnable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function setNomineeOwner(Layout storage l, address nomineeOwner) internal {\\n        l.nomineeOwner = nomineeOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Contract ownership standard interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-173\\n */\\ninterface IERC173 {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @notice get the ERC173 contract owner\\n     * @return conract owner\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice transfer contract ownership to new account\\n     * @param account address of new owner\\n     */\\n    function transferOwnership(address account) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/OwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { OwnableStorage } from './OwnableStorage.sol';\\n\\nabstract contract OwnableInternal {\\n    using OwnableStorage for OwnableStorage.Layout;\\n\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == OwnableStorage.layout().owner,\\n            'Ownable: sender must be owner'\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/OwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary OwnableStorage {\\n    struct Layout {\\n        address owner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Ownable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function setOwner(Layout storage l, address owner) internal {\\n        l.owner = owner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"premiaPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nomineeOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"PremiaMiningProxy","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000bfdc37499d99046710a9c567016791c71cd25cf600000000000000000000000000000000000000000000000006f05b59d3b20000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}