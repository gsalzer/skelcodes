{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/Claim_Codes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IVesting.sol\\\";\\n\\n// Structs are used here as they do not incur any overhead, and\\n// make the function specifications below less tedious\\n\\nstruct Claim {\\n  uint256 amount;\\n  uint8 tranche;\\n  uint32 expiry;\\n  // This is simply here for reference. Solidity does not have optional params\\n  // and after the London fork, zero bytes are charged more in calldata, so we\\n  // simply leave it out of the struct and add it as an argument where it's\\n  // needed\\n  /* address optionalTarget; */\\n}\\n\\n// ECDSA signature as struct\\nstruct Signature {\\n  uint8 v; // Must be 27 or 28\\n  bytes32 r;\\n  bytes32 s; // Must be small order\\n}\\n\\nfunction hash_claim (\\n  uint chainid,\\n  Claim calldata c,\\n  address target\\n) pure returns (bytes32) {\\n  bytes memory _msg = abi.encodePacked(chainid, c.amount, c.tranche, c.expiry);\\n  if (target != address(0)) {\\n    _msg = abi.encodePacked(_msg, target);\\n  }\\n\\n  return keccak256(_msg);\\n}\\n\\ncontract Claim_Codes {\\n  // Only address able to perform management operations\\n  address public controller;\\n\\n  // Vega vesting contract, which must have this contract registered as an\\n  // issuer for `issue_into_tranche` to work. Marked immutable to assist the\\n  // solidity compiler in inlining\\n  IVesting immutable trusted_vesting_contract;\\n\\n  // Track committed and spent signatures (codes). The next constants are used\\n  // as special placeholders. Note that uninitialised slots in a map always will\\n  // have the default value (eg address 0x0 in this case)\\n  mapping (bytes32 => address) public commitments;\\n  address constant UNCLAIMED_CODE = address(0);\\n  address constant SPENT_CODE = address(1);\\n\\n  // Map issuers to their max allowed spending. We may consider here whether we\\n  // actually care about limiting each issuer (signer) spending or not\\n  mapping (address => uint256) public issuers;\\n\\n  // Allow list of countries that can use claim codes. Mapping uppercase ascii\\n  // ISO 2-letter country codes.\\n  mapping (bytes2 => bool) public allowed_countries;\\n\\n  constructor (address vesting_address) {\\n    trusted_vesting_contract = IVesting(vesting_address);\\n    controller = msg.sender;\\n  }\\n\\n  // To prevent front running on untargeted codes, the user can precommit to the\\n  // S part of the signature (ie. the one-time key)\\n  function commit_untargeted (bytes32 s) external {\\n    require(commitments[s] == UNCLAIMED_CODE);\\n    commitments[s] = msg.sender;\\n  }\\n\\n  // Since solidity/web3 do not support optional arguments, we must have a\\n  // separate function with and without the target argument\\n  function claim_targeted (\\n    Signature calldata sig,\\n    Claim calldata clm,\\n    bytes2 country,\\n    address target\\n  ) external {\\n    _claim(sig, clm, target, country);\\n  }\\n\\n  function claim_untargeted (\\n    Signature calldata sig,\\n    Claim calldata clm,\\n    bytes2 country\\n  ) external {\\n    _claim(sig, clm, address(0), country);\\n  }\\n\\n  function _claim (\\n    Signature calldata sig,\\n    Claim calldata clm,\\n    address target,\\n    bytes2 country\\n  ) internal {\\n    require(clm.expiry > block.timestamp, \\\"Claim code has expired\\\");\\n    require(allowed_countries[country], \\\"Claim code is not available in your country\\\");\\n\\n    // Verify the claim was signed by an issuer\\n    bytes32 hash = hash_claim(block.chainid, clm, target);\\n    address issuer = verify(hash, sig);\\n    require(issuer != address(0), \\\"Invalid claim code\\\");\\n\\n    // Burn the claim\\n    target = burn_claim(sig, target);\\n\\n    require(issuer != target, \\\"Cannot claim to yourself\\\");\\n    uint256 issuer_amount = issuers[issuer];\\n    require(clm.amount <= issuer_amount, \\\"Out of funds\\\");\\n    issuers[issuer] = issuer_amount - clm.amount;\\n\\n    trusted_vesting_contract.issue_into_tranche(target, clm.tranche, clm.amount);\\n  }\\n\\n  function allow_countries (\\n    bytes2[] calldata countries\\n  ) only_controller external {\\n    for (uint i = 0; i < countries.length; i++) {\\n      allowed_countries[countries[i]] = true;\\n    }\\n  }\\n\\n  function block_countries (\\n    bytes2[] calldata countries\\n  ) only_controller external {\\n    for (uint i = 0; i < countries.length; i++) {\\n      allowed_countries[countries[i]] = false;\\n    }\\n  }\\n\\n  function permit_issuer (address issuer, uint256 amount) only_controller external {\\n    issuers[issuer] = amount;\\n  }\\n\\n  function revoke_issuer (address issuer) only_controller external {\\n    delete(issuers[issuer]);\\n  }\\n\\n  function swap_controller(address _controller) only_controller external {\\n    require(_controller != address(0));\\n    controller = _controller;\\n  }\\n\\n  function destroy () only_controller external {\\n    selfdestruct(payable(msg.sender));\\n  }\\n\\n  // Strict ECDSA recovery;\\n  // - Only allow small-order s\\n  // - Only allow correct v encoding (27 or 28)\\n  function verify (\\n    bytes32 hash,\\n    Signature calldata _sig\\n  ) internal pure returns (address) {\\n    if (_sig.s > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) return address(0);\\n    return ecrecover(hash, _sig.v, bytes32(_sig.r), bytes32(_sig.s));\\n  }\\n\\n  function burn_claim (\\n    Signature calldata sig,\\n    address target\\n  ) internal returns (address) {\\n    address _tmp = commitments[sig.s];\\n\\n    // If targeted code, just check that it's unspent\\n    if (target != address(0)) {\\n      require(_tmp != SPENT_CODE, \\\"Claim code already spent\\\");\\n    }\\n    // If untargeted, check that it was committed or unspent\\n    else {\\n      require(_tmp == msg.sender || _tmp == UNCLAIMED_CODE, \\\"Claim code already spent\\\");\\n      target = msg.sender;\\n    }\\n\\n    commitments[sig.s] = SPENT_CODE;\\n    return target;\\n  }\\n\\n  modifier only_controller () {\\n    require(msg.sender == controller);\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"/contracts/IVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IVesting {\\n  function issue_into_tranche (\\n    address user,\\n    uint8 tranche,\\n    uint256 amount\\n  ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 20000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vesting_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes2[]\",\"name\":\"countries\",\"type\":\"bytes2[]\"}],\"name\":\"allow_countries\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes2\",\"name\":\"\",\"type\":\"bytes2\"}],\"name\":\"allowed_countries\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes2[]\",\"name\":\"countries\",\"type\":\"bytes2[]\"}],\"name\":\"block_countries\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Signature\",\"name\":\"sig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tranche\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"expiry\",\"type\":\"uint32\"}],\"internalType\":\"struct Claim\",\"name\":\"clm\",\"type\":\"tuple\"},{\"internalType\":\"bytes2\",\"name\":\"country\",\"type\":\"bytes2\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"claim_targeted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Signature\",\"name\":\"sig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tranche\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"expiry\",\"type\":\"uint32\"}],\"internalType\":\"struct Claim\",\"name\":\"clm\",\"type\":\"tuple\"},{\"internalType\":\"bytes2\",\"name\":\"country\",\"type\":\"bytes2\"}],\"name\":\"claim_untargeted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"commit_untargeted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"commitments\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"issuers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"permit_issuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"}],\"name\":\"revoke_issuer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"swap_controller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Claim_Codes","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"20000","ConstructorArguments":"00000000000000000000000023d1bfe8fa50a167816fbd79d7932577c06011f4","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}