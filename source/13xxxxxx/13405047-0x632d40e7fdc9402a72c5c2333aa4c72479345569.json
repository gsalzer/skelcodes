{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/auctions/timed-edition/limited/LimitedTimedEdition.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport \\\"../BaseEdition.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract LimitedTimedEdition is BaseEdition {\\n    using SafeMath for uint256;\\n\\n    event LotCreated(\\n        uint256 pricePerEdition,\\n        uint256 startTime,\\n        uint256 endTime,\\n        uint256 lotID,\\n        uint256 tokenID,\\n        uint256 auctionID\\n    );\\n\\n    // -----------------------------------------------------------------------\\n    // CONSTRUCTOR\\n    // -----------------------------------------------------------------------\\n\\n    constructor(address _registry, address _timer)\\n        BaseEdition(_registry, _timer)\\n    {}\\n\\n    // -----------------------------------------------------------------------\\n    // NON-STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    function getLotInfo(uint256 _lotID)\\n        external\\n        view\\n        returns (\\n            uint256 tokenID,\\n            address owner,\\n            uint256 price,\\n            uint256 startTime,\\n            uint256 endTime,\\n            bool maxBuyPerTx,\\n            uint256 maxBuy,\\n            uint256 maxSupply,\\n            bool biddable\\n        )\\n    {\\n        tokenID = lots_[_lotID].tokenID;\\n        owner = lots_[_lotID].owner;\\n        price = lotPrices_[_lotID].pricePerEdition;\\n        startTime = lotPrices_[_lotID].startTime;\\n        endTime = lotPrices_[_lotID].endTime;\\n        maxBuy = lotPrices_[_lotID].maxBatchBuy;\\n        maxBuy == 0 ? maxBuyPerTx = false : maxBuyPerTx = true;\\n        maxSupply = lotPrices_[_lotID].maxStock;\\n        biddable = lotPrices_[_lotID].biddable;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // PUBLICLY ACCESSIBLE STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _lotID ID of the new lot auction being created within this\\n     *          auction instance.\\n     * @param   _tokenID ID of the token being sold in the auction type.\\n     * @dev     Only the Auction Hub is able to call this function.\\n     */\\n    function createLot(\\n        uint256 _lotID,\\n        uint256 _tokenID,\\n        uint256 _pricePerEdition,\\n        uint256 _startTimeStamp,\\n        uint256 _endTimeStamp,\\n        bool _maxBuyPerTx,\\n        uint256 _maxBuy,\\n        uint256 _maxSupply\\n    ) external {\\n        require(_pricePerEdition != 0, \\\"Lot price cannot be 0\\\");\\n        require(_startTimeStamp < _endTimeStamp, \\\"End time before start\\\");\\n        require(\\n            _endTimeStamp > getCurrentTime(),\\n            \\\"End time cannot be before current\\\"\\n        );\\n        // If there is a max buy limit per batch buy transaction\\n        if (_maxBuyPerTx) {\\n            lotPrices_[_lotID].maxBatchBuy = _maxBuy;\\n        }\\n        // Storing the price for the lot\\n        lotPrices_[_lotID].pricePerEdition = _pricePerEdition;\\n        lotPrices_[_lotID].startTime = _startTimeStamp;\\n        lotPrices_[_lotID].endTime = _endTimeStamp;\\n        lotPrices_[_lotID].tokenID = _tokenID;\\n        lotPrices_[_lotID].useMaxStock = true;\\n        lotPrices_[_lotID].maxStock = _maxSupply;\\n        // Verifying senders rights to start auction, pulling token from the\\n        // hub, emitting relevant info\\n        _createAuctionLot(_lotID, _tokenID);\\n        // Checks if the start time has passed\\n        if (getCurrentTime() >= _startTimeStamp) {\\n            lotPrices_[_lotID].biddable = true;\\n            auctionHubInstance_.lotAuctionStarted(auctionID_, _lotID);\\n        }\\n\\n         emit LotCreated(\\n            _pricePerEdition,\\n            _startTimeStamp,\\n            _endTimeStamp,\\n            _lotID,\\n              _tokenID,\\n            auctionID_\\n        );\\n    }\\n\\n    /**\\n     * @param   _lotID The ID of the lot\\n     * @notice  This function will revert if the bid amount is not higher than\\n     *          the current highest bid and the min bid price for the lot.\\n     */\\n    function bid(uint256 _lotID, uint256 _editionAmount) external payable {\\n        _bid(_lotID, _editionAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/auctions/timed-edition/BaseEdition.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport \\\"./EditionData.sol\\\";\\nimport \\\"../BaseAuction.sol\\\";\\nimport \\\"../../nft/INft.sol\\\";\\nimport \\\"../../testing-helpers/Testable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract BaseEdition is BaseAuction, EditionData, Testable {\\n    using SafeMath for uint256;\\n\\n    event PurchaseOnLot(\\n        uint256 indexed lotId,\\n        uint256 noPurchased,\\n        address indexed bidder,\\n        uint256 amountPaid\\n    );\\n\\n    // -----------------------------------------------------------------------\\n    // CONSTRUCTOR\\n    // -----------------------------------------------------------------------\\n\\n    constructor(address _registry, address _timer)\\n        BaseAuction(_registry)\\n        EditionData()\\n        Testable(_timer)\\n    {}\\n\\n    /**\\n     * @param   _lotID The lot ID\\n     * @notice  Returns the original token to the owner. Can only be called if\\n     *          the lot has expired.\\n     */\\n    function returnOriginal(uint256 _lotID) external {\\n        require(\\n            lotPrices_[_lotID].endTime <= getCurrentTime(),\\n            \\\"Lot has not expired\\\"\\n        );\\n        _returnOriginalToken(_lotID);\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // INTERNAL STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    function _returnOriginalToken(uint256 _lotID) internal {\\n        nftInstance_.transfer(lots_[_lotID].owner, lots_[_lotID].tokenID);\\n        // Setting on the auction hub that the first sale is completed\\n        auctionHubInstance_.firstSaleCompleted(lots_[_lotID].tokenID);\\n        auctionHubInstance_.lotAuctionCompletedAndClaimed(auctionID_, _lotID);\\n    }\\n\\n    /**\\n     * @param   _lotID The ID of the lot\\n     * @param   _editionAmount How many tokens to buy\\n     * @notice  This function will revert if the bid amount is not higher than\\n     *          the current highest bid and the min bid price for the lot.\\n     */\\n    function _bid(uint256 _lotID, uint256 _editionAmount) internal {\\n        // Will revert if lot is not in biddable state\\n        _isLotInBiddableState(_lotID);\\n        // Checks that lot has started (timestamp checks)\\n        require(_isLotBiddable(_lotID), \\\"Lot has not started or ended\\\");\\n        // Ensures that if there is limited stock, cannot buy more than stock.\\n        if (lotPrices_[_lotID].useMaxStock) {\\n            require(\\n                lotPrices_[_lotID].maxStock >=\\n                    lotPrices_[_lotID].tokensMinted.add(_editionAmount),\\n                \\\"Cannot buy more than max stock\\\"\\n            );\\n        }\\n        // Ensures that if there is a max buy per tx, cannot buy more than max.\\n        if (lotPrices_[_lotID].maxBatchBuy != 0) {\\n            require(\\n                lotPrices_[_lotID].maxBatchBuy >= _editionAmount,\\n                \\\"Cannot buy more than max batch\\\"\\n            );\\n        }\\n        // Getting the cost to buy the desired edition amount\\n        uint256 cost = lotPrices_[_lotID].pricePerEdition.mul(_editionAmount);\\n        // Ensuring sent value is sufficient\\n        require(cost <= msg.value, \\\"Insufficient msg.value\\\");\\n\\n        lotPrices_[_lotID].tokensMinted = lotPrices_[_lotID].tokensMinted.add(\\n            _editionAmount\\n        );\\n\\n        _handlePayment(_lotID, cost);\\n\\n        // All event data will come from the NFT contract\\n        nftInstance_.batchDuplicateMint(\\n            msg.sender,\\n            _editionAmount,\\n            lotPrices_[_lotID].tokenID,\\n            lotPrices_[_lotID].useMaxStock\\n        );\\n\\n        emit PurchaseOnLot(_lotID, _editionAmount, msg.sender, cost);\\n    }\\n\\n    /**\\n     * @param   _lotID The ID of the lot\\n     * @notice  This function will not revert. This function will return false\\n     *          if the lot has not reached the start time, or is passed the end\\n     *          time. This function will return true if the lot is between\\n     *          it's start and end time.\\n     */\\n    function _isLotBiddable(uint256 _lotID) internal returns (bool) {\\n        // If the end time has not passed\\n        if (lotPrices_[_lotID].endTime > getCurrentTime()) {\\n            // If the start time has passed\\n            if (getCurrentTime() >= lotPrices_[_lotID].startTime) {\\n                // If biddable has not been set to true\\n                if (lotPrices_[_lotID].biddable == false) {\\n                    // Setting the auction to active on the hub\\n                    auctionHubInstance_.lotAuctionStarted(auctionID_, _lotID);\\n                    lotPrices_[_lotID].biddable = true;\\n                }\\n                // Start time has passed\\n                return true;\\n            }\\n            // Start time has not passed\\n            return false;\\n        } else {\\n            // If end time has passed lot is set to not biddable\\n            lotPrices_[_lotID].biddable = false;\\n            // Lot status updated on hub to complete \\n            auctionHubInstance_.lotAuctionCompleted(auctionID_, _lotID);\\n            return false;\\n        }\\n    }\\n\\n    function _handlePayment(uint256 _lotID, uint256 _totalCollateralAmount)\\n        internal\\n    {\\n        require(\\n            auctionHubInstance_.isFirstSale(lots_[_lotID].tokenID),\\n            \\\"Not first sale\\\"\\n        );\\n        // Temporary storage for splits and shares\\n        uint256 creatorSplit;\\n        uint256 systemSplit;\\n        uint256 creatorShare;\\n        uint256 systemShare;\\n        // Getting the split for the\\n        (creatorSplit, systemSplit) = auctionHubInstance_.getFirstSaleSplit();\\n        // Working out the creators share according to the split\\n        creatorShare = _totalCollateralAmount.mul(creatorSplit).div(\\n            SPLIT_SCALING_FACTOR\\n        );\\n        // Working out the systems share according to the split\\n        systemShare = _totalCollateralAmount.mul(systemSplit).div(\\n            SPLIT_SCALING_FACTOR\\n        );\\n        require(\\n            creatorShare.add(systemShare) <= _totalCollateralAmount,\\n            \\\"BAU: Fatal: value mismatch\\\"\\n        );\\n        // Depositing creator share\\n        royaltiesInstance_.deposit{value: creatorShare}(\\n            nftInstance_.creatorOf(lots_[_lotID].tokenID),\\n            creatorShare\\n        );\\n        // Depositing the system share\\n        royaltiesInstance_.deposit{value: systemShare}(address(0), systemShare);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/auctions/timed-edition/EditionData.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract EditionData {\\n    using SafeMath for uint256;\\n\\n    // -----------------------------------------------------------------------\\n    // STATE VARIABLES\\n    // -----------------------------------------------------------------------\\n\\n    // Storage for each lots price\\n    struct LotPrice {\\n        uint256 pricePerEdition; // The cost per token\\n        uint256 maxBatchBuy; // The max amount of tokens per TX\\n        uint256 tokenID;\\n        uint256 startTime;\\n        uint256 endTime;\\n        bool biddable;\\n        bool useMaxStock;\\n        uint256 maxStock;\\n        uint256 tokensMinted;\\n    }\\n    // Lot ID's to price\\n    mapping(uint256 => LotPrice) internal lotPrices_;\\n}\\n\"\r\n    },\r\n    \"contracts/auctions/BaseAuction.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport \\\"./IHub.sol\\\";\\nimport \\\"./IAuction.sol\\\";\\nimport \\\"../nft/INft.sol\\\";\\nimport \\\"../registry/Registry.sol\\\";\\nimport \\\"../royalties/IRoyalties.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\nabstract contract BaseAuction is IAuction, ReentrancyGuard {\\n    // Libraries\\n    using SafeMath for uint256;\\n\\n    // -----------------------------------------------------------------------\\n    // STATE VARIABLES\\n    // -----------------------------------------------------------------------\\n\\n    // Instance of the registry\\n    Registry internal registryInstance_;\\n    // Instance of the auction Hub\\n    IHub internal auctionHubInstance_;\\n    // Instance of the NFT contract being used (modified ERC1155)\\n    INft internal nftInstance_;\\n    // Instance of the royalties contract\\n    IRoyalties internal royaltiesInstance_;\\n    // ID of this auction instance\\n    uint256 internal auctionID_;\\n    // Bool check to ensure that the auction can only be initialised once.\\n    // Variable is private so it cannot be changed in child contracts, and\\n    // can only be set once on initialisation\\n    bool private isInit_;\\n\\n    struct Lot {\\n        address owner;\\n        uint256 tokenID;\\n        bool biddingStarted;\\n    }\\n\\n    mapping(uint256 => Lot) internal lots_;\\n\\n    uint256 internal constant SPLIT_SCALING_FACTOR = 10000;\\n\\n    // -----------------------------------------------------------------------\\n    // EVENTS\\n    // -----------------------------------------------------------------------\\n\\n    event Initialised(address auctionHub, uint256 auctionID);\\n\\n    event AuctionLotCreated(\\n        address indexed creator,\\n        uint256 auctionID,\\n        uint256 lotID,\\n        uint256 tokenID\\n    );\\n\\n    event LotWinner(\\n        uint256 indexed auctionID,\\n        uint256 indexed lotID,\\n        address indexed winner\\n    );\\n\\n    event LotLoserClaim(\\n        uint256 indexed auctionID,\\n        uint256 indexed lotID,\\n        address indexed claimer,\\n        uint256 claimAmount\\n    );\\n\\n    // -----------------------------------------------------------------------\\n    // MODIFIERS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @notice  A modifier to restrict access to only the auction hub\\n     */\\n    modifier onlyHub() {\\n        require(\\n            msg.sender == address(auctionHubInstance_),\\n            \\\"Access restricted to Hub\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice  A modifier to protect the initialisation call so that an auction\\n     *          can only be initialised once\\n     */\\n    modifier initialise() {\\n        require(isInit_ == false, \\\"Auction has already been init\\\");\\n        _;\\n    }\\n\\n    modifier onlyActive() {\\n        require(\\n            isInit_ && auctionHubInstance_.isAuctionActive(auctionID_),\\n            \\\"Auction not in valid use state\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyLotOwner(uint256 _lotID) {\\n        address owner;\\n        (owner, , , ) = auctionHubInstance_.getLotInformation(_lotID);\\n        // Ensuring the lot information is correct\\n        require(owner == msg.sender, \\\"Creator must own token\\\");\\n        _;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // CONSTRUCTOR\\n    // -----------------------------------------------------------------------\\n\\n    constructor(address _registryInstance) {\\n        registryInstance_ = Registry(_registryInstance);\\n        auctionHubInstance_ = IHub(registryInstance_.getHub());\\n        nftInstance_ = INft(registryInstance_.getNft());\\n        royaltiesInstance_ = IRoyalties(registryInstance_.getRoyalties());\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // NON-MODIFYING FUNCTIONS (VIEW)\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @return  bool The active status of the auction. Will only return true if\\n     *          the auction has been initialised and is active.\\n     */\\n    function isActive() external view override returns (bool) {\\n        if (isInit_ && auctionHubInstance_.isAuctionActive(auctionID_)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @param   _lotID The ID of the lot.\\n     * @return  bool If bidding has started on the lot.\\n     */\\n    function hasBiddingStarted(uint256 _lotID) external view override returns (bool) {\\n        return lots_[_lotID].biddingStarted;\\n    }\\n\\n    /**\\n     * @return  uint256 The auction ID as set by the auction hub of this\\n     *          auction.\\n     */\\n    function getAuctionID() external view override returns (uint256) {\\n        return auctionID_;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // ONLY AUCTION HUB STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _auctionID ID of the auction this auction is\\n     * @dev     This call will be protected so only the Auction hub can call it.\\n     *          This function will also set the auction state to active.\\n     */\\n    function init(uint256 _auctionID)\\n        external\\n        override\\n        onlyHub()\\n        initialise()\\n        returns (bool)\\n    {\\n        auctionID_ = _auctionID;\\n        isInit_ = true;\\n\\n        emit Initialised(msg.sender, _auctionID);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @param   _lotID ID of the lot\\n     * @dev     Transfers the token from the auction back to the lot requester\\n     */\\n    function cancelLot(uint256 _lotID) external override onlyHub() {\\n        // Transferring the token to the lot owner\\n        nftInstance_.transfer(lots_[_lotID].owner, lots_[_lotID].tokenID);\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // INTERNAL STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _lotID ID of the new lot auction being created within this\\n     *          auction instance.\\n     * @param   _tokenID ID of the token being sold in the auction type.\\n     * @dev     Only the Auction Hub is able to call this function.\\n     */\\n    function _createAuctionLot(uint256 _lotID, uint256 _tokenID) internal {\\n        // Getting the relevant lot information\\n        address owner;\\n        uint256 tokenID;\\n        uint256 auctionID;\\n        IHub.LotStatus status;\\n        (owner, tokenID, auctionID, status) = auctionHubInstance_\\n        .getLotInformation(_lotID);\\n        // Ensuring the lot information is correct\\n        require(owner == msg.sender, \\\"Creator must own token\\\");\\n        require(tokenID == _tokenID, \\\"Given lot ID mismatch token lot\\\");\\n        require(auctionID == auctionID_, \\\"Lot on different auction\\\");\\n        require(status == IHub.LotStatus.LOT_REQUESTED, \\\"Lot status incorrect\\\");\\n        // Storing the lot information\\n        lots_[_lotID].owner = owner;\\n        lots_[_lotID].tokenID = tokenID;\\n        // Updating the Lot's status to created\\n        auctionHubInstance_.lotCreated(auctionID_, _lotID);\\n        // Transferring the token to this auction\\n        nftInstance_.transferFrom(\\n            address(auctionHubInstance_),\\n            address(this),\\n            tokenID\\n        );\\n\\n        emit AuctionLotCreated(msg.sender, auctionID, _lotID, tokenID);\\n    }\\n\\n    /**\\n     * @param   _lotID The ID of the lot\\n     * @notice  This function will revert if the lot is not in the created\\n     *          state or active state. Will also revert if the state is\\n     *          canceled.\\n     */\\n    function _isLotInBiddableState(uint256 _lotID) internal {\\n        IHub.LotStatus status;\\n        (, , , status) = auctionHubInstance_.getLotInformation(_lotID);\\n        require(\\n            (status != IHub.LotStatus.AUCTION_CANCELED &&\\n                status == IHub.LotStatus.LOT_CREATED) ||\\n                status == IHub.LotStatus.AUCTION_ACTIVE,\\n            \\\"Bid has ended or canceled\\\"\\n        );\\n        \\n        if(!lots_[_lotID].biddingStarted) {\\n            lots_[_lotID].biddingStarted = true;\\n        }\\n    }\\n\\n    /**\\n     * @param   _lotID The ID of the lot\\n     * @param   _winner The address of the lot winner\\n     * @notice  Shared functionality that all the auctions will need for\\n     *          executing the needed winning functionality.\\n     */\\n    function _winner(uint256 _lotID, address _winner) internal {\\n        // Sending the winner their token\\n        nftInstance_.transfer(_winner, lots_[_lotID].tokenID);\\n        // Setting the lot to completed on the hub\\n        auctionHubInstance_.lotAuctionCompletedAndClaimed(auctionID_, _lotID);\\n        // Emitting that the lot has been resolved\\n        emit LotWinner(auctionID_, _lotID, msg.sender);\\n    }\\n\\n    /**\\n     * @param   _loserAddress Address of loser\\n     * @param   _bidAmount The amount that was bid\\n     * @notice  This function transfers the loser their bid amount. NOTE not all\\n     *          auction types will use this function, which is why it does no\\n     *          data validation.\\n     */\\n    function _insecureLoser(\\n        uint256 lotID,\\n        address _loserAddress,\\n        uint256 _bidAmount\\n    ) internal {\\n        // Sending loser amount\\n        (bool success, ) = _loserAddress.call{value: _bidAmount}(\\\"\\\");\\n        // Ensuring transfer succeeded\\n        require(success, \\\"Transfer failed.\\\");\\n\\n        emit LotLoserClaim(auctionID_, lotID, _loserAddress, _bidAmount);\\n    }\\n\\n    /**\\n     * @param   _lotID The ID of the lot\\n     * @param   _totalCollateralAmount The total amount of collateral that was\\n     *          bid.\\n     * @notice  This function will call first or secondary payment functions\\n     *          as needed.\\n     */\\n    function _insecureHandlePayment(\\n        uint256 _lotID,\\n        uint256 _totalCollateralAmount\\n    ) internal {\\n        if (auctionHubInstance_.isFirstSale(lots_[_lotID].tokenID)) {\\n            _handleFirstSalePayment(_lotID, _totalCollateralAmount);\\n        } else {\\n            _insecureHandleSecondarySalesPayment(\\n                _lotID,\\n                _totalCollateralAmount\\n            );\\n        }\\n    }\\n\\n    function _handleFirstSalePayment(\\n        uint256 _lotID,\\n        uint256 _totalCollateralAmount\\n    ) internal {\\n        require(\\n            auctionHubInstance_.isFirstSale(lots_[_lotID].tokenID),\\n            \\\"Not first sale\\\"\\n        );\\n        // Temporary storage for splits and shares\\n        uint256 creatorSplit;\\n        uint256 systemSplit;\\n        uint256 creatorShare;\\n        uint256 systemShare;\\n        // Getting the split for the\\n        (creatorSplit, systemSplit) = auctionHubInstance_.getFirstSaleSplit();\\n        // Working out the creators share according to the split\\n        creatorShare = _totalCollateralAmount.mul(creatorSplit).div(\\n            SPLIT_SCALING_FACTOR\\n        );\\n        // Working out the systems share according to the split\\n        systemShare = _totalCollateralAmount.mul(systemSplit).div(\\n            SPLIT_SCALING_FACTOR\\n        );\\n        require(\\n            creatorShare.add(systemShare) <= _totalCollateralAmount,\\n            \\\"BAU: Fatal: value mismatch\\\"\\n        );\\n        // Depositing creator share\\n        royaltiesInstance_.deposit{value: creatorShare}(\\n            nftInstance_.creatorOf(lots_[_lotID].tokenID),\\n            creatorShare\\n        );\\n        // Depositing the system share\\n        royaltiesInstance_.deposit{value: systemShare}(address(0), systemShare);\\n        // Setting on the auction hub that the first sale is completed\\n        auctionHubInstance_.firstSaleCompleted(lots_[_lotID].tokenID);\\n    }\\n\\n    function _insecureHandleSecondarySalesPayment(\\n        uint256 _lotID,\\n        uint256 _totalCollateralAmount\\n    ) internal {\\n        require(\\n            !auctionHubInstance_.isFirstSale(lots_[_lotID].tokenID),\\n            \\\"Not secondary sale\\\"\\n        );\\n        // Temporary storage for splits and shares\\n        uint256 creatorSplit;\\n        uint256 sellerSplit;\\n        uint256 systemSplit;\\n        uint256 creatorShare;\\n        uint256 sellerShare;\\n        uint256 systemShare;\\n        // Getting the split for the\\n        (creatorSplit, sellerSplit, systemSplit) = auctionHubInstance_\\n        .getSecondarySaleSplits();\\n        // Working out the creators share according to the split\\n        creatorShare = _totalCollateralAmount.mul(creatorSplit).div(\\n            SPLIT_SCALING_FACTOR\\n        );\\n        // Working out the sellers share according to the split\\n        sellerShare = _totalCollateralAmount.mul(sellerSplit).div(\\n            SPLIT_SCALING_FACTOR\\n        );\\n        // Working out the systems share according to the split\\n        systemShare = _totalCollateralAmount.mul(systemSplit).div(\\n            SPLIT_SCALING_FACTOR\\n        );\\n        // Depositing creator share\\n        royaltiesInstance_.deposit{value: creatorShare}(\\n            nftInstance_.creatorOf(lots_[_lotID].tokenID),\\n            creatorShare\\n        );\\n        // Depositing the system share\\n        royaltiesInstance_.deposit{value: systemShare}(address(0), systemShare);\\n        // Sending user amount\\n        (bool success, ) = lots_[_lotID].owner.call{value: sellerShare}(\\\"\\\");\\n        // Ensuring transfer succeeded\\n        require(success, \\\"Transfer failed.\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/nft/INft.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\ninterface INft {\\n\\n    // -----------------------------------------------------------------------\\n    // NON-MODIFYING FUNCTIONS (VIEW)\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _tokenID The ID of the token\\n     * @return  address of the owner for this token  \\n     */\\n    function ownerOf(uint256 _tokenID) external view returns(address);\\n\\n    /**\\n     * @param   _tokenID The ID of the token\\n     * @return  address of the creator of the token\\n     */\\n    function creatorOf(uint256 _tokenID) external view returns(address);\\n\\n    /**\\n     * @param   _owner The address of the address to check\\n     * @return  uint256 The number of tokens the user owns\\n     */\\n    function balanceOf(address _owner) external view returns(uint256);\\n\\n    /**\\n     * @return  uint256 The total number of circulating tokens\\n     */\\n    function totalSupply() external view returns(uint256);\\n\\n    /**\\n     * @param   _owner Address of the owner\\n     * @param   _spender The address of the spender\\n     * @param   _tokenID ID of the token to check\\n     * @return  bool The approved status of the spender against the owner\\n     */\\n    function isApprovedSpenderOf(\\n        address _owner, \\n        address _spender, \\n        uint256 _tokenID\\n    )\\n        external\\n        view\\n        returns(bool);\\n\\n    /**\\n     * @param   _minter Address of the minter being checked\\n     * @return  isMinter If the minter has the minter role\\n     * @return  isActiveMinter If the minter is an active minter \\n     */\\n    function isMinter(\\n        address _minter\\n    ) \\n        external \\n        view \\n        returns(\\n            bool isMinter, \\n            bool isActiveMinter\\n        );\\n\\n    function isActive() external view returns(bool);\\n\\n    function isTokenBatch(uint256 _tokenID) external view returns(uint256);\\n\\n    function getBatchInfo(\\n        uint256 _batchID\\n    ) \\n        external \\n        view\\n        returns(\\n            uint256 baseTokenID,\\n            uint256[] memory tokenIDs,\\n            bool limitedStock,\\n            uint256 totalMinted\\n        );\\n\\n    // -----------------------------------------------------------------------\\n    // PUBLIC STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _spender The address of the spender\\n     * @param   _tokenID ID of the token to check\\n     * @param   _approvalSpender The status of the spenders approval on the \\n     *          owner\\n     * @notice  Will revert if msg.sender is the spender or if the msg.sender\\n     *          is not the owner of the token.\\n     */\\n    function approveSpender(\\n        address _spender,\\n        uint256 _tokenID,\\n        bool _approvalSpender\\n    )\\n        external;\\n\\n    // -----------------------------------------------------------------------\\n    //  ONLY AUCTIONS (hub or spokes) STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _to Address of receiver \\n     * @param   _tokenID Token to transfer\\n     * @notice  Only auctions (hub or spokes) will be able to transfer tokens.\\n     *          Will revert if to address is the 0x address. Will revert if the \\n     *          msg.sender is not the token owner. Will revert if msg.sender is\\n     *          to to address\\n     */\\n    function transfer(\\n        address _to,\\n        uint256 _tokenID\\n    )\\n        external;\\n\\n    /**\\n     * @param   _to Address to transfer to\\n     * @param   _tokenIDs Array of tokens being transferred\\n     * @notice  Only auctions (hub or spokes) will be able to transfer tokens.\\n     *          Will revert if to address is the 0x address. Will revert if the \\n     *          msg.sender is not the token owner. Will revert if msg.sender is\\n     *          to to address\\n     */\\n    function batchTransfer(\\n        address _to,\\n        uint256[] memory _tokenIDs\\n    )\\n        external;\\n\\n    /**\\n     * @param   _from Address being transferee from \\n     * @param   _to Address to transfer to\\n     * @param   _tokenID ID of token being transferred\\n     * @notice  Only auctions (hub or spokes) will be able to transfer tokens.\\n     *          Will revert if to address is the 0x address. Will revert if\\n     *          msg.sender is not approved spender of token on _from address.\\n     *          Will revert if the _from is not the token owner. Will revert if \\n     *          _from is _to address.\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _tokenID\\n    )\\n        external;\\n\\n    /**\\n     * @param   _from Address being transferee from \\n     * @param   _to Address to transfer to\\n     * @param   _tokenIDs Array of tokens being transferred\\n     * @notice  Only auctions (hub or spokes) will be able to transfer tokens.\\n     *          Will revert if to address is the 0x address. Will revert if\\n     *          msg.sender is not approved spender of token on _from address.\\n     *          Will revert if the _from is not the token owner. Will revert if \\n     *          _from is _to address.\\n     */\\n    function batchTransferFrom(\\n        address _from,\\n        address _to,\\n        uint256[] memory _tokenIDs\\n    )\\n        external;\\n\\n    // -----------------------------------------------------------------------\\n    // ONLY MINTER STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    /**\\n     * @param   _tokenCreator Address of the creator. Address will receive the \\n     *          royalties from sales of the NFT\\n     * @param   _mintTo The address that should receive the token. Note that on\\n     *          the initial sale this address will not receive the sale \\n     *          collateral. Sale collateral will be distributed to creator and\\n     *          system fees\\n     * @notice  Only valid active minters will be able to mint new tokens\\n     */\\n    function mint(\\n        address _tokenCreator, \\n        address _mintTo,\\n        string calldata identifier,      \\n        string calldata location,\\n        bytes32 contentHash \\n    ) external returns(uint256);\\n\\n    /**\\n     * @param   _mintTo The address that should receive the token. Note that on\\n     *          the initial sale this address will not receive the sale \\n     *          collateral. Sale collateral will be distributed to creator and\\n     *          system fees\\n     * @param   _amount Amount of tokens to mint\\n     * @param   _baseTokenID ID of the token being duplicated\\n     * @param   _isLimitedStock Bool for if the batch has a pre-set limit\\n     */\\n    function batchDuplicateMint(\\n        address _mintTo,\\n        uint256 _amount,\\n        uint256 _baseTokenID,\\n        bool _isLimitedStock\\n    )\\n        external\\n        returns(uint256[] memory);\\n}\"\r\n    },\r\n    \"contracts/testing-helpers/Testable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.6.0 < 0.8.0;\\n\\nimport \\\"./Timer.sol\\\";\\n\\n/**\\n * @title Base class that provides time overrides, but only if being run in test mode.\\n */\\nabstract contract Testable {\\n    // If the contract is being run on the test network, then `timerAddress` will be the 0x0 address.\\n    // Note: this variable should be set on construction and never modified.\\n    address public timerAddress;\\n\\n    /**\\n     * @notice Constructs the Testable contract. Called by child contracts.\\n     * @param _timerAddress Contract that stores the current time in a testing environment.\\n     * Must be set to 0x0 for production environments that use live time.\\n     */\\n    constructor(address _timerAddress) internal {\\n        timerAddress = _timerAddress;\\n    }\\n\\n    /**\\n     * @notice Reverts if not running in test mode.\\n     */\\n    modifier onlyIfTest {\\n        require(timerAddress != address(0x0));\\n        _;\\n    }\\n\\n    /**\\n     * @notice Sets the current time.\\n     * @dev Will revert if not running in test mode.\\n     * @param time timestamp to set current Testable time to.\\n     */\\n    function setCurrentTime(uint256 time) external onlyIfTest {\\n        Timer(timerAddress).setCurrentTime(time);\\n    }\\n\\n    /**\\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\\n     * Otherwise, it will return the block timestamp.\\n     * @return uint for the current Testable timestamp.\\n     */\\n    function getCurrentTime() public view returns (uint256) {\\n        if (timerAddress != address(0x0)) {\\n            return Timer(timerAddress).getCurrentTime();\\n        } else {\\n            return block.timestamp;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/auctions/IHub.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\ninterface IHub {\\n    enum LotStatus {\\n        NO_LOT,\\n        LOT_REQUESTED,\\n        LOT_CREATED,\\n        AUCTION_ACTIVE,\\n        AUCTION_RESOLVED,\\n        AUCTION_RESOLVED_AND_CLAIMED,\\n        AUCTION_CANCELED\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // NON-MODIFYING FUNCTIONS (VIEW)\\n    // -----------------------------------------------------------------------\\n\\n    function getLotInformation(uint256 _lotID)\\n        external\\n        view\\n        returns (\\n            address owner,\\n            uint256 tokenID,\\n            uint256 auctionID,\\n            LotStatus status\\n        );\\n\\n    function getAuctionInformation(uint256 _auctionID)\\n        external\\n        view\\n        returns (\\n            bool active,\\n            string memory auctionName,\\n            address auctionContract,\\n            bool onlyPrimarySales\\n        );\\n\\n    function getAuctionID(address _auction) external view returns (uint256);\\n\\n    function isAuctionActive(uint256 _auctionID) external view returns (bool);\\n\\n    function getAuctionCount() external view returns (uint256);\\n\\n    function isAuctionHubImplementation() external view returns (bool);\\n\\n    function isFirstSale(uint256 _tokenID) external view returns (bool);\\n\\n    function getFirstSaleSplit()\\n        external\\n        view\\n        returns (uint256 creatorSplit, uint256 systemSplit);\\n\\n    function getSecondarySaleSplits()\\n        external\\n        view\\n        returns (\\n            uint256 creatorSplit,\\n            uint256 sellerSplit,\\n            uint256 systemSplit\\n        );\\n\\n    function getScalingFactor() external view returns (uint256);\\n\\n    // -----------------------------------------------------------------------\\n    // PUBLIC STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    function requestAuctionLot(uint256 _auctionType, uint256 _tokenID)\\n        external\\n        returns (uint256 lotID);\\n\\n    // -----------------------------------------------------------------------\\n    // ONLY AUCTIONS STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    function firstSaleCompleted(uint256 _tokenID) external;\\n\\n    function lotCreated(uint256 _auctionID, uint256 _lotID) external;\\n\\n    function lotAuctionStarted(uint256 _auctionID, uint256 _lotID) external;\\n\\n    function lotAuctionCompleted(uint256 _auctionID, uint256 _lotID) external;\\n\\n    function lotAuctionCompletedAndClaimed(uint256 _auctionID, uint256 _lotID)\\n        external;\\n\\n    function cancelLot(uint256 _auctionID, uint256 _lotID) external;\\n\\n    // -----------------------------------------------------------------------\\n    // ONLY REGISTRY STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    function init() external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/auctions/IAuction.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\ninterface IAuction {\\n    /**\\n     * @return  bool The active status of the auction. Will only return true if\\n     *          the auction has been initialised and is active.\\n     */\\n    function isActive() external view returns (bool);\\n\\n    /**\\n     * @param   _lotID The ID of the lot.\\n     * @return  bool If bidding has started on the lot.\\n     */\\n    function hasBiddingStarted(uint256 _lotID) external view returns (bool);\\n\\n    /**\\n     * @return  uint256 The auction ID as set by the auction hub of this\\n     *          auction.\\n     */\\n    function getAuctionID() external view returns (uint256);\\n\\n    /**\\n     * @param   _auctionID ID of the auction this auction is\\n     * @dev     This call will be protected so only the Auction hub can call it.\\n     *          This function will also set the auction state to active.\\n     */\\n    function init(uint256 _auctionID) external returns (bool);\\n\\n    /**\\n     * @param   _lotID ID of the lot\\n     * @dev     Transfers the token from the auction back to the lot requester\\n     */\\n    function cancelLot(uint256 _lotID) external;\\n}\\n\"\r\n    },\r\n    \"contracts/registry/Registry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n// Registry managed contracts\\nimport \\\"../auctions/IHub.sol\\\";\\nimport \\\"../royalties/IRoyalties.sol\\\";\\nimport \\\"../nft/INft.sol\\\";\\n\\ncontract Registry is Ownable, ReentrancyGuard {\\n    // -----------------------------------------------------------------------\\n    // STATE\\n    // -----------------------------------------------------------------------\\n\\n    // Storage of current hub instance\\n    IHub internal hubInstance_;\\n    // Storage of current royalties instance\\n    IRoyalties internal royaltiesInstance_;\\n    // Storage of NFT contract (cannot be changed)\\n    INft internal nftInstance_;\\n\\n    // -----------------------------------------------------------------------\\n    // CONSTRUCTOR\\n    // -----------------------------------------------------------------------\\n\\n    constructor(address _nft) Ownable() {\\n        require(INft(_nft).isActive(), \\\"REG: Address invalid NFT\\\");\\n        nftInstance_ = INft(_nft);\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    // NON-MODIFYING FUNCTIONS (VIEW)\\n    // -----------------------------------------------------------------------\\n\\n    function getHub() external view returns (address) {\\n        return address(hubInstance_);\\n    }\\n\\n    function getRoyalties() external view returns (address) {\\n        return address(royaltiesInstance_);\\n    }\\n\\n    function getNft() external view returns (address) {\\n        return address(nftInstance_);\\n    }\\n\\n    function isActive() external view returns (bool) {\\n        return true;\\n    }\\n\\n    // -----------------------------------------------------------------------\\n    //  ONLY OWNER STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    function updateHub(address _newHub) external onlyOwner nonReentrant {\\n        IHub newHub = IHub(_newHub);\\n        require(_newHub != address(0), \\\"REG: cannot set HUB to 0x\\\");\\n        require(\\n            address(hubInstance_) != _newHub,\\n            \\\"REG: Cannot set HUB to existing\\\"\\n        );\\n        require(\\n            newHub.isAuctionHubImplementation(),\\n            \\\"REG: HUB implementation error\\\"\\n        );\\n        require(IHub(_newHub).init(), \\\"REG: HUB could not be init\\\");\\n        hubInstance_ = IHub(_newHub);\\n    }\\n\\n    function updateRoyalties(address _newRoyalties)\\n        external\\n        onlyOwner\\n        nonReentrant\\n    {\\n        require(_newRoyalties != address(0), \\\"REG: cannot set ROY to 0x\\\");\\n        require(\\n            address(royaltiesInstance_) != _newRoyalties,\\n            \\\"REG: Cannot set ROY to existing\\\"\\n        );\\n        require(IRoyalties(_newRoyalties).init(), \\\"REG: ROY could not be init\\\");\\n        royaltiesInstance_ = IRoyalties(_newRoyalties);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/royalties/IRoyalties.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.7.5;\\n\\ninterface IRoyalties {\\n    // -----------------------------------------------------------------------\\n    // NON-MODIFYING FUNCTIONS (VIEW)\\n    // -----------------------------------------------------------------------\\n\\n    function getBalance(address _user) external view returns (uint256);\\n\\n    function getCollateral() external view returns (address);\\n\\n    // -----------------------------------------------------------------------\\n    // PUBLIC STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    function deposit(address _to, uint256 _amount) external payable;\\n\\n    function withdraw(uint256 _amount) external payable;\\n\\n    // -----------------------------------------------------------------------\\n    // ONLY REGISTRY STATE MODIFYING FUNCTIONS\\n    // -----------------------------------------------------------------------\\n\\n    function init() external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/testing-helpers/Timer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.6.0 < 0.8.0;\\n\\n/**\\n * @title Universal store of current contract time for testing environments.\\n */\\ncontract Timer {\\n    uint256 private currentTime;\\n\\n    constructor() public {\\n        currentTime = block.timestamp; \\n    }\\n\\n    /**\\n     * @notice Sets the current time.\\n     * @dev Will revert if not running in test mode.\\n     * @param time timestamp to set `currentTime` to.\\n     */\\n    function setCurrentTime(uint256 time) external {\\n        currentTime = time;\\n    }\\n\\n    /**\\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\\n     * Otherwise, it will return the block timestamp.\\n     * @return uint256 for the current Testable timestamp.\\n     */\\n    function getCurrentTime() public view returns (uint256) {\\n        return currentTime;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_timer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lotID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"AuctionLotCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"auctionHub\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionID\",\"type\":\"uint256\"}],\"name\":\"Initialised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pricePerEdition\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lotID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionID\",\"type\":\"uint256\"}],\"name\":\"LotCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"}],\"name\":\"LotLoserClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"LotWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"lotId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"noPurchased\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPaid\",\"type\":\"uint256\"}],\"name\":\"PurchaseOnLot\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_editionAmount\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotID\",\"type\":\"uint256\"}],\"name\":\"cancelLot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pricePerEdition\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTimeStamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTimeStamp\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_maxBuyPerTx\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_maxBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"}],\"name\":\"createLot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuctionID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotID\",\"type\":\"uint256\"}],\"name\":\"getLotInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"maxBuyPerTx\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"biddable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotID\",\"type\":\"uint256\"}],\"name\":\"hasBiddingStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_auctionID\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotID\",\"type\":\"uint256\"}],\"name\":\"returnOriginal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setCurrentTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LimitedTimedEdition","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000005c446ab1443dfb034cb06bcc231e5befe36af2ba0000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}