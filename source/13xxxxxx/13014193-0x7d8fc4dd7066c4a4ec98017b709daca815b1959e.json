{"status":"1","message":"OK","result":[{"SourceCode":"{\"Isolde.sol\":{\"content\":\"pragma solidity ^0.8.6;\\n\\n// SPDX-License-Identifier: Apache-2.0\\n\\nimport \\\"./UniswapRouter.sol\\\";\\nimport \\\"./Subscription.sol\\\";\\n\\ncontract Isolde {\\n    \\n    modifier onlyOwner {\\n        require(msg.sender == _owner, \\\"caller is not the owner\\\");\\n        _;\\n    }\\n    \\n    // events\\n    event WinnerSelected(address winner);\\n\\n    // router\\n    IUniswapV2Router public router;\\n    \\n    // addresses \\u0026 fees\\n    uint public platformFee = 30;\\n    address private DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD; \\n    address public token;\\n    address payable public treasury;\\n    address private _owner;\\n    \\n    // tiering\\n    uint private TIER_MULTIPLIER = 5;\\n    Subscription.Tier[] private _tiers;\\n    \\n    // subs\\n    address[] private _subs;\\n    mapping (address =\\u003e Subscription.Subscriber) private _subsMap;\\n    uint public lastSubTime = block.timestamp;\\n\\n    \\n    constructor (address routerAddress, address tokenAddress, address payable treasuryAddress) {\\n        _owner = msg.sender;\\n        \\n        router = IUniswapV2Router(routerAddress);\\n        token = tokenAddress;\\n        treasury = treasuryAddress;\\n    }\\n    \\n    function getSubCount() public view returns (uint256) {\\n        return _subs.length;\\n    }\\n    \\n    function setTiers(Subscription.Tier[] memory tiers) public onlyOwner {\\n        delete _tiers;\\n        \\n        for (uint i = 0; i \\u003c tiers.length; ++i) {\\n            Subscription.Tier memory tier = tiers[i];\\n            _tiers.push(Subscription.Tier(tier.name, tier.level, tier.price));\\n        }\\n    }\\n\\n    function getTiers() public view returns (Subscription.Tier[] memory) {\\n        return _tiers;\\n    }\\n    \\n    function viewTier(uint level) public view returns (string memory, uint, uint) {\\n        require(level \\u003e 0 \\u0026\\u0026 level \\u003c= _tiers.length, \\u0027wrong tier\\u0027);\\n        Subscription.Tier memory tier = _tiers[level - 1];\\n        return (tier.name, tier.level, tier.price);\\n    }\\n    \\n    function viewSub(address wallet) public view returns (address, uint, uint) {\\n        Subscription.Subscriber memory sub = _subsMap[wallet];\\n        return (sub.wallet, sub.tier, sub.expiration);\\n    }\\n    \\n    function getSubs() public view returns (address[] memory) {\\n        return _subs;\\n    }\\n    \\n    function _viewSub(address wallet) internal view returns (Subscription.Subscriber memory) {\\n        return _subsMap[wallet];\\n    }\\n    \\n    function subscribe(address who, uint level) public payable { // since who isn\\u0027t msg.sender someone can possibly gift a subscribtion\\n        require(level \\u003e 0 \\u0026\\u0026 level \\u003c= _tiers.length, \\u0027wrong tier\\u0027);\\n        require(msg.value == _tiers[level - 1].price, \\u0027sent ether is different from tier price\\u0027);\\n        \\n        Subscription.Subscriber memory sub = _subsMap[who];\\n        \\n        require(level \\u003e= sub.tier, \\u0027tier downgrade is not allowed\\u0027);\\n        \\n        uint extraTime = 0; // in seconds;\\n        \\n        if (sub.tier == level) {\\n            extraTime = sub.expiration - block.timestamp;\\n        } else if (sub.expiration \\u003e block.timestamp) { // sub.expiration defaults to 0 for new subscribers\\n            extraTime = _convertRemaining(sub, level);\\n        }\\n\\n        uint expiration = block.timestamp + (30 days) + extraTime;\\n        \\n        sub = Subscription.Subscriber(who, level, expiration);\\n        \\n        if (_subsMap[who].wallet == address(0)) {\\n            _subs.push(who);\\n        }\\n        \\n        _subsMap[who] = sub;\\n        \\n        lastSubTime = block.timestamp;\\n    }\\n    \\n    function giftSubscription(address who, uint level) public onlyOwner {\\n        require(level \\u003e 0 \\u0026\\u0026 level \\u003c= _tiers.length, \\u0027wrong tier\\u0027);\\n        require(_subsMap[who].wallet == address(0), \\u0027user is already subscribed\\u0027);\\n        \\n        uint expiration = block.timestamp + (30 days);\\n        \\n        Subscription.Subscriber memory sub = Subscription.Subscriber(who, level, expiration);\\n        \\n        _subs.push(who);\\n        _subsMap[who] = sub;\\n        \\n         lastSubTime = block.timestamp;\\n    }\\n    \\n    function _convertRemaining(Subscription.Subscriber memory sub, uint level) private view returns (uint) {\\n        return (sub.expiration - block.timestamp) / ((level - sub.tier) * TIER_MULTIPLIER);\\n    }\\n    \\n    function _swapEthForTokens(uint256 amount) private {\\n        address[] memory path = new address[](2);\\n        \\n        path[0] = router.WETH();\\n        path[1] = token;\\n\\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount} (\\n            0,\\n            path,\\n            address(DEAD_ADDRESS),\\n            block.timestamp\\n        );\\n    }\\n    \\n    function _sendEthToTreasury(uint256 amount) private {\\n        treasury.transfer(amount);\\n    }\\n    \\n    function rescueEth() public onlyOwner {\\n        require(block.timestamp - lastSubTime \\u003e= 30 days, \\u0027less than a month since last sub\\u0027);\\n        _sendEthToTreasury(address(this).balance);\\n    }\\n    \\n    function _getRandom(uint max) private view returns (uint) {\\n        return uint(keccak256(abi.encodePacked(block.timestamp, block.difficulty, max))) % max;\\n    }\\n    \\n    \\n    function pickWinner() public view returns (address wallet) {\\n        require(_subs.length \\u003e 0, \\u0027no subs to pick from\\u0027);\\n\\n        uint random = _getRandom(_subs.length);\\n        \\n        return _subs[random];\\n    }\\n    \\n    function _deliverGiftToWinner(address wallet) private {\\n        Subscription.Subscriber memory winner = _subsMap[wallet];\\n        \\n        uint added =  14 days;\\n        \\n        if (winner.tier \\u003c _tiers.length) {\\n            // free tier up\\n            winner.tier += 1;\\n            added /= 2;\\n        }\\n            \\n        // add free days\\n        winner.expiration = winner.expiration + added;\\n        \\n        _subsMap[winner.wallet] = winner;\\n        \\n        emit WinnerSelected(wallet);\\n    }\\n    \\n    function buyback() public onlyOwner {\\n        require(address(this).balance \\u003e= 1 ether, \\u0027low balance\\u0027);\\n        require(token != address(0), \\u0027buyback address not set\\u0027);\\n        \\n        removeExpired();\\n        \\n        address winner = pickWinner();\\n        _deliverGiftToWinner(winner);\\n        \\n        uint256 amount = 1 ether;\\n        uint256 fee = amount * platformFee / 100;\\n        amount = amount - fee;\\n        \\n        _swapEthForTokens(amount);\\n        _sendEthToTreasury(fee);\\n    }\\n    \\n    function removeExpired() public {\\n        address[] memory subs = _subs;\\n        delete _subs;\\n\\n        for (uint i = 0; i \\u003c subs.length; i++) {\\n            if (block.timestamp \\u003e= _subsMap[subs[i]].expiration) {\\n                delete _subsMap[subs[i]];\\n            } else {\\n                _subs.push(subs[i]);\\n            }\\n        }\\n    }\\n    \\n    function setRouter(address payable newRouter) public onlyOwner {\\n        router = IUniswapV2Router(newRouter);\\n    }\\n    \\n    function setToken(address newToken) public onlyOwner {\\n        token = newToken;\\n    }\\n    \\n    function setTreasury(address payable newTreasury) public onlyOwner {\\n        treasury = newTreasury;\\n    }\\n    \\n    function setPlatformFee(uint newFee) public onlyOwner {\\n        require(newFee \\u003c= 30, \\u0027maximum fee exceeded\\u0027);\\n        platformFee = newFee;\\n    }\\n    \\n    fallback() external { }\\n    \\n}\"},\"Subscription.sol\":{\"content\":\"pragma solidity ^0.8.6;\\n\\n// SPDX-License-Identifier: Apache-2.0\\n\\nlibrary Subscription {\\n    struct Tier {\\n        string name;\\n        uint256 level;\\n        uint256 price;\\n    }\\n\\n    struct Subscriber {\\n        address wallet;\\n        uint256 tier;\\n        uint256 expiration;\\n    }\\n}\\n\"},\"UniswapRouter.sol\":{\"content\":\"pragma solidity ^0.8.6;\\n\\n// SPDX-License-Identifier: Apache-2.0\\n\\ninterface IUniswapV2Router {\\n    \\n    function WETH() external pure returns (address);\\n    \\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"routerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"treasuryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"WinnerSelected\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"buyback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSubCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSubs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTiers\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct Subscription.Tier[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"giftSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastSubTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pickWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeExpired\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setPlatformFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"internalType\":\"struct Subscription.Tier[]\",\"name\":\"tiers\",\"type\":\"tuple[]\"}],\"name\":\"setTiers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"subscribe\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"viewSub\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"viewTier\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Isolde","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000011a605d7e12b64d713e93c487277d819a1d14b990000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d00000000000000000000000033206057141941e54914a425716576d7e9083b3c","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://205530a40a421129dcfba94b5dce50f001f840afb4f0e5d0834596a211309aea"}]}