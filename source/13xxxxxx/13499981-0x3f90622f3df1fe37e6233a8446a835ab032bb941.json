{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"./contracts/Registry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLV3\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./common/Whitelist.sol\\\";\\n\\n/// @notice Registry for holding gro protocol contract information on chain\\n/// *****************************************************************************\\n/// The registry allows for external entities to verfiy what contracts are active\\n/// and at which point a contract was deactivated/activated. This will simplify\\n/// the tracking of statistics for bots etc. Additional meta data can be attached\\n/// to each contract.\\n/// *****************************************************************************\\n/// Contract storage:\\n///     Deployed contract addresses are stored in an array inside a mapping which\\n///     key is the name of the contract type, e.g.\\n///         \\\"VaultAdapter\\\" => ['0x...', '0x...', ...]\\n///     Each address is in turn mapped to a contract data struct that holds infromation \\n///     regarding the contract, e.g.\\n///         '0x...' => {deployedBlock: x, startBlock: [x, y], endBlock: [z]...}\\n///\\n/// Contract data:\\n///     The following data fields are defined inside the contract data struct:\\n///        deployedBlock - Which block was deployed\\n///        startBlock - Array containing the blocks in which the contract was set to active\\n///        uint256[] endBlock - Array containing the blocks in which the contract was set to inactive\\n///        string abiVersion - Hash of commit used for the contract deployment\\n///        string tag - Inidication of what type of contract it is (core, strategy etc)\\n///        string metaData - additional data used by external actors, provided as a JSON string \\n///        string tokens - token exposures if any (matches entries form the tokens array and tokenMap)\\n///        string protocols - protocol exposure if any (matches entries from the protocols array and protocolMap)\\n///        bool active - If this contract is the active one, there can only be one active contract per\\n///         contract group.\\n///\\n/// Additional data:\\n///     The contract contains data regarding exposures (protocols/tokens) that are used to assist \\n///     external actors. This data is stored in arrays where the index of item in the array will be\\n///     used to reference the protocols/tokens in the meta data. The index of a protocol/token can\\n///     be retrieved by using the protocolMap/tokenMap, a return value of 0 indicates that its\\n///     not present in the registry.\\ncontract Registry is Whitelist {\\n\\n    struct contractData {\\n        uint256 deployedBlock;\\n        uint256[] startBlock;\\n        uint256[] endBlock;\\n        string abiVersion;\\n        string tag;\\n        string metaData;\\n        uint256[] tokens;\\n        uint256[] protocols;\\n        bool active;\\n    }\\n\\n    mapping(string => address[]) contractMap;\\n    mapping(address => contractData ) contractInfo;\\n\\n    mapping(string => bool) activeKey;\\n    mapping(string => uint256) protocolMap;\\n    mapping(address => uint256) tokenMap;\\n\\n    string[] keys;\\n    string[] protocols;\\n    address[] tokens;\\n\\n    event LogNewContract(string indexed contractName, address indexed contractAddress, bool contractTypeActivated);\\n    event LogNewProtocol(string indexed protocol, uint256 index);\\n    event LogNewToken(address indexed token, uint256 index);\\n    event LogAddTokenExposure(address indexed _contract, address[] token);\\n    event LogAddProtocolExposure(address indexed _contract, string[] protocol);\\n    event LogRemovedContract(string indexed contractName, address indexed contractAddress);\\n    event LogContractActivated(string indexed contractName, address indexed contractActivated, address contractDeactivated);\\n    event LogForceUpdate(address indexed contractAddress,  uint256 _deployed, uint256 _startBlock, uint256 _endBlock);\\n    event LogForceUpdateMeta(address contractAddress, string _abiVersion, string _tag, string _metaData);\\n\\n    /// @notice returns a list of active Contract keys in the registry\\n    /// @dev if there are no deployed contracts associated with the key,\\n    ///     it wont be displayed but rather returned as an empty string\\n    function getKeys() external view returns (string[] memory) {\\n        uint256 keyLength = keys.length; \\n        string[] memory _keys = new string[](keyLength);\\n        uint256 j;\\n        for (uint256 i; i < keyLength; i++) {\\n            if (contractMap[keys[i]].length != 0) {\\n                _keys[j] = keys[i];\\n                j++;\\n            }\\n        }\\n        return _keys;\\n    }\\n\\n    function getProtocol(uint256 index) external view returns (string memory) {\\n        require(protocols.length > 1, 'getProtocol: No protocols added');\\n        require(index > 0, 'getProtocol: index = 0');\\n        return protocols[index - 1];\\n    }\\n\\n    function getToken(uint256 index) external view returns (address) {\\n        require(tokens.length > 1, 'getToken: No tokens added');\\n        require(index > 0, 'getProtocol: index = 0');\\n        return tokens[index - 1];\\n    }\\n\\n    /// @notice Add token exposures to contract\\n    /// @param contractAddress contract to add exposures to\\n    /// @param tokenAddresses addresses of tokens the contract is exposed to\\n    /// @dev providing an empty list removes all token exposures from the contract\\n    function addTokenExposures(address contractAddress, address[] calldata tokenAddresses) external onlyWhitelist {\\n        if (tokenAddresses.length > 0) {\\n            uint256[] memory indexes = convertToTokenIndexs(tokenAddresses);\\n            delete contractInfo[contractAddress].tokens;\\n            contractInfo[contractAddress].tokens = indexes;\\n        } else {\\n            delete contractInfo[contractAddress].tokens;\\n        }\\n        emit LogAddTokenExposure(contractAddress, tokenAddresses);\\n    }\\n\\n    /// @notice Add protocol exposures to contract\\n    /// @param contractAddress contract to add exposures to\\n    /// @param protocolNames addresses of protocol the contract is exposed to\\n    /// @dev providing an empty list removes all protocol exposures from the contract\\n    function addProtocolExposures(address contractAddress, string[] calldata protocolNames) external onlyWhitelist {\\n        if (protocolNames.length > 0) {\\n            uint256[] memory indexes = convertToProtocolIndexs(protocolNames);\\n            delete contractInfo[contractAddress].protocols;\\n            contractInfo[contractAddress].protocols = indexes;  \\n        } else {\\n            delete contractInfo[contractAddress].protocols;\\n        }\\n        emit LogAddProtocolExposure(contractAddress, protocolNames);\\n    }\\n\\n    function convertToTokenIndexs(address[] calldata tokenAddresses) public view returns(uint256[] memory) {\\n        uint256 length = tokenAddresses.length;\\n        uint256[] memory tokenIndexes = new uint256[](length);\\n        for(uint256 i; i < length; i++) {\\n            require(tokenMap[tokenAddresses[i]] != 0, 'convertToTokenIndexs: token not registred');\\n            tokenIndexes[i] = tokenMap[tokenAddresses[i]];\\n        }\\n        return tokenIndexes;\\n    }\\n\\n    function convertToProtocolIndexs(string[] calldata protocolNames) public view returns(uint256[] memory) {\\n        uint256 length = protocolNames.length;\\n        uint256[] memory protocolIndexes = new uint256[](length);\\n        for(uint256 i; i < length; i++) {\\n            require(protocolMap[protocolNames[i]] != 0, 'convertToProtocolIndexs: protocol not registred');\\n            protocolIndexes[i] = protocolMap[protocolNames[i]];\\n        }\\n        return protocolIndexes;\\n    }\\n\\n    /// @notice Add a new deployed contract to the registry\\n    /// @param contractName The Contract type (Controller, WithdrawHandler, DaiVaultAdapter etc)\\n    /// @param contractAddress Address of the deployed contract\\n    /// @param _deployed BlockNumber the contract was deployed\\n    /// @param _abiVersion Hash of commit used for contract deployment\\n    /// @param _tag Indicator of the contract type\\n    /// @dev New contractNames will be added to the keys list\\n    function newContract(string calldata contractName, address contractAddress, uint256 _deployed, string calldata _abiVersion, string calldata _tag) external onlyWhitelist {\\n        require(contractInfo[contractAddress].deployedBlock == 0, 'newContract: Already in registry');\\n\\n        bool newContractType;\\n        contractMap[contractName].push(contractAddress);\\n        contractInfo[contractAddress].deployedBlock = _deployed;  \\n        contractInfo[contractAddress].abiVersion = _abiVersion;  \\n        contractInfo[contractAddress].tag = _tag;  \\n        contractInfo[contractAddress].active = false;  \\n        if (!activeKey[contractName]) {\\n            newContractType = true;\\n            activeKey[contractName] = true;\\n            keys.push(contractName);\\n        }\\n        emit LogNewContract(contractName, contractAddress, newContractType);\\n    }\\n    /// @notice Add a new protocol to the registry\\n    /// @param _protocol Protocol name\\n    function addProtocol(string calldata _protocol) external onlyWhitelist {\\n        require(protocolMap[_protocol] == 0, 'addProtocol: protocol already added');\\n        protocols.push(_protocol);\\n        uint256 position = protocols.length;\\n        protocolMap[_protocol] = position;\\n        emit LogNewProtocol(_protocol, position);\\n    }\\n\\n    /// @notice Add a new token to the registry\\n    /// @param _token Token address\\n    function addToken(address _token) external onlyWhitelist {\\n        require(tokenMap[_token] == 0, 'addToken: token already added');\\n        tokens.push(_token);\\n        uint256 position = tokens.length;\\n        tokenMap[_token] = position;\\n        emit LogNewToken(_token, position);\\n    }\\n\\n    /// @notice Pop last added contract from the contractMap array, removing all associated data\\n    function removeContract(string calldata contractName) external onlyWhitelist {\\n        address[] memory contracts = contractMap[contractName];\\n        require(contracts.length > 0, 'removeContract: No deployed contracts');\\n        address _contract = contracts[contracts.length - 1];\\n        contractMap[contractName].pop();\\n        contractInfo[_contract].deployedBlock = 0;  \\n        contractInfo[_contract].abiVersion = \\\"\\\";  \\n        contractInfo[_contract].tag = \\\"\\\";  \\n        contractInfo[_contract].metaData = \\\"\\\";\\n        contractInfo[_contract].active = false;\\n        delete contractInfo[_contract].tokens;\\n        delete contractInfo[_contract].protocols;\\n\\n        emit LogRemovedContract(contractName, _contract);\\n    }\\n\\n    /// @notice Force an update of contract information\\n    /// @param contractAddress Address of the deployed contract\\n    /// @param _deployed Block number the contract was deployed\\n    /// @param _startBlock Block number the contract was activated\\n    /// @param _endBlock block number the contract was deactivated\\n    /// @dev start/end blocks of 0 will skip updating those fields, will otherwise pop and replace last value\\n    function forceUpdate(address contractAddress, uint256 _deployed, uint256 _startBlock, uint256 _endBlock) external onlyOwner {\\n        require(contractInfo[contractAddress].deployedBlock > 0, 'No contract');\\n        contractInfo[contractAddress].deployedBlock = _deployed;  \\n        if (_startBlock > 0) {\\n            contractInfo[contractAddress].startBlock.pop();  \\n            contractInfo[contractAddress].startBlock.push(_startBlock);  \\n        }\\n        if (_endBlock > 0) {\\n            contractInfo[contractAddress].endBlock.pop();  \\n            contractInfo[contractAddress].endBlock.push(_endBlock);\\n        }\\n        emit LogForceUpdate(contractAddress,  _deployed, _startBlock, _endBlock);\\n    }\\n\\n    /// @notice Force an updated of contract meta data, effectively overwritting old values\\n    /// @param contractAddress Address of the deployed contract\\n    /// @param _abiVersion New ABI version\\n    /// @param _tag New tag\\n    /// @param _metaData new MetaData\\n    function forceUpdateMeta(address contractAddress, string calldata _abiVersion, string calldata _tag, string calldata _metaData) external onlyOwner {\\n        require(contractInfo[contractAddress].deployedBlock > 0, 'No contract');\\n        contractInfo[contractAddress].abiVersion = _abiVersion;  \\n        contractInfo[contractAddress].tag = _tag;  \\n        contractInfo[contractAddress].metaData = _metaData;  \\n        emit LogForceUpdateMeta(contractAddress, _abiVersion, _tag, _metaData);\\n    }\\n\\n    /// @notice Designate a new contract as active, disabling the last active one \\n    /// @param _contractName Contract group name\\n    /// @param _contractAddress Address of contract to start\\n    /// @param _startBlock Block this contract was activated\\n    function activateContract(string calldata _contractName, address _contractAddress, uint256 _startBlock) external onlyWhitelist {\\n        address[] memory contracts = contractMap[_contractName];\\n        uint256 contractLength = contracts.length;\\n        require(contractLength > 0, 'No addresses for contracts');\\n        address deactivated;\\n        bool newActiveExists;\\n        for(uint256 i; i < contractLength; i++) {\\n            if (contracts[i] == _contractAddress) {\\n                newActiveExists = true;\\n            }\\n            if (contractInfo[contracts[i]].active) {\\n                require(contracts[i] != _contractAddress, 'activateContract: !Already active');\\n                deactivated = contracts[i];\\n                contractInfo[contracts[i]].active = false;\\n                contractInfo[contracts[i]].endBlock.push(_startBlock);  \\n            }\\n        }\\n        require(newActiveExists, 'activateContract: contract not added to group'); \\n        contractInfo[_contractAddress].startBlock.push(_startBlock);  \\n        contractInfo[_contractAddress].active = true;\\n        emit LogContractActivated(_contractName, _contractAddress, deactivated);\\n    }\\n\\n    /// @notice Add meta data to contract\\n    /// @param contractAddress Address of target contract\\n    /// @param _metaData Meta data JSON string\\n    function setMetaData(address contractAddress, string calldata _metaData) external onlyWhitelist {\\n        require(contractInfo[contractAddress].deployedBlock > 0, 'No contract');\\n        contractInfo[contractAddress].metaData = _metaData;  \\n    }\\n\\n    /// @notice Get all deployed contracts in a contract type group\\n    /// @param contractName Contract type name\\n    function getContractMap(string calldata contractName) external view returns (address[] memory) {\\n        return contractMap[contractName];\\n    }\\n\\n    /// @notice Get the contract data of the last added contract in a contract type group\\n    /// @param contractName Contract type name\\n    function getLatestData(string calldata contractName) external view returns (contractData memory data) {\\n        address[] memory contracts = contractMap[contractName];\\n        uint256 contractLength = contracts.length;\\n        if (contractLength > 0) {\\n            return contractInfo[contracts[contractLength - 1]];\\n        }\\n        return contractInfo[address(0)];\\n    }\\n\\n    /// @notice Get the contract data of the last added contract in a contract type group\\n    /// @param contractName Contract type name\\n    function getLatest(string calldata contractName) external view returns (address) {\\n        return contractMap[contractName][contractMap[contractName].length - 1];\\n    }\\n\\n    /// @notice Get the contract data of the active contract in a contract type group\\n    /// @param contractName Contract type name\\n    function getActiveData(string calldata contractName) external view returns (contractData memory data) {\\n        address[] memory contracts = contractMap[contractName];\\n        for(uint256 i; i < contracts.length; i++) {\\n            if (contractInfo[contracts[i]].active) {\\n                return contractInfo[contracts[i]];\\n            }\\n        }\\n        return contractInfo[address(0)];\\n    }\\n\\n    /// @notice Get the address of the active contract in a contract type group\\n    /// @param contractName Contract type name\\n    function getActive(string calldata contractName) external view returns (address) {\\n        address[] memory contracts = contractMap[contractName];\\n        for(uint256 i; i < contracts.length; i++) {\\n            if (contractInfo[contracts[i]].active) {\\n                return contracts[i];\\n            }\\n        }\\n        return address(0);\\n    }\\n\\n    /// @notice Get data for specified contract\\n    /// @param contractAddress Address of the deployed contract\\n    function getContractData(address contractAddress) external view returns (contractData memory) {\\n        return contractInfo[contractAddress];\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/common/Whitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPLv3\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract Whitelist is Ownable {\\n    mapping(address => bool) public whitelist;\\n\\n    event LogAddToWhitelist(address indexed user);\\n    event LogRemoveFromWhitelist(address indexed user);\\n\\n    modifier onlyWhitelist() {\\n        require(whitelist[msg.sender], \\\"only whitelist\\\");\\n        _;\\n    }\\n\\n    function addToWhitelist(address user) external onlyOwner {\\n        require(user != address(0), \\\"WhiteList: 0x\\\");\\n        whitelist[user] = true;\\n        emit LogAddToWhitelist(user);\\n    }\\n\\n    function removeFromWhitelist(address user) external onlyOwner {\\n        require(user != address(0), \\\"WhiteList: 0x\\\");\\n        whitelist[user] = false;\\n        emit LogRemoveFromWhitelist(user);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"protocol\",\"type\":\"string[]\"}],\"name\":\"LogAddProtocolExposure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"LogAddToWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"token\",\"type\":\"address[]\"}],\"name\":\"LogAddTokenExposure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractActivated\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractDeactivated\",\"type\":\"address\"}],\"name\":\"LogContractActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_deployed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"}],\"name\":\"LogForceUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_abiVersion\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_tag\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_metaData\",\"type\":\"string\"}],\"name\":\"LogForceUpdateMeta\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"contractTypeActivated\",\"type\":\"bool\"}],\"name\":\"LogNewContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"protocol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"LogNewProtocol\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"LogNewToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"LogRemoveFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"LogRemovedContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_contractName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"name\":\"activateContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_protocol\",\"type\":\"string\"}],\"name\":\"addProtocol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"protocolNames\",\"type\":\"string[]\"}],\"name\":\"addProtocolExposures\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"addTokenExposures\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"protocolNames\",\"type\":\"string[]\"}],\"name\":\"convertToProtocolIndexs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"}],\"name\":\"convertToTokenIndexs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deployed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"}],\"name\":\"forceUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_abiVersion\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tag\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_metaData\",\"type\":\"string\"}],\"name\":\"forceUpdateMeta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"getActive\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"getActiveData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deployedBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"startBlock\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"endBlock\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"abiVersion\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tag\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"metaData\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"protocols\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct Registry.contractData\",\"name\":\"data\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"getContractData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deployedBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"startBlock\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"endBlock\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"abiVersion\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tag\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"metaData\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"protocols\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct Registry.contractData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"getContractMap\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getKeys\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"getLatest\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"getLatestData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deployedBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"startBlock\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"endBlock\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"abiVersion\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tag\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"metaData\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"protocols\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct Registry.contractData\",\"name\":\"data\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getProtocol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deployed\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_abiVersion\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tag\",\"type\":\"string\"}],\"name\":\"newContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"removeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_metaData\",\"type\":\"string\"}],\"name\":\"setMetaData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Registry","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3aa0ab6c0835e4af5fe87a77dbb7aa420d26e3656498150972bc06bab550c073"}]}