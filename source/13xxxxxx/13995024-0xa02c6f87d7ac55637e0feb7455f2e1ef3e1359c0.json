{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Signer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.3;\\r\\n\\r\\n/* Signature Verification\\r\\n\\r\\nHow to Sign and Verify\\r\\n# Signing\\r\\n1. Create message to sign\\r\\n2. Hash the message\\r\\n3. Sign the hash (off chain, keep your private key secret)\\r\\n\\r\\n# Verify\\r\\n1. Recreate hash from the original message\\r\\n2. Recover signer from signature and hash\\r\\n3. Compare recovered signer to claimed signer\\r\\n*/\\r\\n\\r\\nlibrary VerifySignature {\\r\\n    /* 1. Unlock MetaMask account\\r\\n    ethereum.enable()\\r\\n    */\\r\\n\\r\\n    /* 2. Get message hash to sign\\r\\n    getMessageHash(\\r\\n        0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C,\\r\\n        123,\\r\\n        \\\"coffee and donuts\\\",\\r\\n        1\\r\\n    )\\r\\n\\r\\n    hash = \\\"0xcf36ac4f97dc10d91fc2cbb20d718e94a8cbfe0f82eaedc6a4aa38946fb797cd\\\"\\r\\n    */\\r\\n    function getMessageHash(\\r\\n        address _minter,\\r\\n        uint _quantity,\\r\\n        uint _nonce\\r\\n    ) public pure returns (bytes32) {\\r\\n        return keccak256(abi.encodePacked(_minter, _quantity, _nonce));\\r\\n    }\\r\\n\\r\\n    /* 3. Sign message hash\\r\\n    # using browser\\r\\n    account = \\\"copy paste account of signer here\\\"\\r\\n    ethereum.request({ method: \\\"personal_sign\\\", params: [account, hash]}).then(console.log)\\r\\n\\r\\n    # using web3\\r\\n    web3.personal.sign(hash, web3.eth.defaultAccount, console.log)\\r\\n\\r\\n    Signature will be different for different accounts\\r\\n    0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b\\r\\n    */\\r\\n    function getEthSignedMessageHash(bytes32 _messageHash)\\r\\n        public\\r\\n        pure\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        /*\\r\\n        Signature is produced by signing a keccak256 hash with the following format:\\r\\n        \\\"\\\\x19Ethereum Signed Message\\\\n\\\" + len(msg) + msg\\r\\n        */\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _messageHash)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /* 4. Verify signature\\r\\n    signer = 0xB273216C05A8c0D4F0a4Dd0d7Bae1D2EfFE636dd\\r\\n    to = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C\\r\\n    amount = 123\\r\\n    message = \\\"coffee and donuts\\\"\\r\\n    nonce = 1\\r\\n    signature =\\r\\n        0x993dab3dd91f5c6dc28e17439be475478f5635c92a56e17e82349d3fb2f166196f466c0b4e0c146f285204f0dcb13e5ae67bc33f4b888ec32dfe0a063e8f3f781b\\r\\n    */\\r\\n    function verify(\\r\\n        address _signer,\\r\\n        address _minter,\\r\\n        uint _quantity,\\r\\n        uint _nonce,\\r\\n        bytes memory signature\\r\\n    ) public pure returns (bool) {\\r\\n        bytes32 messageHash = getMessageHash(_minter, _quantity, _nonce);\\r\\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\\r\\n\\r\\n        return recoverSigner(ethSignedMessageHash, signature) == _signer;\\r\\n    }\\r\\n\\r\\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)\\r\\n        public\\r\\n        pure\\r\\n        returns (address)\\r\\n    {\\r\\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\\r\\n\\r\\n        return ecrecover(_ethSignedMessageHash, v, r, s);\\r\\n    }\\r\\n\\r\\n    function splitSignature(bytes memory sig)\\r\\n        public\\r\\n        pure\\r\\n        returns (\\r\\n            bytes32 r,\\r\\n            bytes32 s,\\r\\n            uint8 v\\r\\n        )\\r\\n    {\\r\\n        require(sig.length == 65, \\\"invalid signature length\\\");\\r\\n\\r\\n        assembly {\\r\\n            /*\\r\\n            First 32 bytes stores the length of the signature\\r\\n\\r\\n            add(sig, 32) = pointer of sig + 32\\r\\n            effectively, skips first 32 bytes of signature\\r\\n\\r\\n            mload(p) loads next 32 bytes starting at the memory address p into memory\\r\\n            */\\r\\n\\r\\n            // first 32 bytes, after the length prefix\\r\\n            r := mload(add(sig, 32))\\r\\n            // second 32 bytes\\r\\n            s := mload(add(sig, 64))\\r\\n            // final byte (first byte of the next 32 bytes)\\r\\n            v := byte(0, mload(add(sig, 96)))\\r\\n        }\\r\\n\\r\\n        // implicitly return (r, s, v)\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_messageHash\",\"type\":\"bytes32\"}],\"name\":\"getEthSignedMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_ethSignedMessageHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"recoverSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"splitSignature\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"VerifySignature","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"100000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}