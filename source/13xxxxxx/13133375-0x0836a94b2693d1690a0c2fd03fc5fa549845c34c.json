{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.12 ;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary SafeMath {\r\n    \r\n    function mul(uint a, uint b) internal pure returns(uint) {\r\n        uint c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n    function div(uint a, uint b) internal pure returns(uint) {\r\n        require(b > 0);\r\n        uint c = a / b;\r\n        require(a == b * c + a % b);\r\n        return c;\r\n    }\r\n    function sub(uint a, uint b) internal pure returns(uint) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n    function add(uint a, uint b) internal pure returns(uint) {\r\n        uint c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n    function max64(uint64 a, uint64 b) internal pure returns(uint64) {\r\n        return a >= b ? a: b;\r\n    }\r\n    function min64(uint64 a, uint64 b) internal pure returns(uint64) {\r\n        return a < b ? a: b;\r\n    }\r\n    function max256(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        return a >= b ? a: b;\r\n    }\r\n    function min256(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        return a < b ? a: b;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public  returns (uint);\r\n    function balanceOf(address tokenOwner) public returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public  returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\ncontract EZSave90 {\r\n    \r\n    address erc20TokenAddress = 0x9E8bfE46f9Af27c5Ea5C9C72b86D71bb86953A0c;\r\n    address officialAddress = 0xebeE832801821DCDd02e3EBF5EF73D9B0BDf5a9F;\r\n    \r\n    uint256 DAY_NUM = 86400;\r\n    uint256 LIMIT_DAY = 90;\r\n    uint256 PERCENT = 6;\r\n    uint256 OFFICIAL_PERCENT = 8;\r\n    \r\n    uint256 DECIMALS = 18;\r\n    // 2022-02-01\r\n    uint256 BUY_EXPIRE_DATE = 1643644800;\r\n    \r\n    uint256 YEAR_DAYS = 365;\r\n    address public owner;   \r\n    \r\n    \r\n    struct Staking {\r\n        address stakingAddress;\r\n        uint coin;\r\n        uint256 startDatetime;\r\n        uint256 expireDatetime;\r\n        uint256 sum;\r\n        uint256 officialBonus;\r\n        bool isEnd;\r\n    }\r\n    \r\n    mapping(address => Staking) internal stakingMap;\r\n    address[] stakingArray;\r\n    \r\n    constructor() public { \r\n        owner = msg.sender;\r\n    }\r\n    \r\n    \r\n    /*\r\n        Get total staking members\r\n    */\r\n    function getStakingNum() public view returns (uint) {\r\n        return stakingArray.length;\r\n    }\r\n    /*\r\n        Get address information data\r\n    */\r\n    function getStaking(address walletAddress) public view returns(address,uint,uint256,uint256,uint256,uint256,bool) {\r\n        Staking memory staking = stakingMap[walletAddress];\r\n        return (staking.stakingAddress,staking.coin,staking.startDatetime,staking.expireDatetime,staking.sum,staking.officialBonus,staking.isEnd);\r\n    }\r\n    \r\n    /*\r\n        Get contract address\r\n    */\r\n    function getContractAddress() public view returns (address) {\r\n        return address(this);\r\n    }\r\n    \r\n    /*\r\n        Provide users to insert coin to Contract pools\r\n    */\r\n    function transferToContract(uint coin) public returns(string memory){\r\n        \r\n        calMainLogic();\r\n        if(coin <= 1000000000000000000000) {\r\n            require(coin <= 1000000000000000000000,\"Number must be greater than 1000.\");\r\n            return \"Number must be greater than 1000.\";\r\n        }\r\n        \r\n        if(isStakingExists(msg.sender)) {\r\n            require(isStakingExists(msg.sender),\"Staking user already exists.\");\r\n            return \"Staking user already exists.\";\r\n        }\r\n        \r\n        if(now > BUY_EXPIRE_DATE) {\r\n            require(now > BUY_EXPIRE_DATE,\"Purchase time has passed.\");\r\n            return \"Purchase time has passed.\";\r\n        }\r\n        \r\n\r\n        ERC20(erc20TokenAddress).transferFrom(msg.sender, address(this), coin);\r\n            \r\n        stakingArray.push(msg.sender);\r\n        Staking memory newStaking = Staking({\r\n            stakingAddress: msg.sender,\r\n            coin: coin,\r\n            startDatetime: now,\r\n            expireDatetime: now + DAY_NUM * LIMIT_DAY,\r\n            sum:0,\r\n            officialBonus:0,\r\n            isEnd:false\r\n        });\r\n        \r\n        stakingMap[msg.sender] = newStaking;\r\n        return \"Success\";\r\n    }\r\n    \r\n    /*\r\n    * Check address is Exists in contract\r\n    */\r\n    function isStakingExists(address walletAddress) public view returns (bool) {\r\n        return stakingMap[walletAddress].coin != 0;\r\n    }\r\n    \r\n    /*\r\n        Invoke Staking bonus when no user insert coins.\r\n    */\r\n    function calMainLogic() public {\r\n        \r\n        for(uint i=0;i<stakingArray.length;i++) {\r\n            Staking memory staking = stakingMap[stakingArray[i]];\r\n\r\n            if(!staking.isEnd && now >= staking.expireDatetime) {\r\n                uint bonus = stakingMap[stakingArray[i]].coin * LIMIT_DAY * PERCENT / 100 / YEAR_DAYS;\r\n                uint officialBonus = bonus * OFFICIAL_PERCENT / 100;\r\n                stakingMap[stakingArray[i]].sum = bonus - officialBonus + stakingMap[stakingArray[i]].coin;\r\n                stakingMap[stakingArray[i]].officialBonus = officialBonus;\r\n                stakingMap[stakingArray[i]].isEnd = true;\r\n                \r\n                ERC20(erc20TokenAddress).transfer(staking.stakingAddress, stakingMap[stakingArray[i]].sum);\r\n                ERC20(erc20TokenAddress).transfer(officialAddress, officialBonus);\r\n                \r\n            }\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    /*\r\n    *   Get All element for statking memory\r\n    */\r\n    function getAll() public view returns(Staking[] memory) {\r\n        \r\n        Staking[] memory stakingList = new Staking[](stakingArray.length);\r\n        for(uint i=0;i<stakingArray.length;i++) {\r\n            Staking memory staking = stakingMap[stakingArray[i]];\r\n            stakingList[i] = staking;\r\n        }\r\n        \r\n        return stakingList;\r\n    }\r\n    \r\n    /*\r\n    *   Official recycle coin mechanism\r\n    */\r\n    function recycleCoin() public {\r\n        if(officialAddress == msg.sender) {\r\n            uint contractBalance = ERC20(erc20TokenAddress).balanceOf(address(this));\r\n            ERC20(erc20TokenAddress).transfer(officialAddress, contractBalance);\r\n        }\r\n    }\r\n    \r\n    //This function for decimal set 0\r\n    function getDecimalsZero() public view returns (uint) {\r\n        \r\n        uint num = 1;\r\n        for(uint i=0;i<DECIMALS;i++) {\r\n        \r\n            num = num * 10;\r\n        }\r\n        return num;\r\n    }\r\n    \r\n    \r\n    /*\r\n        Get Now TimeZone.\r\n    */\r\n    function getNow() public view returns(uint) {\r\n        return now;\r\n    }\r\n    \r\n    \r\n    function getAddressList() public view returns(address[] memory) {\r\n        return stakingArray;\r\n    }\r\n   \r\n\r\n}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[],\"name\":\"calMainLogic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAddressList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAll\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"stakingAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"coin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDatetime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireDatetime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"officialBonus\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isEnd\",\"type\":\"bool\"}],\"internalType\":\"struct EZSave90.Staking[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDecimalsZero\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"}],\"name\":\"getStaking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStakingNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"walletAddress\",\"type\":\"address\"}],\"name\":\"isStakingExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"recycleCoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coin\",\"type\":\"uint256\"}],\"name\":\"transferToContract\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EZSave90","CompilerVersion":"v0.5.12+commit.7709ece9","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://49aaf864348e458c5c080a87b689472825099f85d4d14c9115f4b37e5b0db11a"}]}