{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.6.1 https://hardhat.org\r\n\r\n// File contracts/IERC721Receiver.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.3.0\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File contracts/IERC721.sol\r\n\r\n\r\n\r\npragma solidity >= 0.8.0;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface IERC721 is IERC165 {\r\n     /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) payable external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) payable external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) payable external;\r\n}\r\n\r\n\r\n// File contracts/IERC721Metadata.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Counters.sol@v4.3.0\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v4.3.0\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.3.0\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v4.3.0\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.3.0\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.3.0\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol@v4.3.0\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.3.0\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File @uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol@v1.1.0-beta.0\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\n// File @uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol@v1.1.0-beta.0\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\n// File @uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol@v1.0.1\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\n// File contracts/SparkLink.sol\r\n\r\n\r\n\r\npragma solidity >= 0.8.4;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract SparkLink is Ownable, ERC165, IERC721, IERC721Metadata{\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n    using SafeERC20 for IERC20;\r\n    Counters.Counter private _issueIds;\r\n    /*\r\n    Abstract struct Issue {\r\n        uint32 total_amount;\r\n        bool is_free\r\n        bool is_ND;\r\n        bool is_NC;\r\n        uint16 shill_times;\r\n        uint8 royalty_fee;\r\n    }\r\n    This structure records some common attributes of a series of NFTs:\r\n        - `royalty_fee`: the proportion of royaltyes\r\n        - `shill_times`: the number of times a single NFT can been shared\r\n        - `total_amount`: the total number of NFTs in the series\r\n    To reduce gas cost, this structure is actually stored in the `father_id` attibute of root NFT\r\n        - 0~31  `total_amount`\r\n        - 37 `is_free`\r\n        - 38 `is_NC`\r\n        - 39 `is_ND`\r\n        - 40~55 `shill_times`\r\n        - 56~63 `royalty_fee`\r\n    */\r\n\r\n    struct Edition {\r\n        // This structure stores NFT related information:\r\n        //  - `father_id`: For root NFT it stores issue abstract sturcture\r\n        //                 For other NFTs its stores the NFT Id of which NFT it `acceptShill` from\r\n        // - `shill_price`: The price should be paid when others `accpetShill` from this NFT\r\n        // - remaining_shill_times: The initial value is the shilltimes of the issue it belongs to\r\n        //                       When others `acceptShill` from this NFT, it will subtract one until its value is 0  \r\n        // - `owner`: record the owner of this NFT\r\n        // - `ipfs_hash`: IPFS hash value of the URI where this NTF's metadata stores\r\n        // - `transfer_price`: The initial value is zero\r\n        //                   Set by `determinePrice` or `determinePriceAndApprove` before `transferFrom`\r\n        //                   It will be checked wether equal to msg.value when `transferFrom` is called\r\n        //                   After `transferFrom` this value will be set to zero\r\n        // - `profit`: record the profit owner can claim (include royalty fee it should conduct to its father NFT)\r\n        uint64 father_id;\r\n        uint128 shill_price;\r\n        uint16 remaining_shill_times;\r\n        address owner;\r\n        bytes32 ipfs_hash;\r\n        uint128 transfer_price;\r\n        uint128 profit;\r\n    }\r\n\r\n    // Emit when `determinePrice` success\r\n    event DeterminePrice(\r\n        uint64 indexed NFT_id,\r\n        uint128 transfer_price\r\n    );\r\n\r\n    // Emit when `determinePriceAndApprove` success\r\n    event DeterminePriceAndApprove(\r\n        uint64 indexed NFT_id,\r\n        uint128 transfer_price,\r\n        address indexed to\r\n    );\r\n\r\n    // Emit when `publish` success\r\n    // - `rootNFTId`: Record the Id of root NFT given to publisher \r\n    event Publish(\r\n        address indexed publisher,\r\n        uint64  indexed rootNFTId,\r\n        address token_addr\r\n    );\r\n\r\n    // Emit when claimProfit success\r\n    //- `amount`: Record the actual amount owner of this NFT received (profit - profit*royalty_fee/100)\r\n    event Claim(\r\n        uint64 indexed NFT_id,\r\n        address indexed receiver,\r\n        uint128 amount\r\n    );\r\n    // Emit when setURI success\r\n    event SetURI(\r\n        uint64 indexed NFT_id,\r\n        bytes32 old_URI,\r\n        bytes32 new_URI\r\n    );\r\n\r\n    event Label(\r\n        uint64 indexed NFT_id,\r\n        string content\r\n    );\r\n\r\n    event SetDAOFee(\r\n        uint8 old_DAO_fee,\r\n        uint8 new_DAO_fee\r\n    );\r\n\r\n    event SetLoosRatio(\r\n        uint8 old_loss_ratio,\r\n        uint8 new_loss_ratio\r\n    );\r\n\r\n    event SetDAORouter01(\r\n        address old_router_address,\r\n        address new_router_address\r\n    );\r\n\r\n    event SetDAORouter02(\r\n        address old_router_address,\r\n        address new_router_address\r\n    );\r\n\r\n    //----------------------------------------------------------------------------------------------------\r\n    /**\r\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n     */\r\n    constructor(address DAO_router_address01,address DAO_router_address02, address uniswapRouterAddress, address factoryAddress) {\r\n        uniswapV2Router =  IUniswapV2Router02(uniswapRouterAddress);\r\n        uniswapV2Factory = IUniswapV2Factory(factoryAddress);\r\n        DAO_router01 = DAO_router_address01;\r\n        DAO_router02 = DAO_router_address02;\r\n        _name = \"SparkLink\";\r\n        _symbol = \"SPL\";\r\n    } \r\n    \r\n   /**\r\n     * @dev Create a issue and mint a root NFT for buyer acceptShill from\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_first_sell_price`: The price should be paid when others `accpetShill` from this NFT\r\n     * - `_royalty_fee`: The proportion of royaltyes, it represents the ratio of the father NFT's profit from the child NFT\r\n     *                   Its value should <= 100\r\n     * - `_shill_times`: the number of times a single NFT can been shared\r\n     *                   Its value should <= 65536\r\n     * - `_ipfs_hash`: IPFS hash value of the URI where this NTF's metadata stores\r\n     *\r\n     * - `token_address`: list of tokens(address) can be accepted for payment.\r\n     *                 `A token address` can be ERC-20 token contract address or `address(0)`(ETH).\r\n     *\r\n     * - `_is_free`:\r\n     * - `_is_NC`: \r\n     * \r\n     * - `_is_ND`: \r\n     * Emits a {Publish} event.\r\n     * - Emitted {Publish} event contains root NFT id.\r\n     */\r\n    function publish(\r\n        uint128 _first_sell_price,\r\n        uint8 _royalty_fee,\r\n        uint16 _shill_times,\r\n        bytes32 _ipfs_hash,\r\n        address _token_addr,\r\n        bool _is_free,\r\n        bool _is_NC,\r\n        bool _is_ND\r\n    ) \r\n        external \r\n    {\r\n        require(_royalty_fee <= 100, \"SparkLink: Royalty fee should be <= 100%.\");\r\n        _issueIds.increment();\r\n        require(_issueIds.current() <= type(uint32).max, \"SparkLink: Value doesn't fit in 32 bits.\");\r\n        if (_token_addr != address(0))\r\n            require(IERC20(_token_addr).totalSupply() > 0, \"Not a valid ERC20 token address\");\r\n        uint32 new_issue_id = uint32(_issueIds.current());\r\n        uint64 rootNFTId = getNftIdByEditionIdAndIssueId(new_issue_id, 1);\r\n        require(\r\n            _checkOnERC721Received(address(0), msg.sender, rootNFTId, \"\"),\r\n            \"SparkLink: Transfer to non ERC721Receiver implementer\"\r\n        );\r\n\r\n        Edition storage new_NFT = editions_by_id[rootNFTId];\r\n        uint64 information;\r\n        information = reWriteUint8InUint64(56, _royalty_fee, information);\r\n        information = reWriteUint16InUint64(40, _shill_times, information);\r\n        information = reWriteBoolInUint64(37, _is_free, information);\r\n        information = reWriteBoolInUint64(38, _is_NC, information);\r\n        information = reWriteBoolInUint64(39, _is_ND, information);\r\n        information += 1;\r\n        token_addresses[new_issue_id] = _token_addr;\r\n        new_NFT.father_id = information;\r\n        new_NFT.remaining_shill_times = _shill_times;\r\n        new_NFT.shill_price = _first_sell_price;\r\n        new_NFT.owner = msg.sender;\r\n        new_NFT.ipfs_hash = _ipfs_hash;\r\n        _balances[msg.sender] += 1;\r\n        emit Transfer(address(0), msg.sender, rootNFTId);\r\n        emit Publish(\r\n            msg.sender,\r\n            rootNFTId,\r\n            _token_addr\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Buy a child NFT from the _NFT_id buyer input\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_NFT_id`: _NFT_id the father NFT id buyer mint NFT from\r\n     *              remain shill times of the NFT_id you input should greater than 0\r\n     * Emits a {Ttansfer} event.\r\n     * - Emitted {Transfer} event from 0x0 address to msg.sender, contain new NFT id.\r\n     * - New NFT id will be generater by edition id and issue id\r\n     *   0~31 edition id\r\n     *   32~63 issue id\r\n     */\r\n    function acceptShill(\r\n        uint64 _NFT_id\r\n    ) \r\n        external \r\n        payable \r\n    {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: This NFT does not exist\");\r\n        require(editions_by_id[_NFT_id].remaining_shill_times > 0, \"SparkLink: There is no remaining shill time for this NFT\");\r\n        if (!isRootNFT(_NFT_id)||!getIsFreeByNFTId(_NFT_id)){\r\n            address token_addr = getTokenAddrByNFTId(_NFT_id);\r\n            if (token_addr == address(0)){\r\n                require(msg.value == editions_by_id[_NFT_id].shill_price, \"SparkLink: Wrong price\");\r\n                _addProfit( _NFT_id, editions_by_id[_NFT_id].shill_price);\r\n            }\r\n            else {\r\n                uint256 before_balance = IERC20(token_addr).balanceOf(address(this));\r\n                IERC20(token_addr).safeTransferFrom(msg.sender, address(this), editions_by_id[_NFT_id].shill_price);\r\n                _addProfit( _NFT_id, uint256toUint128(IERC20(token_addr).balanceOf(address(this))-before_balance));\r\n            }\r\n        }\r\n        editions_by_id[_NFT_id].remaining_shill_times -= 1;\r\n        _mintNFT(_NFT_id, msg.sender);\r\n        if (editions_by_id[_NFT_id].remaining_shill_times == 0)\r\n            _mintNFT(_NFT_id, ownerOf(_NFT_id));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *      \r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `transfer_price` has been set, caller should give same value in msg.sender.\r\n     * - Will call `claimProfit` before transfer and `transfer_price` will be set to zero after transfer. \r\n     * Emits a {TransferAsset} events\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external payable override {\r\n        _transfer(from, to, uint256toUint64(tokenId));\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external payable override{\r\n       _safeTransfer(from, to, uint256toUint64(tokenId), \"\");\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata _data) external payable override {\r\n        _safeTransfer(from, to, uint256toUint64(tokenId), _data);\r\n    }\r\n    \r\n    /**\r\n     * @dev Claim profit from reward pool of NFT.\r\n     *      \r\n     * Requirements:\r\n     *\r\n     * - `_NFT_id`: The NFT id of NFT caller claim, the profit will give to its owner.\r\n     * - If its profit is zero the event {Claim} will not be emited.\r\n     * Emits a {Claim} events\r\n     */\r\n    function claimProfit(uint64 _NFT_id) public {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: This edition does not exist\");\r\n        \r\n        if (editions_by_id[_NFT_id].profit != 0) {\r\n            uint128 amount = editions_by_id[_NFT_id].profit;\r\n            address token_addr = getTokenAddrByNFTId(_NFT_id);\r\n            if (DAO_fee != 0) {\r\n                uint128 DAO_amount = calculateFee(amount, DAO_fee);\r\n                amount -= DAO_amount;\r\n                if (token_addr == address(0)) {\r\n                    payable(DAO_router01).transfer(DAO_amount);\r\n                }\r\n                else if (uniswapV2Factory.getPair(token_addr, uniswapV2Router.WETH()) == address(0)) {\r\n                    IERC20(token_addr).safeTransfer(DAO_router02,DAO_amount);\r\n                }\r\n                else {\r\n                    _swapTokensForEth(token_addr, DAO_amount);\r\n                }\r\n            }\r\n            editions_by_id[_NFT_id].profit = 0;\r\n            if (!isRootNFT(_NFT_id)) {\r\n                uint128 _royalty_fee = calculateFee(amount, getRoyaltyFeeByNFTId(_NFT_id));\r\n                _addProfit(getFatherByNFTId(_NFT_id), _royalty_fee);\r\n                amount -= _royalty_fee;\r\n            }\r\n            if (token_addr == address(0)){\r\n                payable(ownerOf(_NFT_id)).transfer(amount);\r\n            }\r\n            else {\r\n                IERC20(token_addr).safeTransfer(ownerOf(_NFT_id), amount);\r\n            }\r\n            emit Claim(\r\n                _NFT_id,\r\n                ownerOf(_NFT_id),\r\n                amount\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set token URI.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_NFT_id`: transferred token id.\r\n     * - `ipfs_hash`: ipfs hash value of the URI will be set.\r\n     * Emits a {SetURI} events\r\n     */\r\n    function setURI(uint64 _NFT_id, bytes32 ipfs_hash) public {\r\n        if (getIsNDByNFTId(_NFT_id)) {\r\n            require(_NFT_id == getRootNFTIdByNFTId(_NFT_id), \"SparkLink: NFT follows the ND protocol, only the root NFT's URI can be set.\");\r\n        }\r\n        require(ownerOf(_NFT_id) == msg.sender, \"SparkLink: Only owner can set the token URI\");\r\n        _setTokenURI(_NFT_id, ipfs_hash);\r\n    }\r\n\r\n     /**\r\n     * @dev update token URI.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_NFT_id`: transferred token id.\r\n     */\r\n    function updateURI(uint64 _NFT_id) public{\r\n        require(ownerOf(_NFT_id) == msg.sender, \"SparkLink: Only owner can update the token URI\");\r\n        editions_by_id[_NFT_id].ipfs_hash = editions_by_id[getRootNFTIdByNFTId(_NFT_id)].ipfs_hash;\r\n    }\r\n\r\n    function label(uint64 _NFT_id, string memory content) public {\r\n        require(ownerOf(_NFT_id) == msg.sender, \"SparkLink: Only owner can label this NFT\");\r\n        emit Label(_NFT_id, content);\r\n    }\r\n    /**\r\n     * @dev Determine NFT price before transfer.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_NFT_id`: transferred token id.\r\n     * - `_price`: The amount of ETH should be payed for `_NFT_id`\r\n     * Emits a {DeterminePrice} events\r\n     */\r\n    function determinePrice(\r\n        uint64 _NFT_id,\r\n        uint128 _price\r\n    ) \r\n        public \r\n    {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: This NFT does not exist\");\r\n        require(msg.sender == ownerOf(_NFT_id), \"SparkLink: Only owner can set the price\");\r\n        editions_by_id[_NFT_id].transfer_price = _price;\r\n        emit DeterminePrice(_NFT_id, _price);\r\n    }\r\n\r\n    /**\r\n     * @dev Determine NFT price before transfer.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `_NFT_id`: transferred token id.\r\n     * - `_price`: The amount of ETH should be payed for `_NFT_id`\r\n     * - `_to`: The account address `approve` to. \r\n     * Emits a {DeterminePriceAndApprove} events\r\n     */\r\n    function determinePriceAndApprove(\r\n        uint64 _NFT_id,\r\n        uint128 _price,\r\n        address _to\r\n    ) \r\n        public \r\n    {\r\n        determinePrice(_NFT_id, _price);\r\n        approve(_to, _NFT_id);\r\n        emit DeterminePriceAndApprove(_NFT_id, _price, _to);\r\n    }\r\n\r\n    function setDAOFee(uint8 _DAO_fee) public onlyOwner {\r\n        require(_DAO_fee <= MAX_DAO_FEE, \"SparkLink: DAO fee can not exceed 5%\");\r\n        emit SetDAOFee(DAO_fee, _DAO_fee);\r\n        DAO_fee = _DAO_fee;\r\n    }\r\n\r\n    function setDAORouter01(address _DAO_router01) public onlyOwner {\r\n        emit SetDAORouter01(DAO_router01, _DAO_router01);\r\n        DAO_router01 = _DAO_router01;\r\n    }\r\n\r\n    function setDAORouter02(address _DAO_router02) public onlyOwner {\r\n        emit SetDAORouter01(DAO_router02, _DAO_router02);\r\n        DAO_router02 = _DAO_router02;\r\n    }\r\n\r\n    function setUniswapV2Router(address _uniswapV2Router) public onlyOwner {\r\n        uniswapV2Router =  IUniswapV2Router02(_uniswapV2Router);\r\n    }\r\n    function setUniswapV2Factory(address _uniswapV2Factory) public onlyOwner {\r\n        uniswapV2Factory = IUniswapV2Factory(_uniswapV2Factory);\r\n    }\r\n\r\n    function setLoosRatio(uint8 _loss_ratio) public onlyOwner {\r\n        require(_loss_ratio <= MAX_LOSS_RATIO, \"SparkLink: Loss ratio can not below 50%\");\r\n        emit SetLoosRatio(loss_ratio, _loss_ratio);\r\n        loss_ratio = _loss_ratio;\r\n    }\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner, \"SparkLink: Approval to current owner\");\r\n        require(\r\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"SparkLink: Approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, uint256toUint64(tokenId));\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(operator != _msgSender(), \"SparkLink: Approve to caller\");\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"SparkLink: Balance query for the zero address\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = editions_by_id[uint256toUint64(tokenId)].owner;\r\n        require(owner != address(0), \"SparkLink: Owner query for nonexistent token\");\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     *                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    \r\n    /**\r\n     * @dev Query NFT information set.\r\n     *\r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the edition queryed.\r\n     * Return :\r\n     * - `issue_information`: For root NFT it stores issue abstract sturcture\r\n     * - 0~31   `total_amount`\r\n     * - 37     `is_free`\r\n     * - 38     `is_NC`\r\n     * - 39     `is_ND`\r\n     * - 40~55  `shill_times`\r\n     * - 56~63 `royalty_fee`\r\n     * - `father_id`: For root NFT it stores issue abstract sturcture\r\n     *                For other NFTs its stores the NFT Id of which NFT it `acceptShill` from\r\n     * - `shill_price`: The price should be paid when others `accpetShill` from this NFT\r\n     * - `remaining_shill_times`: The initial value is the shilltimes of the issue it belongs to\r\n     *                      When others `acceptShill` from this NFT, it will subtract one until its value is 0  \r\n     * - `owner`: record the owner of this NFT\r\n     * - `transfer_price`: The initial value is zero\r\n     *                  Set by `determinePrice` or `determinePriceAndApprove` before `transferFrom`\r\n     *                  It will be checked wether equal to msg.value when `transferFrom` is called\r\n     *                  After `transferFrom` this value will be set to zero\r\n     * - `profit`: record the profit owner can claim (include royalty fee it should conduct to its father NFT)\r\n     * - `metadata`: IPFS hash value of the URI where this NTF's metadata stores\r\n     */\r\n\r\n    function getNFTInfoByNFTID(uint64 _NFT_id) \r\n        public view  \r\n        returns (\r\n            uint64 issue_information,\r\n            uint64 father_id,\r\n            uint128 shill_price,\r\n            uint16 remain_shill_times,\r\n            uint128 profit,\r\n            string memory metadata\r\n            ) \r\n    {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: Approved query for nonexistent token\");\r\n        return(\r\n            editions_by_id[getRootNFTIdByNFTId(_NFT_id)].father_id,\r\n            getFatherByNFTId(_NFT_id),\r\n            editions_by_id[_NFT_id].shill_price,\r\n            getRemainShillTimesByNFTId(_NFT_id),\r\n            getProfitByNFTId(_NFT_id),\r\n            tokenURI(_NFT_id)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        require(isEditionExisting(uint256toUint64(tokenId)), \"SparkLink: Approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[uint256toUint64(tokenId)];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /** \r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(isEditionExisting(uint256toUint64(tokenId)), \"SparkLink: URI query for nonexistent token\");\r\n        bytes32 _ipfs_hash = editions_by_id[uint256toUint64(tokenId)].ipfs_hash;\r\n        string memory encoded_hash = _toBase58String(_ipfs_hash);\r\n        string memory base = _baseURI();\r\n        return string(abi.encodePacked(base, encoded_hash));\r\n    }\r\n\r\n  /**\r\n     * @dev Query is issue free for first lever buyer.\r\n     *\r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the edition queryed.\r\n     * Return a bool value.\r\n     */\r\n    function getIsFreeByNFTId(uint64 _NFT_id) public view returns (bool) {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: Edition is not exist.\");\r\n        return getBoolFromUint64(37, editions_by_id[getRootNFTIdByNFTId(_NFT_id)].father_id);\r\n    }\r\n\r\n    /**\r\n     * @dev Query is issue follows the NC protocol by any NFT belongs to this issue.\r\n     *\r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the edition queryed.\r\n     * Return a bool value.\r\n     */\r\n    function getIsNCByNFTId(uint64 _NFT_id) public view returns (bool) {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: Edition is not exist.\");\r\n        return getBoolFromUint64(38, editions_by_id[getRootNFTIdByNFTId(_NFT_id)].father_id);\r\n    }\r\n\r\n    /**\r\n     * @dev Query is issue follows the ND protocol by any NFT belongs to this issue.\r\n     *\r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the edition queryed.\r\n     * Return a bool value.\r\n     */\r\n    function getIsNDByNFTId(uint64 _NFT_id) public view returns (bool) {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: Edition is not exist.\");\r\n        return getBoolFromUint64(39, editions_by_id[getRootNFTIdByNFTId(_NFT_id)].father_id);\r\n    }\r\n\r\n    /**\r\n     * @dev Query is edition exist.\r\n     *\r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the edition queryed.\r\n     * Return a bool value.\r\n     */\r\n    function isEditionExisting(uint64 _NFT_id) public view returns (bool) {\r\n        return (editions_by_id[_NFT_id].owner != address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Query the amount of ETH a NFT can be claimed.\r\n     *  \r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the NFT queryed.\r\n     * Return the value this NFT can be claimed.\r\n     * If the NFT is not root NFT, this value will subtract royalty fee percent.\r\n     */\r\n    function getProfitByNFTId(uint64 _NFT_id) public view returns (uint128){\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: Edition is not exist.\");\r\n        uint128 amount = editions_by_id[_NFT_id].profit;\r\n         if (DAO_fee != 0) {\r\n                uint128 DAO_amount = calculateFee(amount, DAO_fee);\r\n                amount -= DAO_amount;\r\n        }\r\n        if (!isRootNFT(_NFT_id)) {\r\n            uint128 _total_fee = calculateFee(amount, getRoyaltyFeeByNFTId(_NFT_id));            \r\n            amount -= _total_fee;\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Query royalty fee percent of an issue by any NFT belongs to this issue.\r\n     *  \r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the NFT queryed.\r\n     * Return royalty fee percent of this issue.\r\n     */\r\n    function getRoyaltyFeeByNFTId(uint64 _NFT_id) public view returns (uint8) {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: Edition is not exist.\");\r\n        return getUint8FromUint64(56, editions_by_id[getRootNFTIdByNFTId(_NFT_id)].father_id);\r\n    }\r\n\r\n    /**\r\n     * @dev Query max shill times of an issue by any NFT belongs to this issue.\r\n     *  \r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the NFT queryed.\r\n     * Return max shill times of this issue.\r\n     */\r\n    function getShillTimesByNFTId(uint64 _NFT_id) public view returns (uint16) {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: Edition is not exist.\");\r\n        return getUint16FromUint64(40, editions_by_id[getRootNFTIdByNFTId(_NFT_id)].father_id);\r\n    }\r\n\r\n    /**\r\n     * @dev Query total NFT number of a issue by any NFT belongs to this issue.\r\n     *  \r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the NFT queryed.\r\n     * Return total NFT number of this issue.\r\n     */\r\n    function getTotalAmountByNFTId(uint64 _NFT_id) public view returns (uint32) {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: Edition is not exist.\");\r\n        return getBottomUint32FromUint64(editions_by_id[getRootNFTIdByNFTId(_NFT_id)].father_id);\r\n    }\r\n\r\n    /**\r\n     * @dev Query supported token address of a issue by any NFT belongs to this issue.\r\n     *  \r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the NFT queryed.\r\n     * Return supported token address of this NFT.\r\n     * Address 0 represent ETH.\r\n     */\r\n    function getTokenAddrByNFTId(uint64 _NFT_id) public view returns (address) {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: Edition is not exist.\");\r\n        return token_addresses[uint32(_NFT_id>>32)];\r\n    }\r\n\r\n    /**\r\n     * @dev Query the id of this NFT's father NFT.\r\n     *  \r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the NFT queryed.\r\n     * - This NFT should exist and not be root NFT.\r\n     * Return the father NFT id of this NFT.\r\n     */\r\n    function getFatherByNFTId(uint64 _NFT_id) public view returns (uint64) {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: Edition is not exist.\");\r\n        if (isRootNFT(_NFT_id)) {\r\n            return 0;\r\n        }\r\n        return editions_by_id[_NFT_id].father_id;\r\n    }    \r\n    \r\n    /**\r\n     * @dev Query transfer_price of this NFT.\r\n     *  \r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the NFT queryed.\r\n     * Return transfer_price of this NFT.\r\n     */\r\n    function getTransferPriceByNFTId(uint64 _NFT_id) public view returns (uint128) {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: Edition is not exist.\");\r\n        return editions_by_id[_NFT_id].transfer_price;\r\n    }\r\n\r\n    /**\r\n     * @dev Query shill_price of this NFT.\r\n     *  \r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the NFT queryed.\r\n     * Return shill_price of this NFT.\r\n     */\r\n    function getShillPriceByNFTId(uint64 _NFT_id) public view returns (uint128) {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: Edition is not exist.\");\r\n        if (getIsFreeByNFTId(_NFT_id)&&isRootNFT(_NFT_id))\r\n            return 0;\r\n        else\r\n            return editions_by_id[_NFT_id].shill_price;\r\n    }\r\n\r\n    /**\r\n     * @dev Query remaining_shill_times of this NFT.\r\n     *  \r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the NFT queryed.\r\n     * Return remaining_shill_times of this NFT.\r\n     */\r\n    function getRemainShillTimesByNFTId(uint64 _NFT_id) public view returns (uint16) {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: Edition is not exist.\");\r\n        return editions_by_id[_NFT_id].remaining_shill_times;\r\n    }\r\n\r\n    /**\r\n     * @dev Query depth of this NFT.\r\n     *  \r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the NFT queryed.\r\n     * Return depth of this NFT.\r\n     */\r\n    function getDepthByNFTId(uint64 _NFT_id) public view returns (uint64) {\r\n        require(isEditionExisting(_NFT_id), \"SparkLink: Edition is not exist.\");\r\n        uint64 depth = 0;\r\n        for (depth = 0; !isRootNFT(_NFT_id); _NFT_id = getFatherByNFTId(_NFT_id)) {\r\n            depth += 1;\r\n        }\r\n        return depth;\r\n    }\r\n\r\n    /**\r\n     * @dev Query is this NFT is root NFT by check is its edition id is 1.\r\n     *  \r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the NFT queryed.\r\n     * Return a bool value to indicate wether this NFT is root NFT.\r\n     */\r\n    function isRootNFT(uint64 _NFT_id) public pure returns (bool) {\r\n        return getBottomUint32FromUint64(_NFT_id) == uint32(1);\r\n    }\r\n\r\n    /**\r\n     * @dev Query root NFT id by NFT id.\r\n     *  \r\n     * Requirements:\r\n     * - `_NFT_id`: The id of the NFT queryed.\r\n     * Return a bool value to indicate wether this NFT is root NFT.\r\n     */\r\n    function getRootNFTIdByNFTId(uint64 _NFT_id) public pure returns (uint64) {\r\n        return ((_NFT_id>>32)<<32 | uint64(1));\r\n    }\r\n\r\n    /**\r\n     * @dev Query loss ratio of this contract.\r\n     *  \r\n     * Return loss ratio of this contract.\r\n     */\r\n    function getLossRatio() public view returns (uint8) {\r\n        return loss_ratio;\r\n    }\r\n    \r\n    /**\r\n     * @dev Calculate edition id by NFT id.\r\n     *  \r\n     * Requirements:\r\n     * - `_NFT_id`: The NFT id of the NFT caller want to get.\r\n     * Return edition id.\r\n     */\r\n    function getEditionIdByNFTId(uint64 _NFT_id) public pure returns (uint32) {\r\n        return getBottomUint32FromUint64(_NFT_id);\r\n    }\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n    uint8 public loss_ratio = 62;\r\n    uint8 public DAO_fee = 2;\r\n    uint8 public constant MAX_DAO_FEE = 2;\r\n    uint8 public constant MAX_LOSS_RATIO = 50;\r\n    address public DAO_router01;\r\n    address public DAO_router02;\r\n    IUniswapV2Router02 public  uniswapV2Router;\r\n    IUniswapV2Factory public  uniswapV2Factory;\r\n    // Mapping owner address to token count\r\n    mapping(address => uint64) private _balances;\r\n    // Mapping from token ID to approved address\r\n    mapping(uint64 => address) private _tokenApprovals;\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n    mapping (uint64 => Edition) private editions_by_id;\r\n    // mapping from issue ID to support ERC20 token address\r\n    mapping(uint32 => address) private token_addresses;\r\n\r\n    bytes constant private sha256MultiHash = hex\"1220\"; \r\n    bytes constant private ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\r\n\r\n    function _swapTokensForEth(address token_addr, uint128 token_amount) private {\r\n        // generate the uniswap pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = token_addr;\r\n        path[1] = uniswapV2Router.WETH();\r\n\r\n        IERC20(token_addr).approve(address(uniswapV2Router), token_amount);\r\n\r\n        // make the swap\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            token_amount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            DAO_router01,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n\r\n     /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint64 tokenId,\r\n        bytes memory _data\r\n    ) \r\n        private \r\n        returns (bool) \r\n    {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"SparkLink: Transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _setTokenURI(uint64 tokenId, bytes32 ipfs_hash) internal virtual {\r\n        bytes32 old_URI = editions_by_id[tokenId].ipfs_hash;\r\n        editions_by_id[tokenId].ipfs_hash = ipfs_hash;\r\n        emit SetURI(tokenId, old_URI, ipfs_hash);\r\n    }\r\n    \r\n     /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param _NFT_id NFT id of father NFT\r\n     * @param _owner indicate the address new NFT transfer to\r\n     * @return a uint64 store new NFT id\r\n     **/\r\n    function _mintNFT(\r\n        uint64 _NFT_id,\r\n        address _owner\r\n    ) \r\n        internal \r\n        returns (uint64) \r\n    {\r\n        _addTotalAmount(_NFT_id);\r\n        uint32 new_edition_id = getTotalAmountByNFTId(_NFT_id);\r\n        uint64 new_NFT_id = getNftIdByEditionIdAndIssueId(uint32(_NFT_id>>32), new_edition_id);\r\n        require(\r\n            _checkOnERC721Received(address(0), _owner, new_NFT_id, \"\"),\r\n            \"SparkLink: Transfer to non ERC721Receiver implementer\"\r\n        );\r\n        Edition storage new_NFT = editions_by_id[new_NFT_id];\r\n        new_NFT.remaining_shill_times = getShillTimesByNFTId(_NFT_id);\r\n        new_NFT.father_id = _NFT_id;\r\n        if (getIsFreeByNFTId(_NFT_id)&&isRootNFT(_NFT_id))\r\n            new_NFT.shill_price = editions_by_id[_NFT_id].shill_price;\r\n        else\r\n            new_NFT.shill_price = calculateFee(editions_by_id[_NFT_id].shill_price, loss_ratio);\r\n        if (new_NFT.shill_price == 0) {\r\n            new_NFT.shill_price = editions_by_id[_NFT_id].shill_price;\r\n        }\r\n        new_NFT.owner = _owner;\r\n        new_NFT.ipfs_hash = editions_by_id[_NFT_id].ipfs_hash;\r\n        _balances[_owner] += 1;\r\n        emit Transfer(address(0), _owner, new_NFT_id);\r\n        return new_NFT_id;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to clear approve and transfer_price\r\n     *\r\n     * @param _NFT_id NFT id of father NFT\r\n     **/\r\n    function _afterTokenTransfer (uint64 _NFT_id) internal {\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), _NFT_id);\r\n        editions_by_id[_NFT_id].transfer_price = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to support transfer `tokenId` from `from` to `to`.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint64 tokenId\r\n    ) \r\n        internal \r\n        virtual \r\n    {\r\n        require(ownerOf(tokenId) == from, \"SparkLink: Transfer of token that is not own\");\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"SparkLink: Transfer caller is not owner nor approved\");\r\n        require(to != address(0), \"SparkLink: Transfer to the zero address\");\r\n        if (msg.sender != ownerOf(tokenId)) {\r\n            address token_addr = getTokenAddrByNFTId(tokenId);\r\n            uint128 transfer_price = editions_by_id[tokenId].transfer_price;\r\n            if (token_addr == address(0)){\r\n                require(msg.value == transfer_price, \"SparkLink: Price not met\");\r\n                _addProfit(tokenId, transfer_price);\r\n            }\r\n            else {\r\n                uint256 before_balance = IERC20(token_addr).balanceOf(address(this));\r\n                IERC20(token_addr).safeTransferFrom(msg.sender, address(this), transfer_price);\r\n                _addProfit(tokenId, uint256toUint128(IERC20(token_addr).balanceOf(address(this))-before_balance));\r\n            }\r\n            claimProfit(tokenId);\r\n        }\r\n        else {\r\n            claimProfit(tokenId);\r\n        }\r\n        _afterTokenTransfer(tokenId);\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        editions_by_id[tokenId].owner = to;\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n     /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint64 tokenId,\r\n        bytes memory _data\r\n    ) \r\n        internal \r\n        virtual \r\n    {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"SparkLink: Transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(address to, uint64 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    function _addProfit(uint64 _NFT_id, uint128 _increase) internal {\r\n        editions_by_id[_NFT_id].profit = editions_by_id[_NFT_id].profit+_increase;\r\n    }\r\n\r\n    function _addTotalAmount(uint64 _NFT_Id) internal {\r\n        require(getTotalAmountByNFTId(_NFT_Id) < type(uint32).max, \"SparkLink: There is no left in this issue.\");\r\n        editions_by_id[getRootNFTIdByNFTId(_NFT_Id)].father_id += 1;\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, uint64 tokenId) internal view virtual returns (bool) {\r\n        require(isEditionExisting(tokenId), \"SparkLink: Operator query for nonexistent token\");\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n        \r\n    function _baseURI() internal pure returns (string memory) {\r\n        return \"https://ipfs.io/ipfs/\";\r\n    } \r\n\r\n\r\n    /**\r\n     * @dev Calculate NFT id by issue id and edition id.\r\n     *  \r\n     * Requirements:\r\n     * - `_issue_id`: The issue id of the NFT caller want to get.\r\n     * - `_edition_id`: The edition id of the NFT caller want to get.\r\n     * Return NFT id.\r\n     */\r\n    function getNftIdByEditionIdAndIssueId(uint32 _issue_id, uint32 _edition_id) internal pure returns (uint64) {\r\n        return (uint64(_issue_id)<<32)|uint64(_edition_id);\r\n    }\r\n\r\n    function getBoolFromUint64(uint8 position, uint64 data64) internal pure returns (bool flag) {\r\n        // (((1 << size) - 1) & base >> position)\r\n        assembly {\r\n            flag := and(1, shr(position, data64))\r\n        }\r\n    }\r\n\r\n    function getUint8FromUint64(uint8 position, uint64 data64) internal pure returns (uint8 data8) {\r\n        // (((1 << size) - 1) & base >> position)\r\n        assembly {\r\n            data8 := and(sub(shl(8, 1), 1), shr(position, data64))\r\n        }\r\n    }\r\n    function getUint16FromUint64(uint8 position, uint64 data64) internal pure returns (uint16 data16) {\r\n        // (((1 << size) - 1) & base >> position)\r\n        assembly {\r\n            data16 := and(sub(shl(16, 1), 1), shr(position, data64))\r\n        }\r\n    }\r\n    function getBottomUint32FromUint64(uint64 data64) internal pure returns (uint32 data32) {\r\n        // (((1 << size) - 1) & base >> position)\r\n        assembly {\r\n            data32 := and(sub(shl(32, 1), 1), data64)\r\n        }\r\n    }\r\n\r\n    function reWriteBoolInUint64(uint8 position, bool flag, uint64 data64) internal pure returns (uint64 boxed) {\r\n        assembly {\r\n            // mask = ~((1 << 8 - 1) << position)\r\n            // _box = (mask & _box) | ()data << position)\r\n            boxed := or( and(data64, not(shl(position, 1))), shl(position, flag))\r\n        }\r\n    }\r\n\r\n    \r\n    function reWriteUint8InUint64(uint8 position, uint8 flag, uint64 data64) internal pure returns (uint64 boxed) {\r\n        assembly {\r\n            // mask = ~((1 << 8 - 1) << position)\r\n            // _box = (mask & _box) | ()data << position)\r\n            boxed := or(and(data64, not(shl(position, 1))), shl(position, flag))\r\n        }\r\n    }\r\n\r\n    function reWriteUint16InUint64(uint8 position, uint16 data16, uint64 data64) internal pure returns (uint64 boxed) {\r\n        assembly {\r\n            // mask = ~((1 << 16 - 1) << position)\r\n            // _box = (mask & _box) | ()data << position)\r\n            boxed := or( and(data64, not(shl(position, sub(shl(16, 1), 1)))), shl(position, data16))\r\n        }\r\n    }\r\n\r\n    function uint256toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value <= type(uint64).max, \"SparkLink: Value doesn't fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    function uint256toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value <= type(uint128).max, \"SparkLink: Value doesn't fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n    \r\n    function calculateFee(uint128 _amount, uint8 _fee_percent) internal pure returns (uint128) {\r\n        return _amount*_fee_percent/10**2;\r\n    }\r\n\r\n    function _toBase58String(bytes32 con) internal pure returns (string memory) {\r\n        \r\n        bytes memory source = bytes.concat(sha256MultiHash,con);\r\n\r\n        uint8[] memory digits = new uint8[](64); //TODO: figure out exactly how much is needed\r\n        digits[0] = 0;\r\n        uint8 digitlength = 1;\r\n        for (uint256 i = 0; i<source.length; ++i) {\r\n        uint carry = uint8(source[i]);\r\n        for (uint256 j = 0; j<digitlength; ++j) {\r\n            carry += uint(digits[j]) * 256;\r\n            digits[j] = uint8(carry % 58);\r\n            carry = carry / 58;\r\n        }\r\n        \r\n        while (carry > 0) {\r\n            digits[digitlength] = uint8(carry % 58);\r\n            digitlength++;\r\n            carry = carry / 58;\r\n        }\r\n        }\r\n        //return digits;\r\n        return string(toAlphabet(reverse(truncate(digits, digitlength))));\r\n    }\r\n\r\n    function toAlphabet(uint8[] memory indices) internal pure returns (bytes memory) {\r\n        bytes memory output = new bytes(indices.length);\r\n        for (uint256 i = 0; i<indices.length; i++) {\r\n            output[i] = ALPHABET[indices[i]];\r\n        }\r\n        return output;\r\n    }\r\n    \r\n    function truncate(uint8[] memory array, uint8 length) internal pure returns (uint8[] memory) {\r\n        uint8[] memory output = new uint8[](length);\r\n        for (uint256 i = 0; i<length; i++) {\r\n            output[i] = array[i];\r\n        }\r\n        return output;\r\n    }\r\n  \r\n    function reverse(uint8[] memory input) internal pure returns (uint8[] memory) {\r\n        uint8[] memory output = new uint8[](input.length);\r\n        for (uint256 i = 0; i<input.length; i++) {\r\n            output[i] = input[input.length-1-i];\r\n        }\r\n        return output;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"DAO_router_address01\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"DAO_router_address02\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"uniswapRouterAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factoryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"NFT_id\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"NFT_id\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"transfer_price\",\"type\":\"uint128\"}],\"name\":\"DeterminePrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"NFT_id\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"transfer_price\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"DeterminePriceAndApprove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"NFT_id\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"content\",\"type\":\"string\"}],\"name\":\"Label\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"publisher\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"rootNFTId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token_addr\",\"type\":\"address\"}],\"name\":\"Publish\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"old_DAO_fee\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"new_DAO_fee\",\"type\":\"uint8\"}],\"name\":\"SetDAOFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"old_router_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"new_router_address\",\"type\":\"address\"}],\"name\":\"SetDAORouter01\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"old_router_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"new_router_address\",\"type\":\"address\"}],\"name\":\"SetDAORouter02\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"old_loss_ratio\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"new_loss_ratio\",\"type\":\"uint8\"}],\"name\":\"SetLoosRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"NFT_id\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"old_URI\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"new_URI\",\"type\":\"bytes32\"}],\"name\":\"SetURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAO_fee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAO_router01\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAO_router02\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DAO_FEE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_LOSS_RATIO\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"acceptShill\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"claimProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"_price\",\"type\":\"uint128\"}],\"name\":\"determinePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"_price\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"determinePriceAndApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getDepthByNFTId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getEditionIdByNFTId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getFatherByNFTId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getIsFreeByNFTId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getIsNCByNFTId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getIsNDByNFTId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLossRatio\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getNFTInfoByNFTID\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"issue_information\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"father_id\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"shill_price\",\"type\":\"uint128\"},{\"internalType\":\"uint16\",\"name\":\"remain_shill_times\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"profit\",\"type\":\"uint128\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getProfitByNFTId\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getRemainShillTimesByNFTId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getRootNFTIdByNFTId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getRoyaltyFeeByNFTId\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getShillPriceByNFTId\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getShillTimesByNFTId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getTokenAddrByNFTId\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getTotalAmountByNFTId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"getTransferPriceByNFTId\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"isEditionExisting\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"isRootNFT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"content\",\"type\":\"string\"}],\"name\":\"label\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loss_ratio\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_first_sell_price\",\"type\":\"uint128\"},{\"internalType\":\"uint8\",\"name\":\"_royalty_fee\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"_shill_times\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"_ipfs_hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_token_addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_is_free\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_is_NC\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_is_ND\",\"type\":\"bool\"}],\"name\":\"publish\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_DAO_fee\",\"type\":\"uint8\"}],\"name\":\"setDAOFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_DAO_router01\",\"type\":\"address\"}],\"name\":\"setDAORouter01\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_DAO_router02\",\"type\":\"address\"}],\"name\":\"setDAORouter02\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_loss_ratio\",\"type\":\"uint8\"}],\"name\":\"setLoosRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"ipfs_hash\",\"type\":\"bytes32\"}],\"name\":\"setURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapV2Factory\",\"type\":\"address\"}],\"name\":\"setUniswapV2Factory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniswapV2Router\",\"type\":\"address\"}],\"name\":\"setUniswapV2Router\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Factory\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_NFT_id\",\"type\":\"uint64\"}],\"name\":\"updateURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SparkLink","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005245841d384c48ea47f16da587b31d23e194cb4a00000000000000000000000063c8d73cedd89a42cba911f890fdca94648b7baf0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://933f6f737a354378b11fa0569b363a10f31397d3f42d4be2a8b4cad33b3ab021"}]}