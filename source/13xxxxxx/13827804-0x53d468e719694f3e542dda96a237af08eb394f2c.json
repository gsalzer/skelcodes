{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"brink-verifiers/Verifiers/LimitSwapVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.8.10;\\npragma abicoder v1;\\n\\n/**\\n *    ,,                           ,,                                \\n *   *MM                           db                      `7MM      \\n *    MM                                                     MM      \\n *    MM,dMMb.      `7Mb,od8     `7MM      `7MMpMMMb.        MM  ,MP'\\n *    MM    `Mb       MM' \\\"'       MM        MM    MM        MM ;Y   \\n *    MM     M8       MM           MM        MM    MM        MM;Mm   \\n *    MM.   ,M9       MM           MM        MM    MM        MM `Mb. \\n *    P^YbmdP'      .JMML.       .JMML.    .JMML  JMML.    .JMML. YA.\\n *\\n *    LimitSwapVerifier.sol :: 0x53D468E719694f3e542Dda96a237Af08eb394f2C\\n *    etherscan.io verified 2021-12-18\\n */ \\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../Interfaces/ICallExecutor.sol\\\";\\nimport \\\"../Libraries/Bit.sol\\\";\\n\\n/// @title Verifier for ERC20 limit swaps\\n/// @notice These functions should be executed by metaPartialSignedDelegateCall() on Brink account proxy contracts\\ncontract LimitSwapVerifier {\\n  /// @dev Revert when limit swap is expired\\n  error Expired();\\n\\n  /// @dev Revert when swap has not received enough of the output asset to be fulfilled\\n  error NotEnoughReceived(uint256 amountReceived);\\n\\n  ICallExecutor internal immutable CALL_EXECUTOR;\\n\\n  constructor(ICallExecutor callExecutor) {\\n    CALL_EXECUTOR = callExecutor;\\n  }\\n\\n  /// @dev Executes an ERC20 to ERC20 limit swap\\n  /// @notice This should be executed by metaDelegateCall() or metaDelegateCall_EIP1271() with the following signed and unsigned params\\n  /// @param bitmapIndex The index of the replay bit's bytes32 slot [signed]\\n  /// @param bit The value of the replay bit [signed]\\n  /// @param tokenIn The input token provided for the swap [signed]\\n  /// @param tokenOut The output token required to be received from the swap [signed]\\n  /// @param tokenInAmount Amount of tokenIn provided [signed]\\n  /// @param tokenOutAmount Amount of tokenOut required to be received [signed]\\n  /// @param expiryBlock The block when the swap expires [signed]\\n  /// @param to Address of the contract that will fulfill the swap [unsigned]\\n  /// @param data Data to execute on the `to` contract to fulfill the swap [unsigned]\\n  function tokenToToken(\\n    uint256 bitmapIndex, uint256 bit, IERC20 tokenIn, IERC20 tokenOut, uint256 tokenInAmount, uint256 tokenOutAmount,\\n    uint256 expiryBlock, address to, bytes calldata data\\n  )\\n    external\\n  {\\n    if (expiryBlock <= block.number) {\\n      revert Expired();\\n    }\\n  \\n    Bit.useBit(bitmapIndex, bit);\\n\\n    uint256 tokenOutBalance = tokenOut.balanceOf(address(this));\\n\\n    tokenIn.transfer(to, tokenInAmount);\\n\\n    CALL_EXECUTOR.proxyCall(to, data);\\n\\n    uint256 tokenOutAmountReceived = tokenOut.balanceOf(address(this)) - tokenOutBalance;\\n    if (tokenOutAmountReceived < tokenOutAmount) {\\n      revert NotEnoughReceived(tokenOutAmountReceived);\\n    }\\n  }\\n\\n  /// @dev Executes an ETH to ERC20 limit swap\\n  /// @notice This should be executed by metaDelegateCall() or metaDelegateCall_EIP1271() with the following signed and unsigned params\\n  /// @param bitmapIndex The index of the replay bit's bytes32 slot [signed]\\n  /// @param bit The value of the replay bit [signed]\\n  /// @param token The output token required to be received from the swap [signed]\\n  /// @param ethAmount Amount of ETH provided [signed]\\n  /// @param tokenAmount Amount of token required to be received [signed]\\n  /// @param expiryBlock The block when the swap expires [signed]\\n  /// @param to Address of the contract that will fulfill the swap [unsigned]\\n  /// @param data Data to execute on the `to` contract to fulfill the swap [unsigned]\\n  function ethToToken(\\n    uint256 bitmapIndex, uint256 bit, IERC20 token, uint256 ethAmount, uint256 tokenAmount, uint256 expiryBlock,\\n    address to, bytes calldata data\\n  )\\n    external\\n  {\\n    if (expiryBlock <= block.number) {\\n      revert Expired();\\n    }\\n\\n    Bit.useBit(bitmapIndex, bit);\\n\\n    uint256 tokenBalance = token.balanceOf(address(this));\\n\\n    CALL_EXECUTOR.proxyCall{value: ethAmount}(to, data);\\n\\n    uint256 tokenAmountReceived = token.balanceOf(address(this)) - tokenBalance;\\n    if (tokenAmountReceived < tokenAmount) {\\n      revert NotEnoughReceived(tokenAmountReceived);\\n    }\\n  }\\n\\n  /// @dev Executes an ERC20 to ETH limit swap\\n  /// @notice This should be executed by metaDelegateCall() or metaDelegateCall_EIP1271() with the following signed and unsigned params\\n  /// @param bitmapIndex The index of the replay bit's bytes32 slot [signed]\\n  /// @param bit The value of the replay bit [signed]\\n  /// @param token The input token provided for the swap [signed]\\n  /// @param tokenAmount Amount of tokenIn provided [signed]\\n  /// @param ethAmount Amount of ETH to receive [signed]\\n  /// @param expiryBlock The block when the swap expires [signed]\\n  /// @param to Address of the contract that will fulfill the swap [unsigned]\\n  /// @param data Data to execute on the `to` contract to fulfill the swap [unsigned]\\n  function tokenToEth(\\n    uint256 bitmapIndex, uint256 bit, IERC20 token, uint256 tokenAmount, uint256 ethAmount, uint256 expiryBlock,\\n    address to, bytes calldata data\\n  )\\n    external\\n  {\\n    if (expiryBlock <= block.number) {\\n      revert Expired();\\n    }\\n\\n    Bit.useBit(bitmapIndex, bit);\\n    \\n    uint256 ethBalance = address(this).balance;\\n\\n    token.transfer(to, tokenAmount);\\n\\n    CALL_EXECUTOR.proxyCall(to, data);\\n\\n    uint256 ethAmountReceived = address(this).balance - ethBalance;\\n    if (ethAmountReceived < ethAmount) {\\n      revert NotEnoughReceived(ethAmountReceived);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"brink-verifiers/Interfaces/ICallExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.8.10;\\npragma abicoder v1;\\n\\ninterface ICallExecutor {\\n  function proxyCall(address to, bytes memory data) external payable;\\n}\\n\"\r\n    },\r\n    \"brink-verifiers/Libraries/Bit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.8.10;\\npragma abicoder v1;\\n\\n/// @title Bit replay protection library\\n/// @notice Handles storage and loads for replay protection bits\\n/// @dev Solution adapted from https://github.com/PISAresearch/metamask-comp/blob/77fa8295c168ee0b6bf801cbedab797d6f8cfd5d/src/contracts/BitFlipMetaTransaction/README.md\\n/// @dev This is a gas optimized technique that stores up to 256 replay protection bits per bytes32 slot\\nlibrary Bit {\\n  /// @dev Revert when bit provided is not valid\\n  error InvalidBit();\\n\\n  /// @dev Revert when bit provided is used\\n  error BitUsed();\\n\\n  /// @dev Initial pointer for bitmap storage ptr computation\\n  /// @notice This is the uint256 representation of keccak(\\\"bmp\\\")\\n  uint256 constant INITIAL_BMP_PTR = \\n  48874093989078844336340380824760280705349075126087700760297816282162649029611;\\n\\n  /// @dev Adds a bit to the uint256 bitmap at bitmapIndex\\n  /// @dev Value of bit cannot be zero and must represent a single bit\\n  /// @param bitmapIndex The index of the uint256 bitmap\\n  /// @param bit The value of the bit within the uint256 bitmap\\n  function useBit(uint256 bitmapIndex, uint256 bit) internal {\\n    if (!validBit(bit)) {\\n      revert InvalidBit();\\n    }\\n    bytes32 ptr = bitmapPtr(bitmapIndex);\\n    uint256 bitmap = loadUint(ptr);\\n    if (bitmap & bit != 0) {\\n      revert BitUsed();\\n    }\\n    uint256 updatedBitmap = bitmap | bit;\\n    assembly { sstore(ptr, updatedBitmap) }\\n  }\\n\\n  /// @dev Check that a bit is valid\\n  /// @param bit The bit to check\\n  /// @return isValid True if bit is greater than zero and represents a single bit\\n  function validBit(uint256 bit) internal pure returns (bool isValid) {\\n    assembly {\\n      // equivalent to: isValid = (bit > 0 && bit & bit-1) == 0;\\n      isValid := and(\\n        iszero(iszero(bit)), \\n        iszero(and(bit, sub(bit, 1)))\\n      )\\n    } \\n  }\\n\\n  /// @dev Get a bitmap storage pointer\\n  /// @return The bytes32 pointer to the storage location of the uint256 bitmap at bitmapIndex\\n  function bitmapPtr (uint256 bitmapIndex) internal pure returns (bytes32) {\\n    return bytes32(INITIAL_BMP_PTR + bitmapIndex);\\n  }\\n\\n  /// @dev Returns the uint256 value at storage location ptr\\n  /// @param ptr The storage location pointer\\n  /// @return val The uint256 value at storage location ptr\\n  function loadUint(bytes32 ptr) internal view returns (uint256 val) {\\n    assembly { val := sload(ptr) }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ICallExecutor\",\"name\":\"callExecutor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BitUsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Expired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"}],\"name\":\"NotEnoughReceived\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bitmapIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bit\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ethToToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bitmapIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bit\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tokenToEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bitmapIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bit\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenInAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenOutAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tokenToToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LimitSwapVerifier","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"800","ConstructorArguments":"000000000000000000000000de61dfe5fbf3f4df70b16d0618f69b96a2754bf8","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}