{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at BscScan.com on 2021-10-30\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n\t/**\r\n\t * @dev Returns the amount of tokens in existence.\r\n\t */\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Returns the amount of tokens owned by `account`.\r\n\t */\r\n\tfunction balanceOf(address account) external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n\t *\r\n\t * Returns a boolean value indicating whether the operation succeeded.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n\t/**\r\n\t * @dev Returns the remaining number of tokens that `spender` will be\r\n\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n\t * zero by default.\r\n\t *\r\n\t * This value changes when {approve} or {transferFrom} are called.\r\n\t */\r\n\tfunction allowance(address owner, address spender) external view returns (uint256);\r\n\r\n\t/**\r\n\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n\t *\r\n\t * Returns a boolean value indicating whether the operation succeeded.\r\n\t *\r\n\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n\t * that someone may use both the old and the new allowance by unfortunate\r\n\t * transaction ordering. One possible solution to mitigate this race\r\n\t * condition is to first reduce the spender's allowance to 0 and set the\r\n\t * desired value afterwards:\r\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n\t *\r\n\t * Emits an {Approval} event.\r\n\t */\r\n\tfunction approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\t/**\r\n\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n\t * allowance mechanism. `amount` is then deducted from the caller's\r\n\t * allowance.\r\n\t *\r\n\t * Returns a boolean value indicating whether the operation succeeded.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction transferFrom(\r\n\t\taddress sender,\r\n\t\taddress recipient,\r\n\t\tuint256 amount\r\n\t) external returns (bool);\r\n\r\n\t/**\r\n\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n\t * another (`to`).\r\n\t *\r\n\t * Note that `value` may be zero.\r\n\t */\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\t/**\r\n\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n\t * a call to {approve}. `value` is the new allowance.\r\n\t */\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v4.3.2\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n\t/**\r\n\t * @dev Returns true if `account` is a contract.\r\n\t *\r\n\t * [IMPORTANT]\r\n\t * ====\r\n\t * It is unsafe to assume that an address for which this function returns\r\n\t * false is an externally-owned account (EOA) and not a contract.\r\n\t *\r\n\t * Among others, `isContract` will return false for the following\r\n\t * types of addresses:\r\n\t *\r\n\t *  - an externally-owned account\r\n\t *  - a contract in construction\r\n\t *  - an address where a contract will be created\r\n\t *  - an address where a contract lived, but was destroyed\r\n\t * ====\r\n\t */\r\n\tfunction isContract(address account) internal view returns (bool) {\r\n\t\t// This method relies on extcodesize, which returns 0 for contracts in\r\n\t\t// construction, since the code is only stored at the end of the\r\n\t\t// constructor execution.\r\n\r\n\t\tuint256 size;\r\n\t\tassembly {\r\n\t\t\tsize := extcodesize(account)\r\n\t\t}\r\n\t\treturn size > 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n\t * `recipient`, forwarding all available gas and reverting on errors.\r\n\t *\r\n\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n\t * imposed by `transfer`, making them unable to receive funds via\r\n\t * `transfer`. {sendValue} removes this limitation.\r\n\t *\r\n\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n\t *\r\n\t * IMPORTANT: because control is transferred to `recipient`, care must be\r\n\t * taken to not create reentrancy vulnerabilities. Consider using\r\n\t * {ReentrancyGuard} or the\r\n\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n\t */\r\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n\t\t(bool success, ) = recipient.call{value: amount}(\"\");\r\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Performs a Solidity function call using a low level `call`. A\r\n\t * plain `call` is an unsafe replacement for a function call: use this\r\n\t * function instead.\r\n\t *\r\n\t * If `target` reverts with a revert reason, it is bubbled up by this\r\n\t * function (like regular Solidity function calls).\r\n\t *\r\n\t * Returns the raw returned data. To convert to the expected return value,\r\n\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `target` must be a contract.\r\n\t * - calling `target` with `data` must not revert.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n\t * `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but also transferring `value` wei to `target`.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - the calling contract must have an ETH balance of at least `value`.\r\n\t * - the called Solidity function must be `payable`.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 value\r\n\t) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n\t * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 value,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n\t\trequire(isContract(target), \"Address: call to non-contract\");\r\n\r\n\t\t(bool success, bytes memory returndata) = target.call{value: value}(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but performing a static call.\r\n\t *\r\n\t * _Available since v3.3._\r\n\t */\r\n\tfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n\t\treturn functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n\t * but performing a static call.\r\n\t *\r\n\t * _Available since v3.3._\r\n\t */\r\n\tfunction functionStaticCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal view returns (bytes memory) {\r\n\t\trequire(isContract(target), \"Address: static call to non-contract\");\r\n\r\n\t\t(bool success, bytes memory returndata) = target.staticcall(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but performing a delegate call.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n\t * but performing a delegate call.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction functionDelegateCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\trequire(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n\t\t(bool success, bytes memory returndata) = target.delegatecall(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n\t * revert reason using the provided one.\r\n\t *\r\n\t * _Available since v4.3._\r\n\t */\r\n\tfunction verifyCallResult(\r\n\t\tbool success,\r\n\t\tbytes memory returndata,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (bytes memory) {\r\n\t\tif (success) {\r\n\t\t\treturn returndata;\r\n\t\t} else {\r\n\t\t\t// Look for revert reason and bubble it up if present\r\n\t\t\tif (returndata.length > 0) {\r\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n\t\t\t\tassembly {\r\n\t\t\t\t\tlet returndata_size := mload(returndata)\r\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\trevert(errorMessage);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol@v4.3.2\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n\tusing Address for address;\r\n\r\n\tfunction safeTransfer(\r\n\t\tIERC20 token,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n\t}\r\n\r\n\tfunction safeTransferFrom(\r\n\t\tIERC20 token,\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Deprecated. This function has issues similar to the ones found in\r\n\t * {IERC20-approve}, and its usage is discouraged.\r\n\t *\r\n\t * Whenever possible, use {safeIncreaseAllowance} and\r\n\t * {safeDecreaseAllowance} instead.\r\n\t */\r\n\tfunction safeApprove(\r\n\t\tIERC20 token,\r\n\t\taddress spender,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\t// safeApprove should only be called when setting an initial allowance,\r\n\t\t// or when resetting it to zero. To increase and decrease it, use\r\n\t\t// 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n\t\trequire(\r\n\t\t\t(value == 0) || (token.allowance(address(this), spender) == 0),\r\n\t\t\t\"SafeERC20: approve from non-zero to non-zero allowance\"\r\n\t\t);\r\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n\t}\r\n\r\n\tfunction safeIncreaseAllowance(\r\n\t\tIERC20 token,\r\n\t\taddress spender,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\tuint256 newAllowance = token.allowance(address(this), spender) + value;\r\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n\t}\r\n\r\n\tfunction safeDecreaseAllowance(\r\n\t\tIERC20 token,\r\n\t\taddress spender,\r\n\t\tuint256 value\r\n\t) internal {\r\n\t\tunchecked {\r\n\t\t\tuint256 oldAllowance = token.allowance(address(this), spender);\r\n\t\t\trequire(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n\t\t\tuint256 newAllowance = oldAllowance - value;\r\n\t\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n\t * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n\t * @param token The token targeted by the call.\r\n\t * @param data The call data (encoded using abi.encode or one of its variants).\r\n\t */\r\n\tfunction _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n\t\t// We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n\t\t// we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n\t\t// the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n\t\tbytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n\t\tif (returndata.length > 0) {\r\n\t\t\t// Return data is optional\r\n\t\t\trequire(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.3.2\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns (bytes calldata) {\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.3.2\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n\taddress private _owner;\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n\tconstructor() {\r\n\t\t_setOwner(_msgSender());\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the address of the current owner.\r\n\t */\r\n\tfunction owner() public view virtual returns (address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Leaves the contract without owner. It will not be possible to call\r\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n\t *\r\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\r\n\t * thereby removing any functionality that is only available to the owner.\r\n\t */\r\n\tfunction renounceOwnership() public virtual onlyOwner {\r\n\t\t_setOwner(address(0));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t * Can only be called by the current owner.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\t\t_setOwner(newOwner);\r\n\t}\r\n\r\n\tfunction _setOwner(address newOwner) private {\r\n\t\taddress oldOwner = _owner;\r\n\t\t_owner = newOwner;\r\n\t\temit OwnershipTransferred(oldOwner, newOwner);\r\n\t}\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/proxy/utils/Initializable.sol@v4.3.2\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n\t/**\r\n\t * @dev Indicates that the contract has been initialized.\r\n\t */\r\n\tbool private _initialized;\r\n\r\n\t/**\r\n\t * @dev Indicates that the contract is in the process of being initialized.\r\n\t */\r\n\tbool private _initializing;\r\n\r\n\t/**\r\n\t * @dev Modifier to protect an initializer function from being invoked twice.\r\n\t */\r\n\tmodifier initializer() {\r\n\t\trequire(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n\t\tbool isTopLevelCall = !_initializing;\r\n\t\tif (isTopLevelCall) {\r\n\t\t\t_initializing = true;\r\n\t\t\t_initialized = true;\r\n\t\t}\r\n\r\n\t\t_;\r\n\r\n\t\tif (isTopLevelCall) {\r\n\t\t\t_initializing = false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/security/ReentrancyGuard.sol@v4.3.2\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n\t// Booleans are more expensive than uint256 or any type that takes up a full\r\n\t// word because each write operation emits an extra SLOAD to first read the\r\n\t// slot's contents, replace the bits taken up by the boolean, and then write\r\n\t// back. This is the compiler's defense against contract upgrades and\r\n\t// pointer aliasing, and it cannot be disabled.\r\n\r\n\t// The values being non-zero value makes deployment a bit more expensive,\r\n\t// but in exchange the refund on every call to nonReentrant will be lower in\r\n\t// amount. Since refunds are capped to a percentage of the total\r\n\t// transaction's gas, it is best to keep them low in cases like this one, to\r\n\t// increase the likelihood of the full refund coming into effect.\r\n\tuint256 private constant _NOT_ENTERED = 1;\r\n\tuint256 private constant _ENTERED = 2;\r\n\r\n\tuint256 private _status;\r\n\r\n\tconstructor() {\r\n\t\t_status = _NOT_ENTERED;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Prevents a contract from calling itself, directly or indirectly.\r\n\t * Calling a `nonReentrant` function from another `nonReentrant`\r\n\t * function is not supported. It is possible to prevent this from happening\r\n\t * by making the `nonReentrant` function external, and make it call a\r\n\t * `private` function that does the actual work.\r\n\t */\r\n\tmodifier nonReentrant() {\r\n\t\t// On the first call to nonReentrant, _notEntered will be true\r\n\t\trequire(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n\t\t// Any calls to nonReentrant after this point will fail\r\n\t\t_status = _ENTERED;\r\n\r\n\t\t_;\r\n\r\n\t\t// By storing the original value once again, a refund is triggered (see\r\n\t\t// https://eips.ethereum.org/EIPS/eip-2200)\r\n\t\t_status = _NOT_ENTERED;\r\n\t}\r\n}\r\n\r\n\r\n// File contracts/ERC20RewardStakingV4.sol\r\npragma solidity ^0.8.4;\r\n\r\n\r\ncontract ERC20RewardStakingV4 is ReentrancyGuard, Ownable, Initializable {\r\n\tusing SafeERC20 for IERC20;\r\n\r\n\t// Info of each user.\r\n\tstruct UserInfo {\r\n\t\tuint256 amount;     // How many LP tokens the user has provided.\r\n\t\tuint256 rewardDebt; // Reward debt. See explanation below.\r\n\t}\r\n\r\n\t// Info of each pool.\r\n\tstruct PoolInfo {\r\n\t\tIERC20 lpToken;           // Address of LP token contract.\r\n\t\tuint256 allocPoint;       // How many allocation points assigned to this pool. Rewards to distribute per block.\r\n\t\tuint256 lastRewardBlock;  // Last block number that Rewards distribution occurs.\r\n\t\tuint256 accRewardTokenPerShare; // Accumulated Rewards per share, times 1e30. See below.\r\n\t}\r\n\r\n\t// The stake token\r\n\tIERC20 public STAKE_TOKEN;\r\n\t// The reward token\r\n\tIERC20 public REWARD_TOKEN;\r\n\r\n\t// Reward tokens created per block.\r\n\tuint256 public rewardPerBlock;\r\n\r\n\t// Keep track of number of tokens staked in case the contract earns reflect fees\r\n\tuint256 public totalStaked = 0;\r\n\t// Keep track of number of reward tokens paid to find remaining reward balance\r\n\tuint256 public totalRewardsPaid = 0;\r\n\t// Keep track of number of reward tokens paid to find remaining reward balance\r\n\tuint256 public totalRewardsAllocated = 0;\r\n\r\n\t// Info of each pool.\r\n\tPoolInfo public poolInfo;\r\n\t// Info of each user that stakes LP tokens.\r\n\tmapping (address => UserInfo) public userInfo;\r\n\t// Total allocation poitns. Must be the sum of all allocation points in all pools.\r\n\tuint256 private totalAllocPoint = 0;\r\n\t// The block number when Reward mining starts.\r\n\tuint256 public startBlock;\r\n\t// The block number when mining ends.\r\n\tuint256 public bonusEndBlock;\r\n\r\n\tevent Deposit(address indexed user, uint256 amount);\r\n\tevent DepositRewards(uint256 amount);\r\n\tevent Withdraw(address indexed user, uint256 amount);\r\n\tevent EmergencyWithdraw(address indexed user, uint256 amount);\r\n\tevent SkimStakeTokenFees(address indexed user, uint256 amount);\r\n\tevent LogUpdatePool(uint256 bonusEndBlock, uint256 rewardPerBlock);\r\n\tevent EmergencyRewardWithdraw(address indexed user, uint256 amount);\r\n\tevent EmergencySweepWithdraw(address indexed user, IERC20 indexed token, uint256 amount);\r\n\r\n\tfunction initialize(\r\n\t\tIERC20 _stakeToken,\r\n\t\tIERC20 _rewardToken,\r\n\t\tuint256 _rewardPerBlock,\r\n\t\tuint256 _startBlock,\r\n\t\tuint256 _bonusEndBlock\r\n\t) external initializer\r\n\t{\r\n\t\tSTAKE_TOKEN = _stakeToken;\r\n\t\tREWARD_TOKEN = _rewardToken;\r\n\t\trewardPerBlock = _rewardPerBlock;\r\n\t\tstartBlock = _startBlock;\r\n\t\tbonusEndBlock = _bonusEndBlock;\r\n\r\n\t\t// staking pool\r\n\t\tpoolInfo = PoolInfo({\r\n\t\t\tlpToken: _stakeToken,\r\n\t\t\tallocPoint: 1000,\r\n\t\t\tlastRewardBlock: startBlock,\r\n\t\t\taccRewardTokenPerShare: 0\r\n\t\t});\r\n\r\n\t\ttotalAllocPoint = 1000;\r\n\t}\r\n\r\n\t// Return reward multiplier over the given _from to _to block.\r\n\tfunction getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\r\n\t\tif (_to <= bonusEndBlock) {\r\n\t\t\treturn _to - _from;\r\n\t\t} else if (_from >= bonusEndBlock) {\r\n\t\t\treturn 0;\r\n\t\t} else {\r\n\t\t\treturn bonusEndBlock - _from;\r\n\t\t}\r\n\t}\r\n\r\n\t/// @param  _bonusEndBlock The block when rewards will end\r\n\tfunction setBonusEndBlock(uint256 _bonusEndBlock) external onlyOwner {\r\n\t\trequire(_bonusEndBlock > block.number, 'new bonus end block must be greater than current');\r\n\t\tbonusEndBlock = _bonusEndBlock;\r\n\t\temit LogUpdatePool(bonusEndBlock, rewardPerBlock);\r\n\t}\r\n\r\n\t// View function to see pending Reward on frontend.\r\n\tfunction pendingReward(address _user) external view returns (uint256) {\r\n\t\tUserInfo storage user = userInfo[_user];\r\n\t\tuint256 accRewardTokenPerShare = poolInfo.accRewardTokenPerShare;\r\n\t\tif (block.number > poolInfo.lastRewardBlock && totalStaked != 0) {\r\n\t\t\tuint256 multiplier = getMultiplier(poolInfo.lastRewardBlock, block.number);\r\n\t\t\tuint256 tokenReward = multiplier * rewardPerBlock * poolInfo.allocPoint / totalAllocPoint;\r\n\t\t\taccRewardTokenPerShare = accRewardTokenPerShare + (tokenReward * 1e30 / totalStaked);\r\n\t\t}\r\n\t\treturn user.amount * accRewardTokenPerShare / 1e30 - user.rewardDebt;\r\n\t}\r\n\r\n\t// Update reward variables of the given pool to be up-to-date.\r\n\tfunction updatePool() public {\r\n\t\tif (block.number <= poolInfo.lastRewardBlock) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (totalStaked == 0) {\r\n\t\t\tpoolInfo.lastRewardBlock = block.number;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tuint256 multiplier = getMultiplier(poolInfo.lastRewardBlock, block.number);\r\n\t\tuint256 tokenReward = multiplier * rewardPerBlock * poolInfo.allocPoint / totalAllocPoint;\r\n\t\ttotalRewardsAllocated += tokenReward;\r\n\t\tpoolInfo.accRewardTokenPerShare = poolInfo.accRewardTokenPerShare + (tokenReward * 1e30 / totalStaked);\r\n\t\tpoolInfo.lastRewardBlock = block.number;\r\n\t}\r\n\r\n\r\n\t/// Deposit staking token into the contract to earn rewards.\r\n\t/// @dev Since this contract needs to be supplied with rewards we are\r\n\t///  sending the balance of the contract if the pending rewards are higher\r\n\t/// @param _amount The amount of staking tokens to deposit\r\n\tfunction deposit(uint256 _amount) external nonReentrant {\r\n\t\tUserInfo storage user = userInfo[msg.sender];\r\n\t\tupdatePool();\r\n\t\tif (user.amount > 0) {\r\n\t\t\tuint256 pending = user.amount * poolInfo.accRewardTokenPerShare / 1e30 - user.rewardDebt;\r\n\t\t\tif(pending > 0) {\r\n\t\t\t\t// If rewardBalance is low then revert to avoid losing the user's rewards\r\n\t\t\t\trequire(rewardBalance() >= pending, \"insufficient reward balance\");\r\n\t\t\t\tsafeTransferRewardInternal(address(msg.sender), pending);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint256 finalDepositAmount = 0;\r\n\t\tif (_amount > 0) {\r\n\t\t\tuint256 preStakeBalance = STAKE_TOKEN.balanceOf(address(this));\r\n\t\t\tpoolInfo.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n\t\t\tfinalDepositAmount = STAKE_TOKEN.balanceOf(address(this)) - preStakeBalance;\r\n\t\t\tuser.amount = user.amount + finalDepositAmount;\r\n\t\t\ttotalStaked = totalStaked + finalDepositAmount;\r\n\t\t}\r\n\t\tuser.rewardDebt = user.amount * poolInfo.accRewardTokenPerShare / 1e30;\r\n\r\n\t\temit Deposit(msg.sender, finalDepositAmount);\r\n\t}\r\n\r\n\t/// Withdraw rewards and/or staked tokens. Pass a 0 amount to withdraw only rewards\r\n\t/// @param _amount The amount of staking tokens to withdraw\r\n\tfunction withdraw(uint256 _amount) external nonReentrant {\r\n\t\tUserInfo storage user = userInfo[msg.sender];\r\n\t\trequire(user.amount >= _amount, \"withdraw: not good\");\r\n\t\tupdatePool();\r\n\t\tuint256 pending = user.amount * poolInfo.accRewardTokenPerShare / 1e30 - user.rewardDebt;\r\n\t\tif(pending > 0) {\r\n\t\t\t// If rewardBalance is low then revert to avoid losing the user's rewards\r\n\t\t\trequire(rewardBalance() >= pending, \"insufficient reward balance\");\r\n\t\t\tsafeTransferRewardInternal(address(msg.sender), pending);\r\n\t\t}\r\n\r\n\t\tif(_amount > 0) {\r\n\t\t\tuser.amount = user.amount - _amount;\r\n\t\t\tpoolInfo.lpToken.safeTransfer(address(msg.sender), _amount);\r\n\t\t\ttotalStaked = totalStaked - _amount;\r\n\t\t}\r\n\r\n\t\tuser.rewardDebt = user.amount * poolInfo.accRewardTokenPerShare / 1e30;\r\n\r\n\t\temit Withdraw(msg.sender, _amount);\r\n\t}\r\n\r\n\t/// Obtain the reward balance of this contract\r\n\t/// @return wei balace of conract\r\n\tfunction rewardBalance() public view returns (uint256) {\r\n\t\tuint256 balance = REWARD_TOKEN.balanceOf(address(this));\r\n\t\tif (STAKE_TOKEN == REWARD_TOKEN) {\r\n\t\t\treturn balance - totalStaked;\r\n\t\t}\r\n\t\treturn balance;\r\n\t}\r\n\r\n\t/// Get the balance of rewards that have not been harvested\r\n\t/// @return wei balance of rewards left to be paid\r\n\tfunction getUnharvestedRewards() public view returns (uint256) {\r\n\t\treturn totalRewardsAllocated - totalRewardsPaid;\r\n\t}\r\n\r\n\t// Deposit Rewards into contract\r\n\tfunction depositRewards(uint256 _amount) external {\r\n\t\trequire(_amount > 0, 'Deposit value must be greater than 0.');\r\n\t\tREWARD_TOKEN.safeTransferFrom(address(msg.sender), address(this), _amount);\r\n\t\temit DepositRewards(_amount);\r\n\t}\r\n\r\n\t/// @param _to address to send reward token to\r\n\t/// @param _amount value of reward token to transfer\r\n\tfunction safeTransferRewardInternal(address _to, uint256 _amount) internal {\r\n\t\ttotalRewardsPaid += _amount;\r\n\t\tREWARD_TOKEN.safeTransfer(_to, _amount);\r\n\t}\r\n\r\n\t/// @dev Obtain the stake balance of this contract\r\n\tfunction totalStakeTokenBalance() public view returns (uint256) {\r\n\t\tif (STAKE_TOKEN == REWARD_TOKEN)\r\n\t\t\treturn totalStaked;\r\n\t\treturn STAKE_TOKEN.balanceOf(address(this));\r\n\t}\r\n\r\n\t/// @dev Obtain the stake token fees (if any) earned by reflect token\r\n\t/// @notice If STAKE_TOKEN == REWARD_TOKEN there are no fees to skim\r\n\tfunction getStakeTokenFeeBalance() public view returns (uint256) {\r\n\t\treturn totalStakeTokenBalance() - totalStaked;\r\n\t}\r\n\r\n\t/* Admin Functions */\r\n\r\n\t/// @param _rewardPerBlock The amount of reward tokens to be given per block\r\n\tfunction setRewardPerBlock(uint256 _rewardPerBlock) external onlyOwner {\r\n\t\trewardPerBlock = _rewardPerBlock;\r\n\t\temit LogUpdatePool(bonusEndBlock, rewardPerBlock);\r\n\t}\r\n\r\n\t\t/// @dev Remove excess stake tokens earned by reflect fees\r\n\tfunction skimStakeTokenFees(address _to) external onlyOwner {\r\n\t\tuint256 stakeTokenFeeBalance = getStakeTokenFeeBalance();\r\n\t\tSTAKE_TOKEN.safeTransfer(_to, stakeTokenFeeBalance);\r\n\t\temit SkimStakeTokenFees(_to, stakeTokenFeeBalance);\r\n\t}\r\n\r\n\t/* Emergency Functions */\r\n\r\n\t// Withdraw without caring about rewards. EMERGENCY ONLY.\r\n\tfunction emergencyWithdraw() external nonReentrant {\r\n\t\tUserInfo storage user = userInfo[msg.sender];\r\n\t\tpoolInfo.lpToken.safeTransfer(address(msg.sender), user.amount);\r\n\t\ttotalStaked = totalStaked - user.amount;\r\n\t\tuser.amount = 0;\r\n\t\tuser.rewardDebt = 0;\r\n\t\temit EmergencyWithdraw(msg.sender, user.amount);\r\n\t}\r\n\r\n\t// Withdraw reward. EMERGENCY ONLY.\r\n\tfunction emergencyRewardWithdraw(uint256 _amount) external onlyOwner {\r\n\t\trequire(_amount <= rewardBalance(), 'not enough rewards');\r\n\t\t// Withdraw rewards\r\n\t\tREWARD_TOKEN.safeTransfer(msg.sender, _amount);\r\n\t\temit EmergencyRewardWithdraw(msg.sender, _amount);\r\n\t}\r\n\r\n\t/// @notice A public function to sweep accidental ERC20 transfers to this contract.\r\n\t///   Tokens are sent to owner\r\n\t/// @param token The address of the ERC20 token to sweep\r\n\tfunction sweepToken(IERC20 token) external onlyOwner {\r\n\t\trequire(address(token) != address(STAKE_TOKEN), \"can not sweep stake token\");\r\n\t\trequire(address(token) != address(REWARD_TOKEN), \"can not sweep reward token\");\r\n\t\tuint256 balance = token.balanceOf(address(this));\r\n\t\ttoken.safeTransfer(msg.sender, balance);\r\n\t\temit EmergencySweepWithdraw(msg.sender, token, balance);\r\n\t}\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyRewardWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencySweepWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusEndBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"LogUpdatePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SkimStakeTokenFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"REWARD_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKE_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emergencyRewardWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeTokenFeeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnharvestedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonusEndBlock\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardTokenPerShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bonusEndBlock\",\"type\":\"uint256\"}],\"name\":\"setBonusEndBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"setRewardPerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"skimStakeTokenFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardsAllocated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardsPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakeTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC20RewardStakingV4","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://bde539c186b030ddc87e92a75f2e2ad5d4f43568cbc66086f137b3f85d0d30e1"}]}