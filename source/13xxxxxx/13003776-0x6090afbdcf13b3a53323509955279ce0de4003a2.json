{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@aragon/govern-contract-utils/contracts/acl/ACL.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../initializable/Initializable.sol\\\";\\n\\nimport \\\"./IACLOracle.sol\\\";\\n\\nlibrary ACLData {\\n    enum BulkOp { Grant, Revoke, Freeze }\\n\\n    struct BulkItem {\\n        BulkOp op;\\n        bytes4 role;\\n        address who;\\n    }\\n}\\n\\ncontract ACL is Initializable {\\n    bytes4 public constant ROOT_ROLE =\\n        this.grant.selector\\n        ^ this.revoke.selector\\n        ^ this.freeze.selector\\n        ^ this.bulk.selector\\n    ;\\n\\n    // \\\"Who\\\" constants\\n    address internal constant ANY_ADDR = address(-1);\\n\\n    // \\\"Access\\\" flags\\n    address internal constant UNSET_ROLE = address(0);\\n    address internal constant FREEZE_FLAG = address(1); // Also used as \\\"who\\\"\\n    address internal constant ALLOW_FLAG = address(2);\\n\\n    // Role -> Who -> Access flag (unset or allow) or ACLOracle (any other address denominates auth via ACLOracle)\\n    mapping (bytes4 => mapping (address => address)) public roles;\\n\\n    event Granted(bytes4 indexed role, address indexed actor, address indexed who, IACLOracle oracle);\\n    event Revoked(bytes4 indexed role, address indexed actor, address indexed who);\\n    event Frozen(bytes4 indexed role, address indexed actor);\\n\\n    modifier auth(bytes4 _role) {\\n        require(willPerform(_role, msg.sender, msg.data), \\\"acl: auth\\\");\\n        _;\\n    }\\n\\n    modifier initACL(address _initialRoot) {\\n        // ACL might have been already initialized by constructors\\n        if (initBlocks[\\\"acl\\\"] == 0) {\\n            _initializeACL(_initialRoot);\\n        } else {\\n            require(roles[ROOT_ROLE][_initialRoot] == ALLOW_FLAG, \\\"acl: initial root misaligned\\\");\\n        }\\n        _;\\n    }\\n\\n    constructor(address _initialRoot) public initACL(_initialRoot) { }\\n\\n    function grant(bytes4 _role, address _who) external auth(ROOT_ROLE) {\\n        _grant(_role, _who);\\n    }\\n\\n    function grantWithOracle(bytes4 _role, address _who, IACLOracle _oracle) external auth(ROOT_ROLE) {\\n        _grantWithOracle(_role, _who, _oracle);\\n    }\\n\\n    function revoke(bytes4 _role, address _who) external auth(ROOT_ROLE) {\\n        _revoke(_role, _who);\\n    }\\n\\n    function freeze(bytes4 _role) external auth(ROOT_ROLE) {\\n        _freeze(_role);\\n    }\\n\\n    function bulk(ACLData.BulkItem[] calldata items) external auth(ROOT_ROLE) {\\n        for (uint256 i = 0; i < items.length; i++) {\\n            ACLData.BulkItem memory item = items[i];\\n\\n            if (item.op == ACLData.BulkOp.Grant) _grant(item.role, item.who);\\n            else if (item.op == ACLData.BulkOp.Revoke) _revoke(item.role, item.who);\\n            else if (item.op == ACLData.BulkOp.Freeze) _freeze(item.role);\\n        }\\n    }\\n\\n    function willPerform(bytes4 _role, address _who, bytes memory _data) internal returns (bool) {\\n        // First check if the given who is auth'd, then if any address is auth'd\\n        return _checkRole(_role, _who, _data) || _checkRole(_role, ANY_ADDR, _data);\\n    }\\n\\n    function isFrozen(bytes4 _role) public view returns (bool) {\\n        return roles[_role][FREEZE_FLAG] == FREEZE_FLAG;\\n    }\\n\\n    function _initializeACL(address _initialRoot) internal onlyInit(\\\"acl\\\") {\\n        _grant(ROOT_ROLE, _initialRoot);\\n    }\\n\\n    function _grant(bytes4 _role, address _who) internal {\\n        _grantWithOracle(_role, _who, IACLOracle(ALLOW_FLAG));\\n    }\\n\\n    function _grantWithOracle(bytes4 _role, address _who, IACLOracle _oracle) internal {\\n        require(!isFrozen(_role), \\\"acl: frozen\\\");\\n        require(_who != FREEZE_FLAG, \\\"acl: bad freeze\\\");\\n\\n        roles[_role][_who] = address(_oracle);\\n        emit Granted(_role, msg.sender, _who, _oracle);\\n    }\\n\\n    function _revoke(bytes4 _role, address _who) internal {\\n        require(!isFrozen(_role), \\\"acl: frozen\\\");\\n\\n        roles[_role][_who] = UNSET_ROLE;\\n        emit Revoked(_role, msg.sender, _who);\\n    }\\n\\n    function _freeze(bytes4 _role) internal {\\n        require(!isFrozen(_role), \\\"acl: frozen\\\");\\n\\n        roles[_role][FREEZE_FLAG] = FREEZE_FLAG;\\n        emit Frozen(_role, msg.sender);\\n    }\\n\\n    function _checkRole(bytes4 _role, address _who, bytes memory _data) internal returns (bool) {\\n        address accessFlagOrAclOracle = roles[_role][_who];\\n        if (accessFlagOrAclOracle != UNSET_ROLE) {\\n            if (accessFlagOrAclOracle == ALLOW_FLAG) return true;\\n\\n            // Since it's not a flag, assume it's an ACLOracle and try-catch to skip failures\\n            try IACLOracle(accessFlagOrAclOracle).willPerform(_role, _who, _data) returns (bool allowed) {\\n                if (allowed) return true;\\n            } catch { }\\n        }\\n\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/acl/IACLOracle.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\n\\ninterface IACLOracle {\\n    function willPerform(bytes4 role, address who, bytes calldata data) external returns (bool allowed);\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/adaptive-erc165/AdaptiveERC165.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\n\\nimport \\\"../erc165/ERC165.sol\\\";\\n\\ncontract AdaptiveERC165 is ERC165 {\\n    // ERC165 interface ID -> whether it is supported\\n    mapping (bytes4 => bool) internal standardSupported;\\n    // Callback function signature -> magic number to return\\n    mapping (bytes4 => bytes32) internal callbackMagicNumbers;\\n\\n    bytes32 internal constant UNREGISTERED_CALLBACK = bytes32(0);\\n\\n    event RegisteredStandard(bytes4 interfaceId);\\n    event RegisteredCallback(bytes4 sig, bytes4 magicNumber);\\n    event ReceivedCallback(bytes4 indexed sig, bytes data);\\n\\n    function supportsInterface(bytes4 _interfaceId) override virtual public view returns (bool) {\\n        return standardSupported[_interfaceId] || super.supportsInterface(_interfaceId);\\n    }\\n\\n    function _handleCallback(bytes4 _sig, bytes memory _data) internal {\\n        bytes32 magicNumber = callbackMagicNumbers[_sig];\\n        require(magicNumber != UNREGISTERED_CALLBACK, \\\"adap-erc165: unknown callback\\\");\\n\\n        emit ReceivedCallback(_sig, _data);\\n\\n        // low-level return magic number\\n        assembly {\\n            mstore(0x00, magicNumber)\\n            return(0x00, 0x20)\\n        }\\n    }\\n\\n    function _registerStandardAndCallback(bytes4 _interfaceId, bytes4 _callbackSig, bytes4 _magicNumber) internal {\\n        _registerStandard(_interfaceId);\\n        _registerCallback(_callbackSig, _magicNumber);\\n    }\\n\\n    function _registerStandard(bytes4 _interfaceId) internal {\\n        standardSupported[_interfaceId] = true;\\n        emit RegisteredStandard(_interfaceId);\\n    }\\n\\n    function _registerCallback(bytes4 _callbackSig, bytes4 _magicNumber) internal {\\n        callbackMagicNumbers[_callbackSig] = _magicNumber;\\n        emit RegisteredCallback(_callbackSig, _magicNumber);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/address-utils/AddressUtils.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\n\\nlibrary AddressUtils {\\n    \\n    function toPayable(address addr) internal pure returns (address payable) {\\n        return address(bytes20(addr));\\n    }\\n\\n    /**\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     */\\n    function isContract(address addr) internal view returns (bool result) {\\n        assembly {\\n            result := iszero(iszero(extcodesize(addr)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/bitmaps/BitmapLib.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\n\\nlibrary BitmapLib {\\n    bytes32 constant internal empty = bytes32(0);\\n\\n    function flip(bytes32 map, uint8 index) internal pure returns (bytes32) {\\n        return bytes32(uint256(map) ^ uint256(1) << index);\\n    }\\n\\n    function get(bytes32 map, uint8 index) internal pure returns (bool) {\\n        return (uint256(map) >> index & 1) == 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/erc165/ERC165.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\n\\nabstract contract ERC165 {\\n    // Includes supportsInterface method:\\n    bytes4 internal constant ERC165_INTERFACE_ID = bytes4(0x01ffc9a7);\\n\\n    /**\\n    * @dev Query if a contract implements a certain interface\\n    * @param _interfaceId The interface identifier being queried, as specified in ERC-165\\n    * @return True if the contract implements the requested interface and if its not 0xffffffff, false otherwise\\n    */\\n    function supportsInterface(bytes4 _interfaceId) virtual public view returns (bool) {\\n        return _interfaceId == ERC165_INTERFACE_ID;\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/erc20/ERC20.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface ERC20 {\\n    // Optional fields \\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address _who) external view returns (uint256);\\n\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n\\n    function transfer(address _to, uint256 _value) external returns (bool);\\n\\n    function approve(address _spender, uint256 _value) external returns (bool);\\n\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/erc20/SafeERC20.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\n// From https://github.com/aragon/aragonOS/blob/next/contracts/common/SafeERC20.sol\\n\\n// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\\n// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\\n\\npragma solidity ^0.6.8;\\n\\nimport \\\"../address-utils/AddressUtils.sol\\\";\\n\\nimport \\\"./ERC20.sol\\\";\\n\\nlibrary SafeERC20 {\\n    using AddressUtils for address;\\n\\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\\n        private\\n        returns (bool ret)\\n    {\\n        if (!_addr.isContract()) {\\n            return false;\\n        }\\n\\n        assembly {\\n            let ptr := mload(0x40)    // free memory pointer\\n\\n            let success := call(\\n                gas(),                // forward all\\n                _addr,                // address\\n                0,                    // no value\\n                add(_calldata, 0x20), // calldata start\\n                mload(_calldata),     // calldata length\\n                ptr,                  // write output over free memory\\n                0x20                  // uint256 return\\n            )\\n\\n            if gt(success, 0) {\\n                // Check number of bytes returned from last function call\\n                switch returndatasize()\\n\\n                // No bytes returned: assume success\\n                case 0 {\\n                    ret := 1\\n                }\\n\\n                // 32 bytes returned: check if non-zero\\n                case 0x20 {\\n                    // Only return success if returned data was true\\n                    // Already have output in ptr\\n                    ret := iszero(iszero(mload(ptr)))\\n                }\\n\\n                // Not sure what was returned: don't mark as success\\n                default { }\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\\n        bytes memory transferCallData = abi.encodeWithSelector(\\n            _token.transfer.selector,\\n            _to,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(address(_token), transferCallData);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\\n        bytes memory transferFromCallData = abi.encodeWithSelector(\\n            _token.transferFrom.selector,\\n            _from,\\n            _to,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(address(_token), transferFromCallData);\\n    }\\n\\n    /**\\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\\n    *      Note that this makes an external call to the token.\\n    */\\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\\n        bytes memory approveCallData = abi.encodeWithSelector(\\n            _token.approve.selector,\\n            _spender,\\n            _amount\\n        );\\n        return invokeAndCheckSuccess(address(_token), approveCallData);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/initializable/Initializable.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity 0.6.8;\\n\\ncontract Initializable {\\n    mapping (string => uint256) public initBlocks;\\n\\n    event Initialized(string indexed key);\\n\\n    modifier onlyInit(string memory key) {\\n        require(initBlocks[key] == 0, \\\"initializable: already initialized\\\");\\n        initBlocks[key] = block.number;\\n        _;\\n        emit Initialized(key);\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\n// Inspired by: https://github.com/optionality/clone-factory\\n\\npragma solidity ^0.6.8;\\n\\nlibrary ERC1167ProxyFactory {\\n    function clone(address _implementation) internal returns (address cloneAddr) {\\n        bytes memory createData = generateCreateData(_implementation);\\n\\n        assembly {\\n            cloneAddr := create(0, add(createData, 0x20), 55)\\n        }\\n\\n        require(cloneAddr != address(0), \\\"proxy-factory: bad create\\\");\\n    }\\n\\n    function clone(address _implementation, bytes memory _initData) internal returns (address cloneAddr) {\\n        cloneAddr = clone(_implementation);\\n        (bool ok, bytes memory ret) = cloneAddr.call(_initData);\\n\\n        require(ok, _getRevertMsg(ret));\\n    }\\n\\n    function clone2(address _implementation, bytes32 _salt) internal returns (address cloneAddr) {\\n        bytes memory createData = generateCreateData(_implementation);\\n\\n        assembly {\\n            cloneAddr := create2(0, add(createData, 0x20), 55, _salt)\\n        }\\n\\n        require(cloneAddr != address(0), \\\"proxy-factory: bad create2\\\");\\n    }\\n\\n    function clone2(address _implementation, bytes32 _salt, bytes memory _initData) internal returns (address cloneAddr) {\\n        cloneAddr = clone2(_implementation, _salt);\\n        (bool ok, bytes memory ret) = cloneAddr.call(_initData);\\n\\n        require(ok, _getRevertMsg(ret));\\n    }\\n\\n    function generateCreateData(address _implementation) internal pure returns (bytes memory) {\\n        return abi.encodePacked(\\n            //---- constructor -----\\n            bytes10(0x3d602d80600a3d3981f3),\\n            //---- proxy code -----\\n            bytes10(0x363d3d373d3d3d363d73),\\n            _implementation,\\n            bytes15(0x5af43d82803e903d91602b57fd5bf3)\\n        );\\n    }\\n\\n    // From: https://ethereum.stackexchange.com/a/83577\\n    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\n        if (_returnData.length < 68) return '';\\n\\n        assembly {\\n            _returnData := add(_returnData, 0x04) // Slice the sighash.\\n        }\\n        return abi.decode(_returnData, (string)); // All that remains is the revert string\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-core/contracts/Govern.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity 0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"erc3k/contracts/IERC3000Executor.sol\\\";\\nimport \\\"erc3k/contracts/IERC3000.sol\\\";\\n\\nimport \\\"@aragon/govern-contract-utils/contracts/acl/ACL.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/adaptive-erc165/AdaptiveERC165.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/bitmaps/BitmapLib.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/address-utils/AddressUtils.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/erc20/ERC20.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/erc20/SafeERC20.sol\\\";\\n\\nimport \\\"./erc1271/ERC1271.sol\\\";\\n\\ncontract Govern is IERC3000Executor, AdaptiveERC165, ERC1271, ACL {\\n    using BitmapLib for bytes32;\\n    using AddressUtils for address;\\n    using SafeERC20 for ERC20;\\n\\n    string private constant ERROR_DEPOSIT_AMOUNT_ZERO = \\\"GOVERN_DEPOSIT_AMOUNT_ZERO\\\";\\n    string private constant ERROR_ETH_DEPOSIT_AMOUNT_MISMATCH = \\\"GOVERN_ETH_DEPOSIT_AMOUNT_MISMATCH\\\";\\n    string private constant ERROR_TOKEN_NOT_CONTRACT = \\\"GOVERN_TOKEN_NOT_CONTRACT\\\";\\n    string private constant ERROR_TOKEN_DEPOSIT_FAILED = \\\"GOVERN_TOKEN_DEPOSIT_FAILED\\\";\\n    string private constant ERROR_TOO_MANY_ACTIONS = \\\"GOVERN_TOO_MANY_ACTIONS\\\";\\n    string private constant ERROR_ACTION_CALL_FAILED = \\\"GOVERN_ACTION_CALL_FAILED\\\";\\n    string private constant ERROR_TOKEN_WITHDRAW_FAILED = \\\"GOVERN_TOKEN_WITHDRAW_FAILED\\\";\\n    string private constant ERROR_ETH_WITHDRAW_FAILED = \\\"GOVERN_ETH_WITHDRAW_FAILED\\\";\\n\\n    bytes4 internal constant EXEC_ROLE = this.exec.selector;\\n    bytes4 internal constant WITHDRAW_ROLE = this.withdraw.selector;\\n\\n    bytes4 internal constant REGISTER_STANDARD_ROLE = this.registerStandardAndCallback.selector;\\n    bytes4 internal constant SET_SIGNATURE_VALIDATOR_ROLE = this.setSignatureValidator.selector;\\n    uint256 internal constant MAX_ACTIONS = 256;\\n\\n    ERC1271 signatureValidator;\\n\\n    // ETHDeposited and Deposited are both needed. ETHDeposited makes sure that whoever sends funds\\n    // with `send/transfer`, receive function can still be executed without reverting due to gas cost\\n    // increases in EIP-2929. To still use `send/transfer`, access list is needed that has the address\\n    // of the contract(base contract) that is behind the proxy.\\n    event ETHDeposited(address sender, uint256 amount);\\n\\n    event Deposited(address indexed sender, address indexed token, uint256 amount, string _reference);\\n    event Withdrawn(address indexed token, address indexed to, address from, uint256 amount, string _reference);\\n\\n    constructor(address _initialExecutor) ACL(address(this)) public {\\n        initialize(_initialExecutor);\\n    }\\n\\n    function initialize(address _initialExecutor) public initACL(address(this)) onlyInit(\\\"govern\\\") {\\n        _grant(EXEC_ROLE, address(_initialExecutor));\\n        _grant(WITHDRAW_ROLE, address(this));\\n\\n        // freeze the withdraw so that only GovernExecutor can call\\n        _freeze(WITHDRAW_ROLE);\\n\\n        _grant(REGISTER_STANDARD_ROLE, address(this));\\n        _grant(SET_SIGNATURE_VALIDATOR_ROLE, address(this));\\n\\n        _registerStandard(ERC3000_EXEC_INTERFACE_ID);\\n        _registerStandard(type(ERC1271).interfaceId);\\n    }\\n\\n    receive () external payable {\\n        emit ETHDeposited(msg.sender, msg.value);\\n    }\\n\\n    fallback () external {\\n        _handleCallback(msg.sig, msg.data); // WARN: does a low-level return, any code below would be unreacheable\\n    }\\n\\n    function deposit(address _token, uint256 _amount, string calldata _reference) external payable {\\n        require(_amount > 0, ERROR_DEPOSIT_AMOUNT_ZERO);\\n\\n        if (_token == address(0)) {\\n            require(msg.value == _amount, ERROR_ETH_DEPOSIT_AMOUNT_MISMATCH);\\n        } else {\\n            require(_token.isContract(), ERROR_TOKEN_NOT_CONTRACT);\\n            require(ERC20(_token).safeTransferFrom(msg.sender, address(this), _amount), ERROR_TOKEN_DEPOSIT_FAILED);\\n        }\\n        emit Deposited(msg.sender, _token, _amount, _reference);\\n    }\\n\\n    function withdraw(address _token, address _from, address _to, uint256 _amount, string memory _reference) public auth(WITHDRAW_ROLE) {\\n        if (_token == address(0)) {\\n            (bool ok, ) = _to.call{value: _amount}(\\\"\\\");\\n            require(ok, ERROR_ETH_WITHDRAW_FAILED);\\n        } else {\\n            require(ERC20(_token).safeTransfer(_to, _amount), ERROR_TOKEN_WITHDRAW_FAILED);\\n        }\\n        emit Withdrawn(_token, _to, _from, _amount, _reference);\\n    }\\n\\n    function exec(ERC3000Data.Action[] memory actions, bytes32 allowFailuresMap, bytes32 memo) override public auth(EXEC_ROLE) returns (bytes32, bytes[] memory) {\\n        require(actions.length <= MAX_ACTIONS, ERROR_TOO_MANY_ACTIONS); // need to limit since we use 256-bit bitmaps\\n\\n        bytes[] memory execResults = new bytes[](actions.length);\\n        bytes32 failureMap = BitmapLib.empty; // start with an empty bitmap\\n\\n        for (uint256 i = 0; i < actions.length; i++) {\\n            // TODO: optimize with assembly\\n            (bool ok, bytes memory ret) = actions[i].to.call{value: actions[i].value}(actions[i].data);\\n            require(ok || allowFailuresMap.get(uint8(i)), ERROR_ACTION_CALL_FAILED);\\n            // if a call fails, flip that bit to signal failure\\n            failureMap = ok ? failureMap : failureMap.flip(uint8(i));\\n            execResults[i] = ret;\\n        }\\n\\n        emit Executed(msg.sender, actions, memo, failureMap, execResults);\\n\\n        return (failureMap, execResults);\\n    }\\n\\n    function registerStandardAndCallback(bytes4 _interfaceId, bytes4 _callbackSig, bytes4 _magicNumber) external auth(REGISTER_STANDARD_ROLE) {\\n        _registerStandardAndCallback(_interfaceId, _callbackSig, _magicNumber);\\n    }\\n\\n    function setSignatureValidator(ERC1271 _signatureValidator) external auth(SET_SIGNATURE_VALIDATOR_ROLE) {\\n        signatureValidator = _signatureValidator;\\n    }\\n\\n    function isValidSignature(bytes32 _hash, bytes memory _signature) override public view returns (bytes4) {\\n        if (address(signatureValidator) == address(0)) return bytes4(0); // invalid magic number\\n        return signatureValidator.isValidSignature(_hash, _signature); // forward call to set validation contract\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/govern-core/contracts/erc1271/ERC1271.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\n\\n/**\\n* @title ERC1271 interface\\n* @dev see https://eips.ethereum.org/EIPS/eip-1271\\n*/\\nabstract contract ERC1271 {\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\n    bytes4 constant internal MAGICVALUE = 0x1626ba7e;\\n\\n    /**\\n    * @dev Should return whether the signature provided is valid for the provided data\\n    * @param _hash Keccak256 hash of arbitrary length data signed on the behalf of address(this)\\n    * @param _signature Signature byte array associated with _data\\n    *\\n    * MUST return the bytes4 magic value 0x1626ba7e when function passes.\\n    * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\\n    * MUST allow external calls\\n    */\\n    function isValidSignature(bytes32 _hash, bytes memory _signature) virtual public view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"contracts/core-factories/GovernFactory.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    GPL-3.0\\n */\\n\\npragma solidity 0.6.8;\\n\\nimport \\\"erc3k/contracts/IERC3000.sol\\\";\\nimport \\\"@aragon/govern-core/contracts/Govern.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/minimal-proxies/ERC1167ProxyFactory.sol\\\";\\nimport \\\"@aragon/govern-contract-utils/contracts/address-utils/AddressUtils.sol\\\";\\n\\ncontract GovernFactory {\\n    using ERC1167ProxyFactory for address;\\n    using AddressUtils for address;\\n    \\n    address public base;\\n\\n    constructor() public {\\n        setupBase();\\n    }\\n\\n    function newGovern(IERC3000 _initialExecutor, bytes32 _salt) public returns (Govern govern) {\\n        if (_salt != bytes32(0)) {\\n            return Govern(base.clone2(_salt, abi.encodeWithSelector(govern.initialize.selector, _initialExecutor)).toPayable());\\n        } else {\\n            return new Govern(address(_initialExecutor));\\n        }\\n    }\\n\\n    function setupBase() private {\\n        base = address(new Govern(address(2)));\\n    }\\n}\\n\"\r\n    },\r\n    \"erc3k/contracts/ERC3000Data.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IERC3000Executor.sol\\\";\\n\\nlibrary ERC3000Data {\\n    // TODO: come up with a non-shitty name\\n    struct Container {\\n        Payload payload;\\n        Config config;\\n    }\\n\\n    // WARN: Always remember to change the 'hash' function if modifying the struct\\n    struct Payload {\\n        uint256 nonce;\\n        uint256 executionTime;\\n        address submitter;\\n        IERC3000Executor executor;\\n        Action[] actions;\\n        bytes32 allowFailuresMap;\\n        bytes proof;\\n    }\\n\\n    struct Action {\\n        address to;\\n        uint256 value;\\n        bytes data;\\n    }\\n\\n    struct Config {\\n        uint256 executionDelay; // how many seconds to wait before being able to call `execute`.\\n        Collateral scheduleDeposit; // fees for scheduling\\n        Collateral challengeDeposit; // fees for challenging\\n        address resolver;  // resolver that will rule the disputes\\n        bytes rules; // rules of how DAO should be managed\\n        uint256 maxCalldataSize; // max calldatasize for the schedule\\n    }\\n\\n    struct Collateral {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    function containerHash(bytes32 payloadHash, bytes32 configHash) internal view returns (bytes32) {\\n        uint chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        return keccak256(abi.encodePacked(\\\"erc3k-v1\\\", address(this), chainId, payloadHash, configHash));\\n    }\\n\\n    function hash(Container memory container) internal view returns (bytes32) {\\n        return containerHash(hash(container.payload), hash(container.config));\\n    }\\n\\n    function hash(Payload memory payload) internal pure returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                payload.nonce,\\n                payload.executionTime,\\n                payload.submitter,\\n                payload.executor,\\n                keccak256(abi.encode(payload.actions)),\\n                payload.allowFailuresMap,\\n                keccak256(payload.proof)\\n            )\\n        );\\n    }\\n\\n    function hash(Config memory config) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(config));\\n    }\\n}\\n\"\r\n    },\r\n    \"erc3k/contracts/IERC3000.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC3000Data.sol\\\";\\n\\nabstract contract IERC3000 {\\n    /**\\n     * @notice Schedules an action for execution, allowing for challenges and vetos on a defined time window\\n     * @param container A Container struct holding both the payload being scheduled for execution and\\n     * the current configuration of the system\\n     * @return containerHash\\n     */\\n    function schedule(ERC3000Data.Container memory container) virtual public returns (bytes32 containerHash);\\n    event Scheduled(bytes32 indexed containerHash, ERC3000Data.Payload payload);\\n\\n    /**\\n     * @notice Executes an action after its execution delay has passed and its state hasn't been altered by a challenge or veto\\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\\n     * the current configuration of the system\\n     * MUST be an ERC3000Executor call: payload.executor.exec(payload.actions)\\n     * @return failureMap\\n     * @return execResults\\n     */\\n    function execute(ERC3000Data.Container memory container) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\\n    event Executed(bytes32 indexed containerHash, address indexed actor);\\n\\n    /**\\n     * @notice Challenge a container in case its scheduling is illegal as per Config.rules. Pulls collateral and dispute fees from sender into contract\\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\\n     * the current configuration of the system\\n     * @param reason Hint for case reviewers as to why the scheduled container is illegal\\n     * @return resolverId\\n     */\\n    function challenge(ERC3000Data.Container memory container, bytes memory reason) virtual public returns (uint256 resolverId);\\n    event Challenged(bytes32 indexed containerHash, address indexed actor, bytes reason, uint256 resolverId, ERC3000Data.Collateral collateral);\\n\\n    /**\\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\\n     * the current configuration of the system\\n     * @param resolverId disputeId in the arbitrator in which the dispute over the container was created\\n     * @return failureMap\\n     * @return execResults\\n     */\\n    function resolve(ERC3000Data.Container memory container, uint256 resolverId) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\\n    event Resolved(bytes32 indexed containerHash, address indexed actor, bool approved);\\n\\n    /**\\n     * @notice Apply arbitrator's ruling over a challenge once it has come to a final ruling\\n     * @param container A ERC3000Data.Container struct holding both the payload being scheduled for execution and\\n     * the current configuration of the system\\n     * @param reason Justification for the veto\\n     */\\n    function veto(ERC3000Data.Container memory container, bytes memory reason) virtual public;\\n    event Vetoed(bytes32 indexed containerHash, address indexed actor, bytes reason);\\n\\n    /**\\n     * @notice Apply a new configuration for all *new* containers to be scheduled\\n     * @param config A ERC3000Data.Config struct holding all the new params that will control the system\\n     * @return configHash\\n     */\\n    function configure(ERC3000Data.Config memory config) virtual public returns (bytes32 configHash);\\n    event Configured(bytes32 indexed configHash, address indexed actor, ERC3000Data.Config config);\\n}\\n\"\r\n    },\r\n    \"erc3k/contracts/IERC3000Executor.sol\": {\r\n      \"content\": \"/*\\n * SPDX-License-Identifier:    MIT\\n */\\n\\npragma solidity ^0.6.8;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ERC3000Data.sol\\\";\\n\\nabstract contract IERC3000Executor {\\n    bytes4 internal constant ERC3000_EXEC_INTERFACE_ID = this.exec.selector;\\n\\n    /**\\n     * @notice Executes all given actions\\n     * @param actions A array of ERC3000Data.Action for later executing those\\n     * @param allowFailuresMap A map with the allowed failures\\n     * @param memo The hash of the ERC3000Data.Container\\n     * @return failureMap\\n     * @return execResults\\n     */\\n    function exec(ERC3000Data.Action[] memory actions, bytes32 allowFailuresMap, bytes32 memo) virtual public returns (bytes32 failureMap, bytes[] memory execResults);\\n    event Executed(address indexed actor, ERC3000Data.Action[] actions, bytes32 memo, bytes32 failureMap, bytes[] execResults);\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"base\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC3000\",\"name\":\"_initialExecutor\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_salt\",\"type\":\"bytes32\"}],\"name\":\"newGovern\",\"outputs\":[{\"internalType\":\"contract Govern\",\"name\":\"govern\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GovernFactory","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}