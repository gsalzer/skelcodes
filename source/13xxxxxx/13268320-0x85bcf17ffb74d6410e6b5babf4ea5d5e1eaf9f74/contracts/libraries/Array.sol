// SPDX-License-Identifier: MIT
pragma solidity 0.8.7;

library Array {
    function bubbleSort(address[] memory arr) internal pure {
        uint256 l = arr.length;
        for (uint256 i = 0; i < l; i++) {
            for (uint256 j = i + 1; j < l; j++) {
                if (arr[i] > arr[j]) {
                    address temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
            }
        }
    }

    function isSortedAndUnique(address[] memory tokens) internal pure returns (bool) {
        if (tokens.length < 2) {
            return true;
        }
        for (uint256 i = 0; i < tokens.length - 1; i++) {
            if (tokens[i] >= tokens[i + 1]) {
                return false;
            }
        }
        return true;
    }

    /// @dev
    /// Requires both sets of tokens to be sorted. When tokens are not sorted, it's undefined behavior.
    /// If there is a token in tokensToProject that is not part of tokens and corresponding tokenAmountsToProject > 0, reverts.
    /// Zero token amount is eqiuvalent to missing token
    function projectTokenAmounts(
        address[] memory tokens,
        address[] memory tokensToProject,
        uint256[] memory tokenAmountsToProject
    ) internal pure returns (uint256[] memory) {
        uint256[] memory res = new uint256[](tokens.length);
        uint256 t = 0;
        uint256 tp = 0;
        while ((t < tokens.length) && (tp < tokensToProject.length)) {
            if (tokens[t] < tokensToProject[tp]) {
                res[t] = 0;
                t++;
            } else if (tokens[t] > tokensToProject[tp]) {
                if (tokenAmountsToProject[tp] == 0) {
                    tp++;
                } else {
                    revert("TPS");
                }
            } else {
                res[t] = tokenAmountsToProject[tp];
                t++;
                tp++;
            }
        }
        while (t < tokens.length) {
            res[t] = 0;
            t++;
        }
        return res;
    }

    /// @notice Splits each amount from `amounts` into k amounts according to `weights`.
    /// @dev Requires tokens and tokenAmounts to be vector of size n and delegatedTokenAmounts to be k x n matrix
    /// so that delegatedTokenAmounts[i] is a vector of size n
    /// norm is a vector 1 x k
    /// the error is up to k tokens due to rounding
    /// @param amounts Amounts to split, vector n x 1
    /// @param weights Weights of the split, matrix n x k, weights[i] is vector n x 1.
    /// Weights do not need to sum to 1 in each column, but they will be normalized on split.
    function splitAmounts(uint256[] memory amounts, uint256[][] memory weights)
        internal
        pure
        returns (uint256[][] memory)
    {
        uint256 k = weights.length;
        require(k > 0, "KGT0");
        uint256 n = amounts.length;
        require(n > 0, "NGT0");
        uint256[] memory weightsNorm = new uint256[](n);
        for (uint256 i = 0; i < k; i++) {
            require(weights[i].length == n, "NV");
        }
        for (uint256 j = 0; j < n; j++) {
            weightsNorm[j] = 0;
            for (uint256 i = 0; i < k; i++) {
                weightsNorm[j] += weights[i][j];
            }
        }

        uint256[][] memory res = new uint256[][](k);
        for (uint256 i = 0; i < k; i++) {
            res[i] = new uint256[](n);
            for (uint256 j = 0; j < n; j++) {
                res[i][j] = (weights[i][j] * amounts[j]) / weightsNorm[j];
            }
        }
        return res;
    }

    function _isSubsetOf(
        address[] memory tokens,
        address[] memory tokensToCheck,
        address[] memory amountsToCheck
    ) internal {}
}

