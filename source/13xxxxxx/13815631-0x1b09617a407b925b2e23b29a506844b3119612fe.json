{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/nftTypeRegistry/NftTypeRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"../utils/Ownable.sol\\\";\\nimport \\\"../utils/ContractKeys.sol\\\";\\n\\n/**\\n * @title  NftTypeRegistry\\n * @author NFTfi\\n * @dev Registry for NFT Types supported by NFTfi.\\n * Each NFT type is associated with the address of an NFT wrapper contract.\\n */\\ncontract NftTypeRegistry is Ownable {\\n    /* ******* */\\n    /* STORAGE */\\n    /* ******* */\\n\\n    mapping(bytes32 => address) private nftTypes;\\n\\n    /* ****** */\\n    /* EVENTS */\\n    /* ****** */\\n\\n    /**\\n     * @notice This event is fired whenever the admins register a ntf type.\\n     *\\n     * @param nftType - Nft type represented by keccak256('nft type').\\n     * @param nftWrapper - Address of the wrapper contract.\\n     */\\n    event TypeUpdated(bytes32 indexed nftType, address indexed nftWrapper);\\n\\n    /* *********** */\\n    /* CONSTRUCTOR */\\n    /* *********** */\\n\\n    /**\\n     * @notice Sets the admin of the contract.\\n     * Initializes the wrappers contract addresses for the given batch of NFT Types.\\n     *\\n     * @param _admin - Initial admin of this contract.\\n     * @param _nftTypes - The nft types, e.g. \\\"ERC721\\\", or \\\"ERC1155\\\".\\n     * @param _nftWrappers - The addresses of the wrapper contract that implements INftWrapper behaviour for dealing\\n     */\\n    constructor(\\n        address _admin,\\n        string[] memory _nftTypes,\\n        address[] memory _nftWrappers\\n    ) Ownable(_admin) {\\n        _setNftTypes(_nftTypes, _nftWrappers);\\n    }\\n\\n    /* ********* */\\n    /* FUNCTIONS */\\n    /* ********* */\\n\\n    /**\\n     * @notice Set or update the wrapper contract address for the given NFT Type.\\n     * Set address(0) for a nft type for un-register such type.\\n     *\\n     * @param _nftType - The nft type, e.g. \\\"ERC721\\\", or \\\"ERC1155\\\".\\n     * @param _nftWrapper - The address of the wrapper contract that implements INftWrapper behaviour for dealing with\\n     * NFTs.\\n     */\\n    function setNftType(string memory _nftType, address _nftWrapper) external onlyOwner {\\n        _setNftType(_nftType, _nftWrapper);\\n    }\\n\\n    /**\\n     * @notice Batch set or update the wrappers contract address for the given batch of NFT Types.\\n     * Set address(0) for a nft type for un-register such type.\\n     *\\n     * @param _nftTypes - The nft types, e.g. \\\"ERC721\\\", or \\\"ERC1155\\\".\\n     * @param _nftWrappers - The addresses of the wrapper contract that implements INftWrapper behaviour for dealing\\n     * with NFTs.\\n     */\\n    function setNftTypes(string[] memory _nftTypes, address[] memory _nftWrappers) external onlyOwner {\\n        _setNftTypes(_nftTypes, _nftWrappers);\\n    }\\n\\n    /**\\n     * @notice This function can be called by anyone to get the contract address that implements the given nft type.\\n     *\\n     * @param  _nftType - The nft type, e.g. bytes32(\\\"ERC721\\\"), or bytes32(\\\"ERC1155\\\").\\n     */\\n    function getNftTypeWrapper(bytes32 _nftType) external view returns (address) {\\n        return nftTypes[_nftType];\\n    }\\n\\n    /**\\n     * @notice Set or update the wrapper contract address for the given NFT Type.\\n     * Set address(0) for a nft type for un-register such type.\\n     *\\n     * @param _nftType - The nft type, e.g. \\\"ERC721\\\", or \\\"ERC1155\\\".\\n     * @param _nftWrapper - The address of the wrapper contract that implements INftWrapper behaviour for dealing with\\n     * NFTs.\\n     */\\n    function _setNftType(string memory _nftType, address _nftWrapper) internal {\\n        require(bytes(_nftType).length != 0, \\\"nftType is empty\\\");\\n        bytes32 nftTypeKey = ContractKeys.getIdFromStringKey(_nftType);\\n\\n        nftTypes[nftTypeKey] = _nftWrapper;\\n\\n        emit TypeUpdated(nftTypeKey, _nftWrapper);\\n    }\\n\\n    /**\\n     * @notice Batch set or update the wrappers contract address for the given batch of NFT Types.\\n     * Set address(0) for a nft type for un-register such type.\\n     *\\n     * @param _nftTypes - The nft types, e.g. keccak256(\\\"ERC721\\\"), or keccak256(\\\"ERC1155\\\").\\n     * @param _nftWrappers - The addresses of the wrapper contract that implements INftWrapper behaviour for dealing\\n     * with NFTs.\\n     */\\n    function _setNftTypes(string[] memory _nftTypes, address[] memory _nftWrappers) internal {\\n        require(_nftTypes.length == _nftWrappers.length, \\\"setNftTypes function information arity mismatch\\\");\\n\\n        for (uint256 i = 0; i < _nftWrappers.length; i++) {\\n            _setNftType(_nftTypes[i], _nftWrappers[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n *\\n * Modified version from openzeppelin/contracts/access/Ownable.sol that allows to\\n * initialize the owner using a parameter in the constructor\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor(address _initialOwner) {\\n        _setOwner(_initialOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address _newOwner) public virtual onlyOwner {\\n        require(_newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(_newOwner);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Sets the owner.\\n     */\\n    function _setOwner(address _newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = _newOwner;\\n        emit OwnershipTransferred(oldOwner, _newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ContractKeys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title ContractKeys\\n * @author NFTfi\\n * @dev Common library for contract keys\\n */\\nlibrary ContractKeys {\\n    bytes32 public constant PERMITTED_ERC20S = bytes32(\\\"PERMITTED_ERC20S\\\");\\n    bytes32 public constant PERMITTED_NFTS = bytes32(\\\"PERMITTED_NFTS\\\");\\n    bytes32 public constant PERMITTED_PARTNERS = bytes32(\\\"PERMITTED_PARTNERS\\\");\\n    bytes32 public constant NFT_TYPE_REGISTRY = bytes32(\\\"NFT_TYPE_REGISTRY\\\");\\n    bytes32 public constant LOAN_REGISTRY = bytes32(\\\"LOAN_REGISTRY\\\");\\n    bytes32 public constant PERMITTED_SNFT_RECEIVER = bytes32(\\\"PERMITTED_SNFT_RECEIVER\\\");\\n    bytes32 public constant PERMITTED_BUNDLE_ERC20S = bytes32(\\\"PERMITTED_BUNDLE_ERC20S\\\");\\n    bytes32 public constant PERMITTED_AIRDROPS = bytes32(\\\"PERMITTED_AIRDROPS\\\");\\n    bytes32 public constant AIRDROP_RECEIVER = bytes32(\\\"AIRDROP_RECEIVER\\\");\\n    bytes32 public constant AIRDROP_FACTORY = bytes32(\\\"AIRDROP_FACTORY\\\");\\n    bytes32 public constant AIRDROP_FLASH_LOAN = bytes32(\\\"AIRDROP_FLASH_LOAN\\\");\\n    bytes32 public constant NFTFI_BUNDLER = bytes32(\\\"NFTFI_BUNDLER\\\");\\n\\n    string public constant AIRDROP_WRAPPER_STRING = \\\"AirdropWrapper\\\";\\n\\n    /**\\n     * @notice Returns the bytes32 representation of a string\\n     * @param _key the string key\\n     * @return id bytes32 representation\\n     */\\n    function getIdFromStringKey(string memory _key) external pure returns (bytes32 id) {\\n        require(bytes(_key).length <= 32, \\\"invalid key\\\");\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            id := mload(add(_key, 32))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/utils/ContractKeys.sol\": {\r\n        \"ContractKeys\": \"0x9cd0bbd444a7496b81d329a4af66024071271828\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"_nftTypes\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_nftWrappers\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nftType\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftWrapper\",\"type\":\"address\"}],\"name\":\"TypeUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_nftType\",\"type\":\"bytes32\"}],\"name\":\"getNftTypeWrapper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_nftType\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_nftWrapper\",\"type\":\"address\"}],\"name\":\"setNftType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_nftTypes\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_nftWrappers\",\"type\":\"address[]\"}],\"name\":\"setNftTypes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NftTypeRegistry","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"0000000000000000000000003d5437e05cbb27537e1bd80d5f409c6f1c894745000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000064552433732310000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d43727970746f4b6974746965730000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000074552433131353500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e41697264726f7057726170706572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000065a7c369c94daefc2d7d9daf5f4ca5572cbaf6cb0000000000000000000000000623962d10c27f4149b909c34b288b8d3d72dfb700000000000000000000000068c9bb116c66290ecb523b276730ecb098d07f6900000000000000000000000065a7c369c94daefc2d7d9daf5f4ca5572cbaf6cb","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}