{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\n// File: @openzeppelin/contracts/utils/Strings.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/introspection/ERC165.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n    /**\r\n     * @dev Returns the total amount of tokens stored by the contract.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * Use along with {totalSupply} to enumerate all tokens.\r\n     */\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/ERC721.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\r\n * {ERC721Enumerable}.\r\n */\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 => address) private _owners;\r\n\r\n    // Mapping owner address to token count\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = _owners[tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, can be overriden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n     */\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, _data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n        // Clear approvals\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[owner] -= 1;\r\n        delete _owners[tokenId];\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\r\n * enumerability of all the token ids in the contract as well as all token ids owned by each\r\n * account.\r\n */\r\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] private _allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\r\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\r\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n        return _ownedTokens[owner][index];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Enumerable-tokenByIndex}.\r\n     */\r\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\r\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n        if (from == address(0)) {\r\n            _addTokenToAllTokensEnumeration(tokenId);\r\n        } else if (from != to) {\r\n            _removeTokenFromOwnerEnumeration(from, tokenId);\r\n        }\r\n        if (to == address(0)) {\r\n            _removeTokenFromAllTokensEnumeration(tokenId);\r\n        } else if (to != from) {\r\n            _addTokenToOwnerEnumeration(to, tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n     * @param to address representing the new owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n     */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        uint256 length = ERC721.balanceOf(to);\r\n        _ownedTokens[to][length] = tokenId;\r\n        _ownedTokensIndex[tokenId] = length;\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to add a token to this extension's token tracking data structures.\r\n     * @param tokenId uint256 ID of the token to be added to the tokens list\r\n     */\r\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\r\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete _ownedTokensIndex[tokenId];\r\n        delete _ownedTokens[from][lastTokenIndex];\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's token tracking data structures.\r\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n     */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = _allTokens.length - 1;\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete _allTokensIndex[tokenId];\r\n        _allTokens.pop();\r\n    }\r\n}\r\n\r\n// File: prb-math/contracts/PRBMath.sol\r\n\r\n\r\npragma solidity >=0.8.4;\r\n\r\n/// @notice Emitted when the result overflows uint256.\r\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\r\n\r\n/// @notice Emitted when the result overflows uint256.\r\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\r\n\r\n/// @notice Emitted when one of the inputs is type(int256).min.\r\nerror PRBMath__MulDivSignedInputTooSmall();\r\n\r\n/// @notice Emitted when the intermediary absolute result overflows int256.\r\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the input is MIN_SD59x18.\r\nerror PRBMathSD59x18__AbsInputTooSmall();\r\n\r\n/// @notice Emitted when ceiling a number overflows SD59x18.\r\nerror PRBMathSD59x18__CeilOverflow(int256 x);\r\n\r\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\r\nerror PRBMathSD59x18__DivInputTooSmall();\r\n\r\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\r\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the input is greater than 133.084258667509499441.\r\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\r\n\r\n/// @notice Emitted when the input is greater than 192.\r\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\r\n\r\n/// @notice Emitted when flooring a number underflows SD59x18.\r\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\r\n\r\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\r\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\r\n\r\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\r\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\r\n\r\n/// @notice Emitted when the product of the inputs is negative.\r\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\r\n\r\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\r\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\r\n\r\n/// @notice Emitted when the input is less than or equal to zero.\r\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\r\n\r\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\r\nerror PRBMathSD59x18__MulInputTooSmall();\r\n\r\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\r\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\r\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the input is negative.\r\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\r\n\r\n/// @notice Emitted when the calculating the square root overflows SD59x18.\r\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\r\n\r\n/// @notice Emitted when addition overflows UD60x18.\r\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\r\n\r\n/// @notice Emitted when ceiling a number overflows UD60x18.\r\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\r\n\r\n/// @notice Emitted when the input is greater than 133.084258667509499441.\r\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\r\n\r\n/// @notice Emitted when the input is greater than 192.\r\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\r\n\r\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\r\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\r\n\r\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\r\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\r\n\r\n/// @notice Emitted when the input is less than 1.\r\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\r\n\r\n/// @notice Emitted when the calculating the square root overflows UD60x18.\r\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\r\n\r\n/// @notice Emitted when subtraction underflows UD60x18.\r\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\r\n\r\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\r\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\r\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\r\nlibrary PRBMath {\r\n    /// STRUCTS ///\r\n\r\n    struct SD59x18 {\r\n        int256 value;\r\n    }\r\n\r\n    struct UD60x18 {\r\n        uint256 value;\r\n    }\r\n\r\n    /// STORAGE ///\r\n\r\n    /// @dev How many trailing decimals can be represented.\r\n    uint256 internal constant SCALE = 1e18;\r\n\r\n    /// @dev Largest power of two divisor of SCALE.\r\n    uint256 internal constant SCALE_LPOTD = 262144;\r\n\r\n    /// @dev SCALE inverted mod 2^256.\r\n    uint256 internal constant SCALE_INVERSE = 78156646155174841979727994598816262306175212592076161876661508869554232690281;\r\n\r\n    /// FUNCTIONS ///\r\n\r\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\r\n    /// @dev Has to use 192.64-bit fixed-point numbers.\r\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\r\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function exp2(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // Start from 0.5 in the 192.64-bit fixed-point format.\r\n            result = 0x800000000000000000000000000000000000000000000000;\r\n\r\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\r\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\r\n            if (x & 0x8000000000000000 > 0) {\r\n                result = (result * 0x16A09E667F3BCC909) >> 64;\r\n            }\r\n            if (x & 0x4000000000000000 > 0) {\r\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\r\n            }\r\n            if (x & 0x2000000000000000 > 0) {\r\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\r\n            }\r\n            if (x & 0x1000000000000000 > 0) {\r\n                result = (result * 0x10B5586CF9890F62A) >> 64;\r\n            }\r\n            if (x & 0x800000000000000 > 0) {\r\n                result = (result * 0x1059B0D31585743AE) >> 64;\r\n            }\r\n            if (x & 0x400000000000000 > 0) {\r\n                result = (result * 0x102C9A3E778060EE7) >> 64;\r\n            }\r\n            if (x & 0x200000000000000 > 0) {\r\n                result = (result * 0x10163DA9FB33356D8) >> 64;\r\n            }\r\n            if (x & 0x100000000000000 > 0) {\r\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\r\n            }\r\n            if (x & 0x80000000000000 > 0) {\r\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\r\n            }\r\n            if (x & 0x40000000000000 > 0) {\r\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\r\n            }\r\n            if (x & 0x20000000000000 > 0) {\r\n                result = (result * 0x100162F3904051FA1) >> 64;\r\n            }\r\n            if (x & 0x10000000000000 > 0) {\r\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\r\n            }\r\n            if (x & 0x8000000000000 > 0) {\r\n                result = (result * 0x100058BA01FB9F96D) >> 64;\r\n            }\r\n            if (x & 0x4000000000000 > 0) {\r\n                result = (result * 0x10002C5CC37DA9492) >> 64;\r\n            }\r\n            if (x & 0x2000000000000 > 0) {\r\n                result = (result * 0x1000162E525EE0547) >> 64;\r\n            }\r\n            if (x & 0x1000000000000 > 0) {\r\n                result = (result * 0x10000B17255775C04) >> 64;\r\n            }\r\n            if (x & 0x800000000000 > 0) {\r\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\r\n            }\r\n            if (x & 0x400000000000 > 0) {\r\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\r\n            }\r\n            if (x & 0x200000000000 > 0) {\r\n                result = (result * 0x10000162E43F4F831) >> 64;\r\n            }\r\n            if (x & 0x100000000000 > 0) {\r\n                result = (result * 0x100000B1721BCFC9A) >> 64;\r\n            }\r\n            if (x & 0x80000000000 > 0) {\r\n                result = (result * 0x10000058B90CF1E6E) >> 64;\r\n            }\r\n            if (x & 0x40000000000 > 0) {\r\n                result = (result * 0x1000002C5C863B73F) >> 64;\r\n            }\r\n            if (x & 0x20000000000 > 0) {\r\n                result = (result * 0x100000162E430E5A2) >> 64;\r\n            }\r\n            if (x & 0x10000000000 > 0) {\r\n                result = (result * 0x1000000B172183551) >> 64;\r\n            }\r\n            if (x & 0x8000000000 > 0) {\r\n                result = (result * 0x100000058B90C0B49) >> 64;\r\n            }\r\n            if (x & 0x4000000000 > 0) {\r\n                result = (result * 0x10000002C5C8601CC) >> 64;\r\n            }\r\n            if (x & 0x2000000000 > 0) {\r\n                result = (result * 0x1000000162E42FFF0) >> 64;\r\n            }\r\n            if (x & 0x1000000000 > 0) {\r\n                result = (result * 0x10000000B17217FBB) >> 64;\r\n            }\r\n            if (x & 0x800000000 > 0) {\r\n                result = (result * 0x1000000058B90BFCE) >> 64;\r\n            }\r\n            if (x & 0x400000000 > 0) {\r\n                result = (result * 0x100000002C5C85FE3) >> 64;\r\n            }\r\n            if (x & 0x200000000 > 0) {\r\n                result = (result * 0x10000000162E42FF1) >> 64;\r\n            }\r\n            if (x & 0x100000000 > 0) {\r\n                result = (result * 0x100000000B17217F8) >> 64;\r\n            }\r\n            if (x & 0x80000000 > 0) {\r\n                result = (result * 0x10000000058B90BFC) >> 64;\r\n            }\r\n            if (x & 0x40000000 > 0) {\r\n                result = (result * 0x1000000002C5C85FE) >> 64;\r\n            }\r\n            if (x & 0x20000000 > 0) {\r\n                result = (result * 0x100000000162E42FF) >> 64;\r\n            }\r\n            if (x & 0x10000000 > 0) {\r\n                result = (result * 0x1000000000B17217F) >> 64;\r\n            }\r\n            if (x & 0x8000000 > 0) {\r\n                result = (result * 0x100000000058B90C0) >> 64;\r\n            }\r\n            if (x & 0x4000000 > 0) {\r\n                result = (result * 0x10000000002C5C860) >> 64;\r\n            }\r\n            if (x & 0x2000000 > 0) {\r\n                result = (result * 0x1000000000162E430) >> 64;\r\n            }\r\n            if (x & 0x1000000 > 0) {\r\n                result = (result * 0x10000000000B17218) >> 64;\r\n            }\r\n            if (x & 0x800000 > 0) {\r\n                result = (result * 0x1000000000058B90C) >> 64;\r\n            }\r\n            if (x & 0x400000 > 0) {\r\n                result = (result * 0x100000000002C5C86) >> 64;\r\n            }\r\n            if (x & 0x200000 > 0) {\r\n                result = (result * 0x10000000000162E43) >> 64;\r\n            }\r\n            if (x & 0x100000 > 0) {\r\n                result = (result * 0x100000000000B1721) >> 64;\r\n            }\r\n            if (x & 0x80000 > 0) {\r\n                result = (result * 0x10000000000058B91) >> 64;\r\n            }\r\n            if (x & 0x40000 > 0) {\r\n                result = (result * 0x1000000000002C5C8) >> 64;\r\n            }\r\n            if (x & 0x20000 > 0) {\r\n                result = (result * 0x100000000000162E4) >> 64;\r\n            }\r\n            if (x & 0x10000 > 0) {\r\n                result = (result * 0x1000000000000B172) >> 64;\r\n            }\r\n            if (x & 0x8000 > 0) {\r\n                result = (result * 0x100000000000058B9) >> 64;\r\n            }\r\n            if (x & 0x4000 > 0) {\r\n                result = (result * 0x10000000000002C5D) >> 64;\r\n            }\r\n            if (x & 0x2000 > 0) {\r\n                result = (result * 0x1000000000000162E) >> 64;\r\n            }\r\n            if (x & 0x1000 > 0) {\r\n                result = (result * 0x10000000000000B17) >> 64;\r\n            }\r\n            if (x & 0x800 > 0) {\r\n                result = (result * 0x1000000000000058C) >> 64;\r\n            }\r\n            if (x & 0x400 > 0) {\r\n                result = (result * 0x100000000000002C6) >> 64;\r\n            }\r\n            if (x & 0x200 > 0) {\r\n                result = (result * 0x10000000000000163) >> 64;\r\n            }\r\n            if (x & 0x100 > 0) {\r\n                result = (result * 0x100000000000000B1) >> 64;\r\n            }\r\n            if (x & 0x80 > 0) {\r\n                result = (result * 0x10000000000000059) >> 64;\r\n            }\r\n            if (x & 0x40 > 0) {\r\n                result = (result * 0x1000000000000002C) >> 64;\r\n            }\r\n            if (x & 0x20 > 0) {\r\n                result = (result * 0x10000000000000016) >> 64;\r\n            }\r\n            if (x & 0x10 > 0) {\r\n                result = (result * 0x1000000000000000B) >> 64;\r\n            }\r\n            if (x & 0x8 > 0) {\r\n                result = (result * 0x10000000000000006) >> 64;\r\n            }\r\n            if (x & 0x4 > 0) {\r\n                result = (result * 0x10000000000000003) >> 64;\r\n            }\r\n            if (x & 0x2 > 0) {\r\n                result = (result * 0x10000000000000001) >> 64;\r\n            }\r\n            if (x & 0x1 > 0) {\r\n                result = (result * 0x10000000000000001) >> 64;\r\n            }\r\n\r\n            // We're doing two things at the same time:\r\n            //\r\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\r\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\r\n            //      rather than 192.\r\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\r\n            //\r\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\r\n            result *= SCALE;\r\n            result >>= (191 - (x >> 64));\r\n        }\r\n    }\r\n\r\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\r\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\r\n    /// @param x The uint256 number for which to find the index of the most significant bit.\r\n    /// @return msb The index of the most significant bit as an uint256.\r\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\r\n        if (x >= 2**128) {\r\n            x >>= 128;\r\n            msb += 128;\r\n        }\r\n        if (x >= 2**64) {\r\n            x >>= 64;\r\n            msb += 64;\r\n        }\r\n        if (x >= 2**32) {\r\n            x >>= 32;\r\n            msb += 32;\r\n        }\r\n        if (x >= 2**16) {\r\n            x >>= 16;\r\n            msb += 16;\r\n        }\r\n        if (x >= 2**8) {\r\n            x >>= 8;\r\n            msb += 8;\r\n        }\r\n        if (x >= 2**4) {\r\n            x >>= 4;\r\n            msb += 4;\r\n        }\r\n        if (x >= 2**2) {\r\n            x >>= 2;\r\n            msb += 2;\r\n        }\r\n        if (x >= 2**1) {\r\n            // No need to shift x any more.\r\n            msb += 1;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\r\n    ///\r\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\r\n    ///\r\n    /// Requirements:\r\n    /// - The denominator cannot be zero.\r\n    /// - The result must fit within uint256.\r\n    ///\r\n    /// Caveats:\r\n    /// - This function does not work with fixed-point numbers.\r\n    ///\r\n    /// @param x The multiplicand as an uint256.\r\n    /// @param y The multiplier as an uint256.\r\n    /// @param denominator The divisor as an uint256.\r\n    /// @return result The result as an uint256.\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n        // variables such that product = prod1 * 2^256 + prod0.\r\n        uint256 prod0; // Least significant 256 bits of the product\r\n        uint256 prod1; // Most significant 256 bits of the product\r\n        assembly {\r\n            let mm := mulmod(x, y, not(0))\r\n            prod0 := mul(x, y)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        // Handle non-overflow cases, 256 by 256 division.\r\n        if (prod1 == 0) {\r\n            unchecked {\r\n                result = prod0 / denominator;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n        if (prod1 >= denominator) {\r\n            revert PRBMath__MulDivOverflow(prod1, denominator);\r\n        }\r\n\r\n        ///////////////////////////////////////////////\r\n        // 512 by 256 division.\r\n        ///////////////////////////////////////////////\r\n\r\n        // Make division exact by subtracting the remainder from [prod1 prod0].\r\n        uint256 remainder;\r\n        assembly {\r\n            // Compute remainder using mulmod.\r\n            remainder := mulmod(x, y, denominator)\r\n\r\n            // Subtract 256 bit number from 512 bit number.\r\n            prod1 := sub(prod1, gt(remainder, prod0))\r\n            prod0 := sub(prod0, remainder)\r\n        }\r\n\r\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n        // See https://cs.stackexchange.com/q/138556/92363.\r\n        unchecked {\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 lpotdod = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by lpotdod.\r\n                denominator := div(denominator, lpotdod)\r\n\r\n                // Divide [prod1 prod0] by lpotdod.\r\n                prod0 := div(prod0, lpotdod)\r\n\r\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\r\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * lpotdod;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates floor(x*y÷1e18) with full precision.\r\n    ///\r\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\r\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\r\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\r\n    ///\r\n    /// Requirements:\r\n    /// - The result must fit within uint256.\r\n    ///\r\n    /// Caveats:\r\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\r\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\r\n    ///     1. x * y = type(uint256).max * SCALE\r\n    ///     2. (x * y) % SCALE >= SCALE / 2\r\n    ///\r\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        uint256 prod0;\r\n        uint256 prod1;\r\n        assembly {\r\n            let mm := mulmod(x, y, not(0))\r\n            prod0 := mul(x, y)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        if (prod1 >= SCALE) {\r\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\r\n        }\r\n\r\n        uint256 remainder;\r\n        uint256 roundUpUnit;\r\n        assembly {\r\n            remainder := mulmod(x, y, SCALE)\r\n            roundUpUnit := gt(remainder, 499999999999999999)\r\n        }\r\n\r\n        if (prod1 == 0) {\r\n            unchecked {\r\n                result = (prod0 / SCALE) + roundUpUnit;\r\n                return result;\r\n            }\r\n        }\r\n\r\n        assembly {\r\n            result := add(\r\n                mul(\r\n                    or(\r\n                        div(sub(prod0, remainder), SCALE_LPOTD),\r\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\r\n                    ),\r\n                    SCALE_INVERSE\r\n                ),\r\n                roundUpUnit\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\r\n    ///\r\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\r\n    ///\r\n    /// Requirements:\r\n    /// - None of the inputs can be type(int256).min.\r\n    /// - The result must fit within int256.\r\n    ///\r\n    /// @param x The multiplicand as an int256.\r\n    /// @param y The multiplier as an int256.\r\n    /// @param denominator The divisor as an int256.\r\n    /// @return result The result as an int256.\r\n    function mulDivSigned(\r\n        int256 x,\r\n        int256 y,\r\n        int256 denominator\r\n    ) internal pure returns (int256 result) {\r\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\r\n            revert PRBMath__MulDivSignedInputTooSmall();\r\n        }\r\n\r\n        // Get hold of the absolute values of x, y and the denominator.\r\n        uint256 ax;\r\n        uint256 ay;\r\n        uint256 ad;\r\n        unchecked {\r\n            ax = x < 0 ? uint256(-x) : uint256(x);\r\n            ay = y < 0 ? uint256(-y) : uint256(y);\r\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\r\n        }\r\n\r\n        // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\r\n        uint256 rAbs = mulDiv(ax, ay, ad);\r\n        if (rAbs > uint256(type(int256).max)) {\r\n            revert PRBMath__MulDivSignedOverflow(rAbs);\r\n        }\r\n\r\n        // Get the signs of x, y and the denominator.\r\n        uint256 sx;\r\n        uint256 sy;\r\n        uint256 sd;\r\n        assembly {\r\n            sx := sgt(x, sub(0, 1))\r\n            sy := sgt(y, sub(0, 1))\r\n            sd := sgt(denominator, sub(0, 1))\r\n        }\r\n\r\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\r\n        // If yes, the result should be negative.\r\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\r\n    }\r\n\r\n    /// @notice Calculates the square root of x, rounding down.\r\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\r\n    ///\r\n    /// Caveats:\r\n    /// - This function does not work with fixed-point numbers.\r\n    ///\r\n    /// @param x The uint256 number for which to calculate the square root.\r\n    /// @return result The result as an uint256.\r\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Set the initial guess to the closest power of two that is higher than x.\r\n        uint256 xAux = uint256(x);\r\n        result = 1;\r\n        if (xAux >= 0x100000000000000000000000000000000) {\r\n            xAux >>= 128;\r\n            result <<= 64;\r\n        }\r\n        if (xAux >= 0x10000000000000000) {\r\n            xAux >>= 64;\r\n            result <<= 32;\r\n        }\r\n        if (xAux >= 0x100000000) {\r\n            xAux >>= 32;\r\n            result <<= 16;\r\n        }\r\n        if (xAux >= 0x10000) {\r\n            xAux >>= 16;\r\n            result <<= 8;\r\n        }\r\n        if (xAux >= 0x100) {\r\n            xAux >>= 8;\r\n            result <<= 4;\r\n        }\r\n        if (xAux >= 0x10) {\r\n            xAux >>= 4;\r\n            result <<= 2;\r\n        }\r\n        if (xAux >= 0x8) {\r\n            result <<= 1;\r\n        }\r\n\r\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\r\n        unchecked {\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1; // Seven iterations should be enough\r\n            uint256 roundedDownResult = x / result;\r\n            return result >= roundedDownResult ? roundedDownResult : result;\r\n        }\r\n    }\r\n}\r\n\r\n// File: prb-math/contracts/PRBMathUD60x18.sol\r\n\r\n\r\npragma solidity >=0.8.4;\r\n\r\n\r\n/// @title PRBMathUD60x18\r\n/// @author Paul Razvan Berg\r\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\r\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\r\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\r\n/// maximum values permitted by the Solidity type uint256.\r\nlibrary PRBMathUD60x18 {\r\n    /// @dev Half the SCALE number.\r\n    uint256 internal constant HALF_SCALE = 5e17;\r\n\r\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\r\n    uint256 internal constant LOG2_E = 1442695040888963407;\r\n\r\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\r\n    uint256 internal constant MAX_UD60x18 = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\r\n\r\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\r\n    uint256 internal constant MAX_WHOLE_UD60x18 = 115792089237316195423570985008687907853269984665640564039457000000000000000000;\r\n\r\n    /// @dev How many trailing decimals can be represented.\r\n    uint256 internal constant SCALE = 1e18;\r\n\r\n    /// @notice Calculates arithmetic average of x and y, rounding down.\r\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\r\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        // The operations can never overflow.\r\n        unchecked {\r\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\r\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\r\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\r\n        }\r\n    }\r\n\r\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\r\n    ///\r\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\r\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\r\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\r\n    function ceil(uint256 x) internal pure returns (uint256 result) {\r\n        if (x > MAX_WHOLE_UD60x18) {\r\n            revert PRBMathUD60x18__CeilOverflow(x);\r\n        }\r\n        assembly {\r\n            // Equivalent to \"x % SCALE\" but faster.\r\n            let remainder := mod(x, SCALE)\r\n\r\n            // Equivalent to \"SCALE - remainder\" but faster.\r\n            let delta := sub(SCALE, remainder)\r\n\r\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\r\n            result := add(x, mul(delta, gt(remainder, 0)))\r\n        }\r\n    }\r\n\r\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\r\n    ///\r\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\r\n    ///\r\n    /// Requirements:\r\n    /// - The denominator cannot be zero.\r\n    ///\r\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        result = PRBMath.mulDiv(x, SCALE, y);\r\n    }\r\n\r\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\r\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\r\n    function e() internal pure returns (uint256 result) {\r\n        result = 2718281828459045235;\r\n    }\r\n\r\n    /// @notice Calculates the natural exponent of x.\r\n    ///\r\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"log2\".\r\n    /// - x must be less than 133.084258667509499441.\r\n    ///\r\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function exp(uint256 x) internal pure returns (uint256 result) {\r\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\r\n        if (x >= 133084258667509499441) {\r\n            revert PRBMathUD60x18__ExpInputTooBig(x);\r\n        }\r\n\r\n        // Do the fixed-point multiplication inline to save gas.\r\n        unchecked {\r\n            uint256 doubleScaleProduct = x * LOG2_E;\r\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\r\n    ///\r\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be 192 or less.\r\n    /// - The result must fit within MAX_UD60x18.\r\n    ///\r\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function exp2(uint256 x) internal pure returns (uint256 result) {\r\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\r\n        if (x >= 192e18) {\r\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\r\n        }\r\n\r\n        unchecked {\r\n            // Convert x to the 192.64-bit fixed-point format.\r\n            uint256 x192x64 = (x << 64) / SCALE;\r\n\r\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\r\n            result = PRBMath.exp2(x192x64);\r\n        }\r\n    }\r\n\r\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\r\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\r\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\r\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\r\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\r\n    function floor(uint256 x) internal pure returns (uint256 result) {\r\n        assembly {\r\n            // Equivalent to \"x % SCALE\" but faster.\r\n            let remainder := mod(x, SCALE)\r\n\r\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\r\n            result := sub(x, mul(remainder, gt(remainder, 0)))\r\n        }\r\n    }\r\n\r\n    /// @notice Yields the excess beyond the floor of x.\r\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\r\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\r\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\r\n    function frac(uint256 x) internal pure returns (uint256 result) {\r\n        assembly {\r\n            result := mod(x, SCALE)\r\n        }\r\n    }\r\n\r\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\r\n    ///\r\n    /// @param x The basic integer to convert.\r\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\r\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            if (x > MAX_UD60x18 / SCALE) {\r\n                revert PRBMathUD60x18__FromUintOverflow(x);\r\n            }\r\n            result = x * SCALE;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\r\n    ///\r\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        unchecked {\r\n            // Checking for overflow this way is faster than letting Solidity do it.\r\n            uint256 xy = x * y;\r\n            if (xy / x != y) {\r\n                revert PRBMathUD60x18__GmOverflow(x, y);\r\n            }\r\n\r\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\r\n            // during multiplication. See the comments within the \"sqrt\" function.\r\n            result = PRBMath.sqrt(xy);\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates 1 / x, rounding towards zero.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x cannot be zero.\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\r\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\r\n    function inv(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 1e36 is SCALE * SCALE.\r\n            result = 1e36 / x;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the natural logarithm of x.\r\n    ///\r\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"log2\".\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"log2\".\r\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\r\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\r\n    function ln(uint256 x) internal pure returns (uint256 result) {\r\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\r\n        // can return is 196205294292027477728.\r\n        unchecked {\r\n            result = (log2(x) * SCALE) / LOG2_E;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the common logarithm of x.\r\n    ///\r\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\r\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"log2\".\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"log2\".\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\r\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\r\n    function log10(uint256 x) internal pure returns (uint256 result) {\r\n        if (x < SCALE) {\r\n            revert PRBMathUD60x18__LogInputTooSmall(x);\r\n        }\r\n\r\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\r\n        // in this contract.\r\n        // prettier-ignore\r\n        assembly {\r\n            switch x\r\n            case 1 { result := mul(SCALE, sub(0, 18)) }\r\n            case 10 { result := mul(SCALE, sub(1, 18)) }\r\n            case 100 { result := mul(SCALE, sub(2, 18)) }\r\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\r\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\r\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\r\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\r\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\r\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\r\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\r\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\r\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\r\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\r\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\r\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\r\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\r\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\r\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\r\n            case 1000000000000000000 { result := 0 }\r\n            case 10000000000000000000 { result := SCALE }\r\n            case 100000000000000000000 { result := mul(SCALE, 2) }\r\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\r\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\r\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\r\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\r\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\r\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\r\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\r\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\r\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\r\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\r\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\r\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\r\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\r\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\r\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\r\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\r\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\r\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\r\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\r\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\r\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\r\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\r\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\r\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\r\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\r\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\r\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\r\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\r\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\r\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\r\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\r\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\r\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\r\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\r\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\r\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\r\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\r\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\r\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\r\n            default {\r\n                result := MAX_UD60x18\r\n            }\r\n        }\r\n\r\n        if (result == MAX_UD60x18) {\r\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\r\n            unchecked {\r\n                result = (log2(x) * SCALE) / 3321928094887362347;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the binary logarithm of x.\r\n    ///\r\n    /// @dev Based on the iterative approximation algorithm.\r\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\r\n    ///\r\n    /// Caveats:\r\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\r\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\r\n    function log2(uint256 x) internal pure returns (uint256 result) {\r\n        if (x < SCALE) {\r\n            revert PRBMathUD60x18__LogInputTooSmall(x);\r\n        }\r\n        unchecked {\r\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\r\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\r\n\r\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\r\n            // because n is maximum 255 and SCALE is 1e18.\r\n            result = n * SCALE;\r\n\r\n            // This is y = x * 2^(-n).\r\n            uint256 y = x >> n;\r\n\r\n            // If y = 1, the fractional part is zero.\r\n            if (y == SCALE) {\r\n                return result;\r\n            }\r\n\r\n            // Calculate the fractional part via the iterative approximation.\r\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\r\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\r\n                y = (y * y) / SCALE;\r\n\r\n                // Is y^2 > 2 and so in the range [2,4)?\r\n                if (y >= 2 * SCALE) {\r\n                    // Add the 2^(-m) factor to the logarithm.\r\n                    result += delta;\r\n\r\n                    // Corresponds to z/2 on Wikipedia.\r\n                    y >>= 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\r\n    /// fixed-point number.\r\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\r\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        result = PRBMath.mulDivFixedPoint(x, y);\r\n    }\r\n\r\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\r\n    function pi() internal pure returns (uint256 result) {\r\n        result = 3141592653589793238;\r\n    }\r\n\r\n    /// @notice Raises x to the power of y.\r\n    ///\r\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"exp2\", \"log2\" and \"mul\".\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"exp2\", \"log2\" and \"mul\".\r\n    /// - Assumes 0^0 is 1.\r\n    ///\r\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\r\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        if (x == 0) {\r\n            result = y == 0 ? SCALE : uint256(0);\r\n        } else {\r\n            result = exp2(mul(log2(x), y));\r\n        }\r\n    }\r\n\r\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\r\n    /// famous algorithm \"exponentiation by squaring\".\r\n    ///\r\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\r\n    ///\r\n    /// Requirements:\r\n    /// - The result must fit within MAX_UD60x18.\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"mul\".\r\n    /// - Assumes 0^0 is 1.\r\n    ///\r\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The exponent as an uint256.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        // Calculate the first iteration of the loop in advance.\r\n        result = y & 1 > 0 ? x : SCALE;\r\n\r\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\r\n        for (y >>= 1; y > 0; y >>= 1) {\r\n            x = PRBMath.mulDivFixedPoint(x, x);\r\n\r\n            // Equivalent to \"y % 2 == 1\" but faster.\r\n            if (y & 1 > 0) {\r\n                result = PRBMath.mulDivFixedPoint(result, x);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\r\n    function scale() internal pure returns (uint256 result) {\r\n        result = SCALE;\r\n    }\r\n\r\n    /// @notice Calculates the square root of x, rounding down.\r\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be less than MAX_UD60x18 / SCALE.\r\n    ///\r\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\r\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            if (x > MAX_UD60x18 / SCALE) {\r\n                revert PRBMathUD60x18__SqrtOverflow(x);\r\n            }\r\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\r\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\r\n            result = PRBMath.sqrt(x * SCALE);\r\n        }\r\n    }\r\n\r\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\r\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\r\n    /// @return result The same number in basic integer form.\r\n    function toUint(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            result = x / SCALE;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/MultyOwned.sol\r\n\r\npragma solidity >=0.5.0;\r\n\r\n//import \"hardhat/console.sol\";\r\n\r\n\r\n/// @title у контракта несколько владельцев\r\ncontract MultyOwned {\r\n    using PRBMathUD60x18 for uint256;\r\n\r\n    uint256 public constant OWNERS_COUNT = 3; // количество владельцев\r\n    uint256 constant OWNER_PART_0 = 425E15;\r\n    uint256 constant OWNER_PART_1 = 425E15;\r\n    uint256 constant OWNER_PART_2 = 150E15;\r\n    address OWNER_0 = address(0x1d3d6671a8A6650E60802613a3838865a4c260ef);\r\n    address OWNER_1 = address(0x79E551d8fF2eB3eC04e2d8B83c0714937cF00ECA);\r\n    address OWNER_2 = address(0xE102c1e0E0DB088ea15f9032b839E9C8cAf92cBC);\r\n\r\n    address[OWNERS_COUNT] _OwnerRequest; // кому предложено стать владельцем кошелька\r\n\r\n    // раскомментировать, перед выполнением тестов\r\n    /*constructor() {\r\n        OWNER_0 = msg.sender;\r\n    }*/\r\n\r\n    /// @dev модификатор метода, только для владельца контракта\r\n    modifier onlyOwner() {\r\n        require(IsOwner(msg.sender), \"Only owner can call this function.\");\r\n        _;\r\n    }\r\n\r\n    /// @dev определяет, является ли указанный адрес владельцем контракта\r\n    function IsOwner(address account) public view returns (bool) {\r\n        return account == OWNER_0 || account == OWNER_1 || account == OWNER_2;\r\n    }\r\n\r\n    /// @dev получает индекс владельца или индекс равный OWNERS_COUNT, если указанный адрес не владелец\r\n    function GetContractOwner(uint256 index) public view returns (address) {\r\n        if (index == 0) return OWNER_0;\r\n        if (index == 1) return OWNER_1;\r\n        if (index == 2) return OWNER_2;\r\n        return address(0);\r\n    }\r\n\r\n    /// @dev выводит владельца с указанным индексом\r\n    function GetContractOwnerIndex(address account)\r\n        public\r\n        view\r\n        returns (uint8)\r\n    {\r\n        if (account == OWNER_0) return 0;\r\n        if (account == OWNER_1) return 1;\r\n        if (account == OWNER_2) return 2;\r\n        return 4;\r\n    }\r\n\r\n    /// @dev предложить акку стать владельцем\r\n    function TransferOwnerRequest(address newOwner) public onlyOwner {\r\n        _OwnerRequest[GetContractOwnerIndex(msg.sender)] = newOwner;\r\n    }\r\n\r\n    /// @dev принимает запрос на получение права владения\r\n    function ApplyOwnerRequest() public {\r\n        if (_OwnerRequest[0] == msg.sender) {\r\n            OWNER_0 = msg.sender;\r\n            return;\r\n        }\r\n        if (_OwnerRequest[1] == msg.sender) {\r\n            OWNER_1 = msg.sender;\r\n            return;\r\n        }\r\n        if (_OwnerRequest[2] == msg.sender) {\r\n            OWNER_2 = msg.sender;\r\n            return;\r\n        }\r\n    }\r\n\r\n    /// @dev донатит разработчикам\r\n    function Donate() public payable {\r\n        uint256 sum; // сколько всего отправили\r\n        uint256 partSum;\r\n\r\n        // передаем 0 разработчику\r\n        partSum = PRBMathUD60x18.mul(OWNER_PART_0, msg.value);\r\n        payable(OWNER_0).transfer(partSum);\r\n        sum += partSum;\r\n\r\n        // передаем 1 разработчику\r\n        partSum = PRBMathUD60x18.mul(OWNER_PART_1, msg.value);\r\n        if (sum + partSum > msg.value) {\r\n            partSum = msg.value - sum;\r\n            if (partSum > 0) payable(OWNER_1).transfer(partSum);            \r\n            return;\r\n        }\r\n        payable(OWNER_1).transfer(partSum);\r\n        sum += partSum;\r\n\r\n        // передаем 2 разработчику\r\n        partSum = PRBMathUD60x18.mul(OWNER_PART_2, msg.value);\r\n        if (sum + partSum > msg.value) {\r\n            partSum = msg.value - sum;\r\n            if (partSum > 0) payable(OWNER_2).transfer(partSum);            \r\n            return;\r\n        }\r\n        payable(OWNER_2).transfer(partSum);\r\n    }\r\n}\r\n\r\n// File: contracts/OpenSeaMeta.sol\r\n\r\npragma solidity >=0.8.3;\r\n\r\n\r\n\r\n/// @title описывает метаданные для Opensea\r\ncontract OpenSeaMeta is MultyOwned, ERC721Enumerable {   \r\n    address _owner; // овнер - только для openSea и подобных систем\r\n    string public ContractURI = \"https://musicracernft.org/api/globalmeta\"; // мета контракта\r\n    string public BaseURI = \"https://musicracernft.org/api/carsmeta/\"; // базовый адрес для меты токенов\r\n\r\n    constructor(string memory name_, string memory symbol_)\r\n        ERC721(name_, symbol_)\r\n    {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function SetOwner(address newOwner) public onlyOwner {\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /// @dev ссылка на метаданные уровня витрины\r\n    //function contractURI() public view returns (string memory) {\r\n    //    return ContractURIInternal;\r\n    //}\r\n\r\n    /// @dev задает адрес меты контракта\r\n    function SetContractURI(string calldata newContractURI) public onlyOwner {\r\n        ContractURI = newContractURI;\r\n    }\r\n\r\n    /// @dev задает новый BaseURI\r\n    function SetBaseURI(string calldata newBaseURI) public onlyOwner {\r\n        BaseURI = newBaseURI;\r\n    }\r\n\r\n    /// @dev используется для вычисления адресов через\r\n    /// унаследованную функцию tokenURI(uint256 tokenId), который дописывает ID токена вконец\r\n    function _baseURI() internal view override returns (string memory) {\r\n        return BaseURI;\r\n    }\r\n}\r\n\r\n// File: contracts/Car.sol\r\n\r\npragma solidity >=0.8.3;\r\n\r\n/// @title описание формирования начальной цены машины\r\nstruct PriceData {\r\n    /// @notice начальная цена 1=0.001 eth\r\n    uint256 StartPrice;\r\n    /// @notice конечная цена (когда все продано) 1=0.001 eth\r\n    uint256 EndPrice;\r\n    /// @notice тип формирования цены\r\n    /// 0 - только стартовая цена\r\n    /// 1 - линейная интерполяция от начальной цены к конечной\r\n    uint256 PriceType;\r\n}\r\n\r\n/// @title тип части машины\r\nstruct CarPartType {\r\n    /// @notice вероятность генерации не нуливого значения 100000=100%\r\n    uint256 Probability;\r\n    /// @notice сколько всего частей имеется\r\n    uint256 Count;\r\n}\r\n\r\n/// @title тип машины\r\nstruct CarType {\r\n    /// @notice все типы частей\r\n    CarPartType[] PartTypes;\r\n    /// @notice вероятности окрасок 100% будет окраска=100000\r\n    uint256[] Colors;\r\n    /// @notice сколько машин создано\r\n    uint256 Count;\r\n    /// @notice максимальное количество генерируемых машин\r\n    uint256 MaxCount;\r\n    /// @notice цена минта\r\n    PriceData Price;\r\n    /// @notice сколько машин зарезервировано для фабрики (это количество машин не может минтиться с контракта напрямую)\r\n    uint256 FactoryReserve;\r\n    /// @notice если истина, то минт машин этого типа возможен\r\n    bool Enable;\r\n}\r\n\r\n/// @title описание инстанции одной машины\r\nstruct Car {\r\n    /// @notice ID типа машины (больше 0, тк 0 это отсуствие типа)\r\n    uint256 TypeId;\r\n    /// @notice установленные части машины 0 - часть не задана\r\n    uint256[] Parts;\r\n    /// @notice какие цвета в машине включены, а какие нет\r\n    bool[] ColorsEnable;\r\n    /// @notice цвета машины\r\n    uint256[] Colors;\r\n}\r\n\r\n// File: contracts/CarFactory.sol\r\n\r\npragma solidity >=0.8.4;\r\n\r\n\r\n\r\n\r\n/// @title порождает машины\r\ncontract CarFactory is OpenSeaMeta {\r\n    using PRBMathUD60x18 for uint256;\r\n\r\n    uint256 PriceMul = 1e15; // 1=0.001 эфира\r\n\r\n    mapping(uint256 => CarType) public CarsTypes; // все типы машин\r\n    uint256 public CarTypesCount = 0; // общее количество типов машин\r\n    uint256 _RandNonce = 0; // нонс рандома\r\n    event NewType(uint256 indexed carType); // когда создается новый тип машины\r\n\r\n    constructor(string memory name_, string memory symbol_)\r\n        OpenSeaMeta(name_, symbol_)\r\n    {\r\n        CarType storage ct = CarsTypes[1];\r\n        ct.PartTypes.push(CarPartType(50e3, 83));\r\n        ct.PartTypes.push(CarPartType(100e3, 28));\r\n        ct.PartTypes.push(CarPartType(50e3, 10));\r\n        ct.PartTypes.push(CarPartType(50e3, 11));\r\n        ct.PartTypes.push(CarPartType(100e3, 11));\r\n        ct.Colors = new uint256[](2);\r\n        ct.Colors[0] = 100e3;\r\n        ct.Colors[1] = 50e3;\r\n        ct.MaxCount = 333;\r\n        ct.Price = PriceData(132, 330, 1);\r\n        ct.FactoryReserve = 47;\r\n        ct.Enable = true;\r\n\r\n        CarTypesCount = 1;\r\n        emit NewType(CarTypesCount);\r\n    }\r\n\r\n    /// @dev порождает новую машину указанного типа\r\n    /// @param carTypeId ID типа машины\r\n    /// @param carType тип машины\r\n    function CreateCar(uint256 carTypeId, CarType storage carType)\r\n        internal\r\n        returns (Car memory)\r\n    {\r\n        // генерируем части машины из ее типа\r\n        uint256[] memory parts = new uint256[](carType.PartTypes.length);\r\n        for (uint256 i = 0; i < carType.PartTypes.length; ++i) {\r\n            CarPartType memory partType = carType.PartTypes[i];\r\n            if ((_Random() % 100000) < partType.Probability)\r\n                parts[i] = 1 + (_Random() % partType.Count);\r\n            else parts[i] = 0;\r\n        }\r\n\r\n        // генерация цветов\r\n        bool[] memory colorsEnable = new bool[](carType.Colors.length);\r\n        uint256[] memory colors = new uint256[](carType.Colors.length);\r\n        for (uint256 i = 0; i < carType.Colors.length; ++i) {\r\n            colorsEnable[i] = (_Random() % 100000) < carType.Colors[i];\r\n            if (colorsEnable[i]) colors[i] = RandomColor();\r\n        }\r\n\r\n        // создаем машину\r\n        Car memory newCar = Car(carTypeId, parts, colorsEnable, colors);\r\n        // увеличиваем счетчик созданных машин\r\n        carType.Count++;\r\n        // вывод результата\r\n        return newCar;\r\n    }\r\n\r\n    /// @notice\r\n    function RandomColor() internal returns (uint256) {\r\n        uint256 r = _Random() % 256;\r\n        uint256 g = _Random() % 256;\r\n        uint256 b = _Random() % 256;\r\n        //uint256 a = _Random() % 256;\r\n\r\n        return b | (g << 8) | (r << 16); // & (a << 24);\r\n    }\r\n\r\n    function _Random() internal returns (uint256) {\r\n        uint256 res = uint256(\r\n            keccak256(abi.encodePacked(msg.sender, _RandNonce, block.timestamp))\r\n        );\r\n        _RandNonce++;\r\n        return res;\r\n    }\r\n\r\n    /// @dev добавляет новый тип машины\r\n    function AddCarType(CarType calldata newType) public onlyOwner {\r\n        require(\r\n            newType.Price.StartPrice <= newType.Price.EndPrice,\r\n            \"car price is incorrect\"\r\n        );\r\n        CarTypesCount++;\r\n        CarsTypes[CarTypesCount] = newType;\r\n        emit NewType(CarTypesCount);\r\n    }\r\n\r\n    /// @dev возвращает текущую цену машины\r\n    /// @param carTypeId Id типа машины\r\n    function GetPrice(uint256 carTypeId) public view returns (uint256) {\r\n        return GetPriceAlgorithm(carTypeId) * PriceMul;\r\n    }\r\n\r\n    /// @dev алгоритм получения ценника\r\n    function GetPriceAlgorithm(uint256 carTypeId)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        CarType memory carType = CarsTypes[carTypeId];\r\n        if (carType.Price.PriceType == 0) return carType.Price.StartPrice;\r\n        if (carType.Price.PriceType == 1) {\r\n            uint256 f = PRBMathUD60x18.div(carType.Count, carType.MaxCount);\r\n            return\r\n                carType.Price.StartPrice +\r\n                PRBMathUD60x18.mul(\r\n                    f,\r\n                    carType.Price.EndPrice - carType.Price.StartPrice\r\n                );\r\n        } else return carType.Price.StartPrice;\r\n    }\r\n\r\n    /// @dev возвращает настройки ценообразования минта на определенный тип машин\r\n    function GetPriceData(uint256 carTypeId)\r\n        public\r\n        view\r\n        returns (PriceData memory)\r\n    {\r\n        return CarsTypes[carTypeId].Price;\r\n    }\r\n\r\n    /// @dev возвращает количество возможных частей машины указанного типа\r\n    /// @param carTypeId Id типа машины\r\n    function GetPartsCount(uint256 carTypeId) public view returns (uint256) {\r\n        return CarsTypes[carTypeId].PartTypes.length;\r\n    }\r\n\r\n    /// @dev возвращает тип части машины\r\n    /// @param carTypeId Id типа машины\r\n    /// @param partIndex индекс части машины\r\n    function GetPart(uint256 carTypeId, uint256 partIndex)\r\n        public\r\n        view\r\n        returns (CarPartType memory)\r\n    {\r\n        return CarsTypes[carTypeId].PartTypes[partIndex];\r\n    }\r\n}\r\n\r\n// File: contracts/MusicRacerNFT.sol\r\n\r\npragma solidity >=0.8.3;\r\n\r\n//import \"hardhat/console.sol\";\r\n\r\n\r\n\r\n\r\n/// @title определяет владение машинами\r\ncontract MusicRacerNFT is CarFactory {\r\n    mapping(uint256 => Car) public IdToCar; // кэш машин по ID\r\n    uint256 _CurMintId = 1; // текщий ID токена для минта\r\n    address public Factory; // фабрика, которая может минтить токены\r\n    mapping(uint256 => bool) public ChangeCarsBlock; // блоки изменений по типам машин (если true то гарантируется, что эту машину овнер изменить не может)\r\n\r\n    constructor() CarFactory(\"MusicRacerNFT\", \"MRCR\") {}\r\n\r\n    /// @dev возвращает непосредственно данные машины для конкретного токена\r\n    function GetCar(uint256 tokenId) public view returns (Car memory) {\r\n        return IdToCar[tokenId];\r\n    }\r\n\r\n    /// @dev возвращает цвет в формате RGB\r\n    /// @param tokenId id токена\r\n    /// @param colorIndex индекс цвета\r\n    function GetCarColorRGB(uint256 tokenId, uint256 colorIndex)\r\n        public\r\n        view\r\n        returns (\r\n            bool, // имеется ли цвет\r\n            uint8, // r\r\n            uint8, // g\r\n            uint8 // b\r\n        )\r\n    {\r\n        Car memory car = GetCar(tokenId);\r\n        uint256 color = car.Colors[colorIndex];\r\n        uint8 b = (uint8)(color & 0xff);\r\n        color >>= 8;\r\n        uint8 g = (uint8)(color & 0xff);\r\n        color >>= 8;\r\n        uint8 r = (uint8)(color & 0xff);\r\n        return (car.ColorsEnable[colorIndex], r, g, b);\r\n    }\r\n\r\n    /// @dev задает адрес фабрики-краудсейла\r\n    function SetFactory(address newFactory) public onlyOwner {\r\n        Factory = newFactory;\r\n    }\r\n\r\n    /// @dev проверка возможности заминтить токен вызывающим адресом\r\n    function canMint(uint256 carTypeId) external view returns (bool) {\r\n        return canMintInternal(CarsTypes[carTypeId]);\r\n    }\r\n\r\n    function canMintInternal(CarType storage carType)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (msg.sender == Factory) {\r\n            if (carType.Count >= carType.MaxCount) return false;\r\n        } else if (carType.Count + carType.FactoryReserve >= carType.MaxCount)\r\n            return false;\r\n        if (\r\n            msg.sender != address(this) &&\r\n            msg.sender != Factory &&\r\n            !IsOwner(msg.sender)\r\n        ) return false;\r\n        return carType.Enable;\r\n    }\r\n\r\n    /// @dev минтит машину с указанным ID (метод для фабрики)\r\n    /// @param carTypeId id типа машины\r\n    /// @param _toAddress кому заминтить\r\n    function mint(uint256 carTypeId, address _toAddress) external {\r\n        CarType storage carType = CarsTypes[carTypeId];\r\n        require(canMintInternal(carType), \"cannot mint car\");\r\n        IdToCar[_CurMintId] = CreateCar(carTypeId, carType);\r\n        _mint(_toAddress, _CurMintId);\r\n        _CurMintId++;\r\n        if (msg.sender == Factory) --carType.FactoryReserve;\r\n    }\r\n\r\n    /// @dev производит изначальный минт машин\r\n    /// @param carTypeId ID типа машины, которую нужно заминтить\r\n    function MintCar(uint256 carTypeId) public payable {\r\n        require(msg.value >= GetPrice(carTypeId), \"not enough eth\");\r\n        Donate();\r\n        this.mint(carTypeId, msg.sender);\r\n    }\r\n\r\n    /// @dev изменяет машину\r\n    /// @param tokenId id токена\r\n    /// @param newCar новые данные машины\r\n    function ChangeCar(uint256 tokenId, Car calldata newCar) public onlyOwner {\r\n        uint256 carTypeId = IdToCar[tokenId].TypeId;\r\n        require(!ChangeCarsBlock[carTypeId], \"cars changes blocked\");\r\n        IdToCar[tokenId] = newCar;\r\n        IdToCar[tokenId].TypeId = carTypeId;\r\n    }\r\n\r\n    /// @dev изменяет настройки генерации машин определенного типа\r\n    function ChangeCarType(uint256 carTypeId, CarType calldata newTypeData)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(!ChangeCarsBlock[carTypeId], \"cars changes blocked\");\r\n        CarsTypes[carTypeId] = newTypeData;\r\n    }\r\n\r\n    /// @dev изменяет стоимость машины\r\n    function SetCarPrice(uint256 carTypeId, PriceData calldata newPrice)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(!ChangeCarsBlock[carTypeId], \"cars changes blocked\");\r\n        require(newPrice.StartPrice <= newPrice.EndPrice, \"price is incorrect\");\r\n        CarsTypes[carTypeId].Price = newPrice;\r\n    }\r\n\r\n    /// @dev блокирует изменения определенного типа машин\r\n    /// @param carTypeId тип машин\r\n    function BlockCarChanges(uint256 carTypeId) public onlyOwner {\r\n        ChangeCarsBlock[carTypeId] = true;\r\n    }\r\n\r\n    /// @dev задает возможность минтить машину указанного типа\r\n    /// @param carTypeId тип машин\r\n    /// @param mintEnable можно ли минтить машину\r\n    function SetMintEnable(uint256 carTypeId, bool mintEnable)\r\n        public\r\n        onlyOwner\r\n    {\r\n        CarsTypes[carTypeId].Enable = mintEnable;\r\n    }\r\n\r\n    /// @dev выводит список всех токенов указанного владельца\r\n    /// @param account на какого владельца выдать список\r\n    function GetTokensList(address account)\r\n        public\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        uint256 count = balanceOf(account);\r\n        uint256[] memory res = new uint256[](count);\r\n        for (uint256 i = 0; i < count; ++i) {\r\n            res[i] = tokenOfOwnerByIndex(account, i);\r\n        }\r\n        return res;\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"}],\"name\":\"PRBMath__MulDivFixedPointOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"PRBMath__MulDivOverflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"carType\",\"type\":\"uint256\"}],\"name\":\"NewType\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Probability\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Count\",\"type\":\"uint256\"}],\"internalType\":\"struct CarPartType[]\",\"name\":\"PartTypes\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"Colors\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"Count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MaxCount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"StartPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EndPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"PriceType\",\"type\":\"uint256\"}],\"internalType\":\"struct PriceData\",\"name\":\"Price\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"FactoryReserve\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"Enable\",\"type\":\"bool\"}],\"internalType\":\"struct CarType\",\"name\":\"newType\",\"type\":\"tuple\"}],\"name\":\"AddCarType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ApplyOwnerRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BaseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"carTypeId\",\"type\":\"uint256\"}],\"name\":\"BlockCarChanges\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CarTypesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CarsTypes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MaxCount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"StartPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EndPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"PriceType\",\"type\":\"uint256\"}],\"internalType\":\"struct PriceData\",\"name\":\"Price\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"FactoryReserve\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"Enable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"TypeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"Parts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"ColorsEnable\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"Colors\",\"type\":\"uint256[]\"}],\"internalType\":\"struct Car\",\"name\":\"newCar\",\"type\":\"tuple\"}],\"name\":\"ChangeCar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"carTypeId\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Probability\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Count\",\"type\":\"uint256\"}],\"internalType\":\"struct CarPartType[]\",\"name\":\"PartTypes\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"Colors\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"Count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MaxCount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"StartPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EndPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"PriceType\",\"type\":\"uint256\"}],\"internalType\":\"struct PriceData\",\"name\":\"Price\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"FactoryReserve\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"Enable\",\"type\":\"bool\"}],\"internalType\":\"struct CarType\",\"name\":\"newTypeData\",\"type\":\"tuple\"}],\"name\":\"ChangeCarType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ChangeCarsBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ContractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Donate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"GetCar\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"TypeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"Parts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"ColorsEnable\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"Colors\",\"type\":\"uint256[]\"}],\"internalType\":\"struct Car\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"colorIndex\",\"type\":\"uint256\"}],\"name\":\"GetCarColorRGB\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"GetContractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GetContractOwnerIndex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"carTypeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partIndex\",\"type\":\"uint256\"}],\"name\":\"GetPart\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Probability\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Count\",\"type\":\"uint256\"}],\"internalType\":\"struct CarPartType\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"carTypeId\",\"type\":\"uint256\"}],\"name\":\"GetPartsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"carTypeId\",\"type\":\"uint256\"}],\"name\":\"GetPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"carTypeId\",\"type\":\"uint256\"}],\"name\":\"GetPriceData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"StartPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EndPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"PriceType\",\"type\":\"uint256\"}],\"internalType\":\"struct PriceData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GetTokensList\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"IdToCar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"TypeId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"IsOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"carTypeId\",\"type\":\"uint256\"}],\"name\":\"MintCar\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OWNERS_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"SetBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"carTypeId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"StartPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"EndPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"PriceType\",\"type\":\"uint256\"}],\"internalType\":\"struct PriceData\",\"name\":\"newPrice\",\"type\":\"tuple\"}],\"name\":\"SetCarPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newContractURI\",\"type\":\"string\"}],\"name\":\"SetContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFactory\",\"type\":\"address\"}],\"name\":\"SetFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"carTypeId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"mintEnable\",\"type\":\"bool\"}],\"name\":\"SetMintEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"SetOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"TransferOwnerRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"carTypeId\",\"type\":\"uint256\"}],\"name\":\"canMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"carTypeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MusicRacerNFT","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://a6ec59f0b4532043f867b838fa0a0b7ded9a917f9c5cff484d9f7962d713bb93"}]}