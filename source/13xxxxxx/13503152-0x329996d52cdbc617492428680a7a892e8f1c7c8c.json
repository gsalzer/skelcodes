{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/L1CrossDomainMessengerFast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.8.8;\\n\\n/* Library Imports */\\nimport { AddressAliasHelper } from \\\"@eth-optimism/contracts/contracts/standards/AddressAliasHelper.sol\\\";\\nimport { Lib_AddressResolver } from \\\"@eth-optimism/contracts/contracts/libraries/resolver/Lib_AddressResolver.sol\\\";\\nimport { Lib_OVMCodec } from \\\"@eth-optimism/contracts/contracts/libraries/codec/Lib_OVMCodec.sol\\\";\\nimport { Lib_AddressManager } from \\\"@eth-optimism/contracts/contracts/libraries/resolver/Lib_AddressManager.sol\\\";\\nimport { Lib_SecureMerkleTrie } from \\\"@eth-optimism/contracts/contracts/libraries/trie/Lib_SecureMerkleTrie.sol\\\";\\nimport { Lib_DefaultValues } from \\\"@eth-optimism/contracts/contracts/libraries/constants/Lib_DefaultValues.sol\\\";\\nimport { Lib_PredeployAddresses } from \\\"@eth-optimism/contracts/contracts/libraries/constants/Lib_PredeployAddresses.sol\\\";\\nimport { Lib_CrossDomainUtils } from \\\"@eth-optimism/contracts/contracts/libraries/bridge/Lib_CrossDomainUtils.sol\\\";\\n\\n/* Interface Imports */\\nimport { IL1CrossDomainMessenger } from \\\"@eth-optimism/contracts/contracts/L1/messaging/IL1CrossDomainMessenger.sol\\\";\\nimport { ICanonicalTransactionChain } from \\\"@eth-optimism/contracts/contracts/L1/rollup/ICanonicalTransactionChain.sol\\\";\\nimport { IStateCommitmentChain } from \\\"@eth-optimism/contracts/contracts/L1/rollup/IStateCommitmentChain.sol\\\";\\n\\n/* External Imports */\\nimport { OwnableUpgradeable } from \\n    \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport { PausableUpgradeable } from \\n    \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport { ReentrancyGuardUpgradeable } from \\n    \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\n\\n/**\\n * @title L1CrossDomainMessengerFast\\n * @dev The L1 Cross Domain Messenger contract sends messages from L1 to L2, and relays messages from L2 onto L1.\\n * In the event that a message sent from L1 to L2 is rejected for exceeding the L2 epoch gas limit, it can be resubmitted\\n * via this contract's replay function.\\n *\\n * Compiler used: solc\\n * Runtime target: EVM\\n */\\ncontract L1CrossDomainMessengerFast is\\n    IL1CrossDomainMessenger,\\n    Lib_AddressResolver,\\n    OwnableUpgradeable,\\n    PausableUpgradeable,\\n    ReentrancyGuardUpgradeable\\n{\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n\\n    event MessageBlocked(\\n        bytes32 indexed _xDomainCalldataHash\\n    );\\n\\n    event MessageAllowed(\\n        bytes32 indexed _xDomainCalldataHash\\n    );\\n\\n    /**********************\\n     * Contract Variables *\\n     **********************/\\n\\n    mapping (bytes32 => bool) public blockedMessages;\\n    mapping (bytes32 => bool) public relayedMessages;\\n    mapping (bytes32 => bool) public successfulMessages;\\n    mapping (bytes32 => bool) public failedMessages;\\n\\n    address internal xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * This contract is intended to be behind a delegate proxy.\\n     * We pass the zero address to the address resolver just to satisfy the constructor.\\n     * We still need to set this value in initialize().\\n     */\\n    constructor()\\n        Lib_AddressResolver(address(0))\\n    {}\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Address Manager.\\n     */\\n    function initialize(\\n        address _libAddressManager\\n    )\\n        public\\n        initializer\\n    {\\n        require(\\n            address(libAddressManager) == address(0),\\n            \\\"L1CrossDomainMessenger already intialized.\\\"\\n        );\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\\n\\n        // Initialize upgradable OZ contracts\\n        __Context_init_unchained(); // Context is a dependency for both Ownable and Pausable\\n        __Ownable_init_unchained();\\n        __Pausable_init_unchained();\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    /**\\n     * Pause fast exit relays\\n     */\\n    function pause() \\n        external \\n        onlyOwner() {\\n        _pause();\\n    }\\n\\n    /**\\n     * UnPause fast exit relays\\n     */\\n    function unpause() \\n        external \\n        onlyOwner() {\\n        _unpause();\\n    }\\n\\n    /**\\n     * Block a message.\\n     * @param _xDomainCalldataHash Hash of the message to block.\\n     */\\n    function blockMessage(\\n        bytes32 _xDomainCalldataHash\\n    )\\n        external\\n        onlyOwner\\n    {\\n        blockedMessages[_xDomainCalldataHash] = true;\\n        emit MessageBlocked(_xDomainCalldataHash);\\n    }\\n\\n    /**\\n     * Allow a message.\\n     * @param _xDomainCalldataHash Hash of the message to block.\\n     */\\n    function allowMessage(\\n        bytes32 _xDomainCalldataHash\\n    )\\n        external\\n        onlyOwner\\n    {\\n        blockedMessages[_xDomainCalldataHash] = false;\\n        emit MessageAllowed(_xDomainCalldataHash);\\n    }\\n\\n    function xDomainMessageSender()\\n        public\\n        override\\n        view\\n        returns (\\n            address\\n        )\\n    {\\n        require(xDomainMsgSender != Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER, \\\"xDomainMessageSender is not set\\\");\\n        return xDomainMsgSender;\\n    }\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    function sendMessage(\\n        address _target,\\n        bytes memory _message,\\n        uint32 _gasLimit\\n    )\\n        override\\n        public\\n    {\\n        revert(\\\"Sending via this messenger is disabled\\\");\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Relays a cross domain message to a contract.\\n     * @inheritdoc IL1CrossDomainMessenger\\n     */\\n    function relayMessage(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _messageNonce,\\n        L2MessageInclusionProof memory _proof\\n    )\\n        override\\n        public\\n        nonReentrant\\n        whenNotPaused\\n    {\\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\\n            _target,\\n            _sender,\\n            _message,\\n            _messageNonce\\n        );\\n\\n        require(\\n            _verifyXDomainMessage(\\n                xDomainCalldata,\\n                _proof\\n            ) == true,\\n            \\\"Provided message could not be verified.\\\"\\n        );\\n\\n        bytes32 xDomainCalldataHash = keccak256(xDomainCalldata);\\n\\n        require(\\n            successfulMessages[xDomainCalldataHash] == false,\\n            \\\"Provided message has already been received.\\\"\\n        );\\n\\n        require(\\n            blockedMessages[xDomainCalldataHash] == false,\\n            \\\"Provided message has been blocked.\\\"\\n        );\\n\\n        require(\\n            _target != resolve(\\\"CanonicalTransactionChain\\\"),\\n            \\\"Cannot send L2->L1 messages to L1 system contracts.\\\"\\n        );\\n\\n        xDomainMsgSender = _sender;\\n        (bool success, ) = _target.call(_message);\\n        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\\n\\n        // Mark the message as received if the call was successful. Ensures that a message can be\\n        // relayed multiple times in the case that the call reverted.\\n        if (success == true) {\\n            successfulMessages[xDomainCalldataHash] = true;\\n            emit RelayedMessage(xDomainCalldataHash);\\n        } else {\\n            failedMessages[xDomainCalldataHash] == true;\\n            emit FailedRelayedMessage(xDomainCalldataHash);\\n        }\\n\\n        // Store an identifier that can be used to prove that the given message was relayed by some\\n        // user. Gives us an easy way to pay relayers for their work.\\n        bytes32 relayId = keccak256(\\n            abi.encodePacked(\\n                xDomainCalldata,\\n                msg.sender,\\n                block.number\\n            )\\n        );\\n        relayedMessages[relayId] = true;\\n    }\\n\\n    /**\\n     * Replays a cross domain message to the target messenger.\\n     * @inheritdoc IL1CrossDomainMessenger\\n     */\\n    function replayMessage(\\n        address _target,\\n        address _sender,\\n        bytes memory _message,\\n        uint256 _queueIndex,\\n        uint32 _oldGasLimit,\\n        uint32 _newGasLimit\\n    )\\n        override\\n        public\\n    {\\n        // Verify that the message is in the queue:\\n        address canonicalTransactionChain = resolve(\\\"CanonicalTransactionChain\\\");\\n        Lib_OVMCodec.QueueElement memory element =\\n            ICanonicalTransactionChain(canonicalTransactionChain).getQueueElement(_queueIndex);\\n\\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\\n            _target,\\n            _sender,\\n            _message,\\n            _queueIndex\\n        );\\n        \\n        // Compute the transactionHash\\n        bytes32 transactionHash = keccak256(\\n            abi.encode(\\n                AddressAliasHelper.applyL1ToL2Alias(address(this)),\\n                Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,\\n                _oldGasLimit,\\n                _message\\n            )\\n        );\\n\\n        require(\\n            transactionHash == element.transactionHash,\\n            \\\"Provided message has not been enqueued.\\\"\\n        );\\n\\n        _sendXDomainMessage(\\n            canonicalTransactionChain,\\n            xDomainCalldata,\\n            _newGasLimit\\n        );\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Verifies that the given message is valid.\\n     * @param _xDomainCalldata Calldata to verify.\\n     * @param _proof Inclusion proof for the message.\\n     * @return Whether or not the provided message is valid.\\n     */\\n    function _verifyXDomainMessage(\\n        bytes memory _xDomainCalldata,\\n        L2MessageInclusionProof memory _proof\\n    )\\n        internal\\n        view\\n        returns (\\n            bool\\n        )\\n    {\\n        return (\\n            _verifyStateRootProof(_proof)\\n            && _verifyStorageProof(_xDomainCalldata, _proof)\\n        );\\n    }\\n\\n    /**\\n     * Verifies that the state root within an inclusion proof is valid.\\n     * @param _proof Message inclusion proof.\\n     * @return Whether or not the provided proof is valid.\\n     */\\n    function _verifyStateRootProof(\\n        L2MessageInclusionProof memory _proof\\n    )\\n        internal\\n        view\\n        returns (\\n            bool\\n        )\\n    {\\n        IStateCommitmentChain ovmStateCommitmentChain = IStateCommitmentChain(\\n            resolve(\\\"StateCommitmentChain\\\")\\n        );\\n\\n        return (\\n            ovmStateCommitmentChain.verifyStateCommitment(\\n                _proof.stateRoot,\\n                _proof.stateRootBatchHeader,\\n                _proof.stateRootProof\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Verifies that the storage proof within an inclusion proof is valid.\\n     * @param _xDomainCalldata Encoded message calldata.\\n     * @param _proof Message inclusion proof.\\n     * @return Whether or not the provided proof is valid.\\n     */\\n    function _verifyStorageProof(\\n        bytes memory _xDomainCalldata,\\n        L2MessageInclusionProof memory _proof\\n    )\\n        internal\\n        view\\n        returns (\\n            bool\\n        )\\n    {\\n        bytes32 storageKey = keccak256(\\n            abi.encodePacked(\\n                keccak256(\\n                    abi.encodePacked(\\n                        _xDomainCalldata,\\n                        Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER\\n                    )\\n                ),\\n                uint256(0)\\n            )\\n        );\\n\\n        (\\n            bool exists,\\n            bytes memory encodedMessagePassingAccount\\n        ) = Lib_SecureMerkleTrie.get(\\n            abi.encodePacked(Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER),\\n            _proof.stateTrieWitness,\\n            _proof.stateRoot\\n        );\\n\\n        require(\\n            exists == true,\\n            \\\"Message passing predeploy has not been initialized or invalid proof provided.\\\"\\n        );\\n\\n        Lib_OVMCodec.EVMAccount memory account = Lib_OVMCodec.decodeEVMAccount(\\n            encodedMessagePassingAccount\\n        );\\n\\n        return Lib_SecureMerkleTrie.verifyInclusionProof(\\n            abi.encodePacked(storageKey),\\n            abi.encodePacked(uint8(1)),\\n            _proof.storageTrieWitness,\\n            account.storageRoot\\n        );\\n    }\\n\\n    /**\\n     * Sends a cross domain message.\\n     * @param _canonicalTransactionChain Address of the CanonicalTransactionChain instance.\\n     * @param _message Message to send.\\n     * @param _gasLimit OVM gas limit for the message.\\n     */\\n    function _sendXDomainMessage(\\n        address _canonicalTransactionChain,\\n        bytes memory _message,\\n        uint256 _gasLimit\\n    )\\n        internal\\n    {\\n        revert(\\\"Sending via this messenger is disabled\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/standards/AddressAliasHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.7;\\n\\nlibrary AddressAliasHelper {\\n  uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\\n\\n  /// @notice Utility function that converts the address in the L1 that submitted a tx to\\n  /// the inbox to the msg.sender viewed in the L2\\n  /// @param l1Address the address in the L1 that triggered the tx to L2\\n  /// @return l2Address L2 address as viewed in msg.sender\\n  function applyL1ToL2Alias(address l1Address)\\n    internal\\n    pure\\n    returns (address l2Address)\\n  {\\n    unchecked {\\n      l2Address = address(uint160(l1Address) + offset);\\n    }\\n  }\\n\\n  /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n  /// address in the L1 that submitted a tx to the inbox\\n  /// @param l2Address L2 address as viewed in msg.sender\\n  /// @return l1Address the address in the L1 that triggered the tx to L2\\n  function undoL1ToL2Alias(address l2Address)\\n    internal\\n    pure\\n    returns (address l1Address)\\n  {\\n    unchecked {\\n      l1Address = address(uint160(l2Address) - offset);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/libraries/resolver/Lib_AddressResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport {Lib_AddressManager} from './Lib_AddressManager.sol';\\n\\n/**\\n * @title Lib_AddressResolver\\n */\\nabstract contract Lib_AddressResolver {\\n  /*************\\n   * Variables *\\n   *************/\\n\\n  Lib_AddressManager public libAddressManager;\\n\\n  /***************\\n   * Constructor *\\n   ***************/\\n\\n  /**\\n   * @param _libAddressManager Address of the Lib_AddressManager.\\n   */\\n  constructor(address _libAddressManager) {\\n    libAddressManager = Lib_AddressManager(_libAddressManager);\\n  }\\n\\n  /********************\\n   * Public Functions *\\n   ********************/\\n\\n  /**\\n   * Resolves the address associated with a given name.\\n   * @param _name Name to resolve an address for.\\n   * @return Address associated with the given name.\\n   */\\n  function resolve(string memory _name) public view returns (address) {\\n    return libAddressManager.getAddress(_name);\\n  }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/libraries/codec/Lib_OVMCodec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport {Lib_RLPReader} from '../rlp/Lib_RLPReader.sol';\\nimport {Lib_RLPWriter} from '../rlp/Lib_RLPWriter.sol';\\nimport {Lib_BytesUtils} from '../utils/Lib_BytesUtils.sol';\\nimport {Lib_Bytes32Utils} from '../utils/Lib_Bytes32Utils.sol';\\n\\n/**\\n * @title Lib_OVMCodec\\n */\\nlibrary Lib_OVMCodec {\\n  /*********\\n   * Enums *\\n   *********/\\n\\n  enum QueueOrigin {\\n    SEQUENCER_QUEUE,\\n    L1TOL2_QUEUE\\n  }\\n\\n  /***********\\n   * Structs *\\n   ***********/\\n\\n  struct EVMAccount {\\n    uint256 nonce;\\n    uint256 balance;\\n    bytes32 storageRoot;\\n    bytes32 codeHash;\\n  }\\n\\n  struct ChainBatchHeader {\\n    uint256 batchIndex;\\n    bytes32 batchRoot;\\n    uint256 batchSize;\\n    uint256 prevTotalElements;\\n    bytes extraData;\\n  }\\n\\n  struct ChainInclusionProof {\\n    uint256 index;\\n    bytes32[] siblings;\\n  }\\n\\n  struct Transaction {\\n    uint256 timestamp;\\n    uint256 blockNumber;\\n    QueueOrigin l1QueueOrigin;\\n    address l1TxOrigin;\\n    address entrypoint;\\n    uint256 gasLimit;\\n    bytes data;\\n  }\\n\\n  struct TransactionChainElement {\\n    bool isSequenced;\\n    uint256 queueIndex; // QUEUED TX ONLY\\n    uint256 timestamp; // SEQUENCER TX ONLY\\n    uint256 blockNumber; // SEQUENCER TX ONLY\\n    bytes txData; // SEQUENCER TX ONLY\\n  }\\n\\n  struct QueueElement {\\n    bytes32 transactionHash;\\n    uint40 timestamp;\\n    uint40 blockNumber;\\n  }\\n\\n  /**********************\\n   * Internal Functions *\\n   **********************/\\n\\n  /**\\n   * Encodes a standard OVM transaction.\\n   * @param _transaction OVM transaction to encode.\\n   * @return Encoded transaction bytes.\\n   */\\n  function encodeTransaction(Transaction memory _transaction)\\n    internal\\n    pure\\n    returns (bytes memory)\\n  {\\n    return\\n      abi.encodePacked(\\n        _transaction.timestamp,\\n        _transaction.blockNumber,\\n        _transaction.l1QueueOrigin,\\n        _transaction.l1TxOrigin,\\n        _transaction.entrypoint,\\n        _transaction.gasLimit,\\n        _transaction.data\\n      );\\n  }\\n\\n  /**\\n   * Hashes a standard OVM transaction.\\n   * @param _transaction OVM transaction to encode.\\n   * @return Hashed transaction\\n   */\\n  function hashTransaction(Transaction memory _transaction)\\n    internal\\n    pure\\n    returns (bytes32)\\n  {\\n    return keccak256(encodeTransaction(_transaction));\\n  }\\n\\n  /**\\n   * @notice Decodes an RLP-encoded account state into a useful struct.\\n   * @param _encoded RLP-encoded account state.\\n   * @return Account state struct.\\n   */\\n  function decodeEVMAccount(bytes memory _encoded)\\n    internal\\n    pure\\n    returns (EVMAccount memory)\\n  {\\n    Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(\\n      _encoded\\n    );\\n\\n    return\\n      EVMAccount({\\n        nonce: Lib_RLPReader.readUint256(accountState[0]),\\n        balance: Lib_RLPReader.readUint256(accountState[1]),\\n        storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\\n        codeHash: Lib_RLPReader.readBytes32(accountState[3])\\n      });\\n  }\\n\\n  /**\\n   * Calculates a hash for a given batch header.\\n   * @param _batchHeader Header to hash.\\n   * @return Hash of the header.\\n   */\\n  function hashBatchHeader(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\\n    internal\\n    pure\\n    returns (bytes32)\\n  {\\n    return\\n      keccak256(\\n        abi.encode(\\n          _batchHeader.batchRoot,\\n          _batchHeader.batchSize,\\n          _batchHeader.prevTotalElements,\\n          _batchHeader.extraData\\n        )\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/libraries/resolver/Lib_AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* External Imports */\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n  /**********\\n   * Events *\\n   **********/\\n\\n  event AddressSet(\\n    string indexed _name,\\n    address _newAddress,\\n    address _oldAddress\\n  );\\n\\n  /*************\\n   * Variables *\\n   *************/\\n\\n  mapping(bytes32 => address) private addresses;\\n\\n  /********************\\n   * Public Functions *\\n   ********************/\\n\\n  /**\\n   * Changes the address associated with a particular name.\\n   * @param _name String name to associate an address with.\\n   * @param _address Address to associate with the name.\\n   */\\n  function setAddress(string memory _name, address _address)\\n    external\\n    onlyOwner\\n  {\\n    bytes32 nameHash = _getNameHash(_name);\\n    address oldAddress = addresses[nameHash];\\n    addresses[nameHash] = _address;\\n\\n    emit AddressSet(_name, _address, oldAddress);\\n  }\\n\\n  /**\\n   * Retrieves the address associated with a given name.\\n   * @param _name Name to retrieve an address for.\\n   * @return Address associated with the given name.\\n   */\\n  function getAddress(string memory _name) external view returns (address) {\\n    return addresses[_getNameHash(_name)];\\n  }\\n\\n  /**********************\\n   * Internal Functions *\\n   **********************/\\n\\n  /**\\n   * Computes the hash of a name.\\n   * @param _name Name to compute a hash for.\\n   * @return Hash of the given name.\\n   */\\n  function _getNameHash(string memory _name) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(_name));\\n  }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/libraries/trie/Lib_SecureMerkleTrie.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport {Lib_MerkleTrie} from './Lib_MerkleTrie.sol';\\n\\n/**\\n * @title Lib_SecureMerkleTrie\\n */\\nlibrary Lib_SecureMerkleTrie {\\n  /**********************\\n   * Internal Functions *\\n   **********************/\\n\\n  /**\\n   * @notice Verifies a proof that a given key/value pair is present in the\\n   * Merkle trie.\\n   * @param _key Key of the node to search for, as a hex string.\\n   * @param _value Value of the node to search for, as a hex string.\\n   * @param _proof Merkle trie inclusion proof for the desired node. Unlike\\n   * traditional Merkle trees, this proof is executed top-down and consists\\n   * of a list of RLP-encoded nodes that make a path down to the target node.\\n   * @param _root Known root of the Merkle trie. Used to verify that the\\n   * included proof is correctly constructed.\\n   * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\\n   */\\n  function verifyInclusionProof(\\n    bytes memory _key,\\n    bytes memory _value,\\n    bytes memory _proof,\\n    bytes32 _root\\n  ) internal pure returns (bool _verified) {\\n    bytes memory key = _getSecureKey(_key);\\n    return Lib_MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\\n  }\\n\\n  /**\\n   * @notice Updates a Merkle trie and returns a new root hash.\\n   * @param _key Key of the node to update, as a hex string.\\n   * @param _value Value of the node to update, as a hex string.\\n   * @param _proof Merkle trie inclusion proof for the node *nearest* the\\n   * target node. If the key exists, we can simply update the value.\\n   * Otherwise, we need to modify the trie to handle the new k/v pair.\\n   * @param _root Known root of the Merkle trie. Used to verify that the\\n   * included proof is correctly constructed.\\n   * @return _updatedRoot Root hash of the newly constructed trie.\\n   */\\n  function update(\\n    bytes memory _key,\\n    bytes memory _value,\\n    bytes memory _proof,\\n    bytes32 _root\\n  ) internal pure returns (bytes32 _updatedRoot) {\\n    bytes memory key = _getSecureKey(_key);\\n    return Lib_MerkleTrie.update(key, _value, _proof, _root);\\n  }\\n\\n  /**\\n   * @notice Retrieves the value associated with a given key.\\n   * @param _key Key to search for, as hex bytes.\\n   * @param _proof Merkle trie inclusion proof for the key.\\n   * @param _root Known root of the Merkle trie.\\n   * @return _exists Whether or not the key exists.\\n   * @return _value Value of the key if it exists.\\n   */\\n  function get(\\n    bytes memory _key,\\n    bytes memory _proof,\\n    bytes32 _root\\n  ) internal pure returns (bool _exists, bytes memory _value) {\\n    bytes memory key = _getSecureKey(_key);\\n    return Lib_MerkleTrie.get(key, _proof, _root);\\n  }\\n\\n  /**\\n   * Computes the root hash for a trie with a single node.\\n   * @param _key Key for the single node.\\n   * @param _value Value for the single node.\\n   * @return _updatedRoot Hash of the trie.\\n   */\\n  function getSingleNodeRootHash(bytes memory _key, bytes memory _value)\\n    internal\\n    pure\\n    returns (bytes32 _updatedRoot)\\n  {\\n    bytes memory key = _getSecureKey(_key);\\n    return Lib_MerkleTrie.getSingleNodeRootHash(key, _value);\\n  }\\n\\n  /*********************\\n   * Private Functions *\\n   *********************/\\n\\n  /**\\n   * Computes the secure counterpart to a key.\\n   * @param _key Key to get a secure key from.\\n   * @return _secureKey Secure version of the key.\\n   */\\n  function _getSecureKey(bytes memory _key)\\n    private\\n    pure\\n    returns (bytes memory _secureKey)\\n  {\\n    return abi.encodePacked(keccak256(_key));\\n  }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/libraries/constants/Lib_DefaultValues.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_DefaultValues\\n */\\nlibrary Lib_DefaultValues {\\n  // The default x-domain message sender being set to a non-zero value makes\\n  // deployment a bit more expensive, but in exchange the refund on every call to\\n  // `relayMessage` by the L1 and L2 messengers will be higher.\\n  address internal constant DEFAULT_XDOMAIN_SENDER =\\n    0x000000000000000000000000000000000000dEaD;\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/libraries/constants/Lib_PredeployAddresses.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_PredeployAddresses\\n */\\nlibrary Lib_PredeployAddresses {\\n  // solhint-disable max-line-length\\n  address internal constant L2_TO_L1_MESSAGE_PASSER =\\n    0x4200000000000000000000000000000000000000;\\n  address internal constant L1_MESSAGE_SENDER =\\n    0x4200000000000000000000000000000000000001;\\n  address internal constant DEPLOYER_WHITELIST =\\n    0x4200000000000000000000000000000000000002;\\n  address payable internal constant OVM_ETH =\\n    payable(0x4200000000000000000000000000000000000006);\\n  // solhint-disable-next-line max-line-length\\n  address internal constant L2_CROSS_DOMAIN_MESSENGER =\\n    0x4200000000000000000000000000000000000007;\\n  address internal constant LIB_ADDRESS_MANAGER =\\n    0x4200000000000000000000000000000000000008;\\n  address internal constant PROXY_EOA =\\n    0x4200000000000000000000000000000000000009;\\n  address internal constant L2_STANDARD_BRIDGE =\\n    0x4200000000000000000000000000000000000010;\\n  address internal constant SEQUENCER_FEE_WALLET =\\n    0x4200000000000000000000000000000000000011;\\n  address internal constant L2_STANDARD_TOKEN_FACTORY =\\n    0x4200000000000000000000000000000000000012;\\n  address internal constant L1_BLOCK_NUMBER =\\n    0x4200000000000000000000000000000000000013;\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/libraries/bridge/Lib_CrossDomainUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport {Lib_RLPReader} from '../rlp/Lib_RLPReader.sol';\\n\\n/**\\n * @title Lib_CrossDomainUtils\\n */\\nlibrary Lib_CrossDomainUtils {\\n  /**\\n   * Generates the correct cross domain calldata for a message.\\n   * @param _target Target contract address.\\n   * @param _sender Message sender address.\\n   * @param _message Message to send to the target.\\n   * @param _messageNonce Nonce for the provided message.\\n   * @return ABI encoded cross domain calldata.\\n   */\\n  function encodeXDomainCalldata(\\n    address _target,\\n    address _sender,\\n    bytes memory _message,\\n    uint256 _messageNonce\\n  ) internal pure returns (bytes memory) {\\n    return\\n      abi.encodeWithSignature(\\n        'relayMessage(address,address,bytes,uint256)',\\n        _target,\\n        _sender,\\n        _message,\\n        _messageNonce\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/L1/messaging/IL1CrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport {Lib_OVMCodec} from '../../libraries/codec/Lib_OVMCodec.sol';\\n\\n/* Interface Imports */\\nimport {ICrossDomainMessenger} from '../../libraries/bridge/ICrossDomainMessenger.sol';\\n\\n/**\\n * @title IL1CrossDomainMessenger\\n */\\ninterface IL1CrossDomainMessenger is ICrossDomainMessenger {\\n  /*******************\\n   * Data Structures *\\n   *******************/\\n\\n  struct L2MessageInclusionProof {\\n    bytes32 stateRoot;\\n    Lib_OVMCodec.ChainBatchHeader stateRootBatchHeader;\\n    Lib_OVMCodec.ChainInclusionProof stateRootProof;\\n    bytes stateTrieWitness;\\n    bytes storageTrieWitness;\\n  }\\n\\n  /********************\\n   * Public Functions *\\n   ********************/\\n\\n  /**\\n   * Relays a cross domain message to a contract.\\n   * @param _target Target contract address.\\n   * @param _sender Message sender address.\\n   * @param _message Message to send to the target.\\n   * @param _messageNonce Nonce for the provided message.\\n   * @param _proof Inclusion proof for the given message.\\n   */\\n  function relayMessage(\\n    address _target,\\n    address _sender,\\n    bytes memory _message,\\n    uint256 _messageNonce,\\n    L2MessageInclusionProof memory _proof\\n  ) external;\\n\\n  /**\\n   * Replays a cross domain message to the target messenger.\\n   * @param _target Target contract address.\\n   * @param _sender Original sender address.\\n   * @param _message Message to send to the target.\\n   * @param _queueIndex CTC Queue index for the message to replay.\\n   * @param _oldGasLimit Original gas limit used to send the message.\\n   * @param _newGasLimit New gas limit to be used for this message.\\n   */\\n  function replayMessage(\\n    address _target,\\n    address _sender,\\n    bytes memory _message,\\n    uint256 _queueIndex,\\n    uint32 _oldGasLimit,\\n    uint32 _newGasLimit\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/L1/rollup/ICanonicalTransactionChain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/* Library Imports */\\nimport {Lib_OVMCodec} from '../../libraries/codec/Lib_OVMCodec.sol';\\n\\n/* Interface Imports */\\nimport {IChainStorageContainer} from './IChainStorageContainer.sol';\\n\\n/**\\n * @title ICanonicalTransactionChain\\n */\\ninterface ICanonicalTransactionChain {\\n  /**********\\n   * Events *\\n   **********/\\n\\n  event L2GasParamsUpdated(\\n    uint256 l2GasDiscountDivisor,\\n    uint256 enqueueGasCost,\\n    uint256 enqueueL2GasPrepaid\\n  );\\n\\n  event TransactionEnqueued(\\n    address indexed _l1TxOrigin,\\n    address indexed _target,\\n    uint256 _gasLimit,\\n    bytes _data,\\n    uint256 indexed _queueIndex,\\n    uint256 _timestamp\\n  );\\n\\n  event QueueBatchAppended(\\n    uint256 _startingQueueIndex,\\n    uint256 _numQueueElements,\\n    uint256 _totalElements\\n  );\\n\\n  event SequencerBatchAppended(\\n    uint256 _startingQueueIndex,\\n    uint256 _numQueueElements,\\n    uint256 _totalElements\\n  );\\n\\n  event TransactionBatchAppended(\\n    uint256 indexed _batchIndex,\\n    bytes32 _batchRoot,\\n    uint256 _batchSize,\\n    uint256 _prevTotalElements,\\n    bytes _extraData\\n  );\\n\\n  /***********\\n   * Structs *\\n   ***********/\\n\\n  struct BatchContext {\\n    uint256 numSequencedTransactions;\\n    uint256 numSubsequentQueueTransactions;\\n    uint256 timestamp;\\n    uint256 blockNumber;\\n  }\\n\\n  /*******************************\\n   * Authorized Setter Functions *\\n   *******************************/\\n\\n  /**\\n   * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.\\n   * The value of enqueueL2GasPrepaid is immediately updated as well.\\n   */\\n  function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost)\\n    external;\\n\\n  /********************\\n   * Public Functions *\\n   ********************/\\n\\n  /**\\n   * Accesses the batch storage container.\\n   * @return Reference to the batch storage container.\\n   */\\n  function batches() external view returns (IChainStorageContainer);\\n\\n  /**\\n   * Accesses the queue storage container.\\n   * @return Reference to the queue storage container.\\n   */\\n  function queue() external view returns (IChainStorageContainer);\\n\\n  /**\\n   * Retrieves the total number of elements submitted.\\n   * @return _totalElements Total submitted elements.\\n   */\\n  function getTotalElements() external view returns (uint256 _totalElements);\\n\\n  /**\\n   * Retrieves the total number of batches submitted.\\n   * @return _totalBatches Total submitted batches.\\n   */\\n  function getTotalBatches() external view returns (uint256 _totalBatches);\\n\\n  /**\\n   * Returns the index of the next element to be enqueued.\\n   * @return Index for the next queue element.\\n   */\\n  function getNextQueueIndex() external view returns (uint40);\\n\\n  /**\\n   * Gets the queue element at a particular index.\\n   * @param _index Index of the queue element to access.\\n   * @return _element Queue element at the given index.\\n   */\\n  function getQueueElement(uint256 _index)\\n    external\\n    view\\n    returns (Lib_OVMCodec.QueueElement memory _element);\\n\\n  /**\\n   * Returns the timestamp of the last transaction.\\n   * @return Timestamp for the last transaction.\\n   */\\n  function getLastTimestamp() external view returns (uint40);\\n\\n  /**\\n   * Returns the blocknumber of the last transaction.\\n   * @return Blocknumber for the last transaction.\\n   */\\n  function getLastBlockNumber() external view returns (uint40);\\n\\n  /**\\n   * Get the number of queue elements which have not yet been included.\\n   * @return Number of pending queue elements.\\n   */\\n  function getNumPendingQueueElements() external view returns (uint40);\\n\\n  /**\\n   * Retrieves the length of the queue, including\\n   * both pending and canonical transactions.\\n   * @return Length of the queue.\\n   */\\n  function getQueueLength() external view returns (uint40);\\n\\n  /**\\n   * Adds a transaction to the queue.\\n   * @param _target Target contract to send the transaction to.\\n   * @param _gasLimit Gas limit for the given transaction.\\n   * @param _data Transaction data.\\n   */\\n  function enqueue(\\n    address _target,\\n    uint256 _gasLimit,\\n    bytes memory _data\\n  ) external;\\n\\n  /**\\n   * Allows the sequencer to append a batch of transactions.\\n   * @dev This function uses a custom encoding scheme for efficiency reasons.\\n   * .param _shouldStartAtElement Specific batch we expect to start appending to.\\n   * .param _totalElementsToAppend Total number of batch elements we expect to append.\\n   * .param _contexts Array of batch contexts.\\n   * .param _transactionDataFields Array of raw transaction data.\\n   */\\n  function appendSequencerBatch(\\n    // uint40 _shouldStartAtElement,\\n    // uint24 _totalElementsToAppend,\\n    // BatchContext[] _contexts,\\n    // bytes[] _transactionDataFields\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/L1/rollup/IStateCommitmentChain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/* Library Imports */\\nimport {Lib_OVMCodec} from '../../libraries/codec/Lib_OVMCodec.sol';\\n\\n/**\\n * @title IStateCommitmentChain\\n */\\ninterface IStateCommitmentChain {\\n  /**********\\n   * Events *\\n   **********/\\n\\n  event StateBatchAppended(\\n    uint256 indexed _batchIndex,\\n    bytes32 _batchRoot,\\n    uint256 _batchSize,\\n    uint256 _prevTotalElements,\\n    bytes _extraData\\n  );\\n\\n  event StateBatchDeleted(uint256 indexed _batchIndex, bytes32 _batchRoot);\\n\\n  /********************\\n   * Public Functions *\\n   ********************/\\n\\n  /**\\n   * Retrieves the total number of elements submitted.\\n   * @return _totalElements Total submitted elements.\\n   */\\n  function getTotalElements() external view returns (uint256 _totalElements);\\n\\n  /**\\n   * Retrieves the total number of batches submitted.\\n   * @return _totalBatches Total submitted batches.\\n   */\\n  function getTotalBatches() external view returns (uint256 _totalBatches);\\n\\n  /**\\n   * Retrieves the timestamp of the last batch submitted by the sequencer.\\n   * @return _lastSequencerTimestamp Last sequencer batch timestamp.\\n   */\\n  function getLastSequencerTimestamp()\\n    external\\n    view\\n    returns (uint256 _lastSequencerTimestamp);\\n\\n  /**\\n   * Appends a batch of state roots to the chain.\\n   * @param _batch Batch of state roots.\\n   * @param _shouldStartAtElement Index of the element at which this batch should start.\\n   */\\n  function appendStateBatch(\\n    bytes32[] calldata _batch,\\n    uint256 _shouldStartAtElement\\n  ) external;\\n\\n  /**\\n   * Deletes all state roots after (and including) a given batch.\\n   * @param _batchHeader Header of the batch to start deleting from.\\n   */\\n  function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\\n    external;\\n\\n  /**\\n   * Verifies a batch inclusion proof.\\n   * @param _element Hash of the element to verify a proof for.\\n   * @param _batchHeader Header of the batch in which the element was included.\\n   * @param _proof Merkle inclusion proof for the element.\\n   */\\n  function verifyStateCommitment(\\n    bytes32 _element,\\n    Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\\n    Lib_OVMCodec.ChainInclusionProof memory _proof\\n  ) external view returns (bool _verified);\\n\\n  /**\\n   * Checks whether a given batch is still inside its fraud proof window.\\n   * @param _batchHeader Header of the batch to check.\\n   * @return _inside Whether or not the batch is inside the fraud proof window.\\n   */\\n  function insideFraudProofWindow(\\n    Lib_OVMCodec.ChainBatchHeader memory _batchHeader\\n  ) external view returns (bool _inside);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal initializer {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal initializer {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal initializer {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/libraries/rlp/Lib_RLPReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_RLPReader\\n * @dev Adapted from \\\"RLPReader\\\" by Hamdi Allam (hamdi.allam97@gmail.com).\\n */\\nlibrary Lib_RLPReader {\\n  /*************\\n   * Constants *\\n   *************/\\n\\n  uint256 internal constant MAX_LIST_LENGTH = 32;\\n\\n  /*********\\n   * Enums *\\n   *********/\\n\\n  enum RLPItemType {\\n    DATA_ITEM,\\n    LIST_ITEM\\n  }\\n\\n  /***********\\n   * Structs *\\n   ***********/\\n\\n  struct RLPItem {\\n    uint256 length;\\n    uint256 ptr;\\n  }\\n\\n  /**********************\\n   * Internal Functions *\\n   **********************/\\n\\n  /**\\n   * Converts bytes to a reference to memory position and length.\\n   * @param _in Input bytes to convert.\\n   * @return Output memory reference.\\n   */\\n  function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\\n    uint256 ptr;\\n    assembly {\\n      ptr := add(_in, 32)\\n    }\\n\\n    return RLPItem({length: _in.length, ptr: ptr});\\n  }\\n\\n  /**\\n   * Reads an RLP list value into a list of RLP items.\\n   * @param _in RLP list value.\\n   * @return Decoded RLP list items.\\n   */\\n  function readList(RLPItem memory _in)\\n    internal\\n    pure\\n    returns (RLPItem[] memory)\\n  {\\n    (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\\n\\n    require(itemType == RLPItemType.LIST_ITEM, 'Invalid RLP list value.');\\n\\n    // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n    // writing to the length. Since we can't know the number of RLP items without looping over\\n    // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n    // simply set a reasonable maximum list length and decrease the size before we finish.\\n    RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\\n\\n    uint256 itemCount = 0;\\n    uint256 offset = listOffset;\\n    while (offset < _in.length) {\\n      require(\\n        itemCount < MAX_LIST_LENGTH,\\n        'Provided RLP list exceeds max list length.'\\n      );\\n\\n      (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\\n        RLPItem({length: _in.length - offset, ptr: _in.ptr + offset})\\n      );\\n\\n      out[itemCount] = RLPItem({\\n        length: itemLength + itemOffset,\\n        ptr: _in.ptr + offset\\n      });\\n\\n      itemCount += 1;\\n      offset += itemOffset + itemLength;\\n    }\\n\\n    // Decrease the array size to match the actual item count.\\n    assembly {\\n      mstore(out, itemCount)\\n    }\\n\\n    return out;\\n  }\\n\\n  /**\\n   * Reads an RLP list value into a list of RLP items.\\n   * @param _in RLP list value.\\n   * @return Decoded RLP list items.\\n   */\\n  function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\\n    return readList(toRLPItem(_in));\\n  }\\n\\n  /**\\n   * Reads an RLP bytes value into bytes.\\n   * @param _in RLP bytes value.\\n   * @return Decoded bytes.\\n   */\\n  function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\\n    (\\n      uint256 itemOffset,\\n      uint256 itemLength,\\n      RLPItemType itemType\\n    ) = _decodeLength(_in);\\n\\n    require(itemType == RLPItemType.DATA_ITEM, 'Invalid RLP bytes value.');\\n\\n    return _copy(_in.ptr, itemOffset, itemLength);\\n  }\\n\\n  /**\\n   * Reads an RLP bytes value into bytes.\\n   * @param _in RLP bytes value.\\n   * @return Decoded bytes.\\n   */\\n  function readBytes(bytes memory _in) internal pure returns (bytes memory) {\\n    return readBytes(toRLPItem(_in));\\n  }\\n\\n  /**\\n   * Reads an RLP string value into a string.\\n   * @param _in RLP string value.\\n   * @return Decoded string.\\n   */\\n  function readString(RLPItem memory _in)\\n    internal\\n    pure\\n    returns (string memory)\\n  {\\n    return string(readBytes(_in));\\n  }\\n\\n  /**\\n   * Reads an RLP string value into a string.\\n   * @param _in RLP string value.\\n   * @return Decoded string.\\n   */\\n  function readString(bytes memory _in) internal pure returns (string memory) {\\n    return readString(toRLPItem(_in));\\n  }\\n\\n  /**\\n   * Reads an RLP bytes32 value into a bytes32.\\n   * @param _in RLP bytes32 value.\\n   * @return Decoded bytes32.\\n   */\\n  function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\\n    require(_in.length <= 33, 'Invalid RLP bytes32 value.');\\n\\n    (\\n      uint256 itemOffset,\\n      uint256 itemLength,\\n      RLPItemType itemType\\n    ) = _decodeLength(_in);\\n\\n    require(itemType == RLPItemType.DATA_ITEM, 'Invalid RLP bytes32 value.');\\n\\n    uint256 ptr = _in.ptr + itemOffset;\\n    bytes32 out;\\n    assembly {\\n      out := mload(ptr)\\n\\n      // Shift the bytes over to match the item size.\\n      if lt(itemLength, 32) {\\n        out := div(out, exp(256, sub(32, itemLength)))\\n      }\\n    }\\n\\n    return out;\\n  }\\n\\n  /**\\n   * Reads an RLP bytes32 value into a bytes32.\\n   * @param _in RLP bytes32 value.\\n   * @return Decoded bytes32.\\n   */\\n  function readBytes32(bytes memory _in) internal pure returns (bytes32) {\\n    return readBytes32(toRLPItem(_in));\\n  }\\n\\n  /**\\n   * Reads an RLP uint256 value into a uint256.\\n   * @param _in RLP uint256 value.\\n   * @return Decoded uint256.\\n   */\\n  function readUint256(RLPItem memory _in) internal pure returns (uint256) {\\n    return uint256(readBytes32(_in));\\n  }\\n\\n  /**\\n   * Reads an RLP uint256 value into a uint256.\\n   * @param _in RLP uint256 value.\\n   * @return Decoded uint256.\\n   */\\n  function readUint256(bytes memory _in) internal pure returns (uint256) {\\n    return readUint256(toRLPItem(_in));\\n  }\\n\\n  /**\\n   * Reads an RLP bool value into a bool.\\n   * @param _in RLP bool value.\\n   * @return Decoded bool.\\n   */\\n  function readBool(RLPItem memory _in) internal pure returns (bool) {\\n    require(_in.length == 1, 'Invalid RLP boolean value.');\\n\\n    uint256 ptr = _in.ptr;\\n    uint256 out;\\n    assembly {\\n      out := byte(0, mload(ptr))\\n    }\\n\\n    require(\\n      out == 0 || out == 1,\\n      'Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1'\\n    );\\n\\n    return out != 0;\\n  }\\n\\n  /**\\n   * Reads an RLP bool value into a bool.\\n   * @param _in RLP bool value.\\n   * @return Decoded bool.\\n   */\\n  function readBool(bytes memory _in) internal pure returns (bool) {\\n    return readBool(toRLPItem(_in));\\n  }\\n\\n  /**\\n   * Reads an RLP address value into a address.\\n   * @param _in RLP address value.\\n   * @return Decoded address.\\n   */\\n  function readAddress(RLPItem memory _in) internal pure returns (address) {\\n    if (_in.length == 1) {\\n      return address(0);\\n    }\\n\\n    require(_in.length == 21, 'Invalid RLP address value.');\\n\\n    return address(uint160(readUint256(_in)));\\n  }\\n\\n  /**\\n   * Reads an RLP address value into a address.\\n   * @param _in RLP address value.\\n   * @return Decoded address.\\n   */\\n  function readAddress(bytes memory _in) internal pure returns (address) {\\n    return readAddress(toRLPItem(_in));\\n  }\\n\\n  /**\\n   * Reads the raw bytes of an RLP item.\\n   * @param _in RLP item to read.\\n   * @return Raw RLP bytes.\\n   */\\n  function readRawBytes(RLPItem memory _in)\\n    internal\\n    pure\\n    returns (bytes memory)\\n  {\\n    return _copy(_in);\\n  }\\n\\n  /*********************\\n   * Private Functions *\\n   *********************/\\n\\n  /**\\n   * Decodes the length of an RLP item.\\n   * @param _in RLP item to decode.\\n   * @return Offset of the encoded data.\\n   * @return Length of the encoded data.\\n   * @return RLP item type (LIST_ITEM or DATA_ITEM).\\n   */\\n  function _decodeLength(RLPItem memory _in)\\n    private\\n    pure\\n    returns (\\n      uint256,\\n      uint256,\\n      RLPItemType\\n    )\\n  {\\n    require(_in.length > 0, 'RLP item cannot be null.');\\n\\n    uint256 ptr = _in.ptr;\\n    uint256 prefix;\\n    assembly {\\n      prefix := byte(0, mload(ptr))\\n    }\\n\\n    if (prefix <= 0x7f) {\\n      // Single byte.\\n\\n      return (0, 1, RLPItemType.DATA_ITEM);\\n    } else if (prefix <= 0xb7) {\\n      // Short string.\\n\\n      uint256 strLen = prefix - 0x80;\\n\\n      require(_in.length > strLen, 'Invalid RLP short string.');\\n\\n      return (1, strLen, RLPItemType.DATA_ITEM);\\n    } else if (prefix <= 0xbf) {\\n      // Long string.\\n      uint256 lenOfStrLen = prefix - 0xb7;\\n\\n      require(_in.length > lenOfStrLen, 'Invalid RLP long string length.');\\n\\n      uint256 strLen;\\n      assembly {\\n        // Pick out the string length.\\n        strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\\n      }\\n\\n      require(_in.length > lenOfStrLen + strLen, 'Invalid RLP long string.');\\n\\n      return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n    } else if (prefix <= 0xf7) {\\n      // Short list.\\n      uint256 listLen = prefix - 0xc0;\\n\\n      require(_in.length > listLen, 'Invalid RLP short list.');\\n\\n      return (1, listLen, RLPItemType.LIST_ITEM);\\n    } else {\\n      // Long list.\\n      uint256 lenOfListLen = prefix - 0xf7;\\n\\n      require(_in.length > lenOfListLen, 'Invalid RLP long list length.');\\n\\n      uint256 listLen;\\n      assembly {\\n        // Pick out the list length.\\n        listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\\n      }\\n\\n      require(_in.length > lenOfListLen + listLen, 'Invalid RLP long list.');\\n\\n      return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n    }\\n  }\\n\\n  /**\\n   * Copies the bytes from a memory location.\\n   * @param _src Pointer to the location to read from.\\n   * @param _offset Offset to start reading from.\\n   * @param _length Number of bytes to read.\\n   * @return Copied bytes.\\n   */\\n  function _copy(\\n    uint256 _src,\\n    uint256 _offset,\\n    uint256 _length\\n  ) private pure returns (bytes memory) {\\n    bytes memory out = new bytes(_length);\\n    if (out.length == 0) {\\n      return out;\\n    }\\n\\n    uint256 src = _src + _offset;\\n    uint256 dest;\\n    assembly {\\n      dest := add(out, 32)\\n    }\\n\\n    // Copy over as many complete words as we can.\\n    for (uint256 i = 0; i < _length / 32; i++) {\\n      assembly {\\n        mstore(dest, mload(src))\\n      }\\n\\n      src += 32;\\n      dest += 32;\\n    }\\n\\n    // Pick out the remaining bytes.\\n    uint256 mask;\\n    unchecked {\\n      mask = 256**(32 - (_length % 32)) - 1;\\n    }\\n\\n    assembly {\\n      mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\\n    }\\n    return out;\\n  }\\n\\n  /**\\n   * Copies an RLP item into bytes.\\n   * @param _in RLP item to copy.\\n   * @return Copied bytes.\\n   */\\n  function _copy(RLPItem memory _in) private pure returns (bytes memory) {\\n    return _copy(_in.ptr, 0, _in.length);\\n  }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/libraries/rlp/Lib_RLPWriter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_RLPWriter\\n * @author Bakaoh (with modifications)\\n */\\nlibrary Lib_RLPWriter {\\n  /**********************\\n   * Internal Functions *\\n   **********************/\\n\\n  /**\\n   * RLP encodes a byte string.\\n   * @param _in The byte string to encode.\\n   * @return The RLP encoded string in bytes.\\n   */\\n  function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\\n    bytes memory encoded;\\n\\n    if (_in.length == 1 && uint8(_in[0]) < 128) {\\n      encoded = _in;\\n    } else {\\n      encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n    }\\n\\n    return encoded;\\n  }\\n\\n  /**\\n   * RLP encodes a list of RLP encoded byte byte strings.\\n   * @param _in The list of RLP encoded byte strings.\\n   * @return The RLP encoded list of items in bytes.\\n   */\\n  function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\\n    bytes memory list = _flatten(_in);\\n    return abi.encodePacked(_writeLength(list.length, 192), list);\\n  }\\n\\n  /**\\n   * RLP encodes a string.\\n   * @param _in The string to encode.\\n   * @return The RLP encoded string in bytes.\\n   */\\n  function writeString(string memory _in) internal pure returns (bytes memory) {\\n    return writeBytes(bytes(_in));\\n  }\\n\\n  /**\\n   * RLP encodes an address.\\n   * @param _in The address to encode.\\n   * @return The RLP encoded address in bytes.\\n   */\\n  function writeAddress(address _in) internal pure returns (bytes memory) {\\n    return writeBytes(abi.encodePacked(_in));\\n  }\\n\\n  /**\\n   * RLP encodes a uint.\\n   * @param _in The uint256 to encode.\\n   * @return The RLP encoded uint256 in bytes.\\n   */\\n  function writeUint(uint256 _in) internal pure returns (bytes memory) {\\n    return writeBytes(_toBinary(_in));\\n  }\\n\\n  /**\\n   * RLP encodes a bool.\\n   * @param _in The bool to encode.\\n   * @return The RLP encoded bool in bytes.\\n   */\\n  function writeBool(bool _in) internal pure returns (bytes memory) {\\n    bytes memory encoded = new bytes(1);\\n    encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n    return encoded;\\n  }\\n\\n  /*********************\\n   * Private Functions *\\n   *********************/\\n\\n  /**\\n   * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\\n   * @param _len The length of the string or the payload.\\n   * @param _offset 128 if item is string, 192 if item is list.\\n   * @return RLP encoded bytes.\\n   */\\n  function _writeLength(uint256 _len, uint256 _offset)\\n    private\\n    pure\\n    returns (bytes memory)\\n  {\\n    bytes memory encoded;\\n\\n    if (_len < 56) {\\n      encoded = new bytes(1);\\n      encoded[0] = bytes1(uint8(_len) + uint8(_offset));\\n    } else {\\n      uint256 lenLen;\\n      uint256 i = 1;\\n      while (_len / i != 0) {\\n        lenLen++;\\n        i *= 256;\\n      }\\n\\n      encoded = new bytes(lenLen + 1);\\n      encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n      for (i = 1; i <= lenLen; i++) {\\n        encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\\n      }\\n    }\\n\\n    return encoded;\\n  }\\n\\n  /**\\n   * Encode integer in big endian binary form with no leading zeroes.\\n   * @notice TODO: This should be optimized with assembly to save gas costs.\\n   * @param _x The integer to encode.\\n   * @return RLP encoded bytes.\\n   */\\n  function _toBinary(uint256 _x) private pure returns (bytes memory) {\\n    bytes memory b = abi.encodePacked(_x);\\n\\n    uint256 i = 0;\\n    for (; i < 32; i++) {\\n      if (b[i] != 0) {\\n        break;\\n      }\\n    }\\n\\n    bytes memory res = new bytes(32 - i);\\n    for (uint256 j = 0; j < res.length; j++) {\\n      res[j] = b[i++];\\n    }\\n\\n    return res;\\n  }\\n\\n  /**\\n   * Copies a piece of memory to another location.\\n   * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\\n   * @param _dest Destination location.\\n   * @param _src Source location.\\n   * @param _len Length of memory to copy.\\n   */\\n  function _memcpy(\\n    uint256 _dest,\\n    uint256 _src,\\n    uint256 _len\\n  ) private pure {\\n    uint256 dest = _dest;\\n    uint256 src = _src;\\n    uint256 len = _len;\\n\\n    for (; len >= 32; len -= 32) {\\n      assembly {\\n        mstore(dest, mload(src))\\n      }\\n      dest += 32;\\n      src += 32;\\n    }\\n\\n    uint256 mask;\\n    unchecked {\\n      mask = 256**(32 - len) - 1;\\n    }\\n    assembly {\\n      let srcpart := and(mload(src), not(mask))\\n      let destpart := and(mload(dest), mask)\\n      mstore(dest, or(destpart, srcpart))\\n    }\\n  }\\n\\n  /**\\n   * Flattens a list of byte strings into one byte string.\\n   * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\\n   * @param _list List of byte strings to flatten.\\n   * @return The flattened byte string.\\n   */\\n  function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\\n    if (_list.length == 0) {\\n      return new bytes(0);\\n    }\\n\\n    uint256 len;\\n    uint256 i = 0;\\n    for (; i < _list.length; i++) {\\n      len += _list[i].length;\\n    }\\n\\n    bytes memory flattened = new bytes(len);\\n    uint256 flattenedPtr;\\n    assembly {\\n      flattenedPtr := add(flattened, 0x20)\\n    }\\n\\n    for (i = 0; i < _list.length; i++) {\\n      bytes memory item = _list[i];\\n\\n      uint256 listPtr;\\n      assembly {\\n        listPtr := add(item, 0x20)\\n      }\\n\\n      _memcpy(flattenedPtr, listPtr, item.length);\\n      flattenedPtr += _list[i].length;\\n    }\\n\\n    return flattened;\\n  }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/libraries/utils/Lib_BytesUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_BytesUtils\\n */\\nlibrary Lib_BytesUtils {\\n  /**********************\\n   * Internal Functions *\\n   **********************/\\n\\n  function slice(\\n    bytes memory _bytes,\\n    uint256 _start,\\n    uint256 _length\\n  ) internal pure returns (bytes memory) {\\n    require(_length + 31 >= _length, 'slice_overflow');\\n    require(_start + _length >= _start, 'slice_overflow');\\n    require(_bytes.length >= _start + _length, 'slice_outOfBounds');\\n\\n    bytes memory tempBytes;\\n\\n    assembly {\\n      switch iszero(_length)\\n      case 0 {\\n        // Get a location of some free memory and store it in tempBytes as\\n        // Solidity does for memory variables.\\n        tempBytes := mload(0x40)\\n\\n        // The first word of the slice result is potentially a partial\\n        // word read from the original array. To read it, we calculate\\n        // the length of that partial word and start copying that many\\n        // bytes into the array. The first word we copy will start with\\n        // data we don't care about, but the last `lengthmod` bytes will\\n        // land at the beginning of the contents of the new array. When\\n        // we're done copying, we overwrite the full first word with\\n        // the actual length of the slice.\\n        let lengthmod := and(_length, 31)\\n\\n        // The multiplication in the next line is necessary\\n        // because when slicing multiples of 32 bytes (lengthmod == 0)\\n        // the following copy loop was copying the origin's length\\n        // and then ending prematurely not copying everything it should.\\n        let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n        let end := add(mc, _length)\\n\\n        for {\\n          // The multiplication in the next line has the same exact purpose\\n          // as the one above.\\n          let cc := add(\\n            add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))),\\n            _start\\n          )\\n        } lt(mc, end) {\\n          mc := add(mc, 0x20)\\n          cc := add(cc, 0x20)\\n        } {\\n          mstore(mc, mload(cc))\\n        }\\n\\n        mstore(tempBytes, _length)\\n\\n        //update free-memory pointer\\n        //allocating the array padded to 32 bytes like the compiler does now\\n        mstore(0x40, and(add(mc, 31), not(31)))\\n      }\\n      //if we want a zero-length slice let's just return a zero-length array\\n      default {\\n        tempBytes := mload(0x40)\\n\\n        //zero out the 32 bytes slice we are about to return\\n        //we need to do it because Solidity does not garbage collect\\n        mstore(tempBytes, 0)\\n\\n        mstore(0x40, add(tempBytes, 0x20))\\n      }\\n    }\\n\\n    return tempBytes;\\n  }\\n\\n  function slice(bytes memory _bytes, uint256 _start)\\n    internal\\n    pure\\n    returns (bytes memory)\\n  {\\n    if (_start >= _bytes.length) {\\n      return bytes('');\\n    }\\n\\n    return slice(_bytes, _start, _bytes.length - _start);\\n  }\\n\\n  function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {\\n    if (_bytes.length < 32) {\\n      bytes32 ret;\\n      assembly {\\n        ret := mload(add(_bytes, 32))\\n      }\\n      return ret;\\n    }\\n\\n    return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\\n  }\\n\\n  function toUint256(bytes memory _bytes) internal pure returns (uint256) {\\n    return uint256(toBytes32(_bytes));\\n  }\\n\\n  function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n    bytes memory nibbles = new bytes(_bytes.length * 2);\\n\\n    for (uint256 i = 0; i < _bytes.length; i++) {\\n      nibbles[i * 2] = _bytes[i] >> 4;\\n      nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\\n    }\\n\\n    return nibbles;\\n  }\\n\\n  function fromNibbles(bytes memory _bytes)\\n    internal\\n    pure\\n    returns (bytes memory)\\n  {\\n    bytes memory ret = new bytes(_bytes.length / 2);\\n\\n    for (uint256 i = 0; i < ret.length; i++) {\\n      ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\\n    }\\n\\n    return ret;\\n  }\\n\\n  function equal(bytes memory _bytes, bytes memory _other)\\n    internal\\n    pure\\n    returns (bool)\\n  {\\n    return keccak256(_bytes) == keccak256(_other);\\n  }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/libraries/utils/Lib_Bytes32Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_Byte32Utils\\n */\\nlibrary Lib_Bytes32Utils {\\n  /**********************\\n   * Internal Functions *\\n   **********************/\\n\\n  /**\\n   * Converts a bytes32 value to a boolean. Anything non-zero will be converted to \\\"true.\\\"\\n   * @param _in Input bytes32 value.\\n   * @return Bytes32 as a boolean.\\n   */\\n  function toBool(bytes32 _in) internal pure returns (bool) {\\n    return _in != 0;\\n  }\\n\\n  /**\\n   * Converts a boolean to a bytes32 value.\\n   * @param _in Input boolean value.\\n   * @return Boolean as a bytes32.\\n   */\\n  function fromBool(bool _in) internal pure returns (bytes32) {\\n    return bytes32(uint256(_in ? 1 : 0));\\n  }\\n\\n  /**\\n   * Converts a bytes32 value to an address. Takes the *last* 20 bytes.\\n   * @param _in Input bytes32 value.\\n   * @return Bytes32 as an address.\\n   */\\n  function toAddress(bytes32 _in) internal pure returns (address) {\\n    return address(uint160(uint256(_in)));\\n  }\\n\\n  /**\\n   * Converts an address to a bytes32.\\n   * @param _in Input address value.\\n   * @return Address as a bytes32.\\n   */\\n  function fromAddress(address _in) internal pure returns (bytes32) {\\n    return bytes32(uint256(uint160(_in)));\\n  }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/libraries/trie/Lib_MerkleTrie.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport {Lib_BytesUtils} from '../utils/Lib_BytesUtils.sol';\\nimport {Lib_RLPReader} from '../rlp/Lib_RLPReader.sol';\\nimport {Lib_RLPWriter} from '../rlp/Lib_RLPWriter.sol';\\n\\n/**\\n * @title Lib_MerkleTrie\\n */\\nlibrary Lib_MerkleTrie {\\n  /*******************\\n   * Data Structures *\\n   *******************/\\n\\n  enum NodeType {\\n    BranchNode,\\n    ExtensionNode,\\n    LeafNode\\n  }\\n\\n  struct TrieNode {\\n    bytes encoded;\\n    Lib_RLPReader.RLPItem[] decoded;\\n  }\\n\\n  /**********************\\n   * Contract Constants *\\n   **********************/\\n\\n  // TREE_RADIX determines the number of elements per branch node.\\n  uint256 constant TREE_RADIX = 16;\\n  // Branch nodes have TREE_RADIX elements plus an additional `value` slot.\\n  uint256 constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\\n  // Leaf nodes and extension nodes always have two elements, a `path` and a `value`.\\n  uint256 constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\\n\\n  // Prefixes are prepended to the `path` within a leaf or extension node and\\n  // allow us to differentiate between the two node types. `ODD` or `EVEN` is\\n  // determined by the number of nibbles within the unprefixed `path`. If the\\n  // number of nibbles if even, we need to insert an extra padding nibble so\\n  // the resulting prefixed `path` has an even number of nibbles.\\n  uint8 constant PREFIX_EXTENSION_EVEN = 0;\\n  uint8 constant PREFIX_EXTENSION_ODD = 1;\\n  uint8 constant PREFIX_LEAF_EVEN = 2;\\n  uint8 constant PREFIX_LEAF_ODD = 3;\\n\\n  // Just a utility constant. RLP represents `NULL` as 0x80.\\n  bytes1 constant RLP_NULL = bytes1(0x80);\\n  bytes constant RLP_NULL_BYTES = hex'80';\\n  bytes32 internal constant KECCAK256_RLP_NULL_BYTES =\\n    keccak256(RLP_NULL_BYTES);\\n\\n  /**********************\\n   * Internal Functions *\\n   **********************/\\n\\n  /**\\n   * @notice Verifies a proof that a given key/value pair is present in the\\n   * Merkle trie.\\n   * @param _key Key of the node to search for, as a hex string.\\n   * @param _value Value of the node to search for, as a hex string.\\n   * @param _proof Merkle trie inclusion proof for the desired node. Unlike\\n   * traditional Merkle trees, this proof is executed top-down and consists\\n   * of a list of RLP-encoded nodes that make a path down to the target node.\\n   * @param _root Known root of the Merkle trie. Used to verify that the\\n   * included proof is correctly constructed.\\n   * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\\n   */\\n  function verifyInclusionProof(\\n    bytes memory _key,\\n    bytes memory _value,\\n    bytes memory _proof,\\n    bytes32 _root\\n  ) internal pure returns (bool _verified) {\\n    (bool exists, bytes memory value) = get(_key, _proof, _root);\\n\\n    return (exists && Lib_BytesUtils.equal(_value, value));\\n  }\\n\\n  /**\\n   * @notice Updates a Merkle trie and returns a new root hash.\\n   * @param _key Key of the node to update, as a hex string.\\n   * @param _value Value of the node to update, as a hex string.\\n   * @param _proof Merkle trie inclusion proof for the node *nearest* the\\n   * target node. If the key exists, we can simply update the value.\\n   * Otherwise, we need to modify the trie to handle the new k/v pair.\\n   * @param _root Known root of the Merkle trie. Used to verify that the\\n   * included proof is correctly constructed.\\n   * @return _updatedRoot Root hash of the newly constructed trie.\\n   */\\n  function update(\\n    bytes memory _key,\\n    bytes memory _value,\\n    bytes memory _proof,\\n    bytes32 _root\\n  ) internal pure returns (bytes32 _updatedRoot) {\\n    // Special case when inserting the very first node.\\n    if (_root == KECCAK256_RLP_NULL_BYTES) {\\n      return getSingleNodeRootHash(_key, _value);\\n    }\\n\\n    TrieNode[] memory proof = _parseProof(_proof);\\n    (uint256 pathLength, bytes memory keyRemainder, ) = _walkNodePath(\\n      proof,\\n      _key,\\n      _root\\n    );\\n    TrieNode[] memory newPath = _getNewPath(\\n      proof,\\n      pathLength,\\n      _key,\\n      keyRemainder,\\n      _value\\n    );\\n\\n    return _getUpdatedTrieRoot(newPath, _key);\\n  }\\n\\n  /**\\n   * @notice Retrieves the value associated with a given key.\\n   * @param _key Key to search for, as hex bytes.\\n   * @param _proof Merkle trie inclusion proof for the key.\\n   * @param _root Known root of the Merkle trie.\\n   * @return _exists Whether or not the key exists.\\n   * @return _value Value of the key if it exists.\\n   */\\n  function get(\\n    bytes memory _key,\\n    bytes memory _proof,\\n    bytes32 _root\\n  ) internal pure returns (bool _exists, bytes memory _value) {\\n    TrieNode[] memory proof = _parseProof(_proof);\\n    (\\n      uint256 pathLength,\\n      bytes memory keyRemainder,\\n      bool isFinalNode\\n    ) = _walkNodePath(proof, _key, _root);\\n\\n    bool exists = keyRemainder.length == 0;\\n\\n    require(exists || isFinalNode, 'Provided proof is invalid.');\\n\\n    bytes memory value = exists\\n      ? _getNodeValue(proof[pathLength - 1])\\n      : bytes('');\\n\\n    return (exists, value);\\n  }\\n\\n  /**\\n   * Computes the root hash for a trie with a single node.\\n   * @param _key Key for the single node.\\n   * @param _value Value for the single node.\\n   * @return _updatedRoot Hash of the trie.\\n   */\\n  function getSingleNodeRootHash(bytes memory _key, bytes memory _value)\\n    internal\\n    pure\\n    returns (bytes32 _updatedRoot)\\n  {\\n    return\\n      keccak256(_makeLeafNode(Lib_BytesUtils.toNibbles(_key), _value).encoded);\\n  }\\n\\n  /*********************\\n   * Private Functions *\\n   *********************/\\n\\n  /**\\n   * @notice Walks through a proof using a provided key.\\n   * @param _proof Inclusion proof to walk through.\\n   * @param _key Key to use for the walk.\\n   * @param _root Known root of the trie.\\n   * @return _pathLength Length of the final path\\n   * @return _keyRemainder Portion of the key remaining after the walk.\\n   * @return _isFinalNode Whether or not we've hit a dead end.\\n   */\\n  function _walkNodePath(\\n    TrieNode[] memory _proof,\\n    bytes memory _key,\\n    bytes32 _root\\n  )\\n    private\\n    pure\\n    returns (\\n      uint256 _pathLength,\\n      bytes memory _keyRemainder,\\n      bool _isFinalNode\\n    )\\n  {\\n    uint256 pathLength = 0;\\n    bytes memory key = Lib_BytesUtils.toNibbles(_key);\\n\\n    bytes32 currentNodeID = _root;\\n    uint256 currentKeyIndex = 0;\\n    uint256 currentKeyIncrement = 0;\\n    TrieNode memory currentNode;\\n\\n    // Proof is top-down, so we start at the first element (root).\\n    for (uint256 i = 0; i < _proof.length; i++) {\\n      currentNode = _proof[i];\\n      currentKeyIndex += currentKeyIncrement;\\n\\n      // Keep track of the proof elements we actually need.\\n      // It's expensive to resize arrays, so this simply reduces gas costs.\\n      pathLength += 1;\\n\\n      if (currentKeyIndex == 0) {\\n        // First proof element is always the root node.\\n        require(\\n          keccak256(currentNode.encoded) == currentNodeID,\\n          'Invalid root hash'\\n        );\\n      } else if (currentNode.encoded.length >= 32) {\\n        // Nodes 32 bytes or larger are hashed inside branch nodes.\\n        require(\\n          keccak256(currentNode.encoded) == currentNodeID,\\n          'Invalid large internal hash'\\n        );\\n      } else {\\n        // Nodes smaller than 31 bytes aren't hashed.\\n        require(\\n          Lib_BytesUtils.toBytes32(currentNode.encoded) == currentNodeID,\\n          'Invalid internal node hash'\\n        );\\n      }\\n\\n      if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\\n        if (currentKeyIndex == key.length) {\\n          // We've hit the end of the key\\n          // meaning the value should be within this branch node.\\n          break;\\n        } else {\\n          // We're not at the end of the key yet.\\n          // Figure out what the next node ID should be and continue.\\n          uint8 branchKey = uint8(key[currentKeyIndex]);\\n          Lib_RLPReader.RLPItem memory nextNode = currentNode.decoded[\\n            branchKey\\n          ];\\n          currentNodeID = _getNodeID(nextNode);\\n          currentKeyIncrement = 1;\\n          continue;\\n        }\\n      } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\\n        bytes memory path = _getNodePath(currentNode);\\n        uint8 prefix = uint8(path[0]);\\n        uint8 offset = 2 - (prefix % 2);\\n        bytes memory pathRemainder = Lib_BytesUtils.slice(path, offset);\\n        bytes memory keyRemainder = Lib_BytesUtils.slice(key, currentKeyIndex);\\n        uint256 sharedNibbleLength = _getSharedNibbleLength(\\n          pathRemainder,\\n          keyRemainder\\n        );\\n\\n        if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\\n          if (\\n            pathRemainder.length == sharedNibbleLength &&\\n            keyRemainder.length == sharedNibbleLength\\n          ) {\\n            // The key within this leaf matches our key exactly.\\n            // Increment the key index to reflect that we have no remainder.\\n            currentKeyIndex += sharedNibbleLength;\\n          }\\n\\n          // We've hit a leaf node, so our next node should be NULL.\\n          currentNodeID = bytes32(RLP_NULL);\\n          break;\\n        } else if (\\n          prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD\\n        ) {\\n          if (sharedNibbleLength != pathRemainder.length) {\\n            // Our extension node is not identical to the remainder.\\n            // We've hit the end of this path\\n            // updates will need to modify this extension.\\n            currentNodeID = bytes32(RLP_NULL);\\n            break;\\n          } else {\\n            // Our extension shares some nibbles.\\n            // Carry on to the next node.\\n            currentNodeID = _getNodeID(currentNode.decoded[1]);\\n            currentKeyIncrement = sharedNibbleLength;\\n            continue;\\n          }\\n        } else {\\n          revert('Received a node with an unknown prefix');\\n        }\\n      } else {\\n        revert('Received an unparseable node.');\\n      }\\n    }\\n\\n    // If our node ID is NULL, then we're at a dead end.\\n    bool isFinalNode = currentNodeID == bytes32(RLP_NULL);\\n    return (\\n      pathLength,\\n      Lib_BytesUtils.slice(key, currentKeyIndex),\\n      isFinalNode\\n    );\\n  }\\n\\n  /**\\n   * @notice Creates new nodes to support a k/v pair insertion into a given Merkle trie path.\\n   * @param _path Path to the node nearest the k/v pair.\\n   * @param _pathLength Length of the path. Necessary because the provided path may include\\n   *  additional nodes (e.g., it comes directly from a proof) and we can't resize in-memory\\n   *  arrays without costly duplication.\\n   * @param _key Full original key.\\n   * @param _keyRemainder Portion of the initial key that must be inserted into the trie.\\n   * @param _value Value to insert at the given key.\\n   * @return _newPath A new path with the inserted k/v pair and extra supporting nodes.\\n   */\\n  function _getNewPath(\\n    TrieNode[] memory _path,\\n    uint256 _pathLength,\\n    bytes memory _key,\\n    bytes memory _keyRemainder,\\n    bytes memory _value\\n  ) private pure returns (TrieNode[] memory _newPath) {\\n    bytes memory keyRemainder = _keyRemainder;\\n\\n    // Most of our logic depends on the status of the last node in the path.\\n    TrieNode memory lastNode = _path[_pathLength - 1];\\n    NodeType lastNodeType = _getNodeType(lastNode);\\n\\n    // Create an array for newly created nodes.\\n    // We need up to three new nodes, depending on the contents of the last node.\\n    // Since array resizing is expensive, we'll keep track of the size manually.\\n    // We're using an explicit `totalNewNodes += 1` after insertions for clarity.\\n    TrieNode[] memory newNodes = new TrieNode[](3);\\n    uint256 totalNewNodes = 0;\\n\\n    // solhint-disable-next-line max-line-length\\n    // Reference: https://github.com/ethereumjs/merkle-patricia-tree/blob/c0a10395aab37d42c175a47114ebfcbd7efcf059/src/baseTrie.ts#L294-L313\\n    bool matchLeaf = false;\\n    if (lastNodeType == NodeType.LeafNode) {\\n      uint256 l = 0;\\n      if (_path.length > 0) {\\n        for (uint256 i = 0; i < _path.length - 1; i++) {\\n          if (_getNodeType(_path[i]) == NodeType.BranchNode) {\\n            l++;\\n          } else {\\n            l += _getNodeKey(_path[i]).length;\\n          }\\n        }\\n      }\\n\\n      if (\\n        _getSharedNibbleLength(\\n          _getNodeKey(lastNode),\\n          Lib_BytesUtils.slice(Lib_BytesUtils.toNibbles(_key), l)\\n        ) ==\\n        _getNodeKey(lastNode).length &&\\n        keyRemainder.length == 0\\n      ) {\\n        matchLeaf = true;\\n      }\\n    }\\n\\n    if (matchLeaf) {\\n      // We've found a leaf node with the given key.\\n      // Simply need to update the value of the node to match.\\n      newNodes[totalNewNodes] = _makeLeafNode(_getNodeKey(lastNode), _value);\\n      totalNewNodes += 1;\\n    } else if (lastNodeType == NodeType.BranchNode) {\\n      if (keyRemainder.length == 0) {\\n        // We've found a branch node with the given key.\\n        // Simply need to update the value of the node to match.\\n        newNodes[totalNewNodes] = _editBranchValue(lastNode, _value);\\n        totalNewNodes += 1;\\n      } else {\\n        // We've found a branch node, but it doesn't contain our key.\\n        // Reinsert the old branch for now.\\n        newNodes[totalNewNodes] = lastNode;\\n        totalNewNodes += 1;\\n        // Create a new leaf node, slicing our remainder since the first byte points\\n        // to our branch node.\\n        newNodes[totalNewNodes] = _makeLeafNode(\\n          Lib_BytesUtils.slice(keyRemainder, 1),\\n          _value\\n        );\\n        totalNewNodes += 1;\\n      }\\n    } else {\\n      // Our last node is either an extension node or a leaf node with a different key.\\n      bytes memory lastNodeKey = _getNodeKey(lastNode);\\n      uint256 sharedNibbleLength = _getSharedNibbleLength(\\n        lastNodeKey,\\n        keyRemainder\\n      );\\n\\n      if (sharedNibbleLength != 0) {\\n        // We've got some shared nibbles between the last node and our key remainder.\\n        // We'll need to insert an extension node that covers these shared nibbles.\\n        bytes memory nextNodeKey = Lib_BytesUtils.slice(\\n          lastNodeKey,\\n          0,\\n          sharedNibbleLength\\n        );\\n        newNodes[totalNewNodes] = _makeExtensionNode(\\n          nextNodeKey,\\n          _getNodeHash(_value)\\n        );\\n        totalNewNodes += 1;\\n\\n        // Cut down the keys since we've just covered these shared nibbles.\\n        lastNodeKey = Lib_BytesUtils.slice(lastNodeKey, sharedNibbleLength);\\n        keyRemainder = Lib_BytesUtils.slice(keyRemainder, sharedNibbleLength);\\n      }\\n\\n      // Create an empty branch to fill in.\\n      TrieNode memory newBranch = _makeEmptyBranchNode();\\n\\n      if (lastNodeKey.length == 0) {\\n        // Key remainder was larger than the key for our last node.\\n        // The value within our last node is therefore going to be shifted into\\n        // a branch value slot.\\n        newBranch = _editBranchValue(newBranch, _getNodeValue(lastNode));\\n      } else {\\n        // Last node key was larger than the key remainder.\\n        // We're going to modify some index of our branch.\\n        uint8 branchKey = uint8(lastNodeKey[0]);\\n        // Move on to the next nibble.\\n        lastNodeKey = Lib_BytesUtils.slice(lastNodeKey, 1);\\n\\n        if (lastNodeType == NodeType.LeafNode) {\\n          // We're dealing with a leaf node.\\n          // We'll modify the key and insert the old leaf node into the branch index.\\n          TrieNode memory modifiedLastNode = _makeLeafNode(\\n            lastNodeKey,\\n            _getNodeValue(lastNode)\\n          );\\n          newBranch = _editBranchIndex(\\n            newBranch,\\n            branchKey,\\n            _getNodeHash(modifiedLastNode.encoded)\\n          );\\n        } else if (lastNodeKey.length != 0) {\\n          // We're dealing with a shrinking extension node.\\n          // We need to modify the node to decrease the size of the key.\\n          TrieNode memory modifiedLastNode = _makeExtensionNode(\\n            lastNodeKey,\\n            _getNodeValue(lastNode)\\n          );\\n          newBranch = _editBranchIndex(\\n            newBranch,\\n            branchKey,\\n            _getNodeHash(modifiedLastNode.encoded)\\n          );\\n        } else {\\n          // We're dealing with an unnecessary extension node.\\n          // We're going to delete the node entirely.\\n          // Simply insert its current value into the branch index.\\n          newBranch = _editBranchIndex(\\n            newBranch,\\n            branchKey,\\n            _getNodeValue(lastNode)\\n          );\\n        }\\n      }\\n\\n      if (keyRemainder.length == 0) {\\n        // We've got nothing left in the key remainder.\\n        // Simply insert the value into the branch value slot.\\n        newBranch = _editBranchValue(newBranch, _value);\\n        // Push the branch into the list of new nodes.\\n        newNodes[totalNewNodes] = newBranch;\\n        totalNewNodes += 1;\\n      } else {\\n        // We've got some key remainder to work with.\\n        // We'll be inserting a leaf node into the trie.\\n        // First, move on to the next nibble.\\n        keyRemainder = Lib_BytesUtils.slice(keyRemainder, 1);\\n        // Push the branch into the list of new nodes.\\n        newNodes[totalNewNodes] = newBranch;\\n        totalNewNodes += 1;\\n        // Push a new leaf node for our k/v pair.\\n        newNodes[totalNewNodes] = _makeLeafNode(keyRemainder, _value);\\n        totalNewNodes += 1;\\n      }\\n    }\\n\\n    // Finally, join the old path with our newly created nodes.\\n    // Since we're overwriting the last node in the path, we use `_pathLength - 1`.\\n    return _joinNodeArrays(_path, _pathLength - 1, newNodes, totalNewNodes);\\n  }\\n\\n  /**\\n   * @notice Computes the trie root from a given path.\\n   * @param _nodes Path to some k/v pair.\\n   * @param _key Key for the k/v pair.\\n   * @return _updatedRoot Root hash for the updated trie.\\n   */\\n  function _getUpdatedTrieRoot(TrieNode[] memory _nodes, bytes memory _key)\\n    private\\n    pure\\n    returns (bytes32 _updatedRoot)\\n  {\\n    bytes memory key = Lib_BytesUtils.toNibbles(_key);\\n\\n    // Some variables to keep track of during iteration.\\n    TrieNode memory currentNode;\\n    NodeType currentNodeType;\\n    bytes memory previousNodeHash;\\n\\n    // Run through the path backwards to rebuild our root hash.\\n    for (uint256 i = _nodes.length; i > 0; i--) {\\n      // Pick out the current node.\\n      currentNode = _nodes[i - 1];\\n      currentNodeType = _getNodeType(currentNode);\\n\\n      if (currentNodeType == NodeType.LeafNode) {\\n        // Leaf nodes are already correctly encoded.\\n        // Shift the key over to account for the nodes key.\\n        bytes memory nodeKey = _getNodeKey(currentNode);\\n        key = Lib_BytesUtils.slice(key, 0, key.length - nodeKey.length);\\n      } else if (currentNodeType == NodeType.ExtensionNode) {\\n        // Shift the key over to account for the nodes key.\\n        bytes memory nodeKey = _getNodeKey(currentNode);\\n        key = Lib_BytesUtils.slice(key, 0, key.length - nodeKey.length);\\n\\n        // If this node is the last element in the path, it'll be correctly encoded\\n        // and we can skip this part.\\n        if (previousNodeHash.length > 0) {\\n          // Re-encode the node based on the previous node.\\n          currentNode = _editExtensionNodeValue(currentNode, previousNodeHash);\\n        }\\n      } else if (currentNodeType == NodeType.BranchNode) {\\n        // If this node is the last element in the path, it'll be correctly encoded\\n        // and we can skip this part.\\n        if (previousNodeHash.length > 0) {\\n          // Re-encode the node based on the previous node.\\n          uint8 branchKey = uint8(key[key.length - 1]);\\n          key = Lib_BytesUtils.slice(key, 0, key.length - 1);\\n          currentNode = _editBranchIndex(\\n            currentNode,\\n            branchKey,\\n            previousNodeHash\\n          );\\n        }\\n      }\\n\\n      // Compute the node hash for the next iteration.\\n      previousNodeHash = _getNodeHash(currentNode.encoded);\\n    }\\n\\n    // Current node should be the root at this point.\\n    // Simply return the hash of its encoding.\\n    return keccak256(currentNode.encoded);\\n  }\\n\\n  /**\\n   * @notice Parses an RLP-encoded proof into something more useful.\\n   * @param _proof RLP-encoded proof to parse.\\n   * @return _parsed Proof parsed into easily accessible structs.\\n   */\\n  function _parseProof(bytes memory _proof)\\n    private\\n    pure\\n    returns (TrieNode[] memory _parsed)\\n  {\\n    Lib_RLPReader.RLPItem[] memory nodes = Lib_RLPReader.readList(_proof);\\n    TrieNode[] memory proof = new TrieNode[](nodes.length);\\n\\n    for (uint256 i = 0; i < nodes.length; i++) {\\n      bytes memory encoded = Lib_RLPReader.readBytes(nodes[i]);\\n      proof[i] = TrieNode({\\n        encoded: encoded,\\n        decoded: Lib_RLPReader.readList(encoded)\\n      });\\n    }\\n\\n    return proof;\\n  }\\n\\n  /**\\n   * @notice Picks out the ID for a node. Node ID is referred to as the\\n   * \\\"hash\\\" within the specification, but nodes < 32 bytes are not actually\\n   * hashed.\\n   * @param _node Node to pull an ID for.\\n   * @return _nodeID ID for the node, depending on the size of its contents.\\n   */\\n  function _getNodeID(Lib_RLPReader.RLPItem memory _node)\\n    private\\n    pure\\n    returns (bytes32 _nodeID)\\n  {\\n    bytes memory nodeID;\\n\\n    if (_node.length < 32) {\\n      // Nodes smaller than 32 bytes are RLP encoded.\\n      nodeID = Lib_RLPReader.readRawBytes(_node);\\n    } else {\\n      // Nodes 32 bytes or larger are hashed.\\n      nodeID = Lib_RLPReader.readBytes(_node);\\n    }\\n\\n    return Lib_BytesUtils.toBytes32(nodeID);\\n  }\\n\\n  /**\\n   * @notice Gets the path for a leaf or extension node.\\n   * @param _node Node to get a path for.\\n   * @return _path Node path, converted to an array of nibbles.\\n   */\\n  function _getNodePath(TrieNode memory _node)\\n    private\\n    pure\\n    returns (bytes memory _path)\\n  {\\n    return Lib_BytesUtils.toNibbles(Lib_RLPReader.readBytes(_node.decoded[0]));\\n  }\\n\\n  /**\\n   * @notice Gets the key for a leaf or extension node. Keys are essentially\\n   * just paths without any prefix.\\n   * @param _node Node to get a key for.\\n   * @return _key Node key, converted to an array of nibbles.\\n   */\\n  function _getNodeKey(TrieNode memory _node)\\n    private\\n    pure\\n    returns (bytes memory _key)\\n  {\\n    return _removeHexPrefix(_getNodePath(_node));\\n  }\\n\\n  /**\\n   * @notice Gets the path for a node.\\n   * @param _node Node to get a value for.\\n   * @return _value Node value, as hex bytes.\\n   */\\n  function _getNodeValue(TrieNode memory _node)\\n    private\\n    pure\\n    returns (bytes memory _value)\\n  {\\n    return Lib_RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);\\n  }\\n\\n  /**\\n   * @notice Computes the node hash for an encoded node. Nodes < 32 bytes\\n   * are not hashed, all others are keccak256 hashed.\\n   * @param _encoded Encoded node to hash.\\n   * @return _hash Hash of the encoded node. Simply the input if < 32 bytes.\\n   */\\n  function _getNodeHash(bytes memory _encoded)\\n    private\\n    pure\\n    returns (bytes memory _hash)\\n  {\\n    if (_encoded.length < 32) {\\n      return _encoded;\\n    } else {\\n      return abi.encodePacked(keccak256(_encoded));\\n    }\\n  }\\n\\n  /**\\n   * @notice Determines the type for a given node.\\n   * @param _node Node to determine a type for.\\n   * @return _type Type of the node; BranchNode/ExtensionNode/LeafNode.\\n   */\\n  function _getNodeType(TrieNode memory _node)\\n    private\\n    pure\\n    returns (NodeType _type)\\n  {\\n    if (_node.decoded.length == BRANCH_NODE_LENGTH) {\\n      return NodeType.BranchNode;\\n    } else if (_node.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\\n      bytes memory path = _getNodePath(_node);\\n      uint8 prefix = uint8(path[0]);\\n\\n      if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\\n        return NodeType.LeafNode;\\n      } else if (\\n        prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD\\n      ) {\\n        return NodeType.ExtensionNode;\\n      }\\n    }\\n\\n    revert('Invalid node type');\\n  }\\n\\n  /**\\n   * @notice Utility; determines the number of nibbles shared between two\\n   * nibble arrays.\\n   * @param _a First nibble array.\\n   * @param _b Second nibble array.\\n   * @return _shared Number of shared nibbles.\\n   */\\n  function _getSharedNibbleLength(bytes memory _a, bytes memory _b)\\n    private\\n    pure\\n    returns (uint256 _shared)\\n  {\\n    uint256 i = 0;\\n    while (_a.length > i && _b.length > i && _a[i] == _b[i]) {\\n      i++;\\n    }\\n    return i;\\n  }\\n\\n  /**\\n   * @notice Utility; converts an RLP-encoded node into our nice struct.\\n   * @param _raw RLP-encoded node to convert.\\n   * @return _node Node as a TrieNode struct.\\n   */\\n  function _makeNode(bytes[] memory _raw)\\n    private\\n    pure\\n    returns (TrieNode memory _node)\\n  {\\n    bytes memory encoded = Lib_RLPWriter.writeList(_raw);\\n\\n    return\\n      TrieNode({encoded: encoded, decoded: Lib_RLPReader.readList(encoded)});\\n  }\\n\\n  /**\\n   * @notice Utility; converts an RLP-decoded node into our nice struct.\\n   * @param _items RLP-decoded node to convert.\\n   * @return _node Node as a TrieNode struct.\\n   */\\n  function _makeNode(Lib_RLPReader.RLPItem[] memory _items)\\n    private\\n    pure\\n    returns (TrieNode memory _node)\\n  {\\n    bytes[] memory raw = new bytes[](_items.length);\\n    for (uint256 i = 0; i < _items.length; i++) {\\n      raw[i] = Lib_RLPReader.readRawBytes(_items[i]);\\n    }\\n    return _makeNode(raw);\\n  }\\n\\n  /**\\n   * @notice Creates a new extension node.\\n   * @param _key Key for the extension node, unprefixed.\\n   * @param _value Value for the extension node.\\n   * @return _node New extension node with the given k/v pair.\\n   */\\n  function _makeExtensionNode(bytes memory _key, bytes memory _value)\\n    private\\n    pure\\n    returns (TrieNode memory _node)\\n  {\\n    bytes[] memory raw = new bytes[](2);\\n    bytes memory key = _addHexPrefix(_key, false);\\n    raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));\\n    raw[1] = Lib_RLPWriter.writeBytes(_value);\\n    return _makeNode(raw);\\n  }\\n\\n  /**\\n   * Creates a new extension node with the same key but a different value.\\n   * @param _node Extension node to copy and modify.\\n   * @param _value New value for the extension node.\\n   * @return New node with the same key and different value.\\n   */\\n  function _editExtensionNodeValue(TrieNode memory _node, bytes memory _value)\\n    private\\n    pure\\n    returns (TrieNode memory)\\n  {\\n    bytes[] memory raw = new bytes[](2);\\n    bytes memory key = _addHexPrefix(_getNodeKey(_node), false);\\n    raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));\\n    if (_value.length < 32) {\\n      raw[1] = _value;\\n    } else {\\n      raw[1] = Lib_RLPWriter.writeBytes(_value);\\n    }\\n    return _makeNode(raw);\\n  }\\n\\n  /**\\n   * @notice Creates a new leaf node.\\n   * @dev This function is essentially identical to `_makeExtensionNode`.\\n   * Although we could route both to a single method with a flag, it's\\n   * more gas efficient to keep them separate and duplicate the logic.\\n   * @param _key Key for the leaf node, unprefixed.\\n   * @param _value Value for the leaf node.\\n   * @return _node New leaf node with the given k/v pair.\\n   */\\n  function _makeLeafNode(bytes memory _key, bytes memory _value)\\n    private\\n    pure\\n    returns (TrieNode memory _node)\\n  {\\n    bytes[] memory raw = new bytes[](2);\\n    bytes memory key = _addHexPrefix(_key, true);\\n    raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));\\n    raw[1] = Lib_RLPWriter.writeBytes(_value);\\n    return _makeNode(raw);\\n  }\\n\\n  /**\\n   * @notice Creates an empty branch node.\\n   * @return _node Empty branch node as a TrieNode struct.\\n   */\\n  function _makeEmptyBranchNode() private pure returns (TrieNode memory _node) {\\n    bytes[] memory raw = new bytes[](BRANCH_NODE_LENGTH);\\n    for (uint256 i = 0; i < raw.length; i++) {\\n      raw[i] = RLP_NULL_BYTES;\\n    }\\n    return _makeNode(raw);\\n  }\\n\\n  /**\\n   * @notice Modifies the value slot for a given branch.\\n   * @param _branch Branch node to modify.\\n   * @param _value Value to insert into the branch.\\n   * @return _updatedNode Modified branch node.\\n   */\\n  function _editBranchValue(TrieNode memory _branch, bytes memory _value)\\n    private\\n    pure\\n    returns (TrieNode memory _updatedNode)\\n  {\\n    bytes memory encoded = Lib_RLPWriter.writeBytes(_value);\\n    _branch.decoded[_branch.decoded.length - 1] = Lib_RLPReader.toRLPItem(\\n      encoded\\n    );\\n    return _makeNode(_branch.decoded);\\n  }\\n\\n  /**\\n   * @notice Modifies a slot at an index for a given branch.\\n   * @param _branch Branch node to modify.\\n   * @param _index Slot index to modify.\\n   * @param _value Value to insert into the slot.\\n   * @return _updatedNode Modified branch node.\\n   */\\n  function _editBranchIndex(\\n    TrieNode memory _branch,\\n    uint8 _index,\\n    bytes memory _value\\n  ) private pure returns (TrieNode memory _updatedNode) {\\n    bytes memory encoded = _value.length < 32\\n      ? _value\\n      : Lib_RLPWriter.writeBytes(_value);\\n    _branch.decoded[_index] = Lib_RLPReader.toRLPItem(encoded);\\n    return _makeNode(_branch.decoded);\\n  }\\n\\n  /**\\n   * @notice Utility; adds a prefix to a key.\\n   * @param _key Key to prefix.\\n   * @param _isLeaf Whether or not the key belongs to a leaf.\\n   * @return _prefixedKey Prefixed key.\\n   */\\n  function _addHexPrefix(bytes memory _key, bool _isLeaf)\\n    private\\n    pure\\n    returns (bytes memory _prefixedKey)\\n  {\\n    uint8 prefix = _isLeaf ? uint8(0x02) : uint8(0x00);\\n    uint8 offset = uint8(_key.length % 2);\\n    bytes memory prefixed = new bytes(2 - offset);\\n    prefixed[0] = bytes1(prefix + offset);\\n    return abi.encodePacked(prefixed, _key);\\n  }\\n\\n  /**\\n   * @notice Utility; removes a prefix from a path.\\n   * @param _path Path to remove the prefix from.\\n   * @return _unprefixedKey Unprefixed key.\\n   */\\n  function _removeHexPrefix(bytes memory _path)\\n    private\\n    pure\\n    returns (bytes memory _unprefixedKey)\\n  {\\n    if (uint8(_path[0]) % 2 == 0) {\\n      return Lib_BytesUtils.slice(_path, 2);\\n    } else {\\n      return Lib_BytesUtils.slice(_path, 1);\\n    }\\n  }\\n\\n  /**\\n   * @notice Utility; combines two node arrays. Array lengths are required\\n   * because the actual lengths may be longer than the filled lengths.\\n   * Array resizing is extremely costly and should be avoided.\\n   * @param _a First array to join.\\n   * @param _aLength Length of the first array.\\n   * @param _b Second array to join.\\n   * @param _bLength Length of the second array.\\n   * @return _joined Combined node array.\\n   */\\n  function _joinNodeArrays(\\n    TrieNode[] memory _a,\\n    uint256 _aLength,\\n    TrieNode[] memory _b,\\n    uint256 _bLength\\n  ) private pure returns (TrieNode[] memory _joined) {\\n    TrieNode[] memory ret = new TrieNode[](_aLength + _bLength);\\n\\n    // Copy elements from the first array.\\n    for (uint256 i = 0; i < _aLength; i++) {\\n      ret[i] = _a[i];\\n    }\\n\\n    // Copy elements from the second array.\\n    for (uint256 i = 0; i < _bLength; i++) {\\n      ret[i + _aLength] = _b[i];\\n    }\\n\\n    return ret;\\n  }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/libraries/bridge/ICrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title ICrossDomainMessenger\\n */\\ninterface ICrossDomainMessenger {\\n  /**********\\n   * Events *\\n   **********/\\n\\n  event SentMessage(\\n    address indexed target,\\n    address sender,\\n    bytes message,\\n    uint256 messageNonce,\\n    uint256 gasLimit\\n  );\\n  event RelayedMessage(bytes32 indexed msgHash);\\n  event FailedRelayedMessage(bytes32 indexed msgHash);\\n\\n  /*************\\n   * Variables *\\n   *************/\\n\\n  function xDomainMessageSender() external view returns (address);\\n\\n  /********************\\n   * Public Functions *\\n   ********************/\\n\\n  /**\\n   * Sends a cross domain message to the target messenger.\\n   * @param _target Target contract address.\\n   * @param _message Message to send to the target.\\n   * @param _gasLimit Gas limit for the provided message.\\n   */\\n  function sendMessage(\\n    address _target,\\n    bytes calldata _message,\\n    uint32 _gasLimit\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/contracts/L1/rollup/IChainStorageContainer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title IChainStorageContainer\\n */\\ninterface IChainStorageContainer {\\n  /********************\\n   * Public Functions *\\n   ********************/\\n\\n  /**\\n   * Sets the container's global metadata field. We're using `bytes27` here because we use five\\n   * bytes to maintain the length of the underlying data structure, meaning we have an extra\\n   * 27 bytes to store arbitrary data.\\n   * @param _globalMetadata New global metadata to set.\\n   */\\n  function setGlobalMetadata(bytes27 _globalMetadata) external;\\n\\n  /**\\n   * Retrieves the container's global metadata field.\\n   * @return Container global metadata field.\\n   */\\n  function getGlobalMetadata() external view returns (bytes27);\\n\\n  /**\\n   * Retrieves the number of objects stored in the container.\\n   * @return Number of objects in the container.\\n   */\\n  function length() external view returns (uint256);\\n\\n  /**\\n   * Pushes an object into the container.\\n   * @param _object A 32 byte value to insert into the container.\\n   */\\n  function push(bytes32 _object) external;\\n\\n  /**\\n   * Pushes an object into the container. Function allows setting the global metadata since\\n   * we'll need to touch the \\\"length\\\" storage slot anyway, which also contains the global\\n   * metadata (it's an optimization).\\n   * @param _object A 32 byte value to insert into the container.\\n   * @param _globalMetadata New global metadata for the container.\\n   */\\n  function push(bytes32 _object, bytes27 _globalMetadata) external;\\n\\n  /**\\n   * Retrieves an object from the container.\\n   * @param _index Index of the particular object to access.\\n   * @return 32 byte object value.\\n   */\\n  function get(uint256 _index) external view returns (bytes32);\\n\\n  /**\\n   * Removes all objects after and including a given index.\\n   * @param _index Object index to delete from.\\n   */\\n  function deleteElementsAfterInclusive(uint256 _index) external;\\n\\n  /**\\n   * Removes all objects after and including a given index. Also allows setting the global\\n   * metadata field.\\n   * @param _index Object index to delete from.\\n   * @param _globalMetadata New global metadata for the container.\\n   */\\n  function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata)\\n    external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"}],\"name\":\"FailedRelayedMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_xDomainCalldataHash\",\"type\":\"bytes32\"}],\"name\":\"MessageAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_xDomainCalldataHash\",\"type\":\"bytes32\"}],\"name\":\"MessageBlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"msgHash\",\"type\":\"bytes32\"}],\"name\":\"RelayedMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"messageNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"SentMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_xDomainCalldataHash\",\"type\":\"bytes32\"}],\"name\":\"allowMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_xDomainCalldataHash\",\"type\":\"bytes32\"}],\"name\":\"blockMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"blockedMessages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"failedMessages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_libAddressManager\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"libAddressManager\",\"outputs\":[{\"internalType\":\"contract Lib_AddressManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_messageNonce\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"stateRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevTotalElements\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.ChainBatchHeader\",\"name\":\"stateRootBatchHeader\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Lib_OVMCodec.ChainInclusionProof\",\"name\":\"stateRootProof\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"stateTrieWitness\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"storageTrieWitness\",\"type\":\"bytes\"}],\"internalType\":\"struct IL1CrossDomainMessenger.L2MessageInclusionProof\",\"name\":\"_proof\",\"type\":\"tuple\"}],\"name\":\"relayMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"relayedMessages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_queueIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_oldGasLimit\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_newGasLimit\",\"type\":\"uint32\"}],\"name\":\"replayMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"_gasLimit\",\"type\":\"uint32\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"successfulMessages\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xDomainMessageSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"L1CrossDomainMessengerFast","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}