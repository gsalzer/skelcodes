{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Volumes/My Passport/SingularityDao/dynasets/Dynaset/contracts/Dynaset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\n/* ========== Internal Inheritance ========== */\\nimport \\\"./DToken.sol\\\";\\nimport \\\"./BMath.sol\\\";\\n\\n/* ========== Internal Interfaces ========== */\\nimport \\\"./interfaces/IDynaset.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Router.sol\\\";\\nimport \\\"./interfaces/OneInchAgregator.sol\\\";\\n\\n\\n/************************************************************************************************\\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license \\n*************************************************************************************************/\\n\\n\\ncontract Dynaset is DToken, BMath, IDynaset {\\n\\n/* ==========  EVENTS  ========== */\\n\\n  /** @dev Emitted when tokens are swapped. */\\n  event LOG_SWAP(\\n    address indexed tokenIn,\\n    address indexed tokenOut,\\n    uint256 Amount\\n  );\\n\\n  /** @dev Emitted when underlying tokens are deposited for dynaset tokens. */\\n  event LOG_JOIN(\\n    address indexed caller,\\n    address indexed tokenIn,\\n    uint256 tokenAmountIn\\n  );\\n\\n  /** @dev Emitted when dynaset tokens are burned for underlying. */\\n  event LOG_EXIT(\\n    address indexed caller,\\n    address indexed tokenOut,\\n    uint256 tokenAmountOut\\n  );\\n\\n  event LOG_CALL(\\n        bytes4  indexed sig,\\n        address indexed caller,\\n        bytes           data\\n  ) anonymous;\\n\\n  /** @dev Emitted when a token's weight updates. */\\n  event LOG_DENORM_UPDATED(address indexed token, uint256 newDenorm);\\n\\n/* ==========  Modifiers  ========== */\\n  \\n  modifier _logs_() {\\n      emit LOG_CALL(msg.sig, msg.sender, msg.data);\\n      _;\\n  }\\n\\n  modifier _lock_ {\\n    require(!_mutex, \\\"ERR_REENTRY\\\");\\n    _mutex = true;\\n    _;\\n    _mutex = false;\\n  }\\n\\n  modifier _viewlock_() {\\n    require(!_mutex, \\\"ERR_REENTRY\\\");\\n    _;\\n  }\\n\\n  modifier _control_ {\\n    require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n    _;\\n  }\\n\\n  modifier _digital_asset_managers_ {\\n    require(msg.sender == _digital_asset_manager, \\\"ERR_NOT_DAM\\\");\\n    _;\\n  }\\n\\n  modifier _mint_forge_ {\\n    require(_mint_forges[msg.sender], \\\"ERR_NOT_FORGE\\\");\\n    _;\\n  }\\n\\n  modifier _burn_forge_ {\\n     require(_burn_forges[msg.sender], \\\"ERR_NOT_FORGE\\\");\\n    _;\\n  }\\n\\n  /* uniswap addresses*/\\n\\n  //address of the uniswap v2 router\\n  address private constant UNISWAP_V2_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n  //address of the oneInch v3 aggregation router\\n  address private constant ONEINCH_V4_AGREGATION_ROUTER = 0x1111111254fb6c44bAC0beD2854e76F90643097d;\\n    //address of WETH token.  This is needed because some times it is better to trade through WETH.\\n    //you might get a better price using WETH.\\n    //example trading from token A to WETH then WETH to token B might result in a better price\\n  address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n/* ==========  Storage  ========== */\\n  \\n  bool internal _mutex;\\n  // Account with CONTROL role. Able to modify the swap fee,\\n  // adjust token weights, bind and unbind tokens and lock\\n  // public swaps & joins.\\n  address internal _controller;\\n\\n  address internal _digital_asset_manager;\\n\\n  mapping(address =>bool) internal _mint_forges;\\n  mapping(address =>bool) internal _burn_forges;\\n\\n\\n  // Array of underlying tokens in the dynaset.\\n  address[] internal _tokens;\\n\\n  // Internal records of the dynaset's underlying tokens\\n  mapping(address => Record) internal _records;\\n\\n  // Total denormalized weight of the dynaset.\\n  uint256 internal _totalWeight;\\n\\n\\n  constructor() public {\\n      _controller = msg.sender;\\n  }\\n\\n/* ==========  Controls  ========== */\\n\\n  /**\\n   * @dev Sets the controller address and the token name & symbol.\\n   *\\n   * Note: This saves on storage costs for multi-step dynaset deployment.\\n   *\\n   * @param controller Controller of the dynaset\\n   * @param name Name of the dynaset token\\n   * @param symbol Symbol of the dynaset token\\n   */\\n  function configure(\\n    address controller,//admin\\n    address dam,//digital asset manager\\n    string calldata name,\\n    string calldata symbol\\n  ) external override  _control_{\\n    _controller = controller;\\n    _digital_asset_manager = dam;\\n    _initializeToken(name, symbol);\\n  }\\n\\n    /**\\n   * @dev Sets up the initial assets for the pool.\\n   *\\n   * Note: `tokenProvider` must have approved the pool to transfer the\\n   * corresponding `balances` of `tokens`.\\n   *\\n   * @param tokens Underlying tokens to initialize the pool with\\n   * @param balances Initial balances to transfer\\n   * @param denorms Initial denormalized weights for the tokens\\n   * @param tokenProvider Address to transfer the balances from\\n   */\\n  function initialize(\\n    address[] calldata tokens,\\n    uint256[] calldata balances,\\n    uint96[] calldata denorms,\\n    address tokenProvider\\n  )\\n    external\\n    override\\n    _control_\\n  {\\n    require(_tokens.length == 0, \\\"ERR_INITIALIZED\\\");\\n    uint256 len = tokens.length;\\n    require(len > 1, \\\"ERR_MIN_TOKENS\\\");\\n    require(len <= MAX_BOUND_TOKENS, \\\"ERR_MAX_TOKENS\\\");\\n    require(balances.length == len && denorms.length == len, \\\"ERR_ARR_LEN\\\");\\n    uint256 totalWeight = 0;\\n    for (uint256 i = 0; i < len; i++) {\\n      address token = tokens[i];\\n      uint96 denorm = denorms[i];\\n      uint256 balance = balances[i];\\n      require(denorm >= MIN_WEIGHT, \\\"ERR_MIN_WEIGHT\\\");\\n      require(denorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n      require(balance >= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n\\n      _records[token] = Record({\\n        bound: true,\\n        ready: true,\\n        index: uint8(i),\\n        denorm: denorm,\\n        balance: balance\\n      });\\n\\n      _tokens.push(token);\\n      \\n      totalWeight = badd(totalWeight, denorm);\\n      _pullUnderlying(token, tokenProvider, balance);\\n    }\\n    require(totalWeight <= MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n    _totalWeight = totalWeight;\\n    _mintdynasetShare(INIT_POOL_SUPPLY);\\n    _pushdynasetShare(tokenProvider, INIT_POOL_SUPPLY);\\n  }\\n\\n    /**\\n   * @dev Get all bound tokens.\\n   */\\n  function getCurrentTokens()\\n    public\\n    view\\n    override\\n    returns (address[] memory tokens)\\n  {\\n    tokens = _tokens;\\n  }\\n\\n  /**\\n   * @dev Returns the list of tokens which have a desired weight above 0.\\n   * Tokens with a desired weight of 0 are set to be phased out of the dynaset.\\n   */\\n  function getCurrentDesiredTokens()\\n    external\\n    view\\n    override\\n    returns (address[] memory tokens)\\n  {\\n    address[] memory tempTokens = _tokens;\\n    tokens = new address[](tempTokens.length);\\n    uint256 usedIndex = 0;\\n    for (uint256 i = 0; i < tokens.length; i++) {\\n      address token = tempTokens[i];\\n      if (_records[token].denorm > 0) {\\n        tokens[usedIndex++] = token;\\n      }\\n    }\\n    assembly { mstore(tokens, usedIndex) }\\n  }\\n\\n   /**\\n   * @dev Returns the denormalized weight of a bound token.\\n   */\\n  function getDenormalizedWeight(address token)\\n    external\\n    view\\n    override\\n    returns (uint256/* denorm */)\\n  {\\n    require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n    return _records[token].denorm;\\n  }\\n\\n  function getNormalizedWeight(address token)\\n        external \\n        view\\n        _viewlock_\\n        returns (uint)\\n  {\\n    require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n    uint denorm = _records[token].denorm;\\n    return bdiv(denorm, _totalWeight);\\n  }\\n\\n    /**\\n   * @dev Get the total denormalized weight of the dynaset.\\n   */\\n  function getTotalDenormalizedWeight()\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return _totalWeight;\\n  }\\n\\n  /**\\n   * @dev Returns the stored balance of a bound token.\\n   */\\n    function getBalance(address token) external view override returns (uint256) {\\n      Record storage record = _records[token];\\n      require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n      return record.balance;\\n    }\\n\\n      /**\\n     * @dev Sets the desired weights for the pool tokens, which\\n     * will be adjusted over time as they are swapped.\\n     *\\n     * Note: This does not check for duplicate tokens or that the total\\n     * of the desired weights is equal to the target total weight (25).\\n     * Those assumptions should be met in the controller. Further, the\\n     * provided tokens should only include the tokens which are not set\\n     * for removal.\\n     */\\n    function reweighTokens(\\n      address[] calldata tokens,\\n      uint96[] calldata Denorms\\n    )\\n      external\\n      override\\n      _lock_\\n      _control_\\n    {\\n      for (uint256 i = 0; i < tokens.length; i++){\\n        require(_records[tokens[i]].bound, \\\"ERR_NOT_BOUND\\\");\\n        _setDesiredDenorm(tokens[i], Denorms[i]);\\n      }\\n    }\\n\\n    // Absorb any tokens that have been sent to this contract into the dynaset\\n  function updateAfterSwap(address _tokenIn,address _tokenOut) external _digital_asset_managers_{ //external for test\\n\\n     uint256 balance_in = IERC20(_tokenIn).balanceOf(address(this)); \\n     uint256 balance_out = IERC20(_tokenOut).balanceOf(address(this));\\n     \\n     _records[_tokenIn].balance = balance_in;\\n     _records[_tokenOut].balance = balance_out;\\n  \\n  }\\n\\n\\n/* ==========  Liquidity Provider Actions  ========== */\\n\\n  /*\\n   * @dev Mint new dynaset tokens by providing the proportional amount of each\\n   * underlying token's balance relative to the proportion of dynaset tokens minted.\\n   *\\n   *\\n   * @param dynasetAmountOut Amount of dynaset tokens to mint\\n   * @param maxAmountsIn Maximum amount of each token to pay in the same\\n   * order as the dynaset's _tokens list.\\n   */\\n\\n  function joinDynaset(uint256 _amount) external override _mint_forge_{\\n\\n    uint256[] memory maxAmountsIn = new uint256[](getCurrentTokens().length);\\n    for (uint256 i = 0; i < maxAmountsIn.length; i++) {\\n      maxAmountsIn[i] = uint256(-1);\\n    }\\n    _joinDynaset(_amount, maxAmountsIn);\\n  }\\n\\n  function _joinDynaset(uint256 dynasetAmountOut, uint256[] memory maxAmountsIn)\\n   internal \\n   //external\\n   //override\\n  {\\n    uint256 dynasetTotal = totalSupply();\\n    uint256 ratio = bdiv(dynasetAmountOut, dynasetTotal); \\n    require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n    require(maxAmountsIn.length == _tokens.length, \\\"ERR_ARR_LEN\\\");\\n\\n    for (uint256 i = 0; i < maxAmountsIn.length; i++) {\\n      address t = _tokens[i];\\n      (, uint256 realBalance) = _getInputToken(t);\\n      //uint256 bal = getBalance(t);\\n      uint256 tokenAmountIn = bmul(ratio, realBalance);\\n      require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n      require(tokenAmountIn <= maxAmountsIn[i], \\\"ERR_LIMIT_IN\\\");\\n     \\n      _updateInputToken(t, badd(realBalance, tokenAmountIn));\\n      emit LOG_JOIN(msg.sender, t, tokenAmountIn);\\n      _pullUnderlying(t, msg.sender, tokenAmountIn);\\n    }\\n\\n    _mintdynasetShare(dynasetAmountOut);\\n    _pushdynasetShare(msg.sender, dynasetAmountOut);\\n  }\\n\\n\\n  /*\\n   * @dev Burns `dynasetAmountIn` dynaset tokens in exchange for the amounts of each\\n   * underlying token's balance proportional to the ratio of tokens burned to\\n   * total dynaset supply. The amount of each token transferred to the caller must\\n   * be greater than or equal to the associated minimum output amount from the\\n   * `minAmountsOut` array.\\n   *\\n   * @param dynasetAmountIn Exact amount of dynaset tokens to burn\\n   * @param minAmountsOut Minimum amount of each token to receive, in the same\\n   * order as the dynaset's _tokens list.\\n   */\\n  \\n  function exitDynaset(uint256 _amount) external override _burn_forge_ {\\n    uint256[] memory minAmountsOut = new uint256[](getCurrentTokens().length);\\n    for (uint256 i = 0; i < minAmountsOut.length; i++) {\\n      minAmountsOut[i] = 0;\\n    }\\n    _exitDynaset(_amount, minAmountsOut);\\n  }\\n\\n  function _exitDynaset(uint256 dynasetAmountIn, uint256[] memory minAmountsOut)\\n   internal\\n  {\\n    require(minAmountsOut.length == _tokens.length, \\\"ERR_ARR_LEN\\\");\\n    uint256 dynasetTotal = totalSupply();\\n    uint256 ratio = bdiv(dynasetAmountIn, dynasetTotal);\\n    require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n    _pulldynasetShare(msg.sender, dynasetAmountIn);\\n    _burndynasetShare(dynasetAmountIn);\\n    \\n    for (uint256 i = 0; i < minAmountsOut.length; i++) {\\n      address t = _tokens[i];\\n      Record memory record = _records[t];\\n       if (record.ready) {\\n        uint256 tokenAmountOut = bmul(ratio, record.balance);\\n        require(tokenAmountOut != 0, \\\"ERR_MATH_APPROX\\\");\\n        require(tokenAmountOut >= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\n   \\n        _records[t].balance = bsub(record.balance, tokenAmountOut);\\n        emit LOG_EXIT(msg.sender, t, tokenAmountOut);\\n        _pushUnderlying(t, msg.sender, tokenAmountOut);\\n       \\n        }else{\\n           require(minAmountsOut[i] == 0, \\\"ERR_OUT_NOT_READY\\\");\\n        }\\n      \\n      } \\n    \\n  }\\n\\n\\n\\n/* ==========  Other  ========== */\\n\\n  /**\\n   * @dev Absorb any tokens that have been sent to the dynaset.\\n   * If the token is not bound, it will be sent to the unbound\\n   * token handler.\\n   */\\n\\n/* ==========  Token Swaps  ========== */\\n  \\n  function ApproveOneInch(address token,uint256 amount) external _digital_asset_managers_ {\\n      \\n      require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n      IERC20(token).approve(ONEINCH_V4_AGREGATION_ROUTER, amount);\\n  }\\n  \\n\\n  function swapUniswap(\\n    address _tokenIn,\\n    address _tokenOut,\\n    uint256 _amountIn,\\n    uint256 _amountOutMin) \\n  external\\n  _digital_asset_managers_\\n  {\\n        \\n    require(_records[_tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n    require(_records[_tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        //next we need to allow the uniswapv2 router to spend the token we just sent to this contract\\n        //by calling IERC20 approve you allow the uniswap contract to spend the tokens in this contract\\n    IERC20(_tokenIn).approve(UNISWAP_V2_ROUTER, _amountIn);\\n\\n        //path is an array of addresses.\\n        //this path array will have 3 addresses [tokenIn, WETH, tokenOut]\\n        //the if statement below takes into account if token in or token out is WETH.  then the path is only 2 addresses\\n    address[] memory path;\\n    if (_tokenIn == WETH || _tokenOut == WETH) {\\n        path = new address[](2);\\n        path[0] = _tokenIn;\\n        path[1] = _tokenOut;\\n    } else {\\n        path = new address[](3);\\n        path[0] = _tokenIn;\\n        path[1] = WETH;\\n        path[2] = _tokenOut;\\n    }\\n        //then we will call swapExactTokensForTokens\\n        //for the deadline we will pass in block.timestamp\\n        //the deadline is the latest time the trade is valid for\\n    IUniswapV2Router(UNISWAP_V2_ROUTER).swapExactTokensForTokens(\\n      _amountIn,\\n      _amountOutMin,\\n      path,\\n      address(this),\\n      block.timestamp\\n      );\\n\\n      uint256 balance_in = IERC20(_tokenIn).balanceOf(address(this));\\n     \\n      uint256 balance_out = IERC20(_tokenOut).balanceOf(address(this));\\n   \\n     _records[_tokenIn].balance = balance_in;\\n     _records[_tokenOut].balance = balance_out;\\n  }\\n\\n  //swap using oneinch api\\n  \\n  function swapOneInch(\\n    address _tokenIn,\\n    address _tokenOut,\\n    uint256 amount,\\n    uint256 minReturn,\\n    bytes32[] calldata _data) \\n  external \\n  _digital_asset_managers_ \\n  {\\n      \\n  require(_records[_tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n  require(_records[_tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n     \\n  OneInchAgregator(ONEINCH_V4_AGREGATION_ROUTER).unoswap(_tokenIn,amount,minReturn,_data);\\n    \\n  uint256 balance_in = IERC20(_tokenIn).balanceOf(address(this));\\n  uint256 balance_out = IERC20(_tokenOut).balanceOf(address(this));\\n     \\n  _records[_tokenIn].balance = balance_in;\\n  _records[_tokenOut].balance = balance_out;\\n\\n  emit LOG_SWAP(_tokenIn,_tokenOut,amount);\\n\\n  }\\n\\n  function swapOneInchUniV3(\\n    address _tokenIn,\\n    address _tokenOut,\\n    uint256 amount,\\n    uint256 minReturn,\\n    uint256[] calldata _pools) \\n  external \\n  _digital_asset_managers_ \\n  {\\n      \\n  require(_records[_tokenIn].bound, \\\"ERR_NOT_BOUND\\\");\\n  require(_records[_tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n   \\n  OneInchAgregator(ONEINCH_V4_AGREGATION_ROUTER).uniswapV3Swap(amount,minReturn,_pools);\\n    \\n  uint256 balance_in = IERC20(_tokenIn).balanceOf(address(this));\\n  uint256 balance_out = IERC20(_tokenOut).balanceOf(address(this));\\n     \\n  _records[_tokenIn].balance = balance_in;\\n  _records[_tokenOut].balance = balance_out;\\n\\n  emit LOG_SWAP(_tokenIn,_tokenOut,amount);\\n\\n  }\\n\\n/* ==========  Config Queries  ========== */\\n  \\n  function setMintForge(address _mintForge) external  _control_ returns(address) {\\n    require (!_mint_forges[_mintForge],\\\"forge already added\\\");\\n    _mint_forges[_mintForge] = true;\\n  }\\n\\n  function setBurnForge(address _burnForge) external _control_ returns(address) {\\n    require (!_burn_forges[_burnForge],\\\"forge already added\\\");\\n    _burn_forges[_burnForge] = true;\\n  }\\n\\n   function removeMintForge(address _mintForge) external  _control_ returns(address) {\\n    require (_mint_forges[_mintForge],\\\"not forge \\\");\\n    delete _mint_forges[_mintForge];\\n  }\\n\\n  function removeBurnForge(address _burnForge) external _control_ returns(address) {\\n    require (_burn_forges[_burnForge],\\\"not forge \\\");\\n    delete _burn_forges[_burnForge];\\n  }\\n\\n  \\n\\n  /**\\n   * @dev Returns the controller address.\\n   */\\n  function getController() external view override returns (address) {\\n    return _controller;\\n  }\\n\\n/* ==========  Token Queries  ========== */\\n\\n  /**\\n   * @dev Check if a token is bound to the dynaset.\\n   */\\n  function isBound(address t) external view override returns (bool) {\\n    return _records[t].bound;\\n  }\\n\\n  /**\\n   * @dev Get the number of tokens bound to the dynaset.\\n   */\\n  function getNumTokens() external view override returns (uint256) {\\n    return _tokens.length;\\n  }\\n\\n  /**\\n   * @dev Returns the record for a token bound to the dynaset.\\n   */\\n  function getTokenRecord(address token)\\n    external\\n    view\\n    override\\n    returns (Record memory record)\\n  {\\n    record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n  }\\n\\n\\n/* ==========  Price Queries  ========== */\\n\\n\\n  function _setDesiredDenorm(address token, uint96 Denorm) internal {\\n    Record storage record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n    // If the desired weight is 0, this will trigger a gradual unbinding of the token.\\n    // Therefore the weight only needs to be above the minimum weight if it isn't 0.\\n    require(\\n      Denorm >= MIN_WEIGHT || Denorm == 0,\\n      \\\"ERR_MIN_WEIGHT\\\"\\n    );\\n    require(Denorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n    record.denorm = Denorm;\\n    emit LOG_DENORM_UPDATED(token,Denorm);\\n\\n  }\\n\\n\\n/* ==========  dynaset Share Internal Functions  ========== */\\n\\n  function _pulldynasetShare(address from, uint256 amount) internal {\\n    _pull(from, amount);\\n  }\\n\\n  function _pushdynasetShare(address to, uint256 amount) internal {\\n    _push(to, amount);\\n  }\\n\\n  function _mintdynasetShare(uint256 amount) internal {\\n    _mint(amount);\\n  }\\n\\n  function _burndynasetShare(uint256 amount) internal {\\n    _burn(amount);\\n  }\\n\\n/* ==========  Underlying Token Internal Functions  ========== */\\n  // 'Underlying' token-manipulation functions make external calls but are NOT locked\\n  // You must `_lock_` or otherwise ensure reentry-safety\\n\\n  function _pullUnderlying(\\n    address erc20,\\n    address from,\\n    uint256 amount\\n  ) internal {\\n\\n    IERC20(erc20).transferFrom(from,address(this),amount);\\n  }\\n\\n\\n  function _pushUnderlying(\\n    address erc20,\\n    address to,\\n    uint256 amount\\n  ) internal {\\n\\n    IERC20(erc20).transfer(to ,amount);\\n\\n  }\\n\\n\\n  function withdrawAnyTokens(address token,uint256 amount) \\n  external \\n  _control_ {\\n    IERC20 Token = IERC20(token);\\n   // uint256 currentTokenBalance = Token.balanceOf(address(this));\\n    Token.transfer(msg.sender, amount); \\n  }\\n\\n\\n/* ==========  Token Management Internal Functions  ========== */\\n\\n  /** \\n   * @dev Handles weight changes and initialization of an\\n   * input token.\\n   *\\n   * If the token is not initialized and the new balance is\\n   * still below the minimum, this will not do anything.\\n   *\\n   * If the token is not initialized but the new balance will\\n   * bring the token above the minimum balance, this will\\n   * mark the token as initialized, remove the minimum\\n   * balance and set the weight to the minimum weight plus\\n   * 1%.\\n   *\\n   *\\n   * @param token Address of the input token\\n   * and weight if the token was uninitialized.\\n   */\\n  function _updateInputToken(\\n    address token,\\n    uint256 realBalance\\n  )\\n    internal\\n  {\\n      // If the token is still not ready, do not adjust the weight.\\n    _records[token].balance = realBalance;\\n\\n  }\\n\\n\\n/* ==========  Token Query Internal Functions  ========== */\\n\\n  /**\\n   * @dev Get the record for a token which is being swapped in.\\n   * The token must be bound to the dynaset. If the token is not\\n   * initialized (meaning it does not have the minimum balance)\\n   * this function will return the actual balance of the token\\n   * which the dynaset holds, but set the record's balance and weight\\n   * to the token's minimum balance and the dynaset's minimum weight.\\n   * This allows the token swap to be priced correctly even if the\\n   * dynaset does not own any of the tokens.\\n   */\\n   function _getInputToken(address token)\\n    internal\\n    view\\n    returns (Record memory record, uint256 realBalance)\\n  {\\n    record = _records[token];\\n    require(record.bound, \\\"ERR_NOT_BOUND\\\");\\n\\n    realBalance = record.balance;\\n\\n  }\\n\\n\\n\\n  function calcTokensForAmount(uint256 _amount)\\n    external\\n    view\\n    returns (address[] memory tokens, uint256[] memory amounts)\\n  {\\n\\n    uint256 dynasetTotal = totalSupply();\\n    uint256 ratio = bdiv(_amount, dynasetTotal);\\n    require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n    // Underlying_token_amount = Ratio * token_balance_in_dynaset\\n    //   Ratio  = User_amount / Dynaset_token_supply \\n    tokens = _tokens;\\n    amounts = new uint256[](_tokens.length);\\n\\n    for (uint256 i = 0; i < _tokens.length; i++) {\\n      address t = tokens[i];\\n      (Record memory record, ) = _getInputToken(t);\\n      uint256 tokenAmountIn = bmul(ratio, record.balance);\\n      amounts[i] = tokenAmountIn;\\n    }\\n  }\\n\\n}\\n\\n\"\r\n    },\r\n    \"/Volumes/My Passport/SingularityDao/dynasets/Dynaset/contracts/interfaces/OneInchAgregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface OneInchAgregator {\\n    function unoswap(address srcToken,uint256 amount,uint256 minReturn,bytes32[] calldata _pools) external payable returns(uint256 returnAmount);\\n    function uniswapV3Swap(uint256 amount,uint256 minReturn,uint256[] calldata pools) external payable returns(uint256 returnAmount); \\n}\\n\"\r\n    },\r\n    \"/Volumes/My Passport/SingularityDao/dynasets/Dynaset/contracts/interfaces/IUniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\ninterface IUniswapV2Router {\\n\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function swapExactTokensForTokens(\\n\\n    //amount of tokens we are sending in\\n        uint256 amountIn,\\n    //the minimum amount of tokens we want out of the trade\\n        uint256 amountOutMin,\\n    //list of token addresses we are going to trade in.  this is necessary to calculate amounts\\n        address[] calldata path,\\n    //this is the address we are going to send the output tokens to\\n        address to,\\n    //the last time that the trade is valid for\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n}\"\r\n    },\r\n    \"/Volumes/My Passport/SingularityDao/dynasets/Dynaset/contracts/interfaces/IDynaset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\npragma experimental ABIEncoderV2;\\n\\n\\ninterface IDynaset {\\n  /**\\n   * @dev Token record data structure\\n   * @param bound is token bound to pool\\n   * @param ready has token been initialized\\n   * @param lastDenormUpdate timestamp of last denorm change\\n   * @param denorm denormalized weight\\n   * @param desiredDenorm desired denormalized weight (used for incremental changes)\\n   * @param index of address in tokens array\\n   * @param balance token balance\\n   */\\n  struct Record {\\n      bool bound;   // is token bound to dynaset\\n      bool ready;\\n      uint index;   // private\\n      uint96 denorm;  // denormalized weight\\n      uint256 balance;\\n  }\\n\\n  event LOG_SWAP(\\n    address indexed caller,\\n    address indexed tokenIn,\\n    address indexed tokenOut,\\n    uint256 tokenAmountIn,\\n    uint256 tokenAmountOut\\n  );\\n\\n  event LOG_JOIN(\\n    address indexed caller,\\n    address indexed tokenIn,\\n    uint256 tokenAmountIn\\n  );\\n\\n  event LOG_EXIT(\\n    address indexed caller,\\n    address indexed tokenOut,\\n    uint256 tokenAmountOut\\n  );\\n\\n  event LOG_DENORM_UPDATED(address indexed token, uint256 newDenorm);\\n\\n  event LOG_DESIRED_DENORM_SET(address indexed token, uint256 desiredDenorm);\\n\\n  event LOG_MINIMUM_BALANCE_UPDATED(address token, uint256 minimumBalance);\\n\\n  event LOG_TOKEN_READY(address indexed token);\\n\\n  event LOG_PUBLIC_SWAP_TOGGLED(bool enabled);\\n\\n  function configure(\\n    address controller,\\n    address dam,\\n    string calldata name,\\n    string calldata symbol\\n  ) external;\\n\\n  function initialize(\\n    address[] calldata tokens,\\n    uint256[] calldata balances,\\n    uint96[] calldata denorms,\\n    address tokenProvider\\n  ) external;\\n  \\n\\n  function reweighTokens(\\n    address[] calldata tokens,\\n    uint96[] calldata Denorms\\n  ) external;\\n\\n  function joinDynaset(uint256 _amount) external;\\n\\n  function exitDynaset(uint256 _amount) external;\\n\\n  //function updateAfterSwap(address token) external;\\n\\n  function getController() external view returns (address);\\n\\n  function isBound(address t) external view returns (bool);\\n\\n  function getNumTokens() external view returns (uint256);\\n\\n  function getCurrentTokens() external view returns (address[] memory tokens);\\n\\n  function getCurrentDesiredTokens() external view returns (address[] memory tokens);\\n\\n  function getDenormalizedWeight(address token) external view returns (uint256/* denorm */);\\n\\n  function getTokenRecord(address token) external view returns (Record memory record);\\n\\n  function getTotalDenormalizedWeight() external view returns (uint256);\\n\\n  function getBalance(address token) external view returns (uint256);\\n\\n}\"\r\n    },\r\n    \"/Volumes/My Passport/SingularityDao/dynasets/Dynaset/contracts/DToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\nimport \\\"./BNum.sol\\\";\\n\\n\\n/************************************************************************************************\\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BToken.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n\\n// Highly opinionated token implementation\\ninterface IERC20 {\\n  event Approval(address indexed src, address indexed dst, uint256 amt);\\n  event Transfer(address indexed src, address indexed dst, uint256 amt);\\n\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address whom) external view returns (uint256);\\n\\n  function allowance(address src, address dst) external view returns (uint256);\\n\\n  function approve(address dst, uint256 amt) external returns (bool);\\n\\n  function transfer(address dst, uint256 amt) external returns (bool);\\n\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint256 amt\\n  ) external returns (bool);\\n}\\n\\n\\ncontract DTokenBase is BNum {\\n  mapping(address => uint256) internal _balance;\\n  mapping(address => mapping(address => uint256)) internal _allowance;\\n  uint256 internal _totalSupply;\\n\\n  event Approval(address indexed src, address indexed dst, uint256 amt);\\n  event Transfer(address indexed src, address indexed dst, uint256 amt);\\n\\n  function _mint(uint256 amt) internal {\\n    _balance[address(this)] = badd(_balance[address(this)], amt);\\n    _totalSupply = badd(_totalSupply, amt);\\n    emit Transfer(address(0), address(this), amt);\\n  }\\n\\n  function _burn(uint256 amt) internal {\\n    require(_balance[address(this)] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n    _balance[address(this)] = bsub(_balance[address(this)], amt);\\n    _totalSupply = bsub(_totalSupply, amt);\\n    emit Transfer(address(this), address(0), amt);\\n  }\\n\\n  function _move(\\n    address src,\\n    address dst,\\n    uint256 amt\\n  ) internal {\\n    require(_balance[src] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n    _balance[src] = bsub(_balance[src], amt);\\n    _balance[dst] = badd(_balance[dst], amt);\\n    emit Transfer(src, dst, amt);\\n  }\\n\\n  function _push(address to, uint256 amt) internal {\\n    _move(address(this), to, amt);\\n  }\\n\\n  function _pull(address from, uint256 amt) internal {\\n    _move(from, address(this), amt);\\n  }\\n}\\n\\n\\ncontract DToken is DTokenBase, IERC20 {\\n  uint8 private constant DECIMALS = 18;\\n  string private _name;\\n  string private _symbol;\\n\\n  function _initializeToken(string memory name, string memory symbol) internal {\\n    require(\\n      bytes(_name).length == 0 &&\\n      bytes(name).length != 0 &&\\n      bytes(symbol).length != 0,\\n      \\\"ERR_BTOKEN_INITIALIZED\\\"\\n    );\\n    _name = name;\\n    _symbol = symbol;\\n  }\\n\\n  function name()\\n    external\\n    override\\n    view\\n    returns (string memory)\\n  {\\n    return _name;\\n  }\\n\\n  function symbol()\\n    external\\n    override\\n    view\\n    returns (string memory)\\n  {\\n    return _symbol;\\n  }\\n\\n  function decimals()\\n    external\\n    override\\n    view\\n    returns (uint8)\\n  {\\n    return DECIMALS;\\n  }\\n\\n  function allowance(address src, address dst)\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    return _allowance[src][dst];\\n  }\\n\\n  function balanceOf(address whom) external override view returns (uint256) {\\n    return _balance[whom];\\n  }\\n\\n  function totalSupply() public override view returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function approve(address dst, uint256 amt) external override returns (bool) {\\n    _allowance[msg.sender][dst] = amt;\\n    emit Approval(msg.sender, dst, amt);\\n    return true;\\n  }\\n\\n  function increaseApproval(address dst, uint256 amt) external returns (bool) {\\n    _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\\n    emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n    return true;\\n  }\\n\\n  function decreaseApproval(address dst, uint256 amt) external returns (bool) {\\n    uint256 oldValue = _allowance[msg.sender][dst];\\n    if (amt > oldValue) {\\n      _allowance[msg.sender][dst] = 0;\\n    } else {\\n      _allowance[msg.sender][dst] = bsub(oldValue, amt);\\n    }\\n    emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n    return true;\\n  }\\n\\n  function transfer(address dst, uint256 amt) external override returns (bool) {\\n    _move(msg.sender, dst, amt);\\n    return true;\\n  }\\n\\n  function transferFrom(\\n    address src,\\n    address dst,\\n    uint256 amt\\n  ) external override returns (bool) {\\n    require(\\n      msg.sender == src || amt <= _allowance[src][msg.sender],\\n      \\\"ERR_BTOKEN_BAD_CALLER\\\"\\n    );\\n    _move(src, dst, amt);\\n    if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\\n      _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\\n      emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\\n    }\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"/Volumes/My Passport/SingularityDao/dynasets/Dynaset/contracts/BNum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\nimport \\\"./BConst.sol\\\";\\n\\n\\n/************************************************************************************************\\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n\\ncontract BNum is BConst {\\n  function btoi(uint256 a) internal pure returns (uint256) {\\n    return a / BONE;\\n  }\\n\\n  function bfloor(uint256 a) internal pure returns (uint256) {\\n    return btoi(a) * BONE;\\n  }\\n\\n  function badd(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n    return c;\\n  }\\n\\n  function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    (uint256 c, bool flag) = bsubSign(a, b);\\n    require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n    return c;\\n  }\\n\\n  function bsubSign(uint256 a, uint256 b)\\n    internal\\n    pure\\n    returns (uint256, bool)\\n  {\\n    if (a >= b) {\\n      return (a - b, false);\\n    } else {\\n      return (b - a, true);\\n    }\\n  }\\n\\n  function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c0 = a * b;\\n    require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n    uint256 c1 = c0 + (BONE / 2);\\n    require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n    uint256 c2 = c1 / BONE;\\n    return c2;\\n  }\\n\\n  function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n    uint256 c0 = a * BONE;\\n    require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n    uint256 c1 = c0 + (b / 2);\\n    require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n    uint256 c2 = c1 / b;\\n    return c2;\\n  }\\n\\n  // DSMath.wpow\\n  function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\\n    uint256 z = n % 2 != 0 ? a : BONE;\\n\\n    for (n /= 2; n != 0; n /= 2) {\\n      a = bmul(a, a);\\n\\n      if (n % 2 != 0) {\\n        z = bmul(z, a);\\n      }\\n    }\\n    return z;\\n  }\\n\\n  // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n  // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n  // of approximation of b^0.w\\n  function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\\n    require(base >= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n    require(base <= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n    uint256 whole = bfloor(exp);\\n    uint256 remain = bsub(exp, whole);\\n\\n    uint256 wholePow = bpowi(base, btoi(whole));\\n\\n    if (remain == 0) {\\n      return wholePow;\\n    }\\n\\n    uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n    return bmul(wholePow, partialResult);\\n  }\\n\\n  function bpowApprox(\\n    uint256 base,\\n    uint256 exp,\\n    uint256 precision\\n  ) internal pure returns (uint256) {\\n    // term 0:\\n    uint256 a = exp;\\n    (uint256 x, bool xneg) = bsubSign(base, BONE);\\n    uint256 term = BONE;\\n    uint256 sum = term;\\n    bool negative = false;\\n\\n    // term(k) = numer / denom\\n    //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n    // each iteration, multiply previous term by (a-(k-1)) * x / k\\n    // continue until term is less than precision\\n    for (uint256 i = 1; term >= precision; i++) {\\n      uint256 bigK = i * BONE;\\n      (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n      term = bmul(term, bmul(c, x));\\n      term = bdiv(term, bigK);\\n      if (term == 0) break;\\n\\n      if (xneg) negative = !negative;\\n      if (cneg) negative = !negative;\\n      if (negative) {\\n        sum = bsub(sum, term);\\n      } else {\\n        sum = badd(sum, term);\\n      }\\n    }\\n\\n    return sum;\\n  }\\n}\\n\"\r\n    },\r\n    \"/Volumes/My Passport/SingularityDao/dynasets/Dynaset/contracts/BMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\nimport \\\"./BNum.sol\\\";\\n\\n\\n/************************************************************************************************\\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BMath.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n\\ncontract BMath is BConst, BNum {\\n  /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n  function calcSpotPrice(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 spotPrice) {\\n    uint256 numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n    uint256 denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n    uint256 ratio = bdiv(numer, denom);\\n    uint256 scale = bdiv(BONE, bsub(BONE, swapFee));\\n    return (spotPrice = bmul(ratio, scale));\\n  }\\n\\n  /**********************************************************************************************\\n    // calcOutGivenIn                                                                            //\\n    // aO = tokenAmountOut                                                                       //\\n    // bO = tokenBalanceOut                                                                      //\\n    // bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\      //\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\\n    // wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /      //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n  function calcOutGivenIn(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 tokenAmountIn,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountOut) {\\n    uint256 weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\\n    uint256 adjustedIn = bsub(BONE, swapFee);\\n    adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n    uint256 y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\\n    uint256 foo = bpow(y, weightRatio);\\n    uint256 bar = bsub(BONE, foo);\\n    tokenAmountOut = bmul(tokenBalanceOut, bar);\\n    return tokenAmountOut;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcInGivenOut                                                                            //\\n    // aI = tokenAmountIn                                                                        //\\n    // bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\                 //\\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /                 //\\n    // wI = tokenWeightIn           --------------------------------------------                 //\\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n  function calcInGivenOut(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 tokenAmountOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountIn) {\\n    uint256 weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\\n    uint256 diff = bsub(tokenBalanceOut, tokenAmountOut);\\n    uint256 y = bdiv(tokenBalanceOut, diff);\\n    uint256 foo = bpow(y, weightRatio);\\n    foo = bsub(foo, BONE);\\n    tokenAmountIn = bsub(BONE, swapFee);\\n    tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\\n    return tokenAmountIn;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcPoolOutGivenSingleIn                                                                  //\\n    // pAo = poolAmountOut         /                                              \\\\              //\\n    // tAi = tokenAmountIn        ///      /     //    wI \\\\      \\\\\\\\       \\\\     wI \\\\             //\\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\\\    --  \\\\            //\\n    // tW = totalWeight     pAo=||  \\\\      \\\\     \\\\\\\\    tW /      //         | ^ tW   | * pS - pS //\\n    // tBi = tokenBalanceIn      \\\\\\\\  ------------------------------------- /        /            //\\n    // pS = poolSupply            \\\\\\\\                    tBi               /        /             //\\n    // sF = swapFee                \\\\                                              /              //\\n    **********************************************************************************************/\\n  function calcPoolOutGivenSingleIn(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 tokenAmountIn,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 poolAmountOut) {\\n    // Charge the trading fee for the proportion of tokenAi\\n    ///  which is implicitly traded to the other pool tokens.\\n    // That proportion is (1- weightTokenIn)\\n    // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\\n    uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n    uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n    uint256 tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\\n\\n    uint256 newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\n    uint256 tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\n\\n    // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\\n    uint256 poolRatio = bpow(tokenInRatio, normalizedWeight);\\n    uint256 newPoolSupply = bmul(poolRatio, poolSupply);\\n    poolAmountOut = bsub(newPoolSupply, poolSupply);\\n    return poolAmountOut;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcSingleInGivenPoolOut                                                                  //\\n    // tAi = tokenAmountIn              //(pS + pAo)\\\\     /    1    \\\\\\\\                           //\\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\\n    // pAo = poolAmountOut              \\\\\\\\    pS    /     \\\\(wI / tW)//                           //\\n    // bI = balanceIn          tAi =  --------------------------------------------               //\\n    // wI = weightIn                              /      wI  \\\\                                   //\\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\\n    // sF = swapFee                               \\\\      tW  /                                   //\\n    **********************************************************************************************/\\n  function calcSingleInGivenPoolOut(\\n    uint256 tokenBalanceIn,\\n    uint256 tokenWeightIn,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 poolAmountOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountIn) {\\n    uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n    uint256 newPoolSupply = badd(poolSupply, poolAmountOut);\\n    uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n    //uint newBalTi = poolRatio^(1/weightTi) * balTi;\\n    uint256 boo = bdiv(BONE, normalizedWeight);\\n    uint256 tokenInRatio = bpow(poolRatio, boo);\\n    uint256 newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\n    uint256 tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\\n    // Do reverse order of fees charged in joinswap_ExternAmountIn, this way\\n    //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\\n    //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\\n    uint256 zar = bmul(bsub(BONE, normalizedWeight), swapFee);\\n    tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\\n    return tokenAmountIn;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcSingleOutGivenPoolIn                                                                  //\\n    // tAo = tokenAmountOut            /      /                                             \\\\\\\\   //\\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\\\     /    1    \\\\      \\\\\\\\  //\\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\\n    // ps = poolSupply                \\\\      \\\\\\\\          pS           /     \\\\(wO / tW)/      //  //\\n    // wI = tokenWeightIn      tAo =   \\\\      \\\\                                             //   //\\n    // tW = totalWeight                    /     /      wO \\\\       \\\\                             //\\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\\n    // eF = exitFee                        \\\\     \\\\      tW /       /                             //\\n    **********************************************************************************************/\\n  function calcSingleOutGivenPoolIn(\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 poolAmountIn,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 tokenAmountOut) {\\n    uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n    // charge exit fee on the pool token side\\n    // pAiAfterExitFee = pAi*(1-exitFee)\\n    uint256 poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));\\n    uint256 newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\\n    uint256 poolRatio = bdiv(newPoolSupply, poolSupply);\\n\\n    // newBalTo = poolRatio^(1/weightTo) * balTo;\\n    uint256 tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\\n    uint256 newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\\n\\n    uint256 tokenAmountOutBeforeSwapFee = bsub(\\n      tokenBalanceOut,\\n      newTokenBalanceOut\\n    );\\n\\n    // charge swap fee on the output token side\\n    //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\\n    uint256 zaz = bmul(bsub(BONE, normalizedWeight), swapFee);\\n    tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\\n    return tokenAmountOut;\\n  }\\n\\n  /**********************************************************************************************\\n    // calcPoolInGivenSingleOut                                                                  //\\n    // pAi = poolAmountIn               // /               tAo             \\\\\\\\     / wO \\\\     \\\\   //\\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\\\   | ---- |     \\\\  //\\n    // tAo = tokenAmountOut      pS - ||   \\\\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\\\ tW /  * pS | //\\n    // ps = poolSupply                 \\\\\\\\ -----------------------------------/                /  //\\n    // wO = tokenWeightOut  pAi =       \\\\\\\\               bO                 /                /   //\\n    // tW = totalWeight           -------------------------------------------------------------  //\\n    // sF = swapFee                                        ( 1 - eF )                            //\\n    // eF = exitFee                                                                              //\\n    **********************************************************************************************/\\n  function calcPoolInGivenSingleOut(\\n    uint256 tokenBalanceOut,\\n    uint256 tokenWeightOut,\\n    uint256 poolSupply,\\n    uint256 totalWeight,\\n    uint256 tokenAmountOut,\\n    uint256 swapFee\\n  ) internal pure returns (uint256 poolAmountIn) {\\n    // charge swap fee on the output token side\\n    uint256 normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n    //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\\n    uint256 zoo = bsub(BONE, normalizedWeight);\\n    uint256 zar = bmul(zoo, swapFee);\\n    uint256 tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\\n\\n    uint256 newTokenBalanceOut = bsub(\\n      tokenBalanceOut,\\n      tokenAmountOutBeforeSwapFee\\n    );\\n    uint256 tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\n\\n    //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\\n    uint256 poolRatio = bpow(tokenOutRatio, normalizedWeight);\\n    uint256 newPoolSupply = bmul(poolRatio, poolSupply);\\n    uint256 poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\\n\\n    // charge exit fee on the pool token side\\n    // pAi = pAiAfterExitFee/(1-exitFee)\\n    poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));\\n    return poolAmountIn;\\n  }\\n}\\n\"\r\n    },\r\n    \"/Volumes/My Passport/SingularityDao/dynasets/Dynaset/contracts/BConst.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.6.0;\\n\\n\\n/************************************************************************************************\\nOriginally from https://github.com/balancer-labs/balancer-core/blob/master/contracts/BConst.sol\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n\\ncontract BConst {\\n\\n\\n  uint256 public constant VERSION_NUMBER = 1;\\n\\n/* ---  Weight Updates  --- */\\n\\n  // Minimum time passed between each weight update for a token.\\n  uint256 internal constant WEIGHT_UPDATE_DELAY = 1 hours;\\n\\n  // Maximum percent by which a weight can adjust at a time\\n  // relative to the current weight.\\n  // The number of iterations needed to move from weight A to weight B is the floor of:\\n  // (A > B): (ln(A) - ln(B)) / ln(1.01)\\n  // (B > A): (ln(A) - ln(B)) / ln(0.99)\\n  uint256 internal constant WEIGHT_CHANGE_PCT = BONE/100;\\n\\n  uint256 internal constant BONE = 10**18;\\n\\n  uint256 internal constant MIN_BOUND_TOKENS = 2;\\n  uint256 internal constant MAX_BOUND_TOKENS = 10;\\n  // Minimum swap fee.\\n  uint256 internal constant MIN_FEE = BONE / 10**6;\\n  // Maximum swap or exit fee.\\n  uint256 internal constant MAX_FEE = BONE / 10;\\n  // Actual exit fee.\\n  uint256 internal constant EXIT_FEE = 5e15;\\n  \\n  // Minimum weight for any token (1/100).\\n  uint256 internal constant MIN_WEIGHT = BONE;\\n  uint256 internal constant MAX_WEIGHT = BONE * 50;\\n  // Maximum total weight.\\n  uint256 internal constant MAX_TOTAL_WEIGHT = BONE * 50;\\n  // Minimum balance for a token (only applied at initialization)\\n  uint256 internal constant MIN_BALANCE = BONE / 10**12;\\n  // Initial pool tokens\\n  uint256 internal constant INIT_POOL_SUPPLY = BONE * 100;\\n\\n  uint256 internal constant MIN_BPOW_BASE = 1 wei;\\n  uint256 internal constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\\n  uint256 internal constant BPOW_PRECISION = BONE / 10**10;\\n\\n  // Maximum ratio of input tokens to balance for swaps.\\n  uint256 internal constant MAX_IN_RATIO = BONE / 2;\\n  // Maximum ratio of output tokens to balance for swaps.\\n  uint256 internal constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LOG_CALL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDenorm\",\"type\":\"uint256\"}],\"name\":\"LOG_DENORM_UPDATED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"desiredDenorm\",\"type\":\"uint256\"}],\"name\":\"LOG_DESIRED_DENORM_SET\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumBalance\",\"type\":\"uint256\"}],\"name\":\"LOG_MINIMUM_BALANCE_UPDATED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"LOG_PUBLIC_SWAP_TOGGLED\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"LOG_TOKEN_READY\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ApproveOneInch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION_NUMBER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calcTokensForAmount\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dam\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"configure\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"exitDynaset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentDesiredTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getNormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenRecord\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"bound\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ready\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"denorm\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct IDynaset.Record\",\"name\":\"record\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint96[]\",\"name\":\"denorms\",\"type\":\"uint96[]\"},{\"internalType\":\"address\",\"name\":\"tokenProvider\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"isBound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"joinDynaset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_burnForge\",\"type\":\"address\"}],\"name\":\"removeBurnForge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mintForge\",\"type\":\"address\"}],\"name\":\"removeMintForge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint96[]\",\"name\":\"Denorms\",\"type\":\"uint96[]\"}],\"name\":\"reweighTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_burnForge\",\"type\":\"address\"}],\"name\":\"setBurnForge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mintForge\",\"type\":\"address\"}],\"name\":\"setMintForge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_data\",\"type\":\"bytes32[]\"}],\"name\":\"swapOneInch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_pools\",\"type\":\"uint256[]\"}],\"name\":\"swapOneInchUniV3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOutMin\",\"type\":\"uint256\"}],\"name\":\"swapUniswap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"}],\"name\":\"updateAfterSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAnyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Dynaset","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}