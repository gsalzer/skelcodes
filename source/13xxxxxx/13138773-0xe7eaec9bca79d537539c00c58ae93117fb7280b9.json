{"status":"1","message":"OK","result":[{"SourceCode":"{\"DogeProtocol.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./ERC20Detailed.sol\\\";\\n\\ncontract DogeProtocol is ERC20Detailed {\\n    \\n  string constant tokenNameWeNeed = \\\"Doge Protocol\\\";\\n  string constant tokenSymbol = \\\"dogep\\\";\\n  uint8 decimalsWeNeed = 18;\\n  \\n  uint256 totalSupplyWeNeed = 100 * (10**12) * (10**decimalsWeNeed);\\n  uint256  baseBurnPercentDivisor = 100000; //0.1% per transaction\\n\\n  //Saturday, April 30, 2022 11:59:59 PM\\n  uint256 tokenAllowedCutOffDate = 1651363199;  \\n  uint256 tokenAllowedPerAccount = 99 * (10**10) * (10**decimalsWeNeed);\\n  \\n  constructor(address priorApprovalContractAddress) public payable ERC20Detailed\\n  (\\n       tokenNameWeNeed, \\n       tokenSymbol, \\n       totalSupplyWeNeed,\\n       baseBurnPercentDivisor, \\n       decimalsWeNeed,\\n       tokenAllowedCutOffDate,\\n       tokenAllowedPerAccount,\\n       priorApprovalContractAddress\\n   ) \\n  {\\n    _mint(msg.sender, totalSupply());\\n  }\\n\\n  function multiTransfer(address[] memory receivers, uint256[] memory amounts) public {\\n    for (uint256 i = 0; i \\u003c receivers.length; i++) {\\n      transfer(receivers[i], amounts[i]);\\n    }\\n  }\\n\\n  \\n}\"},\"ERC20Detailed.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./PriorApprovalERC20.sol\\\";\\n\\ncontract ERC20Detailed is IERC20 {\\n    \\n  using SafeMath for uint256;\\n  mapping (address =\\u003e uint256) private _balances;\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowed;\\n\\n  uint256 private _totalSupply;\\n  uint256 private _basePercent = 100;\\n  uint256 private _baseBurnPercentDivisor;\\n  \\n  string private _name;\\n  string private _symbol;\\n  uint8 private _decimals;\\n  \\n  uint256 private _tokenAllowedCutOffDate;\\n  uint256 private _tokenAllowedPerAccount;\\n  \\n  address private _owner;\\n\\n  address private _priorApprovalContractAddress;\\n\\n  constructor\\n  (\\n      string memory name,\\n      string memory symbol,\\n      uint256 totalSupply,\\n      uint256 baseBurnPercentDivisor, \\n      uint8 decimals,\\n      uint256 tokenAllowedCutOffDate,\\n      uint256 tokenAllowedPerAccount,\\n      address priorApprovalContractAddress\\n  ) public {\\n    _name = name;\\n    _symbol = symbol;\\n    _totalSupply = totalSupply;\\n    _decimals = decimals;\\n    _baseBurnPercentDivisor = baseBurnPercentDivisor;\\n    _tokenAllowedCutOffDate = tokenAllowedCutOffDate;\\n    _tokenAllowedPerAccount = tokenAllowedPerAccount;\\n    _priorApprovalContractAddress = priorApprovalContractAddress;\\n  }\\n\\n  function name() public view returns(string memory) {\\n    return _name;\\n  }\\n\\n  function symbol() public view returns(string memory) {\\n    return _symbol;\\n  }\\n\\n  function decimals() public view returns(uint8) {\\n    return _decimals;\\n  }\\n  \\n  function totalSupply() public view virtual override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  function balanceOf(address owner) public view virtual override returns (uint256) {\\n    return _balances[owner];\\n  }\\n\\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n    return _allowed[owner][spender];\\n  }\\n\\n  //This function calculates number of tokens to burn, given an input number of tokens\\n  function calculateNumTokensToBurn(uint256 numTokens) public view returns (uint256)  {\\n    uint256 roundValue = numTokens.ceil(_basePercent);\\n    return roundValue.mul(_basePercent).div(_baseBurnPercentDivisor);\\n  }\\n\\n  function transfer(address to, uint256 value) public virtual override returns (bool) {\\n    require(value \\u003c= _balances[msg.sender]);\\n    require(to != address(0));\\n\\n    if(checkValidity(to, value) == false)\\n    {\\n        revert(\\\"Number of tokens exceeds allowed limit\\\");\\n    }\\n\\n    uint256 tokensToBurn = calculateNumTokensToBurn(value);\\n    uint256 tokensToTransfer = value.sub(tokensToBurn);\\n\\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\\n    _balances[to] = _balances[to].add(tokensToTransfer);\\n\\n    _totalSupply = _totalSupply.sub(tokensToBurn);\\n\\n    emit Transfer(msg.sender, to, tokensToTransfer);\\n    emit Transfer(msg.sender, address(0), tokensToBurn);\\n    \\n    return true;\\n  }\\n\\n  function approve(address spender, uint256 value) public virtual override returns (bool) {\\n    require(spender != address(0));\\n    \\n    if(checkValidity(spender, value) == false)\\n    {\\n        revert(\\\"Number of tokens exceeds allowed limit\\\");\\n    }\\n    \\n    _allowed[msg.sender][spender] = value;\\n    emit Approval(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  function transferFrom(address from, address to, uint256 value) public virtual override returns (bool) {\\n    require(value \\u003c= _balances[from]);\\n    require(value \\u003c= _allowed[from][msg.sender]);\\n    require(to != address(0));\\n\\n    _balances[from] = _balances[from].sub(value);\\n\\n    uint256 tokensToBurn = calculateNumTokensToBurn(value);\\n    uint256 tokensToTransfer = value.sub(tokensToBurn);\\n\\n    _balances[to] = _balances[to].add(tokensToTransfer);\\n    _totalSupply = _totalSupply.sub(tokensToBurn);\\n\\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n\\n    emit Transfer(from, to, tokensToTransfer);\\n    emit Transfer(from, address(0), tokensToBurn);\\n\\n    return true;\\n  }\\n\\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n    require(spender != address(0));\\n    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n    require(spender != address(0));\\n    _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  function _mint(address account, uint256 amount) internal {\\n    require(amount != 0);\\n    _owner = account;\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  function _burn(address account, uint256 amount) internal {\\n    require(amount != 0);\\n    require(amount \\u003c= _balances[account]);\\n    _totalSupply = _totalSupply.sub(amount);\\n    _balances[account] = _balances[account].sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n \\n    //This function is called to find whether the message sender is a token validate or not\\n    function checkValidity(address to, uint256 value)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        //If maximum allowed tokens in account exceeds limit\\n        uint256 estimatedBalanceAfterTxn = _balances[to] + value;\\n        if(estimatedBalanceAfterTxn \\u003c= _tokenAllowedPerAccount) {\\n            return true;\\n        }\\n                \\n        //If cutoff date exceeds\\n        if(block.timestamp \\u003e _tokenAllowedCutOffDate) {\\n            return true;\\n        }\\n        \\n        //Only exchanges like Swap liquidity pools can have higher amount\\n        //Hence this needs multi party approval \\n        if(PriorApprovalERC20(_priorApprovalContractAddress).verifyPriorApprovalERC20(to) == true) {\\n            return true;\\n        }\\n        \\n        return false;\\n    } \\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n  function balanceOf(address who) external view returns (uint256);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  function transfer(address to, uint256 value) external returns (bool);\\n  function approve(address spender, uint256 value) external returns (bool);\\n  function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"PriorApprovalERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\r\\n\\r\\ncontract PriorApprovalERC20 {\\r\\n\\r\\n    event OnPriorApproval (\\r\\n        address indexed receiver,\\r\\n        address indexed approver,\\r\\n        uint256 indexed blockTime\\r\\n    );\\r\\n\\r\\n    event OnPriorApprovalRemoval (        \\r\\n        address indexed receiver,\\r\\n        address indexed approver,\\r\\n        uint256 indexed blockTime\\r\\n    );\\r\\n\\r\\n    //List of addresses that can approve receivers to receive tokens sent from the Token Contract\\r\\n    address[] private _approverAddressList; \\r\\n\\r\\n    //Minimum number of approvals required for any address to receive tokens sent from the Token Contract\\r\\n    uint256 private _minimumApprovalCountRequired;\\r\\n    \\r\\n    //A map with key as receiver and value as approver. \\r\\n    //This map gets an entry when an approver approves a receiver\\r\\n    //The entry gets removed when approver revokes the approval\\r\\n    mapping(bytes32 =\\u003e bool) _receiverApproverMapping;\\r\\n\\r\\n    constructor(address[] memory approverAddressList, uint256 minimumApprovalCountRequired){\\r\\n         require(approverAddressList.length == 4, \\\"Approver count does not match the number of assigned approvers\\\");\\r\\n         require(minimumApprovalCountRequired == 3, \\\"Minimum approval count does not  match the number of assigned approvals\\\");\\r\\n        _approverAddressList = approverAddressList;\\r\\n        _minimumApprovalCountRequired = minimumApprovalCountRequired;\\r\\n    }\\r\\n\\r\\n    modifier restricted() {\\r\\n        require(isApprover() == true, \\\"Caller is not an approver\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    function append(address a, address c) internal pure returns (bytes32) {\\r\\n        return sha256(abi.encodePacked(a, c));\\r\\n    }\\r\\n\\r\\n    //This function is called when an approver makes a request to approve a receiver\\r\\n    function newPriorApprovalERC20(\\r\\n        address receiver) \\r\\n        external\\r\\n        restricted()\\r\\n    returns (bool)\\r\\n    {\\r\\n        _receiverApproverMapping[append(receiver, msg.sender)] = true;\\r\\n        emit OnPriorApproval(receiver, msg.sender, block.timestamp);\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    //This function is called when an approval makes a request to revoke an approval\\r\\n    function removePriorApprovalERC20(address receiver)\\r\\n        external\\r\\n        restricted()\\r\\n        returns (bool)\\r\\n    {\\r\\n        _receiverApproverMapping[append(receiver, msg.sender)] = false;\\r\\n        emit OnPriorApprovalRemoval(receiver, msg.sender, block.timestamp);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    //This function is called when you need to check whether the receiver is approved or not\\r\\n    function verifyPriorApprovalERC20(address receiver)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        uint256 approvalCount = 0; \\r\\n        uint arrayLength = _approverAddressList.length;\\r\\n        for (uint i = 0; i \\u003c arrayLength; i++) {\\r\\n            if(_receiverApproverMapping[append(receiver, _approverAddressList[i])] == true) {\\r\\n                approvalCount = approvalCount + 1;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        if(approvalCount \\u003e= _minimumApprovalCountRequired){\\r\\n            return true;\\r\\n        }\\r\\n        \\r\\n        return false;\\r\\n    }\\r\\n    \\r\\n    //This function is called to find whether an approver has approved a receiver or not\\r\\n    function getPriorApprovalERC20(address receiver, address approver)\\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            bool approved\\r\\n        )\\r\\n    {\\r\\n        approved = _receiverApproverMapping[append(receiver, approver)];\\r\\n    }\\r\\n\\r\\n\\r\\n    //This function is called to find whether the message sender is an approver or not\\r\\n    function isApprover()\\r\\n        private\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        uint arrayLength = _approverAddressList.length;\\r\\n        for (uint i = 0; i \\u003c arrayLength; i++) {\\r\\n            if(_approverAddressList[i] == msg.sender) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"\\n// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nlibrary SafeMath {\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    uint256 c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a / b;\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n\\n  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\\n    uint256 c = add(a,m);\\n    uint256 d = sub(c,1);\\n    return mul(div(d,m),m);\\n  }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"priorApprovalContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"name\":\"calculateNumTokensToBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"receivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"multiTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DogeProtocol","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007815afee871ca3d331939baa75fcb4656c4e901f","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://53d29d6433fec3e8a45435fc89c0682f6dc96265c2ab74f5167da9d4f5b04d79"}]}