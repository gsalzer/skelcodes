{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/v0/libraries/Calculator.sol\": {\r\n      \"content\": \"/**\\n * Submitted for verification at Etherscan.io on 2021-12-23\\n */\\n\\n// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.4;\\n\\nlibrary Calculator {\\n    struct Result {\\n        uint256 tokensAmount;\\n        uint256 maintainerBonusTokensAmount;\\n        uint256 bountyBonusTokensAmount;\\n        uint256 nextNodeId;\\n        uint256 nextPricePerToken;\\n    }\\n\\n    // solhint-disable-next-line contract-name-camelcase\\n    struct _LoopState {\\n        uint256 prev;\\n        uint256 curr;\\n        uint256 next;\\n    }\\n\\n    uint8 public constant DECIMALS = 18;\\n\\n    uint256 public constant MAINTAINER_BONUS_PRICE_THRESHOLD =\\n        10 * 10**DECIMALS;\\n\\n    uint256 public constant BOUNTY_BONUS_PRICE_THRESHOLD = 20 * 10**DECIMALS;\\n\\n    function adjustNodeId(\\n        uint256 nodeId,\\n        uint256 supply,\\n        uint256[] storage supplyLUT\\n    ) public view returns (uint256) {\\n        if (supply < supplyLUT[nodeId + 1]) {\\n            if (supply < supplyLUT[nodeId]) {\\n                while (true) {\\n                    nodeId -= 1;\\n                    if (supply >= supplyLUT[nodeId]) {\\n                        return nodeId;\\n                    }\\n                }\\n            }\\n        } else {\\n            while (true) {\\n                nodeId += 1;\\n                if (supply < supplyLUT[nodeId + 1]) {\\n                    return nodeId;\\n                }\\n            }\\n        }\\n\\n        return nodeId;\\n    }\\n\\n    // solhint-disable-next-line function-max-lines\\n    function calcTokens(\\n        uint256 usdAmount,\\n        uint256 supply,\\n        uint256 nodeId,\\n        bool suppressMaintainerBonus,\\n        bool suppressBountyBonus,\\n        uint256[] storage supplyLUT,\\n        uint256[] storage priceLUT\\n    ) public view returns (Result memory r) {\\n        require(\\n            supply >= supplyLUT[nodeId] && supply < supplyLUT[nodeId + 1],\\n            \\\"nodeId is out of sync\\\"\\n        );\\n\\n        r.nextNodeId = nodeId;\\n\\n        _LoopState memory supplyNode = _LoopState(0, supply, 0);\\n        _LoopState memory priceNode = _LoopState(0, 0, 0);\\n\\n        while (true) {\\n            supplyNode.prev = supplyLUT[r.nextNodeId];\\n            supplyNode.next = supplyLUT[r.nextNodeId + 1];\\n\\n            priceNode.prev = priceLUT[r.nextNodeId];\\n            priceNode.next = priceLUT[r.nextNodeId + 1];\\n\\n            priceNode.curr = _approxPricePerToken(supplyNode, priceNode);\\n\\n            uint256 usdAmountMaxed = usdAmount * 10**DECIMALS;\\n            uint256 tokensByIteration;\\n\\n            if (\\n                supplyNode.next - supplyNode.curr >\\n                (2 * usdAmountMaxed) / (priceNode.next + priceNode.curr)\\n            ) {\\n                _LoopState memory adjustedSupplyNode = _LoopState(\\n                    supplyNode.prev,\\n                    supplyNode.curr +\\n                        usdAmountMaxed /\\n                        (priceNode.next + priceNode.curr),\\n                    supplyNode.next\\n                );\\n\\n                tokensByIteration =\\n                    usdAmountMaxed /\\n                    _approxPricePerToken(adjustedSupplyNode, priceNode);\\n\\n                r.tokensAmount += tokensByIteration;\\n                supplyNode.curr += tokensByIteration;\\n\\n                usdAmount = 0;\\n            }\\n            else {\\n                tokensByIteration = supplyNode.next - supplyNode.curr;\\n\\n                r.tokensAmount += tokensByIteration;\\n                supplyNode.curr = supplyNode.next;\\n                r.nextNodeId += 1;\\n\\n                usdAmount -=\\n                    (tokensByIteration *\\n                        ((priceNode.curr + priceNode.next) / 2)) /\\n                    10**DECIMALS;\\n            }\\n\\n            if (\\n                false == suppressMaintainerBonus &&\\n                priceNode.curr >= MAINTAINER_BONUS_PRICE_THRESHOLD\\n            ) {\\n                r.maintainerBonusTokensAmount += tokensByIteration / 10;\\n                supplyNode.curr += tokensByIteration / 10;\\n            }\\n\\n            if (\\n                false == suppressBountyBonus &&\\n                priceNode.curr >= BOUNTY_BONUS_PRICE_THRESHOLD\\n            ) {\\n                r.bountyBonusTokensAmount += tokensByIteration / 10;\\n                supplyNode.curr += tokensByIteration / 10;\\n            }\\n\\n            r.nextNodeId = adjustNodeId(\\n                r.nextNodeId,\\n                supplyNode.curr,\\n                supplyLUT\\n            );\\n\\n            if (usdAmount == 0) break;\\n        }\\n\\n        r.nextPricePerToken = _approxPricePerToken(supplyNode, priceNode);\\n    }\\n\\n    function _approxPricePerToken(\\n        _LoopState memory supplyNode,\\n        _LoopState memory priceNode\\n    ) private pure returns (uint256) {\\n        return\\n            ((supplyNode.curr - supplyNode.prev) *\\n                (priceNode.next - priceNode.prev)) /\\n            (supplyNode.next - supplyNode.prev) +\\n            priceNode.prev;\\n    }\\n}\\n\\n// Copyright 2021 ToonCoin.COM\\n// http://tooncoin.com/license\\n// Full source code: http://tooncoin.com/sourcecode\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"evmVersion\": \"berlin\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"BOUNTY_BONUS_PRICE_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAINTAINER_BONUS_PRICE_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Calculator","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}