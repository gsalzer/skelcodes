{"status":"1","message":"OK","result":[{"SourceCode":"{\"Aggregate.sol\":{\"content\":\"\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\n\\n    /// @title A Fee on Transfer token with automatic reflections to holders.\\n    /// @notice Token contract inheriting ERC20 standard with basic access\\n    /// control and emergency pause mechanism. The token contract implements\\n    /// Fee on Transfer distributed among marketing wallet, acquisition wallets,\\n    /// and all token holders (via reflections) on Buy / Sell transactions\\n    /// only. Wallet-to-wallet transfers do not incur a fee on transfer.\\ncontract Aggregate is ERC20, Pausable, Ownable {\\n\\n    //--------------------------State Variables---------------------------------\\n\\n    struct FeeValues {\\n          uint256 Amount;\\n          uint256 TransferAmount;\\n          uint256 ReflectFee;\\n          uint256 MarketingFee;\\n          uint256 AcquisitionFee;\\n      }\\n    enum MarketSide {\\n      NONE,\\n      BUY,\\n      SELL\\n    }\\n\\n    mapping (address =\\u003e uint256) private _rOwned;\\n    mapping (address =\\u003e uint256) private _tOwned;\\n    mapping (address =\\u003e bool) private _isExcluded;\\n    address[] private _excluded;\\n    uint256 private _tTotal;\\n    uint256 private _rTotal;\\n    uint256 private _tFeeTotal;\\n\\n    address private _marketingWallet;\\n    address[5] private _acquisitionWallets;\\n    mapping (address =\\u003e bool) private _isExchange;\\n\\n    uint8 private _buyFeeReflect;\\n    uint8 private _buyFeeMarketing;\\n    uint8 private _buyFeeAcquisition;\\n    uint8 private _sellFeeReflect;\\n    uint8 private _sellFeeMarketing;\\n    uint8 private _sellFeeAcquisition;\\n\\n    //--------------------------Constructor-------------------------------------\\n\\n    /// @notice Sets the values for name, symbol, totalSupply, marketingWallet,\\n    /// and acquisitionWallets. Initial allocation: 95% to Admin account (for\\n    /// liquidity), 2% to Marketing wallet, 3% to Acquisition wallets.\\n    /// @param name_ is token name.\\n    /// @param symbol_ is token symbol.\\n    /// @param supply_ is total token supply.\\n    /// @param marketing_ is inital marketing wallet address.\\n    /// @param acquisition_ is list of initial 5 acquisition wallet addresses.\\n    constructor (\\n      string memory name_,\\n      string memory symbol_,\\n      uint256 supply_,\\n      address marketing_,\\n      address[] memory acquisition_\\n      ) {\\n\\n      _name = name_;\\n      _symbol = symbol_;\\n      _tTotal = supply_ * 10**4;\\n      _rTotal = (~uint256(0) - (~uint256(0) % _tTotal));\\n      _buyFeeReflect = 1;\\n      _buyFeeMarketing = 1;\\n      _buyFeeAcquisition = 7;\\n      _sellFeeReflect = 5;\\n      _sellFeeMarketing = 1;\\n      _sellFeeAcquisition = 3;\\n      _marketingWallet = marketing_;\\n      for(uint i = 0; i \\u003c _acquisitionWallets.length; i++) {\\n        _acquisitionWallets[i] = acquisition_[i];\\n      }\\n\\n      _tOwned[_msgSender()] += _tTotal * 95 / 100;\\n      _rOwned[_msgSender()] += _rTotal / 100 * 95;\\n      emit Transfer(address(0), _msgSender(), _tOwned[_msgSender()]);\\n\\n      _tOwned[_marketingWallet] += _tTotal * 2 / 100;\\n      _rOwned[_marketingWallet] += _rTotal / 100 * 2;\\n      emit Transfer(address(0), _marketingWallet, _tTotal * 2 / 100);\\n\\n      for(uint i = 0; i \\u003c _acquisitionWallets.length; i++){\\n        _tOwned[_acquisitionWallets[i]] +=\\n          _tTotal * 3 / 100 / _acquisitionWallets.length;\\n        _rOwned[_acquisitionWallets[i]] +=\\n          _rTotal / 100 * 3 / _acquisitionWallets.length;\\n\\n        emit Transfer(\\n          address(0),\\n          _acquisitionWallets[i],\\n          _tTotal * 3 / 100 / _acquisitionWallets.length\\n          );\\n      }\\n\\n    }\\n\\n    //--------------------------ERC20 Override Functions------------------------\\n\\n    /// @notice See {IERC20-totalSupply}.\\n    /// @dev Overrides ERC20 totalSupply function.\\n    /// @return supply_ is total token supply.\\n    function totalSupply() public view override returns (uint256) {\\n        return _tTotal;\\n    }\\n\\n    /// @notice See {IERC20-balanceOf}.\\n    /// @dev Overrides ERC20 balanceOf function. If account is excluded then\\n    /// _tOwned balance is returned since that tracks token balance without\\n    /// reflections. Otherwise, _rOwned balance is returned after scaling down\\n    /// by reflection rate.\\n    /// @param account is address to be checked for token balance.\\n    /// @return balance_ is token balance of \\u0027account\\u0027.\\n    function balanceOf(address account) public view override returns (uint256) {\\n        if (_isExcluded[account]) return _tOwned[account];\\n        return tokenFromReflection(_rOwned[account]);\\n    }\\n\\n    /// @notice Number of decimals for token representation.\\n    /// @dev Overrides ERC20 decimals function. Value of 4 decimals is required\\n    /// to maintain precision of arithmetic operations for reflection fee\\n    /// distributions, given the token supply.\\n    /// @return decimals_ is number of decimals for display purposes.\\n    function decimals() public pure override returns (uint8) {\\n        return 4;\\n    }\\n\\n    /// @notice See {IERC20-transfer}.\\n    /// @dev Overrides ERC20 _transfer function. Requires \\u0027sender\\u0027 and\\n    /// \\u0027recipient\\u0027 to be non-zero address to prevent minting/burning and\\n    /// non-zero transfer amount. Function determines transaction type \\u0027BUY\\u0027,\\n    /// \\u0027SELL\\u0027, or \\u0027NONE\\u0027 depending on whether sender or recipient is exchange\\n    /// pair address. Actual token transfer is delegated to {_transferStandard}.\\n    /// Function is pausable by token administrator.\\n    /// @param sender is address sending token.\\n    /// @param recipient is address receiving token.\\n    /// @param amount is number of tokens being transferred.\\n    function _transfer(\\n      address sender,\\n      address recipient,\\n      uint256 amount\\n      ) internal override whenNotPaused {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        require(amount \\u003e 0, \\\"ERC20: transfer amount must be greater than zero\\\");\\n        uint256 senderBalance = balanceOf(sender);\\n        require(senderBalance \\u003e= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n\\n        MarketSide _side;\\n        if(_isExchange[sender]){\\n            _side = MarketSide.BUY;\\n        } else if(_isExchange[recipient]) {\\n            _side = MarketSide.SELL;\\n        } else {\\n            _side = MarketSide.NONE;\\n        }\\n\\n        _transferStandard(sender, recipient, amount, _side);\\n    }\\n\\n    //--------------------------View Functions----------------------------------\\n\\n    /// @notice Provides scaled down amount based on current reflection rate.\\n    /// @dev Helper function for balanceOf function. Scales down a given amount,\\n    /// inclusive of reflections, by reflection rate.\\n    /// @param rAmount is the amount, inclusive of reflections, to be scaled\\n    /// down by reflection rate.\\n    /// @return tAmount_ is amount scaled down by current reflection rate.\\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\\n        require(rAmount \\u003c= _rTotal, \\\"Amount must be less than total supply\\\");\\n        uint256 currentRate =  _getRate();\\n        return rAmount / currentRate;\\n    }\\n\\n    /// @notice Allows checking whether an account has been excluded from\\n    /// receiving reflection distributions.\\n    /// @param account is address to be checked if excluded from reflections.\\n    /// @return excluded_ is true if account is excluded, otherwise, returns\\n    /// false.\\n    function isExcluded(address account) public view returns (bool) {\\n        return _isExcluded[account];\\n    }\\n\\n    /// @notice Returns which address is receiving marketing fees\\n    /// from \\u0027BUY\\u0027 / \\u0027SELL\\u0027 transactions.\\n    function getMarketingWallet() public view returns (address){\\n      return _marketingWallet;\\n    }\\n\\n    /// @notice Returns which address is receiving acquisition fees\\n    /// from \\u0027BUY\\u0027 / \\u0027SELL\\u0027 transactions at a given index.\\n    /// @param index is number between 0 - 4 representing wallets 1 through 5.\\n    function getAcquisitionWallet(uint256 index) public view returns (address){\\n      require(index \\u003c _acquisitionWallets.length, \\\"Invalid index\\\");\\n      return _acquisitionWallets[index];\\n    }\\n\\n    /// @notice Allows to view total amount of reflection fees collected since\\n    /// contract creation.\\n    /// @return totalFees_ is total reflection fees collected.\\n    function totalFees() public view returns (uint256) {\\n        return _tFeeTotal;\\n    }\\n\\n    //--------------------------Token Transfer----------------------------------\\n\\n    /// @dev Updates _rOwned and _tOwned balances after deducting applicable\\n    /// transaction fees and allocates fees to marketing and acquisition\\n    /// wallets. {_getValues} helper function calculates all relevant amounts.\\n    /// Emits a {Transfer} event after the balances have been updated.\\n    /// @param sender is address sending token.\\n    /// @param recipient is address receiving token.\\n    /// @param tAmount is number of tokens being transferred.\\n    /// @param _side is transaction type: \\u0027BUY\\u0027, \\u0027SELL\\u0027, \\u0027NONE\\u0027.\\n    function _transferStandard(\\n      address sender,\\n      address recipient,\\n      uint256 tAmount,\\n      MarketSide _side\\n      ) private {\\n\\n        (\\n          FeeValues memory _tValues,\\n          FeeValues memory _rValues\\n          ) = _getValues(tAmount, _side);\\n\\n        if(_isExcluded[sender]){\\n          _tOwned[sender] -= _tValues.Amount;\\n          _rOwned[sender] -= _rValues.Amount;\\n        } else {\\n          _rOwned[sender] -= _rValues.Amount;\\n        }\\n\\n        if(_isExcluded[recipient]){\\n          _tOwned[recipient] += _tValues.TransferAmount;\\n          _rOwned[recipient] += _rValues.TransferAmount;\\n        } else {\\n          _rOwned[recipient] += _rValues.TransferAmount;\\n        }\\n        emit Transfer(sender, recipient, _tValues.TransferAmount);\\n\\n        if(_side != MarketSide.NONE){\\n          _reflectFee(_rValues.ReflectFee, _tValues.ReflectFee);\\n          if(_tValues.MarketingFee \\u003e 0) {\\n            if(_isExcluded[_marketingWallet]){\\n              _tOwned[_marketingWallet] += _tValues.MarketingFee;\\n              _rOwned[_marketingWallet] += _rValues.MarketingFee;\\n            } else {\\n              _rOwned[_marketingWallet] += _rValues.MarketingFee;\\n            }\\n            emit Transfer(sender, _marketingWallet, _tValues.MarketingFee);\\n          }\\n\\n          if(_tValues.AcquisitionFee \\u003e 0) {\\n            _acquisitionWalletAlloc(\\n              sender, _tValues.AcquisitionFee,\\n              _rValues.AcquisitionFee\\n              );\\n          }\\n        }\\n    }\\n\\n    /// @dev Allocates the acquisition wallet fees to each of the five\\n    /// acquisition addresses in equal proportion.\\n    /// @param sender is address sending token.\\n    /// @param tAmount is amount of tokens to be allocated.\\n    /// @param rAmount is scaled up amount, inclusive of reflections, of tokens\\n    /// to be allocated.\\n    function _acquisitionWalletAlloc(\\n      address sender,\\n      uint256 tAmount,\\n      uint256 rAmount\\n      ) private {\\n        uint256 _tAllocation = tAmount / _acquisitionWallets.length;\\n        uint256 _rAllocation = rAmount / _acquisitionWallets.length;\\n\\n        for(uint i = 0; i \\u003c _acquisitionWallets.length; i++){\\n          if(_isExcluded[_acquisitionWallets[i]]){\\n            _tOwned[_acquisitionWallets[i]] += _tAllocation;\\n            _rOwned[_acquisitionWallets[i]] += _rAllocation;\\n          } else {\\n            _rOwned[_acquisitionWallets[i]] += _rAllocation;\\n          }\\n          emit Transfer(sender, _acquisitionWallets[i], _tAllocation);\\n        }\\n    }\\n\\n    //--------------------------Fee Calculation---------------------------------\\n\\n    /// @dev Updates {_rTotal} supply by subtracting reflection fees. Updates\\n    /// {_tFeeTotal} to add reflection fees. This is used to update the\\n    /// reflection rate to calculate users\\u0027 balances included in reflection.\\n    /// @param rFee Scaled up reflection fees from transaction\\n    /// @param tFee Actual reflection fees from transaction\\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\\n        _rTotal = _rTotal - rFee;\\n        _tFeeTotal = _tFeeTotal + tFee;\\n    }\\n\\n    /// @dev Calculates the required fees to be deducted for given transaction\\n    /// amount and transaction type.\\n    /// @param tAmount is the amount being transferred by user.\\n    /// @param _side is the transaction type: {BUY}, {SELL}, {NONE}.\\n    /// @return tValues_ is the calculated actual fee values for transfer\\n    /// amount {tAmount}.\\n    function _getValues(\\n      uint256 tAmount,\\n      MarketSide _side\\n      ) private view returns (\\n        FeeValues memory tValues_,\\n        FeeValues memory rValues_\\n        ) {\\n\\n        uint256 currentRate =  _getRate();\\n        FeeValues memory _tValues = _getTValues(tAmount, _side);\\n        FeeValues memory _rValues = _getRValues(_tValues, currentRate);\\n\\n        return (_tValues, _rValues);\\n    }\\n\\n    /// @dev Function call {_getFeeValues} to obtain the relevant fee\\n    /// percentage for the {_side} transaction type. Calculates the actual\\n    /// marketing, acquistion, and reflection fees to be deducted from the\\n    /// transfer amount.\\n    /// @param tAmount is the amount being transferred by user.\\n    /// @param _side is the transaction type: \\u0027BUY\\u0027, \\u0027SELL\\u0027, \\u0027NONE\\u0027.\\n    function _getTValues(\\n      uint256 tAmount,\\n      MarketSide _side\\n      ) private view returns (FeeValues memory) {\\n        (\\n          uint8 feeReflect_,\\n          uint8 feeMarketing_,\\n          uint8 feeAcquisition_\\n          ) = _getFeeValues(_side);\\n\\n        FeeValues memory _tValues;\\n        _tValues.Amount = tAmount;\\n        _tValues.ReflectFee = tAmount * feeReflect_ / 100;\\n        _tValues.MarketingFee = tAmount * feeMarketing_ / 100;\\n        _tValues.AcquisitionFee = tAmount * feeAcquisition_ / 100;\\n        _tValues.TransferAmount =\\n          _tValues.Amount\\n          - _tValues.ReflectFee\\n          - _tValues.MarketingFee\\n          - _tValues.AcquisitionFee;\\n\\n        return (_tValues);\\n    }\\n\\n    /// @dev Scales up the actual transaction fees {_tValues} by reflection\\n    /// rate to allow proper update of _rOwned user balance.\\n    /// @param _tValues is the struct containing actual transfer amount and\\n    /// fees to be deducted.\\n    /// @param currentRate is current reflection rate.\\n    function _getRValues(\\n      FeeValues memory _tValues,\\n      uint256 currentRate\\n      ) private pure returns (FeeValues memory) {\\n\\n        FeeValues memory _rValues;\\n        _rValues.Amount = _tValues.Amount * currentRate;\\n        _rValues.ReflectFee = _tValues.ReflectFee * currentRate;\\n        _rValues.MarketingFee = _tValues.MarketingFee * currentRate;\\n        _rValues.AcquisitionFee = _tValues.AcquisitionFee * currentRate;\\n        _rValues.TransferAmount =\\n          _rValues.Amount\\n          - _rValues.ReflectFee\\n          - _rValues.MarketingFee\\n          - _rValues.AcquisitionFee;\\n\\n        return (_rValues);\\n    }\\n\\n    /// @dev Calculates the reflection rate based on rSupply and rSupply. As\\n    /// reflection fees are deducted from rSupply by {_reflectFee} function,\\n    /// the reflection rate will decrease, causing users\\u0027 balances to increase\\n    /// by the reflection fee in proportion to the user\\u0027s balance / total supply\\n    function _getRate() private view returns (uint256) {\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\n        return rSupply / tSupply;\\n    }\\n\\n    /// @dev Calculates the transaction fee percentages depending on whether\\n    /// user is buying, selling, or transferring the token.\\n    /// @param _side is the transaction type: \\u0027BUY\\u0027, \\u0027SELL\\u0027, \\u0027NONE\\u0027.\\n    function _getFeeValues(MarketSide _side) private view returns (\\n      uint8,\\n      uint8,\\n      uint8\\n      ) {\\n        if(_side == MarketSide.BUY){\\n            return (_buyFeeReflect, _buyFeeMarketing, _buyFeeAcquisition);\\n        } else if(_side == MarketSide.SELL){\\n            return (_sellFeeReflect, _sellFeeMarketing, _sellFeeAcquisition);\\n        } else {\\n            return (0, 0, 0);\\n        }\\n    }\\n\\n    /// @dev Calculates the scaled up and actual token supply exclusive of\\n    /// excluded addresses. This impacts the reflection rate (greater decrease)\\n    /// to allow included addresses to receive reflections that would have gone\\n    /// to excluded accounts.\\n    function _getCurrentSupply() private view returns (uint256, uint256) {\\n        uint256 rSupply = _rTotal;\\n        uint256 tSupply = _tTotal;\\n        for (uint256 i = 0; i \\u003c _excluded.length; i++) {\\n          if (_rOwned[_excluded[i]] \\u003e rSupply || _tOwned[_excluded[i]] \\u003e tSupply)\\n          return (_rTotal, _tTotal);\\n\\n          rSupply = rSupply - _rOwned[_excluded[i]];\\n          tSupply = tSupply - _tOwned[_excluded[i]];\\n        }\\n        if (rSupply \\u003c _rTotal / _tTotal) return (_rTotal, _tTotal);\\n        return (rSupply, tSupply);\\n    }\\n\\n    //--------------------------Restricted Functions----------------------------\\n\\n    /// @notice Sets the exchange pair address for the token to detect \\u0027BUY\\u0027,\\n    /// \\u0027SELL\\u0027, or \\u0027NONE\\u0027 transactions for fee collection. Can only be updated\\n    /// by administrator.\\n    /// @dev Only transactions to, and from this address will trigger fee\\n    /// collection.\\n    /// @param exchangePair is the DEX-created contract address of the\\n    /// exchange pair.\\n    function setExchange(address exchangePair) external onlyOwner {\\n        require(!_isExchange[exchangePair], \\\"Address already Exchange\\\");\\n        _isExchange[exchangePair] = true;\\n    }\\n\\n    /// @notice Removes an exchange pair address from fee collection. Can\\n    /// only be updated by administrator.\\n    /// @param exchangePair is the DEX-created contract address of the exchange\\n    /// pair to be removed as an \\\"exchange\\\" for fee collection.\\n    function removeExchange(address exchangePair) external onlyOwner {\\n        require(_isExchange[exchangePair], \\\"Address not Exchange\\\");\\n        _isExchange[exchangePair] = false;\\n    }\\n\\n    /// @notice Changes marketing wallet address to receive marketing fee going\\n    /// forward. Can only be updated by administrator.\\n    /// @param newAddress is the new address to replace existing\\n    /// marketing wallet address.\\n    function changeMarketing(address newAddress) external onlyOwner {\\n        require(newAddress != address(0), \\\"Address cannot be zero address\\\");\\n        _marketingWallet = newAddress;\\n    }\\n\\n    /// @notice Changes acquisition wallets address to receive acquisition fee\\n    /// going forward. Can only be updated by administrator.\\n    /// @param index is the acquisition wallet address to be replaced,\\n    /// from 0 to 4.\\n    /// @param newAddress is the new address to replace existing\\n    /// acquisition wallet address.\\n    function changeAcquisition(\\n      uint256 index,\\n      address newAddress\\n      ) external onlyOwner {\\n        require(index \\u003c _acquisitionWallets.length, \\\"Invalid index value\\\");\\n        require(newAddress != address(0), \\\"Address cannot be zero address\\\");\\n        _acquisitionWallets[index] = newAddress;\\n    }\\n\\n    /// @notice Changes the reflection, marketing, and acquisition fee\\n    /// percentages to be deducted from \\u0027BUY\\u0027 transaction type. Can only be\\n    /// updated by administrator.\\n    /// @param reflectFee is the new reflection fee percentage.\\n    /// @param marketingFee is the new marketing fee percentage.\\n    /// @param acquisitionFee is the new acquisition fee percentage.\\n    function setBuyFees(\\n      uint8 reflectFee,\\n      uint8 marketingFee,\\n      uint8 acquisitionFee\\n      ) external onlyOwner {\\n        require(reflectFee + marketingFee + acquisitionFee \\u003c 100,\\n          \\\"Total fee percentage must be less than 100%\\\"\\n          );\\n\\n        _buyFeeReflect = reflectFee;\\n        _buyFeeMarketing = marketingFee;\\n        _buyFeeAcquisition = acquisitionFee;\\n    }\\n\\n    /// @notice Changes the reflection, marketing, and acquisition fee\\n    /// percentages to be deducted from {SELL} transaction type. Can only be\\n    /// updated by administrator.\\n    /// @param reflectFee is the new reflection fee percentage.\\n    /// @param marketingFee is the new marketing fee percentage.\\n    /// @param acquisitionFee is the new acquisition fee percentage.\\n    function setSellFees(\\n      uint8 reflectFee,\\n      uint8 marketingFee,\\n      uint8 acquisitionFee\\n      ) external onlyOwner {\\n        require(reflectFee + marketingFee + acquisitionFee \\u003c 100,\\n          \\\"Total fee percentage must be less than 100%\\\"\\n          );\\n\\n        _sellFeeReflect = reflectFee;\\n        _sellFeeMarketing = marketingFee;\\n        _sellFeeAcquisition = acquisitionFee;\\n    }\\n\\n    /// @notice Removes address from receiving future reflection distributions.\\n    /// Can only be updated by administrator.\\n    /// @param account is address to be excluded from reflections.\\n    function excludeAccount(address account) external onlyOwner {\\n        require(!_isExcluded[account], \\\"Account already excluded\\\");\\n        require(balanceOf(account) \\u003c _tTotal, \\\"Cannot exclude total supply\\\");\\n         _tOwned[account] = balanceOf(account);\\n         _excluded.push(account);\\n        _isExcluded[account] = true;\\n    }\\n\\n    /// @notice Includes previously excluded address to receive reflection\\n    /// distributions in case of erroneously excluded address. NOTE: Included\\n    /// address will receive all previous reflection distribution it should\\n    /// have received while address was excluded. Can only be updated by\\n    /// administrator.\\n    /// @param account is address to be re-included to reflections.\\n    function includeAccount(address account) external onlyOwner {\\n      require(_isExcluded[account], \\\"Account already included\\\");\\n\\n      for (uint256 i = 0; i \\u003c _excluded.length; i++) {\\n        if (_excluded[i] == account) {\\n          _excluded[i] = _excluded[_excluded.length - 1];\\n          _excluded.pop();\\n          _isExcluded[account] = false;\\n          break;\\n        }\\n      }\\n    }\\n\\n    /// @notice Pauses token transfer functionality in case of emergency.\\n    /// Can only be updated by administrator.\\n    function lockToken() external onlyOwner {\\n        _pause();\\n    }\\n\\n    /// @notice Unpauses token transfer functionality to allow users to\\n    /// transfer token. Can only be updated by administrator.\\n    function unlockToken() external onlyOwner {\\n        _unpause();\\n    }\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context {\\n    mapping(address =\\u003e uint256) internal _balances;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) internal _allowances;\\n\\n    uint256 internal _totalSupply;\\n\\n    string internal _name;\\n    string internal _symbol;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     * @return decimal_ is number of decimals for display purposes.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance \\u003e= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n        /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance \\u003e= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance \\u003e= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"},\"Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     * @return status is current pause status. Returns true if contract is paused, otherwise, returns false.\\n     */\\n    function paused() public view virtual returns (bool status) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"supply_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"marketing_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"acquisition_\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeAcquisition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeMarketing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getAcquisitionWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangePair\",\"type\":\"address\"}],\"name\":\"removeExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"reflectFee\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"marketingFee\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"acquisitionFee\",\"type\":\"uint8\"}],\"name\":\"setBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangePair\",\"type\":\"address\"}],\"name\":\"setExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"reflectFee\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"marketingFee\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"acquisitionFee\",\"type\":\"uint8\"}],\"name\":\"setSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Aggregate","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000091ffdff74ba00000000000000000000000090b63e54b5447b32d068cfe2bff713f248e99a900000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000a41676772656761746520000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005414747524f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000000000000abfa45313805fd8eaa4e4999b88183883db6b22d000000000000000000000000a0813b1a5e797446447481045bb8fc24c6721db1000000000000000000000000ff6311fba0e08b321ac4969f82dba39ec4f0fd0200000000000000000000000013f5ea4873900d11986352291242a0ab5634105b000000000000000000000000043413e871fb523a04cdd5076609448c7b338d23","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://15e5f899a19c958cfdf76b385ad390959c51c38e4b234a05ab9403337192a564"}]}