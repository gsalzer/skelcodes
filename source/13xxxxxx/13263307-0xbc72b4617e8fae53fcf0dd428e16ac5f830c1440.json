{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.8.7;\r\n\r\ninterface KeeperCompatibleInterface {\r\n    function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\r\n    function performUpkeep(bytes calldata performData) external;\r\n}\r\n\r\n\r\ncontract OusdKeeper is KeeperCompatibleInterface {\r\n    struct Config {\r\n        uint24 windowStart;\r\n        uint24 windowEnd;\r\n    }\r\n    address constant vault = 0xE75D77B1865Ae93c7eaa3040B038D7aA7BC02F70;\r\n    uint24 immutable windowStart; // seconds after start of day\r\n    uint24 immutable windowEnd; // seconds after start of day\r\n    uint256 lastRunDay = 0;\r\n\r\n    constructor(\r\n        uint24 _windowStart,\r\n        uint24 _windowEnd\r\n    ) {\r\n        windowStart = _windowStart;\r\n        windowEnd = _windowEnd;\r\n    }\r\n\r\n    function checkUpkeep(bytes calldata checkData)\r\n        external\r\n        view\r\n        override\r\n        returns (bool upkeepNeeded, bytes memory performData)\r\n    {\r\n        // If either can run, let's go!\r\n        (bool runRebase, bool runAllocate) = _shouldRun(checkData);\r\n        upkeepNeeded = (runRebase || runAllocate);\r\n        performData = checkData;\r\n    }\r\n\r\n    function performUpkeep(bytes calldata performData) external override {\r\n        (bool runRebase, bool runAllocate) = _shouldRun(performData);\r\n        if (runRebase || runAllocate) {\r\n            // write today, so that we only run once per day\r\n            lastRunDay = (block.timestamp / 86400);\r\n        }\r\n        \r\n        // Allocate before rebase, so the rebase picks up the harvested rewards.\r\n        // \r\n        // Both commands run and do not revert if they fail so that the last run\r\n        // day is still written the keepers do empty their gas running the\r\n        // failing method over and over again.\r\n\r\n        if (runAllocate) {\r\n            vault.call(abi.encodeWithSignature(\"allocate()\"));\r\n        }\r\n        if (runRebase) {\r\n            vault.call(abi.encodeWithSignature(\"rebase()\"));\r\n        }\r\n    }\r\n\r\n    function _shouldRun(bytes memory performData)\r\n        internal\r\n        view\r\n        returns (bool runRebase, bool runAllocate)\r\n    {\r\n        // Have we run today?\r\n        uint256 day = block.timestamp / 86400;\r\n        if (lastRunDay >= day) {\r\n            return (false, false);\r\n        }\r\n\r\n        // Are we in the window?\r\n        uint256 daySeconds = block.timestamp % 86400;\r\n        if (daySeconds < windowStart || daySeconds > windowEnd) {\r\n            return (false, false);\r\n        }\r\n\r\n        // Load schedule\r\n        require(performData.length == 2, \"Wrong schedule format\");\r\n        uint8 rebaseDays = uint8(performData[0]); // day of week bits\r\n        uint8 allocateDays = uint8(performData[1]); // day of week bits\r\n\r\n        // Weekday\r\n        uint8 weekday = uint8((day + 4) % 7);\r\n        // Need a rebase?\r\n        if (((rebaseDays >> weekday) & 1) != 0) {\r\n            runRebase = true;\r\n        }\r\n        // Need an allocate?\r\n        if (((allocateDays >> weekday) & 1) != 0) {\r\n            runAllocate = true;\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"_windowStart\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"_windowEnd\",\"type\":\"uint24\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OusdKeeper","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000624d00000000000000000000000000000000000000000000000000000000000065d1","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://96446e926c07826619ae1f2db4856df743530f6b2ff2f1f98a3253ca951c1771"}]}