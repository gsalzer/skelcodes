{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"brink-verifiers/Verifiers/CancelVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.8.10;\\npragma abicoder v1;\\n\\n/**\\n *    ,,                           ,,                                \\n *   *MM                           db                      `7MM      \\n *    MM                                                     MM      \\n *    MM,dMMb.      `7Mb,od8     `7MM      `7MMpMMMb.        MM  ,MP'\\n *    MM    `Mb       MM' \\\"'       MM        MM    MM        MM ;Y   \\n *    MM     M8       MM           MM        MM    MM        MM;Mm   \\n *    MM.   ,M9       MM           MM        MM    MM        MM `Mb. \\n *    P^YbmdP'      .JMML.       .JMML.    .JMML  JMML.    .JMML. YA.\\n *\\n *    CancelVerifier.sol :: 0xE0670a90E67eda0126D54843267b27Ca6343B2d8\\n *    etherscan.io verified 2021-12-18\\n */ \\n\\nimport \\\"../Libraries/Bit.sol\\\";\\n\\n/// @title Verifier for cancellation of messages signed with a bitmapIndex and bit\\n/// @notice Uses the Bit library to use the bit, which invalidates messages signed with the same bit\\ncontract CancelVerifier {\\n  event Cancel (uint256 bitmapIndex, uint256 bit);\\n\\n  /// @dev Cancels existing messages signed with bitmapIndex and bit\\n  /// @param bitmapIndex The bitmap index to use\\n  /// @param bit The bit to use\\n  function cancel(uint256 bitmapIndex, uint256 bit) external {\\n    Bit.useBit(bitmapIndex, bit);\\n    emit Cancel(bitmapIndex, bit);\\n  }\\n}\\n\"\r\n    },\r\n    \"brink-verifiers/Libraries/Bit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity =0.8.10;\\npragma abicoder v1;\\n\\n/// @title Bit replay protection library\\n/// @notice Handles storage and loads for replay protection bits\\n/// @dev Solution adapted from https://github.com/PISAresearch/metamask-comp/blob/77fa8295c168ee0b6bf801cbedab797d6f8cfd5d/src/contracts/BitFlipMetaTransaction/README.md\\n/// @dev This is a gas optimized technique that stores up to 256 replay protection bits per bytes32 slot\\nlibrary Bit {\\n  /// @dev Revert when bit provided is not valid\\n  error InvalidBit();\\n\\n  /// @dev Revert when bit provided is used\\n  error BitUsed();\\n\\n  /// @dev Initial pointer for bitmap storage ptr computation\\n  /// @notice This is the uint256 representation of keccak(\\\"bmp\\\")\\n  uint256 constant INITIAL_BMP_PTR = \\n  48874093989078844336340380824760280705349075126087700760297816282162649029611;\\n\\n  /// @dev Adds a bit to the uint256 bitmap at bitmapIndex\\n  /// @dev Value of bit cannot be zero and must represent a single bit\\n  /// @param bitmapIndex The index of the uint256 bitmap\\n  /// @param bit The value of the bit within the uint256 bitmap\\n  function useBit(uint256 bitmapIndex, uint256 bit) internal {\\n    if (!validBit(bit)) {\\n      revert InvalidBit();\\n    }\\n    bytes32 ptr = bitmapPtr(bitmapIndex);\\n    uint256 bitmap = loadUint(ptr);\\n    if (bitmap & bit != 0) {\\n      revert BitUsed();\\n    }\\n    uint256 updatedBitmap = bitmap | bit;\\n    assembly { sstore(ptr, updatedBitmap) }\\n  }\\n\\n  /// @dev Check that a bit is valid\\n  /// @param bit The bit to check\\n  /// @return isValid True if bit is greater than zero and represents a single bit\\n  function validBit(uint256 bit) internal pure returns (bool isValid) {\\n    assembly {\\n      // equivalent to: isValid = (bit > 0 && bit & bit-1) == 0;\\n      isValid := and(\\n        iszero(iszero(bit)), \\n        iszero(and(bit, sub(bit, 1)))\\n      )\\n    } \\n  }\\n\\n  /// @dev Get a bitmap storage pointer\\n  /// @return The bytes32 pointer to the storage location of the uint256 bitmap at bitmapIndex\\n  function bitmapPtr (uint256 bitmapIndex) internal pure returns (bytes32) {\\n    return bytes32(INITIAL_BMP_PTR + bitmapIndex);\\n  }\\n\\n  /// @dev Returns the uint256 value at storage location ptr\\n  /// @param ptr The storage location pointer\\n  /// @return val The uint256 value at storage location ptr\\n  function loadUint(bytes32 ptr) internal view returns (uint256 val) {\\n    assembly { val := sload(ptr) }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"BitUsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBit\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bitmapIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bit\",\"type\":\"uint256\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bitmapIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bit\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CancelVerifier","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"800","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}