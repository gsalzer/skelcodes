{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/CrystalsMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"./Interfaces.sol\\\";\\n\\n// takes crystal data and shapes it for our eyes\\ncontract CrystalsMetadata is ICrystalsMetadata {\\n    using strings for string;\\n    using strings for strings.slice;\\n\\n    string public description;\\n\\n    ICrystals public iCrystals;\\n\\n    uint32 private constant GEN_THRESH = 10000000;\\n    uint32 private constant glootOffset = 9997460;\\n    string private constant cursedSuffixes =\\n        \\\"of Nightmares,of Darkness,of Death,of Doom,of Madness,of Temptation,of the Underworld,of Corruption,of Revelation\\\";\\n    string private constant suffixes =\\n        \\\"of Power,of Giants,of Titans,of Skill,of Perfection,of Brilliance,of Enlightenment,of Protection,of Anger,of Rage,of Fury,of Vitriol,of the Fox,of Detection,of Reflection,of the Twins,of Relevance,of the Rift\\\";\\n    string private constant colors =\\n        \\\"Beige,Blue,Green,Red,Cyan,Yellow,Orange,Pink,Gray,White,Purple\\\";\\n    string private constant specialColors =\\n        \\\"Aqua,black,Crimson,Ghostwhite,Indigo,Turquoise,Maroon,Magenta,Fuchsia,Firebrick,Hotpink\\\";\\n    string private constant slabs = \\\"&#9698;,&#9699;,&#9700;,&#9701;\\\";\\n\\n    uint8 private constant presuffLength = 9;\\n    uint8 private constant suffixesLength = 18;\\n    uint8 private constant colorsLength = 11;\\n    uint8 private constant slabsLength = 4;\\n\\n    constructor(address crystalsAddress) {\\n        description = \\\"Mana Crystals from the Rift\\\";\\n        iCrystals = ICrystals(crystalsAddress);\\n    }\\n\\n    function tokenURI(uint256 tokenId) override external view returns (string memory) {\\n        require(iCrystals.crystalsMap(tokenId).focus > 0, \\\"INV\\\");\\n\\n        uint256 rows = iCrystals.crystalsMap(tokenId).attunement;\\n\\n        if (rows > 10) {\\n          rows = rows % 10;\\n\\n          if (rows == 0) {\\n            rows = 10;\\n          }\\n        }\\n\\n        string memory output;\\n\\n        output = string(\\n            abi.encodePacked(\\n                '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 350 350\\\"><style>text{fill:',\\n                getColor(tokenId),\\n                \\\";font-family:serif;font-size:14px}.slab{transform:rotate(180deg)translate(75px, 79px);transform-origin:bottom right;font-size:\\\",\\n                toString(160 / rows),\\n                'px;}</style><rect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"',\\n                getBG(tokenId),\\n                '\\\" /><text x=\\\"10\\\" y=\\\"20\\\">',\\n                getName(tokenId)\\n            )\\n        );\\n\\n        output = string(\\n            abi.encodePacked(\\n                output,\\n                '</text><text x=\\\"10\\\" y=\\\"40\\\">Attunement: ',\\n                toString(iCrystals.crystalsMap(tokenId).attunement),\\n                '</text><text x=\\\"10\\\" y=\\\"60\\\">Focus: ',\\n                toString(iCrystals.crystalsMap(tokenId).focus),\\n                '</text><text x=\\\"10\\\" y=\\\"80\\\">Resonance: ',\\n                toString(iCrystals.getResonance(tokenId)),\\n                '</text><text x=\\\"10\\\" y=\\\"100\\\">Spin: ',\\n                toString(iCrystals.getSpin(tokenId)),\\n                '</text>',\\n                getSlabs(tokenId, rows),\\n                '</svg>'\\n            )\\n        );\\n\\n        string memory prefix = string(\\n            abi.encodePacked(\\n                '{\\\"id\\\": ',\\n                toString(tokenId),\\n                ', \\\"name\\\": \\\"#',\\n                toString(tokenId),\\n                '\\\", \\\"bagId\\\": ',\\n                toString(tokenId % GEN_THRESH),\\n                ', \\\"description\\\": \\\"This crystal vibrates with energy from the Rift!\\\", \\\"background_color\\\": \\\"000000\\\", \\\"attributes\\\": [{ \\\"trait_type\\\": \\\"Focus\\\", \\\"value\\\":',\\n                toString(iCrystals.crystalsMap(tokenId).focus),\\n                ' }, { \\\"trait_type\\\": \\\"Resonance\\\", \\\"value\\\": ',\\n                toString(iCrystals.getResonance(tokenId)),\\n                ' }, { \\\"trait_type\\\": \\\"Spin\\\", \\\"value\\\": '\\n        ));\\n\\n        string memory attributes = string(\\n            abi.encodePacked(\\n                toString(iCrystals.getSpin(tokenId)),\\n                ' }, { \\\"trait_type\\\": \\\"Loot Type\\\", \\\"value\\\": \\\"',\\n                getLootType(tokenId),\\n                '\\\" }, { \\\"trait_type\\\": \\\"Surface\\\", \\\"value\\\": \\\"',\\n                getSurfaceType(tokenId),\\n                '\\\" }, { \\\"trait_type\\\": \\\"Attunement\\\", \\\"value\\\": ',\\n                toString(iCrystals.crystalsMap(tokenId).attunement),\\n                ' }, { \\\"trait_type\\\": \\\"Color\\\", \\\"value\\\": \\\"',\\n                getColor(tokenId)\\n        ));\\n\\n        return string(\\n            abi.encodePacked(\\\"data:application/json;base64,\\\", Base64.encode(bytes(string(\\n                abi.encodePacked(\\n                    prefix,\\n                    attributes,\\n                    '\\\" }], \\\"image\\\": \\\"data:image/svg+xml;base64,',\\n                    Base64.encode(bytes(output)), '\\\"}'\\n                )\\n        )))));\\n    }\\n\\n    function getBG(uint256 tokenId) internal view returns (string memory) {\\n        uint256 r = 100 / uint256(iCrystals.crystalsMap(tokenId).focus);\\n        uint256 d = r * diffDays(iCrystals.crystalsMap(tokenId).lastClaim, block.timestamp);\\n        if (d < 10) {\\n            return \\\"#000000\\\";\\n        }\\n        if (d < 40) {\\n            return \\\"#2C2C2C\\\";\\n        }\\n        if (d < 60) {\\n            return \\\"#686868\\\";\\n        }\\n        if (d < 80 ) {\\n            return \\\"#9F9F9F\\\";\\n        }\\n        if (d < 95) {\\n            return \\\"#DEDEDE\\\";\\n        }\\n\\n        return \\\"#FFFFFF\\\";\\n    }\\n\\n    /// @dev returns random number based on the tokenId\\n    function getRandom(uint256 tokenId, string memory key)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return random(string(abi.encodePacked(\\n            tokenId,\\n            key,\\n            iCrystals.crystalsMap(tokenId).regNum\\n        )));\\n    }\\n\\n    /// @dev returns random roll based on the tokenId\\n    function getRoll(\\n        uint256 tokenId,\\n        string memory key,\\n        uint256 size,\\n        uint256 times\\n    ) internal view returns (uint256) {\\n        return ((getRandom(tokenId, key) % size) + 1) * times;\\n    }\\n\\n    function getColor(uint256 tokenId) public view returns (string memory) {\\n        if (getRoll(tokenId, \\\"%CLR_RARITY\\\", 20, 1) > 18) {\\n            return getItemFromCSV(\\n                specialColors,\\n                getRandom(tokenId, \\\"%CLR\\\") % colorsLength\\n            );\\n        }\\n\\n        return getItemFromCSV(colors, getRandom(tokenId, \\\"%CLR\\\") % colorsLength);\\n    }\\n\\n    function getName(uint256 tokenId) public view returns (string memory output) {\\n        // check original seed to determine name type\\n        if ((tokenId % GEN_THRESH) > 8000 && (tokenId % GEN_THRESH) <= glootOffset) {\\n            output = getBasicName(tokenId);\\n        } else {\\n            output = getLootName(tokenId);\\n        }\\n\\n        return output;\\n    }\\n\\n    function getBasicName(uint256 tokenId)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        uint256 rand = getRandom(tokenId, \\\"%NAME\\\");\\n        uint256 alignment = getRoll(tokenId, \\\"%ALIGN\\\", 20, 1);\\n\\n        string memory surface = getSurfaceType(tokenId);\\n        string memory suffix = \\\"\\\";\\n        string memory prefix = \\\"\\\";\\n        \\n        if (\\n            alignment == 10\\n            && getRoll(tokenId, \\\"%CLR_RARITY\\\", 20, 1) == 10\\n        ) {\\n            prefix = \\\"Average\\\";\\n        }\\n        \\n        if (alignment < 5) {\\n          suffix = getItemFromCSV(cursedSuffixes, rand % presuffLength);\\n        } else if (alignment > 15) {\\n          suffix = getItemFromCSV(suffixes, rand % suffixesLength);\\n        }\\n\\n        return string(abi.encodePacked(prefix, \\\" \\\", surface, \\\" Crystal \\\", suffix));\\n    }\\n\\n    function getLootName(uint256 tokenId)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        uint256 rand = getRandom(tokenId, \\\"%NAME\\\");\\n        uint256 alignment = getRoll(tokenId, \\\"%ALIGN\\\", 20, 1);\\n\\n        string memory surface = getSurfaceType(tokenId);\\n        string memory suffix = \\\"\\\";\\n        string memory prefix = \\\"\\\";\\n        \\n        if (\\n            alignment == 10\\n            && getRoll(tokenId, \\\"%CLR_RARITY\\\", 20, 1) == 10\\n        ) {\\n            prefix = \\\"Perfectly Average\\\";\\n        } else if (alignment == 20) {\\n            prefix = \\\"Divine\\\";\\n        } else if (alignment == 1) {\\n            prefix = \\\"Demonic\\\";\\n        }\\n        \\n        if (alignment < 5) {\\n          suffix = getItemFromCSV(cursedSuffixes, rand % presuffLength);\\n        } else if (alignment > 15) {\\n          suffix = getItemFromCSV(suffixes, rand % suffixesLength);\\n        }\\n\\n        return string(abi.encodePacked(prefix, \\\" \\\", surface, \\\" Crystal \\\", suffix));\\n    }\\n\\n    function getSurfaceType(uint256 tokenId)\\n        internal\\n        view\\n        returns (string memory) \\n    {\\n        uint256 rand = getRandom(tokenId, \\\"%SURFACE\\\");\\n        uint256 alignment = getRoll(tokenId, \\\"%ALIGN\\\", 20, 1);\\n\\n        if (alignment < 6) {\\n            return getItemFromCSV(\\\"Broken,Twisted,Cracked,Fragmented,Splintered,Beaten,Ruined\\\", rand % 7);\\n        } else if (alignment > 15) {\\n            return getItemFromCSV(\\\"Gleaming,Glowing,Shiny,Luminous,Radiant,Brilliant\\\", rand % 6);\\n        } else {\\n            return getItemFromCSV(\\\"Dull,Smooth,Faceted,Glassy,Polished,\\\", rand % 5);\\n        }\\n    }\\n\\n    function getSlabs(uint256 tokenId) external view returns (string memory output) {\\n        uint256 rows = iCrystals.crystalsMap(tokenId).attunement;\\n\\n        if (rows > 10) {\\n          rows = rows % 10;\\n\\n          if (rows == 0) {\\n            rows = 10;\\n          }\\n        }\\n\\n        output = '';\\n\\n        for (uint256 i = 0; i < rows; i++) {\\n            for (uint256 j = 0; j < rows; j++) {\\n                output = string(abi.encodePacked(output, getSlab(tokenId, i, j)));\\n            }\\n            output = string(abi.encodePacked(output, '\\\\n'));\\n        }\\n\\n        return output;\\n    }\\n\\n    function getSlabs(uint256 tokenId, uint256 rows) private view returns (string memory output) {\\n        output = '';\\n\\n        for (uint256 i = 0; i < rows; i++) {\\n            output = string(\\n                abi.encodePacked(\\n                    output,\\n                    '<text class=\\\"slab\\\" x=\\\"285\\\" y=\\\"',\\n                    toString((415 + (rows * 4)) - (160 / rows * i)),\\n                    '\\\">'\\n            ));\\n\\n            for (uint256 j = 0; j < rows; j++) {\\n                output = string(abi.encodePacked(output, getSlab(tokenId, i, j)));\\n            }\\n\\n            output = string(abi.encodePacked(output, '</text>'));\\n        }\\n\\n        return output;\\n    }\\n\\n    function getSlab(uint256 tokenId, uint256 x, uint256 y) internal view returns (string memory output) {\\n        output = getItemFromCSV(\\n                        slabs,\\n                        getRandom(\\n                            tokenId,\\n                            string(abi.encodePacked(\\\"SLAB_\\\", toString(x), \\\"_\\\", toString(y)))\\n                        ) % slabsLength\\n                    );\\n\\n        return output;\\n    }\\n\\n    function getLootType(uint256 tokenId) public pure returns (string memory) {\\n        uint256 oSeed = tokenId % GEN_THRESH;\\n        if (oSeed > 0 && oSeed < 8001) {\\n            return 'Loot';\\n        }\\n\\n        if (oSeed > glootOffset) {\\n            return 'gLoot';\\n        }\\n\\n        return 'mLoot';\\n    }\\n\\n    function getItemFromCSV(string memory str, uint256 index)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        strings.slice memory strSlice = str.toSlice();\\n        string memory separatorStr = \\\",\\\";\\n        strings.slice memory separator = separatorStr.toSlice();\\n        strings.slice memory item;\\n        for (uint256 i = 0; i <= index; i++) {\\n            item = strSlice.split(separator);\\n        }\\n        return item.toString();\\n    }\\n\\n    function random(string memory input) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(input, \\\"%RIFT-OPEN\\\")));\\n    }\\n\\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        require(fromTimestamp <= toTimestamp);\\n        return (toTimestamp - fromTimestamp) / (24 * 60 * 60);\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT license\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint i) internal pure returns (string memory) {\\n        // https://stackoverflow.com/a/69302348/424107\\n        \\n        if (i == 0) return \\\"0\\\";\\n        uint j = i;\\n        uint length;\\n        while (j != 0) {\\n            length++;\\n            j = j >> 4;\\n        }\\n        uint mask = 15;\\n        bytes memory bstr = new bytes(length);\\n        uint k = length;\\n        while (i != 0) {\\n            uint curr = (i & mask);\\n            bstr[--k] = curr > 9 ?\\n                bytes1(uint8(55 + curr)) :\\n                bytes1(uint8(48 + curr)); // 55 = 65 - 10\\n            i = i >> 4;\\n        }\\n        return string(bstr);\\n    }\\n}\\n\\n/// @notice Calculates the square root of x, rounding down.\\n/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n/// @param x The uint256 number for which to calculate the square root.\\n/// @return result The result as an uint256.\\nfunction sqrt(uint256 x) pure returns (uint256 result) {\\n    if (x == 0) {\\n        return 0;\\n    }\\n\\n    // Calculate the square root of the perfect square of a power of two that is the closest to x.\\n    uint256 xAux = uint256(x);\\n    result = 1;\\n    if (xAux >= 0x100000000000000000000000000000000) {\\n        xAux >>= 128;\\n        result <<= 64;\\n    }\\n    if (xAux >= 0x10000000000000000) {\\n        xAux >>= 64;\\n        result <<= 32;\\n    }\\n    if (xAux >= 0x100000000) {\\n        xAux >>= 32;\\n        result <<= 16;\\n    }\\n    if (xAux >= 0x10000) {\\n        xAux >>= 16;\\n        result <<= 8;\\n    }\\n    if (xAux >= 0x100) {\\n        xAux >>= 8;\\n        result <<= 4;\\n    }\\n    if (xAux >= 0x10) {\\n        xAux >>= 4;\\n        result <<= 2;\\n    }\\n    if (xAux >= 0x8) {\\n        result <<= 1;\\n    }\\n\\n    // The operations can never overflow because the result is max 2^127 when it enters this block.\\n    unchecked {\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1; // Seven iterations should be enough\\n        uint256 roundedDownResult = x / result;\\n        return result >= roundedDownResult ? roundedDownResult : result;\\n    }\\n}\\n\\nlibrary strings {\\n    struct slice {\\n        uint256 _len;\\n        uint256 _ptr;\\n    }\\n\\n    function memcpy(\\n        uint256 dest,\\n        uint256 src,\\n        uint256 len\\n    ) private pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint256 mask = 256**(32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }\\n\\n    \\n    function toString(slice memory self) internal pure returns (string memory) {\\n        string memory ret = new string(self._len);\\n        uint256 retptr;\\n        assembly {\\n            retptr := add(ret, 32)\\n        }\\n\\n        memcpy(retptr, self._ptr, self._len);\\n        return ret;\\n    }\\n\\n    function findPtr(\\n        uint256 selflen,\\n        uint256 selfptr,\\n        uint256 needlelen,\\n        uint256 needleptr\\n    ) private pure returns (uint256) {\\n        uint256 ptr = selfptr;\\n        uint256 idx;\\n\\n        if (needlelen <= selflen) {\\n            if (needlelen <= 32) {\\n                bytes32 mask = bytes32(~(2**(8 * (32 - needlelen)) - 1));\\n\\n                bytes32 needledata;\\n                assembly {\\n                    needledata := and(mload(needleptr), mask)\\n                }\\n\\n                uint256 end = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly {\\n                    ptrdata := and(mload(ptr), mask)\\n                }\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr >= end) return selfptr + selflen;\\n                    ptr++;\\n                    assembly {\\n                        ptrdata := and(mload(ptr), mask)\\n                    }\\n                }\\n                return ptr;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly {\\n                    hash := keccak256(needleptr, needlelen)\\n                }\\n\\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\\n                    bytes32 testHash;\\n                    assembly {\\n                        testHash := keccak256(ptr, needlelen)\\n                    }\\n                    if (hash == testHash) return ptr;\\n                    ptr += 1;\\n                }\\n            }\\n        }\\n        return selfptr + selflen;\\n    }\\n\\n    function split(\\n        slice memory self,\\n        slice memory needle,\\n        slice memory token\\n    ) internal pure returns (slice memory) {\\n        uint256 ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = self._ptr;\\n        token._len = ptr - self._ptr;\\n        if (ptr == self._ptr + self._len) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n            self._ptr = ptr + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    function split(slice memory self, slice memory needle)\\n        internal\\n        pure\\n        returns (slice memory token)\\n    {\\n        split(self, needle, token);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\nstruct Bag {\\n    uint64 totalManaProduced;\\n    uint64 mintCount;\\n}\\n\\nstruct Crystal {\\n    uint16 attunement;\\n    uint64 lastClaim;\\n    uint16 focus;\\n    uint32 focusManaProduced;\\n    uint32 regNum;\\n    uint16 lvlClaims;\\n}\\n\\ninterface ICrystalsMetadata {\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ninterface ICrystals {\\n    function crystalsMap(uint256 tokenID) external view returns (Crystal memory);\\n    function bags(uint256 tokenID) external view returns (Bag memory);\\n    function getResonance(uint256 tokenId) external view returns (uint32);\\n    function getSpin(uint256 tokenId) external view returns (uint32);\\n    function claimableMana(uint256 tokenID) external view returns (uint32);\\n    function availableClaims(uint256 tokenId) external view returns (uint8);\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n}\\n\\n/// [MIT License]\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\nlibrary Base64 {\\n    bytes internal constant TABLE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF)\\n                )\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF)\\n                )\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(input, 0x3F))), 0xFF)\\n                )\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"crystalsAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getColor\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getLootType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"output\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getSlabs\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"output\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"iCrystals\",\"outputs\":[{\"internalType\":\"contract ICrystals\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CrystalsMetadata","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003051162ed7def8af730aaf4c7cb8a10ee19b8303","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}