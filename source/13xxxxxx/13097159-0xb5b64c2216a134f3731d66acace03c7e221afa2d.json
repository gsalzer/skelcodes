{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/L1_NovaExecutionManager.sol\": {\r\n      \"content\": \"// @unsupported: ovm\\n// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {Auth} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {NovaExecHashLib} from \\\"./libraries/NovaExecHashLib.sol\\\";\\nimport {CrossDomainEnabled, iOVM_CrossDomainMessenger} from \\\"./external/CrossDomainEnabled.sol\\\";\\n\\nimport {L2_NovaRegistry} from \\\"./L2_NovaRegistry.sol\\\";\\nimport {L1_NovaApprovalEscrow} from \\\"./L1_NovaApprovalEscrow.sol\\\";\\n\\n/// @notice Entry point for relayers to execute requests.\\n/// @dev Deploys an L1_NovaApprovalEscrow and sends cross domain messages to the L2_NovaRegistry.\\ncontract L1_NovaExecutionManager is Auth, CrossDomainEnabled {\\n    using SafeMath for uint256;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The revert message text used to trigger a hard revert.\\n    /// @notice The execution manager will ignore hard reverts if they are triggered by a strategy not registered as UNSAFE.\\n    string public constant HARD_REVERT_TEXT = \\\"__NOVA__HARD__REVERT__\\\";\\n\\n    /// @notice The keccak256 hash of the hard revert text.\\n    /// @dev The exec function uses this hash the compare the revert reason of an execution with the hard revert text.\\n    bytes32 public constant HARD_REVERT_HASH = keccak256(abi.encodeWithSignature(\\\"Error(string)\\\", HARD_REVERT_TEXT));\\n\\n    /// @notice The 'default' value for currentExecHash.\\n    /// @dev Outside of an active exec call currentExecHash will always equal DEFAULT_EXECHASH.\\n    bytes32 public constant DEFAULT_EXECHASH = 0xFEEDFACECAFEBEEFFEEDFACECAFEBEEFFEEDFACECAFEBEEFFEEDFACECAFEBEEF;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The address of the L2_NovaRegistry to send cross domain messages to.\\n    /// @dev This address will not have contract code on L1, it is the address of a contract\\n    /// deployed on L2. We can only communicate with this address using cross domain messages.\\n    address public immutable L2_NOVA_REGISTRY_ADDRESS;\\n\\n    /// @notice The address of the L1_NovaApprovalEscrow to access tokens from.\\n    /// @dev The transferFromRelayer function uses the escrow as a proxy identity for relayers to approve their tokens to, where\\n    /// only the execution manager can transfer them. If relayers approved tokens directly to the execution manager, another relayer\\n    /// could steal them by calling exec with the token set as the strategy and transferFrom or pull (used by DAI/MKR) used as calldata.\\n    L1_NovaApprovalEscrow public immutable L1_NOVA_APPROVAL_ESCROW;\\n\\n    /// @param _L2_NOVA_REGISTRY_ADDRESS The address of the L2_NovaRegistry on L2 to send cross domain messages to.\\n    /// @param _CROSS_DOMAIN_MESSENGER The L1 cross domain messenger contract to use for sending cross domain messages.\\n    constructor(address _L2_NOVA_REGISTRY_ADDRESS, iOVM_CrossDomainMessenger _CROSS_DOMAIN_MESSENGER)\\n        CrossDomainEnabled(_CROSS_DOMAIN_MESSENGER)\\n    {\\n        L2_NOVA_REGISTRY_ADDRESS = _L2_NOVA_REGISTRY_ADDRESS;\\n\\n        // Create an approval escrow which implicitly becomes\\n        // owned by the execution manager in its constructor.\\n        L1_NOVA_APPROVAL_ESCROW = new L1_NovaApprovalEscrow();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Emitted when `updateGasConfig` is called.\\n    /// @param newGasConfig The updated gasConfig.\\n    event GasConfigUpdated(GasConfig newGasConfig);\\n\\n    /// @notice Emitted when `registerSelfAsStrategy` is called.\\n    /// @param strategyRiskLevel The risk level the strategy registered itself as.\\n    event StrategyRegistered(StrategyRiskLevel strategyRiskLevel);\\n\\n    /// @notice Emitted when `exec` is called.\\n    /// @param execHash The execHash computed from arguments and transaction context.\\n    /// @param reverted Will be true if the strategy call reverted, will be false if not.\\n    /// @param gasUsed The gas estimate computed during the call.\\n    event Exec(bytes32 indexed execHash, address relayer, bool reverted, uint256 gasUsed);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                   GAS LIMIT/ESTIMATION CONFIGURATION\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Packed struct of gas limit/estimation configuration values used in exec.\\n    /// @param calldataByteGasEstimate The amount of gas to assume each byte of calldata consumes.\\n    /// @param missingGasEstimate The extra amount of gas the system consumes but cannot measure on the fly.\\n    /// @param strategyCallGasBuffer The extra amount of gas to keep as a buffer when calling a strategy.\\n    /// @param execCompletedMessageGasLimit The L2 gas limit to use for the cross domain call to execCompleted.\\n    struct GasConfig {\\n        // This needs to factor in raw calldata costs, along with the hidden\\n        // cost of abi decoding and copying the calldata into an Solidity function.\\n        uint32 calldataByteGasEstimate;\\n        // This needs to factor in the base transaction gas (currently 21000), along\\n        // with the gas cost of sending the cross domain message and emitting the Exec event.\\n        uint96 missingGasEstimate;\\n        // This needs to factor in the max amount of gas consumed after the strategy call, up\\n        // until the cross domain message is sent (as this is not accounted for in missingGasEstimate).\\n        uint96 strategyCallGasBuffer;\\n        // This needs to factor in the overhead of relaying the message on L2 (currently ~800k),\\n        // along with the actual L2 gas cost of calling the L2_NovaRegistry's execCompleted function.\\n        uint32 execCompletedMessageGasLimit;\\n    }\\n\\n    /// @notice Gas limit/estimation configuration values used in exec.\\n    GasConfig public gasConfig =\\n        GasConfig({\\n            calldataByteGasEstimate: 13, // OpenGSN uses 13 to estimate gas per calldata byte too.\\n            missingGasEstimate: 200000, // Rough estimate for missing gas. Tune this in production.\\n            strategyCallGasBuffer: 5000, // Overly cautious gas buffer. Can likely be safely reduced.\\n            execCompletedMessageGasLimit: 1500000 // If the limit is too low, relayers won't get paid.\\n        });\\n\\n    /// @notice Updates the gasConfig.\\n    /// @param newGasConfig The updated value to use for gasConfig.\\n    function updateGasConfig(GasConfig calldata newGasConfig) external requiresAuth {\\n        gasConfig = newGasConfig;\\n\\n        emit GasConfigUpdated(newGasConfig);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                      STRATEGY RISK LEVEL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Risk classifications for strategies.\\n    enum StrategyRiskLevel {\\n        // The strategy has not been assigned a risk level.\\n        // It has the equivalent abilities of a SAFE strategy,\\n        // but could upgrade itself to an UNSAFE strategy at any time.\\n        UNKNOWN,\\n        // The strategy has registered itself as a safe strategy,\\n        // meaning it cannot use transferFromRelayer or trigger a hard\\n        // revert. A SAFE strategy cannot upgrade itself to become UNSAFE.\\n        SAFE,\\n        // The strategy has registered itself as an unsafe strategy,\\n        // meaning it has access to all the functionality the execution\\n        // manager provides like transferFromRelayer and the ability to hard\\n        // revert. An UNSAFE strategy cannot downgrade itself to become SAFE.\\n        UNSAFE\\n    }\\n\\n    /// @notice Maps strategy addresses to their registered risk level.\\n    /// @dev This mapping is used to determine if strategies can access transferFromRelayer and trigger hard reverts.\\n    mapping(address => StrategyRiskLevel) public getStrategyRiskLevel;\\n\\n    /// @notice Registers the caller as a strategy with the provided risk level.\\n    /// @dev A strategy can only register once, and will have no way to change its risk level after registering.\\n    /// @param strategyRiskLevel The risk level the strategy is registering as. Strategies cannot register as UNKNOWN.\\n    function registerSelfAsStrategy(StrategyRiskLevel strategyRiskLevel) external requiresAuth {\\n        // Ensure the strategy has not already registered itself, as if strategies could change their risk level arbitrarily\\n        // they would be able to trick relayers into executing them believing they were safe, and then use unsafe functionality.\\n        require(getStrategyRiskLevel[msg.sender] == StrategyRiskLevel.UNKNOWN, \\\"ALREADY_REGISTERED\\\");\\n\\n        // Strategies can't register as UNKNOWN because it would emit an unhelpful StrategyRegistered event and confuse relayers.\\n        require(strategyRiskLevel != StrategyRiskLevel.UNKNOWN, \\\"INVALID_RISK_LEVEL\\\");\\n\\n        // Set the strategy's risk level.\\n        getStrategyRiskLevel[msg.sender] = strategyRiskLevel;\\n\\n        emit StrategyRegistered(strategyRiskLevel);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        EXECUTION CONTEXT STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The address who called exec.\\n    /// @dev This will not be reset after each execution completes.\\n    address public currentRelayer;\\n\\n    /// @notice The address of the strategy that is currently being called.\\n    /// @dev This will not be reset after each execution completes.\\n    address public currentlyExecutingStrategy;\\n\\n    /// @notice The execHash computed from the currently executing call to exec.\\n    /// @dev This will be reset to DEFAULT_EXECHASH after each execution completes.\\n    bytes32 public currentExecHash = DEFAULT_EXECHASH;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            EXECUTION LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Executes a request and sends tips/gas/inputs to a specific address on L2.\\n    /// @param nonce The nonce of the request to execute.\\n    /// @param strategy The strategy specified in the request.\\n    /// @param l1Calldata The calldata associated with the request.\\n    /// @param l2Recipient An address who will receive the tips, gas and input tokens attached to the request on L2.\\n    /// @param deadline Timestamp after which the transaction will immediately revert.\\n    function exec(\\n        uint256 nonce,\\n        address strategy,\\n        bytes calldata l1Calldata,\\n        uint256 gasLimit,\\n        address l2Recipient,\\n        uint256 deadline\\n    ) external {\\n        // Measure gas left at the start of execution.\\n        uint256 startGas = gasleft();\\n\\n        // Check that the deadline has not already passed.\\n        require(block.timestamp <= deadline, \\\"PAST_DEADLINE\\\");\\n\\n        // Substitute for Auth's requiresAuth modifier.\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        // Prevent the strategy or another contract from trying\\n        // to frontrun a relayer's execution and take their payment.\\n        require(currentExecHash == DEFAULT_EXECHASH, \\\"ALREADY_EXECUTING\\\");\\n\\n        // We cannot allow calling cross domain messenger directly, as a\\n        // malicious relayer could use it to trigger the registry's execCompleted\\n        // function and claim bounties without actually executing the proper request(s).\\n        require(strategy != address(CROSS_DOMAIN_MESSENGER), \\\"UNSAFE_STRATEGY\\\");\\n\\n        // We cannot allow calling the approval escrow directly, as a malicious\\n        // relayer could call its transferTokenToStrategy function and access tokens\\n        // from other relayers outside of a proper call to the transferFromRelayer function.\\n        require(strategy != address(L1_NOVA_APPROVAL_ESCROW), \\\"UNSAFE_STRATEGY\\\");\\n\\n        // We cannot allow calling the execution manager itself, as any malicious\\n        // relayer could exploit Auth inherited functions to change ownership, blacklist\\n        // other relayers, or freeze the contract entirely, without being properly authorized.\\n        require(strategy != address(this), \\\"UNSAFE_STRATEGY\\\");\\n\\n        // Compute the relevant execHash.\\n        bytes32 execHash = NovaExecHashLib.compute({\\n            nonce: nonce,\\n            strategy: strategy,\\n            l1Calldata: l1Calldata,\\n            gasLimit: gasLimit,\\n            gasPrice: tx.gasprice\\n        });\\n\\n        // Initialize execution context.\\n        currentExecHash = execHash;\\n        currentRelayer = msg.sender;\\n        currentlyExecutingStrategy = strategy;\\n\\n        // Call the strategy with a safe gas limit.\\n        (bool success, bytes memory returnData) = strategy.call{\\n            gas: gasLimit\\n                .sub(msg.data.length.mul(gasConfig.calldataByteGasEstimate))\\n                .sub(gasConfig.strategyCallGasBuffer)\\n                .sub(gasConfig.missingGasEstimate)\\n                .sub(startGas - gasleft())\\n        }(l1Calldata);\\n\\n        // Revert if a valid hard revert was triggered. A hard revert is only valid if the strategy had a risk level of UNSAFE.\\n        require(\\n            success || keccak256(returnData) != HARD_REVERT_HASH || getStrategyRiskLevel[strategy] != StrategyRiskLevel.UNSAFE,\\n            \\\"HARD_REVERT\\\"\\n        );\\n\\n        // Reset currentExecHash to default so transferFromRelayer becomes uncallable again.\\n        currentExecHash = DEFAULT_EXECHASH;\\n\\n        // Estimate how much gas this tx will have consumed in total (not accounting for refunds).\\n        uint256 gasUsedEstimate = msg.data.length.mul(gasConfig.calldataByteGasEstimate).add(gasConfig.missingGasEstimate).add(\\n            startGas - gasleft()\\n        );\\n\\n        // Send message to unlock the bounty on L2.\\n        CROSS_DOMAIN_MESSENGER.sendMessage(\\n            L2_NOVA_REGISTRY_ADDRESS,\\n            abi.encodeWithSelector(\\n                L2_NovaRegistry.execCompleted.selector,\\n                // Computed execHash:\\n                execHash,\\n                // The reward recipient on L2:\\n                l2Recipient,\\n                // Did the call revert:\\n                !success,\\n                // Estimated gas used in total:\\n                gasUsedEstimate\\n            ),\\n            gasConfig.execCompletedMessageGasLimit\\n        );\\n\\n        emit Exec(execHash, msg.sender, !success, gasUsedEstimate);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          STRATEGY UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Transfers tokens the relayer (the address that called exec)\\n    /// approved to the L1_NOVA_APPROVAL_ESCROW to currently executing strategy.\\n    /// @notice Can only be called by the currently executing strategy (if there is one at all).\\n    /// @notice The currently execution strategy must be registered as UNSAFE to use this function.\\n    /// @notice Will hard revert if the correct amount of tokens are not approved to the escrow.\\n    /// @param token The ER20 token to transfer to the currently executing strategy.\\n    /// @param amount The amount of the token to transfer to the currently executing strategy.\\n    function transferFromRelayer(address token, uint256 amount) external requiresAuth {\\n        // Only the currently executing strategy is allowed to call this function.\\n        // Since msg.sender is inexpensive, from here on it's used to access the strategy.\\n        require(msg.sender == currentlyExecutingStrategy, \\\"NOT_CURRENT_STRATEGY\\\");\\n\\n        // Ensure currentExecHash is not set to DEFAULT_EXECHASH as otherwise a\\n        // malicious strategy could transfer tokens outside of an active execution.\\n        require(currentExecHash != DEFAULT_EXECHASH, \\\"NO_ACTIVE_EXECUTION\\\");\\n\\n        // Ensure the strategy has registered itself as UNSAFE so relayers can\\n        // avoid strategies that use transferFromRelayer if they want to be cautious.\\n        require(getStrategyRiskLevel[msg.sender] == StrategyRiskLevel.UNSAFE, \\\"UNSUPPORTED_RISK_LEVEL\\\");\\n\\n        // Transfer tokens from the relayer to the strategy.\\n        require(\\n            L1_NOVA_APPROVAL_ESCROW.transferApprovedToken({\\n                token: token,\\n                amount: amount,\\n                sender: currentRelayer,\\n                recipient: msg.sender\\n            }),\\n            HARD_REVERT_TEXT // Hard revert if the transfer fails.\\n        );\\n    }\\n\\n    /// @notice Convenience function that triggers a hard revert.\\n    /// @notice The execution manager will ignore hard reverts if\\n    /// they are triggered by a strategy not registered as UNSAFE.\\n    function hardRevert() external pure {\\n        // Call revert with the hard revert text.\\n        revert(HARD_REVERT_TEXT);\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/auth/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event AuthorityUpdated(Authority indexed authority);\\n\\n    event OwnerUpdated(address indexed owner);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       OWNER AND AUTHORITY STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    Authority public authority;\\n\\n    address public owner;\\n\\n    constructor() {\\n        owner = msg.sender;\\n\\n        emit OwnerUpdated(msg.sender);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                  OWNER AND AUTHORITY SETTER FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setOwner(address newOwner) external requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(owner);\\n    }\\n\\n    function setAuthority(Authority newAuthority) external requiresAuth {\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(authority);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        AUTHORIZATION LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    modifier requiresAuth() {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\\n        if (src == address(this)) {\\n            return true;\\n        }\\n\\n        if (src == owner) {\\n            return true;\\n        }\\n\\n        Authority _authority = authority;\\n\\n        if (_authority == Authority(address(0))) {\\n            return false;\\n        }\\n\\n        return _authority.canCall(src, address(this), sig);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\ninterface Authority {\\n    function canCall(\\n        address src,\\n        address dst,\\n        bytes4 sig\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/NovaExecHashLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.7.6;\\n\\n/// @notice Library for computing a Nova execHash.\\n/// @dev Just because an execHash can be properly computed, doesn't mean it's a valid request in the registry.\\nlibrary NovaExecHashLib {\\n    /// @dev Computes a Nova execHash from a nonce, strategy address, calldata and gas price.\\n    /// @return A Nova execHash: keccak256(abi.encodePacked(nonce, strategy, l1Calldata, gasPrice, gasLimit))\\n    /// @dev Use of abi.encodePacked() here is safe because we only have one dynamic type (l1Calldata).\\n    function compute(\\n        uint256 nonce,\\n        address strategy,\\n        bytes memory l1Calldata,\\n        uint256 gasPrice,\\n        uint256 gasLimit\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(nonce, strategy, l1Calldata, gasPrice, gasLimit));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/CrossDomainEnabled.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.7.6;\\n\\nimport {iOVM_CrossDomainMessenger} from \\\"@eth-optimism/contracts/iOVM/bridge/messaging/iOVM_CrossDomainMessenger.sol\\\";\\n\\n/// @notice Mixin for contracts performing cross-domain communication.\\n/// @author Modified from OptimismPBC (https://github.com/ethereum-optimism/optimism)\\nabstract contract CrossDomainEnabled {\\n    /// @notice Messenger contract used to send and receive messages from the other domain.\\n    iOVM_CrossDomainMessenger public immutable CROSS_DOMAIN_MESSENGER;\\n\\n    /// @param _CROSS_DOMAIN_MESSENGER Address of the iOVM_CrossDomainMessenger on the current layer.\\n    constructor(iOVM_CrossDomainMessenger _CROSS_DOMAIN_MESSENGER) {\\n        CROSS_DOMAIN_MESSENGER = _CROSS_DOMAIN_MESSENGER;\\n    }\\n\\n    /// @dev Enforces that the modified function is only callable by a specific cross-domain account.\\n    /// @param sourceDomainAccount The only account on the originating domain which is authenticated to call this function.\\n    modifier onlyFromCrossDomainAccount(address sourceDomainAccount) {\\n        require(msg.sender == address(CROSS_DOMAIN_MESSENGER), \\\"NOT_CROSS_DOMAIN_MESSENGER\\\");\\n\\n        require(CROSS_DOMAIN_MESSENGER.xDomainMessageSender() == sourceDomainAccount, \\\"WRONG_CROSS_DOMAIN_SENDER\\\");\\n\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L2_NovaRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport {Auth} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\n\\nimport {NovaExecHashLib} from \\\"./libraries/NovaExecHashLib.sol\\\";\\nimport {SafeTransferLib} from \\\"./libraries/SafeTransferLib.sol\\\";\\nimport {CrossDomainEnabled, iOVM_CrossDomainMessenger} from \\\"./external/CrossDomainEnabled.sol\\\";\\n\\n/// @notice Hub for contracts/users on L2 to create and manage requests.\\n/// @dev Receives messages from the L1_NovaExecutionManager via a cross domain messenger.\\ncontract L2_NovaRegistry is Auth, CrossDomainEnabled {\\n    using SafeTransferLib for address;\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The maximum amount of input tokens that may be added to a request.\\n    uint256 public constant MAX_INPUT_TOKENS = 5;\\n\\n    /// @notice The minimum delay between when unlockTokens and withdrawTokens can be called.\\n    uint256 public constant MIN_UNLOCK_DELAY_SECONDS = 300;\\n\\n    /// @param _CROSS_DOMAIN_MESSENGER The L2 cross domain messenger to trust for receiving messages.\\n    constructor(iOVM_CrossDomainMessenger _CROSS_DOMAIN_MESSENGER) CrossDomainEnabled(_CROSS_DOMAIN_MESSENGER) {}\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    EXECUTION MANAGER ADDRESS STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The address of the only contract authorized to make cross domain calls to execCompleted.\\n    address public L1_NovaExecutionManagerAddress;\\n\\n    /// @notice Authorizes newExecutionManagerAddress to make cross domain calls to execCompleted.\\n    /// @param newExecutionManagerAddress The address to authorized to make cross domain calls to execCompleted.\\n    function connectExecutionManager(address newExecutionManagerAddress) external requiresAuth {\\n        L1_NovaExecutionManagerAddress = newExecutionManagerAddress;\\n\\n        emit ExecutionManagerConnected(newExecutionManagerAddress);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Emitted when `connectExecutionManager` is called.\\n    /// @param newExecutionManagerAddress The new value for L1_NovaExecutionManagerAddress.\\n    event ExecutionManagerConnected(address newExecutionManagerAddress);\\n\\n    /// @notice Emitted when `requestExec` is called.\\n    /// @param execHash The unique identifier generated for this request.\\n    /// @param strategy The strategy associated with the request.\\n    event RequestExec(bytes32 indexed execHash, address indexed strategy);\\n\\n    /// @notice Emitted when `execCompleted` is called.\\n    /// @param execHash The unique identifier associated with the request executed.\\n    /// @param rewardRecipient The address the relayer specified to be the recipient of the tokens on L2.\\n    /// @param reverted If the strategy reverted on L1 during execution.\\n    /// @param gasUsed The amount of gas used by the execution tx on L1.\\n    event ExecCompleted(bytes32 indexed execHash, address indexed rewardRecipient, bool reverted, uint256 gasUsed);\\n\\n    /// @notice Emitted when `claimInputTokens` is called.\\n    /// @param execHash The unique identifier associated with the request that had its input tokens claimed.\\n    event ClaimInputTokens(bytes32 indexed execHash);\\n\\n    /// @notice Emitted when `withdrawTokens` is called.\\n    /// @param execHash The unique identifier associated with the request that had its tokens withdrawn.\\n    event WithdrawTokens(bytes32 indexed execHash);\\n\\n    /// @notice Emitted when `unlockTokens` is called.\\n    /// @param execHash The unique identifier associated with the request that had a token unlock scheduled.\\n    /// @param unlockTimestamp When the unlock will set into effect and the creator will be able to call withdrawTokens.\\n    event UnlockTokens(bytes32 indexed execHash, uint256 unlockTimestamp);\\n\\n    /// @notice Emitted when `relockTokens` is called.\\n    /// @param execHash The unique identifier associated with the request that had its tokens relocked.\\n    event RelockTokens(bytes32 indexed execHash);\\n\\n    /// @notice Emitted when `speedUpRequest` is called.\\n    /// @param execHash The unique identifier associated with the request that was uncled and replaced by the newExecHash.\\n    /// @param newExecHash The execHash of the resubmitted request (copy of its uncle with an updated gasPrice).\\n    /// @param newNonce The nonce of the resubmitted request.\\n    /// @param switchTimestamp When the uncled request (execHash) will have its tokens transferred to the resubmitted request (newExecHash).\\n    event SpeedUpRequest(bytes32 indexed execHash, bytes32 indexed newExecHash, uint256 newNonce, uint256 switchTimestamp);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       GLOBAL NONCE COUNTER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice The most recent nonce assigned to a request.\\n    uint256 public systemNonce;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           PER REQUEST STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Maps execHashes to the creator of the request.\\n    mapping(bytes32 => address) public getRequestCreator;\\n\\n    /// @notice Maps execHashes to the address of the strategy associated with the request.\\n    mapping(bytes32 => address) public getRequestStrategy;\\n\\n    /// @notice Maps execHashes to the calldata associated with the request.\\n    mapping(bytes32 => bytes) public getRequestCalldata;\\n\\n    /// @notice Maps execHashes to the gas limit that will be used when calling the request's strategy.\\n    mapping(bytes32 => uint256) public getRequestGasLimit;\\n\\n    /// @notice Maps execHashes to the gas price (in wei) a relayer must use to execute the request.\\n    mapping(bytes32 => uint256) public getRequestGasPrice;\\n\\n    /// @notice Maps execHashes to the additional tip (in wei) relayers will receive for successfully executing the request.\\n    mapping(bytes32 => uint256) public getRequestTip;\\n\\n    /// @notice Maps execHashes to the nonce assigned to the request.\\n    mapping(bytes32 => uint256) public getRequestNonce;\\n\\n    /// @notice A token/amount pair that a relayer will need on L1 to execute the request (and will be returned to them on L2).\\n    /// @param l2Token The token on L2 to transfer to the relayer upon a successful execution.\\n    /// @param amount The amount of l2Token to refund the relayer upon a successful execution.\\n    /// @dev Relayers must reference a list of L2-L1 token mappings to determine the L1 equivalent for an l2Token.\\n    /// @dev The decimal scheme may not align between the L1 and L2 tokens, relayers should check via off-chain logic.\\n    struct InputToken {\\n        IERC20 l2Token;\\n        uint256 amount;\\n    }\\n\\n    /// @dev Maps execHashes to the input tokens a relayer must have to execute the request.\\n    mapping(bytes32 => InputToken[]) internal requestInputTokens;\\n\\n    /// @notice Fetches the input tokens a relayer must have to execute a request.\\n    /// @return The input tokens required to execute the request.\\n    function getRequestInputTokens(bytes32 execHash) external view returns (InputToken[] memory) {\\n        return requestInputTokens[execHash];\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INPUT TOKEN RECIPIENT STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Struct containing data about the status of the request's input tokens.\\n    /// @param recipient The user who is entitled to take the request's input tokens.\\n    /// If recipient is not address(0), this means the request is no longer executable.\\n    /// @param isClaimed Will be true if the input tokens have been removed, false if not.\\n    struct InputTokenRecipientData {\\n        address recipient;\\n        bool isClaimed;\\n    }\\n\\n    /// @notice Maps execHashes to a struct which contains data about the status of the request's input tokens.\\n    mapping(bytes32 => InputTokenRecipientData) public getRequestInputTokenRecipientData;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              UNLOCK STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Maps execHashes to a timestamp representing when the request will have\\n    /// its tokens unlocked, meaning the creator can withdraw tokens from the request.\\n    /// @notice Will be 0 if no unlock has been scheduled.\\n    mapping(bytes32 => uint256) public getRequestUnlockTimestamp;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              UNCLE STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Maps execHashes which represent resubmitted requests created\\n    /// via speedUpRequest to their corresponding \\\"uncled\\\" request's execHash.\\n    /// @notice An uncled request is a request that has had its tokens removed via\\n    /// speedUpRequest in favor of a resubmitted request generated in the transaction.\\n    /// @notice Will be bytes32(0) the request is not a resubmitted copy of an uncle.\\n    mapping(bytes32 => bytes32) public getRequestUncle;\\n\\n    /// @notice Maps execHashes which represent requests uncled via\\n    /// speedUpRequest to their corresponding \\\"resubmitted\\\" request's execHash.\\n    /// @notice A resubmitted request is a request that is scheduled to replace its\\n    /// uncle after MIN_UNLOCK_DELAY_SECONDS from the time speedUpRequest was called.\\n    /// @notice Will be bytes32(0) if the request is not an uncle.\\n    mapping(bytes32 => bytes32) public getResubmittedRequest;\\n\\n    /// @notice Maps execHashes to a timestamp representing when the request will be disabled\\n    /// and replaced by a re-submitted request with a higher gas price (via speedUpRequest).\\n    /// @notice Will be 0 if speedUpRequest has not been called with the execHash.\\n    mapping(bytes32 => uint256) public getRequestDeathTimestamp;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           STATEFUL FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Request a strategy to be executed with specific calldata and (optionally) input tokens.\\n    /// @notice The caller must attach (gasPrice * gasLimit) + tip of ETH when calling.\\n    /// @param strategy The address of the \\\"strategy\\\" contract that should be called on L1.\\n    /// @param l1Calldata The abi encoded calldata the strategy should be called with.\\n    /// @param gasLimit The gas limit that will be used when calling the strategy.\\n    /// @param gasPrice The gas price (in wei) a relayer must use to execute the request.\\n    /// @param tip The additional wei to pay as a tip for any relayer that successfully executes the request.\\n    /// If the relayer executes the request and the strategy reverts, the creator will be refunded the tip.\\n    /// @param inputTokens An array with a length of MAX_INPUT_TOKENS or less token/amount pairs that the relayer will\\n    /// need to execute the request on L1. Input tokens are refunded to the relayer on L2 after a successful execution.\\n    /// @return execHash The \\\"execHash\\\" (unique identifier) for this request.\\n    function requestExec(\\n        address strategy,\\n        bytes calldata l1Calldata,\\n        uint256 gasLimit,\\n        uint256 gasPrice,\\n        uint256 tip,\\n        InputToken[] calldata inputTokens\\n    ) public payable requiresAuth returns (bytes32 execHash) {\\n        // Do not allow more than MAX_INPUT_TOKENS input tokens as it could use too much gas.\\n        require(inputTokens.length <= MAX_INPUT_TOKENS, \\\"TOO_MANY_INPUTS\\\");\\n\\n        // Ensure enough ETH was sent along with the call to cover gas and the tip.\\n        require(msg.value == gasLimit.mul(gasPrice).add(tip), \\\"BAD_ETH_VALUE\\\");\\n\\n        // Increment the global nonce.\\n        systemNonce += 1;\\n\\n        // Compute the execHash for this request.\\n        execHash = NovaExecHashLib.compute({\\n            nonce: systemNonce,\\n            strategy: strategy,\\n            l1Calldata: l1Calldata,\\n            gasPrice: gasPrice,\\n            gasLimit: gasLimit\\n        });\\n\\n        // Store all critical request data.\\n        getRequestCreator[execHash] = msg.sender;\\n        getRequestStrategy[execHash] = strategy;\\n        getRequestCalldata[execHash] = l1Calldata;\\n        getRequestGasLimit[execHash] = gasLimit;\\n        getRequestGasPrice[execHash] = gasPrice;\\n        getRequestTip[execHash] = tip;\\n        getRequestNonce[execHash] = systemNonce;\\n\\n        emit RequestExec(execHash, strategy);\\n\\n        // Transfer input tokens in that the request creator has approved.\\n        for (uint256 i = 0; i < inputTokens.length; i++) {\\n            inputTokens[i].l2Token.safeTransferFrom(msg.sender, address(this), inputTokens[i].amount);\\n\\n            // We can't just put a calldata/memory array directly into storage so we have to go index by index.\\n            requestInputTokens[execHash].push(inputTokens[i]);\\n        }\\n    }\\n\\n    /// @notice Bundles a call to requestExec and unlockTokens into a single transaction.\\n    /// @notice See requestExec and unlockTokens for more information.\\n    function requestExecWithTimeout(\\n        address strategy,\\n        bytes calldata l1Calldata,\\n        uint256 gasLimit,\\n        uint256 gasPrice,\\n        uint256 tip,\\n        InputToken[] calldata inputTokens,\\n        uint256 autoUnlockDelaySeconds\\n    ) external payable returns (bytes32 execHash) {\\n        // Create a request and get its execHash.\\n        execHash = requestExec(strategy, l1Calldata, gasLimit, gasPrice, tip, inputTokens);\\n\\n        // Schedule an unlock set to complete autoUnlockDelay seconds from now.\\n        unlockTokens(execHash, autoUnlockDelaySeconds);\\n    }\\n\\n    /// @notice Claims input tokens earned from executing a request.\\n    /// @notice Request creators must also call this function if their request\\n    /// reverted (as input tokens are not sent to relayers if the request reverts).\\n    /// @notice Anyone may call this function, but the tokens will be sent to the proper input token recipient\\n    /// which is either the l2Recipient passed to execCompleted or the request creator if the request reverted.\\n    /// @param execHash The unique identifier of the executed request to claim tokens for.\\n    function claimInputTokens(bytes32 execHash) external requiresAuth {\\n        // Get a pointer to the input token recipient data.\\n        InputTokenRecipientData storage inputTokenRecipientData = getRequestInputTokenRecipientData[execHash];\\n\\n        // Ensure input tokens for this request are ready to be sent to a recipient.\\n        require(inputTokenRecipientData.recipient != address(0), \\\"NO_RECIPIENT\\\");\\n\\n        // Ensure that the tokens have not already been claimed.\\n        require(!inputTokenRecipientData.isClaimed, \\\"ALREADY_CLAIMED\\\");\\n\\n        // Mark the input tokens as claimed.\\n        inputTokenRecipientData.isClaimed = true;\\n\\n        emit ClaimInputTokens(execHash);\\n\\n        // Loop over each input token to transfer it to the recipient.\\n        InputToken[] memory inputTokens = requestInputTokens[execHash];\\n        for (uint256 i = 0; i < inputTokens.length; i++) {\\n            inputTokens[i].l2Token.safeTransfer(inputTokenRecipientData.recipient, inputTokens[i].amount);\\n        }\\n    }\\n\\n    /// @notice Unlocks a request's tokens after a delay. Once the delay has passed,\\n    /// anyone can call withdrawTokens on behalf of the creator to refund their tokens.\\n    /// @notice unlockDelaySeconds must be greater than or equal to MIN_UNLOCK_DELAY_SECONDS.\\n    /// @notice The caller must be the creator of the request associated with the execHash.\\n    /// @param execHash The unique identifier of the request to unlock tokens for.\\n    /// @param unlockDelaySeconds The delay (in seconds) until the creator can withdraw their tokens.\\n    function unlockTokens(bytes32 execHash, uint256 unlockDelaySeconds) public requiresAuth {\\n        // Ensure the request currently has tokens.\\n        (bool requestHasTokens, ) = hasTokens(execHash);\\n        require(requestHasTokens, \\\"REQUEST_HAS_NO_TOKENS\\\");\\n\\n        // Ensure an unlock is not already scheduled.\\n        require(getRequestUnlockTimestamp[execHash] == 0, \\\"UNLOCK_ALREADY_SCHEDULED\\\");\\n\\n        // Ensure the caller is the creator of the request.\\n        require(getRequestCreator[execHash] == msg.sender, \\\"NOT_CREATOR\\\");\\n\\n        // Ensure the delay is greater than the minimum.\\n        require(unlockDelaySeconds >= MIN_UNLOCK_DELAY_SECONDS, \\\"DELAY_TOO_SMALL\\\");\\n\\n        // Set the unlock timestamp to block.timestamp + unlockDelaySeconds.\\n        uint256 unlockTimestamp = block.timestamp.add(unlockDelaySeconds);\\n        getRequestUnlockTimestamp[execHash] = unlockTimestamp;\\n\\n        emit UnlockTokens(execHash, unlockTimestamp);\\n    }\\n\\n    /// @notice Reverses a request's completed token unlock, hence requiring the creator\\n    /// to call unlockTokens again if they wish to unlock the request's tokens another time.\\n    /// @notice The caller must be the creator of the request associated with the execHash.\\n    /// @param execHash The unique identifier of the request to relock tokens for.\\n    function relockTokens(bytes32 execHash) external requiresAuth {\\n        // Ensure the request currently has tokens.\\n        (bool requestHasTokens, ) = hasTokens(execHash);\\n        require(requestHasTokens, \\\"REQUEST_HAS_NO_TOKENS\\\");\\n\\n        // Ensure that the request has had its tokens unlocked.\\n        (bool tokensUnlocked, ) = areTokensUnlocked(execHash);\\n        require(tokensUnlocked, \\\"NOT_UNLOCKED\\\");\\n\\n        // Ensure the caller is the creator of the request.\\n        require(getRequestCreator[execHash] == msg.sender, \\\"NOT_CREATOR\\\");\\n\\n        // Reset the unlock timestamp to 0.\\n        delete getRequestUnlockTimestamp[execHash];\\n\\n        emit RelockTokens(execHash);\\n    }\\n\\n    /// @notice Withdraws tokens from a request that has its tokens unlocked.\\n    /// @notice The creator of the request associated with the execHash must call unlockTokens and\\n    /// wait the unlockDelaySeconds they specified before tokens may be withdrawn from their request.\\n    /// @notice Anyone may call this function, but the tokens will still go the creator of the request associated with the execHash.\\n    /// @param execHash The unique identifier of the request to withdraw tokens from.\\n    function withdrawTokens(bytes32 execHash) external requiresAuth {\\n        // Ensure that the tokens are unlocked.\\n        (bool tokensUnlocked, ) = areTokensUnlocked(execHash);\\n        require(tokensUnlocked, \\\"NOT_UNLOCKED\\\");\\n\\n        // Ensure that the tokens have not already been removed.\\n        (bool requestHasTokens, ) = hasTokens(execHash);\\n        require(requestHasTokens, \\\"REQUEST_HAS_NO_TOKENS\\\");\\n\\n        // Get the request creator.\\n        address creator = getRequestCreator[execHash];\\n\\n        // Store that the request has had its input tokens withdrawn.\\n        // isClaimed is set to true so the creator cannot call claimInputTokens to claim their tokens twice!\\n        getRequestInputTokenRecipientData[execHash] = InputTokenRecipientData({recipient: creator, isClaimed: true});\\n\\n        emit WithdrawTokens(execHash);\\n\\n        // Transfer the ETH which would have been used for (gas + tip) back to the creator.\\n        creator.safeTransferETH(getRequestGasPrice[execHash].mul(getRequestGasLimit[execHash]).add(getRequestTip[execHash]));\\n\\n        // Transfer input tokens back to the creator.\\n        InputToken[] memory inputTokens = requestInputTokens[execHash];\\n        for (uint256 i = 0; i < inputTokens.length; i++) {\\n            inputTokens[i].l2Token.safeTransfer(creator, inputTokens[i].amount);\\n        }\\n    }\\n\\n    /// @notice Resubmit a request with a higher gas price.\\n    /// @notice This will \\\"uncle\\\" the execHash which means after MIN_UNLOCK_DELAY_SECONDS it will be disabled and the newExecHash will be enabled.\\n    /// @notice The caller must be the creator of the request associated with the execHash.\\n    /// @param execHash The unique identifier of the request to resubmit with a higher gas price.\\n    /// @param gasPrice The updated gas price to use for the resubmitted request.\\n    /// @return newExecHash The unique identifier for the resubmitted request.\\n    function speedUpRequest(bytes32 execHash, uint256 gasPrice) external payable requiresAuth returns (bytes32 newExecHash) {\\n        // Ensure the request currently has tokens.\\n        (bool requestHasTokens, ) = hasTokens(execHash);\\n        require(requestHasTokens, \\\"REQUEST_HAS_NO_TOKENS\\\");\\n\\n        // Ensure that the caller is the creator of the request.\\n        require(getRequestCreator[execHash] == msg.sender, \\\"NOT_CREATOR\\\");\\n\\n        // Ensure the request has not already been sped up.\\n        require(getRequestDeathTimestamp[execHash] == 0, \\\"ALREADY_SPED_UP\\\");\\n\\n        // Get the previous gas price.\\n        uint256 previousGasPrice = getRequestGasPrice[execHash];\\n\\n        // Ensure that the new gas price is greater than the previous.\\n        require(gasPrice > previousGasPrice, \\\"GAS_PRICE_MUST_BE_HIGHER\\\");\\n\\n        // Compute the timestamp when the request would become uncled.\\n        uint256 switchTimestamp = MIN_UNLOCK_DELAY_SECONDS.add(block.timestamp);\\n\\n        // Ensure that if there is a token unlock scheduled it would be after the switch.\\n        // Tokens cannot be withdrawn after the switch, which is why it's safe if they unlock after.\\n        uint256 tokenUnlockTimestamp = getRequestUnlockTimestamp[execHash];\\n        require(tokenUnlockTimestamp == 0 || tokenUnlockTimestamp > switchTimestamp, \\\"UNLOCK_BEFORE_SWITCH\\\");\\n\\n        // Get more data about the previous request.\\n        address previousStrategy = getRequestStrategy[execHash];\\n        bytes memory previousCalldata = getRequestCalldata[execHash];\\n        uint256 previousGasLimit = getRequestGasLimit[execHash];\\n\\n        // Ensure enough ETH was sent along with the call to cover the increased gas price.\\n        require(msg.value == gasPrice.sub(previousGasPrice).mul(previousGasLimit), \\\"BAD_ETH_VALUE\\\");\\n\\n        // Generate a new execHash for the resubmitted request.\\n        systemNonce += 1;\\n        newExecHash = NovaExecHashLib.compute({\\n            nonce: systemNonce,\\n            strategy: previousStrategy,\\n            l1Calldata: previousCalldata,\\n            gasLimit: previousGasLimit,\\n            gasPrice: gasPrice\\n        });\\n\\n        // Fill out data for the resubmitted request.\\n        getRequestCreator[newExecHash] = msg.sender;\\n        getRequestStrategy[newExecHash] = previousStrategy;\\n        getRequestCalldata[newExecHash] = previousCalldata;\\n        getRequestGasLimit[newExecHash] = previousGasLimit;\\n        getRequestGasPrice[newExecHash] = gasPrice;\\n        getRequestTip[newExecHash] = getRequestTip[execHash];\\n        getRequestNonce[execHash] = systemNonce;\\n\\n        // Map the resubmitted request to its uncle.\\n        getRequestUncle[newExecHash] = execHash;\\n        getResubmittedRequest[execHash] = newExecHash;\\n\\n        // Set the uncled request to die in MIN_UNLOCK_DELAY_SECONDS.\\n        getRequestDeathTimestamp[execHash] = switchTimestamp;\\n\\n        emit SpeedUpRequest(execHash, newExecHash, systemNonce, switchTimestamp);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                  CROSS DOMAIN MESSENGER ONLY FUNCTION\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev Assigns and partially rewards to the relayer of a request.\\n    /// @dev Only the connected L1_NovaExecutionManager can call via the cross domain messenger.\\n    /// @param execHash The unique identifier of the request that was executed.\\n    /// @param rewardRecipient The address the relayer specified to be the recipient of rewards on L2.\\n    /// @param reverted If the strategy reverted during execution.\\n    /// @param gasUsed The amount of gas used by the execution transaction on L1.\\n    function execCompleted(\\n        bytes32 execHash,\\n        address rewardRecipient,\\n        bool reverted,\\n        uint256 gasUsed\\n    ) external onlyFromCrossDomainAccount(L1_NovaExecutionManagerAddress) {\\n        // Ensure the request still has tokens.\\n        (bool requestHasTokens, ) = hasTokens(execHash);\\n        require(requestHasTokens, \\\"REQUEST_HAS_NO_TOKENS\\\");\\n\\n        // We cannot allow providing address(0) for rewardRecipient, as we\\n        // use address(0) to indicate a request has not its tokens removed.\\n        require(rewardRecipient != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        // Get relevant request data.\\n        uint256 tip = getRequestTip[execHash];\\n        uint256 gasLimit = getRequestGasLimit[execHash];\\n        uint256 gasPrice = getRequestGasPrice[execHash];\\n        address requestCreator = getRequestCreator[execHash];\\n        bytes32 resubmittedRequest = getResubmittedRequest[execHash];\\n\\n        // The amount of ETH to pay for the gas consumed, capped at the gas limit.\\n        uint256 gasPayment = gasPrice.mul(gasUsed > gasLimit ? gasLimit : gasUsed);\\n\\n        // Give the proper input token recipient the ability to claim the tokens.\\n        // isClaimed is implicitly kept as false, so the recipient can claim the tokens with claimInputTokens.\\n        getRequestInputTokenRecipientData[execHash].recipient = reverted ? requestCreator : rewardRecipient;\\n\\n        emit ExecCompleted(execHash, rewardRecipient, reverted, gasUsed);\\n\\n        // Pay the reward recipient for gas consumed and the tip if execution did not revert.\\n        rewardRecipient.safeTransferETH(gasPayment.add(reverted ? 0 : tip));\\n\\n        // Refund any unused gas, the tip if execution reverted, and extra ETH from the resubmitted request if necessary.\\n        requestCreator.safeTransferETH(\\n            gasLimit.mul(gasPrice).sub(gasPayment).add(reverted ? tip : 0).add(\\n                // Refund the ETH attached to the request's resubmitted copy if necessary.\\n                // The hasTokens call above ensures that this request isn't a dead uncle.\\n                resubmittedRequest != bytes32(0) ? getRequestGasPrice[resubmittedRequest].sub(gasPrice).mul(gasLimit) : 0\\n            )\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             VIEW FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Checks if a request exists and hasn't been withdrawn, uncled, or executed.\\n    /// @notice A resubmitted request isn't considered to exist until its uncle dies.\\n    /// @param execHash The unique identifier of the request to check.\\n    /// @return requestHasTokens A boolean indicating if the request exists and has all of its tokens.\\n    /// @return changeTimestamp A timestamp indicating when the request may have its tokens removed or added.\\n    /// Will be 0 if there is no removal/addition expected.\\n    /// Will also be 0 if the request has had its tokens withdrawn or was executed.\\n    /// Will be a timestamp if the request will have its tokens added soon (it's a resubmitted copy of an uncled request)\\n    /// or if the request will have its tokens removed soon (it's an uncled request scheduled to die soon).\\n    function hasTokens(bytes32 execHash) public view returns (bool requestHasTokens, uint256 changeTimestamp) {\\n        if (getRequestInputTokenRecipientData[execHash].recipient != address(0)) {\\n            // The request has been executed or had its tokens withdrawn,\\n            // so we know its tokens are removed and won't be added back.\\n            return (false, 0);\\n        }\\n\\n        uint256 deathTimestamp = getRequestDeathTimestamp[execHash];\\n        if (deathTimestamp != 0) {\\n            if (block.timestamp >= deathTimestamp) {\\n                // This request is an uncle which has died, meaning its\\n                // tokens have been removed and sent to a resubmitted request.\\n                return (false, 0);\\n            } else {\\n                // This request is an uncle which has not died yet, so we know\\n                // it has tokens that will be removed on its deathTimestamp.\\n                return (true, deathTimestamp);\\n            }\\n        }\\n\\n        bytes32 uncleExecHash = getRequestUncle[execHash];\\n        if (uncleExecHash == bytes32(0)) {\\n            if (getRequestCreator[execHash] == address(0)) {\\n                // The request passed all the previous removal checks but\\n                // doesn't actually exist, so we know it does not have tokens.\\n                return (false, 0);\\n            } else {\\n                // This request does not have an uncle and has passed all\\n                // the previous removal checks, so we know it has tokens.\\n                return (true, 0);\\n            }\\n        }\\n\\n        if (getRequestInputTokenRecipientData[uncleExecHash].recipient != address(0)) {\\n            // This request is a resubmitted version of its uncle\\n            // which was executed before it could \\\"die\\\" and switch its\\n            // tokens to this request, so we know it does not have tokens.\\n            return (false, 0);\\n        }\\n\\n        uint256 uncleDeathTimestamp = getRequestDeathTimestamp[uncleExecHash];\\n        if (uncleDeathTimestamp > block.timestamp) {\\n            // This request is a resubmitted version of its uncle\\n            // which has not \\\"died\\\" yet, so we know it does not have its\\n            // tokens yet, but will receive them after the uncleDeathTimestamp.\\n            return (false, uncleDeathTimestamp);\\n        }\\n\\n        // This is a resubmitted request with an uncle that died properly\\n        // without being executed early, so we know it has its tokens.\\n        return (true, 0);\\n    }\\n\\n    /// @notice Checks if a request has had an unlock completed (unlockTokens was called and MIN_UNLOCK_DELAY_SECONDS has passed).\\n    /// @param execHash The unique identifier of the request to check.\\n    /// @return unlocked A boolean indicating if the request has had an unlock completed and hence a withdrawal can be triggered.\\n    /// @return changeTimestamp A timestamp indicating when the request may have its unlock completed.\\n    /// Will be 0 if there is no unlock scheduled or the request has already completed an unlock.\\n    /// It will be a timestamp if an unlock has been scheduled but not completed.\\n    function areTokensUnlocked(bytes32 execHash) public view returns (bool unlocked, uint256 changeTimestamp) {\\n        uint256 tokenUnlockTimestamp = getRequestUnlockTimestamp[execHash];\\n\\n        if (tokenUnlockTimestamp == 0) {\\n            // There is no unlock scheduled.\\n            unlocked = false;\\n            changeTimestamp = 0;\\n        } else {\\n            // There has been an unlock scheduled/completed.\\n            unlocked = block.timestamp >= tokenUnlockTimestamp;\\n            changeTimestamp = unlocked ? 0 : tokenUnlockTimestamp;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L1_NovaApprovalEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.7.6;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @notice Escrow contract for relayers to approve input tokens to.\\n/// @dev Used by the L1_NovaExecutionManager to safely transfer tokens from relayers to strategies.\\ncontract L1_NovaApprovalEscrow {\\n    /// @notice The address who is authorized to transfer tokens from the approval escrow.\\n    /// @dev Initializing it as msg.sender here is equivalent to setting it in the constructor.\\n    address public immutable ESCROW_ADMIN = msg.sender;\\n\\n    /// @notice Transfers a token approved to the escrow.\\n    /// @notice Only the escrow admin can call this function.\\n    /// @param token The token to transfer.\\n    /// @param amount The amount of the token to transfer.\\n    /// @param sender The user who approved the token to the escrow.\\n    /// @param recipient The address to transfer the approved tokens to.\\n    /// @return A bool indicating if the transfer succeeded or not.\\n    function transferApprovedToken(\\n        address token,\\n        uint256 amount,\\n        address sender,\\n        address recipient\\n    ) external returns (bool) {\\n        // Ensure the caller is the escrow admin.\\n        require(ESCROW_ADMIN == msg.sender, \\\"UNAUTHORIZED\\\");\\n\\n        // Transfer tokens from the sender to the recipient.\\n        (bool success, bytes memory returnData) = address(token).call(\\n            abi.encodeWithSelector(\\n                // The token to transfer:\\n                IERC20(token).transferFrom.selector,\\n                // The address who approved tokens to the escrow:\\n                sender,\\n                // The address who should receive the tokens:\\n                recipient,\\n                // The amount of tokens to transfer to the recipient:\\n                amount\\n            )\\n        );\\n\\n        if (!success) {\\n            // If it reverted, return false\\n            // to indicate the transfer failed.\\n            return false;\\n        }\\n\\n        if (returnData.length > 0) {\\n            // An abi-encoded bool takes up 32 bytes.\\n            if (returnData.length == 32) {\\n                // Return false to indicate failure if\\n                // the return data was not a positive bool.\\n                return abi.decode(returnData, (bool));\\n            } else {\\n                // It returned some data that was not a bool,\\n                // return false to indicate the transfer failed.\\n                return false;\\n            }\\n        }\\n\\n        // If there was no failure,\\n        // return true to indicate success.\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/iOVM/bridge/messaging/iOVM_CrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title iOVM_CrossDomainMessenger\\n */\\ninterface iOVM_CrossDomainMessenger {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event SentMessage(bytes message);\\n    event RelayedMessage(bytes32 msgHash);\\n    event FailedRelayedMessage(bytes32 msgHash);\\n\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    function xDomainMessageSender() external view returns (address);\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    function sendMessage(\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _gasLimit\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.7.6;\\n\\n/// @notice Library for safely transferring Ether.\\n/// @dev This is used as a replacement for payable.transfer().\\nlibrary SafeTransferLib {\\n    /// @dev Attempts to transfer ETH and reverts on failure.\\n    /// @param to The address to receive the ETH.\\n    /// @param value The amount of wei to send.\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_L2_NOVA_REGISTRY_ADDRESS\",\"type\":\"address\"},{\"internalType\":\"contract iOVM_CrossDomainMessenger\",\"name\":\"_CROSS_DOMAIN_MESSENGER\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"execHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"reverted\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"}],\"name\":\"Exec\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"calldataByteGasEstimate\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"missingGasEstimate\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"strategyCallGasBuffer\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"execCompletedMessageGasLimit\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct L1_NovaExecutionManager.GasConfig\",\"name\":\"newGasConfig\",\"type\":\"tuple\"}],\"name\":\"GasConfigUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum L1_NovaExecutionManager.StrategyRiskLevel\",\"name\":\"strategyRiskLevel\",\"type\":\"uint8\"}],\"name\":\"StrategyRegistered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CROSS_DOMAIN_MESSENGER\",\"outputs\":[{\"internalType\":\"contract iOVM_CrossDomainMessenger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_EXECHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HARD_REVERT_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HARD_REVERT_TEXT\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"L1_NOVA_APPROVAL_ESCROW\",\"outputs\":[{\"internalType\":\"contract L1_NovaApprovalEscrow\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"L2_NOVA_REGISTRY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentExecHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRelayer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentlyExecutingStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"l1Calldata\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"l2Recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"exec\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasConfig\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"calldataByteGasEstimate\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"missingGasEstimate\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"strategyCallGasBuffer\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"execCompletedMessageGasLimit\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getStrategyRiskLevel\",\"outputs\":[{\"internalType\":\"enum L1_NovaExecutionManager.StrategyRiskLevel\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hardRevert\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum L1_NovaExecutionManager.StrategyRiskLevel\",\"name\":\"strategyRiskLevel\",\"type\":\"uint8\"}],\"name\":\"registerSelfAsStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFromRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"calldataByteGasEstimate\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"missingGasEstimate\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"strategyCallGasBuffer\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"execCompletedMessageGasLimit\",\"type\":\"uint32\"}],\"internalType\":\"struct L1_NovaExecutionManager.GasConfig\",\"name\":\"newGasConfig\",\"type\":\"tuple\"}],\"name\":\"updateGasConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"L1_NovaExecutionManager","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"0000000000000000000000005421e2b1349b33ac17fb611cca538fc2c03a023d00000000000000000000000025ace71c97b33cc4729cf772ae268934f7ab5fa1","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}