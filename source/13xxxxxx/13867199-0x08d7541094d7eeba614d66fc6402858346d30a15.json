{"status":"1","message":"OK","result":[{"SourceCode":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/Arb.sol\n// SPDX-License-Identifier: UNLICENSED\npragma solidity =0.8.6 >=0.8.6 <0.9.0;\n\n////// src/IBasicIssuance.sol\n/* pragma solidity 0.8.6; */\n\ninterface IBasicIssuance {\n    function getRequiredComponentUnitsForIssue(\n        address _setToken,\n        uint256 _quantity\n    )\n        external\n        view\n        returns (address[] memory, uint256[] memory);\n\n    function issue(\n        address _setToken,\n        uint256 _quantity,\n        address _to\n    ) external;\n}\n\n////// src/IERC20.sol\n/* pragma solidity ^0.8.6; */\n\ninterface IERC20 {\n    function balanceOf(address _guy) external view returns (uint256);\n    function transfer(address _guy, uint256 _wad) external;\n    function approve(address spender, uint256 amount) external;\n    function allowance(address owner, address spender) external view returns (uint256);\n}\n\n////// src/IExchangeIssuance.sol\n/* pragma solidity ^0.8.6; */\n\ninterface IExchangeIssuance {\n    function redeemExactSetForToken(\n        address _setToken,\n        address _outputToken,\n        uint256 _amountSetToken,\n        uint256 _minOutputReceive\n    ) external returns (uint256);\n\n    function issueExactSetFromToken(\n        address _setToken,\n        address _inputToken,\n        uint256 _amountSetToken,\n        uint256 _maxAmountInputToken\n    ) external returns (uint256);\n}\n\n////// src/ISetToken.sol\n/* pragma solidity 0.8.6; */\n\ninterface ISetToken {\n    function getComponents() external view returns (address[] memory);\n}\n\n////// src/IUniRouter.sol\n// SPDX-License-Identifer: UNLICENSED\n/* pragma solidity 0.8.6; */\n\ninterface IUniRouter {\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n}\n\n////// src/IUniswapV3Pool.sol\n/* pragma solidity ^0.8.6; */\n\ninterface IUniswapV3Pool {\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes memory data\n    ) external returns (int256 amount0, int256 amount1);\n}\n\n////// src/IWETH9.sol\n/* pragma solidity 0.8.6; */\n\ninterface IWETH9 {\n    function deposit() external payable;\n}\n\n////// src/Arb.sol\n/* pragma solidity ^0.8.6; */\n\n/* import { IBasicIssuance } from \"./IBasicIssuance.sol\"; */\n/* import { IERC20 } from \"./IERC20.sol\"; */\n/* import { IExchangeIssuance } from \"./IExchangeIssuance.sol\"; */\n/* import { ISetToken } from \"./ISetToken.sol\"; */\n/* import { IUniRouter } from \"./IUniRouter.sol\"; */\n/* import { IUniswapV3Pool } from \"./IUniswapV3Pool.sol\"; */\n/* import { IWETH9 } from \"./IWETH9.sol\"; */\n\ncontract Arb {\n\n    IUniswapV3Pool constant pool = IUniswapV3Pool(0x9359c87B38DD25192c5f2b07b351ac91C90E6ca7);\n    IExchangeIssuance constant exchangeIssuance = IExchangeIssuance(0xc8C85A3b4d03FB3451e7248Ff94F780c92F884fD);\n    IBasicIssuance constant basicIssuance = IBasicIssuance(0xd8EF3cACe8b4907117a45B0b125c68560532F94D);\n\n    IUniRouter constant uniRouter = IUniRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n    IUniRouter constant sushiRouter = IUniRouter(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n\n    address constant inst = 0x6f40d4A6237C257fff2dB00FA0510DeEECd303eb;\n    address constant badger = 0x3472A5A71965499acd81997a54BBA8D852C6E53d;\n    address constant wbtc = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n    address constant knc = 0xdeFA4e8a7bcBA345F687a2f1456F5Edd9CE97202;\n\n    IUniswapV3Pool constant instPool = IUniswapV3Pool(0xCba27C8e7115b4Eb50Aa14999BC0866674a96eCB);\n\n    IERC20 constant dpi = IERC20(0x1494CA1F11D487c2bBe4543E90080AeBa4BA3C2b);\n    IERC20 constant weth = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n\n    constructor() {\n        dpi.approve(address(exchangeIssuance), type(uint256).max);\n        dpi.approve(address(pool), type(uint256).max);\n        weth.approve(address(exchangeIssuance), type(uint256).max);\n        weth.approve(address(pool), type(uint256).max);\n\n        weth.approve(address(uniRouter), type(uint256).max);\n        weth.approve(address(sushiRouter), type(uint256).max);\n        weth.approve(address(instPool), type(uint256).max);\n    }\n\n    function buy(uint256 _dpiAmount) external {\n\n        pool.swap(\n            address(this),\n            false,\n            -int256(_dpiAmount),\n            1461446703485210103287273052203988822378723970341,\n            bytes(abi.encode(true, msg.sender))\n        );\n    }\n\n    function sell(uint256 _dpiAmount) external {\n\n        pool.swap(\n            address(this),\n            true,\n            int256(_dpiAmount),\n            4295128740,\n            bytes(abi.encode(false, msg.sender))\n        );\n    }\n\n    function approve() external {\n        address[] memory components = ISetToken(address(dpi)).getComponents();\n\n        for (uint256 i = 0; i < components.length; i++) {\n            IERC20 component = IERC20(components[i]);\n            if(component.allowance(address(this), address(basicIssuance)) == 0) {\n                component.approve(address(basicIssuance), type(uint256).max);\n            }\n        }\n    }\n\n    function uniswapV3SwapCallback(int256 a, int256 b, bytes calldata c) external {\n        (bool isBuy, address to) = abi.decode(c, (bool, address));\n\n        if (to == address(0)) {\n            weth.transfer(address(instPool), uint256(b));\n            return;\n        }\n\n        if (isBuy) {\n            _completeBuy(uint256(b), to);\n            weth.transfer(address(pool), uint256(b));\n        } else {\n            _completeSell(uint256(a), to);\n            dpi.transfer(address(pool), uint256(a));\n        }\n    }\n\n    function _completeBuy(uint256 _back, address _to) internal {\n\n        uint256 dpiBalance = dpi.balanceOf(address(this));\n        uint256 out = exchangeIssuance.redeemExactSetForToken(\n            address(dpi),\n            address(weth),\n            dpiBalance,\n            0\n        );\n\n        weth.transfer(_to, out - _back);\n    }\n\n    function _completeSell(uint256 _back, address _to) internal {\n\n        _issue(_back);\n\n        uint256 wethBalance = weth.balanceOf(address(this));\n        weth.transfer(_to, wethBalance);\n    }\n\n    function _issue(uint256 _amount) internal {\n        (address[] memory components, uint256[] memory amounts) =\n            basicIssuance.getRequiredComponentUnitsForIssue(address(dpi), _amount);\n\n        for (uint256 i = 0; i < components.length; i++) {\n            _buyComponent(components[i], amounts[i]);\n        }\n\n        basicIssuance.issue(address(dpi), _amount, address(this));\n    }\n\n    function _buyComponent(address _token, uint256 _amount) internal {\n\n        if (_token == inst) {\n            instPool.swap(\n                address(this),\n                false,\n                -int256(_amount),\n                1461446703485210103287273052203988822378723970341,\n                bytes(abi.encode(true, address(0)))\n            );\n        } else if (_token == badger) {\n            address[] memory path = new address[](3);\n            path[0] = address(weth);\n            path[1] = wbtc;\n            path[2] = _token;\n\n            uniRouter.swapTokensForExactTokens(\n                _amount,\n                type(uint256).max,\n                path,\n                address(this),\n                type(uint256).max\n            );\n        } else {\n            address[] memory path = new address[](2);\n            path[0] = address(weth);\n            path[1] = _token;\n\n            IUniRouter router = _token == knc ? sushiRouter : uniRouter;\n\n            router.swapTokensForExactTokens(\n                _amount,\n                type(uint256).max,\n                path,\n                address(this),\n                type(uint256).max\n            );\n        }\n    }\n\n    receive() external payable {\n        IWETH9(address(weth)).deposit{value: msg.value}();\n    }\n}\n","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dpiAmount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dpiAmount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"a\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"b\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"c\",\"type\":\"bytes\"}],\"name\":\"uniswapV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Arb","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}