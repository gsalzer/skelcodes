{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT OR Apache-2.0\r\n\r\npragma solidity 0.8.6;\r\npragma abicoder v2; // solhint-disable-line\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Attempt to send ETH and if the transfer fails or runs out of gas, store the balance\r\n * for future withdrawal instead.\r\n */\r\nabstract contract SendValueWithFallbackWithdraw is ReentrancyGuard {\r\n  using Address for address payable;\r\n\r\n  mapping(address => uint256) private pendingWithdrawals;\r\n\r\n  event WithdrawPending(address indexed user, uint256 amount);\r\n  event Withdrawal(address indexed user, uint256 amount);\r\n\r\n  /**\r\n   * @notice Returns how much funds are available for manual withdraw due to failed transfers.\r\n   */\r\n  function getPendingWithdrawal(address user) public view returns (uint256) {\r\n    return pendingWithdrawals[user];\r\n  }\r\n\r\n  /**\r\n   * @notice Allows a user to manually withdraw funds which originally failed to transfer to themselves.\r\n   */\r\n  function withdraw() public {\r\n    withdrawFor(payable(msg.sender));\r\n  }\r\n\r\n  /**\r\n   * @notice Allows anyone to manually trigger a withdrawal of funds which originally failed to transfer for a user.\r\n   */\r\n  function withdrawFor(address payable user) public nonReentrant {\r\n    uint256 amount = pendingWithdrawals[user];\r\n    require(amount > 0, \"No funds are pending withdrawal\");\r\n    pendingWithdrawals[user] = 0;\r\n    user.sendValue(amount);\r\n    emit Withdrawal(user, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Attempt to send a user ETH with a reasonably low gas limit of 20k,\r\n   * which is enough to send to contracts as well.\r\n   */\r\n  function _sendValueWithFallbackWithdrawWithLowGasLimit(address user, uint256 amount) internal {\r\n    _sendValueWithFallbackWithdraw(user, amount, 20000);\r\n  }\r\n\r\n  /**\r\n   * @dev Attempt to send a user or contract ETH with a moderate gas limit of 90k,\r\n   * which is enough for a 5-way split.\r\n   */\r\n  function _sendValueWithFallbackWithdrawWithMediumGasLimit(address user, uint256 amount) internal {\r\n    _sendValueWithFallbackWithdraw(user, amount, 210000);\r\n  }\r\n\r\n  /**\r\n   * @dev Attempt to send a user or contract ETH and if it fails store the amount owned for later withdrawal.\r\n   */\r\n  function _sendValueWithFallbackWithdraw(\r\n    address user,\r\n    uint256 amount,\r\n    uint256 gasLimit\r\n  ) private {\r\n    if (amount == 0) {\r\n      return;\r\n    }\r\n    // Cap the gas to prevent consuming all available gas to block a tx from completing successfully\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, ) = payable(user).call{ value: amount, gas: gasLimit }(\"\");\r\n    if (!success) {\r\n      // Record failed sends for a withdrawal later\r\n      // Transfers could fail if sent to a multisig with non-trivial receiver logic\r\n      // solhint-disable-next-line reentrancy\r\n      pendingWithdrawals[user] = pendingWithdrawals[user] + amount;\r\n      emit WithdrawPending(user, amount);\r\n    }\r\n  }\r\n}\r\n\r\n\r\ninterface ICAAsset {\r\n\r\n  function ownerOf(uint256 _tokenId) external view returns (address _owner);\r\n  function exists(uint256 _tokenId) external view returns (bool _exists);\r\n  \r\n  function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n  function safeTransferFrom(address _from , address _to, uint256 _tokenId, bytes memory _data) external;\r\n\r\n  function editionOfTokenId(uint256 _tokenId) external view returns (uint256 tokenId);\r\n\r\n  function artistCommission(uint256 _tokenId) external view returns (address _artistAccount, uint256 _artistCommission);\r\n\r\n  function editionOptionalCommission(uint256 _tokenId) external view returns (uint256 _rate, address _recipient);\r\n\r\n  function mint(address _to, uint256 _editionNumber) external returns (uint256);\r\n\r\n  function approve(address _to, uint256 _tokenId) external;\r\n\r\n\r\n\r\n  function createActiveEdition(\r\n    uint256 _editionNumber,\r\n    bytes32 _editionData,\r\n    uint256 _editionType,\r\n    uint256 _startDate,\r\n    uint256 _endDate,\r\n    address _artistAccount,\r\n    uint256 _artistCommission,\r\n    uint256 _priceInWei,\r\n    string memory _tokenUri,\r\n    uint256 _totalAvailable\r\n  ) external returns (bool);\r\n\r\n  function artistsEditions(address _artistsAccount) external returns (uint256[] memory _editionNumbers);\r\n\r\n  function totalAvailableEdition(uint256 _editionNumber) external returns (uint256);\r\n\r\n  function highestEditionNumber() external returns (uint256);\r\n\r\n  function updateOptionalCommission(uint256 _editionNumber, uint256 _rate, address _recipient) external;\r\n\r\n  function updateStartDate(uint256 _editionNumber, uint256 _startDate) external;\r\n\r\n  function updateEndDate(uint256 _editionNumber, uint256 _endDate) external;\r\n\r\n  function updateEditionType(uint256 _editionNumber, uint256 _editionType) external;\r\n}\r\n\r\n\r\n/**\r\n * @dev Constant values shared across mixins.\r\n */\r\nabstract contract Constants {\r\n  uint32 internal constant BASIS_POINTS = 10000;\r\n}\r\n\r\n\r\n\r\n/**\r\n * @notice A mixin to distribute funds when an NFT is sold.\r\n */\r\nabstract contract NFTMarketFees is\r\n  Constants,\r\n  SendValueWithFallbackWithdraw\r\n{\r\n\r\n  event MarketFeesUpdated(\r\n    uint32 caPoints,\r\n    uint32 artistPoints,\r\n    uint32 sellerPoints,\r\n    uint32 auctionAwardPoints,\r\n    uint32 sharePoints\r\n  );\r\n\r\n  ICAAsset immutable caAsset;\r\n  uint32 private caPoints;\r\n  uint32 private sharePoints;\r\n  uint32 private artistPoints;\r\n  uint32 private sellerPoints;\r\n\r\n  uint32 private auctionAwardPoints;\r\n  \r\n  uint256 public withdrawThreshold;\r\n\r\n  address payable private treasury;\r\n\r\n\r\n  mapping(address => uint256) public awards;\r\n\r\n  mapping(uint256 => bool) private nftContractToTokenIdToFirstSaleCompleted;\r\n\r\n\r\n  event AuctionAwardUpdated(uint256 indexed auctionId, address indexed bidder, uint256 award);\r\n  event ShareAwardUpdated(address indexed share, uint256 award);\r\n\r\n  /**\r\n   * @dev Called once after the initial deployment to set the CART treasury address.\r\n   */\r\n  constructor(\r\n    ICAAsset _caAsset,\r\n    address payable _treasury) {\r\n    require(_treasury != address(0), \"NFTMarketFees: Address not zero\");\r\n    caAsset = _caAsset;\r\n    treasury = _treasury;\r\n\r\n    caPoints = 150;\r\n    sharePoints = 100;\r\n    artistPoints = 1000;\r\n    sellerPoints = 8250;\r\n    auctionAwardPoints = 500;\r\n\r\n    withdrawThreshold = 0.1 ether;\r\n  }\r\n\r\n  function setCATreasury(address payable _treasury) external {\r\n    require(_treasury != msg.sender, \"NFTMarketFees: no permission\");\r\n    require(_treasury != address(0), \"NFTMarketFees: Address not zero\");\r\n    treasury = _treasury;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the address of the CART treasury.\r\n   */\r\n  function getCATreasury() public view returns (address payable) {\r\n    return treasury;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns true if the given NFT has not been sold in this market previously and is being sold by the creator.\r\n   */\r\n  function getIsPrimary(uint256 tokenId) public view returns (bool) {\r\n    return !nftContractToTokenIdToFirstSaleCompleted[tokenId];\r\n  }\r\n\r\n  function getArtist(uint256 tokenId) public view returns (address artist) {\r\n      uint256 editionNumber = caAsset.editionOfTokenId(tokenId);\r\n      (artist,) = caAsset.artistCommission(editionNumber);\r\n  }\r\n\r\n\r\n  /**\r\n   * @notice Returns how funds will be distributed for a sale at the given price point.\r\n   * @dev This could be used to present exact fee distributing on listing or before a bid is placed.\r\n   */\r\n  function getFees(uint tokenId, uint256 price)\r\n    public\r\n    view\r\n    returns (\r\n      uint256 caFee,\r\n      uint256 artistFee,\r\n      uint256 sellerFee,\r\n      uint256 auctionFee,\r\n      uint256 shareFee\r\n    )\r\n  {\r\n    sellerFee = sellerPoints * price / BASIS_POINTS;\r\n    // 首次拍卖的时候，作家即卖家，联名者需参与分成\r\n    if (!nftContractToTokenIdToFirstSaleCompleted[tokenId]) {\r\n        caFee = (caPoints + artistPoints) * price / BASIS_POINTS;\r\n        artistFee = sellerFee;\r\n        sellerFee = 0;\r\n    } else {\r\n        caFee = caPoints * price / BASIS_POINTS;\r\n        artistFee = artistPoints * price / BASIS_POINTS;\r\n    }\r\n\r\n    auctionFee = auctionAwardPoints * price / BASIS_POINTS;\r\n    shareFee = sharePoints * price / BASIS_POINTS;\r\n  }\r\n\r\n  function withdrawFunds(address to) external {\r\n    require(awards[msg.sender] >= withdrawThreshold, \"NFTMarketFees: under withdrawThreshold\");\r\n    uint wdAmount= awards[msg.sender];\r\n    awards[msg.sender] = 0;\r\n    _sendValueWithFallbackWithdrawWithMediumGasLimit(to, wdAmount);\r\n  }\r\n\r\n  function _distributeBidFunds(\r\n      uint256 lastPrice,\r\n      uint256 auctionId,\r\n      uint256 price,\r\n      address bidder\r\n  ) internal {\r\n      uint award = auctionAwardPoints * (price - lastPrice) / BASIS_POINTS;\r\n      awards[bidder] += award;\r\n\r\n      emit AuctionAwardUpdated(auctionId, bidder, award);\r\n  }\r\n\r\n  /**\r\n   * @dev Distributes funds to foundation, creator, and NFT owner after a sale.\r\n   */\r\n  function _distributeFunds(\r\n    uint256 tokenId,\r\n    address seller,\r\n    address shareUser,\r\n    uint256 price\r\n  ) internal {\r\n    (uint caFee, uint artistFee, uint sellerFee, ,uint shareFee) = getFees(tokenId, price);\r\n    \r\n    if (shareUser == address(0)) {\r\n      _sendValueWithFallbackWithdrawWithLowGasLimit(treasury, caFee + shareFee);\r\n    } else {\r\n      _sendValueWithFallbackWithdrawWithLowGasLimit(treasury, caFee);\r\n      awards[shareUser] += shareFee;\r\n\r\n      emit ShareAwardUpdated(shareUser, shareFee);\r\n    }\r\n\r\n      uint256 editionNumber = caAsset.editionOfTokenId(tokenId);\r\n      (address artist, uint256 artistRate) = caAsset.artistCommission(editionNumber);\r\n      (uint256 optionalRate, address optionalRecipient) = caAsset.editionOptionalCommission(editionNumber);\r\n    \r\n      if (optionalRecipient == address(0)) { \r\n        if (artist == seller) {\r\n          _sendValueWithFallbackWithdrawWithMediumGasLimit(seller, artistFee + sellerFee);\r\n        } else {\r\n          _sendValueWithFallbackWithdrawWithMediumGasLimit(seller, sellerFee);\r\n          _sendValueWithFallbackWithdrawWithMediumGasLimit(artist, artistFee);\r\n        }\r\n      } else {\r\n        uint optionalFee = artistFee * optionalRate / (optionalRate + artistRate);\r\n        if (optionalFee > 0) {\r\n          _sendValueWithFallbackWithdrawWithMediumGasLimit(optionalRecipient, optionalFee);\r\n        }\r\n\r\n        if (artist == seller) {\r\n          _sendValueWithFallbackWithdrawWithMediumGasLimit(seller, artistFee + sellerFee - optionalFee);\r\n        } else {\r\n          _sendValueWithFallbackWithdrawWithMediumGasLimit(seller, sellerFee);\r\n          _sendValueWithFallbackWithdrawWithMediumGasLimit(artist, artistFee - optionalFee);\r\n        }\r\n      }\r\n\r\n    // Anytime fees are distributed that indicates the first sale is complete,\r\n    // which will not change state during a secondary sale.\r\n    // This must come after the `getFees` call above as this state is considered in the function.\r\n    nftContractToTokenIdToFirstSaleCompleted[tokenId] = true;\r\n  }\r\n\r\n\r\n  /**\r\n   * @notice Returns the current fee configuration in basis points.\r\n   */\r\n  function getFeeConfig()\r\n    public\r\n    view\r\n    returns (\r\n      uint32 ,\r\n      uint32 ,\r\n      uint32 ,\r\n      uint32 ,\r\n      uint32) {\r\n    return (caPoints, artistPoints, sellerPoints, auctionAwardPoints, sharePoints);\r\n  }\r\n\r\n  function _updateWithdrawThreshold(uint256 _withdrawalThreshold) internal {\r\n    withdrawThreshold = _withdrawalThreshold;\r\n  }\r\n\r\n  /**\r\n   * @notice Allows CA to change the market fees.\r\n   */\r\n  function _updateMarketFees(\r\n    uint32 _caPoints,\r\n    uint32 _artistPoints,\r\n    uint32 _sellerPoints,\r\n    uint32 _auctionAwardPoints,\r\n    uint32 _sharePoints\r\n  ) internal {\r\n    require(_caPoints + _artistPoints + _sellerPoints + _auctionAwardPoints + _sharePoints < BASIS_POINTS, \"NFTMarketFees: Fees >= 100%\");\r\n\r\n    caPoints = caPoints;\r\n    artistPoints = _artistPoints;\r\n    sellerPoints = _sellerPoints;\r\n    auctionAwardPoints = _auctionAwardPoints;\r\n    sharePoints = _sharePoints;\r\n\r\n    emit MarketFeesUpdated(\r\n      _caPoints,\r\n      _artistPoints,\r\n      _sellerPoints,\r\n      _auctionAwardPoints,\r\n      _sharePoints\r\n    );\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @notice An abstraction layer for auctions.\r\n * @dev This contract can be expanded with reusable calls and data as more auction types are added.\r\n */\r\nabstract contract NFTMarketAuction {\r\n  /**\r\n   * @dev A global id for auctions of any type.\r\n   */\r\n  uint256 private nextAuctionId = 1;\r\n\r\n\r\n  function _getNextAndIncrementAuctionId() internal returns (uint256) {\r\n    return nextAuctionId++;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @notice Interface for OperatorRole which wraps a role from\r\n * OpenZeppelin's AccessControl for easy integration.\r\n */\r\ninterface IAccessControl {\r\n\r\n  function isCAAdmin(address _operator) external view returns (bool);\r\n  function hasRole(address _operator, uint8 _role) external view returns (bool);\r\n  function canPlayRole(address _operator, uint8 _role) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice Manages a reserve price countdown auction for NFTs.\r\n */\r\nabstract contract NFTMarketReserveAuction is\r\n  Constants,\r\n  ReentrancyGuard,\r\n  SendValueWithFallbackWithdraw,\r\n  NFTMarketFees,\r\n  NFTMarketAuction\r\n{\r\n\r\n  struct ReserveAuction {\r\n    uint256 tokenId;\r\n    address seller;\r\n    uint32 duration;\r\n    uint32 extensionDuration;\r\n    uint32 endTime;\r\n    address bidder;\r\n    uint256 amount;\r\n    address shareUser;\r\n  }\r\n\r\n  mapping(uint256 => uint256) private nftTokenIdToAuctionId;\r\n  mapping(uint256 => ReserveAuction) private auctionIdToAuction;\r\n\r\n  IAccessControl public immutable accessControl;\r\n\r\n  uint32 private _minPercentIncrementInBasisPoints;\r\n\r\n  uint32 private _duration;\r\n\r\n  // Cap the max duration so that overflows will not occur\r\n  uint32 private constant MAX_MAX_DURATION = 1000 days;\r\n\r\n  uint32 private constant EXTENSION_DURATION = 15 minutes;\r\n\r\n  event ReserveAuctionConfigUpdated(\r\n    uint32 minPercentIncrementInBasisPoints,\r\n    uint256 maxBidIncrementRequirement,\r\n    uint256 duration,\r\n    uint256 extensionDuration,\r\n    uint256 goLiveDate\r\n  );\r\n\r\n  event ReserveAuctionCreated(\r\n    address indexed seller,\r\n    uint256 indexed tokenId,\r\n    uint256 indexed auctionId,\r\n    uint256 duration,\r\n    uint256 extensionDuration,\r\n    uint256 reservePrice\r\n    \r\n  );\r\n  event ReserveAuctionUpdated(uint256 indexed auctionId, uint256 reservePrice);\r\n  event ReserveAuctionCanceled(uint256 indexed auctionId);\r\n  event ReserveAuctionBidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount, uint256 endTime);\r\n  event ReserveAuctionFinalized(\r\n    uint256 indexed auctionId,\r\n    address indexed seller,\r\n    address indexed bidder,\r\n    uint256 tokenId,\r\n    uint256 amount\r\n  );\r\n  event ReserveAuctionCanceledByAdmin(uint256 indexed auctionId, string reason);\r\n  event ReserveAuctionSellerMigrated(\r\n    uint256 indexed auctionId,\r\n    address indexed originalSellerAddress,\r\n    address indexed newSellerAddress\r\n  );\r\n\r\n  modifier onlyValidAuctionConfig(uint256 reservePrice) {\r\n    require(reservePrice > 0, \"NFTMarketReserveAuction: Reserve price must be at least 1 wei\");\r\n    _;\r\n  }\r\n\r\n  modifier onlyCAAdmin(address user) {\r\n    require(accessControl.isCAAdmin(user), \"CAAdminRole: caller does not have the Admin role\");\r\n    _;\r\n  }\r\n\r\n  constructor(IAccessControl access) {\r\n    _duration = 24 hours; // A sensible default value\r\n    accessControl = access;\r\n    _minPercentIncrementInBasisPoints = 1000;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns auction details for a given auctionId.\r\n   */\r\n  function getReserveAuction(uint256 auctionId) public view returns (ReserveAuction memory) {\r\n    return auctionIdToAuction[auctionId];\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the auctionId for a given NFT, or 0 if no auction is found.\r\n   * @dev If an auction is canceled, it will not be returned. However the auction may be over and pending finalization.\r\n   */\r\n  function getReserveAuctionIdFor(uint256 tokenId) public view returns (uint256) {\r\n    return nftTokenIdToAuctionId[tokenId];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the seller that put a given NFT into escrow,\r\n   * or bubbles the call up to check the current owner if the NFT is not currently in escrow.\r\n   */\r\n  function getSellerFor(uint256 tokenId)\r\n    internal\r\n    view\r\n    virtual\r\n    returns (address)\r\n  {\r\n    address seller = auctionIdToAuction[nftTokenIdToAuctionId[tokenId]].seller;\r\n    if (seller == address(0)) {\r\n      return caAsset.ownerOf(tokenId);\r\n    }\r\n    return seller;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the current configuration for reserve auctions.\r\n   */\r\n  function getReserveAuctionConfig() public view returns (uint256 minPercentIncrementInBasisPoints, uint256 duration) {\r\n    minPercentIncrementInBasisPoints = _minPercentIncrementInBasisPoints;\r\n    duration = _duration;\r\n  }\r\n\r\n\r\n\r\n  function _updateReserveAuctionConfig(uint32 minPercentIncrementInBasisPoints, uint32 duration) internal {\r\n    require(minPercentIncrementInBasisPoints <= BASIS_POINTS, \"NFTMarketReserveAuction: Min increment must be <= 100%\");\r\n    // Cap the max duration so that overflows will not occur\r\n    require(duration <= MAX_MAX_DURATION, \"NFTMarketReserveAuction: Duration must be <= 1000 days\");\r\n    require(duration >= EXTENSION_DURATION, \"NFTMarketReserveAuction: Duration must be >= EXTENSION_DURATION\");\r\n    _minPercentIncrementInBasisPoints = minPercentIncrementInBasisPoints;\r\n    _duration = duration;\r\n\r\n    // We continue to emit unused configuration variables to simplify the subgraph integration.\r\n    emit ReserveAuctionConfigUpdated(minPercentIncrementInBasisPoints, 0, duration, EXTENSION_DURATION, 0);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates an auction for the given NFT.\r\n   * The NFT is held in escrow until the auction is finalized or canceled.\r\n   */\r\n  function createReserveAuction(\r\n    uint256 tokenId,\r\n    address seller,\r\n    uint256 reservePrice\r\n  ) public onlyValidAuctionConfig(reservePrice) nonReentrant {\r\n    \r\n    // If an auction is already in progress then the NFT would be in escrow and the modifier would have failed\r\n    uint256 auctionId = _getNextAndIncrementAuctionId();\r\n    nftTokenIdToAuctionId[tokenId] = auctionId;\r\n    auctionIdToAuction[auctionId] = ReserveAuction(\r\n      tokenId,\r\n      seller,\r\n      _duration,\r\n      EXTENSION_DURATION,\r\n      0, // endTime is only known once the reserve price is met\r\n      address(0), // bidder is only known once a bid has been placed\r\n      reservePrice,\r\n      address(0)\r\n    );\r\n\r\n    caAsset.transferFrom(msg.sender, address(this), tokenId);\r\n\r\n    emit ReserveAuctionCreated(\r\n      seller,\r\n      tokenId,\r\n      auctionId,\r\n      _duration,\r\n      EXTENSION_DURATION,\r\n      reservePrice\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice If an auction has been created but has not yet received bids, the configuration\r\n   * such as the reservePrice may be changed by the seller.\r\n   */\r\n  function updateReserveAuction(uint256 auctionId, uint256 reservePrice) public onlyValidAuctionConfig(reservePrice) {\r\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\r\n    require(auction.seller == msg.sender, \"NFTMarketReserveAuction: Not your auction\");\r\n    require(auction.endTime == 0, \"NFTMarketReserveAuction: Auction in progress\");\r\n\r\n    auction.amount = reservePrice;\r\n\r\n    emit ReserveAuctionUpdated(auctionId, reservePrice);\r\n  }\r\n\r\n  /**\r\n   * @notice If an auction has been created but has not yet received bids, it may be canceled by the seller.\r\n   * The NFT is returned to the seller from escrow.\r\n   */\r\n  function cancelReserveAuction(uint256 auctionId) public nonReentrant {\r\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\r\n    require(auction.seller == msg.sender, \"NFTMarketReserveAuction: Not your auction\");\r\n    require(auction.endTime == 0, \"NFTMarketReserveAuction: Auction in progress\");\r\n\r\n    delete nftTokenIdToAuctionId[auction.tokenId];\r\n    delete auctionIdToAuction[auctionId];\r\n\r\n    caAsset.transferFrom(address(this), auction.seller, auction.tokenId);\r\n\r\n    emit ReserveAuctionCanceled(auctionId);\r\n  }\r\n\r\n  /**\r\n   * @notice A bidder may place a bid which is at least the value defined by `getMinBidAmount`.\r\n   * If this is the first bid on the auction, the countdown will begin.\r\n   * If there is already an outstanding bid, the previous bidder will be refunded at this time\r\n   * and if the bid is placed in the final moments of the auction, the countdown may be extended.\r\n   */\r\n  function placeBid(uint256 auctionId, address shareUser) public payable nonReentrant {\r\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\r\n    require(auction.amount != 0, \"NFTMarketReserveAuction: Auction not found\");\r\n\r\n    if (auction.endTime == 0) {\r\n      // If this is the first bid, ensure it's >= the reserve price\r\n      require(auction.amount <= msg.value, \"NFTMarketReserveAuction: Bid must be at least the reserve price\");\r\n    } else {\r\n      // If this bid outbids another, confirm that the bid is at least x% greater than the last\r\n      require(auction.endTime >= block.timestamp, \"NFTMarketReserveAuction: Auction is over\");\r\n      require(auction.bidder != msg.sender, \"NFTMarketReserveAuction: You already have an outstanding bid\");\r\n      uint256 minAmount = _getMinBidAmountForReserveAuction(auction.amount);\r\n      require(msg.value >= minAmount, \"NFTMarketReserveAuction: Bid amount too low\");\r\n    }\r\n\r\n    if (auction.endTime == 0) {\r\n      auction.amount = msg.value;\r\n      auction.bidder = msg.sender;\r\n      // On the first bid, the endTime is now + duration\r\n      auction.endTime = uint32(block.timestamp) + auction.duration;\r\n      auction.shareUser = shareUser;\r\n\r\n      _distributeBidFunds(0, auctionId, msg.value, msg.sender);\r\n    } else {\r\n      // Cache and update bidder state before a possible reentrancy (via the value transfer)\r\n      uint256 originalAmount = auction.amount;\r\n      address originalBidder = auction.bidder;\r\n      auction.amount = msg.value;\r\n      auction.bidder = msg.sender;\r\n      auction.shareUser = shareUser;\r\n\r\n      // When a bid outbids another, check to see if a time extension should apply.\r\n      if (auction.endTime - uint32(block.timestamp) < auction.extensionDuration) {\r\n        auction.endTime = uint32(block.timestamp) + auction.extensionDuration;\r\n      }\r\n      \r\n      _distributeBidFunds(originalAmount, auctionId, msg.value, msg.sender);\r\n\r\n      // Refund the previous bidder\r\n      _sendValueWithFallbackWithdrawWithLowGasLimit(originalBidder, originalAmount);\r\n    }\r\n\r\n    emit ReserveAuctionBidPlaced(auctionId, msg.sender, msg.value, auction.endTime);\r\n  }\r\n\r\n  /**\r\n   * @notice Once the countdown has expired for an auction, anyone can settle the auction.\r\n   * This will send the NFT to the highest bidder and distribute funds.\r\n   */\r\n  function finalizeReserveAuction(uint256 auctionId) public nonReentrant {\r\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\r\n    require(auction.endTime > 0, \"NFTMarketReserveAuction: Auction was already settled\");\r\n    require(auction.endTime < uint32(block.timestamp), \"NFTMarketReserveAuction: Auction still in progress\");\r\n\r\n    delete nftTokenIdToAuctionId[auction.tokenId];\r\n    delete auctionIdToAuction[auctionId];\r\n\r\n    caAsset.transferFrom(address(this), auction.bidder, auction.tokenId);\r\n\r\n    _distributeFunds(auction.tokenId, auction.seller, auction.shareUser, auction.amount);\r\n\r\n    emit ReserveAuctionFinalized(auctionId, auction.seller, auction.bidder, auction.tokenId, auction.amount);\r\n  }\r\n\r\n\r\n  /**\r\n   * @notice Returns the minimum amount a bidder must spend to participate in an auction.\r\n   */\r\n  function getMinBidAmount(uint256 auctionId) public view returns (uint256) {\r\n    ReserveAuction storage auction = auctionIdToAuction[auctionId];\r\n    if (auction.endTime == 0) {\r\n      return auction.amount;\r\n    }\r\n    return _getMinBidAmountForReserveAuction(auction.amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Determines the minimum bid amount when outbidding another user.\r\n   */\r\n  function _getMinBidAmountForReserveAuction(uint256 currentBidAmount) private view returns (uint256) {\r\n    uint256 minIncrement = currentBidAmount * _minPercentIncrementInBasisPoints / BASIS_POINTS;\r\n    if (minIncrement == 0) {\r\n      // The next bid must be at least 1 wei greater than the current.\r\n      return currentBidAmount + 1;\r\n    }\r\n    return minIncrement + currentBidAmount;\r\n  }\r\n\r\n  /**\r\n   * @notice Allows Foundation to cancel an auction, refunding the bidder and returning the NFT to the seller.\r\n   * This should only be used for extreme cases such as DMCA takedown requests. The reason should always be provided.\r\n   */\r\n  function adminCancelReserveAuction(uint256 auctionId, string memory reason) public onlyCAAdmin(msg.sender) {\r\n    require(bytes(reason).length > 0, \"NFTMarketReserveAuction: Include a reason for this cancellation\");\r\n    ReserveAuction memory auction = auctionIdToAuction[auctionId];\r\n    require(auction.amount > 0, \"NFTMarketReserveAuction: Auction not found\");\r\n\r\n    delete nftTokenIdToAuctionId[auction.tokenId];\r\n    delete auctionIdToAuction[auctionId];\r\n\r\n    caAsset.transferFrom(address(this), auction.seller, auction.tokenId);\r\n    if (auction.bidder != address(0)) {\r\n      _sendValueWithFallbackWithdrawWithMediumGasLimit(auction.bidder, auction.amount);\r\n    }\r\n\r\n    emit ReserveAuctionCanceledByAdmin(auctionId, reason);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title A market for NFTs on CA.\r\n * @dev This top level file holds no data directly to ease future upgrades.\r\n */\r\ncontract CANFTMarket is\r\n  ReentrancyGuard,\r\n  SendValueWithFallbackWithdraw,\r\n  NFTMarketFees,\r\n  NFTMarketAuction,\r\n  NFTMarketReserveAuction\r\n{\r\n  /**\r\n   * @notice Called once to configure the contract after the initial deployment.\r\n   * @dev This farms the initialize call out to inherited contracts as needed.\r\n   */\r\n  constructor (IAccessControl access,\r\n    ICAAsset caAsset,\r\n    address payable treasury)\r\n    NFTMarketFees(caAsset, treasury)\r\n    NFTMarketReserveAuction(access) {\r\n  }\r\n\r\n\r\n  /**\r\n   * @notice Allows Foundation to update the market configuration.\r\n   */\r\n  function adminUpdateConfig(\r\n    uint32 minPercentIncrementInBasisPoints,\r\n    uint32 duration,\r\n    uint32 _caPoints,\r\n    uint32 _artistPoints,\r\n    uint32 _sellerPoints,\r\n    uint32 _auctionAwardPoints,\r\n    uint32 _sharePoints\r\n  ) public onlyCAAdmin(msg.sender) {\r\n    _updateReserveAuctionConfig(minPercentIncrementInBasisPoints, duration);\r\n    _updateMarketFees(_caPoints, _artistPoints, _sellerPoints, _auctionAwardPoints, _sharePoints);\r\n  }\r\n\r\n  function adminUpdateWithdrawThreshold(uint256 _withdrawalThreshold) public onlyCAAdmin(msg.sender) {\r\n    _updateWithdrawThreshold(_withdrawalThreshold);\r\n  }\r\n\r\n    /**\r\n   * @dev Allows for the ability to extract stuck ether\r\n   * @dev Only callable from owner\r\n   */\r\n  function withdrawStuckEther(address _withdrawalAccount) onlyCAAdmin(msg.sender) public {\r\n    require(_withdrawalAccount != address(0), \"Invalid address provided\");\r\n    payable(_withdrawalAccount).transfer(address(this).balance);\r\n  }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IAccessControl\",\"name\":\"access\",\"type\":\"address\"},{\"internalType\":\"contract ICAAsset\",\"name\":\"caAsset\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"award\",\"type\":\"uint256\"}],\"name\":\"AuctionAwardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"caPoints\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"artistPoints\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"sellerPoints\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"auctionAwardPoints\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"sharePoints\",\"type\":\"uint32\"}],\"name\":\"MarketFeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionBidPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"ReserveAuctionCanceledByAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"minPercentIncrementInBasisPoints\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxBidIncrementRequirement\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"extensionDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"goLiveDate\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionConfigUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"extensionDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"originalSellerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newSellerAddress\",\"type\":\"address\"}],\"name\":\"ReserveAuctionSellerMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"share\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"award\",\"type\":\"uint256\"}],\"name\":\"ShareAwardUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accessControl\",\"outputs\":[{\"internalType\":\"contract IAccessControl\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"adminCancelReserveAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"minPercentIncrementInBasisPoints\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_caPoints\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_artistPoints\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_sellerPoints\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_auctionAwardPoints\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_sharePoints\",\"type\":\"uint32\"}],\"name\":\"adminUpdateConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawalThreshold\",\"type\":\"uint256\"}],\"name\":\"adminUpdateWithdrawThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"awards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"cancelReserveAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"}],\"name\":\"createReserveAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"finalizeReserveAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getArtist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCATreasury\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeConfig\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"getFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"caFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"artistFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"auctionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shareFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getIsPrimary\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getMinBidAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getPendingWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getReserveAuction\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"extensionDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"shareUser\",\"type\":\"address\"}],\"internalType\":\"struct NFTMarketReserveAuction.ReserveAuction\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserveAuctionConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minPercentIncrementInBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getReserveAuctionIdFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"shareUser\",\"type\":\"address\"}],\"name\":\"placeBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setCATreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"}],\"name\":\"updateReserveAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"withdrawFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_withdrawalAccount\",\"type\":\"address\"}],\"name\":\"withdrawStuckEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CANFTMarket","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000fd160d7ba98506ab1a112edc2a3d4241d8516afc0000000000000000000000003ad503084f1bd8d15a7f5ebe7a038c064e1e3fa1000000000000000000000000db6e076ea582fbe875f6998b610422b9b162a42a","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c0e9a6f6bb3b810e0face83a6cd64b792d946d185f6e3dbeb0d19e24b7aac47f"}]}