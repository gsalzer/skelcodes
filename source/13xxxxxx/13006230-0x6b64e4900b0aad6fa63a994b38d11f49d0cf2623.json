{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.6.0 https://hardhat.org\r\n\r\n// File deps/@openzeppelin/contracts-upgradeable/utils/EnumerableSetUpgradeable.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\r\n * (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSetUpgradeable {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint256(_at(set._inner, index)));\r\n    }\r\n\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/BadgerRegistry.sol\r\n\r\npragma solidity >=0.6.0 <0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract BadgerRegistry {\r\n  using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\r\n\r\n  //@dev is the vault at the experimental, guarded or open stage? Only for Prod Vaults\r\n  enum VaultStatus { experimental, guarded, open }\r\n\r\n  struct VaultData {\r\n    string version;\r\n    VaultStatus status;\r\n    address[] list;\r\n  }\r\n\r\n  //@dev Multisig. Vaults from here are considered Production ready\r\n  address public governance;\r\n  address public devGovernance; //@notice an address with some powers to make things easier in development\r\n\r\n  //@dev Given an Author Address, and Token, Return the Vault\r\n  mapping(address => mapping(string => EnumerableSetUpgradeable.AddressSet)) private vaults;\r\n  mapping(string => address) public addresses;\r\n\r\n  //@dev Given Version and VaultStatus, returns the list of Vaults in production\r\n  mapping(string => mapping(VaultStatus => EnumerableSetUpgradeable.AddressSet)) private productionVaults;\r\n\r\n  // Known constants you can use\r\n  string[] public keys; //@notice, you don't have a guarantee of the key being there, it's just a utility\r\n  string[] public versions; //@notice, you don't have a guarantee of the key being there, it's just a utility\r\n\r\n  event NewVault(address author, string version, address vault);\r\n  event RemoveVault(address author, string version, address vault);\r\n  event PromoteVault(address author, string version, address vault, VaultStatus status);\r\n  event DemoteVault(address author, string version, address vault, VaultStatus status);\r\n\r\n  event Set(string key, address at);\r\n  event AddKey(string key);\r\n  event AddVersion(string version);\r\n\r\n  function initialize(address newGovernance) public {\r\n    require(governance == address(0));\r\n    governance = newGovernance;\r\n    devGovernance = address(0);\r\n\r\n    versions.push(\"v1\"); //For v1\r\n    versions.push(\"v2\"); //For v2\r\n  }\r\n\r\n  function setGovernance(address _newGov) public {\r\n    require(msg.sender == governance, \"!gov\");\r\n    governance = _newGov;\r\n  }\r\n\r\n  function setDev(address newDev) public {\r\n    require(msg.sender == governance || msg.sender == devGovernance, \"!gov\");\r\n    devGovernance = newDev;\r\n  }\r\n\r\n  //@dev Utility function to add Versions for Vaults, \r\n  //@notice No guarantee that it will be properly used\r\n  function addVersions(string memory version) public {\r\n    require(msg.sender == governance, \"!gov\");\r\n    versions.push(version);\r\n\r\n    emit AddVersion(version);\r\n  }\r\n\r\n\r\n  //@dev Anyone can add a vault to here, it will be indexed by their address\r\n  function add(string memory version, address vault) public {\r\n    bool added = vaults[msg.sender][version].add(vault);\r\n    if (added) { \r\n      emit NewVault(msg.sender, version, vault);\r\n    }\r\n  }\r\n\r\n  //@dev Remove the vault from your index\r\n  function remove(string memory version, address vault) public {\r\n    bool removed = vaults[msg.sender][version].remove(vault);\r\n    if (removed) { \r\n      emit RemoveVault(msg.sender, version, vault); \r\n     }\r\n  }\r\n\r\n  //@dev Promote a vault to Production\r\n  //@dev Promote just means indexed by the Governance Address\r\n  function promote(string memory version, address vault, VaultStatus status) public {\r\n    require(msg.sender == governance || msg.sender == devGovernance, \"!gov\");\r\n\r\n    VaultStatus actualStatus = status;\r\n    if(msg.sender == devGovernance) {\r\n      actualStatus = VaultStatus.experimental;\r\n    }\r\n\r\n    bool added = productionVaults[version][actualStatus].add(vault);\r\n\r\n    // If added remove from old and emit event\r\n    if (added) { \r\n      // also remove from old prod\r\n      if(uint256(actualStatus) == 2){\r\n        // Remove from prev2\r\n        productionVaults[version][VaultStatus(0)].remove(vault);\r\n        productionVaults[version][VaultStatus(1)].remove(vault);\r\n      }\r\n      if(uint256(actualStatus) == 1){\r\n        // Remove from prev1\r\n        productionVaults[version][VaultStatus(0)].remove(vault);\r\n      }\r\n\r\n      emit PromoteVault(msg.sender, version, vault, actualStatus); \r\n    }\r\n  }\r\n\r\n  function demote(string memory version, address vault, VaultStatus status) public {\r\n    require(msg.sender == governance || msg.sender == devGovernance, \"!gov\");\r\n\r\n    VaultStatus actualStatus = status;\r\n    if(msg.sender == devGovernance) {\r\n      actualStatus = VaultStatus.experimental;\r\n    }\r\n\r\n    bool removed = productionVaults[version][actualStatus].remove(vault);\r\n\r\n    if (removed) { \r\n      emit DemoteVault(msg.sender, version, vault, status);\r\n    }\r\n  }\r\n\r\n  /** KEY Management */\r\n\r\n  //@dev Set the value of a key to a specific address\r\n  //@notice e.g. controller = 0x123123 \r\n  function set(string memory key, address at) public {\r\n    require(msg.sender == governance, \"!gov\");\r\n    _addKey(key);\r\n    addresses[key] = at;\r\n    emit Set(key, at);\r\n  }\r\n\r\n  //@dev Retrieve the value of a key\r\n  function get(string memory key) public view returns (address){\r\n    return addresses[key];\r\n  }\r\n\r\n  //@dev Add a key to the list of keys\r\n  //@notice This is used to make it easier to discover keys, \r\n  //@notice however you have no guarantee that all keys will be in the list\r\n  function _addKey(string memory key) internal {\r\n    //If we find the key, skip\r\n    bool found = false;\r\n    for(uint256 x = 0; x < keys.length; x++){\r\n      // Compare strings via their hash because solidity\r\n      if(keccak256(bytes(key)) == keccak256(bytes(keys[x]))) {\r\n        found = true;\r\n      }\r\n    }\r\n\r\n    if(found) {\r\n      return;\r\n    }\r\n\r\n    // Else let's add it and emit the event\r\n    keys.push(key);\r\n\r\n    emit AddKey(key);\r\n  }\r\n\r\n  //@dev Retrieve a list of all Vault Addresses from the given author\r\n  function getVaults(string memory version, address author) public view returns (address[] memory) {\r\n    uint256 length = vaults[author][version].length();\r\n\r\n    address[] memory list = new address[](length);\r\n    for (uint256 i = 0; i < length; i++) {\r\n      list[i] = vaults[author][version].at(i);\r\n    }\r\n    return list;\r\n  }\r\n\r\n  //@dev Retrieve a list of all Vaults that are in production, based on Version and Status\r\n  function getFilteredProductionVaults(string memory version, VaultStatus status) public view returns (address[] memory) {\r\n    uint256 length = productionVaults[version][status].length();\r\n\r\n    address[] memory list = new address[](length);\r\n    for (uint256 i = 0; i < length; i++) {\r\n      list[i] = productionVaults[version][status].at(i);\r\n    }\r\n    return list;\r\n  }\r\n\r\n  function getProductionVaults() public view returns (VaultData[] memory) {\r\n    uint256 versionsCount = versions.length;\r\n\r\n    VaultData[] memory data = new VaultData[](versionsCount * 3);\r\n\r\n    for(uint256 x = 0; x < versionsCount; x++) {\r\n      for(uint256 y = 0; y < 3; y++) {\r\n        uint256 length = productionVaults[versions[x]][VaultStatus(y)].length();\r\n        address[] memory list = new address[](length);\r\n        for(uint256 z = 0; z < length; z++){\r\n          list[z] = productionVaults[versions[x]][VaultStatus(y)].at(z);\r\n        }\r\n        data[x * (versionsCount - 1) + y * 2] = VaultData({\r\n          version: versions[x],\r\n          status: VaultStatus(y),\r\n          list: list\r\n        });\r\n      }\r\n    }\r\n\r\n    return data;\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"AddKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"name\":\"AddVersion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"DemoteVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"NewVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"PromoteVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"RemoveVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"at\",\"type\":\"address\"}],\"name\":\"Set\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"name\":\"addVersions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"demote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"get\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"getFilteredProductionVaults\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProductionVaults\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"list\",\"type\":\"address[]\"}],\"internalType\":\"struct BadgerRegistry.VaultData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"author\",\"type\":\"address\"}],\"name\":\"getVaults\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"keys\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"enum BadgerRegistry.VaultStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"promote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"at\",\"type\":\"address\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDev\",\"type\":\"address\"}],\"name\":\"setDev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGov\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"versions\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BadgerRegistry","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e5c1a60481a84a107bc74c7fbe481c8abee8e79f0ca98240a1d71bb7e41c60c3"}]}