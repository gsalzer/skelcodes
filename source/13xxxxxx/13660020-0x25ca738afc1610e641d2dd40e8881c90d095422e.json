{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/LinearVestingHubSnapshot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport {\\n    EnumerableSet\\n} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {Proxied} from \\\"./vendor/hardhat-deploy/Proxied.sol\\\";\\nimport {ILinearVestingHub} from \\\"./interfaces/ILinearVestingHub.sol\\\";\\nimport {Vesting} from \\\"./structs/SVesting.sol\\\";\\nimport {\\n    _getVestedTkns,\\n    _getTknMaxWithdraw\\n} from \\\"./functions/VestingFormulaFunctions.sol\\\";\\n\\ninterface IToken {\\n    function getCurrentVotes(address account_) external view returns (uint96);\\n}\\n\\ninterface ITokenSale {\\n    function gelLockedByWhale(address whale_) external view returns (uint256);\\n}\\n\\ncontract LinearVestingHubSnapshot is Proxied {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    ILinearVestingHub public immutable LINEAR_VESTING_HUB;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    ITokenSale public immutable TOKEN_SALE;\\n\\n    // delegate => List of receivers who delegated their tokens to delegate\\n    mapping(address => EnumerableSet.AddressSet) internal _receiversByDelegate;\\n    // receivers => delegate\\n    mapping(address => address) public delegateByReceiver;\\n\\n    modifier onlyProxyAdminOrReceiver(address _receiver) {\\n        require(\\n            msg.sender == _proxyAdmin() || msg.sender == _receiver,\\n            \\\"LinearVestingHubSnapshot:: only owner or receiver\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(ILinearVestingHub linearVestingHub_, ITokenSale tokenSale_) {\\n        LINEAR_VESTING_HUB = linearVestingHub_;\\n        TOKEN_SALE = tokenSale_;\\n    }\\n\\n    /// @notice Adds a vestedTokenOwners delegation to a delegate\\n    /// @param vestedTokenOwner_ Account to that has vested tokens which wants to add its delegation\\n    /// @param delegate_ Account which should receive the delegated TOKEN voting power\\n    function setDelegate(address vestedTokenOwner_, address delegate_)\\n        external\\n        onlyProxyAdminOrReceiver(vestedTokenOwner_)\\n    {\\n        require(\\n            delegate_ != address(0),\\n            \\\"LinearVestingHubSnapshot:: cannot remove delegate_\\\"\\n        );\\n\\n        // Get tokens locked in LinearVestingHub\\n        uint256 nextVestingId = LINEAR_VESTING_HUB.nextVestingIdByReceiver(\\n            vestedTokenOwner_\\n        );\\n\\n        uint256 amount;\\n        for (uint256 i = 0; i < nextVestingId; i++) {\\n            amount += getVestingBalance(vestedTokenOwner_, i);\\n        }\\n\\n        require(\\n            amount > 0,\\n            \\\"LinearVestingHubSnapshot:: no vested tokens avail for delegation\\\"\\n        );\\n\\n        // Check if receiver already delegated, if so, remove old delegation\\n        address oldDelegate = delegateByReceiver[vestedTokenOwner_];\\n        if (oldDelegate != address(0)) {\\n            // Remove old delegate\\n            _receiversByDelegate[oldDelegate].remove(vestedTokenOwner_);\\n            delete delegateByReceiver[vestedTokenOwner_];\\n        }\\n\\n        // Add new delegation\\n        _receiversByDelegate[delegate_].add(vestedTokenOwner_);\\n        delegateByReceiver[vestedTokenOwner_] = delegate_;\\n    }\\n\\n    /// @notice Removes a vestedTokenOwners delegation\\n    /// @param vestedTokenOwner_ Account to that has vested tokens which wants to remove its delegation\\n    function removeDelegate(address vestedTokenOwner_)\\n        external\\n        onlyProxyAdminOrReceiver(vestedTokenOwner_)\\n    {\\n        address delegate = delegateByReceiver[vestedTokenOwner_];\\n        require(\\n            delegate != address(0),\\n            \\\"LinearVestingHubSnapshot:: No delegate set\\\"\\n        );\\n        require(\\n            _receiversByDelegate[delegate].contains(vestedTokenOwner_),\\n            \\\"LinearVestingHubSnapshot:: Can only have one receiver mapped to delegate\\\"\\n        );\\n\\n        // Remove delegation\\n        delete delegateByReceiver[vestedTokenOwner_];\\n        _receiversByDelegate[delegate].remove(vestedTokenOwner_);\\n    }\\n\\n    /// @notice Helper func used in TOKEN Snapshot voting to derive the total voting power of an address\\n    /// @param account_ Account to check total TOKEN voting power for\\n    function balanceOf(address account_)\\n        external\\n        view\\n        returns (uint256 balance)\\n    {\\n        // 1. Add tokens delegated in Vesting Hub\\n        balance = getVestingHubDelegations(account_);\\n\\n        // 2. Add tokens delegated in TOKEN token contract\\n        balance += IToken(address(LINEAR_VESTING_HUB.TOKEN())).getCurrentVotes(\\n            account_\\n        );\\n\\n        // 3. Add whale pool balance\\n        balance += TOKEN_SALE.gelLockedByWhale(account_);\\n    }\\n\\n    /// @notice Get total amount of TOKEN delegated to an account_ on Linear Vesting Hub\\n    /// @param account_ Account to check total delegated TOKEN voting power in LVH\\n    function getVestingHubDelegations(address account_)\\n        public\\n        view\\n        returns (uint256 balance)\\n    {\\n        address[] memory receivers = getReceiversByDelegate(account_);\\n\\n        if (receivers.length > 0) {\\n            for (uint256 i; i < receivers.length; i++) {\\n                address receiver = receivers[i];\\n                uint256 nextVestingId = LINEAR_VESTING_HUB\\n                    .nextVestingIdByReceiver(receiver);\\n\\n                for (uint256 j = 0; j < nextVestingId; j++) {\\n                    balance += getVestingBalance(receiver, j);\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @notice Helper func to get all receivers that delegated to a certain address\\n    /// @param delegate_ Delegate for locked receiver tokens\\n    function getReceiversByDelegate(address delegate_)\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n        uint256 length = _receiversByDelegate[delegate_].length();\\n        address[] memory receivers = new address[](length);\\n\\n        for (uint256 i; i < length; i++) {\\n            receivers[i] = _receiversByDelegate[delegate_].at(i);\\n        }\\n        return receivers;\\n    }\\n\\n    function getVestingBalance(address receiver_, uint256 vestingId_)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        try\\n            LINEAR_VESTING_HUB.vestingsByReceiver(receiver_, vestingId_)\\n        returns (Vesting memory vesting) {\\n            return vesting.receiver != address(0) ? vesting.tokenBalance : 0;\\n        } catch {\\n            return 0;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/functions/VestingFormulaFunctions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nfunction _getVestedTkns(\\n    uint256 tknBalance_,\\n    uint256 tknWithdrawn_,\\n    uint256 startDate_,\\n    uint256 duration_\\n) view returns (uint256) {\\n    if (block.timestamp < startDate_) return 0;\\n    if (block.timestamp >= startDate_ + duration_)\\n        return tknBalance_ + tknWithdrawn_;\\n    return\\n        ((tknBalance_ + tknWithdrawn_) * (block.timestamp - startDate_)) /\\n        duration_;\\n}\\n\\nfunction _getTknMaxWithdraw(\\n    uint256 tknBalance_,\\n    uint256 tknWithdrawn_,\\n    uint256 startDate_,\\n    uint256 cliffDuration_,\\n    uint256 duration_\\n) view returns (uint256) {\\n    // Vesting has not started and/or cliff has not passed\\n    if (block.timestamp < startDate_ + cliffDuration_) return 0;\\n\\n    uint256 vestedTkns = _getVestedTkns(\\n        tknBalance_,\\n        tknWithdrawn_,\\n        startDate_,\\n        duration_\\n    );\\n\\n    return vestedTkns > tknWithdrawn_ ? vestedTkns - tknWithdrawn_ : 0;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILinearVestingHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport {Vesting} from \\\"../structs/SVesting.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface ILinearVestingHub {\\n    // solhint-disable-next-line func-name-mixedcase\\n    function TOKEN() external view returns (IERC20);\\n\\n    function nextVestingIdByReceiver(address receiver_)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function vestingsByReceiver(address receiver_, uint256 id_)\\n        external\\n        view\\n        returns (Vesting memory);\\n\\n    function totalWithdrawn() external view returns (uint256);\\n\\n    function isReceiver(address receiver_) external view returns (bool);\\n\\n    function receiverAt(uint256 index_) external view returns (address);\\n\\n    function receivers() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/structs/SVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nstruct Vesting {\\n    uint8 id;\\n    address receiver;\\n    uint256 tokenBalance; // remaining token balance\\n    uint256 withdrawnTokens; //\\n    uint256 startTime; // vesting start time.\\n    uint256 cliffDuration; // lockup time.\\n    uint256 duration;\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/hardhat-deploy/Proxied.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract Proxied {\\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\\n    /// It also allows these functions to be called inside a contructor\\n    /// even if the contract is meant to be used without proxy\\n    modifier proxied() {\\n        address proxyAdminAddress = _proxyAdmin();\\n        // With hardhat-deploy proxies\\n        // the proxyAdminAddress is zero only for the implementation contract\\n        // if the implementation contract want to be used as a standalone/immutable contract\\n        // it simply has to execute the `proxied` function\\n        // This ensure the proxyAdminAddress is never zero post deployment\\n        // And allow you to keep the same code for both proxied contract and immutable contract\\n        if (proxyAdminAddress == address(0)) {\\n            // ensure can not be called twice when used outside of proxy : no admin\\n            // solhint-disable-next-line security/no-inline-assembly\\n            assembly {\\n                sstore(\\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n                )\\n            }\\n        } else {\\n            require(msg.sender == proxyAdminAddress);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyProxyAdmin() {\\n        require(msg.sender == _proxyAdmin(), \\\"NOT_AUTHORIZED\\\");\\n        _;\\n    }\\n\\n    function _proxyAdmin() internal view returns (address ownerAddress) {\\n        // solhint-disable-next-line security/no-inline-assembly\\n        assembly {\\n            ownerAddress := sload(\\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\\n            )\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ILinearVestingHub\",\"name\":\"linearVestingHub_\",\"type\":\"address\"},{\"internalType\":\"contract ITokenSale\",\"name\":\"tokenSale_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"LINEAR_VESTING_HUB\",\"outputs\":[{\"internalType\":\"contract ILinearVestingHub\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_SALE\",\"outputs\":[{\"internalType\":\"contract ITokenSale\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegateByReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegate_\",\"type\":\"address\"}],\"name\":\"getReceiversByDelegate\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vestingId_\",\"type\":\"uint256\"}],\"name\":\"getVestingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"getVestingHubDelegations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vestedTokenOwner_\",\"type\":\"address\"}],\"name\":\"removeDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vestedTokenOwner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegate_\",\"type\":\"address\"}],\"name\":\"setDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LinearVestingHubSnapshot","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"0000000000000000000000004a7c7652abd5e5e3467c458e42493630aaa7ddd60000000000000000000000005898d2ae0745c8d09762bac50fd9f34a2a95a563","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}