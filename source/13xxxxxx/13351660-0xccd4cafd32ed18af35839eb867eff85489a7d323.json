{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(),\"Not Owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0),\"Zero address not allowed\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ninterface ISwapFactory {\r\n    function swap(address tokenA, address tokenB, uint256 amount, address user, uint256 OrderType, uint256 dexId, uint256[] memory distribution, uint256 deadline) \r\n    external payable returns (bool);\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    \r\n    function mint(address to, uint256 amount) external returns(bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\ninterface I1inch {\r\n\r\n    function swap(IERC20 fromToken, IERC20 destToken, uint256 amount, uint256 minReturn, uint256[] calldata distribution, uint256 flags)\r\n    external payable returns(uint256);\r\n    \r\n    function getExpectedReturn(IERC20 fromToken, IERC20 toToken, uint256 amount, uint256 parts, uint256 featureFlags) \r\n    external view returns(uint256, uint256[] calldata);\r\n\r\n}\r\n\r\ninterface IUni {\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external payable\r\n    returns (uint[] memory amounts);\r\n    \r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) \r\n    external \r\n    returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n}\r\n\r\n\r\ninterface IGatewayVault {\r\n    function vaultTransfer(address token, address recipient, uint256 amount) external returns (bool);\r\n    function vaultApprove(address token, address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\nlibrary DisableFlags {\r\n    function enabled(uint256 disableFlags, uint256 flag) internal pure returns(bool) {\r\n        return (disableFlags & flag) == 0;\r\n    }\r\n\r\n    function disabledReserve(uint256 disableFlags, uint256 flag) internal pure returns(bool) {\r\n        // For flag disabled by default (Kyber reserves)\r\n        return enabled(disableFlags, flag);\r\n    }\r\n\r\n    function disabled(uint256 disableFlags, uint256 flag) internal pure returns(bool) {\r\n        return (disableFlags & flag) != 0;\r\n    }\r\n}\r\n\r\ninterface IReimbursement {\r\n    function getLicenseeFee(address licenseeVault, address projectContract) external view returns(uint256); // return fee percentage with 2 decimals\r\n    function getVaultOwner(address vault) external view returns(address);\r\n    // returns address of fee receiver or address(0) if licensee can't receive the fee (fee should be returns to user)\r\n    function requestReimbursement(address user, uint256 feeAmount, address licenseeVault) external returns(address);\r\n}\r\n\r\n\r\nabstract contract Router {\r\n    using DisableFlags for uint256;\r\n     \r\n    uint256 public constant FLAG_UNISWAP = 0x01;\r\n    uint256 public constant FLAG_SUSHI = 0x02;\r\n    uint256 public constant FLAG_1INCH = 0x04;\r\n\r\n    uint256 public constant totalDEX = 3;            // Total no of DEX aggregators or exchanges used\r\n    \r\n    mapping (address => uint256) _disabledDEX;\r\n    enum OrderType {EthForTokens, TokensForEth, TokensForTokens}\r\n\r\n    event Received(address, uint);\r\n    event Error(address);\r\n\r\n    receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n\r\n    fallback() external payable {\r\n        revert();\r\n    }\r\n    \r\n    event Caught(string stringFailure,uint index,uint256 amount);\r\n\r\n    I1inch OneSplit;\r\n    IUni Uni;\r\n    IUni Sushi;\r\n    IUni public uniV2Router;            // uniswap compatible router where we have to feed company token pair\r\n    \r\n    address constant ETH = address(0);\r\n\r\n    // add these variables into contract and initialize it in constructor.\r\n    // also, create setter functions for it with onlyOwner restriction.\r\n\r\n    constructor(address _Uni, address _sushi, address _oneSplit) payable {\r\n        // owner = payable(msg.sender);\r\n        OneSplit = I1inch(_oneSplit);\r\n        Uni = IUni(_Uni);\r\n        Sushi = IUni(_sushi);\r\n    }\r\n    \r\n    function setDisabledDEX(uint256 _disableFlag) external returns(bool) {\r\n        _disabledDEX[msg.sender] = _disableFlag;\r\n        return true;\r\n    }\r\n    \r\n    function getDisabledDEX(address account) public view returns(uint256) {\r\n        return _disabledDEX[account];\r\n    }\r\n    \r\n    function calculateUniswapReturn( uint256 amountIn, address[] memory path, OrderType orderType,uint256 /*disableFlags*/) public view returns(uint256, uint256[] memory) {\r\n        uint256[] memory uniAmounts =new uint[](path.length);\r\n        uint256[] memory distribution;\r\n\r\n        uniAmounts[path.length-1] = uint256(0);\r\n        \r\n        if(orderType == OrderType.EthForTokens){\r\n            path[0] = Uni.WETH();\r\n            try Uni.getAmountsOut(amountIn, path)returns(uint256[] memory _amounts) {\r\n                uniAmounts = _amounts;\r\n            }\r\n            catch{}\r\n        } \r\n        else if(orderType == OrderType.TokensForEth){\r\n            path[path.length-1] = Uni.WETH();\r\n            try Uni.getAmountsOut(amountIn, path)returns(uint256[] memory _amounts) {\r\n                uniAmounts = _amounts;\r\n            }catch{}\r\n        } \r\n        else{\r\n            try Uni.getAmountsOut(amountIn, path)returns(uint256[] memory _amounts) {\r\n                uniAmounts = _amounts;\r\n            }catch{}\r\n        }\r\n        \r\n        return (uniAmounts[path.length-1],distribution);\r\n\r\n    }\r\n    \r\n    function calculateSushiReturn( uint256 amountIn, address[] memory path, OrderType orderType,uint256 /*disableFlags*/) public view returns(uint256, uint256[] memory) {\r\n        uint256[] memory sushiAmounts =new uint[](path.length);\r\n        uint256[] memory distribution;\r\n\r\n        sushiAmounts[path.length-1] = uint256(0);\r\n        \r\n        if(orderType == OrderType.EthForTokens){\r\n            try Sushi.getAmountsOut(amountIn, path) returns(uint256[] memory _amounts) {\r\n                sushiAmounts = _amounts;\r\n            }catch{}\r\n        } \r\n        else if(orderType == OrderType.TokensForEth){\r\n            try Sushi.getAmountsOut(amountIn, path) returns(uint256[] memory _amounts) {\r\n                sushiAmounts = _amounts;\r\n            }catch{}\r\n        } \r\n        else{\r\n            try Sushi.getAmountsOut(amountIn, path) returns(uint256[] memory _amounts) {\r\n                sushiAmounts = _amounts;\r\n            }catch{}\r\n        }\r\n        \r\n        return (sushiAmounts[path.length-1],distribution);\r\n\r\n    }\r\n    \r\n    function calculate1InchReturn( uint256 amountIn, address[] memory path, OrderType orderType,uint256 /*disableFlags*/) public view returns(uint256,uint256[] memory) {\r\n        uint256 returnAmount;\r\n        uint256[] memory distribution;\r\n\r\n        if(orderType == OrderType.EthForTokens){\r\n            path[0] = ETH;\r\n            try OneSplit.getExpectedReturn(IERC20(path[0]), IERC20(path[path.length-1]), amountIn, 100, 0) returns(uint256 _amount, uint256[] memory _distribution){\r\n                returnAmount = _amount;\r\n                distribution = _distribution;\r\n            }catch{}\r\n        }\r\n        else if(orderType == OrderType.TokensForEth){\r\n            path[path.length-1] = ETH;\r\n            try OneSplit.getExpectedReturn(IERC20(path[0]), IERC20(path[path.length-1]), amountIn, 100, 0) returns(uint256 _amount, uint256[] memory _distribution){\r\n                returnAmount = _amount;\r\n                distribution = _distribution;\r\n            }catch{}\r\n        } \r\n        else{\r\n            try OneSplit.getExpectedReturn(IERC20(path[0]), IERC20(path[path.length-1]), amountIn, 100, 0) returns(uint256 _amount, uint256[] memory _distribution){\r\n                returnAmount = _amount;\r\n                distribution = _distribution;\r\n            }catch{}\r\n        }\r\n        \r\n        return (returnAmount,distribution);\r\n\r\n    }\r\n\r\n    function _calculateNoReturn( uint256/* amountIn*/, address[] memory /*path*/, OrderType /*orderType*/,uint256 /*disableFlags*/) internal pure returns(uint256, uint256[] memory) {\r\n        uint256[] memory distribution;\r\n        return (uint256(0), distribution);\r\n    }\r\n    \r\n    // returns : \r\n    // dexId ->  which dex gives highest amountOut 0-> 1inch 1-> uniswap 2-> sushiswap\r\n    // minAmountExpected ->  how much tokens you will get after swap\r\n    // distribution -> the route of swappping\r\n    function getBestQuote(address[] memory path, uint256 amountIn, OrderType orderType, uint256 disableFlags) public view returns (uint256, uint256,uint256[] memory) {\r\n        \r\n        function(uint256, address[] memory, OrderType ,uint256 ) view returns(uint256,uint256[]memory)[3] memory reserves = [\r\n            disableFlags.disabled(FLAG_1INCH)    ? _calculateNoReturn : _calculateNoReturn,\r\n            disableFlags.disabled(FLAG_UNISWAP)  ? _calculateNoReturn : calculateUniswapReturn,\r\n            disableFlags.disabled(FLAG_SUSHI)    ? _calculateNoReturn : calculateSushiReturn\r\n        ];\r\n        \r\n        uint256[3] memory rates;\r\n        uint256[][3] memory distribution;\r\n        \r\n        for (uint256 i = 0; i < rates.length; i++) {\r\n            (rates[i],distribution[i]) = reserves[i](amountIn,path,orderType,disableFlags);\r\n        }\r\n        \r\n        uint256 temp = 0;\r\n        for(uint256 i = 1; i < rates.length; i++) {\r\n            if(rates[i] > rates[temp]) {\r\n                temp = i;\r\n            }\r\n        }\r\n        return(temp, rates[temp], distribution[temp]);   \r\n    \r\n    }\r\n \r\n    function oneInchSwap(address _fromToken, address _toToken, uint256 amountIn, uint256 minReturn, uint256[] memory distribution, uint256 flags)\r\n    internal {\r\n        if (_fromToken == ETH) {\r\n            try OneSplit.swap{value: amountIn}(IERC20(ETH), IERC20(_toToken), amountIn, minReturn, distribution, flags)\r\n             returns (uint256 amountOut){\r\n                 TransferHelper.safeTransferFrom(_toToken, address(this), msg.sender, amountOut);\r\n            } catch {\r\n                emit Error(msg.sender);\r\n                revert(\"Error\");\r\n            }\r\n        } else {\r\n             try OneSplit.swap(IERC20(_fromToken), IERC20(_toToken), amountIn, minReturn, distribution, flags)\r\n              returns (uint256 amountOut){\r\n                  if(_toToken == ETH){\r\n                      payable(msg.sender).transfer(amountOut);\r\n                  } else {\r\n                      TransferHelper.safeTransferFrom(_toToken, address(this), msg.sender, amountOut);\r\n                  }\r\n             } catch {\r\n                emit Error(msg.sender);\r\n                revert(\"Error\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n \r\ncontract Degen is Router, Ownable {\r\n    using DisableFlags for uint256;\r\n    \r\n    address public _Uni = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); //mainnet network address for uniswap (valid for Ropsten as well)\r\n    address public _oneSplit = address(0xC586BeF4a0992C495Cf22e1aeEE4E446CECDee0E); //INCORRECT! mainnet network address for oneInch\r\n    address public _sushi = address(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); // Mainnet network address for sushiswap\r\n    //address public _sushi = address(0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506); // Ropsten network address for sushiswap\r\n    //address public USDT = address(0x47A530f3Fa882502344DC491549cA9c058dbC7Da); // Ropsten test net USDT test token\r\n    address public USDT = address(0xdAC17F958D2ee523a2206206994597C13D831ec7); // USDT Token Address\r\n    address public system;\r\n    address public gatewayVault;\r\n    uint256 public proccessingFee = 0 ;\r\n    \r\n    uint256 private deadlineLimit = 20*60;      // 20 minutes by default \r\n    \r\n    uint256 private collectedFees = 1; // amount of collected fee (starts from 1 to avoid additional gas usage)\r\n    address public feeReceiver; // address which receive the fee (by default is validator)\r\n\r\n\r\n    IReimbursement public reimbursementContract;      // reimbursement contract address\r\n\r\n    address public companyToken;        // company reimbursement token (BSWAP, DEGEN, SMART)\r\n    address public companyVault;    // the vault address of our company registered in reimbursement contract\r\n\r\n    ISwapFactory public swapFactory;\r\n   \r\n   modifier onlySystem() {\r\n        require(msg.sender == system || owner() == msg.sender,\"Caller is not the system\");\r\n        _;\r\n    }\r\n    \r\n    \r\n    constructor(address _companyToken, address _swapFactory, address _system, address _gatewayVault /*, address _companyVault, address _reimbursementContract*/) \r\n    Router( _Uni, _sushi, _oneSplit) {\r\n        companyToken = _companyToken;\r\n        // companyVault = _companyVault;\r\n        // reimbursementContract = IReimbursement(_reimbursementContract);\r\n        swapFactory = ISwapFactory(_swapFactory);\r\n        system = _system;\r\n        gatewayVault = _gatewayVault;\r\n    }\r\n    \r\n    \r\n    // function degenPrice() public view returns (uint256){\r\n    //     (uint112 reserve0, uint112 reserve1,) = poolContract.getReserves();\r\n    //     if(poolContract.token0() == Uni.WETH()){\r\n    //         return ((reserve1 * (10**18)) /(reserve0));\r\n    //     } else {\r\n    //         return ((reserve0 * (10**18)) /(reserve1));\r\n    //     }\r\n    // }\r\n\r\n    function setCompanyToken(address _companyToken) external onlyOwner {\r\n        companyToken = _companyToken;\r\n    }\r\n\r\n    function setCompanyVault(address _comapnyVault) external onlyOwner returns(bool){\r\n        companyVault = _comapnyVault;\r\n        return true;\r\n    }\r\n\r\n    function setReimbursementContract(address _reimbursementContarct) external onlyOwner returns(bool){\r\n        reimbursementContract = IReimbursement(_reimbursementContarct);\r\n        return true;\r\n    }\r\n\r\n    function setProccessingFee(uint256 _processingFees) external onlySystem {\r\n        proccessingFee = _processingFees;\r\n    }\r\n\r\n    function setSwapFactory(address _swapFactory) external onlyOwner {\r\n        swapFactory = ISwapFactory(_swapFactory);\r\n\r\n    }\r\n    \r\n    function setGatewayVault(address _gatewayVault) external onlyOwner returns(bool) {\r\n        gatewayVault = _gatewayVault;\r\n        return true;\r\n    }\r\n    \r\n    function setSystem (address _system) external onlyOwner returns(bool) {\r\n        system = _system;\r\n        return true;\r\n    }\r\n    \r\n    function setFeeReceiver(address _addr) external onlyOwner returns(bool) {\r\n        feeReceiver = _addr;\r\n        return true;\r\n    }\r\n    \r\n    function getDeadlineLimit() public view returns(uint256) {\r\n        return deadlineLimit;\r\n    }\r\n    \r\n    function setDeadlineLimit(uint256 limit) external onlyOwner returns(bool) {\r\n        deadlineLimit = limit;\r\n        return true;\r\n    }\r\n\r\n    // get amount of collected fees that can be claimed\r\n    function getColletedFees() external view returns (uint256) {\r\n        // collectedFees starts from 1 to avoid additional gas usage to initiate storage (when collectedFees = 0)\r\n        return collectedFees - 1;\r\n    }\r\n\r\n    // claim fees by feeReceiver\r\n    function claimFee() external returns (uint256 feeAmount) {\r\n        require(msg.sender == feeReceiver, \"This fee can be claimed only by fee receiver!!\");\r\n        feeAmount = collectedFees - 1;\r\n        collectedFees = 1;        \r\n        TransferHelper.safeTransferETH(msg.sender, feeAmount);\r\n    }\r\n    \r\n    \r\n    // Call function processFee() at the end of main function for correct gas usage calculation.\r\n    // txGas - is gasleft() on start of calling contract. Put `uint256 txGas = gasleft();` as a first command in function\r\n    // feeAmount - fee amount that user paid\r\n    // processing - processing fee (for cross-chain swaping)\r\n    // licenseeVault - address that licensee received on registration and should provide when users comes from their site\r\n    // user - address of user who has to get reimbursement (usually msg.sender)\r\n\r\n    function processFee(uint256 txGas, uint256 feeAmount, uint256 processing, address licenseeVault, address user) internal {\r\n        if (address(reimbursementContract) == address(0)) {\r\n            payable(user).transfer(feeAmount); // return fee to sender if no reimbursement contract\r\n            return;\r\n        }\r\n        \r\n        uint256 licenseeFeeAmount;\r\n        if (licenseeVault != address(0)) {\r\n            uint256 companyFeeRate = reimbursementContract.getLicenseeFee(companyVault, address(this));\r\n            uint256 licenseeFeeRate = reimbursementContract.getLicenseeFee(licenseeVault, address(this));\r\n            if (licenseeFeeRate != 0)\r\n                licenseeFeeAmount = (feeAmount * licenseeFeeRate)/(licenseeFeeRate + companyFeeRate);\r\n            if (licenseeFeeAmount != 0) {\r\n                address licenseeFeeTo = reimbursementContract.requestReimbursement(user, licenseeFeeAmount, licenseeVault);\r\n                if (licenseeFeeTo == address(0)) {\r\n                    payable(user).transfer(licenseeFeeAmount);    // refund to user\r\n                } else {\r\n                    payable(licenseeFeeTo).transfer(licenseeFeeAmount);  // transfer to fee receiver\r\n                }\r\n            }\r\n        }\r\n        feeAmount -= licenseeFeeAmount; // company's part of fee\r\n        collectedFees += feeAmount; \r\n        \r\n        if (processing != 0) \r\n            payable(system).transfer(processing);  // transfer to fee receiver\r\n        \r\n        txGas -= gasleft(); // get gas amount that was spent on Licensee fee\r\n        txGas = txGas * tx.gasprice;\r\n        // request reimbursement for user\r\n        reimbursementContract.requestReimbursement(user, feeAmount+txGas+processing, companyVault);\r\n    }\r\n    \r\n    \r\n    function _swap( \r\n        OrderType orderType, \r\n        address[] memory path, \r\n        uint256 assetInOffered,\r\n        uint256 minExpectedAmount, \r\n        address user,\r\n        address to,\r\n        uint256 dexId,\r\n        uint256[] memory distribution,\r\n        uint256 deadline\r\n    ) internal returns(uint256) {\r\n         \r\n        require(dexId < totalDEX, \"Invalid DEX Id!\");\r\n        require(deadline >= block.timestamp, \"EXPIRED: Deadline for transaction already passed.\");\r\n        \r\n        uint256 disableFlags = getDisabledDEX(user);\r\n         \r\n        // check conditions for disableFlags and return response accordingly. if disabled then minExpectedAmount will be uint(0)\r\n        if( disableFlags.disabled(FLAG_1INCH) || disableFlags.disabled(FLAG_UNISWAP) || disableFlags.disabled(FLAG_SUSHI) ) {\r\n            minExpectedAmount = uint256(0);\r\n        }\r\n        \r\n        if(dexId == 0){\r\n            if(orderType == OrderType.EthForTokens) {\r\n                 path[0] = ETH;\r\n            }\r\n            else if (orderType == OrderType.TokensForEth) {\r\n                path[path.length-1] = ETH;\r\n            }\r\n            oneInchSwap(path[0], path[path.length-1], assetInOffered, 0, distribution, 0);\r\n        }\r\n\r\n        \r\n        else if(dexId == 1){\r\n            uint[] memory swapResult;\r\n            if(orderType == OrderType.EthForTokens) {\r\n                 path[0] = Uni.WETH();\r\n                 swapResult = Uni.swapExactETHForTokens{value:assetInOffered}(0, path, to,block.timestamp);\r\n            }\r\n            else if (orderType == OrderType.TokensForEth) {\r\n                path[path.length-1] = Uni.WETH();\r\n                TransferHelper.safeApprove(path[0], address(_Uni), assetInOffered);\r\n                swapResult = Uni.swapExactTokensForETH(assetInOffered, 0, path,to, block.timestamp);\r\n            }\r\n            else if (orderType == OrderType.TokensForTokens) {\r\n                TransferHelper.safeApprove(path[0], address(_Uni), assetInOffered);\r\n                swapResult = Uni.swapExactTokensForTokens(assetInOffered, minExpectedAmount, path, to, block.timestamp);\r\n            }\r\n        } \r\n        \r\n        else if(dexId == 2){\r\n            uint[] memory swapResult;\r\n            if(orderType == OrderType.EthForTokens) {\r\n                 path[0] = Sushi.WETH();\r\n                 swapResult = Sushi.swapExactETHForTokens{value:assetInOffered}(minExpectedAmount, path, to, block.timestamp);\r\n            }\r\n            else if (orderType == OrderType.TokensForEth) {\r\n                path[path.length-1] = Sushi.WETH();\r\n                TransferHelper.safeApprove(path[0], address(_sushi), assetInOffered);\r\n                swapResult = Sushi.swapExactTokensForETH(assetInOffered, minExpectedAmount, path, to, block.timestamp);\r\n            }\r\n            else if (orderType == OrderType.TokensForTokens) {\r\n                TransferHelper.safeApprove(path[0], address(_sushi), assetInOffered);\r\n                swapResult = Sushi.swapExactTokensForTokens(assetInOffered, minExpectedAmount, path, to, block.timestamp);\r\n            }\r\n        }\r\n\r\n        return minExpectedAmount;\r\n    }\r\n    \r\n    \r\n    function executeSwap(\r\n        OrderType orderType, \r\n        address[] memory path, \r\n        uint256 assetInOffered, \r\n        uint256 fees, \r\n        uint256 minExpectedAmount,\r\n        address licenseeVault,\r\n        uint256 dexId,\r\n        uint256[] memory distribution,\r\n        uint256 deadline\r\n    ) external payable {\r\n        uint256 gasA = gasleft();\r\n        uint256 receivedFees = 0;\r\n        if(deadline == 0) {\r\n            deadline = block.timestamp + deadlineLimit;\r\n        }\r\n        \r\n        if(orderType == OrderType.EthForTokens){\r\n            require(msg.value >= (assetInOffered + fees), \"Payment = assetInOffered + fees\");\r\n            receivedFees = receivedFees + msg.value - assetInOffered;\r\n        } else {\r\n            require(msg.value >= fees, \"fees not received\");\r\n            receivedFees = receivedFees + msg.value;\r\n            TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), assetInOffered);\r\n        }\r\n        \r\n        _swap(orderType, path, assetInOffered, minExpectedAmount, msg.sender, msg.sender, dexId, distribution, deadline);\r\n   \r\n        processFee(gasA, receivedFees, 0, licenseeVault, msg.sender);\r\n    }\r\n    \r\n    \r\n    function executeCrossExchange(\r\n        address[] memory path, \r\n        OrderType orderType,\r\n        uint256 crossOrderType,\r\n        uint256 assetInOffered,\r\n        uint256 fees, \r\n        uint256 minExpectedAmount,\r\n        address licenseeVault,\r\n        uint256[3] memory dexId_deadline, // dexId_deadline[0] - native swap dexId, dexId_deadline[1] - foreign swap dexId, dexId_deadline[2] - deadline\r\n        uint256[] memory distribution\r\n    ) external payable {\r\n        uint256[2] memory feesPrice; \r\n        feesPrice[0] = gasleft();       // equivalent to gasA\r\n        feesPrice[1] = 0;               // processing fees\r\n        \r\n        if (dexId_deadline[2] == 0) {   // if deadline == 0, set deadline to deadlineLimit\r\n            dexId_deadline[2] = block.timestamp + deadlineLimit;\r\n        }\r\n\r\n        if(orderType == OrderType.EthForTokens){\r\n            require(msg.value >= (assetInOffered + fees + proccessingFee), \"Payment = assetInOffered + fees + proccessingFee\");\r\n            feesPrice[1] = msg.value - assetInOffered - fees;\r\n        } else {\r\n            require(msg.value >= (fees + proccessingFee), \"fees not received\");\r\n            feesPrice[1] = msg.value - fees;\r\n            TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), assetInOffered);\r\n        }\r\n        \r\n        if(path[0] == USDT) {\r\n            IERC20(USDT).approve(address(swapFactory), assetInOffered);\r\n            swapFactory.swap(USDT, path[path.length-1], assetInOffered, msg.sender, crossOrderType, dexId_deadline[1], distribution, dexId_deadline[2]);\r\n        }\r\n        else {\r\n            address tokenB = path[path.length-1];\r\n            path[path.length-1] = USDT;\r\n            uint256 minAmountExpected = _swap(orderType, path, assetInOffered, minExpectedAmount, msg.sender, address(this), dexId_deadline[0], distribution, dexId_deadline[2]);\r\n                \r\n            IERC20(USDT).approve(address(swapFactory),minAmountExpected);\r\n            swapFactory.swap(USDT, tokenB, minAmountExpected, msg.sender, crossOrderType, dexId_deadline[1], distribution, dexId_deadline[2]);\r\n        }        \r\n\r\n        processFee(feesPrice[0], fees, feesPrice[1], licenseeVault, msg.sender);\r\n    }\r\n\r\n    function callbackCrossExchange( \r\n        OrderType orderType, \r\n        address[] memory path, \r\n        uint256 assetInOffered, \r\n        address user,\r\n        uint256 dexId,\r\n        uint256[] memory distribution,\r\n        uint256 deadline\r\n    ) external returns(bool) {\r\n        require(msg.sender == address(swapFactory) , \"Degen : caller is not SwapFactory\");\r\n        if(deadline==0) {\r\n            deadline = block.timestamp + deadlineLimit;\r\n        }\r\n        _swap(orderType, path, assetInOffered, uint256(0), user, user, dexId, distribution, deadline);\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_companyToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_system\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gatewayVault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"stringFailure\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Caught\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Error\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"FLAG_1INCH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FLAG_SUSHI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FLAG_UNISWAP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Uni\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_oneSplit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sushi\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"enum Router.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"calculate1InchReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"enum Router.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"calculateSushiReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"enum Router.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"calculateUniswapReturn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum Router.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"assetInOffered\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dexId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"distribution\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"callbackCrossExchange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companyToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"companyVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"enum Router.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"crossOrderType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetInOffered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minExpectedAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"licenseeVault\",\"type\":\"address\"},{\"internalType\":\"uint256[3]\",\"name\":\"dexId_deadline\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[]\",\"name\":\"distribution\",\"type\":\"uint256[]\"}],\"name\":\"executeCrossExchange\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum Router.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"assetInOffered\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minExpectedAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"licenseeVault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dexId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"distribution\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"executeSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gatewayVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"enum Router.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"disableFlags\",\"type\":\"uint256\"}],\"name\":\"getBestQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getColletedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDeadlineLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getDisabledDEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proccessingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reimbursementContract\",\"outputs\":[{\"internalType\":\"contract IReimbursement\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_companyToken\",\"type\":\"address\"}],\"name\":\"setCompanyToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comapnyVault\",\"type\":\"address\"}],\"name\":\"setCompanyVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setDeadlineLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disableFlag\",\"type\":\"uint256\"}],\"name\":\"setDisabledDEX\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setFeeReceiver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gatewayVault\",\"type\":\"address\"}],\"name\":\"setGatewayVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_processingFees\",\"type\":\"uint256\"}],\"name\":\"setProccessingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reimbursementContarct\",\"type\":\"address\"}],\"name\":\"setReimbursementContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapFactory\",\"type\":\"address\"}],\"name\":\"setSwapFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_system\",\"type\":\"address\"}],\"name\":\"setSystem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapFactory\",\"outputs\":[{\"internalType\":\"contract ISwapFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"system\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniV2Router\",\"outputs\":[{\"internalType\":\"contract IUni\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Degen","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000052f4fa063bacf3fb4139ab4a45c28e8efcd1a4cd000000000000000000000000ddf7fe34171251c98664e756f990eacd9360718b000000000000000000000000121be4d1e89039da81f97f072ca89fe1d661f202","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e6df1ab913f7cdc2ad0aff24b7a68d30faf58c483baf6bee04010353359eb3bb"}]}