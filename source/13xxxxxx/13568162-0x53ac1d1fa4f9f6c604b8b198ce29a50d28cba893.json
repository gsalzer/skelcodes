{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/uniswapv2/UniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity =0.6.12;\\n\\nimport \\\"./interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"./UniswapV2Pair.sol\\\";\\n\\ncontract UniswapV2Factory is IUniswapV2Factory {\\n    address public override feeTo;\\n    address public override poolTo;\\n    address public override treasuryTo;\\n    address public override feeToSetter;\\n    address public override migrator;\\n\\n    mapping(address => mapping(address => address)) public override getPair;\\n    address[] public override allPairs;\\n\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint256\\n    );\\n\\n    constructor(address _feeToSetter) public {\\n        feeToSetter = _feeToSetter;\\n    }\\n\\n    function allPairsLength() external view override returns (uint256) {\\n        return allPairs.length;\\n    }\\n\\n    function pairCodeHash() external pure returns (bytes32) {\\n        return keccak256(type(UniswapV2Pair).creationCode);\\n    }\\n\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        override\\n        returns (address pair)\\n    {\\n        require(tokenA != tokenB, \\\"Liter: IDENTICAL_ADDRESSES\\\");\\n        (address token0, address token1) = tokenA < tokenB\\n            ? (tokenA, tokenB)\\n            : (tokenB, tokenA);\\n        require(token0 != address(0), \\\"Liter: ZERO_ADDRESS\\\");\\n        require(getPair[token0][token1] == address(0), \\\"Liter: PAIR_EXISTS\\\"); // single check is sufficient\\n        bytes memory bytecode = type(UniswapV2Pair).creationCode;\\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n        assembly {\\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n        UniswapV2Pair(pair).initialize(token0, token1);\\n        getPair[token0][token1] = pair;\\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\\n        allPairs.push(pair);\\n        emit PairCreated(token0, token1, pair, allPairs.length);\\n    }\\n\\n    function setFeeTo(address _feeTo) external override {\\n        require(msg.sender == feeToSetter, \\\"Liter: FORBIDDEN\\\");\\n        feeTo = _feeTo;\\n    }\\n\\n    function setPoolTo(address _poolTo) external override {\\n        require(msg.sender == feeToSetter, \\\"Liter: FORBIDDEN\\\");\\n        poolTo = _poolTo;\\n    }\\n\\n    function setTreasuryTo(address _treasuryTo) external override {\\n        require(msg.sender == feeToSetter, \\\"Liter: FORBIDDEN\\\");\\n        treasuryTo = _treasuryTo;\\n    }\\n\\n    function setFeeToSetter(address _feeToSetter) external override {\\n        require(msg.sender == feeToSetter, \\\"Liter: FORBIDDEN\\\");\\n        feeToSetter = _feeToSetter;\\n    }\\n\\n    function setMigrator(address _migrator) external override {\\n        require(msg.sender == feeToSetter, \\\"Liter: FORBIDDEN\\\");\\n        migrator = _migrator;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function poolTo() external view returns (address);\\n    function treasuryTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function migrator() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setPoolTo(address) external;\\n    function setTreasuryTo(address) external;\\n    function setFeeToSetter(address) external;\\n    function setMigrator(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/UniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity =0.6.12;\\n\\nimport \\\"./UniswapV2ERC20.sol\\\";\\nimport \\\"./libraries/Math.sol\\\";\\nimport \\\"./libraries/UQ112x112.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Callee.sol\\\";\\n\\ninterface IMigrator {\\n    // Return the desired amount of liquidity token that the migrator wants.\\n    function desiredLiquidity() external view returns (uint256);\\n}\\n\\ncontract UniswapV2Pair is UniswapV2ERC20 {\\n    using SafeMathUniswap for uint256;\\n    using UQ112x112 for uint224;\\n\\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\\n    bytes4 private constant SELECTOR =\\n        bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n\\n    address public factory;\\n    address public token0;\\n    address public token1;\\n    bool public treasury;\\n    bool public pool;\\n\\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\\n\\n    uint256 public price0CumulativeLast;\\n    uint256 public price1CumulativeLast;\\n    uint256 public lastUpdate; // Block number where last price update occurred, used for flashswap guard\\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\\n\\n    uint256 private unlocked = 1;\\n    modifier lock() {\\n        require(unlocked == 1, \\\"LTR: LOCKED\\\");\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    function getReserves()\\n        public\\n        view\\n        returns (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n            uint32 _blockTimestampLast\\n        )\\n    {\\n        _reserve0 = reserve0;\\n        _reserve1 = reserve1;\\n        _blockTimestampLast = blockTimestampLast;\\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) private {\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(SELECTOR, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"LTR: TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        address indexed to\\n    );\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n    event SwitchFees(bool treasuryOn, bool poolOn);\\n\\n    constructor() public {\\n        factory = msg.sender;\\n        treasury = false;\\n        pool = false;\\n    }\\n\\n    // switch fees on/off\\n    function switchFees(bool _treasuryOn, bool _poolOn) external {\\n        require(\\n            IUniswapV2Factory(factory).feeToSetter() == msg.sender,\\n            \\\"LTR: FORBIDDEN\\\"\\n        );\\n        treasury = _treasuryOn;\\n        pool = _poolOn;\\n        emit SwitchFees(treasury, pool);\\n    }\\n\\n    // called once by the factory at time of deployment\\n    function initialize(address _token0, address _token1) external {\\n        require(msg.sender == factory, \\\"LTR: FORBIDDEN\\\"); // sufficient check\\n        token0 = _token0;\\n        token1 = _token1;\\n    }\\n\\n    // update reserves and, on the first call per block, price accumulators\\n    function _update(\\n        uint256 balance0,\\n        uint256 balance1,\\n        uint112 _reserve0,\\n        uint112 _reserve1\\n    ) private {\\n        require(\\n            balance0 <= uint112(-1) && balance1 <= uint112(-1),\\n            \\\"LTR: OVERFLOW\\\"\\n        );\\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\\n            // * never overflows, and + overflow is desired\\n            price0CumulativeLast +=\\n                uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\\n                timeElapsed;\\n            price1CumulativeLast +=\\n                uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\\n                timeElapsed;\\n        }\\n        reserve0 = uint112(balance0);\\n        reserve1 = uint112(balance1);\\n        blockTimestampLast = blockTimestamp;\\n        emit Sync(reserve0, reserve1);\\n    }\\n\\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\\n    function _mintFee(uint112 _reserve0, uint112 _reserve1)\\n        private\\n        returns (bool feeOn)\\n    {\\n        address feeTo = IUniswapV2Factory(factory).feeTo();\\n        address poolTo = IUniswapV2Factory(factory).poolTo();\\n        address treasuryTo = IUniswapV2Factory(factory).treasuryTo();\\n        feeOn = feeTo != address(0);\\n        bool poolOn = poolTo != address(0) && pool;\\n        bool treasuryOn = treasuryTo != address(0) && treasury;\\n        uint256 _kLast = kLast; // gas savings\\n        if (feeOn) {\\n            if (_kLast != 0) {\\n                uint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1));\\n                uint256 rootKLast = Math.sqrt(_kLast);\\n                if (rootK > rootKLast) {\\n                    uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));\\n                    uint256 denominator = rootK.mul(5).add(rootKLast);\\n                    uint256 liquidity = numerator / denominator;\\n                    if (liquidity > 0) {\\n                        if (poolOn) {\\n                            if (treasuryOn) {\\n                                uint256 third = liquidity / 3;\\n                                _mint(poolTo, third);\\n                                _mint(feeTo, third);\\n                                _mint(treasuryTo, third);\\n                            } else {\\n                                uint256 half = liquidity / 2;\\n                                _mint(poolTo, half);\\n                                _mint(feeTo, half);\\n                            }\\n                        } else {\\n                            _mint(feeTo, liquidity);\\n                        }\\n                    }\\n                }\\n            }\\n        } else if (_kLast != 0) {\\n            kLast = 0;\\n        }\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function mint(address to) external lock returns (uint256 liquidity) {\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n        uint256 balance0 = IERC20Uniswap(token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20Uniswap(token1).balanceOf(address(this));\\n        uint256 amount0 = balance0.sub(_reserve0);\\n        uint256 amount1 = balance1.sub(_reserve1);\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        if (_totalSupply == 0) {\\n            address migrator = IUniswapV2Factory(factory).migrator();\\n            if (msg.sender == migrator) {\\n                liquidity = IMigrator(migrator).desiredLiquidity();\\n                require(\\n                    liquidity > 0 && liquidity != uint256(-1),\\n                    \\\"Bad desired liquidity\\\"\\n                );\\n            } else {\\n                require(migrator == address(0), \\\"Must not have migrator\\\");\\n                liquidity = Math.sqrt(amount0.mul(amount1)).sub(\\n                    MINIMUM_LIQUIDITY\\n                );\\n                _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n            }\\n        } else {\\n            liquidity = Math.min(\\n                amount0.mul(_totalSupply) / _reserve0,\\n                amount1.mul(_totalSupply) / _reserve1\\n            );\\n        }\\n        require(liquidity > 0, \\\"LTR: INSUFFICIENT_LIQUIDITY_MINTED\\\");\\n        _mint(to, liquidity);\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n        emit Mint(msg.sender, amount0, amount1);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function burn(address to)\\n        external\\n        lock\\n        returns (uint256 amount0, uint256 amount1)\\n    {\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        uint256 balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\\n        uint256 liquidity = balanceOf[address(this)];\\n\\n        bool feeOn = _mintFee(_reserve0, _reserve1);\\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n        require(\\n            amount0 > 0 && amount1 > 0,\\n            \\\"LTR: INSUFFICIENT_LIQUIDITY_BURNED\\\"\\n        );\\n        _burn(address(this), liquidity);\\n        _safeTransfer(_token0, to, amount0);\\n        _safeTransfer(_token1, to, amount1);\\n        balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\\n        balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n        emit Burn(msg.sender, amount0, amount1, to);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external lock {\\n        require(\\n            amount0Out > 0 || amount1Out > 0,\\n            \\\"LTR: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n        require(\\n            amount0Out < _reserve0 && amount1Out < _reserve1,\\n            \\\"LTR: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n\\n        uint256 balance0;\\n        uint256 balance1;\\n        {\\n            // scope for _token{0,1}, avoids stack too deep errors\\n            address _token0 = token0;\\n            address _token1 = token1;\\n            require(to != _token0 && to != _token1, \\\"LTR: INVALID_TO\\\");\\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\\n            if (data.length > 0)\\n                IUniswapV2Callee(to).uniswapV2Call(\\n                    msg.sender,\\n                    amount0Out,\\n                    amount1Out,\\n                    data\\n                );\\n            balance0 = IERC20Uniswap(_token0).balanceOf(address(this));\\n            balance1 = IERC20Uniswap(_token1).balanceOf(address(this));\\n        }\\n        uint256 amount0In = balance0 > _reserve0 - amount0Out\\n            ? balance0 - (_reserve0 - amount0Out)\\n            : 0;\\n        uint256 amount1In = balance1 > _reserve1 - amount1Out\\n            ? balance1 - (_reserve1 - amount1Out)\\n            : 0;\\n        require(\\n            amount0In > 0 || amount1In > 0,\\n            \\\"LTR: INSUFFICIENT_INPUT_AMOUNT\\\"\\n        );\\n        {\\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\\n            uint256 balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\\n            uint256 balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\\n            require(\\n                balance0Adjusted.mul(balance1Adjusted) >=\\n                    uint256(_reserve0).mul(_reserve1).mul(1000**2),\\n                \\\"LTR: K\\\"\\n            );\\n        }\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        lastUpdate = block.number;\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    // force balances to match reserves\\n    function skim(address to) external lock {\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        _safeTransfer(\\n            _token0,\\n            to,\\n            IERC20Uniswap(_token0).balanceOf(address(this)).sub(reserve0)\\n        );\\n        _safeTransfer(\\n            _token1,\\n            to,\\n            IERC20Uniswap(_token1).balanceOf(address(this)).sub(reserve1)\\n        );\\n    }\\n\\n    // force reserves to match balances\\n    function sync() external lock {\\n        _update(\\n            IERC20Uniswap(token0).balanceOf(address(this)),\\n            IERC20Uniswap(token1).balanceOf(address(this)),\\n            reserve0,\\n            reserve1\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/UniswapV2ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity =0.6.12;\\n\\nimport \\\"./libraries/SafeMath.sol\\\";\\n\\ncontract UniswapV2ERC20 {\\n    using SafeMathUniswap for uint256;\\n\\n    string public constant name = \\\"Standard LTR Token\\\";\\n    string public constant symbol = \\\"LTR\\\";\\n    uint8 public constant decimals = 18;\\n    uint256 public totalSupply;\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint256) public nonces;\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    constructor() public {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) private {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool) {\\n        if (allowance[from][msg.sender] != uint256(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\\n                value\\n            );\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(deadline >= block.timestamp, \\\"UniswapV2: EXPIRED\\\");\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        owner,\\n                        spender,\\n                        value,\\n                        nonces[owner]++,\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(\\n            recoveredAddress != address(0) && recoveredAddress == owner,\\n            \\\"UniswapV2: INVALID_SIGNATURE\\\"\\n        );\\n        _approve(owner, spender, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity =0.6.12;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/libraries/UQ112x112.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity =0.6.12;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity >=0.5.0;\\n\\ninterface IERC20Uniswap {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/interfaces/IUniswapV2Callee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Callee {\\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/uniswapv2/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity =0.6.12;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMathUniswap {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 99999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeToSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairCodeHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"name\":\"setFeeToSetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_migrator\",\"type\":\"address\"}],\"name\":\"setMigrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolTo\",\"type\":\"address\"}],\"name\":\"setPoolTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasuryTo\",\"type\":\"address\"}],\"name\":\"setTreasuryTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UniswapV2Factory","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"99999","ConstructorArguments":"000000000000000000000000a3f5ef413781c7fea58d2a9f0869b79fe3159a61","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}