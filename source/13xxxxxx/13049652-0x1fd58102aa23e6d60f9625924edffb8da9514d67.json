{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NftMetadataHelper.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ncontract NftMetadataHelper {\\r\\n\\r\\n  enum UriExecutedMethod { tokenMetadataURI, tokenURI, uri, baseTokenURI }\\r\\n\\r\\n  struct UriResponse {\\r\\n    UriExecutedMethod method;\\r\\n    string metaUri;\\r\\n    string assetUri;\\r\\n    string contractName;\\r\\n    string contractSymbol;\\r\\n  }\\r\\n\\r\\n  constructor() {}\\r\\n\\r\\n  function _staticcall(address nftContract, uint256 tokenId, string memory sig) view internal returns (bool success, bytes memory result) {\\r\\n    return nftContract.staticcall(abi.encodeWithSignature(sig, tokenId));\\r\\n  }\\r\\n\\r\\n  function _tokenMetadataURI(address nftContract, uint256 tokenId) view internal returns (bool success, bytes memory result) { \\r\\n    return _staticcall(nftContract, tokenId, \\\"tokenMetadataURI(uint256)\\\");\\r\\n  }\\r\\n\\r\\n  function _tokenURI(address nftContract, uint256 tokenId) view internal returns (bool success, bytes memory result) { \\r\\n    (bool status, bytes memory results) = _staticcall(nftContract, tokenId, \\\"tokenURI(uint256)\\\");\\r\\n    return (status, results);\\r\\n  }\\r\\n\\r\\n  function _uri(address nftContract, uint256 tokenId) view internal returns (bool success, bytes memory result) { \\r\\n    return _staticcall(nftContract, tokenId, \\\"uri(uint256)\\\");\\r\\n  }\\r\\n\\r\\n  function _baseTokenURI(address nftContract) view internal returns (bool success, bytes memory result) { \\r\\n    return nftContract.staticcall(abi.encodeWithSignature(\\\"baseTokenURI()\\\"));\\r\\n  }\\r\\n\\r\\n   function _contractName(address nftContract) view internal returns (bool success, bytes memory result) { \\r\\n    return nftContract.staticcall(abi.encodeWithSignature(\\\"name()\\\"));\\r\\n  }\\r\\n\\r\\n  function _contractSymbol(address nftContract) view internal returns (bool success, bytes memory result) { \\r\\n    return nftContract.staticcall(abi.encodeWithSignature(\\\"symbol()\\\"));\\r\\n  }\\r\\n\\r\\n  function _buildUriResponse(address nftContract, UriExecutedMethod method, bytes memory metaUri, bytes memory assetUri) internal view returns (UriResponse memory response) { \\r\\n    string memory contractName = \\\"\\\";\\r\\n    (bool contractNameSuccess, bytes memory contractNameResult) = _contractName(nftContract);\\r\\n    if (contractNameSuccess) {\\r\\n      contractName = abi.decode(contractNameResult, (string));\\r\\n    }\\r\\n\\r\\n    string memory contractSymbol = \\\"\\\";\\r\\n    (bool symbolSuccess, bytes memory symbolResult) = _contractSymbol(nftContract);\\r\\n    if (symbolSuccess) {\\r\\n      contractSymbol = abi.decode(symbolResult, (string));\\r\\n    }\\r\\n\\r\\n    string memory assetUriString = \\\"\\\";\\r\\n    if (assetUri.length > 0) {\\r\\n      assetUriString = abi.decode(assetUri, (string));\\r\\n    }\\r\\n\\r\\n    return UriResponse({\\r\\n      method: method,\\r\\n      metaUri: abi.decode(metaUri, (string)),\\r\\n      assetUri: assetUriString,\\r\\n      contractName: contractName,\\r\\n      contractSymbol: contractSymbol\\r\\n    });\\r\\n  }\\r\\n\\r\\n   function _getBalance(address nftContract, address owner, uint256 tokenId) view internal returns (bool success, bytes memory result) { \\r\\n    return nftContract.staticcall(abi.encodeWithSignature(\\\"balanceOf(address,uint256)\\\",owner,tokenId));\\r\\n  }\\r\\n\\r\\n  function getUri(address nftContract, uint256 tokenId) view public returns (UriResponse memory uri) {\\r\\n    (bool tokenMetadataSuccess, bytes memory tokenMetadataResult) = _tokenMetadataURI(nftContract, tokenId);\\r\\n    if (tokenMetadataSuccess) { \\r\\n      (bool internalTokenUriSuccess, bytes memory internalTokenUriResult) = _tokenURI(nftContract, tokenId);\\r\\n      if (internalTokenUriSuccess) {\\r\\n        return _buildUriResponse(nftContract, UriExecutedMethod.tokenMetadataURI, tokenMetadataResult, internalTokenUriResult);\\r\\n      } else {\\r\\n        return _buildUriResponse(nftContract, UriExecutedMethod.tokenMetadataURI, tokenMetadataResult, bytes(\\\"\\\"));\\r\\n      }\\r\\n    }\\r\\n\\r\\n    (bool tokenUriSuccess, bytes memory tokenUriResult) = _tokenURI(nftContract, tokenId);\\r\\n    if (tokenUriSuccess) { \\r\\n      return _buildUriResponse(nftContract, UriExecutedMethod.tokenURI, tokenUriResult, bytes(\\\"\\\"));\\r\\n    } else {\\r\\n      if(tokenUriResult.length > 0) {\\r\\n        bytes memory errorMessage = tokenUriResult;\\r\\n        assembly {\\r\\n            // Slice the sighash.\\r\\n            errorMessage := add(errorMessage, 0x04)\\r\\n        }\\r\\n\\r\\n        string memory errorMessageString = abi.decode(errorMessage, (string));\\r\\n        string memory expectedErrorMessage = \\\"ERC721Metadata: URI query for nonexistent token\\\";\\r\\n        require(!(keccak256(abi.encodePacked(errorMessageString)) == keccak256(abi.encodePacked(expectedErrorMessage))), \\\"Could not find URI for token due to it being burnt\\\");\\r\\n      }\\r\\n    }\\r\\n\\r\\n    (bool uriSuccess, bytes memory uriResult) = _uri(nftContract, tokenId);\\r\\n    if (uriSuccess) { \\r\\n      return _buildUriResponse(nftContract, UriExecutedMethod.uri, uriResult, bytes(\\\"\\\"));\\r\\n    }\\r\\n\\r\\n    (bool baseTokenUriSuccess, bytes memory baseTokenUriResult) = _baseTokenURI(nftContract);\\r\\n    if (baseTokenUriSuccess) { \\r\\n      return _buildUriResponse(nftContract, UriExecutedMethod.baseTokenURI, baseTokenUriResult, bytes(\\\"\\\"));\\r\\n    }\\r\\n\\r\\n    require(false, \\\"Could not find URI for token\\\");\\r\\n  }\\r\\n\\r\\n  function getBalances(address nftContract, uint256 tokenId, address[] memory owners) view public returns (uint256[] memory ownerBalances) {\\r\\n    uint256[] memory balances = new uint256[](owners.length);\\r\\n    for (uint256 i = 0; i < owners.length; i++) { \\r\\n      (bool success, bytes memory result) = _getBalance(nftContract, owners[i], tokenId);\\r\\n      if (success) { \\r\\n        balances[i] = abi.decode(result, (uint256));\\r\\n      } else {\\r\\n        balances[i] = 0;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return balances;\\r\\n  }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"}],\"name\":\"getBalances\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ownerBalances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getUri\",\"outputs\":[{\"components\":[{\"internalType\":\"enum NftMetadataHelper.UriExecutedMethod\",\"name\":\"method\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"metaUri\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"assetUri\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"contractSymbol\",\"type\":\"string\"}],\"internalType\":\"struct NftMetadataHelper.UriResponse\",\"name\":\"uri\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"NftMetadataHelper","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}