{"status":"1","message":"OK","result":[{"SourceCode":"// File: solidity-rlp/contracts/RLPReader.sol\r\n\r\n/*\r\n* @author Hamdi Allam hamdi.allam97@gmail.com\r\n* Please reach out with any questions or concerns\r\n*/\r\npragma solidity ^0.5.0;\r\n\r\nlibrary RLPReader {\r\n    uint8 constant STRING_SHORT_START = 0x80;\r\n    uint8 constant STRING_LONG_START  = 0xb8;\r\n    uint8 constant LIST_SHORT_START   = 0xc0;\r\n    uint8 constant LIST_LONG_START    = 0xf8;\r\n    uint8 constant WORD_SIZE = 32;\r\n\r\n    struct RLPItem {\r\n        uint len;\r\n        uint memPtr;\r\n    }\r\n\r\n    struct Iterator {\r\n        RLPItem item;   // Item that's being iterated over.\r\n        uint nextPtr;   // Position of the next item in the list.\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the next element in the iteration. Reverts if it has not next element.\r\n    * @param self The iterator.\r\n    * @return The next element in the iteration.\r\n    */\r\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\r\n        require(hasNext(self));\r\n\r\n        uint ptr = self.nextPtr;\r\n        uint itemLength = _itemLength(ptr);\r\n        self.nextPtr = ptr + itemLength;\r\n\r\n        return RLPItem(itemLength, ptr);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the iteration has more elements.\r\n    * @param self The iterator.\r\n    * @return true if the iteration has more elements.\r\n    */\r\n    function hasNext(Iterator memory self) internal pure returns (bool) {\r\n        RLPItem memory item = self.item;\r\n        return self.nextPtr < item.memPtr + item.len;\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\r\n        uint memPtr;\r\n        assembly {\r\n            memPtr := add(item, 0x20)\r\n        }\r\n\r\n        return RLPItem(item.length, memPtr);\r\n    }\r\n\r\n    /*\r\n    * @dev Create an iterator. Reverts if item is not a list.\r\n    * @param self The RLP item.\r\n    * @return An 'Iterator' over the item.\r\n    */\r\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\r\n        require(isList(self));\r\n\r\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\r\n        return Iterator(self, ptr);\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\r\n        return item.len;\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\r\n        return item.len - _payloadOffset(item.memPtr);\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded list in bytes\r\n    */\r\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\r\n        require(isList(item));\r\n\r\n        uint items = numItems(item);\r\n        RLPItem[] memory result = new RLPItem[](items);\r\n\r\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint dataLen;\r\n        for (uint i = 0; i < items; i++) {\r\n            dataLen = _itemLength(memPtr);\r\n            result[i] = RLPItem(dataLen, memPtr); \r\n            memPtr = memPtr + dataLen;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\r\n    function isList(RLPItem memory item) internal pure returns (bool) {\r\n        if (item.len == 0) return false;\r\n\r\n        uint8 byte0;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < LIST_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    /** RLPItem conversions into data types **/\r\n\r\n    // @returns raw rlp encoding in bytes\r\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        bytes memory result = new bytes(item.len);\r\n        if (result.length == 0) return result;\r\n        \r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr, ptr, item.len);\r\n        return result;\r\n    }\r\n\r\n    // any non-zero byte is considered true\r\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\r\n        require(item.len == 1);\r\n        uint result;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            result := byte(0, mload(memPtr))\r\n        }\r\n\r\n        return result == 0 ? false : true;\r\n    }\r\n\r\n    function toAddress(RLPItem memory item) internal pure returns (address) {\r\n        // 1 byte for the length prefix\r\n        require(item.len == 21);\r\n\r\n        return address(toUint(item));\r\n    }\r\n\r\n    function toUint(RLPItem memory item) internal pure returns (uint) {\r\n        require(item.len > 0 && item.len <= 33);\r\n\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset;\r\n\r\n        uint result;\r\n        uint memPtr = item.memPtr + offset;\r\n        assembly {\r\n            result := mload(memPtr)\r\n\r\n            // shfit to the correct location if neccesary\r\n            if lt(len, 32) {\r\n                result := div(result, exp(256, sub(32, len)))\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // enforces 32 byte length\r\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\r\n        // one byte prefix\r\n        require(item.len == 33);\r\n\r\n        uint result;\r\n        uint memPtr = item.memPtr + 1;\r\n        assembly {\r\n            result := mload(memPtr)\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\r\n        require(item.len > 0);\r\n\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset; // data length\r\n        bytes memory result = new bytes(len);\r\n\r\n        uint destPtr;\r\n        assembly {\r\n            destPtr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr + offset, destPtr, len);\r\n        return result;\r\n    }\r\n\r\n    /*\r\n    * Private Helpers\r\n    */\r\n\r\n    // @return number of payload items inside an encoded list.\r\n    function numItems(RLPItem memory item) private pure returns (uint) {\r\n        if (item.len == 0) return 0;\r\n\r\n        uint count = 0;\r\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint endPtr = item.memPtr + item.len;\r\n        while (currPtr < endPtr) {\r\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\r\n           count++;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    // @return entire rlp item byte length\r\n    function _itemLength(uint memPtr) private pure returns (uint) {\r\n        uint itemLen;\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START)\r\n            itemLen = 1;\r\n        \r\n        else if (byte0 < STRING_LONG_START)\r\n            itemLen = byte0 - STRING_SHORT_START + 1;\r\n\r\n        else if (byte0 < LIST_SHORT_START) {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\r\n                memPtr := add(memPtr, 1) // skip over the first byte\r\n                \r\n                /* 32 byte word size */\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        else if (byte0 < LIST_LONG_START) {\r\n            itemLen = byte0 - LIST_SHORT_START + 1;\r\n        } \r\n\r\n        else {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xf7)\r\n                memPtr := add(memPtr, 1)\r\n\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\r\n                itemLen := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        return itemLen;\r\n    }\r\n\r\n    // @return number of bytes until the data\r\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START) \r\n            return 0;\r\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\r\n            return 1;\r\n        else if (byte0 < LIST_SHORT_START)  // being explicit\r\n            return byte0 - (STRING_LONG_START - 1) + 1;\r\n        else\r\n            return byte0 - (LIST_LONG_START - 1) + 1;\r\n    }\r\n\r\n    /*\r\n    * @param src Pointer to source\r\n    * @param dest Pointer to destination\r\n    * @param len Amount of memory to copy from the source\r\n    */\r\n    function copy(uint src, uint dest, uint len) private pure {\r\n        if (len == 0) return;\r\n\r\n        // copy as many word sizes as possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += WORD_SIZE;\r\n            dest += WORD_SIZE;\r\n        }\r\n\r\n        // left over bytes. Mask is used to remove unwanted bytes from the word\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/BytesLib.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary BytesLib {\r\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory tempBytes;\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(\r\n                0x40,\r\n                and(\r\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n                    not(31) // Round down to the nearest 32 bytes.\r\n                )\r\n            )\r\n        }\r\n        return tempBytes;\r\n    }\r\n\r\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n        bytes memory tempBytes;\r\n        assembly {\r\n            switch iszero(_length)\r\n                case 0 {\r\n                    // Get a location of some free memory and store it in tempBytes as\r\n                    // Solidity does for memory variables.\r\n                    tempBytes := mload(0x40)\r\n\r\n                    // The first word of the slice result is potentially a partial\r\n                    // word read from the original array. To read it, we calculate\r\n                    // the length of that partial word and start copying that many\r\n                    // bytes into the array. The first word we copy will start with\r\n                    // data we don't care about, but the last `lengthmod` bytes will\r\n                    // land at the beginning of the contents of the new array. When\r\n                    // we're done copying, we overwrite the full first word with\r\n                    // the actual length of the slice.\r\n                    let lengthmod := and(_length, 31)\r\n\r\n                    // The multiplication in the next line is necessary\r\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                    // the following copy loop was copying the origin's length\r\n                    // and then ending prematurely not copying everything it should.\r\n                    let mc := add(\r\n                        add(tempBytes, lengthmod),\r\n                        mul(0x20, iszero(lengthmod))\r\n                    )\r\n                    let end := add(mc, _length)\r\n\r\n                    for {\r\n                        // The multiplication in the next line has the same exact purpose\r\n                        // as the one above.\r\n                        let cc := add(\r\n                            add(\r\n                                add(_bytes, lengthmod),\r\n                                mul(0x20, iszero(lengthmod))\r\n                            ),\r\n                            _start\r\n                        )\r\n                    } lt(mc, end) {\r\n                        mc := add(mc, 0x20)\r\n                        cc := add(cc, 0x20)\r\n                    } {\r\n                        mstore(mc, mload(cc))\r\n                    }\r\n\r\n                    mstore(tempBytes, _length)\r\n\r\n                    //update free-memory pointer\r\n                    //allocating the array padded to 32 bytes like the compiler does now\r\n                    mstore(0x40, and(add(mc, 31), not(31)))\r\n                }\r\n                //if we want a zero-length slice let's just return a zero-length array\r\n                default {\r\n                    tempBytes := mload(0x40)\r\n                    mstore(0x40, add(tempBytes, 0x20))\r\n                }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    // Pad a bytes array to 32 bytes\r\n    function leftPad(bytes memory _bytes) internal pure returns (bytes memory) {\r\n        // may underflow if bytes.length < 32. Hence using SafeMath.sub\r\n        bytes memory newBytes = new bytes(SafeMath.sub(32, _bytes.length));\r\n        return concat(newBytes, _bytes);\r\n    }\r\n\r\n    function toBytes32(bytes memory b) internal pure returns (bytes32) {\r\n        require(b.length >= 32, \"Bytes array should atleast be 32 bytes\");\r\n        bytes32 out;\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            out |= bytes32(b[i] & 0xFF) >> (i * 8);\r\n        }\r\n        return out;\r\n    }\r\n\r\n    function toBytes4(bytes memory b) internal pure returns (bytes4 result) {\r\n        assembly {\r\n            result := mload(add(b, 32))\r\n        }\r\n    }\r\n\r\n    function fromBytes32(bytes32 x) internal pure returns (bytes memory) {\r\n        bytes memory b = new bytes(32);\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            b[i] = bytes1(uint8(uint256(x) / (2**(8 * (31 - i)))));\r\n        }\r\n        return b;\r\n    }\r\n\r\n    function fromUint(uint256 _num) internal pure returns (bytes memory _ret) {\r\n        _ret = new bytes(32);\r\n        assembly {\r\n            mstore(add(_ret, 32), _num)\r\n        }\r\n    }\r\n\r\n    function toUint(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n        return tempUint;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint256 _start)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n        assembly {\r\n            tempAddress := div(\r\n                mload(add(add(_bytes, 0x20), _start)),\r\n                0x1000000000000000000000000\r\n            )\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/Common.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary Common {\r\n    function getV(bytes memory v, uint16 chainId) public pure returns (uint8) {\r\n        if (chainId > 0) {\r\n            return\r\n                uint8(\r\n                    BytesLib.toUint(BytesLib.leftPad(v), 0) - (chainId * 2) - 8\r\n                );\r\n        } else {\r\n            return uint8(BytesLib.toUint(BytesLib.leftPad(v), 0));\r\n        }\r\n    }\r\n\r\n    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n    function isContract(address _addr) public view returns (bool) {\r\n        uint256 length;\r\n        assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        return (length > 0);\r\n    }\r\n\r\n    // convert bytes to uint8\r\n    function toUint8(bytes memory _arg) public pure returns (uint8) {\r\n        return uint8(_arg[0]);\r\n    }\r\n\r\n    function toUint16(bytes memory _arg) public pure returns (uint16) {\r\n        return (uint16(uint8(_arg[0])) << 8) | uint16(uint8(_arg[1]));\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/RLPEncode.sol\r\n\r\n// Library for RLP encoding a list of bytes arrays.\r\n// Modeled after ethereumjs/rlp (https://github.com/ethereumjs/rlp)\r\n// [Very] modified version of Sam Mayo's library.\r\npragma solidity ^0.5.2;\r\n\r\n\r\nlibrary RLPEncode {\r\n    // Encode an item (bytes memory)\r\n    function encodeItem(bytes memory self)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory encoded;\r\n        if (self.length == 1 && uint8(self[0] & 0xFF) < 0x80) {\r\n            encoded = new bytes(1);\r\n            encoded = self;\r\n        } else {\r\n            encoded = BytesLib.concat(encodeLength(self.length, 128), self);\r\n        }\r\n        return encoded;\r\n    }\r\n\r\n    // Encode a list of items\r\n    function encodeList(bytes[] memory self)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory encoded;\r\n        for (uint256 i = 0; i < self.length; i++) {\r\n            encoded = BytesLib.concat(encoded, encodeItem(self[i]));\r\n        }\r\n        return BytesLib.concat(encodeLength(encoded.length, 192), encoded);\r\n    }\r\n\r\n    // Hack to encode nested lists. If you have a list as an item passed here, included\r\n    // pass = true in that index. E.g.\r\n    // [item, list, item] --> pass = [false, true, false]\r\n    // function encodeListWithPasses(bytes[] memory self, bool[] pass) internal pure returns (bytes memory) {\r\n    //   bytes memory encoded;\r\n    //   for (uint i=0; i < self.length; i++) {\r\n    // \t\tif (pass[i] == true) {\r\n    // \t\t\tencoded = BytesLib.concat(encoded, self[i]);\r\n    // \t\t} else {\r\n    // \t\t\tencoded = BytesLib.concat(encoded, encodeItem(self[i]));\r\n    // \t\t}\r\n    //   }\r\n    //   return BytesLib.concat(encodeLength(encoded.length, 192), encoded);\r\n    // }\r\n\r\n    // Generate the prefix for an item or the entire list based on RLP spec\r\n    function encodeLength(uint256 L, uint256 offset)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        if (L < 56) {\r\n            bytes memory prefix = new bytes(1);\r\n            prefix[0] = bytes1(uint8(L + offset));\r\n            return prefix;\r\n        } else {\r\n            // lenLen is the length of the hex representation of the data length\r\n            uint256 lenLen;\r\n            uint256 i = 0x1;\r\n\r\n            while (L / i != 0) {\r\n                lenLen++;\r\n                i *= 0x100;\r\n            }\r\n\r\n            bytes memory prefix0 = getLengthBytes(offset + 55 + lenLen);\r\n            bytes memory prefix1 = getLengthBytes(L);\r\n            return BytesLib.concat(prefix0, prefix1);\r\n        }\r\n    }\r\n\r\n    function getLengthBytes(uint256 x) internal pure returns (bytes memory b) {\r\n        // Figure out if we need 1 or two bytes to express the length.\r\n        // 1 byte gets us to max 255\r\n        // 2 bytes gets us to max 65535 (no payloads will be larger than this)\r\n        uint256 nBytes = 1;\r\n        if (x > 255) {\r\n            nBytes = 2;\r\n        }\r\n\r\n        b = new bytes(nBytes);\r\n        // Encode the length and return it\r\n        for (uint256 i = 0; i < nBytes; i++) {\r\n            b[i] = bytes1(uint8(x / (2**(8 * (nBytes - 1 - i)))));\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/common/lib/ExitPayloadReader.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\n\r\n\r\nlibrary ExitPayloadReader {\r\n  using RLPReader for bytes;\r\n  using RLPReader for RLPReader.RLPItem;\r\n\r\n  uint8 constant WORD_SIZE = 32;\r\n\r\n  struct ExitPayload {\r\n    RLPReader.RLPItem[] data;\r\n  }\r\n\r\n  struct Receipt {\r\n    RLPReader.RLPItem[] data;\r\n    bytes raw;\r\n    uint256 logIndex;\r\n  }\r\n\r\n  struct Log {\r\n    RLPReader.RLPItem data;\r\n    RLPReader.RLPItem[] list;\r\n  }\r\n\r\n  struct LogTopics {\r\n    RLPReader.RLPItem[] data;\r\n  }\r\n\r\n  function toExitPayload(bytes memory data)\r\n        internal\r\n        pure\r\n        returns (ExitPayload memory)\r\n    {\r\n        RLPReader.RLPItem[] memory payloadData = data\r\n            .toRlpItem()\r\n            .toList();\r\n\r\n        return ExitPayload(payloadData);\r\n    }\r\n\r\n    function copy(uint src, uint dest, uint len) private pure {\r\n        if (len == 0) return;\r\n\r\n        // copy as many word sizes as possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += WORD_SIZE;\r\n            dest += WORD_SIZE;\r\n        }\r\n\r\n        // left over bytes. Mask is used to remove unwanted bytes from the word\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    function getHeaderNumber(ExitPayload memory payload) internal pure returns(uint256) {\r\n      return payload.data[0].toUint();\r\n    }\r\n\r\n    function getBlockProof(ExitPayload memory payload) internal pure returns(bytes memory) {\r\n      return payload.data[1].toBytes();\r\n    }\r\n\r\n    function getBlockNumber(ExitPayload memory payload) internal pure returns(uint256) {\r\n      return payload.data[2].toUint();\r\n    }\r\n\r\n    function getBlockTime(ExitPayload memory payload) internal pure returns(uint256) {\r\n      return payload.data[3].toUint();\r\n    }\r\n\r\n    function getTxRoot(ExitPayload memory payload) internal pure returns(bytes32) {\r\n      return bytes32(payload.data[4].toUint());\r\n    }\r\n\r\n    function getReceiptRoot(ExitPayload memory payload) internal pure returns(bytes32) {\r\n      return bytes32(payload.data[5].toUint());\r\n    }\r\n\r\n    function getReceipt(ExitPayload memory payload) internal pure returns(Receipt memory receipt) {\r\n      receipt.raw = payload.data[6].toBytes();\r\n      RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();\r\n\r\n      if (receiptItem.isList()) {\r\n          // legacy tx\r\n          receipt.data = receiptItem.toList();\r\n      } else {\r\n          // pop first byte before parsting receipt\r\n          bytes memory typedBytes = receipt.raw;\r\n          bytes memory result = new bytes(typedBytes.length - 1);\r\n          uint256 srcPtr;\r\n          uint256 destPtr;\r\n          assembly {\r\n              srcPtr := add(33, typedBytes)\r\n              destPtr := add(0x20, result)\r\n          }\r\n\r\n          copy(srcPtr, destPtr, result.length);\r\n          receipt.data = result.toRlpItem().toList();\r\n      }\r\n\r\n      receipt.logIndex = getReceiptLogIndex(payload);\r\n      return receipt;\r\n    }\r\n\r\n    function getReceiptProof(ExitPayload memory payload) internal pure returns(bytes memory) {\r\n      return payload.data[7].toBytes();\r\n    }\r\n\r\n    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns(bytes memory) {\r\n      return payload.data[8].toBytes();\r\n    }\r\n\r\n    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns(uint256) {\r\n      return payload.data[8].toUint();\r\n    }\r\n\r\n    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns(uint256) {\r\n      return payload.data[9].toUint();\r\n    }\r\n\r\n    function getTx(ExitPayload memory payload) internal pure returns(bytes memory) {\r\n      return payload.data[10].toBytes();\r\n    }\r\n\r\n    function getTxProof(ExitPayload memory payload) internal pure returns(bytes memory) {\r\n      return payload.data[11].toBytes();\r\n    }\r\n    \r\n    // Receipt methods\r\n    function toBytes(Receipt memory receipt) internal pure returns(bytes memory) {\r\n        return receipt.raw;\r\n    }\r\n\r\n    function getLog(Receipt memory receipt) internal pure returns(Log memory) {\r\n        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];\r\n        return Log(logData, logData.toList());\r\n    }\r\n\r\n    // Log methods\r\n    function getEmitter(Log memory log) internal pure returns(address) {\r\n      return RLPReader.toAddress(log.list[0]);\r\n    }\r\n\r\n    function getTopics(Log memory log) internal pure returns(LogTopics memory) {\r\n        return LogTopics(log.list[1].toList());\r\n    }\r\n\r\n    function getData(Log memory log) internal pure returns(bytes memory) {\r\n        return log.list[2].toBytes();\r\n    }\r\n\r\n    function toRlpBytes(Log memory log) internal pure returns(bytes memory) {\r\n      return log.data.toRlpBytes();\r\n    }\r\n\r\n    // LogTopics methods\r\n    function getField(LogTopics memory topics, uint256 index) internal pure returns(RLPReader.RLPItem memory) {\r\n      return topics.data[index];\r\n    }\r\n}\r\n\r\n// File: contracts/root/withdrawManager/IWithdrawManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract IWithdrawManager {\r\n    function createExitQueue(address token) external;\r\n\r\n    function verifyInclusion(\r\n        bytes calldata data,\r\n        uint8 offset,\r\n        bool verifyTxInclusion\r\n    ) external view returns (uint256 age);\r\n\r\n    function addExitToQueue(\r\n        address exitor,\r\n        address childToken,\r\n        address rootToken,\r\n        uint256 exitAmountOrTokenId,\r\n        bytes32 txHash,\r\n        bool isRegularExit,\r\n        uint256 priority\r\n    ) external;\r\n\r\n    function addInput(\r\n        uint256 exitId,\r\n        uint256 age,\r\n        address utxoOwner,\r\n        address token\r\n    ) external;\r\n\r\n    function challengeExit(\r\n        uint256 exitId,\r\n        uint256 inputId,\r\n        bytes calldata challengeData,\r\n        address adjudicatorPredicate\r\n    ) external;\r\n}\r\n\r\n// File: contracts/root/depositManager/IDepositManager.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ninterface IDepositManager {\r\n    function depositEther() external payable;\r\n    function transferAssets(\r\n        address _token,\r\n        address _user,\r\n        uint256 _amountOrNFTId\r\n    ) external;\r\n    function depositERC20(address _token, uint256 _amount) external;\r\n    function depositERC721(address _token, uint256 _tokenId) external;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     * @notice Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/common/misc/ProxyStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract ProxyStorage is Ownable {\r\n    address internal proxyTo;\r\n}\r\n\r\n// File: contracts/common/governance/IGovernance.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ninterface IGovernance {\r\n    function update(address target, bytes calldata data) external;\r\n}\r\n\r\n// File: contracts/common/governance/Governable.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ncontract Governable {\r\n    IGovernance public governance;\r\n\r\n    constructor(address _governance) public {\r\n        governance = IGovernance(_governance);\r\n    }\r\n\r\n    modifier onlyGovernance() {\r\n        _assertGovernance();\r\n        _;\r\n    }\r\n\r\n    function _assertGovernance() private view {\r\n        require(\r\n            msg.sender == address(governance),\r\n            \"Only governance contract is authorized\"\r\n        );\r\n    }\r\n}\r\n\r\n// File: contracts/common/Registry.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\ncontract Registry is Governable {\r\n    // @todo hardcode constants\r\n    bytes32 private constant WETH_TOKEN = keccak256(\"wethToken\");\r\n    bytes32 private constant DEPOSIT_MANAGER = keccak256(\"depositManager\");\r\n    bytes32 private constant STAKE_MANAGER = keccak256(\"stakeManager\");\r\n    bytes32 private constant VALIDATOR_SHARE = keccak256(\"validatorShare\");\r\n    bytes32 private constant WITHDRAW_MANAGER = keccak256(\"withdrawManager\");\r\n    bytes32 private constant CHILD_CHAIN = keccak256(\"childChain\");\r\n    bytes32 private constant STATE_SENDER = keccak256(\"stateSender\");\r\n    bytes32 private constant SLASHING_MANAGER = keccak256(\"slashingManager\");\r\n\r\n    address public erc20Predicate;\r\n    address public erc721Predicate;\r\n\r\n    mapping(bytes32 => address) public contractMap;\r\n    mapping(address => address) public rootToChildToken;\r\n    mapping(address => address) public childToRootToken;\r\n    mapping(address => bool) public proofValidatorContracts;\r\n    mapping(address => bool) public isERC721;\r\n\r\n    enum Type {Invalid, ERC20, ERC721, Custom}\r\n    struct Predicate {\r\n        Type _type;\r\n    }\r\n    mapping(address => Predicate) public predicates;\r\n\r\n    event TokenMapped(address indexed rootToken, address indexed childToken);\r\n    event ProofValidatorAdded(address indexed validator, address indexed from);\r\n    event ProofValidatorRemoved(address indexed validator, address indexed from);\r\n    event PredicateAdded(address indexed predicate, address indexed from);\r\n    event PredicateRemoved(address indexed predicate, address indexed from);\r\n    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\r\n\r\n    constructor(address _governance) public Governable(_governance) {}\r\n\r\n    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\r\n        emit ContractMapUpdated(_key, contractMap[_key], _address);\r\n        contractMap[_key] = _address;\r\n    }\r\n\r\n    /**\r\n     * @dev Map root token to child token\r\n     * @param _rootToken Token address on the root chain\r\n     * @param _childToken Token address on the child chain\r\n     * @param _isERC721 Is the token being mapped ERC721\r\n     */\r\n    function mapToken(\r\n        address _rootToken,\r\n        address _childToken,\r\n        bool _isERC721\r\n    ) external onlyGovernance {\r\n        require(_rootToken != address(0x0) && _childToken != address(0x0), \"INVALID_TOKEN_ADDRESS\");\r\n        rootToChildToken[_rootToken] = _childToken;\r\n        childToRootToken[_childToken] = _rootToken;\r\n        isERC721[_rootToken] = _isERC721;\r\n        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\r\n        emit TokenMapped(_rootToken, _childToken);\r\n    }\r\n\r\n    function addErc20Predicate(address predicate) public onlyGovernance {\r\n        require(predicate != address(0x0), \"Can not add null address as predicate\");\r\n        erc20Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC20);\r\n    }\r\n\r\n    function addErc721Predicate(address predicate) public onlyGovernance {\r\n        erc721Predicate = predicate;\r\n        addPredicate(predicate, Type.ERC721);\r\n    }\r\n\r\n    function addPredicate(address predicate, Type _type) public onlyGovernance {\r\n        require(predicates[predicate]._type == Type.Invalid, \"Predicate already added\");\r\n        predicates[predicate]._type = _type;\r\n        emit PredicateAdded(predicate, msg.sender);\r\n    }\r\n\r\n    function removePredicate(address predicate) public onlyGovernance {\r\n        require(predicates[predicate]._type != Type.Invalid, \"Predicate does not exist\");\r\n        delete predicates[predicate];\r\n        emit PredicateRemoved(predicate, msg.sender);\r\n    }\r\n\r\n    function getValidatorShareAddress() public view returns (address) {\r\n        return contractMap[VALIDATOR_SHARE];\r\n    }\r\n\r\n    function getWethTokenAddress() public view returns (address) {\r\n        return contractMap[WETH_TOKEN];\r\n    }\r\n\r\n    function getDepositManagerAddress() public view returns (address) {\r\n        return contractMap[DEPOSIT_MANAGER];\r\n    }\r\n\r\n    function getStakeManagerAddress() public view returns (address) {\r\n        return contractMap[STAKE_MANAGER];\r\n    }\r\n\r\n    function getSlashingManagerAddress() public view returns (address) {\r\n        return contractMap[SLASHING_MANAGER];\r\n    }\r\n\r\n    function getWithdrawManagerAddress() public view returns (address) {\r\n        return contractMap[WITHDRAW_MANAGER];\r\n    }\r\n\r\n    function getChildChainAndStateSender() public view returns (address, address) {\r\n        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\r\n    }\r\n\r\n    function isTokenMapped(address _token) public view returns (bool) {\r\n        return rootToChildToken[_token] != address(0x0);\r\n    }\r\n\r\n    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\r\n        require(isTokenMapped(_token), \"TOKEN_NOT_MAPPED\");\r\n        return isERC721[_token];\r\n    }\r\n\r\n    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\r\n        if (isTokenMappedAndIsErc721(_token)) {\r\n            return erc721Predicate;\r\n        }\r\n        return erc20Predicate;\r\n    }\r\n\r\n    function isChildTokenErc721(address childToken) public view returns (bool) {\r\n        address rootToken = childToRootToken[childToken];\r\n        require(rootToken != address(0x0), \"Child token is not mapped\");\r\n        return isERC721[rootToken];\r\n    }\r\n}\r\n\r\n// File: contracts/common/mixin/ChainIdMixin.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\ncontract ChainIdMixin {\r\n  bytes constant public networkId = hex\"3A99\";\r\n  uint256 constant public CHAINID = 15001;\r\n}\r\n\r\n// File: contracts/root/RootChainStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\ncontract RootChainHeader {\r\n    event NewHeaderBlock(\r\n        address indexed proposer,\r\n        uint256 indexed headerBlockId,\r\n        uint256 indexed reward,\r\n        uint256 start,\r\n        uint256 end,\r\n        bytes32 root\r\n    );\r\n    // housekeeping event\r\n    event ResetHeaderBlock(address indexed proposer, uint256 indexed headerBlockId);\r\n    struct HeaderBlock {\r\n        bytes32 root;\r\n        uint256 start;\r\n        uint256 end;\r\n        uint256 createdAt;\r\n        address proposer;\r\n    }\r\n}\r\n\r\n\r\ncontract RootChainStorage is ProxyStorage, RootChainHeader, ChainIdMixin {\r\n    bytes32 public heimdallId;\r\n    uint8 public constant VOTE_TYPE = 2;\r\n\r\n    uint16 internal constant MAX_DEPOSITS = 10000;\r\n    uint256 public _nextHeaderBlock = MAX_DEPOSITS;\r\n    uint256 internal _blockDepositId = 1;\r\n    mapping(uint256 => HeaderBlock) public headerBlocks;\r\n    Registry internal registry;\r\n}\r\n\r\n// File: contracts/staking/stakeManager/IStakeManager.sol\r\n\r\npragma solidity 0.5.17;\r\n\r\ncontract IStakeManager {\r\n    // validator replacement\r\n    function startAuction(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n\r\n    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;\r\n\r\n    function transferFunds(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function delegationDeposit(\r\n        uint256 validatorId,\r\n        uint256 amount,\r\n        address delegator\r\n    ) external returns (bool);\r\n\r\n    function unstake(uint256 validatorId) external;\r\n\r\n    function totalStakedFor(address addr) external view returns (uint256);\r\n\r\n    function stakeFor(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 heimdallFee,\r\n        bool acceptDelegation,\r\n        bytes memory signerPubkey\r\n    ) public;\r\n\r\n    function checkSignatures(\r\n        uint256 blockInterval,\r\n        bytes32 voteHash,\r\n        bytes32 stateRoot,\r\n        address proposer,\r\n        uint[3][] calldata sigs\r\n    ) external returns (uint256);\r\n\r\n    function updateValidatorState(uint256 validatorId, int256 amount) public;\r\n\r\n    function ownerOf(uint256 tokenId) public view returns (address);\r\n\r\n    function slash(bytes calldata slashingInfoList) external returns (uint256);\r\n\r\n    function validatorStake(uint256 validatorId) public view returns (uint256);\r\n\r\n    function epoch() public view returns (uint256);\r\n\r\n    function getRegistry() public view returns (address);\r\n\r\n    function withdrawalDelay() public view returns (uint256);\r\n\r\n    function delegatedAmount(uint256 validatorId) public view returns(uint256);\r\n\r\n    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) public;\r\n\r\n    function withdrawDelegatorsReward(uint256 validatorId) public returns(uint256);\r\n\r\n    function delegatorsReward(uint256 validatorId) public view returns(uint256);\r\n\r\n    function dethroneAndStake(\r\n        address auctionUser,\r\n        uint256 heimdallFee,\r\n        uint256 validatorId,\r\n        uint256 auctionAmount,\r\n        bool acceptDelegation,\r\n        bytes calldata signerPubkey\r\n    ) external;\r\n}\r\n\r\n// File: contracts/root/IRootChain.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\ninterface IRootChain {\r\n    function slash() external;\r\n\r\n    function submitHeaderBlock(bytes calldata data, bytes calldata sigs)\r\n        external;\r\n    \r\n    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs)\r\n        external;\r\n\r\n    function getLastChildBlock() external view returns (uint256);\r\n\r\n    function currentHeaderBlock() external view returns (uint256);\r\n}\r\n\r\n// File: contracts/root/RootChain.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract RootChain is RootChainStorage, IRootChain {\r\n    using SafeMath for uint256;\r\n    using RLPReader for bytes;\r\n    using RLPReader for RLPReader.RLPItem;\r\n\r\n    modifier onlyDepositManager() {\r\n        require(msg.sender == registry.getDepositManagerAddress(), \"UNAUTHORIZED_DEPOSIT_MANAGER_ONLY\");\r\n        _;\r\n    }\r\n\r\n    function submitHeaderBlock(bytes calldata data, bytes calldata sigs) external {\r\n        revert();\r\n    }\r\n\r\n    function submitCheckpoint(bytes calldata data, uint[3][] calldata sigs) external {\r\n        (address proposer, uint256 start, uint256 end, bytes32 rootHash, bytes32 accountHash, uint256 _borChainID) = abi\r\n            .decode(data, (address, uint256, uint256, bytes32, bytes32, uint256));\r\n        require(CHAINID == _borChainID, \"Invalid bor chain id\");\r\n\r\n        require(_buildHeaderBlock(proposer, start, end, rootHash), \"INCORRECT_HEADER_DATA\");\r\n\r\n        // check if it is better to keep it in local storage instead\r\n        IStakeManager stakeManager = IStakeManager(registry.getStakeManagerAddress());\r\n        uint256 _reward = stakeManager.checkSignatures(\r\n            end.sub(start).add(1),\r\n            /**  \r\n                prefix 01 to data \r\n                01 represents positive vote on data and 00 is negative vote\r\n                malicious validator can try to send 2/3 on negative vote so 01 is appended\r\n             */\r\n            keccak256(abi.encodePacked(bytes(hex\"01\"), data)),\r\n            accountHash,\r\n            proposer,\r\n            sigs\r\n        );\r\n\r\n        require(_reward != 0, \"Invalid checkpoint\");\r\n        emit NewHeaderBlock(proposer, _nextHeaderBlock, _reward, start, end, rootHash);\r\n        _nextHeaderBlock = _nextHeaderBlock.add(MAX_DEPOSITS);\r\n        _blockDepositId = 1;\r\n    }\r\n\r\n    function updateDepositId(uint256 numDeposits) external onlyDepositManager returns (uint256 depositId) {\r\n        depositId = currentHeaderBlock().add(_blockDepositId);\r\n        // deposit ids will be (_blockDepositId, _blockDepositId + 1, .... _blockDepositId + numDeposits - 1)\r\n        _blockDepositId = _blockDepositId.add(numDeposits);\r\n        require(\r\n            // Since _blockDepositId is initialized to 1; only (MAX_DEPOSITS - 1) deposits per header block are allowed\r\n            _blockDepositId <= MAX_DEPOSITS,\r\n            \"TOO_MANY_DEPOSITS\"\r\n        );\r\n    }\r\n\r\n    function getLastChildBlock() external view returns (uint256) {\r\n        return headerBlocks[currentHeaderBlock()].end;\r\n    }\r\n\r\n    function slash() external {\r\n        //TODO: future implementation\r\n    }\r\n\r\n    function currentHeaderBlock() public view returns (uint256) {\r\n        return _nextHeaderBlock.sub(MAX_DEPOSITS);\r\n    }\r\n\r\n    function _buildHeaderBlock(\r\n        address proposer,\r\n        uint256 start,\r\n        uint256 end,\r\n        bytes32 rootHash\r\n    ) private returns (bool) {\r\n        uint256 nextChildBlock;\r\n        /*\r\n    The ID of the 1st header block is MAX_DEPOSITS.\r\n    if _nextHeaderBlock == MAX_DEPOSITS, then the first header block is yet to be submitted, hence nextChildBlock = 0\r\n    */\r\n        if (_nextHeaderBlock > MAX_DEPOSITS) {\r\n            nextChildBlock = headerBlocks[currentHeaderBlock()].end + 1;\r\n        }\r\n        if (nextChildBlock != start) {\r\n            return false;\r\n        }\r\n\r\n        HeaderBlock memory headerBlock = HeaderBlock({\r\n            root: rootHash,\r\n            start: nextChildBlock,\r\n            end: end,\r\n            createdAt: now,\r\n            proposer: proposer\r\n        });\r\n\r\n        headerBlocks[_nextHeaderBlock] = headerBlock;\r\n        return true;\r\n    }\r\n\r\n    // Housekeeping function. @todo remove later\r\n    function setNextHeaderBlock(uint256 _value) public onlyOwner {\r\n        require(_value % MAX_DEPOSITS == 0, \"Invalid value\");\r\n        for (uint256 i = _value; i < _nextHeaderBlock; i += MAX_DEPOSITS) {\r\n            delete headerBlocks[i];\r\n        }\r\n        _nextHeaderBlock = _value;\r\n        _blockDepositId = 1;\r\n        emit ResetHeaderBlock(msg.sender, _nextHeaderBlock);\r\n    }\r\n\r\n    // Housekeeping function. @todo remove later\r\n    function setHeimdallId(string memory _heimdallId) public onlyOwner {\r\n        heimdallId = keccak256(abi.encodePacked(_heimdallId));\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title IERC165\r\n * @dev https://eips.ethereum.org/EIPS/eip-165\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @notice Query if a contract implements an interface\r\n     * @param interfaceId The interface identifier, as specified in ERC-165\r\n     * @dev Interface identification is specified in ERC-165. This function\r\n     * uses less than 30,000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) public view returns (address owner);\r\n\r\n    function approve(address to, uint256 tokenId) public;\r\n    function getApproved(uint256 tokenId) public view returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) public;\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\r\n\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ncontract IERC721Receiver {\r\n    /**\r\n     * @notice Handle the receipt of an NFT\r\n     * @dev The ERC721 smart contract calls this function on the recipient\r\n     * after a `safeTransfer`. This function MUST return the function selector,\r\n     * otherwise the caller will revert the transaction. The selector to be\r\n     * returned can be obtained as `this.onERC721Received.selector`. This\r\n     * function MAY throw to revert and reject the transfer.\r\n     * Note: the ERC721 contract address is always the message sender.\r\n     * @param operator The address which called `safeTransferFrom` function\r\n     * @param from The address which previously owned the token\r\n     * @param tokenId The NFT identifier which is being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\r\n    public returns (bytes4);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/drafts/Counters.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\r\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\r\n * directly accessed.\r\n */\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n/**\r\n * @title ERC165\r\n * @author Matt Condon (@shrugs)\r\n * @dev Implements ERC165 using a lookup table.\r\n */\r\ncontract ERC165 is IERC165 {\r\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n    /*\r\n     * 0x01ffc9a7 ===\r\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\r\n     */\r\n\r\n    /**\r\n     * @dev a mapping of interface id to whether or not it's supported\r\n     */\r\n    mapping(bytes4 => bool) private _supportedInterfaces;\r\n\r\n    /**\r\n     * @dev A contract implementing SupportsInterfaceWithLookup\r\n     * implement ERC165 itself\r\n     */\r\n    constructor () internal {\r\n        _registerInterface(_INTERFACE_ID_ERC165);\r\n    }\r\n\r\n    /**\r\n     * @dev implement supportsInterface(bytes4) using a lookup table\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        return _supportedInterfaces[interfaceId];\r\n    }\r\n\r\n    /**\r\n     * @dev internal method for registering an interface\r\n     */\r\n    function _registerInterface(bytes4 interfaceId) internal {\r\n        require(interfaceId != 0xffffffff);\r\n        _supportedInterfaces[interfaceId] = true;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ncontract ERC721 is ERC165, IERC721 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Counters for Counters.Counter;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) private _tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => Counters.Counter) private _ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n    /*\r\n     * 0x80ac58cd ===\r\n     *     bytes4(keccak256('balanceOf(address)')) ^\r\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\r\n     *     bytes4(keccak256('approve(address,uint256)')) ^\r\n     *     bytes4(keccak256('getApproved(uint256)')) ^\r\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n     */\r\n\r\n    constructor () public {\r\n        // register the supported interfaces to conform to ERC721 via ERC165\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address\r\n     * @param owner address to query the balance of\r\n     * @return uint256 representing the amount owned by the passed address\r\n     */\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(owner != address(0));\r\n        return _ownedTokensCount[owner].current();\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the owner of the specified token ID\r\n     * @param tokenId uint256 ID of the token to query the owner of\r\n     * @return address currently marked as the owner of the given token ID\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address owner = _tokenOwner[tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Approves another address to transfer the given token ID\r\n     * The zero address indicates there is no approved address.\r\n     * There can only be one approved address per token at a given time.\r\n     * Can only be called by the token owner or an approved operator.\r\n     * @param to address to be approved for the given token ID\r\n     * @param tokenId uint256 ID of the token to be approved\r\n     */\r\n    function approve(address to, uint256 tokenId) public {\r\n        address owner = ownerOf(tokenId);\r\n        require(to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(owner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the approved address for a token ID, or zero if no address set\r\n     * Reverts if the token ID does not exist.\r\n     * @param tokenId uint256 ID of the token to query the approval of\r\n     * @return address currently approved for the given token ID\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        require(_exists(tokenId));\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Sets or unsets the approval of a given operator\r\n     * An operator is allowed to transfer all tokens of the sender on their behalf\r\n     * @param to operator address to set the approval\r\n     * @param approved representing the status of the approval to be set\r\n     */\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(to != msg.sender);\r\n        _operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Tells whether an operator is approved by a given owner\r\n     * @param owner owner address which you want to query the approval of\r\n     * @param operator operator address which you want to query the approval of\r\n     * @return bool whether the given operator is approved by the given owner\r\n     */\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of a given token ID to another address\r\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId));\r\n\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers the ownership of a given token ID to another address\r\n     * If the target address is a contract, it must implement `onERC721Received`,\r\n     * which is called upon a safe transfer, and return the magic value\r\n     * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n     * the transfer is reverted.\r\n     * Requires the msg.sender to be the owner, approved, or operator\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes data to send along with a safe transfer check\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\r\n        transferFrom(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the specified token exists\r\n     * @param tokenId uint256 ID of the token to query the existence of\r\n     * @return bool whether the token exists\r\n     */\r\n    function _exists(uint256 tokenId) internal view returns (bool) {\r\n        address owner = _tokenOwner[tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether the given spender can transfer a given token ID\r\n     * @param spender address of the spender to query\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @return bool whether the msg.sender is approved for the given token ID,\r\n     * is an operator of the owner, or is the owner of the token\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a new token\r\n     * Reverts if the given token ID already exists\r\n     * @param to The address that will own the minted token\r\n     * @param tokenId uint256 ID of the token to be minted\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(to != address(0));\r\n        require(!_exists(tokenId));\r\n\r\n        _tokenOwner[tokenId] = to;\r\n        _ownedTokensCount[to].increment();\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * Deprecated, use _burn(uint256) instead.\r\n     * @param owner owner of the token to burn\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(address owner, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == owner);\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[owner].decrement();\r\n        _tokenOwner[tokenId] = address(0);\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to burn a specific token\r\n     * Reverts if the token does not exist\r\n     * @param tokenId uint256 ID of the token being burned\r\n     */\r\n    function _burn(uint256 tokenId) internal {\r\n        _burn(ownerOf(tokenId), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to transfer ownership of a given token ID to another address.\r\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\r\n     * @param from current owner of the token\r\n     * @param to address to receive the ownership of the given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\r\n        require(ownerOf(tokenId) == from);\r\n        require(to != address(0));\r\n\r\n        _clearApproval(tokenId);\r\n\r\n        _ownedTokensCount[from].decrement();\r\n        _ownedTokensCount[to].increment();\r\n\r\n        _tokenOwner[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke `onERC721Received` on a target address\r\n     * The call is not executed if the target address is not a contract\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\r\n        internal returns (bool)\r\n    {\r\n        if (!to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\r\n        return (retval == _ERC721_RECEIVED);\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to clear current approval of a given token ID\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     */\r\n    function _clearApproval(uint256 tokenId) private {\r\n        if (_tokenApprovals[tokenId] != address(0)) {\r\n            _tokenApprovals[tokenId] = address(0);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/root/withdrawManager/ExitNFT.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\ncontract ExitNFT is ERC721 {\r\n    Registry internal registry;\r\n\r\n    modifier onlyWithdrawManager() {\r\n        require(\r\n            msg.sender == registry.getWithdrawManagerAddress(),\r\n            \"UNAUTHORIZED_WITHDRAW_MANAGER_ONLY\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address _registry) public {\r\n        registry = Registry(_registry);\r\n    }\r\n\r\n    function mint(address _owner, uint256 _tokenId)\r\n        external\r\n        onlyWithdrawManager\r\n    {\r\n        _mint(_owner, _tokenId);\r\n    }\r\n\r\n    function burn(uint256 _tokenId) external onlyWithdrawManager {\r\n        _burn(_tokenId);\r\n    }\r\n\r\n    function exists(uint256 tokenId) public view returns (bool) {\r\n        return _exists(tokenId);\r\n    }\r\n}\r\n\r\n// File: contracts/root/withdrawManager/WithdrawManagerStorage.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ExitsDataStructure {\r\n    struct Input {\r\n        address utxoOwner;\r\n        address predicate;\r\n        address token;\r\n    }\r\n\r\n    struct PlasmaExit {\r\n        uint256 receiptAmountOrNFTId;\r\n        bytes32 txHash;\r\n        address owner;\r\n        address token;\r\n        bool isRegularExit;\r\n        address predicate;\r\n        // Mapping from age of input to Input\r\n        mapping(uint256 => Input) inputs;\r\n    }\r\n}\r\n\r\n\r\ncontract WithdrawManagerHeader is ExitsDataStructure {\r\n    event Withdraw(uint256 indexed exitId, address indexed user, address indexed token, uint256 amount);\r\n\r\n    event ExitStarted(\r\n        address indexed exitor,\r\n        uint256 indexed exitId,\r\n        address indexed token,\r\n        uint256 amount,\r\n        bool isRegularExit\r\n    );\r\n\r\n    event ExitUpdated(uint256 indexed exitId, uint256 indexed age, address signer);\r\n    event ExitPeriodUpdate(uint256 indexed oldExitPeriod, uint256 indexed newExitPeriod);\r\n\r\n    event ExitCancelled(uint256 indexed exitId);\r\n}\r\n\r\n\r\ncontract WithdrawManagerStorage is ProxyStorage, WithdrawManagerHeader {\r\n    // 0.5 week = 7 * 86400 / 2 = 302400\r\n    uint256 public HALF_EXIT_PERIOD = 302400;\r\n\r\n    // Bonded exits collaterized at 0.1 ETH\r\n    uint256 internal constant BOND_AMOUNT = 10**17;\r\n\r\n    Registry internal registry;\r\n    RootChain internal rootChain;\r\n\r\n    mapping(uint128 => bool) isKnownExit;\r\n    mapping(uint256 => PlasmaExit) public exits;\r\n    // mapping with token => (owner => exitId) keccak(token+owner) keccak(token+owner+tokenId)\r\n    mapping(bytes32 => uint256) public ownerExits;\r\n    mapping(address => address) public exitsQueues;\r\n    ExitNFT public exitNft;\r\n\r\n    // ERC721, ERC20 and Weth transfers require 155000, 100000, 52000 gas respectively\r\n    // Processing each exit in a while loop iteration requires ~52000 gas (@todo check if this changed)\r\n    // uint32 constant internal ITERATION_GAS = 52000;\r\n\r\n    // So putting an upper limit of 155000 + 52000 + leeway\r\n    uint32 public ON_FINALIZE_GAS_LIMIT = 300000;\r\n\r\n    uint256 public exitWindow;\r\n}\r\n\r\n// File: contracts/root/predicates/IPredicate.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IPredicate {\r\n    /**\r\n   * @notice Verify the deprecation of a state update\r\n   * @param exit ABI encoded PlasmaExit data\r\n   * @param inputUtxo ABI encoded Input UTXO data\r\n   * @param challengeData RLP encoded data of the challenge reference tx that encodes the following fields\r\n   * headerNumber Header block number of which the reference tx was a part of\r\n   * blockProof Proof that the block header (in the child chain) is a leaf in the submitted merkle root\r\n   * blockNumber Block number of which the reference tx is a part of\r\n   * blockTime Reference tx block time\r\n   * blocktxRoot Transactions root of block\r\n   * blockReceiptsRoot Receipts root of block\r\n   * receipt Receipt of the reference transaction\r\n   * receiptProof Merkle proof of the reference receipt\r\n   * branchMask Merkle proof branchMask for the receipt\r\n   * logIndex Log Index to read from the receipt\r\n   * tx Challenge transaction\r\n   * txProof Merkle proof of the challenge tx\r\n   * @return Whether or not the state is deprecated\r\n   */\r\n    function verifyDeprecation(\r\n        bytes calldata exit,\r\n        bytes calldata inputUtxo,\r\n        bytes calldata challengeData\r\n    ) external returns (bool);\r\n\r\n    function interpretStateUpdate(bytes calldata state)\r\n        external\r\n        view\r\n        returns (bytes memory);\r\n    function onFinalizeExit(bytes calldata data) external;\r\n}\r\n\r\ncontract PredicateUtils is ExitsDataStructure, ChainIdMixin {\r\n    using RLPReader for RLPReader.RLPItem;\r\n\r\n    // Bonded exits collaterized at 0.1 ETH\r\n    uint256 private constant BOND_AMOUNT = 10**17;\r\n\r\n    IWithdrawManager internal withdrawManager;\r\n    IDepositManager internal depositManager;\r\n\r\n    modifier onlyWithdrawManager() {\r\n        require(\r\n            msg.sender == address(withdrawManager),\r\n            \"ONLY_WITHDRAW_MANAGER\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier isBondProvided() {\r\n        require(msg.value == BOND_AMOUNT, \"Invalid Bond amount\");\r\n        _;\r\n    }\r\n\r\n    function onFinalizeExit(bytes calldata data) external onlyWithdrawManager {\r\n        (, address token, address exitor, uint256 tokenId) = decodeExitForProcessExit(\r\n            data\r\n        );\r\n        depositManager.transferAssets(token, exitor, tokenId);\r\n    }\r\n\r\n    function sendBond() internal {\r\n        address(uint160(address(withdrawManager))).transfer(BOND_AMOUNT);\r\n    }\r\n\r\n    function getAddressFromTx(RLPReader.RLPItem[] memory txList)\r\n        internal\r\n        pure\r\n        returns (address signer, bytes32 txHash)\r\n    {\r\n        bytes[] memory rawTx = new bytes[](9);\r\n        for (uint8 i = 0; i <= 5; i++) {\r\n            rawTx[i] = txList[i].toBytes();\r\n        }\r\n        rawTx[6] = networkId;\r\n        rawTx[7] = hex\"\"; // [7] and [8] have something to do with v, r, s values\r\n        rawTx[8] = hex\"\";\r\n\r\n        txHash = keccak256(RLPEncode.encodeList(rawTx));\r\n        signer = ecrecover(\r\n            txHash,\r\n            Common.getV(txList[6].toBytes(), Common.toUint16(networkId)),\r\n            bytes32(txList[7].toUint()),\r\n            bytes32(txList[8].toUint())\r\n        );\r\n    }\r\n\r\n    function decodeExit(bytes memory data)\r\n        internal\r\n        pure\r\n        returns (PlasmaExit memory)\r\n    {\r\n        (address owner, address token, uint256 amountOrTokenId, bytes32 txHash, bool isRegularExit) = abi\r\n            .decode(data, (address, address, uint256, bytes32, bool));\r\n        return\r\n            PlasmaExit(\r\n                amountOrTokenId,\r\n                txHash,\r\n                owner,\r\n                token,\r\n                isRegularExit,\r\n                address(0) /* predicate value is not required */\r\n            );\r\n    }\r\n\r\n    function decodeExitForProcessExit(bytes memory data)\r\n        internal\r\n        pure\r\n        returns (uint256 exitId, address token, address exitor, uint256 tokenId)\r\n    {\r\n        (exitId, token, exitor, tokenId) = abi.decode(\r\n            data,\r\n            (uint256, address, address, uint256)\r\n        );\r\n    }\r\n\r\n    function decodeInputUtxo(bytes memory data)\r\n        internal\r\n        pure\r\n        returns (uint256 age, address signer, address predicate, address token)\r\n    {\r\n        (age, signer, predicate, token) = abi.decode(\r\n            data,\r\n            (uint256, address, address, address)\r\n        );\r\n    }\r\n\r\n}\r\n\r\ncontract IErcPredicate is IPredicate, PredicateUtils {\r\n    enum ExitType {Invalid, OutgoingTransfer, IncomingTransfer, Burnt}\r\n\r\n    struct ExitTxData {\r\n        uint256 amountOrToken;\r\n        bytes32 txHash;\r\n        address childToken;\r\n        address signer;\r\n        ExitType exitType;\r\n    }\r\n\r\n    struct ReferenceTxData {\r\n        uint256 closingBalance;\r\n        uint256 age;\r\n        address childToken;\r\n        address rootToken;\r\n    }\r\n\r\n    uint256 internal constant MAX_LOGS = 10;\r\n\r\n    constructor(address _withdrawManager, address _depositManager) public {\r\n        withdrawManager = IWithdrawManager(_withdrawManager);\r\n        depositManager = IDepositManager(_depositManager);\r\n    }\r\n}\r\n\r\n// File: contracts/root/predicates/ERC721PredicateBurnOnly.sol\r\n\r\npragma solidity ^0.5.2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ERC721PredicateBurnOnly is IErcPredicate {\r\n    using RLPReader for bytes;\r\n    using RLPReader for RLPReader.RLPItem;\r\n    using SafeMath for uint256;\r\n\r\n    using ExitPayloadReader for bytes;\r\n    using ExitPayloadReader for ExitPayloadReader.ExitPayload;\r\n    using ExitPayloadReader for ExitPayloadReader.Receipt;\r\n    using ExitPayloadReader for ExitPayloadReader.Log;\r\n    using ExitPayloadReader for ExitPayloadReader.LogTopics;\r\n\r\n    // keccak256('Withdraw(address,address,uint256)')\r\n    bytes32 constant WITHDRAW_EVENT_SIG = 0x9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb;\r\n\r\n    constructor(address _withdrawManager, address _depositManager)\r\n        public\r\n        IErcPredicate(_withdrawManager, _depositManager)\r\n    {}\r\n\r\n    function verifyDeprecation(\r\n        bytes calldata exit,\r\n        bytes calldata inputUtxo,\r\n        bytes calldata challengeData\r\n    ) external returns (bool) {}\r\n\r\n    function interpretStateUpdate(bytes calldata state)\r\n        external\r\n        view\r\n        returns (bytes memory b) {}\r\n\r\n    function startExitWithBurntTokens(bytes memory data)\r\n        public\r\n        returns (bytes memory)\r\n    {\r\n        uint256 age = withdrawManager.verifyInclusion(\r\n            data,\r\n            0, /* offset */\r\n            false /* verifyTxInclusion */\r\n        );\r\n\r\n        ExitPayloadReader.ExitPayload memory payload = data.toExitPayload();\r\n        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();\r\n        uint256 logIndex = payload.getReceiptLogIndex();\r\n        require(logIndex < MAX_LOGS, \"Supporting a max of 10 logs\");\r\n        ExitPayloadReader.Log memory log = receipt.getLog();\r\n\r\n        // \"address\" (contract address that emitted the log) field in the receipt\r\n        address childToken = log.getEmitter();\r\n        ExitPayloadReader.LogTopics memory topics = log.getTopics();\r\n        // now, inputItems[i] refers to i-th (0-based) topic in the topics array\r\n        // event Withdraw(address indexed token, address indexed from, uint256 amountOrTokenId, uint256 input1, uint256 output1)\r\n        require(\r\n            bytes32(topics.getField(0).toUint()) == WITHDRAW_EVENT_SIG,\r\n            \"Not a withdraw event signature\"\r\n        );\r\n        require(\r\n            msg.sender == address(topics.getField(2).toUint()), // from\r\n            \"Withdrawer and burn exit tx do not match\"\r\n        );\r\n        address rootToken = address(topics.getField(1).toUint());\r\n        uint256 tokenId = BytesLib.toUint(log.getData(), 0);\r\n        uint256 exitId = age << 1;\r\n        withdrawManager.addExitToQueue(\r\n            msg.sender,\r\n            childToken,\r\n            rootToken,\r\n            tokenId,\r\n            bytes32(0x0), /* txHash */\r\n            true, /* isRegularExit */\r\n            exitId\r\n        );\r\n        return abi.encode(rootToken, tokenId, childToken, exitId);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_withdrawManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_depositManager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHAINID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"state\",\"type\":\"bytes\"}],\"name\":\"interpretStateUpdate\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"b\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"networkId\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onFinalizeExit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"startExitWithBurntTokens\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"exit\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"inputUtxo\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"challengeData\",\"type\":\"bytes\"}],\"name\":\"verifyDeprecation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC721PredicateBurnOnly","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002a88696e0ffa76baa1338f2c74497cc013495922000000000000000000000000401f6c983ea34274ec46f84d70b31c151321188b","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"bzzr://661cbafc5849a9b2decde02a9f030a12866cac104098593e1fc55298b8ee7e2b"}]}