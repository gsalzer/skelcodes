{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/choco/ChocoMintERC721BulkMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/MintERC721Lib.sol\\\";\\nimport \\\"../utils/SignatureLib.sol\\\";\\nimport \\\"../interfaces/IChocoMintERC721.sol\\\";\\n\\ncontract ChocoMintERC721BulkMinter {\\n  function mint(\\n    address chocoMintERC721,\\n    MintERC721Lib.MintERC721Data[] memory mintERC721Data,\\n    SignatureLib.SignatureData[] memory signatureData\\n  ) external {\\n    require(mintERC721Data.length == signatureData.length, \\\"ChocoMintERC721BulkMinter: length verification failed\\\");\\n    for (uint256 i = 0; i < mintERC721Data.length; i++) {\\n      IChocoMintERC721(chocoMintERC721).mint(mintERC721Data[i], signatureData[i]);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/MintERC721Lib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SecurityLib.sol\\\";\\nimport \\\"./SignatureLib.sol\\\";\\n\\nlibrary MintERC721Lib {\\n  struct MintERC721Data {\\n    SecurityLib.SecurityData securityData;\\n    address minter;\\n    address to;\\n    uint256 tokenId;\\n    bytes data;\\n  }\\n\\n  bytes32 private constant _MINT_ERC721_TYPEHASH =\\n    keccak256(\\n      bytes(\\n        \\\"MintERC721Data(SecurityData securityData,address minter,address to,uint256 tokenId,bytes data)SecurityData(uint256 validFrom,uint256 validTo,uint256 salt)\\\"\\n      )\\n    );\\n\\n  function hashStruct(MintERC721Data memory mintERC721Data) internal pure returns (bytes32) {\\n    return\\n      keccak256(\\n        abi.encode(\\n          _MINT_ERC721_TYPEHASH,\\n          SecurityLib.hashStruct(mintERC721Data.securityData),\\n          mintERC721Data.minter,\\n          mintERC721Data.to,\\n          mintERC721Data.tokenId,\\n          keccak256(mintERC721Data.data)\\n        )\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SignatureLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary SignatureLib {\\n  struct SignatureData {\\n    bytes32 root;\\n    bytes32[] proof;\\n    bytes signature;\\n  }\\n\\n  bytes32 private constant _SIGNATURE_DATA_TYPEHASH = keccak256(bytes(\\\"SignatureData(bytes32 root)\\\"));\\n\\n  function hashStruct(SignatureData memory signatureData) internal pure returns (bytes32) {\\n    return keccak256(abi.encode(_SIGNATURE_DATA_TYPEHASH, signatureData.root));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IChocoMintERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/MintERC721Lib.sol\\\";\\nimport \\\"../utils/SignatureLib.sol\\\";\\n\\ninterface IChocoMintERC721 {\\n  event Minted(bytes32 indexed mintERC721Hash);\\n\\n  function mint(MintERC721Lib.MintERC721Data memory mintERC721Data, SignatureLib.SignatureData memory signatureData)\\n    external;\\n\\n  function isMinted(uint256 tokenId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SecurityLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary SecurityLib {\\n  struct SecurityData {\\n    uint256 validFrom;\\n    uint256 validTo;\\n    uint256 salt;\\n  }\\n\\n  bytes32 private constant _SECURITY_TYPEHASH =\\n    keccak256(abi.encodePacked(\\\"SecurityData(uint256 validFrom,uint256 validTo,uint256 salt)\\\"));\\n\\n  function validate(SecurityData memory securityData) internal view returns (bool, string memory) {\\n    if (securityData.validFrom > block.timestamp) {\\n      return (false, \\\"SecurityLib: valid from verification failed\\\");\\n    }\\n\\n    if (securityData.validTo < block.timestamp) {\\n      return (false, \\\"SecurityLib: valid to verification failed\\\");\\n    }\\n    return (true, \\\"\\\");\\n  }\\n\\n  function hashStruct(SecurityData memory securityData) internal pure returns (bytes32) {\\n    return keccak256(abi.encode(_SECURITY_TYPEHASH, securityData.validFrom, securityData.validTo, securityData.salt));\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"chocoMintERC721\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"validFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct SecurityLib.SecurityData\",\"name\":\"securityData\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct MintERC721Lib.MintERC721Data[]\",\"name\":\"mintERC721Data\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct SignatureLib.SignatureData[]\",\"name\":\"signatureData\",\"type\":\"tuple[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ChocoMintERC721BulkMinter","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}