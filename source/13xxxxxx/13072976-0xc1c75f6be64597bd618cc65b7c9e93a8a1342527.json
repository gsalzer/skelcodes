{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 40\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/Timelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\n/**\\n  Timelock contract.\\n  Fixed token payout and timing.\\n  Can add recipients and multiple grants per recipient.\\n\\n  @author iain\\n  github.com/iainnash/simple-timelock\\n */\\ncontract Timelock {\\n    // From IERC20\\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\\n    /**\\n        Error codes lookup:\\n        1: Recover and recieve grant days need to be greater than 0\\n        2: Grant not valid.\\n        3: Only owner can add grants.\\n        4: Only owner can recover\\n        5: Cannot set the recovery grant before the unlock time\\n        6: Too early to recover\\n        7: Too early to claim\\n        8: Recover timestamp needs to be after receive timestamp\\n        9: Already granted\\n        10: Cannot grant after unlock\\n        11: Token not approved or not enough\\n        12: Invalid ownership\\n    */\\n\\n    // Timestamp for when the recovery begins\\n    uint256 private immutable timeRecoverGrant;\\n    // Timestamp for when the receive begins\\n    uint256 private immutable timeReceiveGrant;\\n    // Owner that can recover grant and add new grant addresses\\n    address private immutable owner;\\n    // Token to lock\\n    IERC20 private immutable token;\\n\\n    // Mapping of address to grant\\n    mapping(address => uint256) private grants;\\n\\n    // Emitted when a claim is recovered\\n    event Recovered(address recipient, uint256 amount);\\n\\n    // Emitted when a claim is claimed\\n    event Claimed(address actor, uint256 amount);\\n\\n    // Emitted when a grant is added\\n    event GrantsAdded(address actor, address[] newRecipients);\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"3\\\");\\n        _;\\n    }\\n\\n    /**\\n        Sets up grant created by TimelockCreator Contract\\n     */\\n    constructor(\\n        address _owner,\\n        IERC20 _token,\\n        uint256 unlockTimestamp,\\n        uint256 recoverTimestamp\\n    ) {\\n        token = _token;\\n        owner = _owner;\\n        require(\\n            unlockTimestamp > block.timestamp &&\\n                recoverTimestamp > block.timestamp,\\n            \\\"1\\\"\\n        );\\n        require(recoverTimestamp > unlockTimestamp, \\\"8\\\");\\n        timeReceiveGrant = unlockTimestamp;\\n        timeRecoverGrant = recoverTimestamp;\\n    }\\n\\n    /**\\n        Returns token for timelock and amount per recipient\\n     */\\n    function getToken() public view returns (IERC20) {\\n        return token;\\n    }\\n\\n    function getOwner() public view returns (address) {\\n        return owner;\\n    }\\n\\n    /** \\n        Returns the time users can recieve the grant / when the timelock expires\\n     */\\n    function getTimeUnlock() public view returns (uint256) {\\n        return timeReceiveGrant;\\n    }\\n\\n    /** \\n        Returns the admin can recover unclaimed grants\\n     */\\n    function getTimeRecover() public view returns (uint256) {\\n        return timeRecoverGrant;\\n    }\\n\\n    /**\\n        Proxied token information for bookkeeping / discoverability\\n        Not implemented:\\n            1. approvals\\n            2. transfers\\n            etc.\\n    */\\n    function balanceOf(address user) public view returns (uint256) {\\n        return grants[user];\\n    }\\n\\n    function totalSupply() public view returns (uint256) {\\n        return token.balanceOf(address(this));\\n    }\\n\\n    function decimals() public view returns (uint8) {\\n        return IERC20Metadata(address(token)).decimals();\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"Timelocked \\\",\\n                    IERC20Metadata(address(token)).name()\\n                )\\n            );\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"LOCK_\\\",\\n                    IERC20Metadata(address(token)).symbol()\\n                )\\n            );\\n    }\\n\\n    /** \\n        @dev Adds a grant to the timelock\\n        Grants can be added at any time before claim period.\\n    */\\n    function addGrants(address[] memory newRecipients, uint256 grantSize)\\n        external\\n        onlyOwner\\n    {\\n        require(grantSize > 0, \\\"2\\\");\\n        require(getTimeUnlock() > block.timestamp, \\\"10\\\");\\n        require(\\n            token.allowance(msg.sender, address(this)) >=\\n                newRecipients.length * grantSize,\\n            \\\"11\\\"\\n        );\\n\\n        uint256 numberRecipients = newRecipients.length;\\n        token.transferFrom(\\n            msg.sender,\\n            address(this),\\n            grantSize * numberRecipients\\n        );\\n        for (uint256 i = 0; i < numberRecipients; i++) {\\n            emit Transfer(address(0), newRecipients[i], grantSize);\\n            grants[newRecipients[i]] += grantSize;\\n        }\\n        emit GrantsAdded(owner, newRecipients);\\n    }\\n\\n    /** \\n        Returns the status of the grant.\\n     */\\n    function grantedAmount(address recipient) external view returns (uint256) {\\n        return grants[recipient];\\n    }\\n\\n    /**\\n        Allows a user to claim their grant. Claimee has to be msg.sender.\\n     */\\n    function claim() external {\\n        address recipient = msg.sender;\\n        require(block.timestamp >= timeReceiveGrant, \\\"7\\\");\\n        uint256 grantAmount = grants[recipient];\\n        require(grantAmount > 0, \\\"2\\\");\\n        token.transfer(recipient, grantAmount);\\n        grants[recipient] = 0;\\n        // Emit grant claimed event\\n        emit Claimed(recipient, grantAmount);\\n        // Burn tracker token\\n        emit Transfer(recipient, address(0x0), grantAmount);\\n    }\\n\\n    /**\\n        The owner of the grant can recover after the recovery timestamp passes.\\n        This sweeps remaining funds and destroys the contract data.\\n     */\\n    function recover() external onlyOwner {\\n        address payable sender = payable(msg.sender);\\n        require(block.timestamp >= timeRecoverGrant, \\\"6\\\");\\n        uint256 balance = token.balanceOf(address(this));\\n        emit Recovered(sender, balance);\\n        token.transfer(sender, balance);\\n        selfdestruct(sender);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unlockTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recoverTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"actor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"actor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"newRecipients\",\"type\":\"address[]\"}],\"name\":\"GrantsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"newRecipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"grantSize\",\"type\":\"uint256\"}],\"name\":\"addGrants\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimeRecover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimeUnlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"grantedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Timelock","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"40","ConstructorArguments":"00000000000000000000000087ee1158bee297c381745284dcb2e54fa03eb5f200000000000000000000000047e1b433ca6f3f87302face00484bae025b6b31c0000000000000000000000000000000000000000000000000000000061c6a550000000000000000000000000000000000000000000000000000000006292efc0","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}