{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {codehash := extcodehash(account)}\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success,) = recipient.call{value : amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value : weiValue}(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {// Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// MasterChef is the master of Good. He can make Good and he is a fair guy.\r\n//\r\n// Note that it's ownable and the owner wields tremendous power. The ownership\r\n// will be transferred to a governance smart contract once Good is sufficiently\r\n// distributed and the community can show to govern itself.\r\n//\r\n// Have fun reading it. Hopefully it's bug-free. God bless.\r\ncontract zenrpoolv2 {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n\r\n    // Info of each user.\r\n    // struct UserInfo {\r\n    //     uint256 amount; // How many LP tokens the user has provided. 只要小于总的就行的\r\n    //     uint256 rewardDebt; // Reward debt. See explanation below.\r\n    //     uint256 tokenFees;\r\n    //     uint256 haddraw;\r\n    // }\r\n    // Info of each pool.\r\n    // struct PoolInfo {\r\n    //     IERC20 lpToken; // Address of LP token contract.\r\n    //     //uint256 allocPoint; // How many allocation points assigned to this pool. Goods to distribute per block.\r\n    //     uint256 lastRewardBlock; // Last block number that Goods distribution occurs.\r\n    //     uint256 accGoodPerShare; // Accumulated Goods per share, times 1e12. See below.\r\n    //     uint256 poolgoodPerBlock;\r\n    //     uint256 totalpool;\r\n    // }\r\n    // The Good TOKEN!\r\n    IERC20 public good;\r\n    //uint256 public goodPerBlock;\r\n    //PoolInfo[] public poolInfo;\r\n    //mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n    //mapping(address => bool) public lpmap;\r\n    //uint256 public startBlock;\r\n    address public owner;\r\n   address public handleusdt;\r\n    IERC20 public usdt;\r\n    bool public paused = false;\r\n    //IERC20 public good;\r\n    mapping (address => bool) public minters;\r\n\r\n  function addMinter(address _minter) public {\r\n      require(msg.sender == owner, \"!governance\");\r\n      minters[_minter] = true;\r\n  }\r\n  \r\n  function removeMinter(address _minter) public {\r\n      require(msg.sender == owner, \"!governance\");\r\n      minters[_minter] = false;\r\n  }\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event SetPause( bool paused);\r\n    uint256 public usdtuint = 1e18;\r\n    constructor(\r\n        IERC20 _good,\r\n        IERC20 _usdt,\r\n        address _handleusdt\r\n        //uint256 _goodPerBlock,\r\n       // uint256 _startBlock\r\n    ) public {\r\n        good = _good;\r\n        usdt = _usdt;\r\n        handleusdt = _handleusdt;\r\n        //goodPerBlock = _goodPerBlock;\r\n        //startBlock = _startBlock;\r\n\r\n        //good = _good;\r\n        owner = msg.sender; \r\n\r\n        IdoData[1].issuenumber =1;\r\n        IdoData[1].userlimit = 10*usdtuint;\r\n        IdoData[1].totalzenr = 10000000000*1e18;\r\n        IdoData[1].ratio = 4581901489117900000000; //1/0.00021825USDT\r\n        IdoData[1].starttime = 1634745600; //10.21\r\n        //IdoData[1].starttime = 0; //10.21\r\n        IdoData[1].endtime = 1635436800; //10.28 24：00：00\r\n\r\n        IdoData[2].issuenumber =2;\r\n        IdoData[2].userlimit = 20*usdtuint;\r\n        IdoData[2].totalzenr = 20000000000*1e18;\r\n        IdoData[2].ratio = 4287245444801700000000; //1/0.00023325USDT\r\n        IdoData[2].starttime = 1635436800; //10.29\r\n        //IdoData[2].starttime = 0; //10.29\r\n        IdoData[2].endtime = 1636128000; //11.5 24：00：00\r\n\r\n        IdoData[3].issuenumber =3;\r\n        IdoData[3].userlimit = 200*usdtuint;\r\n        IdoData[3].totalzenr = 20000000000*1e18;\r\n        IdoData[3].ratio = 4166666666666600000000; //1/0.00024USDT\r\n        IdoData[3].starttime = 1636128000; //11.6\r\n        //IdoData[3].starttime = 0;\r\n        IdoData[3].endtime = 1636819200; //11.13 24：00：00\r\n\r\n        boxData[1].totalnum = 1000000;\r\n        boxData[2].totalnum = 330000;\r\n        boxData[3].totalnum = 100000;\r\n    }\r\n\r\n    function setPause() public onlyOwner {\r\n        paused = !paused;\r\n        emit SetPause(paused);\r\n\r\n    }\r\n    modifier notPause() {\r\n        require(paused == false, \"Mining has been suspended\");\r\n        _;\r\n    }\r\n\r\n\r\n    modifier onlyOwner {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n        struct User {\r\n            uint256 usdtnum;\r\n            uint256 hadwithdraw;\r\n            bool isout;\r\n        }\r\n\r\n        struct IdoInfo {  \r\n            uint256 issuenumber;\r\n            uint256 userlimit;\r\n            uint256 totalzenr;\r\n            uint256 totalusdt;\r\n            uint256 ratio;\r\n            uint256 starttime;\r\n            uint256 endtime;\r\n            uint256 swapoutzenr;\r\n            //mapping(address => User )  users;\r\n    }\r\n\r\n\r\n\r\n\r\n  function setidoInfo(uint256 issuenumber, uint256 userlimit, uint256 totalzenr, uint256 ratio, \r\n      uint256 starttime,  uint256 endtime) public {\r\n      require(msg.sender == owner ||  minters[msg.sender], \"!governance\");\r\n      IdoData[issuenumber].userlimit = userlimit;\r\n      IdoData[issuenumber].ratio = ratio;\r\n      IdoData[issuenumber].totalzenr = totalzenr;\r\n      IdoData[issuenumber].starttime = starttime;\r\n      IdoData[issuenumber].endtime = endtime;\r\n  }\r\n\r\n  function setBoxdata(uint256 issuenumber, uint256 _allnum) public {\r\n      require(msg.sender == owner ||  minters[msg.sender], \"!governance\");\r\n      boxData[issuenumber].totalnum = _allnum;\r\n  }\r\n    uint256 public currentido = 1;\r\n    mapping(uint256 => IdoInfo) public IdoData;\r\n\r\n  function setCurrentido(uint256 num) public {\r\n      require(msg.sender == owner ||  minters[msg.sender], \"!governance\");\r\n      currentido = num;\r\n  }\r\n\r\n    mapping(address=>address) public userUpline;\r\n    event BuyIdo(address user,uint256 race, uint256 usdtnum,uint256 zenrnum);\r\n    event BuyIdoUpline(address user,address up1, uint256 onenum, address up2, uint256 twonum);\r\n\r\n\r\n    struct idouint {\r\n        uint256 amount;\r\n        uint256 starttime;\r\n        //uint256 hadout;\r\n    }\r\n\r\n    struct UserIdo {\r\n        bool status;\r\n        uint256 rewards;\r\n        uint256 hisrewards;\r\n        uint256 idolen;\r\n\r\n        mapping (uint256=>idouint) idouints;\r\n    }\r\n\r\nfunction getidouints(address user, uint256 num) public view  returns (uint256, uint256) {\r\n    return(useridos[user].idouints[num].amount, useridos[user].idouints[num].starttime );\r\n}\r\n\r\n  mapping (address => UserIdo) public useridos;\r\n\r\n    function buyIdo(uint256 num, uint256 amount, address referrer) public {\r\n        IdoInfo storage idoInfo = IdoData[num];\r\n        require(block.timestamp >= idoInfo.starttime, \"not start\");\r\n        require(block.timestamp <= idoInfo.endtime, \"had end time\");\r\n\r\n        require(amount >= idoInfo.userlimit, \"lt user limite\");\r\n\r\n        uint256 needswap = amount.mul(idoInfo.ratio).div(usdtuint);\r\n        idoInfo.swapoutzenr = idoInfo.swapoutzenr.add(needswap);\r\n        idoInfo.totalusdt = idoInfo.totalusdt.add(amount);\r\n\r\n        require(idoInfo.swapoutzenr <= idoInfo.totalzenr, \"out totalzenr\");\r\n        UserIdo storage userido = useridos[msg.sender];\r\n        userido.status = true;\r\n\r\n        userido.rewards = userido.rewards.add(needswap);\r\n        uint256 len=userido.idolen;\r\n        uint256 outnow = needswap.mul(25).div(100);\r\n        userido.idouints[len].amount = needswap;\r\n        userido.idouints[len].starttime = block.timestamp;\r\n        userido.idolen = len+1;\r\n        //userido.idouints[len].hadout = userido.idouints[len].hadout.add(outnow);\r\n        userido.hisrewards =userido.hisrewards.add(outnow);\r\n\r\n        //idoInfo.users[msg.sender].usdtnum = idoInfo.users[msg.sender].usdtnum .add(amount);\r\n        //idoInfo.users[msg.sender].hadwithdraw = idoInfo.users[msg.sender].hadwithdraw.add(needswap);\r\n\r\n        usdt.transferFrom(msg.sender, handleusdt, amount);\r\n        good.transfer(msg.sender, outnow);\r\n\r\n        if (userUpline[msg.sender] == address(0) && referrer != msg.sender &&referrer != address(0)) {\r\n            userUpline[msg.sender] = referrer;\r\n        }\r\n        uint256 onenum;\r\n        uint256 twonum;\r\n        address up = userUpline[msg.sender];\r\n        address up2 ;\r\n    \r\n        if (up!= address(0)) {\r\n            up2 = userUpline[up];\r\n            if (needswap>0) {\r\n                onenum = needswap.mul(10).div(100);\r\n                boxuser[up].reward=boxuser[up].reward.add(onenum);\r\n                boxuser[up].referreward = boxuser[up].referreward.add(onenum);\r\n                if (up2!= address(0)) {\r\n                    twonum =  needswap.mul(5).div(100);\r\n                    boxuser[up2].reward=boxuser[up2].reward.add(twonum);\r\n                    boxuser[up2].referreward = boxuser[up2].referreward.add(twonum);\r\n                }\r\n            emit BuyIdoUpline(msg.sender, up,onenum, up2, twonum);\r\n            }\r\n        }        \r\n\r\n\r\n        emit BuyIdo(msg.sender,num, amount,outnow );\r\n    }\r\n\r\nuint256 days30 = 30 days;\r\nfunction canWithdrawableZenr(address user) public view returns (uint256 amount) {\r\n    UserIdo storage investor = useridos[user];\r\n    if (!investor.status) {\r\n            return 0;\r\n    }\r\n    uint256 canfraw;\r\n    uint256  nownow = block.timestamp;\r\n    for (uint i = 0; i < investor.idolen; i++) {\r\n\r\n      idouint storage dep = investor.idouints[i];\r\n\r\n      //Tariff storage tariff = tariffs[dep.tariff];\r\n      \r\n      uint finish = (nownow.sub(dep.starttime)).div(days30);\r\n      //uint till = block.number > finish ? finish : block.number;\r\n      if (finish >5) {\r\n            canfraw = canfraw.add(dep.amount);\r\n      } else {\r\n            canfraw = canfraw.add(dep.amount.mul(finish.mul(15).add(25)).div(100));\r\n      }\r\n    }\r\n    return canfraw.sub(investor.hisrewards);\r\n  }\r\n\r\nevent WithdrawZenr(address  user,uint256 fre);\r\n\r\nfunction withdrawZenr() public  returns (uint256 amount) {\r\n    UserIdo storage investor = useridos[msg.sender];\r\n    if (!investor.status) {\r\n            return 0;\r\n    }\r\n    uint256 canfraw =canWithdrawableZenr(msg.sender) ;\r\n    if (canfraw > 0) {\r\n        investor.hisrewards = investor.hisrewards.add(canfraw);\r\n        good.transfer(msg.sender, canfraw);\r\n        emit WithdrawZenr(msg.sender,canfraw);\r\n        return canfraw;\r\n    }\r\n  }\r\n\r\n     struct Userbox {\r\n            uint256 buyamount;\r\n            uint256 buytime; \r\n            uint256 reward;\r\n            uint256 hadwithdrewreward; \r\n            uint256 nftlen;\r\n            uint256 boxreward;\r\n            uint256 referreward;\r\n            uint256 usdtreard;\r\n            uint256 hisusdtreard;\r\n\r\n            mapping(uint256 => uint256 ) nftids;\r\n        }\r\n\r\n        struct boxInfo {  \r\n            uint256 totalnum; \r\n            uint256 hadoutnum; \r\n            uint256 outzenr;  \r\n            //uint256 outusdt;\r\n\r\n            //mapping(address => User )  users;\r\n    }\r\n    mapping(uint256 => boxInfo) public boxData;\r\n    mapping(address => Userbox) public boxuser;\r\n\r\n    function getUserNftids(address _user) public view returns(uint256[] memory ids) {\r\n        Userbox storage userbox = boxuser[_user];\r\n        uint256[] memory b1 = new  uint256[](userbox.nftlen);\r\n        if (userbox.nftlen >0 ) {\r\n            for (uint i=0;i<userbox.nftlen;i++ ) {\r\n                b1[i] = userbox.nftids[i];\r\n            }\r\n        }\r\n        return b1;\r\n    }\r\n\r\n    function getBuyAmount(uint256 typebox) public pure returns (uint256 ) {\r\n        if (typebox == 1) {\r\n            return 10000*1e18;\r\n        } else if (typebox == 2) {\r\n            return 30000*1e18;\r\n        } else if (typebox == 3) {\r\n            return 100000*1e18;\r\n        }\r\n    }\r\n\r\n    bool public isusdt = true;\r\n\r\n  function setIsusdt(bool value) public {\r\n      require(msg.sender == owner ||  minters[msg.sender], \"!governance\");\r\n      isusdt = value;\r\n  }\r\n  function setusdtuint(uint256 value) public {\r\n      require(msg.sender == owner ||  minters[msg.sender], \"!governance\");\r\n      usdtuint = value;\r\n  }\r\n\r\n    function sethandlusdt(address _handle) public {\r\n      require(msg.sender == owner ||  minters[msg.sender], \"!governance\");\r\n      handleusdt = _handle;\r\n  }\r\n\r\n    function caucau(uint256 typebox) internal returns(uint256 nftid, uint256 nowre,  uint256 nowusdt ) {\r\n        uint256 rand= randomnum(100)+1;\r\n        nftid=0;\r\n        nowre=0;\r\n        nowusdt=0;\r\n        if (!isusdt) {\r\n            if (typebox ==1) {\r\n                if (rand<=68) {\r\n                    nowre = 7000*1e18;\r\n                } else if (rand<=89&& rand>=69){\r\n                    nowre = 10000*1e18;\r\n                } else if (rand<=100&& rand>=90){\r\n                    nowre = 12000*1e18;\r\n                } \r\n            } else if (typebox ==2) {\r\n                if (rand<=68) {\r\n                    nowre = 20000*1e18;\r\n                } else if (rand<=84&& rand>=69){\r\n                    nowre = 30000*1e18;\r\n                } else if (rand<=94&& rand>=85) {\r\n                    nowre = 36000*1e18;\r\n                } else if (rand<=100&& rand>=95) {\r\n                    nftid = randomnum(100000)+1;\r\n                }\r\n\r\n            } else if (typebox ==3) {\r\n            if (rand<=68) {\r\n                    nowre = 70000*1e18;\r\n                } else if (rand<=84&& rand>=69){\r\n                    nowre = 100000*1e18;\r\n                } else if (rand<=94&& rand>=85) {\r\n                    nowre = 120000*1e18;\r\n                } else if (rand<=100&& rand>=95) {\r\n                    nftid = randomnum(100000)+1;\r\n                } \r\n            }\r\n        } else {\r\n            if (typebox ==1) {\r\n                if (rand<=65) {\r\n                    nowre = 7000*1e18;\r\n                } else if (rand<=85&& rand>=66){\r\n                    nowre = 10000*1e18;\r\n                } else if (rand<=95&& rand>=86){\r\n                    nowre = 12000*1e18;\r\n                } else {\r\n                    nowusdt = 5*usdtuint;\r\n                }\r\n            } else if (typebox ==2) {\r\n                if (rand<=65) {\r\n                    nowre = 20000*1e18;\r\n                } else if (rand<=80&& rand>=66){\r\n                    nowre = 30000*1e18;\r\n                } else if (rand<=90&& rand>=81) {\r\n                    nowre = 36000*1e18;\r\n                } else if (rand<=95&& rand>=91) {\r\n                    nftid = randomnum(100000)+1;\r\n                } else  {\r\n                    nowusdt = 20*usdtuint;\r\n                } \r\n\r\n            } else if (typebox ==3) {\r\n            if (rand<=65) {\r\n                    nowre = 70000*1e18;\r\n                } else if (rand<=80&& rand>=66){\r\n                    nowre = 100000*1e18;\r\n                } else if (rand<=90&& rand>=81) {\r\n                    nowre = 120000*1e18;\r\n                } else if (rand<=95&& rand>=91) {\r\n                    nftid = randomnum(100000)+1;\r\n                } else  {\r\n                    nowusdt = 50*usdtuint;\r\n                } \r\n            }\r\n        }\r\n\r\n    }\r\n    event BuyBox(address user,uint256 typebox, uint256 reward,uint256 nftid, uint256 usdtre);\r\n    event BuyBoxUpline(address user,address up1, uint256 onenum, address up2, uint256 twonum);\r\n    function buyBox(uint256 typebox, uint256 _amount, address referrer) public returns(uint256 , uint256,uint256 )  {\r\n        uint256 amount= getBuyAmount(typebox);\r\n        require(amount == _amount, \"_amount not right\");\r\n        boxInfo storage boxinfo =boxData[typebox];\r\n        require(boxinfo.hadoutnum <=boxinfo.totalnum , \"out box totalnum\");\r\n        good.transferFrom(msg.sender, address(this), amount);\r\n        boxinfo.hadoutnum=boxinfo.hadoutnum+1;\r\n        boxuser[msg.sender].buyamount=boxuser[msg.sender].buyamount.add(_amount);\r\n        boxuser[msg.sender].buytime +=1;\r\n\r\n       // uint256 rand= randomnum(100)+1;\r\n        uint256 nftid=0;\r\n        uint256 nowre=0;\r\n        uint256 nowusdt=0;\r\n       (nftid,nowre,nowusdt )= caucau(typebox);\r\n        if (nowre >0) {\r\n            //good.transfer(msg.sender, nowre);\r\n            boxuser[msg.sender].reward=boxuser[msg.sender].reward.add(nowre);\r\n            boxuser[msg.sender].boxreward =  boxuser[msg.sender].boxreward.add(nowre);\r\n            boxinfo.outzenr = boxinfo.outzenr.add(nowre);\r\n        }\r\n        if (nftid>0) {\r\n            boxuser[msg.sender].nftids[boxuser[msg.sender].nftlen] = nftid;\r\n            boxuser[msg.sender].nftlen +=1;\r\n        }\r\n        if (nowusdt>0) {\r\n            boxuser[msg.sender].usdtreard = boxuser[msg.sender].usdtreard.add(nowusdt);\r\n            //boxinfo.outusdt =  boxinfo.outusdt.add(nowusdt);\r\n        }\r\n\r\n        updateupline(referrer, amount);\r\n\r\n        emit BuyBox(msg.sender,typebox,nowre,  nftid, nowusdt);\r\n        return(nowre, nftid, nowusdt);\r\n    }\r\n\r\n    function updateupline( address referrer, uint256 nowre) internal\r\n    {\r\n        if (userUpline[msg.sender] == address(0) && referrer != msg.sender &&referrer != address(0)) {\r\n            userUpline[msg.sender] = referrer;\r\n        }\r\n\r\n        uint256 onenum;\r\n        uint256 twonum;\r\n        address up = userUpline[msg.sender];\r\n        address up2 ;\r\n    \r\n        if (up!= address(0)) {\r\n            up2 = userUpline[up];\r\n            if (nowre>0) {\r\n                onenum = nowre.mul(10).div(100);\r\n                boxuser[up].reward=boxuser[up].reward.add(onenum);\r\n                boxuser[up].referreward = boxuser[up].referreward.add(onenum);\r\n                if (up2!= address(0)) {\r\n                    twonum =  nowre.mul(5).div(100);\r\n                    boxuser[up2].reward=boxuser[up2].reward.add(twonum);\r\n                    boxuser[up2].referreward = boxuser[up2].referreward.add(twonum);\r\n\r\n                }\r\n            emit BuyBoxUpline(msg.sender, up,onenum, up2, twonum);\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n    event BoxWithdrew(address user, uint256 reward);\r\n\r\n    function boxwithdrew(uint256 amount ) public {\r\n        Userbox storage _user =boxuser[msg.sender] ;\r\n        require(_user.reward >= amount, \"reward not right\");\r\n        good.transfer(msg.sender, amount);\r\n        _user.reward = _user.reward.sub(amount);\r\n        _user.hadwithdrewreward = _user.hadwithdrewreward.add(amount);\r\n        emit BoxWithdrew(msg.sender, amount);\r\n    }\r\n    event BoxWithdrewUsdt(address user, uint256 reward);\r\n\r\n    function boxwithdrewUsdt(uint256 amount ) public {\r\n        Userbox storage _user =boxuser[msg.sender] ;\r\n        require(_user.usdtreard >= amount, \"usdtreard not right\");\r\n        _user.usdtreard = _user.usdtreard.sub(amount);\r\n        usdt.transfer(msg.sender, amount);\r\n        _user.hisusdtreard = _user.hisusdtreard.add(amount);\r\n        emit BoxWithdrewUsdt(msg.sender, amount);\r\n    }\r\n\r\n    uint public randNonce = 0;\r\n    function randomnum(uint256 max)  internal returns(uint) {\r\n         uint random = uint(keccak256(abi.encodePacked(randNonce, msg.sender, block.difficulty, block.timestamp))) % max;\r\n        randNonce++;\r\n        return random;\r\n    }\r\n\r\n  function getRewardtokens(address _token0,address user,uint256 amount) public {\r\n    //  require(msg.sender == governance|| , \"!governance\");\r\n     require(minters[msg.sender], \"!minter\");\r\n     IERC20(_token0).transfer(user, amount);\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_good\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_handleusdt\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"BoxWithdrew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"BoxWithdrewUsdt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"typebox\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdtre\",\"type\":\"uint256\"}],\"name\":\"BuyBox\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"up1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"onenum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"up2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"twonum\",\"type\":\"uint256\"}],\"name\":\"BuyBoxUpline\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"race\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdtnum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"zenrnum\",\"type\":\"uint256\"}],\"name\":\"BuyIdo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"up1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"onenum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"up2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"twonum\",\"type\":\"uint256\"}],\"name\":\"BuyIdoUpline\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"SetPause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fre\",\"type\":\"uint256\"}],\"name\":\"WithdrawZenr\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"IdoData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"issuenumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userlimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalzenr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalusdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endtime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapoutzenr\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"boxData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalnum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hadoutnum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outzenr\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boxuser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"buyamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buytime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hadwithdrewreward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftlen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boxreward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referreward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdtreard\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hisusdtreard\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"boxwithdrew\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"boxwithdrewUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typebox\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"buyBox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"buyIdo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"canWithdrawableZenr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentido\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typebox\",\"type\":\"uint256\"}],\"name\":\"getBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getRewardtokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserNftids\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"getidouints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"good\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"handleusdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isusdt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"issuenumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allnum\",\"type\":\"uint256\"}],\"name\":\"setBoxdata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setCurrentido\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setIsusdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_handle\",\"type\":\"address\"}],\"name\":\"sethandlusdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"issuenumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userlimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalzenr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"starttime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endtime\",\"type\":\"uint256\"}],\"name\":\"setidoInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setusdtuint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtuint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userUpline\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"useridos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hisrewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"idolen\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawZenr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"zenrpoolv2","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002a49dfb9da871c3dd599660c1e1cd493a5acb97f000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000cadbcba43cdd456144b4c4bf1f587e8116660ea0","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f3b2a5400dd58f3fee6457c5e713b9c55f2bf9e770a0fc2f06722c5dbb4dd916"}]}