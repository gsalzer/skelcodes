{"status":"1","message":"OK","result":[{"SourceCode":"{\"erc721-token-receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-721 interface for accepting safe transfers.\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\n */\\ninterface ERC721TokenReceiver\\n{\\n\\n  /**\\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\\n   * of other than the magic value MUST result in the transaction being reverted.\\n   * Returns `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))` unless throwing.\\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\\n   * MUST implement the wallet interface if it will accept safe transfers.\\n   * @param _operator The address which called `safeTransferFrom` function.\\n   * @param _from The address which previously owned the token.\\n   * @param _tokenId The NFT identifier which is being transferred.\\n   * @param _data Additional data with no specified format.\\n   * @return Returns `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n   */\\n  function onERC721Received(\\n    address _operator,\\n    address _from,\\n    uint256 _tokenId,\\n    bytes calldata _data\\n  )\\n    external\\n    returns(bytes4);\\n\\n}\\n\"},\"mnm-nftoken.sol\":{\"content\":\"//SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.4;\\n\\nimport \\\"./erc721-token-receiver.sol\\\";\\n\\ncontract MNMNFToken\\n{\\n  mapping (uint256 =\\u003e bytes32) internal _id_to_token_name;\\n  mapping (uint256 =\\u003e uint256) internal _id_to_index;\\n  mapping (uint256 =\\u003e uint256) internal _id_to_owner_index;\\n  mapping (uint256 =\\u003e address) internal _id_to_owner;\\n  mapping (uint256 =\\u003e address) internal _id_to_approval;\\n  mapping (uint256 =\\u003e uint256) internal _id_to_value;\\n  mapping (address =\\u003e uint256[]) internal _owner_to_ids;\\n  mapping (address =\\u003e uint256) internal _owner_to_nftoken_count;\\n  mapping (address =\\u003e mapping (address =\\u003e bool)) internal _owner_to_operators;\\n\\n  uint256[] internal _tokens;\\n  uint256 internal _next_token_id = 1;\\n\\n  mapping (bytes32 =\\u003e address) internal _token_name_to_token_contract;\\n  mapping (bytes32 =\\u003e address) internal _token_name_to_nft_factory;\\n\\n  uint256 public customPrice;\\n\\n  address internal _owner;\\n  string public constant name = \\\"MNM NFT\\\";\\n  string public constant symbol = \\\"MNMN\\\";\\n  uint256 public constant decimals = 0;\\n\\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\\n\\n  event Transfer(address indexed from, address indexed to, uint256 indexed token_id);\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  constructor()\\n  {\\n    _owner = msg.sender;\\n    customPrice = 1e17;\\n  }\\n\\n  receive() external payable {}\\n  fallback() external payable {}\\n\\n  function supportsInterface(bytes4 id)\\n    external pure returns(bool)\\n  {\\n    return (\\n         id == 0x5b5e139f // ERC721Metadata\\n      || id == 0x780e9d63 // ERC721Enumerable\\n      || id == 0x80ac58cd // ERC721\\n    );\\n  }\\n\\n  function setCustomPrice(uint256 price)\\n    external\\n  {\\n    _only_owner();\\n    customPrice = price;\\n  }\\n\\n  function setContractOwner(address new_owner)\\n    external\\n  {\\n    _only_owner();\\n    _owner = new_owner;\\n  }\\n\\n  function withdrawEth()\\n    external\\n  {\\n    _only_owner();\\n    (bool success,) = msg.sender.call{value:address(this).balance}(\\\"\\\");\\n    require(success, \\u0027transfer failed\\u0027);\\n  }\\n\\n  function setTokenContractAddress(bytes32 token_name, address token_contract)\\n    external\\n  {\\n    _only_owner();\\n    _token_name_to_token_contract[token_name] = token_contract;\\n  }\\n\\n  function setImageContractAddress(bytes32 token_name, address image_contract)\\n    external\\n  {\\n    _only_owner();\\n    _token_name_to_nft_factory[token_name] = image_contract;\\n  }\\n\\n  function safeTransferFrom(address from, address to, uint256 token_id, bytes calldata data)\\n    external\\n  {\\n    _safe_transfer_from(from, to, token_id, data);\\n  }\\n\\n  function safeTransferFrom(address from, address to, uint256 token_id)\\n    external\\n  {\\n    _safe_transfer_from(from, to, token_id, \\\"\\\");\\n  }\\n\\n  function _safe_transfer_from(address from, address to, uint256 token_id, bytes memory data)\\n    internal\\n  {\\n    _valid_nftoken(token_id);\\n    _can_transfer(token_id);\\n    address token_owner = _id_to_owner[token_id];\\n    require(token_owner == from, \\u0027nft is not owned by from address\\u0027);\\n    require(to != address(0), \\u0027cannot transfer nft to address 0\\u0027);\\n\\n    _transfer(to, token_id);\\n\\n    if (_is_contract(to))\\n    {\\n      bytes4 retval = ERC721TokenReceiver(to).onERC721Received(msg.sender, from, token_id, data);\\n      require(retval == MAGIC_ON_ERC721_RECEIVED, \\u0027failed to transfer to token receiver\\u0027);\\n    }\\n  }\\n\\n  function transferFrom(address from, address to, uint256 token_id)\\n    external\\n  {\\n    _valid_nftoken(token_id);\\n    _can_transfer(token_id);\\n    address token_owner = _id_to_owner[token_id];\\n    require(token_owner == from, \\u0027nft is not owned by from address\\u0027);\\n    require(to != address(0), \\u0027cannot transfer nft to address 0\\u0027);\\n\\n    _transfer(to, token_id);\\n  }\\n\\n  function _transfer(address to, uint256 token_id)\\n    internal\\n  {\\n    address from = _id_to_owner[token_id];\\n\\n    _remove_nftoken(from, token_id);\\n    _add_nftoken(to, token_id);\\n\\n    emit Transfer(from, to, token_id);\\n  }\\n\\n  function tokenURI(uint256 token_id)\\n    external view returns (string memory)\\n  {\\n    _valid_nftoken(token_id);\\n    address img_contract = _token_name_to_nft_factory[_id_to_token_name[token_id]];\\n    return NFTFactory(img_contract).tokenURI(token_id);\\n  }\\n\\n  function tokenByIndex(uint256 index)\\n    external view returns(uint256)\\n  {\\n    require(index \\u003c _tokens.length, \\u0027invalid nft index\\u0027);\\n    return _tokens[index];\\n  }\\n\\n  function tokenOfOwnerByIndex(address owner, uint256 index)\\n    external view returns(uint256)\\n  {\\n    require(index \\u003c _owner_to_ids[owner].length, \\u0027invalid nft index\\u0027);\\n    return _owner_to_ids[owner][index];\\n  }\\n\\n  function totalSupply()\\n    external view returns(uint256)\\n  {\\n    return _tokens.length;\\n  }\\n\\n  function balanceOf(address owner)\\n    external view returns(uint256)\\n  {\\n    require(owner != address(0), \\u0027address 0 is not an owner\\u0027);\\n    return _owner_to_ids[owner].length;\\n  }\\n\\n  function ownerOf(uint256 token_id)\\n    external view returns(address)\\n  {\\n    _valid_nftoken(token_id);\\n    return _id_to_owner[token_id];\\n  }\\n\\n  function getApproved(uint256 token_id)\\n    external view returns(address)\\n  {\\n    _valid_nftoken(token_id);\\n    return _id_to_approval[token_id];\\n  }\\n\\n  function isApprovedForAll(address owner, address operator)\\n    external view returns(bool)\\n  {\\n    return _owner_to_operators[owner][operator];\\n  }\\n\\n  function getIncludedTokenType(uint256 token_id)\\n    external view returns(bytes32)\\n  {\\n    _valid_nftoken(token_id);\\n    return _id_to_token_name[token_id];\\n  }\\n\\n  function getIncludedTokenAmount(uint256 token_id)\\n    external view returns(uint256)\\n  {\\n    _valid_nftoken(token_id);\\n    return _id_to_value[token_id];\\n  }\\n\\n  function mintNFTCustom(uint256 num_whole_tokens, bytes32 token_data, bytes32 token_name)\\n    external payable\\n  {\\n    require(msg.value \\u003e= customPrice, \\u0027not enough eth sent\\u0027);\\n    _mint_nft_custom(num_whole_tokens, token_data, token_name);\\n  }\\n\\n  function mintNFTCustomBatch(uint256[] calldata num_whole_tokens, bytes32[] calldata token_data, bytes32 token_name)\\n    external payable\\n  {\\n    require(msg.value \\u003e= customPrice * token_data.length, \\u0027not enough eth sent\\u0027);\\n    require(num_whole_tokens.length == token_data.length, \\u0027array lengths must match\\u0027);\\n    uint256 i;\\n    for (i=0; i\\u003ctoken_data.length; i++) {\\n      _mint_nft_custom(num_whole_tokens[i], token_data[i], token_name);\\n    }\\n  }\\n\\n  function _mint_nft_custom(uint256 num_whole_tokens, bytes32 token_data, bytes32 token_name)\\n    internal\\n  {\\n    require(num_whole_tokens \\u003e= 9, \\u0027not enough tokens sent\\u0027);\\n\\n    uint256 token_id = _next_token_id;\\n    _next_token_id += 1;\\n    require(_id_to_owner[token_id] == address(0), \\u0027nft already exists\\u0027);\\n\\n    address token_contract = _token_name_to_token_contract[token_name];\\n    require(token_contract != address(0), \\u0027no token contract associated with this token name\\u0027);\\n\\n    address image_contract = _token_name_to_nft_factory[token_name];\\n    require(image_contract != address(0), \\u0027no nft factory associated with this token name\\u0027);\\n\\n    address token_owner = msg.sender;\\n\\n    MNMTokenA(token_contract).withdrawWhole(token_owner, num_whole_tokens);\\n    NFTFactory(image_contract).mintNFTCustom(token_id, token_data);\\n\\n    _add_nftoken(token_owner, token_id);\\n\\n    _tokens.push(token_id);\\n    _id_to_index[token_id] = _tokens.length - 1;\\n\\n    _id_to_token_name[token_id] = token_name;\\n\\n    emit Transfer(address(0), token_owner, token_id);\\n  }\\n\\n  function mintNFT(uint256 num_whole_tokens, bytes32 token_name)\\n    external\\n  {\\n    _mint_nft(num_whole_tokens, token_name);\\n  }\\n\\n  function mintNFTBatch(uint256[] calldata num_whole_tokens, bytes32 token_name)\\n    external\\n  {\\n    uint256 i;\\n    for (i=0; i\\u003cnum_whole_tokens.length; i++) {\\n      _mint_nft(num_whole_tokens[i], token_name);\\n    }\\n  }\\n\\n  function _mint_nft(uint256 num_whole_tokens, bytes32 token_name)\\n    internal\\n  {\\n    require(num_whole_tokens \\u003e 0, \\u0027must send at least 1 token\\u0027);\\n\\n    uint256 token_id = _next_token_id;\\n    _next_token_id += 1;\\n\\n    address token_contract = _token_name_to_token_contract[token_name];\\n    require(token_contract != address(0), \\u0027no token contract associated with this token name\\u0027);\\n\\n    address image_contract = _token_name_to_nft_factory[token_name];\\n    require(image_contract != address(0), \\u0027no nft factory associated with this token name\\u0027);\\n\\n    require(_id_to_owner[token_id] == address(0), \\u0027nft already exists\\u0027);\\n\\n    address token_owner = msg.sender;\\n\\n    MNMTokenA(token_contract).withdrawWhole(token_owner, num_whole_tokens);\\n    NFTFactory(image_contract).mintNFT(token_id, num_whole_tokens, uint256(uint160(token_owner)));\\n\\n    _add_nftoken(token_owner, token_id);\\n\\n    _tokens.push(token_id);\\n    _id_to_index[token_id] = _tokens.length - 1;\\n\\n    _id_to_value[token_id] = num_whole_tokens;\\n\\n    _id_to_token_name[token_id] = token_name;\\n\\n    emit Transfer(address(0), token_owner, token_id);\\n  }\\n\\n  function meltNFT(uint256 token_id)\\n    external\\n  {\\n    _valid_nftoken(token_id);\\n    address token_owner = _id_to_owner[token_id];\\n    address img_contract = _token_name_to_nft_factory[_id_to_token_name[token_id]];\\n    address token_contract = _token_name_to_token_contract[_id_to_token_name[token_id]];\\n\\n    MNMTokenA(token_contract).depositWhole(msg.sender, _id_to_value[token_id]);\\n    NFTFactory(img_contract).burnNFT(token_id);\\n\\n    _remove_nftoken(token_owner, token_id);\\n\\n    uint256 token_index = _id_to_index[token_id];\\n    uint256 last_token_index = _tokens.length - 1;\\n    uint256 last_token = _tokens[last_token_index];\\n    _tokens[token_index] = last_token;\\n    _id_to_index[last_token] = token_index;\\n\\n    _tokens.pop();\\n    delete _id_to_index[token_id];\\n    delete _id_to_token_name[token_id];\\n    delete _id_to_value[token_id];\\n\\n    emit Transfer(token_owner, address(0), token_id);\\n  }\\n\\n  function approve(address approved, uint256 token_id)\\n    external\\n  {\\n    _valid_nftoken(token_id);\\n    _can_operate(token_id);\\n    address token_owner = _id_to_owner[token_id];\\n    require(approved != token_owner, \\u0027already token owner\\u0027);\\n\\n    _id_to_approval[token_id] = approved;\\n\\n    emit Approval(token_owner, approved, token_id);\\n  }\\n\\n  function setApprovalForAll(address operator, bool approved)\\n    external\\n  {\\n    _owner_to_operators[msg.sender][operator] = approved;\\n\\n    emit ApprovalForAll(msg.sender, operator, approved);\\n  }\\n\\n  function _remove_nftoken(address from, uint256 token_id)\\n    internal\\n  {\\n    require(_id_to_owner[token_id] == from, \\u0027not the owner\\u0027);\\n    delete _id_to_owner[token_id];\\n    delete _id_to_approval[token_id];\\n\\n    _owner_to_nftoken_count[from] -= 1;\\n\\n    uint256 token_to_remove_index = _id_to_owner_index[token_id];\\n    uint256 last_token_index = _owner_to_ids[from].length - 1;\\n\\n    if (last_token_index != token_to_remove_index)\\n    {\\n      uint256 last_token = _owner_to_ids[from][last_token_index];\\n      _owner_to_ids[from][token_to_remove_index] = last_token;\\n      _id_to_owner_index[last_token] = token_to_remove_index;\\n    }\\n\\n    _owner_to_ids[from].pop();\\n  }\\n\\n  function _add_nftoken(address to, uint256 token_id)\\n    internal\\n  {\\n    require(_id_to_owner[token_id] == address(0), \\u0027token is already owned\\u0027);\\n    _id_to_owner[token_id] = to;\\n\\n    _owner_to_ids[to].push(token_id);\\n    _id_to_owner_index[token_id] = _owner_to_ids[to].length - 1;\\n\\n    _owner_to_nftoken_count[to] += 1;\\n  }\\n\\n  function getTokenData(uint256 token_id)\\n    external view returns(bytes memory)\\n  {\\n    address img_contract = _token_name_to_nft_factory[_id_to_token_name[token_id]];\\n    return NFTFactory(img_contract).getTokenData(token_id);\\n  }\\n\\n  function _is_contract(address addr)\\n    internal view returns(bool)\\n  {\\n    // This method relies in extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\n    bytes32 account_hash;\\n    bytes32 code_hash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    assembly { account_hash := extcodehash(addr) } // solhint-disable-line\\n    return (account_hash != 0x0 \\u0026\\u0026 account_hash != code_hash);\\n  }\\n\\n  function _can_operate(uint256 token_id)\\n    internal view\\n  {\\n    address token_owner = _id_to_owner[token_id];\\n    require(\\n      token_owner == msg.sender || _owner_to_operators[token_owner][msg.sender],\\n      \\u0027not owner or authorized operator\\u0027\\n    );\\n  }\\n\\n  function _can_transfer(uint256 token_id)\\n    internal view\\n  {\\n    address token_owner = _id_to_owner[token_id];\\n    require(\\n      token_owner == msg.sender\\n      || _id_to_approval[token_id] == msg.sender\\n      || _owner_to_operators[token_owner][msg.sender],\\n      \\u0027not owner or authorized approver or operator\\u0027\\n    );\\n  }\\n\\n  function _valid_nftoken(uint256 token_id)\\n    internal view\\n  {\\n    require(_id_to_owner[token_id] != address(0), \\u0027not a valid nft\\u0027);\\n  }\\n\\n  function _only_owner()\\n    internal view\\n  {\\n    require(msg.sender == _owner, \\u0027not the contract owner\\u0027);\\n  }\\n}\\n\\ncontract MNMTokenA\\n{\\n  function symbol() external pure returns(string memory) {}\\n  function depositWhole(address to, uint256 num_whole_tokens) public {}\\n  function withdrawWhole(address from, uint256 num_whole_tokens) public {}\\n}\\n\\ncontract NFTFactory\\n{\\n  function getTokenData(uint256 token_id) external view returns(bytes memory) {}\\n  function tokenURI(uint256 token_id) external view returns(string memory) {}\\n  function mintNFT(uint256 token_id, uint256 entropy, uint256 entropy2) external {}\\n  function mintNFTCustom(uint256 token_id, bytes32 token_data) external {}\\n  function burnNFT(uint256 token_id) external {}\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"customPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"getIncludedTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"getIncludedTokenType\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"getTokenData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"meltNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num_whole_tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"token_name\",\"type\":\"bytes32\"}],\"name\":\"mintNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"num_whole_tokens\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32\",\"name\":\"token_name\",\"type\":\"bytes32\"}],\"name\":\"mintNFTBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num_whole_tokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"token_data\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"token_name\",\"type\":\"bytes32\"}],\"name\":\"mintNFTCustom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"num_whole_tokens\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"token_data\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"token_name\",\"type\":\"bytes32\"}],\"name\":\"mintNFTCustomBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"token_id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"setContractOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setCustomPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"token_name\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"image_contract\",\"type\":\"address\"}],\"name\":\"setImageContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"token_name\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"token_contract\",\"type\":\"address\"}],\"name\":\"setTokenContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"id\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"token_id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MNMNFToken","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://32915555160d290c927bbf97f38373ceae1120dffe1b13200f46cc17e74f91f6"}]}