{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Staking {\r\n    \r\n    using SafeMath for uint256;\r\n    ManagerRole public manager;\r\n\r\n    struct StakeHolder {\r\n        bool isClaimed;                 // Current Staking status\r\n        uint256 amount;                 // Current active stake\r\n        uint256 stakedBlock;            // Last staked block (if any)\r\n        uint256 releaseBlock;           // Last claimed block (if any)\r\n        uint256 claimedOn;              // Last time claimed\r\n        uint256 rewards;                // Rewards\r\n    }\r\n    mapping (address => StakeHolder) public StakeHolders;\r\n    \r\n    // List of stake holders\r\n    address[] private allStakeHolders;\r\n    \r\n    // Stake & Reward Token\r\n    address public stakeToken;\r\n\r\n    // To check if the staking is paused\r\n    bool public isStakingPaused;\r\n\r\n    // To check if the pool is Active\r\n    bool public isPoolActive;\r\n    \r\n    // No.of Staking Pool Tokens \r\n    uint256 public stakingPool;\r\n\r\n    // No.of Staking Pool Rewards\r\n    uint256 public stakingPoolRewards;\r\n\r\n    // Staking Duration in Days\r\n    uint256 public stakingDuration;\r\n\r\n    // Staking Opening Time for users to stake\r\n    uint256 public stakingOpenTime;\r\n\r\n    // Staking reward start block\r\n    uint256 public stakingStartBlock;\r\n\r\n    // Staking rewards ending block\r\n    uint256 public stakingEndBlock;\r\n\r\n    // No.of Staking Blocks\r\n    uint256 public noOfStakingBlocks;\r\n\r\n    // No.of users staked\r\n    uint256 public noOfStakes;\r\n    \r\n    // 6440 is the avg no.of Ethereum Blocks per day, Applicable only for Ethereum network \r\n    uint256 public avgETHBlocksPerDay = 6440;\r\n\r\n    // To calculate the no.of Currently staked tokens\r\n    uint256 public currentPool;\r\n\r\n    // To check if the users are fully calimed\r\n    bool public isPoolFullyClaimed;\r\n\r\n    // no.of Days in a Year\r\n    uint256 private daysInAYear = 365;\r\n\r\n    /* EVENTS */\r\n    event Staked(address _address, uint256 _stakedTokens);\r\n    event Claimed(address _address, uint256 _stakedTokens, uint256 _claimedTokens);\r\n    event Paused(bool _status, uint256 _timestamp, uint256 _blockNumber);\r\n    event Withdraw(address _stakeToken, address _hotwallet, uint256 _noOfTokens, uint256 _timestamp, uint256 _blockNumber);\r\n    event SafeWithdraw(address _stakeToken, address _hotwallet, uint256 _noOfTokens, uint256 _timestamp, uint256 _blockNumber);\r\n    event EmergencyWithdraw(address _stakeToken, address _hotwallet, uint256 _noOfTokens, uint256 _timestamp, uint256 _blockNumber);\r\n\r\n    /**\r\n     * @param _stakingToken address of the Token which user stakes\r\n     * @param _stakingPool is the total no.of tokens to meet the requirement to start the staking\r\n     * @param _stakingPoolRewards is the total no.of rewards for the _rewardCapital\r\n     * @param _stakingOpenTime is the pool opening time (like count down) epoch\r\n     * @param _stakingDuration is the statking duration of staking ex: 30 days, 60 days, 90 days... in days\r\n     * @param _manager is to manage the managers of the contracts\r\n     */\r\n    constructor(address _stakingToken, uint256 _stakingPool, uint256 _stakingPoolRewards, uint256 _stakingOpenTime, uint256 _stakingDuration, ManagerRole _manager) {\r\n        stakeToken= _stakingToken;\r\n        stakingPool = _stakingPool;\r\n        stakingPoolRewards = _stakingPoolRewards;\r\n        stakingOpenTime = _stakingOpenTime;\r\n        stakingDuration = _stakingDuration;\r\n        stakingStartBlock = _currentBlockNumber();\r\n        manager = _manager;\r\n        isStakingPaused = false;\r\n        isPoolActive = false;\r\n        noOfStakes = 0;\r\n    }\r\n\r\n    function hotWallet() internal view returns(address) {\r\n        return manager.getHotWallet();\r\n    }\r\n\r\n    function getAPY() external view returns(uint256) {\r\n        uint256 apy = stakingPoolRewards.mul(daysInAYear).mul(100).div(stakingPool.mul(stakingDuration));\r\n        return apy;\r\n    }\r\n    \r\n    /* MODIFIERS */\r\n    modifier onlyManager {\r\n        require(manager.isManager(msg.sender), \"Manager:: Unauthorized Access\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice This is the endpoint for staking\r\n     * @param _noOfTokens is the no.of Tokens user want to stake into the pool in WEI\r\n     */\r\n    function stake(uint256 _noOfTokens) external {\r\n        require(isStakingPaused == false, \"Stake:: Staking is paused\");\r\n        require(_noOfTokens > 0, \"Stake:: Can not stake Zero Tokens\");\r\n        require(_currentBlockTimestamp() > stakingOpenTime, \"Stake:: Staking have not started for this pool\");\r\n        require(stakingPool > currentPool, \"Stake:: Staking Pool is Full\");\r\n        require(_noOfTokens <= stakingPool.sub(currentPool), \"Stake: Can not stake more than pool size\");\r\n        _stake(_noOfTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice This is the internal staking function which can be called by stake\r\n     * @param _noOfTokens is the no.of Tokens user want to stake into the pool in WEI\r\n     */\r\n    function _stake(uint256 _noOfTokens) internal {\r\n        IERC20(stakeToken).transferFrom(msg.sender, address(this), _noOfTokens);\r\n        StakeHolders[msg.sender].amount = StakeHolders[msg.sender].amount.add(_noOfTokens);\r\n        StakeHolders[msg.sender].isClaimed = false;\r\n        StakeHolders[msg.sender].stakedBlock = block.number;\r\n        StakeHolders[msg.sender].rewards = _calculateRewards(_noOfTokens);\r\n        currentPool = currentPool.add(_noOfTokens);\r\n        if(stakingPool == currentPool) {\r\n            isPoolActive = true;\r\n            stakingEndBlock = _currentBlockNumber().add(stakingDuration.mul(avgETHBlocksPerDay));\r\n        }\r\n        noOfStakes = noOfStakes.add(1);\r\n        allStakeHolders.push(msg.sender);\r\n        emit Staked(msg.sender, _noOfTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice This is the internal reward calculation function which can be called by _stake\r\n     * @param _noOfTokens is the no.of Tokens user want to stake into the pool in WEI\r\n     */\r\n    function _calculateRewards(uint256 _noOfTokens) internal view returns (uint256) {\r\n        uint256 userShareInPool = (_noOfTokens.mul(1e6)).div(stakingPool);\r\n        return StakeHolders[msg.sender].rewards.add((userShareInPool.mul(stakingPoolRewards)).div(1e6));\r\n    }\r\n\r\n    /**\r\n     * @notice This is the external function to calculate reward\r\n     * @param _noOfTokens is the no.of Tokens user want to stake into the pool in WEI\r\n     */\r\n    function calculateRewardsView(address _wallet, uint256 _noOfTokens) external view returns (uint256) {\r\n        uint256 userShareInPool = (_noOfTokens.mul(1e6)).div(stakingPool);\r\n        return StakeHolders[_wallet].rewards.add((userShareInPool.mul(stakingPoolRewards)).div(1e6));\r\n    }\r\n\r\n    /**\r\n     * @notice This is the endpoint for Claiming the Stake + Rewards\r\n     */\r\n    function claim() external {\r\n        require(isStakingPaused == false, \"Claim:: Pool is Paused\");\r\n        require(isPoolActive == true, \"Claim:: Pool is not active\");\r\n        require(StakeHolders[msg.sender].isClaimed == false, \"Claim:: Already Claimed\");\r\n        require(StakeHolders[msg.sender].amount > 0, \"Claim:: Seems like haven't staked to claim\");\r\n        require(_currentBlockNumber() > stakingEndBlock, \"Claim:: You can not claim before staked duration\");\r\n        require(IERC20(stakeToken).balanceOf(address(this)) >= (StakeHolders[msg.sender].amount).add(StakeHolders[msg.sender].rewards), \"Claim:: Insufficient Balance\");\r\n        _claim();\r\n    }\r\n\r\n    /**\r\n     * @notice This is the internal function which will be called by claim\r\n     */\r\n    function _claim() internal {\r\n        uint256 claimedTokens = StakeHolders[msg.sender].amount;\r\n        uint256 claimedRewards = StakeHolders[msg.sender].rewards;\r\n        IERC20(stakeToken).transfer(msg.sender, claimedTokens);\r\n        IERC20(stakeToken).transfer(msg.sender, claimedRewards);\r\n        StakeHolders[msg.sender].isClaimed = true;\r\n        StakeHolders[msg.sender].amount = claimedTokens;\r\n        StakeHolders[msg.sender].rewards = claimedRewards;\r\n        StakeHolders[msg.sender].releaseBlock = _currentBlockNumber();\r\n        StakeHolders[msg.sender].claimedOn = _currentBlockTimestamp();\r\n        updateFullyClaimed();\r\n        emit Claimed(msg.sender, claimedTokens, claimedRewards);\r\n    }\r\n\r\n    /**\r\n     * @notice Admin Function\r\n     */\r\n    function pauseStaking() external onlyManager {\r\n        isStakingPaused = true;\r\n        emit Paused(isStakingPaused, block.timestamp, block.number);\r\n    }\r\n\r\n    /**\r\n     * @notice Admin Function\r\n     */\r\n    function unPauseStaking() external onlyManager {\r\n        isStakingPaused = false;\r\n        emit Paused(isStakingPaused, block.timestamp, block.number);\r\n    }\r\n\r\n    /**\r\n     * @notice This is the internal function which fetch the Current Time Stamp from Network\r\n     */\r\n    function _currentBlockTimestamp() internal view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice This is the internal function which fetch the Current Block number from Network\r\n     */\r\n    function _currentBlockNumber() internal view returns (uint256) {\r\n        return block.number;\r\n    }\r\n\r\n    /**\r\n     * @notice This is the external function which allow user to check the staking status\r\n     */\r\n    function claimStatus(address _address) external view returns (bool) {\r\n        return StakeHolders[_address].isClaimed;\r\n    }\r\n\r\n    /**\r\n     * @notice This is the external function to fetch the wallet and token information\r\n     */\r\n    function stakeTokenInfo(address _wallet) external view returns(string memory, string memory, uint256) {\r\n        return (IERC20(stakeToken).name(), IERC20(stakeToken).symbol(), IERC20(stakeToken).balanceOf(_wallet));\r\n    }\r\n    \r\n    /**\r\n     * @notice Admin Function\r\n     */\r\n    function withdraw(uint256 _noOfTokens) external onlyManager {\r\n        require(_currentBlockNumber() < stakingEndBlock, \"Withdraw:: Invalid withdraw\");\r\n        require(IERC20(stakeToken).balanceOf(address(this)) >= _noOfTokens, \"Withdraw:: Invalid Balance\");\r\n        IERC20(stakeToken).transfer(hotWallet(), _noOfTokens);\r\n        emit Withdraw(stakeToken, hotWallet(), _noOfTokens, block.timestamp, block.number);\r\n    }\r\n    \r\n    /**\r\n     * @notice Admin Function\r\n     */\r\n    function safeWithdraw() external onlyManager {\r\n        require(_currentBlockNumber() > stakingEndBlock, \"SafeWithdraw:: Invalid withdraw\");\r\n        \r\n        // Unclaimed Tokens\r\n        uint256 notClaimedStake;\r\n        uint256 notClaimedRewards;\r\n        \r\n        // Claimed Tokens\r\n        uint256 claimedStake;\r\n        uint256 claimedRewards;\r\n        \r\n        for(uint256 i=0; i<allStakeHolders.length; i++) {\r\n            if(StakeHolders[allStakeHolders[i]].isClaimed == false) {\r\n                notClaimedStake = notClaimedStake.add(StakeHolders[allStakeHolders[i]].amount);\r\n                notClaimedRewards = notClaimedRewards.add(StakeHolders[allStakeHolders[i]].rewards); \r\n            } else if (StakeHolders[allStakeHolders[i]].isClaimed == true) {\r\n                claimedStake = claimedStake.add(StakeHolders[allStakeHolders[i]].amount);\r\n                claimedRewards = claimedRewards.add(StakeHolders[allStakeHolders[i]].rewards); \r\n            }\r\n        }\r\n        \r\n        // Calculate Balance\r\n        uint256 totalUnClaimed = notClaimedStake.add(notClaimedRewards);\r\n        uint256 balanceInContract = IERC20(stakeToken).balanceOf(address(this));\r\n        \r\n        if(balanceInContract > totalUnClaimed) {\r\n            IERC20(stakeToken).transfer(hotWallet(), balanceInContract.sub(totalUnClaimed));\r\n            emit SafeWithdraw(stakeToken, hotWallet(), balanceInContract.sub(totalUnClaimed), block.timestamp, block.number);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Total Unclaimed Tokens\r\n     */\r\n    function totalUnClaimedTokens() public view returns(uint256) {        \r\n        uint256 notClaimedStake;\r\n        uint256 notClaimedRewards;\r\n        for(uint256 i=0; i<allStakeHolders.length; i++) {\r\n            if(StakeHolders[allStakeHolders[i]].isClaimed == false) {\r\n                notClaimedStake = notClaimedStake.add(StakeHolders[allStakeHolders[i]].amount);\r\n                notClaimedRewards = notClaimedRewards.add(StakeHolders[allStakeHolders[i]].rewards); \r\n            }\r\n        }\r\n        uint256 totalUnClaimed = notClaimedStake.add(notClaimedRewards);\r\n        return totalUnClaimed;\r\n    }\r\n\r\n    /**\r\n     * @notice Update Fully Claimed Status\r\n     */\r\n    function updateFullyClaimed() internal {\r\n        if(totalUnClaimedTokens() == 0) {\r\n            isPoolFullyClaimed = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the current balance of the tokens in the contract\r\n     */\r\n    function balanceOfContact() external view returns(uint256) {\r\n        return IERC20(stakeToken).balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @notice Get the current balance of the tokens\r\n     */\r\n    function balanceToMaintain() external view returns(uint256) {\r\n        uint256 currentBalance = IERC20(stakeToken).balanceOf(address(this));\r\n        uint256 totalUnClaimed = totalUnClaimedTokens();\r\n        if(totalUnClaimed > currentBalance) {\r\n            return totalUnClaimed.sub(currentBalance);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @notice EMERGENCY WITHDRAWL is used to empty the balance in contract in case of Emergency Situation\r\n     */\r\n    function emergencyWithdrawl() external onlyManager {\r\n        isStakingPaused = true;\r\n        uint256 balanceInContract = IERC20(stakeToken).balanceOf(address(this));\r\n        IERC20(stakeToken).transfer(hotWallet(), balanceInContract);\r\n        emit EmergencyWithdraw(stakeToken, hotWallet(), balanceInContract, block.timestamp, block.number);\r\n    }\r\n}\r\n\r\ncontract ManagerRole {\r\n    address public superAdmin;\r\n    address _hotWallet;\r\n\r\n    event ManagerAdded(address _manager, bool _status);\r\n    event ManagerUpdated(address _manager, bool _status);\r\n    event HotWalletUpdated(address _oldHotWallet, address _newHotWallet);\r\n    \r\n    constructor(address _wallet) {\r\n        require(_wallet != address(0), \"Hotwallet can't be the zero address\");\r\n        superAdmin = msg.sender;\r\n        _hotWallet = _wallet;\r\n    }\r\n    \r\n    modifier onlySuperAdmin {\r\n        require(superAdmin == msg.sender, \"Unauthorized Access\");\r\n        _;\r\n    }\r\n\r\n    struct Manager {\r\n        address _manager;\r\n        bool _isActive;\r\n    }\r\n    \r\n    mapping (address => Manager) public managers;\r\n    \r\n    function addManager(address _address, bool _status) external onlySuperAdmin {\r\n        require(_address != address(0), \"Manager can't be the zero address\");\r\n        managers[_address]._manager = _address;\r\n        managers[_address]._isActive = _status;\r\n        emit ManagerAdded(_address, _status);\r\n    }\r\n    \r\n    function getManager(address _address) view external returns (address, bool) {\r\n        return(managers[_address]._manager, managers[_address]._isActive);\r\n    }\r\n\r\n    function isManager(address _address) external view returns(bool _status) {\r\n        return(managers[_address]._isActive);\r\n    }\r\n    \r\n    function updateManager(address _address, bool _status) external onlySuperAdmin {\r\n        require(_address != address(0), \"Manager can't be the zero address\");\r\n        require(managers[_address]._isActive != _status);\r\n        managers[_address]._isActive = _status;\r\n        emit ManagerUpdated(_address, _status);\r\n    }\r\n    \r\n    function governance() external view returns(address){\r\n        return superAdmin;\r\n    }\r\n    \r\n    function getHotWallet() external view returns(address) {\r\n        return _hotWallet;\r\n    }\r\n    \r\n    function setNewHotWallet(address _newHotWallet) external onlySuperAdmin {\r\n        require(_newHotWallet != address(0), \"Hotwallet can't be the zero address\");\r\n        address _oldHotWallet = _hotWallet;\r\n        _hotWallet = _newHotWallet;\r\n        emit HotWalletUpdated(_oldHotWallet, _newHotWallet);\r\n    }\r\n    \r\n}\r\n\r\ninterface IERC20 {\r\n    \r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the sybmol of token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakingPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakingPoolRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakingOpenTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakingDuration\",\"type\":\"uint256\"},{\"internalType\":\"contract ManagerRole\",\"name\":\"_manager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakedTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_claimedTokens\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_hotwallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_noOfTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_hotwallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_noOfTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"SafeWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_stakedTokens\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_hotwallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_noOfTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"StakeHolders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isClaimed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedOn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgETHBlocksPerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfContact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceToMaintain\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_noOfTokens\",\"type\":\"uint256\"}],\"name\":\"calculateRewardsView\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"claimStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdrawl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAPY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPoolActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPoolFullyClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStakingPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"contract ManagerRole\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noOfStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"noOfStakingBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_noOfTokens\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"stakeTokenInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingOpenTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPoolRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingStartBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUnClaimedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPauseStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_noOfTokens\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Staking","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008a40c222996f9f3431f63bf80244c36822060f1200000000000000000000000000000000000000000001a784379d99db4200000000000000000000000000000000000000000000000000054b40b1f852bda00000000000000000000000000000000000000000000000000000000000006138a5c0000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000ab452a7eb5e5345669cb33140f0cb0d55f5bf363","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e6182e2398d5516b6b0cbb83a90677fce4032117f985e72c11a2a4934d751e28"}]}