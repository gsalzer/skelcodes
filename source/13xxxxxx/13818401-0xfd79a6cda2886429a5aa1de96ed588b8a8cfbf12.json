{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Traits.sol\": {\r\n      \"content\": \"//Contract based on https://docs.openzeppelin.com/contracts/3.x/erc721\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport {MerkleProof} from \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\n\\nimport \\\"./ICryptoBees.sol\\\";\\nimport \\\"./IHoney.sol\\\";\\nimport \\\"./Base64.sol\\\";\\n\\ncontract Traits is Ownable {\\n    using Strings for uint256;\\n    using MerkleProof for bytes32[];\\n    // struct to store each trait's data for metadata and rendering\\n    struct Trait {\\n        string name;\\n        string png;\\n    }\\n    string unrevealedImage;\\n\\n    ICryptoBees beesContract;\\n    IHoney honeyContract;\\n    // mint price ETH\\n    uint256 public constant MINT_PRICE = .06 ether;\\n    uint256 public constant MINT_PRICE_DISCOUNT = .055 ether;\\n    uint256 public constant MINTS_PER_WHITELIST = 6;\\n    // used to ensure there are no duplicates\\n    mapping(uint256 => uint256) public existingCombinations;\\n\\n    // mint price HONEY\\n    uint256 public constant MINT_PRICE_HONEY = 3000 ether;\\n    // mint price WOOL\\n    uint256 public mintPriceWool = 6600 ether;\\n    // max number of tokens that can be minted\\n    uint256 public constant MAX_TOKENS = 40000;\\n    // number of tokens that can be claimed for ETH\\n    uint256 public constant PAID_TOKENS = 10000;\\n    /// @notice controls if mintWithEthPresale is paused\\n    bool public mintWithEthPresalePaused = true;\\n    /// @notice controls if mintWithWool is paused\\n    bool public mintWithWoolPaused = true;\\n    /// @notice controls if mainMint is paused\\n    bool public mintWithEthPaused = true;\\n\\n    mapping(address => uint8) public whitelistMints;\\n\\n    bytes32 private merkleRootWhitelist;\\n\\n    string[8] _traitTypes = [\\\"Body\\\", \\\"Color\\\", \\\"Eyes\\\", \\\"Mouth\\\", \\\"Nose\\\", \\\"Hair\\\", \\\"Accessories\\\", \\\"Feelers\\\"];\\n    // storage of each traits name and base64 PNG data\\n    mapping(uint8 => mapping(uint8 => Trait)) public traitData;\\n    string[4] _strengths = [\\\"5\\\", \\\"6\\\", \\\"7\\\", \\\"8\\\"];\\n    // 0 - 7 are associated with Bees, 8 - 18 are associated with Bears, 16 - 23 with Beekeeper\\n    uint8[][24] public rarities;\\n    // 0 - 7 are associated with Bees, 8 - 18 are associated with Bears, 16 - 23 with Beekeeper\\n    uint8[][24] public aliases;\\n\\n    constructor() {\\n        // colours\\n        rarities[1] = [255, 215, 122, 76, 30, 15];\\n        aliases[1] = [0, 0, 0, 0, 0, 0];\\n        // eyes\\n        rarities[2] = [255, 217, 217, 230, 217, 204, 230, 230, 230, 230, 230, 191, 191, 191, 191];\\n        aliases[2] = [0, 0, 1, 2, 3, 4, 0, 1, 2, 6, 7, 1, 1, 2, 5];\\n        // mouth\\n        rarities[3] = [255, 202, 191, 181, 215, 248, 199, 194, 189, 184, 179, 217, 174, 174, 174, 174, 174];\\n        aliases[3] = [0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 10];\\n        // nose\\n        rarities[4] = [255, 230, 204, 192, 179, 179, 179];\\n        aliases[4] = [0, 0, 1, 2, 0, 1, 3];\\n        // hair\\n        rarities[5] = [255, 127, 204, 230, 115, 115, 115, 115, 115];\\n        aliases[5] = [0, 0, 1, 3, 5, 4, 1, 1, 2];\\n        // accessory\\n        rarities[6] = [255, 99, 53];\\n        aliases[6] = [0, 0, 0];\\n        // feelers\\n        rarities[7] = [255, 140, 204, 102, 179, 89, 89];\\n        aliases[7] = [0, 0, 1, 2, 0, 1, 3];\\n\\n        //bear - colours\\n        rarities[9] = [255, 153, 153];\\n        aliases[9] = [0, 0, 1];\\n\\n        //bear - eyes\\n        rarities[10] = [255, 220, 184, 148, 222, 186, 151, 225, 189, 153, 117, 240, 204, 168, 133, 145, 145, 97, 97];\\n        aliases[10] = [0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 3, 6, 10, 14];\\n\\n        //bear - mouth\\n        rarities[11] = [255, 235, 184, 204, 225, 174, 245, 245, 245, 184, 184, 122];\\n        aliases[11] = [0, 0, 1, 2, 3, 4, 0, 1, 6, 2, 3, 5];\\n\\n        //bear - nose\\n        rarities[12] = [255, 230, 204, 179, 179, 179, 179];\\n        aliases[12] = [0, 0, 1, 3, 1, 2, 3];\\n\\n        //bear - hat/hair\\n        rarities[13] = [255, 204, 204, 204, 102, 102, 102, 102];\\n        aliases[13] = [0, 1, 0, 2, 3, 2, 4, 4];\\n\\n        //bear - accessory\\n        rarities[14] = [255, 89, 89, 53, 53, 35, 35];\\n        aliases[14] = [0, 0, 1, 1, 2, 2, 3];\\n\\n        // bear strength\\n        rarities[15] = [255, 102, 153, 51];\\n        aliases[15] = [0, 0, 1, 1];\\n\\n        //beekeeper - color\\n        rarities[17] = [255, 153, 153, 153, 76, 76];\\n        aliases[17] = [0, 0, 1, 1, 2, 2];\\n\\n        //beekeeper - eyes\\n        rarities[18] = [255, 170, 142, 113];\\n        aliases[18] = [0, 0, 1, 2];\\n\\n        //beekeeper - mouth\\n        rarities[19] = [255, 243, 230, 217, 204, 192, 179];\\n        aliases[19] = [0, 0, 1, 2, 3, 4, 5];\\n\\n        //beekeeper - hair\\n        rarities[21] = [255, 230, 230, 230, 230, 230, 230, 230, 230];\\n        aliases[21] = [0, 0, 1, 1, 3, 4, 3, 1, 0];\\n\\n        //beekeeper - accessory\\n        rarities[22] = [255, 122, 122, 122, 122, 122, 122, 122, 122, 122, 92, 30];\\n        aliases[22] = [0, 0, 1, 1, 4, 3, 0, 2, 2, 1, 5, 4];\\n        //beekeeper skill\\n        rarities[23] = [255, 102, 153, 51];\\n        aliases[23] = [0, 0, 1, 2];\\n    }\\n\\n    function setContracts(address _BEES, address _HONEY) external onlyOwner {\\n        honeyContract = IHoney(_HONEY);\\n        beesContract = ICryptoBees(_BEES);\\n    }\\n\\n    /** MINTING */\\n    function mintForEth(\\n        address addr,\\n        uint256 amount,\\n        uint256 minted,\\n        uint256 value,\\n        bool stake\\n    ) external {\\n        require(_msgSender() == address(beesContract), \\\"DONT CHEAT!\\\");\\n        mintCheck(addr, amount, minted, false, value, true);\\n        for (uint256 i = 1; i <= amount; i++) {\\n            beesContract.mint(addr, minted + i, stake);\\n        }\\n    }\\n\\n    function mintForEthWhitelist(\\n        address addr,\\n        uint256 amount,\\n        uint256 minted,\\n        uint256 value,\\n        bytes32[] calldata _merkleProof,\\n        bool stake\\n    ) external {\\n        require(_msgSender() == address(beesContract), \\\"DONT CHEAT!\\\");\\n        bytes32 leaf = keccak256(abi.encodePacked(addr));\\n        require(MerkleProof.verify(_merkleProof, merkleRootWhitelist, leaf), \\\"You are not on the whitelist!\\\");\\n        mintCheck(addr, amount, minted, true, value, true);\\n        for (uint256 i = 1; i <= amount; i++) {\\n            beesContract.mint(addr, minted + i, stake);\\n            whitelistMints[addr]++;\\n        }\\n    }\\n\\n    function mintForHoney(\\n        address addr,\\n        uint256 amount,\\n        uint256 minted,\\n        bool stake\\n    ) external {\\n        require(_msgSender() == address(beesContract), \\\"DONT CHEAT!\\\");\\n        mintCheck(addr, amount, minted, false, 0, false);\\n        uint256 totalHoneyCost = 0;\\n        for (uint256 i = 1; i <= amount; i++) {\\n            totalHoneyCost += mintCost(minted + i);\\n            beesContract.mint(addr, minted + i, stake);\\n        }\\n        honeyContract.burn(addr, totalHoneyCost);\\n    }\\n\\n    function mintForWool(\\n        address addr,\\n        uint256 amount,\\n        uint256 minted,\\n        bool stake\\n    ) external returns (uint256 totalWoolCost) {\\n        require(_msgSender() == address(beesContract), \\\"DONT CHEAT!\\\");\\n        require(!mintWithWoolPaused, \\\"WOOL minting paused\\\");\\n        require(minted + amount <= PAID_TOKENS, \\\"All tokens on-sale already sold\\\");\\n        mintCheck(addr, amount, minted, false, 0, false);\\n\\n        for (uint256 i = 1; i <= amount; i++) {\\n            totalWoolCost += mintPriceWool;\\n            beesContract.mint(addr, minted + i, stake);\\n        }\\n    }\\n\\n    function mintCheck(\\n        address addr,\\n        uint256 amount,\\n        uint256 minted,\\n        bool presale,\\n        uint256 value,\\n        bool isEth\\n    ) private view {\\n        require(tx.origin == addr, \\\"Only EOA\\\");\\n        require(minted + amount <= MAX_TOKENS, \\\"All tokens minted\\\");\\n        if (presale) {\\n            require(!mintWithEthPresalePaused, \\\"Presale mint paused\\\");\\n            require(amount > 0 && whitelistMints[addr] + amount <= MINTS_PER_WHITELIST, \\\"Only limited amount for WL mint\\\");\\n        } else {\\n            require(amount > 0 && amount <= 10, \\\"Invalid mint amount sale\\\");\\n        }\\n        if (isEth) {\\n            require(minted + amount <= PAID_TOKENS, \\\"All tokens on-sale already sold\\\");\\n            if (presale) require(amount * MINT_PRICE_DISCOUNT == value, \\\"Invalid payment amount presale\\\");\\n            else {\\n                require(amount * MINT_PRICE == value, \\\"Invalid payment amount sale\\\");\\n                require(!mintWithEthPaused, \\\"Public sale currently paused\\\");\\n            }\\n        }\\n    }\\n\\n    function getTokenTextType(uint256 tokenId) external view returns (string memory) {\\n        require(beesContract.doesExist(tokenId), \\\"ERC721Metadata: Nonexistent token\\\");\\n        return _getTokenTextType(tokenId);\\n    }\\n\\n    function _getTokenTextType(uint256 tokenId) private view returns (string memory) {\\n        uint8 _type = beesContract.getTokenData(tokenId)._type;\\n        if (_type == 1) return \\\"BEE\\\";\\n        else if (_type == 2) return \\\"BEAR\\\";\\n        else if (_type == 3) return \\\"BEEKEEPER\\\";\\n        else return \\\"NOT REVEALED\\\";\\n    }\\n\\n    function setPresaleMintPaused(bool _paused) external onlyOwner {\\n        mintWithEthPresalePaused = _paused;\\n    }\\n\\n    function setWoolMintPaused(bool _paused) external onlyOwner {\\n        mintWithWoolPaused = _paused;\\n    }\\n\\n    function setMintWithEthPaused(bool _paused) external onlyOwner {\\n        mintWithEthPaused = _paused;\\n    }\\n\\n    function setWoolMintPrice(uint256 _price) external onlyOwner {\\n        mintPriceWool = _price;\\n    }\\n\\n    function setMerkleRoot(bytes32 root) public onlyOwner {\\n        merkleRootWhitelist = root;\\n    }\\n\\n    /**\\n     * generates traits for a specific token, checking to make sure it's unique\\n     * @param seed a pseudorandom 256 bit number to derive traits from\\n     * @return t - a struct of traits for the given token ID\\n     */\\n    function generate(uint256 seed) public view returns (ICryptoBees.Token memory) {\\n        require(_msgSender() == address(beesContract), \\\"DONT CHEAT!\\\");\\n        ICryptoBees.Token memory t = selectTraits(seed);\\n        return t;\\n    }\\n\\n    /**\\n     * selects the species and all of its traits based on the seed value\\n     * @param seed a pseudorandom 256 bit number to derive traits from\\n     * @return t -  a struct of randomly selected traits\\n     */\\n    function selectTraits(uint256 seed) internal view returns (ICryptoBees.Token memory t) {\\n        uint256 num = ((seed & 0xFFFF) % 100);\\n        t._type = 1;\\n        if (num == 0) t._type = 3;\\n        else if (num < 10) t._type = 2;\\n        uint8 shift = t._type > 0 ? ((t._type - 1) * 8) : 0;\\n        seed >>= 16;\\n        t.color = selectTrait(uint16(seed & 0xFFFF), 1 + shift);\\n        seed >>= 16;\\n        t.eyes = selectTrait(uint16(seed & 0xFFFF), 2 + shift);\\n        seed >>= 16;\\n        t.mouth = selectTrait(uint16(seed & 0xFFFF), 3 + shift);\\n        if (t._type != 3) {\\n            seed >>= 16;\\n            t.nose = selectTrait(uint16(seed & 0xFFFF), 4 + shift);\\n        }\\n        seed >>= 16;\\n        t.hair = selectTrait(uint16(seed & 0xFFFF), 5 + shift);\\n        seed >>= 16;\\n        t.accessory = selectTrait(uint16(seed & 0xFFFF), 6 + shift);\\n        if (t._type == 1) {\\n            seed >>= 16;\\n            t.feelers = selectTrait(uint16(seed & 0xFFFF), 7);\\n        } else {\\n            seed >>= 16;\\n            t.strength = selectTrait(uint16(seed & 0xFFFF), 7 + shift);\\n        }\\n    }\\n\\n    /**\\n     * uses A.J. Walker's Alias algorithm for O(1) rarity table lookup\\n     * ensuring O(1) instead of O(n) reduces mint cost by more than 50%\\n     * probability & alias tables are generated off-chain beforehand\\n     * @param seed portion of the 256 bit seed to remove trait correlation\\n     * @param traitType the trait type to select a trait for\\n     * @return the ID of the randomly selected trait\\n     */\\n    function selectTrait(uint16 seed, uint8 traitType) internal view returns (uint8) {\\n        uint8 trait = uint8(seed) % uint8(rarities[traitType].length);\\n        if (seed >> 8 < rarities[traitType][trait]) return trait;\\n        return aliases[traitType][trait];\\n    }\\n\\n    /**\\n     * converts a struct to a 256 bit hash to check for uniqueness\\n     * @param t the struct to pack into a hash\\n     * @return the 256 bit hash of the struct\\n     */\\n    function structToHash(ICryptoBees.Token memory t) internal pure returns (uint256) {\\n        return uint256(bytes32(abi.encodePacked(t._type, t.color, t.eyes, t.mouth, t.nose, t.hair, t.accessory, t.feelers, t.strength)));\\n    }\\n\\n    /**\\n     * Gen 0 can be mint for honey too\\n     * @param tokenId the ID to check the cost of to mint\\n     * @return the cost of the given token ID\\n     */\\n    function mintCost(uint256 tokenId) public pure returns (uint256) {\\n        if (tokenId <= 20000) return MINT_PRICE_HONEY;\\n        if (tokenId <= 30000) return 7500 ether;\\n        return 15000 ether;\\n    }\\n\\n    /**\\n     * administrative to upload the names and images associated with each trait\\n     * @param traitType the trait type to upload the traits for (see traitTypes for a mapping)\\n     * @param traitNames the names and base64 encoded PNGs for each trait\\n     * @param traitImages the names and base64 encoded PNGs for each trait\\n     */\\n    function uploadTraits(\\n        uint8 traitType,\\n        string[] calldata traitNames,\\n        string[] calldata traitImages\\n    ) external onlyOwner {\\n        require(traitNames.length == traitImages.length, \\\"Mismatched inputs\\\");\\n        for (uint256 i = 0; i < traitNames.length; i++) {\\n            traitData[traitType][uint8(i)] = Trait(traitNames[i], traitImages[i]);\\n        }\\n    }\\n\\n    function uploadUnrevealImage(string calldata image) external onlyOwner {\\n        unrevealedImage = image;\\n    }\\n\\n    // function random(uint256 seed) internal view returns (uint256) {\\n    //     return uint256(keccak256(abi.encodePacked(seed)));\\n    // }\\n\\n    /** RENDER */\\n\\n    /**\\n     * generates an <image> element using base64 encoded PNGs\\n     * @param trait the trait storing the PNG data\\n     * @return the <image> element\\n     */\\n    function drawTrait(Trait memory trait) internal pure returns (string memory) {\\n        if (bytes(trait.png).length == 0) return \\\"\\\";\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<image x=\\\"4\\\" y=\\\"4\\\" width=\\\"32\\\" height=\\\"32\\\" image-rendering=\\\"pixelated\\\" preserveAspectRatio=\\\"xMidYMid\\\" xlink:href=\\\"data:image/png;base64,',\\n                    trait.png,\\n                    '\\\"/>'\\n                )\\n            );\\n    }\\n\\n    /**\\n     * generates an <image> element using base64 encoded PNGs\\n     * @return the <image> element\\n     */\\n    function drawUnrevealedImage() internal view returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<image x=\\\"4\\\" y=\\\"4\\\" width=\\\"32\\\" height=\\\"32\\\" image-rendering=\\\"pixelated\\\" preserveAspectRatio=\\\"xMidYMid\\\" xlink:href=\\\"data:image/png;base64,',\\n                    unrevealedImage,\\n                    '\\\"/>'\\n                )\\n            );\\n    }\\n\\n    // /**\\n    //  * generates an entire SVG by composing multiple <image> elements of PNGs\\n    //  * @param tokenId the ID of the token to generate an SVG for\\n    //  * @return a valid SVG of the Sheep / Wolf\\n    //  */\\n    function drawSVG(uint256 tokenId) public view returns (string memory) {\\n        ICryptoBees.Token memory s = beesContract.getTokenData(tokenId);\\n        uint8 shift = s._type > 0 ? ((s._type - 1) * 8) : 0;\\n        string memory svgString;\\n        if (s._type == 0) svgString = drawUnrevealedImage();\\n        else {\\n            svgString = string(\\n                abi.encodePacked(\\n                    drawTrait(traitData[0 + shift][0]),\\n                    drawTrait(traitData[1 + shift][s.color]),\\n                    drawTrait(traitData[2 + shift][s.eyes]),\\n                    drawTrait(traitData[3 + shift][s.mouth]),\\n                    drawTrait(traitData[4 + shift][s.nose]),\\n                    drawTrait(traitData[5 + shift][s.hair]),\\n                    drawTrait(traitData[6 + shift][s.accessory]),\\n                    drawTrait(traitData[7][s.feelers])\\n                )\\n            );\\n        }\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<svg id=\\\"cryptobees\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 40 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">',\\n                    svgString,\\n                    \\\"</svg>\\\"\\n                )\\n            );\\n    }\\n\\n    /**\\n     * generates an attribute for the attributes array in the ERC721 metadata standard\\n     * @param traitType the trait type to reference as the metadata key\\n     * @param value the token's trait associated with the key\\n     * @return a JSON dictionary for the single attribute\\n     */\\n    function attributeForTypeAndValue(string memory traitType, string memory value) internal pure returns (string memory) {\\n        return string(abi.encodePacked('{\\\"trait_type\\\":\\\"', traitType, '\\\",\\\"value\\\":\\\"', value, '\\\"}'));\\n    }\\n\\n    /**\\n     * generates an array composed of all the individual traits and values\\n     * @param tokenId the ID of the token to compose the metadata for\\n     * @return a JSON array of all of the attributes for given token ID\\n     */\\n    function compileAttributes(uint256 tokenId) public view returns (string memory) {\\n        ICryptoBees.Token memory t = beesContract.getTokenData(tokenId);\\n        string memory textType = _getTokenTextType(tokenId);\\n        uint8 shift = t._type > 0 ? ((t._type - 1) * 8) : 0;\\n        string memory traits;\\n        traits = string(\\n            abi.encodePacked(\\n                attributeForTypeAndValue(_traitTypes[1], traitData[1 + shift][t.color].name),\\n                \\\",\\\",\\n                attributeForTypeAndValue(_traitTypes[2], traitData[2 + shift][t.eyes].name),\\n                \\\",\\\",\\n                attributeForTypeAndValue(_traitTypes[3], traitData[3 + shift][t.mouth].name),\\n                \\\",\\\",\\n                attributeForTypeAndValue(_traitTypes[5], traitData[5 + shift][t.hair].name),\\n                \\\",\\\",\\n                attributeForTypeAndValue(_traitTypes[6], traitData[6 + shift][t.accessory].name),\\n                \\\",\\\"\\n            )\\n        );\\n        if (t._type != 3) {\\n            traits = string(abi.encodePacked(traits, attributeForTypeAndValue(_traitTypes[4], traitData[4 + shift][t.nose].name), \\\",\\\"));\\n        }\\n        if (t._type == 1) {\\n            traits = string(abi.encodePacked(traits, attributeForTypeAndValue(_traitTypes[7], traitData[7][t.feelers].name), \\\",\\\"));\\n        } else if (t._type == 2) {\\n            traits = string(abi.encodePacked(traits, attributeForTypeAndValue(\\\"Strength\\\", _strengths[t.strength]), \\\",\\\"));\\n        } else if (t._type == 3) {\\n            traits = string(abi.encodePacked(traits, attributeForTypeAndValue(\\\"Skill\\\", _strengths[t.strength]), \\\",\\\"));\\n        }\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"[\\\",\\n                    traits,\\n                    '{\\\"trait_type\\\":\\\"Generation\\\",\\\"value\\\":',\\n                    tokenId <= PAID_TOKENS ? '\\\"Gen 0\\\"' : '\\\"Gen 1\\\"',\\n                    '},{\\\"trait_type\\\":\\\"Type\\\",\\\"value\\\":\\\"',\\n                    textType,\\n                    '\\\"}]'\\n                )\\n            );\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\\n        // require(beesContract.doesExist(tokenId), \\\"ERC721Metadata: Nonexistent token\\\");\\n\\n        string memory textType = _getTokenTextType(tokenId);\\n        string memory metadata = string(\\n            abi.encodePacked(\\n                '{\\\"name\\\": \\\"',\\n                textType,\\n                \\\" #\\\",\\n                uint256(tokenId).toString(),\\n                '\\\", \\\"type\\\": \\\"',\\n                textType,\\n                '\\\", \\\"description\\\": \\\"People realized that the path to prosperity is to relocate to a farm. Some have bought sheep, some land but many ended up with nothing. $HONEY is the new opportunity.',\\n                '\\\",\\\"image\\\": \\\"data:image/svg+xml;base64,',\\n                Base64.encode(bytes(drawSVG(tokenId))),\\n                '\\\",\\\"attributes\\\":',\\n                compileAttributes(tokenId),\\n                \\\"}\\\"\\n            )\\n        );\\n\\n        return string(abi.encodePacked(\\\"data:application/json;base64,\\\", Base64.encode(bytes(metadata))));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n        return computedHash;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ICryptoBees.sol\": {\r\n      \"content\": \"//Contract based on https://docs.openzeppelin.com/contracts/3.x/erc721\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n// import \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface ICryptoBees {\\n    struct Token {\\n        uint8 _type;\\n        uint8 color;\\n        uint8 eyes;\\n        uint8 mouth;\\n        uint8 nose;\\n        uint8 hair;\\n        uint8 accessory;\\n        uint8 feelers;\\n        uint8 strength;\\n        uint48 lastAttackTimestamp;\\n        uint48 cooldownTillTimestamp;\\n    }\\n\\n    function getMinted() external view returns (uint256 m);\\n\\n    function increaseTokensPot(address _owner, uint256 amount) external;\\n\\n    function updateTokensLastAttack(\\n        uint256 tokenId,\\n        uint48 timestamp,\\n        uint48 till\\n    ) external;\\n\\n    function mint(\\n        address addr,\\n        uint256 tokenId,\\n        bool stake\\n    ) external;\\n\\n    function setPaused(bool _paused) external;\\n\\n    function getTokenData(uint256 tokenId) external view returns (Token memory token);\\n\\n    function getOwnerOf(uint256 tokenId) external view returns (address);\\n\\n    function doesExist(uint256 tokenId) external view returns (bool exists);\\n\\n    function performTransferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    function performSafeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IHoney.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.9;\\n\\ninterface IHoney {\\n    function mint(address to, uint256 amount) external;\\n\\n    function mintGiveaway(address[] calldata addresses, uint256 amount) external;\\n\\n    function burn(address from, uint256 amount) external;\\n\\n    function disableGiveaway() external;\\n\\n    function addController(address controller) external;\\n\\n    function removeController(address controller) external;\\n}\\n\"\r\n    },\r\n    \"contracts/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.9;\\n\\nlibrary Base64 {\\n    string internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // load the table into memory\\n        string memory table = TABLE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {\\n\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                dataPtr := add(dataPtr, 3)\\n\\n                // read 3 bytes\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F)))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore(resultPtr, shl(248, mload(add(tablePtr, and(input, 0x3F)))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINTS_PER_WHITELIST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_PRICE_DISCOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_PRICE_HONEY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAID_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"aliases\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"compileAttributes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"drawSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"existingCombinations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"generate\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"_type\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"color\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"accessory\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"feelers\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"strength\",\"type\":\"uint8\"},{\"internalType\":\"uint48\",\"name\":\"lastAttackTimestamp\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"cooldownTillTimestamp\",\"type\":\"uint48\"}],\"internalType\":\"struct ICryptoBees.Token\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenTextType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mintCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"mintForEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"mintForEthWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"mintForHoney\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"mintForWool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalWoolCost\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPriceWool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintWithEthPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintWithEthPresalePaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintWithWoolPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rarities\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_BEES\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_HONEY\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setMintWithEthPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPresaleMintPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setWoolMintPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setWoolMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"traitData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"png\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"traitType\",\"type\":\"uint8\"},{\"internalType\":\"string[]\",\"name\":\"traitNames\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"traitImages\",\"type\":\"string[]\"}],\"name\":\"uploadTraits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"image\",\"type\":\"string\"}],\"name\":\"uploadUnrevealImage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistMints\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Traits","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}