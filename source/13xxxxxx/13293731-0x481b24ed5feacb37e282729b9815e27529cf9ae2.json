{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8;\r\n\r\n/* Interfaces */\r\n\r\n/**\r\n * @title UniswapV2Router Interface\r\n * @dev See https://uniswap.org/docs/v2/smart-contracts/router02/#swapexactethfortokens. This will allow us to import swapExactETHForTokens function into our contract and the getAmountsOut function to calculate the token amount we will swap\r\n */\r\ninterface IUniswapV2Router {\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin, //minimum amount of output token that must be received\r\n        address[] calldata path, //the different hops between tokens to be made by the exchange\r\n        address to, //recipient\r\n        uint256 deadline //unix timestamp after which the transaction will revert\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256[] memory amounts //amounts of tokens output received\r\n        );\r\n\r\n    function getAmountsOut(\r\n        uint256 amountIn, //amount of input token\r\n        address[] memory path //the different hops between tokens to be made by the exchange\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256[] memory amounts //amounts of tokens output calculated to be received\r\n        );\r\n}\r\n\r\n/**\r\n * @title UBI Interface\r\n * @dev See https://github.com/DemocracyEarth/ubi/blob/master/contracts/UBI.sol This will allow us to see the UBI balance of our contract (burned UBI)\r\n */\r\ninterface IUBI {\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n}\r\n\r\ncontract UBIburner {\r\n\r\n    /* Events */\r\n\r\n    event BurnerAdded(address burner);\r\n    event BurnerRemoved(address burner);\r\n    event Received(address indexed from, uint256 amount);\r\n    event BurnUBIRequested(address requester, uint256 UBIAmount);\r\n    event Burned(address requester, address burner, uint256 amount, uint256 burned);\r\n\r\n    /* Constants */\r\n\r\n    /// @dev address of the uniswap v2 router\r\n    address private constant UNISWAP_V2_ROUTER =\r\n        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n\r\n    /// @dev address of WETH token. In Uniswap v2 there are no more direct ETH pairs, all ETH must be converted to WETH first.\r\n    address private constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n\r\n    /// @dev address of UBI token.\r\n    address private constant UBI = 0xDd1Ad9A21Ce722C151A836373baBe42c868cE9a4;\r\n\r\n    /* Storage */\r\n\r\n    /// @dev An array of token addresses. Any swap needs to have a starting and end path, path.length must be >= 2. Pools for each consecutive pair of addresses must exist and have liquidity.\r\n    address[] path = [WETH, UBI];\r\n\r\n    /// @dev Parameter stored by the burner request of how much the minimum amount of UBIs burned should be.\r\n    uint256 public currentAmountOutMin;\r\n\r\n    /// @dev Burn requester. Variable stored because the burner cannot be the requester.\r\n    address public currentBurnRequester;\r\n\r\n    /// @dev Indicates if the address belongs to a burner. isBurner[address].\r\n    mapping(address => bool) public isBurner;\r\n\r\n    /// @dev Indicates whether or not there is a request to add a new burner. requestBurnerAddMap[requesterAddress][burnerAddressToAdd].\r\n    mapping(address => mapping(address => bool)) public requestBurnerAddMap;\r\n\r\n    /// @dev Indicates whether or not there is a request to remove a burner. requestBurnerRemovalMap[requesterAddress][burnerAddressToRemove].\r\n    mapping(address => mapping(address => bool)) public requestBurnerRemovalMap;\r\n\r\n    /* Modifiers */\r\n\r\n    modifier onlyBurner() {\r\n        require(isBurner[msg.sender], \"Not burner\");\r\n        _;\r\n    }\r\n\r\n    /* Constructor */\r\n\r\n    /// @dev 3 burners will be created by the constructor\r\n    constructor(address _burner2, address _burner3) {\r\n        addBurner(msg.sender); //_burner1\r\n        addBurner(_burner2);\r\n        addBurner(_burner3);\r\n    }\r\n\r\n    /* External and Public */\r\n\r\n    // ************************ //\r\n    // *       Requests       * //\r\n    // ************************ //\r\n    \r\n    /** @dev Requests the creation of a new burner.\r\n     *  @param _burnerToAdd Address of the burner requested to be added.\r\n     */\r\n    function requestBurnerAdd(address _burnerToAdd) external onlyBurner {\r\n        requestBurnerAddMap[msg.sender][_burnerToAdd] = true;\r\n    }\r\n\r\n    /** @dev Acceptance of the new burner. Only a burner other than the requester can accept the request.\r\n     *  @param _requester Requester address.\r\n     *  @param _burnerToAdd Address of the burner to be accepted.\r\n     */\r\n    function AddBurnerAccepted(address _requester, address _burnerToAdd)\r\n        external\r\n        onlyBurner\r\n    {\r\n        require(\r\n            !requestBurnerAddMap[msg.sender][_burnerToAdd] &&\r\n                requestBurnerAddMap[_requester][_burnerToAdd]\r\n        );\r\n        requestBurnerAddMap[_requester][_burnerToAdd] = false;\r\n        addBurner(_burnerToAdd);\r\n    }\r\n\r\n    /** @dev Requests the removal of a burner.\r\n     *  @param _burnerToRemove Address of the burner requested to be removed.\r\n     */\r\n    function requestBurnerRemoval(address _burnerToRemove) external onlyBurner {\r\n        requestBurnerRemovalMap[msg.sender][_burnerToRemove] = true;\r\n    }\r\n\r\n    /** @dev Acceptance of the burner to be removed. Only a burner other than the requester can accept the request.\r\n     *  @param _requester Requester address.\r\n     *  @param _burnerToRemove Address of the burner to be removed.\r\n     */\r\n    function deleteBurnerAccepted(address _requester, address _burnerToRemove)\r\n        external\r\n        onlyBurner\r\n    {\r\n        require(\r\n            !requestBurnerRemovalMap[msg.sender][_burnerToRemove] &&\r\n                requestBurnerRemovalMap[_requester][_burnerToRemove]\r\n        );\r\n        requestBurnerRemovalMap[_requester][_burnerToRemove] = false;\r\n        isBurner[_burnerToRemove] = false;\r\n    }\r\n\r\n    /// @dev UBI burn request. This stores the parameters to be used when another burner accepts. It can be called again to update the values.\r\n    function requestBurnUBI() external onlyBurner {\r\n        currentAmountOutMin = getAmountOutMin();\r\n        currentBurnRequester = msg.sender;\r\n        emit BurnUBIRequested(msg.sender, currentAmountOutMin);\r\n    }\r\n\r\n    // ************************ //\r\n    // *      Burn            * //\r\n    // ************************ //\r\n\r\n    /** @dev Using the parameters stored by the requester, this function buys UBI with the ETH contract balance and freezes on this contract.\r\n     *  @param _deadline Unix timestamp after which the transaction will revert.\r\n     */\r\n    function burnUBI(uint256 _deadline) external onlyBurner {\r\n        uint256 _balanceToBurn = address(this).balance;\r\n        uint256 _amountOutMin = currentAmountOutMin;\r\n        // 0.1% less to avoid tx failure due to price decrease between request and approval\r\n        uint256 _amountOutMinToUse = _amountOutMin - (_amountOutMin / 1000);\r\n        address _burnRequester = currentBurnRequester;\r\n        require(_burnRequester != msg.sender && _burnRequester != address(0));\r\n        currentAmountOutMin = 0;\r\n        currentBurnRequester = address(0);\r\n        uint256[] memory amounts = IUniswapV2Router(UNISWAP_V2_ROUTER).swapExactETHForTokens{\r\n            value: _balanceToBurn\r\n        }(_amountOutMinToUse, path, address(this), _deadline);\r\n        emit Burned(_burnRequester, msg.sender, _balanceToBurn, amounts[1]);\r\n    }\r\n\r\n    /* Internal */\r\n\r\n    /** @dev Internal function to create a burner and emit an event.\r\n     *  @param _burner Burner to add.\r\n     */\r\n    function addBurner(address _burner) internal {\r\n        isBurner[_burner] = true;\r\n        emit BurnerAdded(_burner);\r\n    }\r\n\r\n    /** @dev Internal function to remove a burner and emit an event.\r\n     *  @param _burner Burner to delete.\r\n     */\r\n    function removeBurner(address _burner) internal {\r\n        isBurner[_burner] = false;\r\n        emit BurnerRemoved(_burner);\r\n    }\r\n\r\n    // ************************ //\r\n    // *       Getters        * //\r\n    // ************************ //\r\n\r\n    /** @dev Calculate the minimum UBI amount from swapping the ETH contract balance.\r\n     *  @return The minimum amount of output token that must be received.\r\n     */\r\n    function getAmountOutMin() public view returns (uint256) {\r\n        if (address(this).balance == 0) return 0;\r\n        uint256[] memory amountOutMins = IUniswapV2Router(UNISWAP_V2_ROUTER)\r\n            .getAmountsOut(address(this).balance, path);\r\n        return amountOutMins[1];\r\n    }\r\n\r\n    /** @dev UBI contract balance (burned UBI).\r\n     *  @return The amount of UBI burned.\r\n     */\r\n    function UBIburned() external view returns (uint256) {\r\n        return IUBI(UBI).balanceOf(address(this));\r\n    }\r\n\r\n    /* Fallback Function */\r\n\r\n    /// @dev Allows the contract to receive ETH\r\n    receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_burner2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_burner3\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"UBIAmount\",\"type\":\"uint256\"}],\"name\":\"BurnUBIRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burned\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"burner\",\"type\":\"address\"}],\"name\":\"BurnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"burner\",\"type\":\"address\"}],\"name\":\"BurnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_requester\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_burnerToAdd\",\"type\":\"address\"}],\"name\":\"AddBurnerAccepted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UBIburned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"burnUBI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentAmountOutMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentBurnRequester\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_requester\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_burnerToRemove\",\"type\":\"address\"}],\"name\":\"deleteBurnerAccepted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAmountOutMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBurner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestBurnUBI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_burnerToAdd\",\"type\":\"address\"}],\"name\":\"requestBurnerAdd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"requestBurnerAddMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_burnerToRemove\",\"type\":\"address\"}],\"name\":\"requestBurnerRemoval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"requestBurnerRemovalMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"UBIburner","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000002a52309edf998799c4a8b89324ccad91848c8676000000000000000000000000f49a19f72d0e106df462cfd6b5bebe42b6001616","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://62d1bc05d12efac6459f509f2df2c6807d2401fbae030e79e259202a9257b11e"}]}