{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.2;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of NFTs in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the NFT specified by `tokenId`.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     *\\n     *\\n     * Requirements:\\n     * - `from`, `to` cannot be zero.\\n     * - `tokenId` must be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this\\n     * NFT by either {approve} or {setApprovalForAll}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Requirements:\\n     * - If the caller is not `from`, it must be approved to move this NFT by\\n     * either {approve} or {setApprovalForAll}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n    function approve(address to, uint256 tokenId) external;\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICommunityRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport \\\"../interfaces/IERC20withDec.sol\\\";\\n\\ninterface ICommunityRewards is IERC721 {\\n  function rewardsToken() external view returns (IERC20withDec);\\n\\n  function claimableRewards(uint256 tokenId) external view returns (uint256 rewards);\\n\\n  function totalVestedAt(\\n    uint256 start,\\n    uint256 end,\\n    uint256 granted,\\n    uint256 cliffLength,\\n    uint256 vestingInterval,\\n    uint256 revokedAt,\\n    uint256 time\\n  ) external pure returns (uint256 rewards);\\n\\n  function grant(\\n    address recipient,\\n    uint256 amount,\\n    uint256 vestingLength,\\n    uint256 cliffLength,\\n    uint256 vestingInterval\\n  ) external returns (uint256 tokenId);\\n\\n  function loadRewards(uint256 rewards) external;\\n\\n  function revokeGrant(uint256 tokenId) external;\\n\\n  function getReward(uint256 tokenId) external;\\n\\n  event RewardAdded(uint256 reward);\\n  event Granted(\\n    address indexed user,\\n    uint256 indexed tokenId,\\n    uint256 amount,\\n    uint256 vestingLength,\\n    uint256 cliffLength,\\n    uint256 vestingInterval\\n  );\\n  event GrantRevoked(uint256 indexed tokenId, uint256 totalUnvested);\\n  event RewardPaid(address indexed user, uint256 indexed tokenId, uint256 reward);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20withDec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/*\\nOnly addition is the `decimals` function, which we need, and which both our Fidu and USDC use, along with most ERC20's.\\n*/\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20withDec is IERC20 {\\n  /**\\n   * @dev Returns the number of decimals used for the token\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMerkleDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n// solhint-disable-next-line max-line-length\\n// Adapted from https://github.com/Uniswap/merkle-distributor/blob/c3255bfa2b684594ecd562cacd7664b0f18330bf/contracts/interfaces/IMerkleDistributor.sol.\\npragma solidity 0.6.12;\\n\\n/// @notice Enables the granting of a CommunityRewards grant, if the grant details exist in this\\n/// contract's Merkle root.\\ninterface IMerkleDistributor {\\n  /// @notice Returns the address of the CommunityRewards contract whose grants are distributed by this contract.\\n  function communityRewards() external view returns (address);\\n\\n  /// @notice Returns the merkle root of the merkle tree containing grant details available to accept.\\n  function merkleRoot() external view returns (bytes32);\\n\\n  /// @notice Returns true if the index has been marked accepted.\\n  function isGrantAccepted(uint256 index) external view returns (bool);\\n\\n  /// @notice Causes the sender to accept the grant consisting of the given details. Reverts if\\n  /// the inputs (which includes who the sender is) are invalid.\\n  function acceptGrant(\\n    uint256 index,\\n    uint256 amount,\\n    uint256 vestingLength,\\n    uint256 cliffLength,\\n    uint256 vestingInterval,\\n    bytes32[] calldata merkleProof\\n  ) external;\\n\\n  /// @notice This event is triggered whenever a call to #acceptGrant succeeds.\\n  event GrantAccepted(\\n    uint256 indexed tokenId,\\n    uint256 indexed index,\\n    address indexed account,\\n    uint256 amount,\\n    uint256 vestingLength,\\n    uint256 cliffLength,\\n    uint256 vestingInterval\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/MerkleDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n// solhint-disable-next-line max-line-length\\n// Adapted from https://github.com/Uniswap/merkle-distributor/blob/c3255bfa2b684594ecd562cacd7664b0f18330bf/contracts/MerkleDistributor.sol.\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/MerkleProof.sol\\\";\\n\\nimport \\\"../interfaces/ICommunityRewards.sol\\\";\\nimport \\\"../interfaces/IMerkleDistributor.sol\\\";\\n\\ncontract MerkleDistributor is IMerkleDistributor {\\n  address public immutable override communityRewards;\\n  bytes32 public immutable override merkleRoot;\\n\\n  // @dev This is a packed array of booleans.\\n  mapping(uint256 => uint256) private acceptedBitMap;\\n\\n  constructor(address communityRewards_, bytes32 merkleRoot_) public {\\n    require(communityRewards_ != address(0), \\\"Cannot use the null address\\\");\\n    require(merkleRoot_ != 0, \\\"Invalid merkle root provided\\\");\\n    communityRewards = communityRewards_;\\n    merkleRoot = merkleRoot_;\\n  }\\n\\n  function isGrantAccepted(uint256 index) public view override returns (bool) {\\n    uint256 acceptedWordIndex = index / 256;\\n    uint256 acceptedBitIndex = index % 256;\\n    uint256 acceptedWord = acceptedBitMap[acceptedWordIndex];\\n    uint256 mask = (1 << acceptedBitIndex);\\n    return acceptedWord & mask == mask;\\n  }\\n\\n  function _setGrantAccepted(uint256 index) private {\\n    uint256 acceptedWordIndex = index / 256;\\n    uint256 acceptedBitIndex = index % 256;\\n    acceptedBitMap[acceptedWordIndex] = acceptedBitMap[acceptedWordIndex] | (1 << acceptedBitIndex);\\n  }\\n\\n  function acceptGrant(\\n    uint256 index,\\n    uint256 amount,\\n    uint256 vestingLength,\\n    uint256 cliffLength,\\n    uint256 vestingInterval,\\n    bytes32[] calldata merkleProof\\n  ) external override {\\n    require(!isGrantAccepted(index), \\\"Grant already accepted\\\");\\n\\n    // Verify the merkle proof.\\n    //\\n    /// @dev Per the Warning in\\n    /// https://github.com/ethereum/solidity/blob/v0.6.12/docs/abi-spec.rst#non-standard-packed-mode,\\n    /// it is important that no more than one of the arguments to `abi.encodePacked()` here be a\\n    /// dynamic type (see definition in\\n    /// https://github.com/ethereum/solidity/blob/v0.6.12/docs/abi-spec.rst#formal-specification-of-the-encoding).\\n    bytes32 node = keccak256(abi.encodePacked(index, msg.sender, amount, vestingLength, cliffLength, vestingInterval));\\n    require(MerkleProof.verify(merkleProof, merkleRoot, node), \\\"Invalid proof\\\");\\n\\n    // Mark it accepted and perform the granting.\\n    _setGrantAccepted(index);\\n    uint256 tokenId = ICommunityRewards(communityRewards).grant(\\n      msg.sender,\\n      amount,\\n      vestingLength,\\n      cliffLength,\\n      vestingInterval\\n    );\\n\\n    emit GrantAccepted(tokenId, index, msg.sender, amount, vestingLength, cliffLength, vestingInterval);\\n  }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"communityRewards_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot_\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestingLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cliffLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestingInterval\",\"type\":\"uint256\"}],\"name\":\"GrantAccepted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliffLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingInterval\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"acceptGrant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"communityRewards\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isGrantAccepted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MerkleDistributor","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"0000000000000000000000000cd73c18c085deb287257ed2307ec713e9af3460926446af7200bedeab4755e62ef8d73ac9409bde8e84d5e64a4677690cc9d9c5","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}