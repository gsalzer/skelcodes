{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/JanglesLPool.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\n\\n// File: @openzeppelin/contracts/ownership/Ownable.sol\\n\\npragma solidity ^0.8.0;\\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport './abstracts/Pausable.sol';\\n\\ncontract JangleTokenWrapper {\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) private _balances;\\n    IERC20 public stakedToken;\\n\\n    event Staked(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    string constant _transferErrorMessage = 'staked token transfer failed';\\n\\n    function stakeFor(address forWhom, uint128 amount) public payable virtual {\\n        IERC20 st = stakedToken;\\n        if (st == IERC20(address(0))) {\\n            //eth\\n            unchecked {\\n                totalSupply += msg.value;\\n                _balances[forWhom] += msg.value;\\n            }\\n        } else {\\n            require(msg.value == 0, 'non-zero eth');\\n            require(amount > 0, 'Cannot stake 0');\\n            require(\\n                st.transferFrom(msg.sender, address(this), amount),\\n                _transferErrorMessage\\n            );\\n            unchecked {\\n                totalSupply += amount;\\n                _balances[forWhom] += amount;\\n            }\\n        }\\n        emit Staked(forWhom, amount);\\n    }\\n\\n    function withdraw(uint128 amount) public virtual {\\n        require(amount <= _balances[msg.sender], 'withdraw: balance is lower');\\n        unchecked {\\n            _balances[msg.sender] -= amount;\\n            totalSupply = totalSupply - amount;\\n        }\\n        IERC20 st = stakedToken;\\n        if (st == IERC20(address(0))) {\\n            //eth\\n            (bool success, ) = msg.sender.call{value: amount}('');\\n            require(success, 'eth transfer failure');\\n        } else {\\n            require(\\n                stakedToken.transfer(msg.sender, amount),\\n                _transferErrorMessage\\n            );\\n        }\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n}\\n\\ncontract JanglesLPool is JangleTokenWrapper, OwnableUpgradeable, Pausable {\\n    IERC20 public rewardToken;\\n    uint256 public rewardRate;\\n    uint64 public periodFinish;\\n    uint64 public lastUpdateTime;\\n    uint128 public rewardPerTokenStored;\\n    struct UserRewards {\\n        uint128 userRewardPerTokenPaid;\\n        uint128 rewards;\\n    }\\n    mapping(address => UserRewards) public userRewards;\\n\\n    event RewardAdded(uint256 reward);\\n    event RewardPaid(address indexed user, uint256 reward);\\n\\n    //** Initialize functions */\\n    function initialize(address _rewardToken, address _stakedToken)\\n        public\\n        initializer\\n    {\\n        rewardToken = IERC20(_rewardToken);\\n        stakedToken = IERC20(_stakedToken);\\n        __Ownable_init(); // Contract creator becomes owner\\n        __Pausable_init(); // Contract creator becomes pauser\\n    }\\n\\n    modifier updateReward(address account) {\\n        uint128 _rewardPerTokenStored = rewardPerToken();\\n        lastUpdateTime = lastTimeRewardApplicable();\\n        rewardPerTokenStored = _rewardPerTokenStored;\\n        userRewards[account].rewards = earned(account);\\n        userRewards[account].userRewardPerTokenPaid = _rewardPerTokenStored;\\n        _;\\n    }\\n\\n    function lastTimeRewardApplicable() public view returns (uint64) {\\n        uint64 blockTimestamp = uint64(block.timestamp);\\n        return blockTimestamp < periodFinish ? blockTimestamp : periodFinish;\\n    }\\n\\n    function rewardPerToken() public view returns (uint128) {\\n        uint256 totalStakedSupply = totalSupply;\\n        if (totalStakedSupply == 0) {\\n            return rewardPerTokenStored;\\n        }\\n        unchecked {\\n            uint256 rewardDuration =\\n                lastTimeRewardApplicable() - lastUpdateTime;\\n            return\\n                uint128(\\n                    rewardPerTokenStored +\\n                        (rewardDuration * rewardRate * 1e18) /\\n                        totalStakedSupply\\n                );\\n        }\\n    }\\n\\n    function earned(address account) public view returns (uint128) {\\n        unchecked {\\n            return\\n                uint128(\\n                    (balanceOf(account) *\\n                        (rewardPerToken() -\\n                            userRewards[account].userRewardPerTokenPaid)) /\\n                        1e18 +\\n                        userRewards[account].rewards\\n                );\\n        }\\n    }\\n\\n    function stake(uint128 amount) external payable {\\n        stakeFor(msg.sender, amount);\\n    }\\n\\n    function stakeFor(address forWhom, uint128 amount)\\n        public\\n        payable\\n        override\\n        updateReward(forWhom)\\n    {\\n        super.stakeFor(forWhom, amount);\\n    }\\n\\n    function withdraw(uint128 amount) public override updateReward(msg.sender) {\\n        super.withdraw(amount);\\n    }\\n\\n    function exit() external {\\n        getReward();\\n        withdraw(uint128(balanceOf(msg.sender)));\\n    }\\n\\n    function getReward() public updateReward(msg.sender) {\\n        uint256 reward = earned(msg.sender);\\n        if (reward > 0) {\\n            userRewards[msg.sender].rewards = 0;\\n            require(\\n                rewardToken.transfer(msg.sender, reward),\\n                'reward transfer failed'\\n            );\\n            emit RewardPaid(msg.sender, reward);\\n        }\\n    }\\n\\n    function setRewardParams(uint128 reward, uint64 duration)\\n        external\\n        onlyOwner\\n    {\\n        unchecked {\\n            require(reward > 0);\\n            rewardPerTokenStored = rewardPerToken();\\n            uint64 blockTimestamp = uint64(block.timestamp);\\n            uint256 maxRewardSupply = rewardToken.balanceOf(address(this));\\n            if (rewardToken == stakedToken) maxRewardSupply -= totalSupply;\\n            uint256 leftover = 0;\\n            if (blockTimestamp >= periodFinish) {\\n                rewardRate = reward / duration;\\n            } else {\\n                uint256 remaining = periodFinish - blockTimestamp;\\n                leftover = remaining * rewardRate;\\n                rewardRate = (reward + leftover) / duration;\\n            }\\n            require(reward + leftover <= maxRewardSupply, 'not enough tokens');\\n            lastUpdateTime = blockTimestamp;\\n            periodFinish = blockTimestamp + duration;\\n            emit RewardAdded(reward);\\n        }\\n    }\\n\\n    function withdrawReward() external onlyOwner {\\n        uint256 rewardSupply = rewardToken.balanceOf(address(this));\\n        //ensure funds staked by users can't be transferred out\\n        if (rewardToken == stakedToken) rewardSupply -= totalSupply;\\n        require(rewardToken.transfer(msg.sender, rewardSupply));\\n        rewardRate = 0;\\n        periodFinish = uint64(block.timestamp);\\n    }\\n}\\n\\n/*\\n   ____            __   __        __   _\\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\\n _\\\\ \\\\ / // // _ \\\\/ __// _ \\\\/ -_)/ __// / \\\\ \\\\ /\\n/___/ \\\\_, //_//_/\\\\__//_//_/\\\\__/ \\\\__//_/ /_\\\\_\\\\\\n     /___/\\n\\n* Synthetix: YFIRewards.sol\\n*\\n* Docs: https://docs.synthetix.io/\\n*\\n*\\n* MIT License\\n* ===========\\n*\\n* Copyright (c) 2020 Synthetix\\n*\\n* Permission is hereby granted, free of charge, to any person obtaining a copy\\n* of this software and associated documentation files (the \\\"Software\\\"), to deal\\n* in the Software without restriction, including without limitation the rights\\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n* copies of the Software, and to permit persons to whom the Software is\\n* furnished to do so, subject to the following conditions:\\n*\\n* The above copyright notice and this permission notice shall be included in all\\n* copies or substantial portions of the Software.\\n*\\n* THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\n*/\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/abstracts/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an pauser) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the pauser account will be the one that deploys the contract. This\\n * can later be changed with {transferPausership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyPauser`, which can be applied to your functions to restrict their use to\\n * the pauser.\\n */\\nabstract contract Pausable is Initializable, ContextUpgradeable {\\n    address private _pauser;\\n    bool internal _paused;\\n\\n    event PausershipTransferred(\\n        address indexed previousPauser,\\n        address indexed newPauser\\n    );\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal initializer {\\n        _paused = false;\\n        _pauser = _msgSender();\\n        emit PausershipTransferred(address(0), _msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the pauser.\\n     */\\n    modifier whenNotPaused() {\\n        if (pauser() != _msgSender()) {\\n            require(_paused == false, 'Pauseable: Contract is paused');\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current pauser.\\n     */\\n    function pauser() public view virtual returns (address) {\\n        return _pauser;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the pauser.\\n     */\\n    modifier onlyPauser() {\\n        require(\\n            pauser() == _msgSender(),\\n            'Pauseable: caller is not the pauser'\\n        );\\n        _;\\n    }\\n\\n    /** Setters */\\n    function _setPaused(bool paused) external onlyPauser {\\n        _paused = paused;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without pauser. It will not be possible to call\\n     * `onlyPauser` functions anymore. Can only be called by the current pauser.\\n     *\\n     * NOTE: Renouncing pausership will leave the contract without an pauser,\\n     * thereby removing any functionality that is only available to the pauser.\\n     */\\n    function renouncePausership() public virtual onlyPauser {\\n        emit PausershipTransferred(_pauser, address(0));\\n        _pauser = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers pausership of the contract to a new account (`newPauser`).\\n     * Can only be called by the current pauser.\\n     */\\n    function transferPausership(address newPauser) public virtual onlyPauser {\\n        require(\\n            newPauser != address(0),\\n            'Pauseable: new pauser is the zero address'\\n        );\\n        emit PausershipTransferred(_pauser, newPauser);\\n        _pauser = newPauser;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 0\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousPauser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"PausershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"_setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakedToken\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePausership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"reward\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"duration\",\"type\":\"uint64\"}],\"name\":\"setRewardParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forWhom\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"stakeFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"transferPausership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewards\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"userRewardPerTokenPaid\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rewards\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"JanglesLPool","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}