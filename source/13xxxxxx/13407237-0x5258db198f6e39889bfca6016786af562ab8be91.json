{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/SafeMath.sol\r\n\r\n/*\r\n\r\n    Copyright 2020 DODO ZOO.\r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MUL_ERROR\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"DIVIDING_ERROR\");\r\n        return a / b;\r\n    }\r\n\r\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 quotient = div(a, b);\r\n        uint256 remainder = a - quotient * b;\r\n        if (remainder > 0) {\r\n            return quotient + 1;\r\n        } else {\r\n            return quotient;\r\n        }\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SUB_ERROR\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = x / 2 + 1;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/NFTPool/intf/IFilterAdmin.sol\r\n\r\n\r\ninterface IFilterAdmin {\r\n    function _OWNER_() external view returns (address);\r\n\r\n    function _CONTROLLER_() external view returns (address);\r\n\r\n    function init(\r\n        address owner,\r\n        uint256 initSupply,\r\n        string memory name,\r\n        string memory symbol,\r\n        uint256 feeRate,\r\n        address controller,\r\n        address maintainer,\r\n        address[] memory filters\r\n    ) external;\r\n\r\n    function mintFragTo(address to, uint256 rawAmount) external returns (uint256 received);\r\n\r\n    function burnFragFrom(address from, uint256 rawAmount) external returns (uint256 paid);\r\n\r\n    function queryMintFee(uint256 rawAmount)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 poolFee,\r\n            uint256 mtFee,\r\n            uint256 afterChargedAmount\r\n        );\r\n\r\n    function queryBurnFee(uint256 rawAmount)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 poolFee,\r\n            uint256 mtFee,\r\n            uint256 afterChargedAmount\r\n        );\r\n}\r\n\r\n// File: contracts/NFTPool/intf/IController.sol\r\n\r\ninterface IController {\r\n    function getMintFeeRate(address filterAdminAddr) external view returns (uint256);\r\n\r\n    function getBurnFeeRate(address filterAdminAddr) external view returns (uint256);\r\n\r\n    function isEmergencyWithdrawOpen(address filter) external view returns (bool);\r\n}\r\n\r\n// File: contracts/intf/IERC165.sol\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: contracts/intf/IERC1155.sol\r\n\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 id,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: contracts/intf/IERC1155Receiver.sol\r\n\r\n\r\n/**\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n        @dev Handles the receipt of a single ERC1155 token type. This function is\r\n        called at the end of a `safeTransferFrom` after the balance has been updated.\r\n        To accept the transfer, this must return\r\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n        (i.e. 0xf23a6e61, or its own function selector).\r\n        @param operator The address which initiated the transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param id The ID of the token being transferred\r\n        @param value The amount of tokens being transferred\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n        is called at the end of a `safeBatchTransferFrom` after the balances have\r\n        been updated. To accept the transfer(s), this must return\r\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n        (i.e. 0xbc197c81, or its own function selector).\r\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: contracts/lib/DecimalMath.sol\r\n\r\n\r\n/**\r\n * @title DecimalMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Functions for fixed point number with 18 decimals\r\n */\r\nlibrary DecimalMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant ONE = 10**18;\r\n    uint256 internal constant ONE2 = 10**36;\r\n\r\n    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d) / (10**18);\r\n    }\r\n\r\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d).divCeil(10**18);\r\n    }\r\n\r\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).div(d);\r\n    }\r\n\r\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).divCeil(d);\r\n    }\r\n\r\n    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).div(target);\r\n    }\r\n\r\n    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).divCeil(target);\r\n    }\r\n\r\n    function powFloor(uint256 target, uint256 e) internal pure returns (uint256) {\r\n        if (e == 0) {\r\n            return 10 ** 18;\r\n        } else if (e == 1) {\r\n            return target;\r\n        } else {\r\n            uint p = powFloor(target, e.div(2));\r\n            p = p.mul(p) / (10**18);\r\n            if (e % 2 == 1) {\r\n                p = p.mul(target) / (10**18);\r\n            }\r\n            return p;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/InitializableOwnable.sol\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @author DODO Breeder\r\n *\r\n * @notice Ownership related functions\r\n */\r\ncontract InitializableOwnable {\r\n    address public _OWNER_;\r\n    address public _NEW_OWNER_;\r\n    bool internal _INITIALIZED_;\r\n\r\n    // ============ Events ============\r\n\r\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier notInitialized() {\r\n        require(!_INITIALIZED_, \"DODO_INITIALIZED\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    function initOwner(address newOwner) public notInitialized {\r\n        _INITIALIZED_ = true;\r\n        _OWNER_ = newOwner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\r\n        _NEW_OWNER_ = newOwner;\r\n    }\r\n\r\n    function claimOwnership() public {\r\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\r\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\r\n        _OWNER_ = _NEW_OWNER_;\r\n        _NEW_OWNER_ = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ReentrancyGuard.sol\r\n\r\n\r\n/**\r\n * @title ReentrancyGuard\r\n * @author DODO Breeder\r\n *\r\n * @notice Protect functions from Reentrancy Attack\r\n */\r\ncontract ReentrancyGuard {\r\n    // https://solidity.readthedocs.io/en/latest/control-structures.html?highlight=zero-state#scoping-and-declarations\r\n    // zero-state of _ENTERED_ is false\r\n    bool private _ENTERED_;\r\n\r\n    modifier preventReentrant() {\r\n        require(!_ENTERED_, \"REENTRANT\");\r\n        _ENTERED_ = true;\r\n        _;\r\n        _ENTERED_ = false;\r\n    }\r\n}\r\n\r\n// File: contracts/NFTPool/impl/BaseFilterV1.sol\r\n\r\n\r\ncontract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    //=================== Event ===================\r\n    event NftInOrder(address user, uint256 receiveAmount);\r\n    event TargetOutOrder(address user, uint256 paidAmount);\r\n    event RandomOutOrder(address user, uint256 paidAmount);\r\n\r\n    event ChangeNFTInPrice(uint256 newGsStart, uint256 newCr, bool toggleFlag);\r\n    event ChangeNFTRandomOutPrice(uint256 newGsStart, uint256 newCr, bool toggleFlag);\r\n    event ChangeNFTTargetOutPrice(uint256 newGsStart, uint256 newCr, bool toggleFlag);\r\n    event ChangeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount);\r\n    event ChangeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd);\r\n    event ChangeTokenIdMap(uint256 tokenIds, bool isRegistered);\r\n    event ChangeFilterName(string newFilterName);\r\n\r\n    //=================== Storage ===================\r\n    string public _FILTER_NAME_;\r\n\r\n    address public _NFT_COLLECTION_;\r\n    uint256 public _NFT_ID_START_;\r\n    uint256 public _NFT_ID_END_ = uint256(-1);\r\n\r\n    //tokenId => isRegistered\r\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\r\n\r\n    //tokenId => amount\r\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\r\n\r\n    uint256[] public _NFT_IDS_;\r\n    //tokenId => index + 1 of _NFT_IDS_\r\n    mapping(uint256 => uint256) public _TOKENID_IDX_;\r\n    uint256 public _TOTAL_NFT_AMOUNT_;\r\n    uint256 public _MAX_NFT_AMOUNT_;\r\n    uint256 public _MIN_NFT_AMOUNT_;\r\n\r\n    // GS -> Geometric sequence\r\n    // CR -> Common Ratio\r\n\r\n    //For Deposit NFT IN to Pool\r\n    uint256 public _GS_START_IN_;\r\n    uint256 public _CR_IN_;\r\n    bool public _NFT_IN_TOGGLE_ = false;\r\n\r\n    //For NFT Random OUT from Pool\r\n    uint256 public _GS_START_RANDOM_OUT_;\r\n    uint256 public _CR_RANDOM_OUT_;\r\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\r\n\r\n    //For NFT Target OUT from Pool\r\n    uint256 public _GS_START_TARGET_OUT_;\r\n    uint256 public _CR_TARGET_OUT_;\r\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\r\n\r\n    modifier onlySuperOwner() {\r\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\r\n        _;\r\n    }\r\n\r\n    //==================== Query Prop ==================\r\n\r\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\r\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\r\n            return isNFTIDValid(nftId);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\r\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\r\n    }\r\n\r\n    function getAvaliableNFTInAmount() public view returns (uint256) {\r\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\r\n            return 0;\r\n        } else {\r\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\r\n        }\r\n    }\r\n\r\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\r\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\r\n            return 0;\r\n        } else {\r\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\r\n        }\r\n    }\r\n\r\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\r\n        require(_TOKENID_IDX_[tokenId] > 0, \"TOKEN_ID_NOT_EXSIT\");\r\n        return _TOKENID_IDX_[tokenId] - 1;\r\n    }\r\n\r\n    //==================== Query Price ==================\r\n\r\n    function queryNFTIn(uint256 NFTInAmount)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 rawReceive, \r\n            uint256 received\r\n        )\r\n    {\r\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\r\n        (rawReceive, received) = _queryNFTIn(_TOTAL_NFT_AMOUNT_,_TOTAL_NFT_AMOUNT_ + NFTInAmount);\r\n    }\r\n\r\n    function _queryNFTIn(uint256 start, uint256 end) internal view returns(uint256 rawReceive, uint256 received) {\r\n        rawReceive = _geometricCalc(\r\n            _GS_START_IN_,\r\n            _CR_IN_,\r\n            start,\r\n            end\r\n        );\r\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\r\n    }\r\n\r\n    function queryNFTTargetOut(uint256 NFTOutAmount)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 rawPay, \r\n            uint256 pay\r\n        )\r\n    {\r\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\r\n        (rawPay, pay) = _queryNFTTargetOut(_TOTAL_NFT_AMOUNT_ - NFTOutAmount, _TOTAL_NFT_AMOUNT_);\r\n    }\r\n\r\n    function _queryNFTTargetOut(uint256 start, uint256 end) internal view returns(uint256 rawPay, uint256 pay) {\r\n        rawPay = _geometricCalc(\r\n            _GS_START_TARGET_OUT_,\r\n            _CR_TARGET_OUT_,\r\n            start,\r\n            end\r\n        );\r\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\r\n    }\r\n\r\n    function queryNFTRandomOut(uint256 NFTOutAmount)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 rawPay, \r\n            uint256 pay\r\n        )\r\n    {\r\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\r\n        (rawPay, pay) = _queryNFTRandomOut(_TOTAL_NFT_AMOUNT_ - NFTOutAmount, _TOTAL_NFT_AMOUNT_);\r\n    }\r\n\r\n    function _queryNFTRandomOut(uint256 start, uint256 end) internal view returns(uint256 rawPay, uint256 pay) {\r\n        rawPay = _geometricCalc(\r\n            _GS_START_RANDOM_OUT_,\r\n            _CR_RANDOM_OUT_,\r\n            start,\r\n            end\r\n        );\r\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\r\n    }\r\n\r\n    // ============ Math =============\r\n\r\n    function _geometricCalc(\r\n        uint256 a0,\r\n        uint256 q,\r\n        uint256 start,\r\n        uint256 end\r\n    ) internal view returns (uint256) {\r\n        if (q == DecimalMath.ONE) {\r\n            return end.sub(start).mul(a0);\r\n        } \r\n        //q^n\r\n        uint256 qn = DecimalMath.powFloor(q, end);\r\n        //q^m\r\n        uint256 qm = DecimalMath.powFloor(q, start);\r\n        if (q < DecimalMath.ONE) {\r\n            //Sn=a0*(1 - q^n)/(1-q)\r\n            //Sn-Sm = a0*(q^m - q^n)/(1-q)\r\n            return a0.mul(qm.sub(qn)).div(DecimalMath.ONE.sub(q));\r\n        } else {\r\n            //Sn=a0*(q^n - 1)/(q - 1)\r\n            //Sn-Sm = a0*(q^n - q^m)/(q-1)  \r\n            return a0.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\r\n        }\r\n    }\r\n\r\n    function _getRandomNum() public view returns (uint256 randomNum) {\r\n        randomNum = uint256(\r\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\r\n        );\r\n    }\r\n\r\n    // ================= Ownable ================\r\n\r\n    function changeNFTInPrice(\r\n        uint256 newGsStart,\r\n        uint256 newCr,\r\n        bool toggleFlag\r\n    ) external onlySuperOwner {\r\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\r\n    }\r\n\r\n    function _changeNFTInPrice(\r\n        uint256 newGsStart,\r\n        uint256 newCr,\r\n        bool toggleFlag\r\n    ) internal {\r\n        require(newCr != 0, \"CR_INVALID\");\r\n        _GS_START_IN_ = newGsStart;\r\n        _CR_IN_ = newCr;\r\n        _NFT_IN_TOGGLE_ = toggleFlag;\r\n\r\n        emit ChangeNFTInPrice(newGsStart, newCr, toggleFlag);\r\n    }\r\n\r\n    function changeNFTRandomOutPrice(\r\n        uint256 newGsStart,\r\n        uint256 newCr,\r\n        bool toggleFlag\r\n    ) external onlySuperOwner {\r\n        _changeNFTRandomOutPrice(newGsStart, newCr, toggleFlag);\r\n    }\r\n\r\n    function _changeNFTRandomOutPrice(\r\n        uint256 newGsStart,\r\n        uint256 newCr,\r\n        bool toggleFlag\r\n    ) internal {\r\n        require(newCr != 0, \"CR_INVALID\");\r\n        _GS_START_RANDOM_OUT_ = newGsStart;\r\n        _CR_RANDOM_OUT_ = newCr;\r\n        _NFT_RANDOM_OUT_TOGGLE_ = toggleFlag;\r\n\r\n        emit ChangeNFTRandomOutPrice(newGsStart, newCr, toggleFlag);\r\n    }\r\n\r\n    function changeNFTTargetOutPrice(\r\n        uint256 newGsStart,\r\n        uint256 newCr,\r\n        bool toggleFlag\r\n    ) external onlySuperOwner {\r\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\r\n    }\r\n\r\n    function _changeNFTTargetOutPrice(\r\n        uint256 newGsStart,\r\n        uint256 newCr,\r\n        bool toggleFlag\r\n    ) internal {\r\n        require(newCr != 0, \"CR_INVALID\");\r\n        _GS_START_TARGET_OUT_ = newGsStart;\r\n        _CR_TARGET_OUT_ = newCr;\r\n        _NFT_TARGET_OUT_TOGGLE_ = toggleFlag;\r\n\r\n        emit ChangeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\r\n    }\r\n\r\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\r\n        external\r\n        onlySuperOwner\r\n    {\r\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\r\n    }\r\n\r\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\r\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\r\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\r\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\r\n\r\n        emit ChangeNFTAmountRange(maxNFTAmount, minNFTAmount);\r\n    }\r\n\r\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\r\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\r\n    }\r\n\r\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\r\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\r\n\r\n        _NFT_ID_START_ = nftIdStart;\r\n        _NFT_ID_END_ = nftIdEnd;\r\n\r\n        emit ChangeTokenIdRange(nftIdStart, nftIdEnd);\r\n    }\r\n\r\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\r\n        external\r\n        onlySuperOwner\r\n    {\r\n        _changeTokenIdMap(tokenIds, isRegistered);\r\n    }\r\n\r\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\r\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\r\n\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\r\n            emit ChangeTokenIdMap(tokenIds[i], isRegistered[i]);\r\n        }\r\n    }\r\n\r\n    function changeFilterName(string memory newFilterName)\r\n        external\r\n        onlySuperOwner\r\n    {\r\n        _changeFilterName(newFilterName);\r\n    }\r\n\r\n    function _changeFilterName(string memory newFilterName) internal {\r\n        _FILTER_NAME_ = newFilterName;\r\n        emit ChangeFilterName(newFilterName);\r\n    }\r\n\r\n\r\n    function resetFilter(\r\n        string memory filterName,\r\n        bool[] memory toggles,\r\n        uint256[] memory numParams, //0 - startId, 1 - endId, 2 - maxAmount, 3 - minAmount\r\n        uint256[] memory priceRules,\r\n        uint256[] memory spreadIds,\r\n        bool[] memory isRegistered\r\n    ) external onlySuperOwner {\r\n        _changeFilterName(filterName);\r\n        _changeNFTInPrice(priceRules[0], priceRules[1], toggles[0]);\r\n        _changeNFTRandomOutPrice(priceRules[2], priceRules[3], toggles[1]);\r\n        _changeNFTTargetOutPrice(priceRules[4], priceRules[5], toggles[2]);\r\n\r\n        _changeNFTAmountRange(numParams[2], numParams[3]);\r\n        _changeTokenIdRange(numParams[0], numParams[1]);\r\n\r\n        _changeTokenIdMap(spreadIds, isRegistered);\r\n    }\r\n}\r\n\r\n// File: contracts/NFTPool/impl/FilterERC1155V1.sol\r\n\r\n\r\n\r\ncontract FilterERC1155V1 is IERC1155Receiver, BaseFilterV1 {\r\n    using SafeMath for uint256;\r\n\r\n    //=============== Event ==================\r\n    event FilterInit(address filterAdmin, address nftCollection, string name);\r\n    event NftIn(uint256 tokenId, uint256 amount);\r\n    event TargetOut(uint256 tokenId, uint256 amount);\r\n    event RandomOut(uint256 tokenId, uint256 amount);\r\n    event EmergencyWithdraw(address nftContract,uint256 tokenId, uint256 amount, address to);\r\n\r\n    function init(\r\n        address filterAdmin,\r\n        address nftCollection,\r\n        bool[] memory toggles,\r\n        string memory filterName,\r\n        uint256[] memory numParams, //0 - startId, 1 - endId, 2 - maxAmount, 3 - minAmount\r\n        uint256[] memory priceRules,\r\n        uint256[] memory spreadIds\r\n    ) external {\r\n        initOwner(filterAdmin);\r\n        \r\n        _changeFilterName(filterName);\r\n        _NFT_COLLECTION_ = nftCollection;\r\n\r\n        _changeNFTInPrice(priceRules[0], priceRules[1], toggles[0]);\r\n        _changeNFTRandomOutPrice(priceRules[2], priceRules[3], toggles[1]);\r\n        _changeNFTTargetOutPrice(priceRules[4], priceRules[5], toggles[2]);\r\n\r\n        _changeNFTAmountRange(numParams[2], numParams[3]);\r\n\r\n        _changeTokenIdRange(numParams[0], numParams[1]);\r\n        for (uint256 i = 0; i < spreadIds.length; i++) {\r\n            _SPREAD_IDS_REGISTRY_[spreadIds[i]] = true;\r\n            emit ChangeTokenIdMap(spreadIds[i], true);\r\n        }\r\n\r\n        emit FilterInit(filterAdmin, nftCollection, filterName);\r\n    }\r\n\r\n    // ================= Trading ================\r\n\r\n    function ERC1155In(uint256[] memory tokenIds, address to)\r\n        external\r\n        preventReentrant\r\n        returns (uint256 received)\r\n    {\r\n        uint256 avaliableNFTInAmount = getAvaliableNFTInAmount();\r\n        uint256 originTotalNftAmount = _TOTAL_NFT_AMOUNT_;\r\n\r\n        uint256 totalAmount = 0;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            uint256 tokenId = tokenIds[i];\r\n            require(isNFTIDValid(tokenId), \"NFT_ID_NOT_SUPPORT\");\r\n            uint256 inAmount = _maintainERC1155In(tokenId);\r\n            totalAmount = totalAmount.add(inAmount);\r\n            emit NftIn(tokenId, inAmount);\r\n        }\r\n        require(totalAmount <= avaliableNFTInAmount, \"EXCEDD_IN_AMOUNT\");\r\n        (uint256 rawReceive, ) = _queryNFTIn(originTotalNftAmount, originTotalNftAmount + totalAmount);\r\n        received = IFilterAdmin(_OWNER_).mintFragTo(to, rawReceive);\r\n\r\n        emit NftInOrder(to, received);\r\n    }\r\n\r\n    function ERC1155TargetOut(\r\n        uint256[] memory tokenIds,\r\n        uint256[] memory amounts,\r\n        address to,\r\n        uint256 maxBurnAmount \r\n    ) external preventReentrant returns (uint256 paid) {\r\n        require(tokenIds.length == amounts.length, \"PARAM_INVALID\");\r\n        uint256 avaliableNFTOutAmount = getAvaliableNFTOutAmount();\r\n        uint256 originTotalNftAmount = _TOTAL_NFT_AMOUNT_;\r\n\r\n        uint256 totalAmount = 0;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            totalAmount = totalAmount.add(amounts[i]);\r\n            _transferOutERC1155(to, tokenIds[i], amounts[i]);\r\n            emit TargetOut(tokenIds[i], amounts[i]);\r\n        }\r\n        require(totalAmount <= avaliableNFTOutAmount, \"EXCEED_OUT_AMOUNT\");\r\n        (uint256 rawPay, ) = _queryNFTTargetOut(originTotalNftAmount - totalAmount, originTotalNftAmount);\r\n        paid = IFilterAdmin(_OWNER_).burnFragFrom(msg.sender, rawPay);\r\n        require(paid <= maxBurnAmount, \"BURN_AMOUNT_EXCEED\");\r\n\r\n        emit TargetOutOrder(msg.sender, paid);\r\n    }\r\n\r\n    function ERC1155RandomOut(uint256 amount, address to, uint256 maxBurnAmount)\r\n        external\r\n        preventReentrant\r\n        returns (uint256 paid)\r\n    {\r\n        (uint256 rawPay, ) = queryNFTRandomOut(amount);\r\n        paid = IFilterAdmin(_OWNER_).burnFragFrom(msg.sender, rawPay);\r\n        require(paid <= maxBurnAmount, \"BURN_AMOUNT_EXCEED\");\r\n\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            uint256 randomNum = _getRandomNum() % _TOTAL_NFT_AMOUNT_;\r\n            uint256 sum;\r\n            for (uint256 j = 0; j < _NFT_IDS_.length; j++) {\r\n                uint256 tokenId = _NFT_IDS_[j];\r\n                sum = sum.add(_NFT_RESERVE_[tokenId]);\r\n                if (sum >= randomNum) {\r\n                    _transferOutERC1155(to, tokenId, 1);\r\n                    emit RandomOut(tokenId, 1);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        emit RandomOutOrder(msg.sender, paid);\r\n    }\r\n\r\n    // ============ Transfer =============\r\n\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes calldata\r\n    ) external override returns (bytes4) {\r\n        return IERC1155Receiver.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] calldata,\r\n        uint256[] calldata,\r\n        bytes calldata\r\n    ) external override returns (bytes4) {\r\n        return IERC1155Receiver.onERC1155BatchReceived.selector;\r\n    }\r\n\r\n    function _transferOutERC1155(\r\n        address to,\r\n        uint256 tokenId,\r\n        uint256 amount\r\n    ) internal {\r\n        require(_TOKENID_IDX_[tokenId] > 0, \"TOKENID_NOT_EXIST\");\r\n        IERC1155(_NFT_COLLECTION_).safeTransferFrom(address(this), to, tokenId, amount, \"\");\r\n        _maintainERC1155Out(tokenId);\r\n    }\r\n\r\n    function emergencyWithdraw(\r\n        address[] memory nftContract,\r\n        uint256[] memory tokenIds,\r\n        uint256[] memory amounts,\r\n        address to\r\n    ) external onlySuperOwner {\r\n        require(\r\n            nftContract.length == tokenIds.length && nftContract.length == amounts.length,\r\n            \"PARAM_INVALID\"\r\n        );\r\n        address controller = IFilterAdmin(_OWNER_)._CONTROLLER_();\r\n        require(\r\n            IController(controller).isEmergencyWithdrawOpen(address(this)),\r\n            \"EMERGENCY_WITHDRAW_NOT_OPEN\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < nftContract.length; i++) {\r\n            uint256 tokenId = tokenIds[i];\r\n            IERC1155(nftContract[i]).safeTransferFrom(address(this), to, tokenId, amounts[i], \"\");\r\n            if (_NFT_RESERVE_[tokenId] > 0 && nftContract[i] == _NFT_COLLECTION_) {\r\n                _maintainERC1155Out(tokenId);\r\n            }\r\n            emit EmergencyWithdraw(nftContract[i],tokenIds[i], amounts[i], to);\r\n        }\r\n    }\r\n\r\n    function _maintainERC1155Out(uint256 tokenId) internal {\r\n        uint256 currentAmount = IERC1155(_NFT_COLLECTION_).balanceOf(address(this), tokenId);\r\n        uint256 outAmount = _NFT_RESERVE_[tokenId].sub(currentAmount);\r\n        _NFT_RESERVE_[tokenId] = currentAmount;\r\n        _TOTAL_NFT_AMOUNT_ = _TOTAL_NFT_AMOUNT_.sub(outAmount);\r\n        if (currentAmount == 0) {\r\n            uint256 index = _TOKENID_IDX_[tokenId] - 1;\r\n            if(index != _NFT_IDS_.length - 1) {\r\n                uint256 lastTokenId = _NFT_IDS_[_NFT_IDS_.length - 1];\r\n                _NFT_IDS_[index] = lastTokenId;\r\n                _TOKENID_IDX_[lastTokenId] = index + 1;\r\n            }\r\n            _NFT_IDS_.pop();\r\n            _TOKENID_IDX_[tokenId] = 0;\r\n        }\r\n    }\r\n\r\n    function _maintainERC1155In(uint256 tokenId) internal returns (uint256 inAmount) {\r\n        uint256 currentAmount = IERC1155(_NFT_COLLECTION_).balanceOf(address(this), tokenId);\r\n        inAmount = currentAmount.sub(_NFT_RESERVE_[tokenId]);\r\n        if (_NFT_RESERVE_[tokenId] == 0 && currentAmount > 0) {\r\n            _NFT_IDS_.push(tokenId);\r\n            _TOKENID_IDX_[tokenId] = _NFT_IDS_.length;\r\n        }\r\n        _NFT_RESERVE_[tokenId] = currentAmount;\r\n        _TOTAL_NFT_AMOUNT_ = _TOTAL_NFT_AMOUNT_.add(inAmount);\r\n    }\r\n\r\n    // ============ Support ============\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId;\r\n    }\r\n\r\n    function version() external pure virtual returns (string memory) {\r\n        return \"FILTER_1_ERC1155 1.0.0\";\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newFilterName\",\"type\":\"string\"}],\"name\":\"ChangeFilterName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxNFTAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minNFTAmount\",\"type\":\"uint256\"}],\"name\":\"ChangeNFTAmountRange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newGsStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCr\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"toggleFlag\",\"type\":\"bool\"}],\"name\":\"ChangeNFTInPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newGsStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCr\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"toggleFlag\",\"type\":\"bool\"}],\"name\":\"ChangeNFTRandomOutPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newGsStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCr\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"toggleFlag\",\"type\":\"bool\"}],\"name\":\"ChangeNFTTargetOutPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenIds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isRegistered\",\"type\":\"bool\"}],\"name\":\"ChangeTokenIdMap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftIdStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftIdEnd\",\"type\":\"uint256\"}],\"name\":\"ChangeTokenIdRange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"filterAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftCollection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"FilterInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NftIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receiveAmount\",\"type\":\"uint256\"}],\"name\":\"NftInOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferPrepared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RandomOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"}],\"name\":\"RandomOutOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TargetOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"}],\"name\":\"TargetOutOrder\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ERC1155In\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxBurnAmount\",\"type\":\"uint256\"}],\"name\":\"ERC1155RandomOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxBurnAmount\",\"type\":\"uint256\"}],\"name\":\"ERC1155TargetOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_CR_IN_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_CR_RANDOM_OUT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_CR_TARGET_OUT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_FILTER_NAME_\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_GS_START_IN_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_GS_START_RANDOM_OUT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_GS_START_TARGET_OUT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MAX_NFT_AMOUNT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MIN_NFT_AMOUNT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NEW_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NFT_COLLECTION_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_NFT_IDS_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NFT_ID_END_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NFT_ID_START_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NFT_IN_TOGGLE_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NFT_RANDOM_OUT_TOGGLE_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_NFT_RESERVE_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NFT_TARGET_OUT_TOGGLE_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_SPREAD_IDS_REGISTRY_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_TOKENID_IDX_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TOTAL_NFT_AMOUNT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getRandomNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"randomNum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newFilterName\",\"type\":\"string\"}],\"name\":\"changeFilterName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxNFTAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minNFTAmount\",\"type\":\"uint256\"}],\"name\":\"changeNFTAmountRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGsStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newCr\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"toggleFlag\",\"type\":\"bool\"}],\"name\":\"changeNFTInPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGsStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newCr\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"toggleFlag\",\"type\":\"bool\"}],\"name\":\"changeNFTRandomOutPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGsStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newCr\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"toggleFlag\",\"type\":\"bool\"}],\"name\":\"changeNFTTargetOutPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"isRegistered\",\"type\":\"bool[]\"}],\"name\":\"changeTokenIdMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftIdStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftIdEnd\",\"type\":\"uint256\"}],\"name\":\"changeTokenIdRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"nftContract\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvaliableNFTInAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvaliableNFTOutAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getNFTIndexById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"filterAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftCollection\",\"type\":\"address\"},{\"internalType\":\"bool[]\",\"name\":\"toggles\",\"type\":\"bool[]\"},{\"internalType\":\"string\",\"name\":\"filterName\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"numParams\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"priceRules\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"spreadIds\",\"type\":\"uint256[]\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"initOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"isNFTIDValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftCollectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"isNFTValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"NFTInAmount\",\"type\":\"uint256\"}],\"name\":\"queryNFTIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rawReceive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"NFTOutAmount\",\"type\":\"uint256\"}],\"name\":\"queryNFTRandomOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rawPay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pay\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"NFTOutAmount\",\"type\":\"uint256\"}],\"name\":\"queryNFTTargetOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rawPay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pay\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filterName\",\"type\":\"string\"},{\"internalType\":\"bool[]\",\"name\":\"toggles\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"numParams\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"priceRules\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"spreadIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"isRegistered\",\"type\":\"bool[]\"}],\"name\":\"resetFilter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"FilterERC1155V1","CompilerVersion":"v0.6.9+commit.3e3065ac","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7e87a0ea668c48b8057c91bf2a5c20d974e05de3550c0519cb7c4a04f70933fd"}]}