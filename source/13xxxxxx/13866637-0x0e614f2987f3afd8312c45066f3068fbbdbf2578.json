{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/staking/PremiaStakingWithFeeDiscount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IERC20} from \\\"@solidstate/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport {SafeCast} from \\\"@solidstate/contracts/utils/SafeCast.sol\\\";\\r\\nimport {IERC2612} from \\\"@solidstate/contracts/token/ERC20/permit/IERC2612.sol\\\";\\r\\n\\r\\nimport {PremiaStaking} from \\\"./PremiaStaking.sol\\\";\\r\\nimport {FeeDiscount} from \\\"./FeeDiscount.sol\\\";\\r\\nimport {FeeDiscountStorage} from \\\"./FeeDiscountStorage.sol\\\";\\r\\n\\r\\nimport {IPremiaStakingOld} from \\\"./IPremiaStakingOld.sol\\\";\\r\\nimport {IPremiaStakingWithFeeDiscount} from \\\"./IPremiaStakingWithFeeDiscount.sol\\\";\\r\\n\\r\\ncontract PremiaStakingWithFeeDiscount is\\r\\n    IPremiaStakingWithFeeDiscount,\\r\\n    PremiaStaking,\\r\\n    FeeDiscount\\r\\n{\\r\\n    using SafeCast for uint256;\\r\\n\\r\\n    // The old PremiaFeeDiscount contract\\r\\n    address private immutable OLD_FEE_DISCOUNT;\\r\\n    // The old PremiaStaking contract\\r\\n    address private immutable OLD_STAKING;\\r\\n\\r\\n    constructor(\\r\\n        address premia,\\r\\n        address oldFeeDiscount,\\r\\n        address oldStaking\\r\\n    ) PremiaStaking(premia) FeeDiscount(address(this)) {\\r\\n        OLD_FEE_DISCOUNT = oldFeeDiscount;\\r\\n        OLD_STAKING = oldStaking;\\r\\n    }\\r\\n\\r\\n    function _transferXPremia(\\r\\n        address holder,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        _transfer(holder, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Migrate old xPremia from old FeeDiscount contract to new xPremia\\r\\n     * @param user User for whom to migrate\\r\\n     * @param amount Amount of old xPremia to migrate\\r\\n     * @param stakePeriod Stake period selected in old contract\\r\\n     * @param lockedUntil Lock end date from old contract\\r\\n     */\\r\\n    function migrate(\\r\\n        address user,\\r\\n        uint256 amount,\\r\\n        uint256 stakePeriod,\\r\\n        uint256 lockedUntil\\r\\n    ) external {\\r\\n        require(msg.sender == OLD_FEE_DISCOUNT, \\\"Not authorized\\\");\\r\\n\\r\\n        (uint256 premiaDeposited, uint256 xPremiaMinted) = _migrateWithoutLock(\\r\\n            amount,\\r\\n            address(this)\\r\\n        );\\r\\n\\r\\n        emit Deposit(user, premiaDeposited);\\r\\n\\r\\n        FeeDiscountStorage.Layout storage l = FeeDiscountStorage.layout();\\r\\n        FeeDiscountStorage.UserInfo storage userInfo = l.userInfo[user];\\r\\n\\r\\n        uint64 _lockedUntil = lockedUntil.toUint64();\\r\\n        uint64 _stakePeriod = stakePeriod.toUint64();\\r\\n\\r\\n        userInfo.balance += xPremiaMinted;\\r\\n\\r\\n        if (_lockedUntil > userInfo.lockedUntil) {\\r\\n            userInfo.lockedUntil = lockedUntil.toUint64();\\r\\n        }\\r\\n\\r\\n        if (_stakePeriod > userInfo.stakePeriod) {\\r\\n            userInfo.stakePeriod = stakePeriod.toUint64();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Migrate old xPremia to new xPremia using IERC2612 permit\\r\\n     * @param amount Amount of old xPremia to migrate\\r\\n     * @param deadline Deadline after which permit will fail\\r\\n     * @param v V\\r\\n     * @param r R\\r\\n     * @param s S\\r\\n     */\\r\\n    function migrateWithoutLockWithPermit(\\r\\n        uint256 amount,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 premiaDeposited, uint256 xPremiaMinted) {\\r\\n        IERC2612(address(OLD_STAKING)).permit(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            amount,\\r\\n            deadline,\\r\\n            v,\\r\\n            r,\\r\\n            s\\r\\n        );\\r\\n        (premiaDeposited, xPremiaMinted) = _migrateWithoutLock(\\r\\n            amount,\\r\\n            msg.sender\\r\\n        );\\r\\n        emit Deposit(msg.sender, premiaDeposited);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Migrate old xPremia to new xPremia\\r\\n     * @param amount Amount of old xPremia to migrate\\r\\n     * @return premiaDeposited Amount of premia deposited\\r\\n     * @return xPremiaMinted Amount of xPremia minted\\r\\n     */\\r\\n    function migrateWithoutLock(uint256 amount)\\r\\n        external\\r\\n        returns (uint256 premiaDeposited, uint256 xPremiaMinted)\\r\\n    {\\r\\n        (premiaDeposited, xPremiaMinted) = _migrateWithoutLock(\\r\\n            amount,\\r\\n            msg.sender\\r\\n        );\\r\\n        emit Deposit(msg.sender, premiaDeposited);\\r\\n    }\\r\\n\\r\\n    function _migrateWithoutLock(uint256 amount, address to)\\r\\n        internal\\r\\n        returns (uint256 premiaDeposited, uint256 xPremiaMinted)\\r\\n    {\\r\\n        _updateRewards();\\r\\n\\r\\n        // Gets the amount of Premia locked in the contract\\r\\n        uint256 totalPremia = _getStakedPremiaAmount();\\r\\n\\r\\n        //\\r\\n\\r\\n        IERC20(OLD_STAKING).transferFrom(msg.sender, address(this), amount);\\r\\n\\r\\n        uint256 oldPremiaBalance = IERC20(PREMIA).balanceOf(address(this));\\r\\n        IPremiaStakingOld(OLD_STAKING).leave(amount);\\r\\n        uint256 newPremiaBalance = IERC20(PREMIA).balanceOf(address(this));\\r\\n\\r\\n        uint256 toDeposit = newPremiaBalance - oldPremiaBalance;\\r\\n\\r\\n        return (toDeposit, _mintShares(to, toDeposit, totalPremia));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20Internal } from './IERC20Internal.sol';\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 is IERC20Internal {\\n    /**\\n     * @notice query the total minted token supply\\n     * @return token supply\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice query the token balance of given account\\n     * @param account address to query\\n     * @return token balance\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @notice query the allowance granted from given holder to given spender\\n     * @param holder approver of allowance\\n     * @param spender recipient of allowance\\n     * @return token allowance\\n     */\\n    function allowance(address holder, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice grant approval to spender to spend tokens\\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\\n     * @param spender recipient of allowance\\n     * @param amount quantity of tokens approved for spending\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @notice transfer tokens to given recipient\\n     * @param recipient beneficiary of token transfer\\n     * @param amount quantity of tokens to transfer\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @notice transfer tokens to given recipient on behalf of given holder\\n     * @param holder holder of tokens prior to transfer\\n     * @param recipient beneficiary of token transfer\\n     * @param amount quantity of tokens to transfer\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function transferFrom(\\n        address holder,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Helper library for safe casting of uint and int values\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary SafeCast {\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, 'SafeCast: value does not fit');\\n        return uint224(value);\\n    }\\n\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, 'SafeCast: value does not fit');\\n        return uint128(value);\\n    }\\n\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, 'SafeCast: value does not fit');\\n        return uint96(value);\\n    }\\n\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, 'SafeCast: value does not fit');\\n        return uint64(value);\\n    }\\n\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, 'SafeCast: value does not fit');\\n        return uint32(value);\\n    }\\n\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, 'SafeCast: value does not fit');\\n        return uint16(value);\\n    }\\n\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, 'SafeCast: value does not fit');\\n        return uint8(value);\\n    }\\n\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, 'SafeCast: value must be positive');\\n        return uint256(value);\\n    }\\n\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(\\n            value >= type(int128).min && value <= type(int128).max,\\n            'SafeCast: value does not fit'\\n        );\\n        return int128(value);\\n    }\\n\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(\\n            value >= type(int64).min && value <= type(int64).max,\\n            'SafeCast: value does not fit'\\n        );\\n        return int64(value);\\n    }\\n\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(\\n            value >= type(int32).min && value <= type(int32).max,\\n            'SafeCast: value does not fit'\\n        );\\n        return int32(value);\\n    }\\n\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(\\n            value >= type(int16).min && value <= type(int16).max,\\n            'SafeCast: value does not fit'\\n        );\\n        return int16(value);\\n    }\\n\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(\\n            value >= type(int8).min && value <= type(int8).max,\\n            'SafeCast: value does not fit'\\n        );\\n        return int8(value);\\n    }\\n\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(\\n            value <= uint256(type(int256).max),\\n            'SafeCast: value does not fit'\\n        );\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/permit/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice ERC2612 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-2612.\\n */\\ninterface IERC2612 {\\n    /**\\n     * @notice approve spender to transfer tokens held by owner via signature\\n     * @dev this function may be vulnerable to approval replay attacks\\n     * @param owner holder of tokens and signer of permit\\n     * @param spender beneficiary of approval\\n     * @param amount quantity of tokens to approve\\n     * @param v secp256k1 'v' value\\n     * @param r secp256k1 'r' value\\n     * @param s secp256k1 's' value\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @notice get the current ERC2612 nonce for the given address\\n     * @return current nonce\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/PremiaStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IERC20} from \\\"@solidstate/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport {ERC20} from \\\"@solidstate/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport {IERC2612} from \\\"@solidstate/contracts/token/ERC20/permit/IERC2612.sol\\\";\\r\\nimport {ERC20Permit} from \\\"@solidstate/contracts/token/ERC20/permit/ERC20Permit.sol\\\";\\r\\nimport {SafeERC20} from \\\"@solidstate/contracts/utils/SafeERC20.sol\\\";\\r\\n\\r\\nimport {ABDKMath64x64} from \\\"abdk-libraries-solidity/ABDKMath64x64.sol\\\";\\r\\n\\r\\nimport {ABDKMath64x64Token} from \\\"../libraries/ABDKMath64x64Token.sol\\\";\\r\\nimport {IPremiaStaking} from \\\"./IPremiaStaking.sol\\\";\\r\\nimport {PremiaStakingStorage} from \\\"./PremiaStakingStorage.sol\\\";\\r\\n\\r\\ncontract PremiaStaking is IPremiaStaking, ERC20, ERC20Permit {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using ABDKMath64x64 for int128;\\r\\n\\r\\n    address internal immutable PREMIA;\\r\\n\\r\\n    int128 internal constant ONE_64x64 = 0x10000000000000000;\\r\\n    int128 internal constant DECAY_RATE_64x64 = 0x487a423b63e; // 2.7e-7\\r\\n\\r\\n    constructor(address premia) {\\r\\n        PREMIA = premia;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function addRewards(uint256 amount) external override {\\r\\n        _updateRewards();\\r\\n\\r\\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\\r\\n\\r\\n        IERC20(PREMIA).safeTransferFrom(msg.sender, address(this), amount);\\r\\n        l.availableRewards += amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function getAvailableRewards() external view override returns (uint256) {\\r\\n        return PremiaStakingStorage.layout().availableRewards;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function getPendingRewards() external view override returns (uint256) {\\r\\n        return _getPendingRewards();\\r\\n    }\\r\\n\\r\\n    function _getPendingRewards() internal view returns (uint256) {\\r\\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\\r\\n        return\\r\\n            l.availableRewards -\\r\\n            _decay(l.availableRewards, l.lastRewardUpdate, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function _updateRewards() internal {\\r\\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\\r\\n\\r\\n        if (l.lastRewardUpdate == 0) {\\r\\n            l.lastRewardUpdate = block.timestamp;\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        if (l.availableRewards == 0) return;\\r\\n\\r\\n        l.availableRewards -= _getPendingRewards();\\r\\n        l.lastRewardUpdate = block.timestamp;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function depositWithPermit(\\r\\n        uint256 amount,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external override {\\r\\n        IERC2612(PREMIA).permit(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            amount,\\r\\n            deadline,\\r\\n            v,\\r\\n            r,\\r\\n            s\\r\\n        );\\r\\n        _deposit(amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function deposit(uint256 amount) external override {\\r\\n        _deposit(amount);\\r\\n    }\\r\\n\\r\\n    function _deposit(uint256 amount) internal {\\r\\n        _updateRewards();\\r\\n\\r\\n        // Gets the amount of Premia locked in the contract\\r\\n        uint256 totalPremia = _getStakedPremiaAmount();\\r\\n\\r\\n        _mintShares(msg.sender, amount, totalPremia);\\r\\n\\r\\n        // Lock the Premia in the contract\\r\\n        IERC20(PREMIA).safeTransferFrom(msg.sender, address(this), amount);\\r\\n\\r\\n        emit Deposit(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function _mintShares(\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 totalPremia\\r\\n    ) internal returns (uint256) {\\r\\n        // Gets the amount of xPremia in existence\\r\\n        uint256 totalShares = _totalSupply();\\r\\n        // If no xPremia exists, mint it 1:1 to the amount put in\\r\\n        if (totalShares == 0 || totalPremia == 0) {\\r\\n            _mint(to, amount);\\r\\n            return amount;\\r\\n        }\\r\\n        // Calculate and mint the amount of xPremia the Premia is worth. The ratio will change overtime, as xPremia is burned/minted and Premia deposited + gained from fees / withdrawn.\\r\\n        else {\\r\\n            uint256 shares = (amount * totalShares) / totalPremia;\\r\\n            _mint(to, shares);\\r\\n            return shares;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function startWithdraw(uint256 amount) external override {\\r\\n        _updateRewards();\\r\\n\\r\\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\\r\\n\\r\\n        // Gets the amount of xPremia in existence\\r\\n        uint256 totalShares = _totalSupply();\\r\\n\\r\\n        // Calculates the amount of Premia the xPremia is worth\\r\\n        uint256 premiaAmount = (amount * _getStakedPremiaAmount()) /\\r\\n            totalShares;\\r\\n        _burn(msg.sender, amount);\\r\\n        l.pendingWithdrawal += premiaAmount;\\r\\n\\r\\n        l.withdrawals[msg.sender].amount += premiaAmount;\\r\\n        l.withdrawals[msg.sender].startDate = block.timestamp;\\r\\n\\r\\n        emit StartWithdrawal(msg.sender, premiaAmount, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function withdraw() external override {\\r\\n        _updateRewards();\\r\\n\\r\\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\\r\\n\\r\\n        uint256 startDate = l.withdrawals[msg.sender].startDate;\\r\\n\\r\\n        require(startDate > 0, \\\"No pending withdrawal\\\");\\r\\n        require(\\r\\n            block.timestamp > startDate + l.withdrawalDelay,\\r\\n            \\\"Withdrawal still pending\\\"\\r\\n        );\\r\\n\\r\\n        uint256 amount = l.withdrawals[msg.sender].amount;\\r\\n\\r\\n        l.pendingWithdrawal -= amount;\\r\\n        delete l.withdrawals[msg.sender];\\r\\n\\r\\n        IERC20(PREMIA).safeTransfer(msg.sender, amount);\\r\\n\\r\\n        emit Withdrawal(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function getWithdrawalDelay() external view override returns (uint256) {\\r\\n        return PremiaStakingStorage.layout().withdrawalDelay;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function setWithdrawalDelay(uint256 delay) external override {\\r\\n        PremiaStakingStorage.layout().withdrawalDelay = delay;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function getXPremiaToPremiaRatio()\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            ((_getStakedPremiaAmount() + _getPendingRewards()) * 1e18) /\\r\\n            _totalSupply();\\r\\n    }\\r\\n\\r\\n    function getPendingWithdrawal(address user)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (\\r\\n            uint256 amount,\\r\\n            uint256 startDate,\\r\\n            uint256 unlockDate\\r\\n        )\\r\\n    {\\r\\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\\r\\n        amount = l.withdrawals[user].amount;\\r\\n        startDate = l.withdrawals[user].startDate;\\r\\n        unlockDate = startDate + l.withdrawalDelay;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function getStakedPremiaAmount() external view override returns (uint256) {\\r\\n        return _getStakedPremiaAmount() + _getPendingRewards();\\r\\n    }\\r\\n\\r\\n    function _getStakedPremiaAmount() internal view returns (uint256) {\\r\\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\\r\\n        return\\r\\n            IERC20(PREMIA).balanceOf(address(this)) -\\r\\n            l.pendingWithdrawal -\\r\\n            l.availableRewards;\\r\\n    }\\r\\n\\r\\n    function _decay(\\r\\n        uint256 pendingRewards,\\r\\n        uint256 oldTimestamp,\\r\\n        uint256 newTimestamp\\r\\n    ) internal pure returns (uint256) {\\r\\n        return\\r\\n            ONE_64x64\\r\\n                .sub(DECAY_RATE_64x64)\\r\\n                .pow(newTimestamp - oldTimestamp)\\r\\n                .mulu(pendingRewards);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/staking/FeeDiscount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {SafeCast} from \\\"@solidstate/contracts/utils/SafeCast.sol\\\";\\r\\nimport {IERC20, SafeERC20} from \\\"@solidstate/contracts/utils/SafeERC20.sol\\\";\\r\\nimport {IERC2612} from \\\"@solidstate/contracts/token/ERC20/permit/IERC2612.sol\\\";\\r\\n\\r\\nimport {FeeDiscountStorage} from \\\"./FeeDiscountStorage.sol\\\";\\r\\nimport {IFeeDiscount} from \\\"./IFeeDiscount.sol\\\";\\r\\n\\r\\n/**\\r\\n * @author Premia\\r\\n * @title A contract allowing you to lock xPremia to get Premia protocol fee discounts\\r\\n */\\r\\ncontract FeeDiscount is IFeeDiscount {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeCast for uint256;\\r\\n\\r\\n    address internal immutable xPREMIA;\\r\\n    uint256 internal constant INVERSE_BASIS_POINT = 1e4;\\r\\n\\r\\n    constructor(address xPremia) {\\r\\n        xPREMIA = xPremia;\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    //////////\\r\\n    // Main //\\r\\n    //////////\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function stakeWithPermit(\\r\\n        uint256 amount,\\r\\n        uint256 period,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external {\\r\\n        IERC2612(address(xPREMIA)).permit(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            amount,\\r\\n            deadline,\\r\\n            v,\\r\\n            r,\\r\\n            s\\r\\n        );\\r\\n        _stake(amount, period);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function stake(uint256 amount, uint256 period) external override {\\r\\n        _stake(amount, period);\\r\\n    }\\r\\n\\r\\n    function _stake(uint256 amount, uint256 period) internal {\\r\\n        FeeDiscountStorage.Layout storage l = FeeDiscountStorage.layout();\\r\\n\\r\\n        require(\\r\\n            _getStakePeriodMultiplier(period) > 0,\\r\\n            \\\"Stake period does not exists\\\"\\r\\n        );\\r\\n        FeeDiscountStorage.UserInfo storage user = l.userInfo[msg.sender];\\r\\n\\r\\n        uint256 lockedUntil = block.timestamp + period;\\r\\n        require(\\r\\n            lockedUntil > user.lockedUntil,\\r\\n            \\\"Cannot add stake with lower stake period\\\"\\r\\n        );\\r\\n\\r\\n        _transferXPremia(msg.sender, address(this), amount);\\r\\n        user.balance = user.balance + amount;\\r\\n        user.lockedUntil = lockedUntil.toUint64();\\r\\n        user.stakePeriod = period.toUint64();\\r\\n\\r\\n        emit Staked(msg.sender, amount, period, lockedUntil);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function unstake(uint256 amount) external override {\\r\\n        FeeDiscountStorage.Layout storage l = FeeDiscountStorage.layout();\\r\\n\\r\\n        FeeDiscountStorage.UserInfo storage user = l.userInfo[msg.sender];\\r\\n\\r\\n        // We allow unstake if the stakePeriod that the user used has been disabled\\r\\n        require(user.lockedUntil <= block.timestamp, \\\"Stake still locked\\\");\\r\\n\\r\\n        user.balance -= amount;\\r\\n        _transferXPremia(address(this), msg.sender, amount);\\r\\n\\r\\n        emit Unstaked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    //////////\\r\\n    // View //\\r\\n    //////////\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function getStakeAmountWithBonus(address user)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getStakeAmountWithBonus(user);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function getDiscount(address user)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 userBalance = _getStakeAmountWithBonus(user);\\r\\n\\r\\n        IFeeDiscount.StakeLevel[] memory stakeLevels = _getStakeLevels();\\r\\n\\r\\n        for (uint256 i = 0; i < stakeLevels.length; i++) {\\r\\n            IFeeDiscount.StakeLevel memory level = stakeLevels[i];\\r\\n\\r\\n            if (userBalance < level.amount) {\\r\\n                uint256 amountPrevLevel;\\r\\n                uint256 discountPrevLevel;\\r\\n\\r\\n                // If stake is lower, user is in this level, and we need to LERP with prev level to get discount value\\r\\n                if (i > 0) {\\r\\n                    amountPrevLevel = stakeLevels[i - 1].amount;\\r\\n                    discountPrevLevel = stakeLevels[i - 1].discount;\\r\\n                } else {\\r\\n                    // If this is the first level, prev level is 0 / 0\\r\\n                    amountPrevLevel = 0;\\r\\n                    discountPrevLevel = 0;\\r\\n                }\\r\\n\\r\\n                uint256 remappedDiscount = level.discount - discountPrevLevel;\\r\\n\\r\\n                uint256 remappedAmount = level.amount - amountPrevLevel;\\r\\n                uint256 remappedBalance = userBalance - amountPrevLevel;\\r\\n                uint256 levelProgress = (remappedBalance *\\r\\n                    INVERSE_BASIS_POINT) / remappedAmount;\\r\\n\\r\\n                return\\r\\n                    discountPrevLevel +\\r\\n                    ((remappedDiscount * levelProgress) / INVERSE_BASIS_POINT);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // If no match found it means user is >= max possible stake, and therefore has max discount possible\\r\\n        return stakeLevels[stakeLevels.length - 1].discount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function getStakeLevels()\\r\\n        external\\r\\n        pure\\r\\n        override\\r\\n        returns (IFeeDiscount.StakeLevel[] memory stakeLevels)\\r\\n    {\\r\\n        return _getStakeLevels();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function getStakePeriodMultiplier(uint256 period)\\r\\n        external\\r\\n        pure\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getStakePeriodMultiplier(period);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function getUserInfo(address user)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (FeeDiscountStorage.UserInfo memory)\\r\\n    {\\r\\n        return FeeDiscountStorage.layout().userInfo[user];\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    //////////////\\r\\n    // Internal //\\r\\n    //////////////\\r\\n\\r\\n    /**\\r\\n     * @notice Utility function to check if a value is inside an array\\r\\n     * @param value The value to look for\\r\\n     * @param array The array to check\\r\\n     * @return Whether the value is in the array or not\\r\\n     */\\r\\n    function _isInArray(uint256 value, uint256[] memory array)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool)\\r\\n    {\\r\\n        uint256 length = array.length;\\r\\n        for (uint256 i = 0; i < length; ++i) {\\r\\n            if (array[i] == value) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function _getStakeLevels()\\r\\n        internal\\r\\n        pure\\r\\n        returns (IFeeDiscount.StakeLevel[] memory stakeLevels)\\r\\n    {\\r\\n        stakeLevels = new IFeeDiscount.StakeLevel[](4);\\r\\n\\r\\n        stakeLevels[0] = IFeeDiscount.StakeLevel(5000 * 1e18, 2500); // -25%\\r\\n        stakeLevels[1] = IFeeDiscount.StakeLevel(50000 * 1e18, 5000); // -50%\\r\\n        stakeLevels[2] = IFeeDiscount.StakeLevel(250000 * 1e18, 7500); // -75%\\r\\n        stakeLevels[3] = IFeeDiscount.StakeLevel(500000 * 1e18, 9500); // -95%\\r\\n    }\\r\\n\\r\\n    function _getStakePeriodMultiplier(uint256 period)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        if (period == 30 days) return 10000; // x1\\r\\n        if (period == 90 days) return 12500; // x1.25\\r\\n        if (period == 180 days) return 15000; // x1.5\\r\\n        if (period == 360 days) return 20000; // x2\\r\\n\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function _getStakeAmountWithBonus(address user)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        FeeDiscountStorage.Layout storage l = FeeDiscountStorage.layout();\\r\\n\\r\\n        FeeDiscountStorage.UserInfo memory userInfo = l.userInfo[user];\\r\\n        return\\r\\n            (userInfo.balance *\\r\\n                _getStakePeriodMultiplier(userInfo.stakePeriod)) /\\r\\n            INVERSE_BASIS_POINT;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice transfer tokens from holder to recipient\\r\\n     * @param holder owner of tokens to be transferred\\r\\n     * @param recipient beneficiary of transfer\\r\\n     * @param amount quantity of tokens transferred\\r\\n     */\\r\\n    function _transferXPremia(\\r\\n        address holder,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        if (holder == address(this)) {\\r\\n            IERC20(xPREMIA).safeTransfer(recipient, amount);\\r\\n        } else {\\r\\n            IERC20(xPREMIA).safeTransferFrom(holder, recipient, amount);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/staking/FeeDiscountStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary FeeDiscountStorage {\\r\\n    bytes32 internal constant STORAGE_SLOT =\\r\\n        keccak256(\\\"premia.contracts.staking.PremiaFeeDiscount\\\");\\r\\n\\r\\n    struct UserInfo {\\r\\n        uint256 balance; // Balance staked by user\\r\\n        uint64 stakePeriod; // Stake period selected by user\\r\\n        uint64 lockedUntil; // Timestamp at which the lock ends\\r\\n    }\\r\\n\\r\\n    struct Layout {\\r\\n        // User data with xPREMIA balance staked and date at which lock ends\\r\\n        mapping(address => UserInfo) userInfo;\\r\\n    }\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/staking/IPremiaStakingOld.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPremiaStakingOld {\\r\\n    /**\\r\\n     * @notice stake PREMIA using IERC2612 permit\\r\\n     * @param amount quantity of PREMIA to stake\\r\\n     * @param deadline timestamp after which permit will fail\\r\\n     * @param v signature \\\"v\\\" value\\r\\n     * @param r signature \\\"r\\\" value\\r\\n     * @param s signature \\\"s\\\" value\\r\\n     */\\r\\n    function enterWithPermit(\\r\\n        uint256 amount,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice stake PREMIA in exchange for xPremia\\r\\n     * @param amount quantity of PREMIA to stake\\r\\n     */\\r\\n    function enter(uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @notice burn xPremia in exchange for staked PREMIA\\r\\n     * @param amount quantity of xPremia to unstake\\r\\n     */\\r\\n    function leave(uint256 amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/staking/IPremiaStakingWithFeeDiscount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IPremiaStaking} from \\\"./IPremiaStaking.sol\\\";\\r\\nimport {IFeeDiscount} from \\\"./IFeeDiscount.sol\\\";\\r\\n\\r\\ninterface IPremiaStakingWithFeeDiscount is IPremiaStaking, IFeeDiscount {}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial ERC20 interface needed by internal functions\\n */\\ninterface IERC20Internal {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ERC20Base } from './base/ERC20Base.sol';\\nimport { ERC20Extended } from './extended/ERC20Extended.sol';\\nimport { ERC20Metadata } from './metadata/ERC20Metadata.sol';\\n\\n/**\\n * @title SolidState ERC20 implementation, including recommended extensions\\n */\\nabstract contract ERC20 is ERC20Base, ERC20Extended, ERC20Metadata {\\n\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/permit/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { ECDSA } from '../../../cryptography/ECDSA.sol';\\nimport { ERC20Base } from '../base/ERC20Base.sol';\\nimport { ERC20Metadata } from '../metadata/ERC20Metadata.sol';\\nimport { ERC20PermitStorage } from './ERC20PermitStorage.sol';\\nimport { IERC2612 } from './IERC2612.sol';\\n\\n/**\\n * @title ERC20 extension with support for ERC2612 permits\\n * @dev derived from https://github.com/soliditylabs/ERC20-Permit (MIT license)\\n */\\nabstract contract ERC20Permit is IERC2612, ERC20Base, ERC20Metadata {\\n    using ECDSA for bytes32;\\n\\n    /**\\n     * @inheritdoc IERC2612\\n     * @dev If https://eips.ethereum.org/EIPS/eip-1344[ChainID] ever changes, the\\n     * EIP712 Domain Separator is automatically recalculated.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, 'ERC20Permit: expired deadline');\\n\\n        // Assembly for more efficiently computing:\\n        // bytes32 hashStruct = keccak256(\\n        //   abi.encode(\\n        //     _PERMIT_TYPEHASH,\\n        //     owner,\\n        //     spender,\\n        //     amount,\\n        //     _nonces[owner].current(),\\n        //     deadline\\n        //   )\\n        // );\\n\\n        bytes32 hashStruct;\\n        uint256 nonce = ERC20PermitStorage.layout().nonces[owner];\\n\\n        assembly {\\n            // Load free memory pointer\\n            let memPtr := mload(64)\\n\\n            // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")\\n            mstore(\\n                memPtr,\\n                0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9\\n            )\\n            mstore(add(memPtr, 32), owner)\\n            mstore(add(memPtr, 64), spender)\\n            mstore(add(memPtr, 96), amount)\\n            mstore(add(memPtr, 128), nonce)\\n            mstore(add(memPtr, 160), deadline)\\n\\n            hashStruct := keccak256(memPtr, 192)\\n        }\\n\\n        bytes32 eip712DomainHash = _domainSeparator();\\n\\n        // Assembly for more efficient computing:\\n        // bytes32 hash = keccak256(\\n        //   abi.encodePacked(uint16(0x1901), eip712DomainHash, hashStruct)\\n        // );\\n\\n        bytes32 hash;\\n\\n        assembly {\\n            // Load free memory pointer\\n            let memPtr := mload(64)\\n\\n            mstore(\\n                memPtr,\\n                0x1901000000000000000000000000000000000000000000000000000000000000\\n            ) // EIP191 header\\n            mstore(add(memPtr, 2), eip712DomainHash) // EIP712 domain hash\\n            mstore(add(memPtr, 34), hashStruct) // Hash of struct\\n\\n            hash := keccak256(memPtr, 66)\\n        }\\n\\n        address signer = hash.recover(v, r, s);\\n\\n        require(signer == owner, 'ERC20Permit: invalid signature');\\n\\n        ERC20PermitStorage.layout().nonces[owner]++;\\n        _approve(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev inhertidoc IERC2612\\n     */\\n    function nonces(address owner) public view override returns (uint256) {\\n        return ERC20PermitStorage.layout().nonces[owner];\\n    }\\n\\n    /**\\n     * @notice update domain separator for new chain ID\\n     * @return new domain separator\\n     */\\n    function _updateDomainSeparator() private returns (bytes32) {\\n        uint256 chainId = _chainId();\\n\\n        // no need for assembly, running very rarely\\n        bytes32 newDomainSeparator = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\\n                ),\\n                keccak256(bytes(name())), // ERC-20 Name\\n                keccak256(bytes('1')), // Version\\n                chainId,\\n                address(this)\\n            )\\n        );\\n\\n        ERC20PermitStorage.layout().domainSeparators[\\n            chainId\\n        ] = newDomainSeparator;\\n\\n        return newDomainSeparator;\\n    }\\n\\n    /**\\n     * @notice update chain ID if changed and return domain separator\\n     * @return domain separator\\n     */\\n    function _domainSeparator() private returns (bytes32) {\\n        bytes32 domainSeparator = ERC20PermitStorage.layout().domainSeparators[\\n            _chainId()\\n        ];\\n\\n        if (domainSeparator != 0x00) {\\n            return domainSeparator;\\n        }\\n\\n        return _updateDomainSeparator();\\n    }\\n\\n    /**\\n     * @notice get the current chain ID\\n     * @return chainId chain ID\\n     */\\n    function _chainId() private view returns (uint256 chainId) {\\n        assembly {\\n            chainId := chainid()\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '../token/ERC20/IERC20.sol';\\nimport { AddressUtils } from './AddressUtils.sol';\\n\\n/**\\n * @title Safe ERC20 interaction library\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary SafeERC20 {\\n    using AddressUtils for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    /**\\n     * @dev safeApprove (like approve) should only be called when setting an initial allowance or when resetting it to zero; otherwise prefer safeIncreaseAllowance and safeDecreaseAllowance\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            'SafeERC20: approve from non-zero to non-zero allowance'\\n        );\\n\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(\\n                oldAllowance >= value,\\n                'SafeERC20: decreased allowance below zero'\\n            );\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(\\n                token,\\n                abi.encodeWithSelector(\\n                    token.approve.selector,\\n                    spender,\\n                    newAllowance\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice send transaction data and check validity of return value, if present\\n     * @param token ERC20 token interface\\n     * @param data transaction data\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata = address(token).functionCall(\\n            data,\\n            'SafeERC20: low-level call failed'\\n        );\\n\\n        if (returndata.length > 0) {\\n            require(\\n                abi.decode(returndata, (bool)),\\n                'SafeERC20: ERC20 operation did not succeed'\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"abdk-libraries-solidity/ABDKMath64x64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with signed\\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\\n * basically a simple fraction whose numerator is signed 128-bit integer and\\n * denominator is 2^64.  As long as denominator is always the same, there is no\\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\\n * represented by int128 type holding only the numerator.\\n */\\nlibrary ABDKMath64x64 {\\n  /*\\n   * Minimum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\\n\\n  /*\\n   * Maximum value signed 64.64-bit fixed point number may have. \\n   */\\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n  /**\\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromInt (int256 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\\n      return int128 (x << 64);\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\\n   * rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64-bit integer number\\n   */\\n  function toInt (int128 x) internal pure returns (int64) {\\n    unchecked {\\n      return int64 (x >> 64);\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x <= 0x7FFFFFFFFFFFFFFF);\\n      return int128 (int256 (x << 64));\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\\n   * number rounding down.  Revert on underflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return unsigned 64-bit integer number\\n   */\\n  function toUInt (int128 x) internal pure returns (uint64) {\\n    unchecked {\\n      require (x >= 0);\\n      return uint64 (uint128 (x >> 64));\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\\n   * number rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 128.128-bin fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function from128x128 (int256 x) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = x >> 64;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\\n   * number.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 128.128 fixed point number\\n   */\\n  function to128x128 (int128 x) internal pure returns (int256) {\\n    unchecked {\\n      return int256 (x) << 64;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function add (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = int256(x) + y;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sub (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = int256(x) - y;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function mul (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 result = int256(x) * y >> 64;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\\n   * number and y is signed 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y signed 256-bit integer number\\n   * @return signed 256-bit integer number\\n   */\\n  function muli (int128 x, int256 y) internal pure returns (int256) {\\n    unchecked {\\n      if (x == MIN_64x64) {\\n        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\\n          y <= 0x1000000000000000000000000000000000000000000000000);\\n        return -y << 63;\\n      } else {\\n        bool negativeResult = false;\\n        if (x < 0) {\\n          x = -x;\\n          negativeResult = true;\\n        }\\n        if (y < 0) {\\n          y = -y; // We rely on overflow behavior here\\n          negativeResult = !negativeResult;\\n        }\\n        uint256 absoluteResult = mulu (x, uint256 (y));\\n        if (negativeResult) {\\n          require (absoluteResult <=\\n            0x8000000000000000000000000000000000000000000000000000000000000000);\\n          return -int256 (absoluteResult); // We rely on overflow behavior here\\n        } else {\\n          require (absoluteResult <=\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n          return int256 (absoluteResult);\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64 fixed point number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\\n    unchecked {\\n      if (y == 0) return 0;\\n\\n      require (x >= 0);\\n\\n      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\\n      uint256 hi = uint256 (int256 (x)) * (y >> 128);\\n\\n      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      hi <<= 64;\\n\\n      require (hi <=\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\\n      return hi + lo;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function div (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      require (y != 0);\\n      int256 result = (int256 (x) << 64) / y;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @param y signed 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divi (int256 x, int256 y) internal pure returns (int128) {\\n    unchecked {\\n      require (y != 0);\\n\\n      bool negativeResult = false;\\n      if (x < 0) {\\n        x = -x; // We rely on overflow behavior here\\n        negativeResult = true;\\n      }\\n      if (y < 0) {\\n        y = -y; // We rely on overflow behavior here\\n        negativeResult = !negativeResult;\\n      }\\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\\n      if (negativeResult) {\\n        require (absoluteResult <= 0x80000000000000000000000000000000);\\n        return -int128 (absoluteResult); // We rely on overflow behavior here\\n      } else {\\n        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (absoluteResult); // We rely on overflow behavior here\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\\n    unchecked {\\n      require (y != 0);\\n      uint128 result = divuu (x, y);\\n      require (result <= uint128 (MAX_64x64));\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function neg (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x != MIN_64x64);\\n      return -x;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function abs (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x != MIN_64x64);\\n      return x < 0 ? -x : x;\\n    }\\n  }\\n\\n  /**\\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\\n   * zero.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function inv (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x != 0);\\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function avg (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      return int128 ((int256 (x) + int256 (y)) >> 1);\\n    }\\n  }\\n\\n  /**\\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\\n   * Revert on overflow or in case x * y is negative.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\\n    unchecked {\\n      int256 m = int256 (x) * int256 (y);\\n      require (m >= 0);\\n      require (m <\\n          0x4000000000000000000000000000000000000000000000000000000000000000);\\n      return int128 (sqrtu (uint256 (m)));\\n    }\\n  }\\n\\n  /**\\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @param y uint256 value\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\\n    unchecked {\\n      bool negative = x < 0 && y & 1 == 1;\\n\\n      uint256 absX = uint128 (x < 0 ? -x : x);\\n      uint256 absResult;\\n      absResult = 0x100000000000000000000000000000000;\\n\\n      if (absX <= 0x10000000000000000) {\\n        absX <<= 63;\\n        while (y != 0) {\\n          if (y & 0x1 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          if (y & 0x2 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          if (y & 0x4 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          if (y & 0x8 != 0) {\\n            absResult = absResult * absX >> 127;\\n          }\\n          absX = absX * absX >> 127;\\n\\n          y >>= 4;\\n        }\\n\\n        absResult >>= 64;\\n      } else {\\n        uint256 absXShift = 63;\\n        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\\n        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\\n        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\\n        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\\n        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\\n        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\\n\\n        uint256 resultShift = 0;\\n        while (y != 0) {\\n          require (absXShift < 64);\\n\\n          if (y & 0x1 != 0) {\\n            absResult = absResult * absX >> 127;\\n            resultShift += absXShift;\\n            if (absResult > 0x100000000000000000000000000000000) {\\n              absResult >>= 1;\\n              resultShift += 1;\\n            }\\n          }\\n          absX = absX * absX >> 127;\\n          absXShift <<= 1;\\n          if (absX >= 0x100000000000000000000000000000000) {\\n              absX >>= 1;\\n              absXShift += 1;\\n          }\\n\\n          y >>= 1;\\n        }\\n\\n        require (resultShift < 64);\\n        absResult >>= 64 - resultShift;\\n      }\\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\\n      require (result >= MIN_64x64 && result <= MAX_64x64);\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function sqrt (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x >= 0);\\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function log_2 (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x > 0);\\n\\n      int256 msb = 0;\\n      int256 xc = x;\\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n      int256 result = msb - 64 << 64;\\n      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\\n        ux *= ux;\\n        uint256 b = ux >> 255;\\n        ux >>= 127 + b;\\n        result += bit * int256 (b);\\n      }\\n\\n      return int128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Revert if x <= 0.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function ln (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x > 0);\\n\\n      return int128 (int256 (\\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp_2 (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x < 0x400000000000000000); // Overflow\\n\\n      if (x < -0x400000000000000000) return 0; // Underflow\\n\\n      uint256 result = 0x80000000000000000000000000000000;\\n\\n      if (x & 0x8000000000000000 > 0)\\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n      if (x & 0x4000000000000000 > 0)\\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n      if (x & 0x2000000000000000 > 0)\\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n      if (x & 0x1000000000000000 > 0)\\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n      if (x & 0x800000000000000 > 0)\\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n      if (x & 0x400000000000000 > 0)\\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n      if (x & 0x200000000000000 > 0)\\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n      if (x & 0x100000000000000 > 0)\\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n      if (x & 0x80000000000000 > 0)\\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n      if (x & 0x40000000000000 > 0)\\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n      if (x & 0x20000000000000 > 0)\\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n      if (x & 0x10000000000000 > 0)\\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n      if (x & 0x8000000000000 > 0)\\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n      if (x & 0x4000000000000 > 0)\\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n      if (x & 0x2000000000000 > 0)\\n        result = result * 0x1000162E525EE054754457D5995292026 >> 128;\\n      if (x & 0x1000000000000 > 0)\\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n      if (x & 0x800000000000 > 0)\\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n      if (x & 0x400000000000 > 0)\\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n      if (x & 0x200000000000 > 0)\\n        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n      if (x & 0x100000000000 > 0)\\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n      if (x & 0x80000000000 > 0)\\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n      if (x & 0x40000000000 > 0)\\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n      if (x & 0x20000000000 > 0)\\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n      if (x & 0x10000000000 > 0)\\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n      if (x & 0x8000000000 > 0)\\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n      if (x & 0x4000000000 > 0)\\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n      if (x & 0x2000000000 > 0)\\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n      if (x & 0x1000000000 > 0)\\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n      if (x & 0x800000000 > 0)\\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n      if (x & 0x400000000 > 0)\\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n      if (x & 0x200000000 > 0)\\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n      if (x & 0x100000000 > 0)\\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n      if (x & 0x80000000 > 0)\\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n      if (x & 0x40000000 > 0)\\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n      if (x & 0x20000000 > 0)\\n        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n      if (x & 0x10000000 > 0)\\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n      if (x & 0x8000000 > 0)\\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n      if (x & 0x4000000 > 0)\\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n      if (x & 0x2000000 > 0)\\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n      if (x & 0x1000000 > 0)\\n        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n      if (x & 0x800000 > 0)\\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n      if (x & 0x400000 > 0)\\n        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n      if (x & 0x200000 > 0)\\n        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n      if (x & 0x100000 > 0)\\n        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n      if (x & 0x80000 > 0)\\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n      if (x & 0x40000 > 0)\\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n      if (x & 0x20000 > 0)\\n        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n      if (x & 0x10000 > 0)\\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n      if (x & 0x8000 > 0)\\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n      if (x & 0x4000 > 0)\\n        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n      if (x & 0x2000 > 0)\\n        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n      if (x & 0x1000 > 0)\\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n      if (x & 0x800 > 0)\\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n      if (x & 0x400 > 0)\\n        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n      if (x & 0x200 > 0)\\n        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n      if (x & 0x100 > 0)\\n        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n      if (x & 0x80 > 0)\\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n      if (x & 0x40 > 0)\\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n      if (x & 0x20 > 0)\\n        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\\n      if (x & 0x10 > 0)\\n        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n      if (x & 0x8 > 0)\\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n      if (x & 0x4 > 0)\\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n      if (x & 0x2 > 0)\\n        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n      if (x & 0x1 > 0)\\n        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n\\n      result >>= uint256 (int256 (63 - (x >> 64)));\\n      require (result <= uint256 (int256 (MAX_64x64)));\\n\\n      return int128 (int256 (result));\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural exponent of x.  Revert on overflow.\\n   *\\n   * @param x signed 64.64-bit fixed point number\\n   * @return signed 64.64-bit fixed point number\\n   */\\n  function exp (int128 x) internal pure returns (int128) {\\n    unchecked {\\n      require (x < 0x400000000000000000); // Overflow\\n\\n      if (x < -0x400000000000000000) return 0; // Underflow\\n\\n      return exp_2 (\\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\\n   * integer numbers.  Revert on overflow or when y is zero.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @param y unsigned 256-bit integer number\\n   * @return unsigned 64.64-bit fixed point number\\n   */\\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\\n    unchecked {\\n      require (y != 0);\\n\\n      uint256 result;\\n\\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n        result = (x << 64) / y;\\n      else {\\n        uint256 msb = 192;\\n        uint256 xc = x >> 192;\\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\\n\\n        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n        uint256 hi = result * (y >> 128);\\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n        uint256 xh = x >> 192;\\n        uint256 xl = x << 64;\\n\\n        if (xl < lo) xh -= 1;\\n        xl -= lo; // We rely on overflow behavior here\\n        lo = hi << 128;\\n        if (xl < lo) xh -= 1;\\n        xl -= lo; // We rely on overflow behavior here\\n\\n        assert (xh == hi >> 128);\\n\\n        result += xl / y;\\n      }\\n\\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n      return uint128 (result);\\n    }\\n  }\\n\\n  /**\\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\\n   * number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return unsigned 128-bit integer number\\n   */\\n  function sqrtu (uint256 x) private pure returns (uint128) {\\n    unchecked {\\n      if (x == 0) return 0;\\n      else {\\n        uint256 xx = x;\\n        uint256 r = 1;\\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\\n        if (xx >= 0x8) { r <<= 1; }\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1;\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\n        uint256 r1 = x / r;\\n        return uint128 (r < r1 ? r : r1);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ABDKMath64x64Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {ABDKMath64x64} from \\\"abdk-libraries-solidity/ABDKMath64x64.sol\\\";\\r\\n\\r\\nlibrary ABDKMath64x64Token {\\r\\n    using ABDKMath64x64 for int128;\\r\\n\\r\\n    /**\\r\\n     * @notice convert 64x64 fixed point representation of token amount to decimal\\r\\n     * @param value64x64 64x64 fixed point representation of token amount\\r\\n     * @param decimals token display decimals\\r\\n     * @return value decimal representation of token amount\\r\\n     */\\r\\n    function toDecimals(int128 value64x64, uint8 decimals)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256 value)\\r\\n    {\\r\\n        value = value64x64.mulu(10**decimals);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice convert decimal representation of token amount to 64x64 fixed point\\r\\n     * @param value decimal representation of token amount\\r\\n     * @param decimals token display decimals\\r\\n     * @return value64x64 64x64 fixed point representation of token amount\\r\\n     */\\r\\n    function fromDecimals(uint256 value, uint8 decimals)\\r\\n        internal\\r\\n        pure\\r\\n        returns (int128 value64x64)\\r\\n    {\\r\\n        value64x64 = ABDKMath64x64.divu(value, 10**decimals);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice convert 64x64 fixed point representation of token amount to wei (18 decimals)\\r\\n     * @param value64x64 64x64 fixed point representation of token amount\\r\\n     * @return value wei representation of token amount\\r\\n     */\\r\\n    function toWei(int128 value64x64) internal pure returns (uint256 value) {\\r\\n        value = toDecimals(value64x64, 18);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice convert wei representation (18 decimals) of token amount to 64x64 fixed point\\r\\n     * @param value wei representation of token amount\\r\\n     * @return value64x64 64x64 fixed point representation of token amount\\r\\n     */\\r\\n    function fromWei(uint256 value) internal pure returns (int128 value64x64) {\\r\\n        value64x64 = fromDecimals(value, 18);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/staking/IPremiaStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {PremiaStakingStorage} from \\\"./PremiaStakingStorage.sol\\\";\\r\\n\\r\\ninterface IPremiaStaking {\\r\\n    event Deposit(address indexed user, uint256 amount);\\r\\n    event StartWithdrawal(\\r\\n        address indexed user,\\r\\n        uint256 premiaAmount,\\r\\n        uint256 startDate\\r\\n    );\\r\\n    event Withdrawal(address indexed user, uint256 amount);\\r\\n\\r\\n    /**\\r\\n     * @notice add premia tokens as available tokens to be distributed as rewards\\r\\n     * @param amount amount of premia tokens to add as rewards\\r\\n     */\\r\\n    function addRewards(uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @notice get amount of tokens that have not yet been distributed as rewards\\r\\n     * @return amount of tokens not yet distributed as rewards\\r\\n     */\\r\\n    function getAvailableRewards() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice get pending amount of tokens to be distributed as rewards to stakers\\r\\n     * @return amount of tokens pending to be distributed as rewards\\r\\n     */\\r\\n    function getPendingRewards() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice stake PREMIA using IERC2612 permit\\r\\n     * @param amount quantity of PREMIA to stake\\r\\n     * @param deadline timestamp after which permit will fail\\r\\n     * @param v signature \\\"v\\\" value\\r\\n     * @param r signature \\\"r\\\" value\\r\\n     * @param s signature \\\"s\\\" value\\r\\n     */\\r\\n    function depositWithPermit(\\r\\n        uint256 amount,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice stake PREMIA in exchange for xPremia\\r\\n     * @param amount quantity of PREMIA to stake\\r\\n     */\\r\\n    function deposit(uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Initiate the withdrawal process by burning xPremia, starting the delay period\\r\\n     * @param amount quantity of xPremia to unstake\\r\\n     */\\r\\n    function startWithdraw(uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @notice withdraw PREMIA after withdrawal delay has passed\\r\\n     */\\r\\n    function withdraw() external;\\r\\n\\r\\n    /**\\r\\n     * @notice get current withdrawal delay\\r\\n     * @return withdrawal delay\\r\\n     */\\r\\n    function getWithdrawalDelay() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice set current withdrawal delay\\r\\n     * @param delay withdrawal delay\\r\\n     */\\r\\n    function setWithdrawalDelay(uint256 delay) external;\\r\\n\\r\\n    /**\\r\\n     * @notice get the xPREMIA : PREMIA ratio (with 18 decimals)\\r\\n     * @return xPREMIA : PREMIA ratio (with 18 decimals)\\r\\n     */\\r\\n    function getXPremiaToPremiaRatio() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice get pending withdrawal data of a user\\r\\n     * @return amount pending withdrawal amount\\r\\n     * @return startDate start timestamp of withdrawal\\r\\n     * @return unlockDate timestamp at which withdrawal becomes available\\r\\n     */\\r\\n    function getPendingWithdrawal(address user)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 amount,\\r\\n            uint256 startDate,\\r\\n            uint256 unlockDate\\r\\n        );\\r\\n\\r\\n    /**\\r\\n     * @notice get the amount of PREMIA staked (subtracting all pending withdrawals)\\r\\n     * @return amount of PREMIA staked\\r\\n     */\\r\\n    function getStakedPremiaAmount() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/staking/PremiaStakingStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary PremiaStakingStorage {\\r\\n    bytes32 internal constant STORAGE_SLOT =\\r\\n        keccak256(\\\"premia.contracts.staking.PremiaStaking\\\");\\r\\n\\r\\n    struct Withdrawal {\\r\\n        uint256 amount; // Premia amount\\r\\n        uint256 startDate; // Will unlock at startDate + withdrawalDelay\\r\\n    }\\r\\n\\r\\n    struct Layout {\\r\\n        uint256 pendingWithdrawal;\\r\\n        uint256 withdrawalDelay;\\r\\n        mapping(address => Withdrawal) withdrawals;\\r\\n        uint256 availableRewards;\\r\\n        uint256 lastRewardUpdate; // Timestamp of last reward distribution update\\r\\n    }\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/base/ERC20Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '../IERC20.sol';\\nimport { ERC20BaseInternal } from './ERC20BaseInternal.sol';\\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\\n\\n/**\\n * @title Base ERC20 implementation, excluding optional extensions\\n */\\nabstract contract ERC20Base is IERC20, ERC20BaseInternal {\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function balanceOf(address account)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return _balanceOf(account);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function allowance(address holder, address spender)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return ERC20BaseStorage.layout().allowances[holder][spender];\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function approve(address spender, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function transferFrom(\\n        address holder,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        uint256 currentAllowance = ERC20BaseStorage.layout().allowances[holder][\\n            msg.sender\\n        ];\\n        require(\\n            currentAllowance >= amount,\\n            'ERC20: transfer amount exceeds allowance'\\n        );\\n        unchecked {\\n            _approve(holder, msg.sender, currentAllowance - amount);\\n        }\\n        _transfer(holder, recipient, amount);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/extended/ERC20Extended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ERC20Base, ERC20BaseStorage } from '../base/ERC20Base.sol';\\n\\n/**\\n * @title ERC20 safe approval extensions\\n * @dev mitigations for transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\\n */\\nabstract contract ERC20Extended is ERC20Base {\\n    /**\\n     * @notice increase spend amount granted to spender\\n     * @param spender address whose allowance to increase\\n     * @param amount quantity by which to increase allowance\\n     * @return success status (always true; otherwise function will revert)\\n     */\\n    function increaseAllowance(address spender, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        unchecked {\\n            mapping(address => uint256) storage allowances = ERC20BaseStorage\\n                .layout()\\n                .allowances[msg.sender];\\n\\n            uint256 allowance = allowances[spender];\\n            require(\\n                allowance + amount >= allowance,\\n                'ERC20Extended: excessive allowance'\\n            );\\n\\n            _approve(\\n                msg.sender,\\n                spender,\\n                allowances[spender] = allowance + amount\\n            );\\n\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @notice decrease spend amount granted to spender\\n     * @param spender address whose allowance to decrease\\n     * @param amount quantity by which to decrease allowance\\n     * @return success status (always true; otherwise function will revert)\\n     */\\n    function decreaseAllowance(address spender, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        unchecked {\\n            mapping(address => uint256) storage allowances = ERC20BaseStorage\\n                .layout()\\n                .allowances[msg.sender];\\n\\n            uint256 allowance = allowances[spender];\\n            require(\\n                amount <= allowance,\\n                'ERC20Extended: insufficient allowance'\\n            );\\n\\n            _approve(\\n                msg.sender,\\n                spender,\\n                allowances[spender] = allowance - amount\\n            );\\n\\n            return true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/metadata/ERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ERC20MetadataStorage } from './ERC20MetadataStorage.sol';\\nimport { IERC20Metadata } from './IERC20Metadata.sol';\\n\\n/**\\n * @title ERC20 metadata extensions\\n */\\nabstract contract ERC20Metadata is IERC20Metadata {\\n    /**\\n     * @inheritdoc IERC20Metadata\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return ERC20MetadataStorage.layout().name;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20Metadata\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return ERC20MetadataStorage.layout().symbol;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20Metadata\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20MetadataStorage.layout().decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/base/ERC20BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20Internal } from '../IERC20Internal.sol';\\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\\n\\n/**\\n * @title Base ERC20 implementation, excluding optional extensions\\n */\\nabstract contract ERC20BaseInternal is IERC20Internal {\\n    /**\\n     * @notice query the total minted token supply\\n     * @return token supply\\n     */\\n    function _totalSupply() internal view virtual returns (uint256) {\\n        return ERC20BaseStorage.layout().totalSupply;\\n    }\\n\\n    /**\\n     * @notice query the token balance of given account\\n     * @param account address to query\\n     * @return token balance\\n     */\\n    function _balanceOf(address account)\\n        internal\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        return ERC20BaseStorage.layout().balances[account];\\n    }\\n\\n    /**\\n     * @notice enable spender to spend tokens on behalf of holder\\n     * @param holder address on whose behalf tokens may be spent\\n     * @param spender recipient of allowance\\n     * @param amount quantity of tokens approved for spending\\n     */\\n    function _approve(\\n        address holder,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(holder != address(0), 'ERC20: approve from the zero address');\\n        require(spender != address(0), 'ERC20: approve to the zero address');\\n\\n        ERC20BaseStorage.layout().allowances[holder][spender] = amount;\\n\\n        emit Approval(holder, spender, amount);\\n    }\\n\\n    /**\\n     * @notice mint tokens for given account\\n     * @param account recipient of minted tokens\\n     * @param amount quantity of tokens minted\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), 'ERC20: mint to the zero address');\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\n        l.totalSupply += amount;\\n        l.balances[account] += amount;\\n\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @notice burn tokens held by given account\\n     * @param account holder of burned tokens\\n     * @param amount quantity of tokens burned\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), 'ERC20: burn from the zero address');\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\n        uint256 balance = l.balances[account];\\n        require(balance >= amount, 'ERC20: burn amount exceeds balance');\\n        unchecked {\\n            l.balances[account] = balance - amount;\\n        }\\n        l.totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @notice transfer tokens from holder to recipient\\n     * @param holder owner of tokens to be transferred\\n     * @param recipient beneficiary of transfer\\n     * @param amount quantity of tokens transferred\\n     */\\n    function _transfer(\\n        address holder,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(holder != address(0), 'ERC20: transfer from the zero address');\\n        require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n        _beforeTokenTransfer(holder, recipient, amount);\\n\\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\n        uint256 holderBalance = l.balances[holder];\\n        require(\\n            holderBalance >= amount,\\n            'ERC20: transfer amount exceeds balance'\\n        );\\n        unchecked {\\n            l.balances[holder] = holderBalance - amount;\\n        }\\n        l.balances[recipient] += amount;\\n\\n        emit Transfer(holder, recipient, amount);\\n    }\\n\\n    /**\\n     * @notice ERC20 hook, called before all transfers including mint and burn\\n     * @dev function should be overridden and new implementation must call super\\n     * @param from sender of tokens\\n     * @param to receiver of tokens\\n     * @param amount quantity of tokens transferred\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/base/ERC20BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ERC20BaseStorage {\\n    struct Layout {\\n        mapping(address => uint256) balances;\\n        mapping(address => mapping(address => uint256)) allowances;\\n        uint256 totalSupply;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC20Base');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ERC20MetadataStorage {\\n    struct Layout {\\n        string name;\\n        string symbol;\\n        uint8 decimals;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC20Metadata');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function setName(Layout storage l, string memory name) internal {\\n        l.name = name;\\n    }\\n\\n    function setSymbol(Layout storage l, string memory symbol) internal {\\n        l.symbol = symbol;\\n    }\\n\\n    function setDecimals(Layout storage l, uint8 decimals) internal {\\n        l.decimals = decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC20 metadata interface\\n */\\ninterface IERC20Metadata {\\n    /**\\n     * @notice return token name\\n     * @return token name\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @notice return token symbol\\n     * @return token symbol\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @notice return token decimals, generally used only for display purposes\\n     * @return token decimals\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Elliptic Curve Digital Signature Algorithm (ECDSA) operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary ECDSA {\\n    /**\\n     * @notice recover signer of hashed message from signature\\n     * @param hash hashed data payload\\n     * @param signature signed data payload\\n     * @return recovered message signer\\n     */\\n    function recover(bytes32 hash, bytes memory signature)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        require(signature.length == 65, 'ECDSA: invalid signature length');\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @notice recover signer of hashed message from signature v, r, and s values\\n     * @param hash hashed data payload\\n     * @param v signature \\\"v\\\" value\\n     * @param r signature \\\"r\\\" value\\n     * @param s signature \\\"s\\\" value\\n     * @return recovered message signer\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(\\n            uint256(s) <=\\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n            \\\"ECDSA: invalid signature 's' value\\\"\\n        );\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), 'ECDSA: invalid signature');\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @notice generate an \\\"Ethereum Signed Message\\\" in the format returned by the eth_sign JSON-RPC method\\n     * @param hash hashed data payload\\n     * @return signed message hash\\n     */\\n    function toEthSignedMessageHash(bytes32 hash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked('\\\\x19Ethereum Signed Message:\\\\n32', hash)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/permit/ERC20PermitStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ERC20PermitStorage {\\n    struct Layout {\\n        mapping(address => uint256) nonces;\\n        // Mapping of ChainID to domain separators. This is a very gas efficient way\\n        // to not recalculate the domain separator on every call, while still\\n        // automatically detecting ChainID changes.\\n        mapping(uint256 => bytes32) domainSeparators;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC20Permit');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary AddressUtils {\\n    function toString(address account) internal pure returns (string memory) {\\n        bytes32 value = bytes32(uint256(uint160(account)));\\n        bytes memory alphabet = '0123456789abcdef';\\n        bytes memory chars = new bytes(42);\\n\\n        chars[0] = '0';\\n        chars[1] = 'x';\\n\\n        for (uint256 i = 0; i < 20; i++) {\\n            chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\\n            chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\\n        }\\n\\n        return string(chars);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        require(success, 'AddressUtils: failed to send value');\\n    }\\n\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            'AddressUtils: insufficient balance for call'\\n        );\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        require(\\n            isContract(target),\\n            'AddressUtils: function call to non-contract'\\n        );\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/IFeeDiscount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {FeeDiscountStorage} from \\\"./FeeDiscountStorage.sol\\\";\\r\\n\\r\\ninterface IFeeDiscount {\\r\\n    event Staked(\\r\\n        address indexed user,\\r\\n        uint256 amount,\\r\\n        uint256 stakePeriod,\\r\\n        uint256 lockedUntil\\r\\n    );\\r\\n    event Unstaked(address indexed user, uint256 amount);\\r\\n\\r\\n    struct StakeLevel {\\r\\n        uint256 amount; // Amount to stake\\r\\n        uint256 discount; // Discount when amount is reached\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Stake using IERC2612 permit\\r\\n     * @param amount The amount of xPremia to stake\\r\\n     * @param period The lockup period (in seconds)\\r\\n     * @param deadline Deadline after which permit will fail\\r\\n     * @param v V\\r\\n     * @param r R\\r\\n     * @param s S\\r\\n     */\\r\\n    function stakeWithPermit(\\r\\n        uint256 amount,\\r\\n        uint256 period,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Lockup xPremia for protocol fee discounts\\r\\n     *          Longer period of locking will apply a multiplier on the amount staked, in the fee discount calculation\\r\\n     * @param amount The amount of xPremia to stake\\r\\n     * @param period The lockup period (in seconds)\\r\\n     */\\r\\n    function stake(uint256 amount, uint256 period) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Unstake xPremia (If lockup period has ended)\\r\\n     * @param amount The amount of xPremia to unstake\\r\\n     */\\r\\n    function unstake(uint256 amount) external;\\r\\n\\r\\n    //////////\\r\\n    // View //\\r\\n    //////////\\r\\n\\r\\n    /**\\r\\n     * Calculate the stake amount of a user, after applying the bonus from the lockup period chosen\\r\\n     * @param user The user from which to query the stake amount\\r\\n     * @return The user stake amount after applying the bonus\\r\\n     */\\r\\n    function getStakeAmountWithBonus(address user)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate the % of fee discount for user, based on his stake\\r\\n     * @param user The _user for which the discount is for\\r\\n     * @return Percentage of protocol fee discount (in basis point)\\r\\n     *         Ex : 1000 = 10% fee discount\\r\\n     */\\r\\n    function getDiscount(address user) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Get stake levels\\r\\n     * @return Stake levels\\r\\n     *         Ex : 2500 = -25%\\r\\n     */\\r\\n    function getStakeLevels() external returns (StakeLevel[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Get stake period multiplier\\r\\n     * @param period The duration (in seconds) for which tokens are locked\\r\\n     * @return The multiplier for this staking period\\r\\n     *         Ex : 20000 = x2\\r\\n     */\\r\\n    function getStakePeriodMultiplier(uint256 period)\\r\\n        external\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Get staking infos of a user\\r\\n     * @param user The user address for which to get staking infos\\r\\n     * @return The staking infos of the user\\r\\n     */\\r\\n    function getUserInfo(address user)\\r\\n        external\\r\\n        view\\r\\n        returns (FeeDiscountStorage.UserInfo memory);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"premia\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldFeeDiscount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldStaking\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakePeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"premiaAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"}],\"name\":\"StartWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"depositWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getPendingWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getStakeAmountWithBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeLevels\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"discount\",\"type\":\"uint256\"}],\"internalType\":\"struct IFeeDiscount.StakeLevel[]\",\"name\":\"stakeLevels\",\"type\":\"tuple[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"getStakePeriodMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakedPremiaAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"stakePeriod\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lockedUntil\",\"type\":\"uint64\"}],\"internalType\":\"struct FeeDiscountStorage.UserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawalDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getXPremiaToPremiaRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"migrateWithoutLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"premiaDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xPremiaMinted\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"migrateWithoutLockWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"premiaDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xPremiaMinted\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"setWithdrawalDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"stakeWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"startWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PremiaStakingWithFeeDiscount","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006399c842dd2be3de30bf99bc7d1bbf6fa3650e70000000000000000000000000f5aae75d1ad6fdd62cce66137f2674c96feda85400000000000000000000000016f9d564df80376c61ac914205d3fdff7057d610","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}