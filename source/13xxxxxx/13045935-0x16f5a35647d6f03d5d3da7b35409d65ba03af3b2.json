{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.7.6;\r\n\r\n/**\r\n *   ____                  _                          _          ____        _\r\n *  / ___|_ __ _   _ _ __ | |_ ___  _ __  _   _ _ __ | | _____  |  _ \\  __ _| |_ __ _\r\n * | |   | '__| | | | '_ \\| __/ _ \\| '_ \\| | | | '_ \\| |/ / __| | | | |/ _` | __/ _` |\r\n * | |___| |  | |_| | |_) | || (_) | |_) | |_| | | | |   <\\__ \\ | |_| | (_| | || (_| |\r\n *  \\____|_|   \\__, | .__/ \\__\\___/| .__/ \\__,_|_| |_|_|\\_\\___/ |____/ \\__,_|\\__\\__,_|\r\n *             |___/|_|            |_|\r\n *\r\n * On-chain Cryptopunk images and attributes, by Larva Labs.\r\n *\r\n * This contract holds the image and attribute data for the Cryptopunks on-chain.\r\n * The Cryptopunk images are available as raw RGBA pixels, or in SVG format.\r\n * The punk attributes are available as a comma-separated list.\r\n * Included in the attribute list is the head type (various color male and female heads,\r\n * plus the rare zombie, ape, and alien types).\r\n *\r\n * This contract was motivated by community members snowfro and 0xdeafbeef, including a proof-of-concept contract created by 0xdeafbeef.\r\n * Without their involvement, the project would not have come to fruition.\r\n */\r\ncontract CryptopunksData {\r\n\r\n    string internal constant SVG_HEADER = 'data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.2\" viewBox=\"0 0 24 24\">';\r\n    string internal constant SVG_FOOTER = '</svg>';\r\n\r\n    bytes private palette;\r\n    mapping(uint8 => bytes) private assets;\r\n    mapping(uint8 => string) private assetNames;\r\n    mapping(uint64 => uint32) private composites;\r\n    mapping(uint8 => bytes) private punks;\r\n\r\n    address payable internal deployer;\r\n    bool private contractSealed = false;\r\n\r\n    modifier onlyDeployer() {\r\n        require(msg.sender == deployer, \"Only deployer.\");\r\n        _;\r\n    }\r\n\r\n    modifier unsealed() {\r\n        require(!contractSealed, \"Contract sealed.\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        deployer = msg.sender;\r\n    }\r\n\r\n    function setPalette(bytes memory _palette) external onlyDeployer unsealed {\r\n        palette = _palette;\r\n    }\r\n\r\n    function addAsset(uint8 index, bytes memory encoding, string memory name) external onlyDeployer unsealed {\r\n        assets[index] = encoding;\r\n        assetNames[index] = name;\r\n    }\r\n\r\n    function addComposites(uint64 key1, uint32 value1, uint64 key2, uint32 value2, uint64 key3, uint32 value3, uint64 key4, uint32 value4) external onlyDeployer unsealed {\r\n        composites[key1] = value1;\r\n        composites[key2] = value2;\r\n        composites[key3] = value3;\r\n        composites[key4] = value4;\r\n    }\r\n\r\n    function addPunks(uint8 index, bytes memory _punks) external onlyDeployer unsealed {\r\n        punks[index] = _punks;\r\n    }\r\n\r\n    function sealContract() external onlyDeployer unsealed {\r\n        contractSealed = true;\r\n    }\r\n\r\n    /**\r\n     * The Cryptopunk image for the given index.\r\n     * The image is represented in a row-major byte array where each set of 4 bytes is a pixel in RGBA format.\r\n     * @param index the punk index, 0 <= index < 10000\r\n     */\r\n    function punkImage(uint16 index) public view returns (bytes memory) {\r\n        require(index >= 0 && index < 10000);\r\n        bytes memory pixels = new bytes(2304);\r\n        for (uint j = 0; j < 8; j++) {\r\n            uint8 asset = uint8(punks[uint8(index / 100)][(index % 100) * 8 + j]);\r\n            if (asset > 0) {\r\n                bytes storage a = assets[asset];\r\n                uint n = a.length / 3;\r\n                for (uint i = 0; i < n; i++) {\r\n                    uint[4] memory v = [\r\n                        uint(uint8(a[i * 3]) & 0xF0) >> 4,\r\n                        uint(uint8(a[i * 3]) & 0xF),\r\n                        uint(uint8(a[i * 3 + 2]) & 0xF0) >> 4,\r\n                        uint(uint8(a[i * 3 + 2]) & 0xF)\r\n                    ];\r\n                    for (uint dx = 0; dx < 2; dx++) {\r\n                        for (uint dy = 0; dy < 2; dy++) {\r\n                            uint p = ((2 * v[1] + dy) * 24 + (2 * v[0] + dx)) * 4;\r\n                            if (v[2] & (1 << (dx * 2 + dy)) != 0) {\r\n                                bytes4 c = composite(a[i * 3 + 1],\r\n                                        pixels[p],\r\n                                        pixels[p + 1],\r\n                                        pixels[p + 2],\r\n                                        pixels[p + 3]\r\n                                    );\r\n                                pixels[p] = c[0];\r\n                                pixels[p+1] = c[1];\r\n                                pixels[p+2] = c[2];\r\n                                pixels[p+3] = c[3];\r\n                            } else if (v[3] & (1 << (dx * 2 + dy)) != 0) {\r\n                                pixels[p] = 0;\r\n                                pixels[p+1] = 0;\r\n                                pixels[p+2] = 0;\r\n                                pixels[p+3] = 0xFF;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return pixels;\r\n    }\r\n\r\n    /**\r\n     * The Cryptopunk image for the given index, in SVG format.\r\n     * In the SVG, each \"pixel\" is represented as a 1x1 rectangle.\r\n     * @param index the punk index, 0 <= index < 10000\r\n     */\r\n    function punkImageSvg(uint16 index) external view returns (string memory svg) {\r\n        bytes memory pixels = punkImage(index);\r\n        svg = string(abi.encodePacked(SVG_HEADER));\r\n        bytes memory buffer = new bytes(8);\r\n        for (uint y = 0; y < 24; y++) {\r\n            for (uint x = 0; x < 24; x++) {\r\n                uint p = (y * 24 + x) * 4;\r\n                if (uint8(pixels[p + 3]) > 0) {\r\n                    for (uint i = 0; i < 4; i++) {\r\n                        uint8 value = uint8(pixels[p + i]);\r\n                        buffer[i * 2 + 1] = _HEX_SYMBOLS[value & 0xf];\r\n                        value >>= 4;\r\n                        buffer[i * 2] = _HEX_SYMBOLS[value & 0xf];\r\n                    }\r\n                    svg = string(abi.encodePacked(svg,\r\n                        '<rect x=\"', toString(x), '\" y=\"', toString(y),'\" width=\"1\" height=\"1\" shape-rendering=\"crispEdges\" fill=\"#', string(buffer),'\"/>'));\r\n                }\r\n            }\r\n        }\r\n        svg = string(abi.encodePacked(svg, SVG_FOOTER));\r\n    }\r\n\r\n    /**\r\n     * The Cryptopunk attributes for the given index.\r\n     * The attributes are a comma-separated list in UTF-8 string format.\r\n     * The first entry listed is not technically an attribute, but the \"head type\" of the Cryptopunk.\r\n     * @param index the punk index, 0 <= index < 10000\r\n     */\r\n    function punkAttributes(uint16 index) external view returns (string memory text) {\r\n        require(index >= 0 && index < 10000);\r\n        uint8 cell = uint8(index / 100);\r\n        uint offset = (index % 100) * 8;\r\n        for (uint j = 0; j < 8; j++) {\r\n            uint8 asset = uint8(punks[cell][offset + j]);\r\n            if (asset > 0) {\r\n                if (j > 0) {\r\n                    text = string(abi.encodePacked(text, \", \", assetNames[asset]));\r\n                } else {\r\n                    text = assetNames[asset];\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function composite(byte index, byte yr, byte yg, byte yb, byte ya) internal view returns (bytes4 rgba) {\r\n        uint x = uint(uint8(index)) * 4;\r\n        uint8 xAlpha = uint8(palette[x + 3]);\r\n        if (xAlpha == 0xFF) {\r\n            rgba = bytes4(uint32(\r\n                    (uint(uint8(palette[x])) << 24) |\r\n                    (uint(uint8(palette[x+1])) << 16) |\r\n                    (uint(uint8(palette[x+2])) << 8) |\r\n                    xAlpha\r\n                ));\r\n        } else {\r\n            uint64 key =\r\n                (uint64(uint8(palette[x])) << 56) |\r\n                (uint64(uint8(palette[x + 1])) << 48) |\r\n                (uint64(uint8(palette[x + 2])) << 40) |\r\n                (uint64(xAlpha) << 32) |\r\n                (uint64(uint8(yr)) << 24) |\r\n                (uint64(uint8(yg)) << 16) |\r\n                (uint64(uint8(yb)) << 8) |\r\n                (uint64(uint8(ya)));\r\n            rgba = bytes4(composites[key]);\r\n        }\r\n    }\r\n\r\n    //// String stuff from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\r\n\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"encoding\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"addAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"key1\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"value1\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"key2\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"value2\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"key3\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"value3\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"key4\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"value4\",\"type\":\"uint32\"}],\"name\":\"addComposites\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_punks\",\"type\":\"bytes\"}],\"name\":\"addPunks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"punkAttributes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"text\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"punkImage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"punkImageSvg\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"svg\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sealContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_palette\",\"type\":\"bytes\"}],\"name\":\"setPalette\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CryptopunksData","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b5cb11115801def41650f7bf1e201c6d351bae4bbea91fcfec5f6b5be6c6f5b3"}]}