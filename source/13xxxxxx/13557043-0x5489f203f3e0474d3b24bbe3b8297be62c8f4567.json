{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.3.2 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"Shrimps.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// 2021 (C) SUPER HOW Contracts: superhow.ART Shrimps pool v1.0\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./Weighting.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ncontract Shrimps {\\n\\n    address payable internal _shrimpBeneficiary;\\n    address internal _shrimpWeightingContract;\\n    uint internal _totalBid;\\n    uint internal _maximumShrimpBid;\\n    uint internal _minimumShrimpBid;\\n    uint internal _shrimpLastBidTime;\\n    uint internal _shrimpIncrement;\\n    uint internal _shrimpReturnFee;\\n    uint internal _firstDistributionCount;\\n    uint internal _lastDistributionCount;\\n    address[] internal shrimpAddresses;   \\n    bool internal _returnedAllFunds;\\n    bool private constant NOT_ENTERED = false;\\n    bool private constant ENTERED = true;\\n    Weighting scon;\\n    \\n    mapping(address =\\u003e uint) internal _shrimpArray;\\n    mapping(address =\\u003e bool) internal _shrimpBid;\\n    mapping(address =\\u003e bool) internal _userShrimpReentrancy;\\n    \\n    receive() external payable {}\\n    fallback() external payable {}\\n    \\n    modifier shrimpMultipleETH(){\\n      require(msg.value % _shrimpIncrement * 10**18 == 0, \\\"Only 0,1 ETH multiples are accepted\\\"); //0.1 ether\\n       _;\\n    }\\n   \\n    modifier beforeShrimpAuction(uint _time) {\\n        require(block.timestamp \\u003c _time, \\\"Shrimp auction has ended\\\");\\n        _;\\n    }\\n    \\n    modifier afterShrimpAuction(uint _time) {\\n        require(block.timestamp \\u003e= _time, \\\"Shrimp auction did not end yet\\\");\\n        _;\\n    }\\n    \\n    modifier notShrimpOwner() {\\n        require(msg.sender != _shrimpBeneficiary, \\\"Contract owner can not interract here\\\");\\n        _;\\n    }\\n    \\n    modifier onlyShrimpOwner(address messageSender) {\\n        require(_shrimpBeneficiary == messageSender, \\\"Only the owner can use this function\\\");\\n        _;\\n    }\\n    \\n    modifier isShrimpWeighting() {\\n        require(address(_shrimpWeightingContract) == msg.sender, \\\"Wrong contract passed. Contract is not Weighting\\\");\\n        _;\\n    }\\n    \\n    modifier highestBidMaximum() {\\n        require(msg.value \\u003c= _maximumShrimpBid, \\\"Bid must be less than the set maximum bid\\\");\\n        require((_shrimpArray[msg.sender] + msg.value) \\u003c= _maximumShrimpBid, \\\"Bid must be less than the set maximum bid\\\");\\n        _;\\n    }\\n    \\n    modifier lowestShrimpBidMinimum() {\\n        require(msg.value \\u003e= _minimumShrimpBid/(1 ether), \\\"Minimum bid amount required\\\");\\n        _;\\n    }\\n    \\n    modifier returnedAllFunds() {\\n        require(false == _returnedAllFunds, \\\"Funds have been returned to all users\\\");\\n        _;\\n    }\\n    \\n    modifier nonShrimpReentrant() {\\n        require(_userShrimpReentrancy[msg.sender] != ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        _userShrimpReentrancy[msg.sender] = ENTERED;\\n        _;\\n        _userShrimpReentrancy[msg.sender] = NOT_ENTERED;\\n    }\\n\\n    constructor(\\n        address payable shrimpBeneficiary,\\n        uint maximumShrimpBid,\\n        uint minimumShrimpBid,\\n        address shrimpWeightingContract\\n    )\\n    {\\n        _shrimpBeneficiary = shrimpBeneficiary;\\n        _maximumShrimpBid = maximumShrimpBid;\\n        _minimumShrimpBid = minimumShrimpBid;\\n        _shrimpWeightingContract = shrimpWeightingContract;\\n        scon = Weighting(payable(_shrimpWeightingContract));\\n        _shrimpIncrement = 0.1 ether;\\n        _shrimpReturnFee = 0.001 ether;\\n        _firstDistributionCount = 0;\\n        _lastDistributionCount = 100;\\n        _returnedAllFunds = false;\\n    }\\n    \\n    function shrimpsBid()\\n        public\\n        payable\\n        beforeShrimpAuction(scon.getAuctionEndTime())\\n        notShrimpOwner()\\n        highestBidMaximum()\\n        lowestShrimpBidMinimum()\\n        shrimpMultipleETH()\\n        nonShrimpReentrant()\\n    {\\n        _shrimpsBid();\\n    }\\n   \\n    function _shrimpsBid()\\n        internal\\n    {\\n        uint amount = msg.value;\\n        \\n        if(amount \\u003e 0){\\n            _shrimpArray[msg.sender] = _shrimpArray[msg.sender] + amount;\\n            if(_shrimpBid[msg.sender] == false){\\n                _shrimpBid[msg.sender] = true;\\n                shrimpAddresses.push(msg.sender);\\n            }\\n            _totalBid = _totalBid + amount;\\n            _shrimpLastBidTime = block.timestamp;\\n            \\n            uint timeLeft = scon.getAuctionEndTime() - block.timestamp;\\n            if(timeLeft \\u003c= 15 minutes){\\n                scon.setAuctionEndTime();\\n            }\\n        }\\n    }\\n\\n    function _returnShrimpFunds()\\n        external\\n        payable\\n        isShrimpWeighting()\\n        returnedAllFunds()\\n        afterShrimpAuction(scon.getAuctionEndTime())\\n    {\\n        if (_lastDistributionCount \\u003e shrimpAddresses.length) {\\n            _lastDistributionCount = shrimpAddresses.length;\\n        }\\n        for (uint j = _firstDistributionCount; j \\u003c _lastDistributionCount; j++) {\\n            if(_shrimpArray[shrimpAddresses[j]] \\u003e 0){\\n                uint amount = _shrimpArray[shrimpAddresses[j]] - _shrimpReturnFee;\\n                if(payable(shrimpAddresses[j]).send(amount)){\\n                    _shrimpArray[shrimpAddresses[j]] = 0;\\n                }\\n            }\\n        }\\n        _firstDistributionCount = _lastDistributionCount;\\n        _lastDistributionCount += 100;\\n        if (_firstDistributionCount \\u003e= shrimpAddresses.length) {\\n            _returnedAllFunds = true;\\n        }\\n    }\\n    \\n    function transferShrimpOwnership(address payable newShrimpBeneficiary)\\n        public\\n        onlyShrimpOwner(msg.sender)\\n        beforeShrimpAuction(scon.getAuctionEndTime())\\n    {\\n        _transferShrimpOwnership(newShrimpBeneficiary);\\n    }\\n   \\n    function _transferShrimpOwnership(address payable newShrimpBeneficiary)\\n        internal\\n    {\\n        require(newShrimpBeneficiary != address(0));\\n        _shrimpBeneficiary = newShrimpBeneficiary;  \\n    }\\n    \\n    function transferShrimpOwnershipToZero()\\n        public\\n        onlyShrimpOwner(msg.sender)\\n        beforeShrimpAuction(scon.getAuctionEndTime())\\n    {\\n        _transferShrimpOwnershipToZero();\\n    }\\n   \\n    function _transferShrimpOwnershipToZero()\\n        internal\\n    {\\n        _shrimpBeneficiary = payable(address(0));  \\n    }\\n    \\n    function shrimpsTransfer(address recipient, uint256 amount)\\n        public \\n        onlyShrimpOwner(msg.sender)\\n        afterShrimpAuction(scon.getAuctionEndTime())\\n        returns (bool) \\n    {   \\n        _shrimpsTransfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n    \\n    function _shrimpsTransfer(address sender, address recipient, uint256 amount) \\n        internal\\n        virtual \\n    {\\n        require(sender != address(0), \\\"Transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"Transfer to the zero address\\\");\\n        uint256 senderBalance = address(this).balance;\\n        require(senderBalance \\u003e= amount, \\\"Transfer amount exceeds balance\\\");\\n\\n        if(_shrimpBid[recipient] == true){\\n            _shrimpArray[recipient] = _shrimpArray[recipient] - amount;\\n            _totalBid = _totalBid - amount;\\n            if(_shrimpArray[recipient] == 0){\\n                delete _shrimpArray[recipient];\\n            }\\n        }\\n        payable(recipient).transfer(amount);\\n    }\\n    \\n    function shrimpsWithdrawERC20ContractTokens(IERC20 tokenAddress, address recipient)\\n        public\\n        onlyShrimpOwner(msg.sender)\\n        returns(bool)\\n    {\\n        require(msg.sender != address(0), \\\"Sender is address zero\\\");\\n        require(recipient != address(0), \\\"Receiver is address zero\\\");\\n        tokenAddress.approve(address(this), tokenAddress.balanceOf(address(this)));\\n        if(!tokenAddress.transferFrom(address(this), recipient, tokenAddress.balanceOf(address(this)))){\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    function resetShrimpReentrancy(address user) \\n        public\\n        onlyShrimpOwner(msg.sender)\\n    {\\n        _userShrimpReentrancy[user] = NOT_ENTERED;\\n    }\\n\\n    function getShrimpBeneficiary() \\n        public\\n        view\\n        returns (address)\\n    {\\n        return _shrimpBeneficiary;\\n    }\\n    \\n    function getShrimpAuctionEndTime() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return scon.getAuctionEndTime();\\n    }\\n    \\n    function getTotalBid() \\n        public\\n        view\\n        returns (uint)\\n    {\\n        return _totalBid;\\n    }\\n    \\n    function getShrimpReturnFee() \\n        public\\n        view\\n        returns (uint256) \\n    {\\n        return _shrimpReturnFee;\\n    }\\n    \\n    function getMaximumShrimpBid() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _maximumShrimpBid;\\n    }\\n    \\n    function getMinimumShrimpBid() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _minimumShrimpBid;\\n    }\\n    \\n    function checkIfShrimpExists(address shrimp) \\n        public\\n        view\\n        returns (bool)\\n    {\\n        if(_shrimpBid[shrimp] == true){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    function getShrimpBid(address shrimpAddress) \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _shrimpArray[shrimpAddress];\\n    }\\n    \\n    function getShrimpReentrancyStatus(address user) \\n        public\\n        view\\n        onlyShrimpOwner(msg.sender)\\n        returns (bool) \\n    {\\n        return _userShrimpReentrancy[user];\\n    }\\n    \\n    function getTotalAmountOfShrimps() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return shrimpAddresses.length;\\n    }\\n    \\n    function getShrimpLastBidTime()\\n        public\\n        view\\n        returns (uint)\\n    {\\n        return _shrimpLastBidTime;\\n    }\\n    \\n    function getShrimpIncrement() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _shrimpIncrement;\\n    }\\n    \\n    function getShrimpAddress(uint id) \\n        public\\n        view\\n        returns (address)\\n    {\\n        return shrimpAddresses[id];\\n    }\\n    \\n    function getShrimpContractAddress() \\n        public\\n        view\\n        returns (address)\\n    {\\n        return address(this);\\n    }\\n    \\n    function getShrimpContractBalance() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return address(this).balance;\\n    }\\n    \\n}\\n\"},\"Weighting.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// 2021 (C) SUPER HOW Contracts: superhow.ART Auction engine v1.0\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./Whales.sol\\\";\\nimport \\\"./Shrimps.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ncontract Weighting {\\n    \\n    address payable internal _weightingBeneficiary;\\n    address internal _highestWhaleBidder;\\n    address internal _winnerContract;\\n    address internal _shrimpsContractAddress;\\n    address internal _whalesContractAddress;\\n    uint internal _highestWhaleBid;\\n    uint internal _highestShrimpBid;\\n    uint internal _whaleBidTime;\\n    uint internal _shrimpBidTime;\\n    uint internal _auctionEndTime;  \\n    uint internal _paintingMinimalPricing;\\n    uint internal _weightingWinner;\\n    uint internal _weightingWinnerMidAuction;\\n    bool internal _whaleWinnerCheck;\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    receive() external payable {}\\n    fallback() external payable {}\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == _weightingBeneficiary, \\\"Only the owner can use this function\\\");\\n        _;\\n    }\\n    \\n    modifier afterAuction() {\\n        require(block.timestamp \\u003e= _auctionEndTime, \\\"Auction time is incorrect\\\");\\n        _;\\n    }\\n    \\n    modifier beforeAuction() {\\n        require(block.timestamp \\u003c _auctionEndTime, \\\"Auction time is incorrect\\\");\\n        _;\\n    }\\n    modifier onlyShrimpsOrWhales() {\\n        require(msg.sender == _whalesContractAddress || msg.sender == _shrimpsContractAddress, \\\"Not shrimps or whales contract calling\\\");\\n        _;\\n    }\\n    \\n   \\n    constructor(\\n        address payable weightingBeneficiary,\\n        uint paintingMinimalPricing,\\n        uint auctionEndTime\\n    )\\n    {\\n        _weightingBeneficiary = weightingBeneficiary;\\n        _paintingMinimalPricing = paintingMinimalPricing;\\n        _auctionEndTime = auctionEndTime;\\n        \\n        _weightingWinner = 0;\\n        _weightingWinnerMidAuction = 0;\\n        _whaleWinnerCheck = false;\\n    }\\n   \\n    function returnWhaleFunds(Whales whalesContract) \\n        public\\n        payable\\n        onlyOwner()\\n        afterAuction()\\n    {\\n        whalesContract._returnWhaleFunds();\\n    }\\n    \\n    function returnShrimpFunds(Shrimps shrimpContract) \\n        public\\n        payable\\n        onlyOwner()\\n        afterAuction()\\n    {\\n        shrimpContract._returnShrimpFunds();\\n    }\\n    \\n    function determineWinner(Whales whalesContract, Shrimps shrimpContract)\\n        public\\n        onlyOwner()\\n        afterAuction()\\n        returns(uint)\\n    {\\n        _highestWhaleBid = whalesContract.getHighestBid();\\n        _highestShrimpBid = shrimpContract.getTotalBid();\\n        \\n        _whaleBidTime = whalesContract.getWhaleLastBidTime();\\n        _shrimpBidTime = shrimpContract.getShrimpLastBidTime();\\n    \\n        if(_highestShrimpBid \\u003c _paintingMinimalPricing \\u0026\\u0026 _highestWhaleBid \\u003c _paintingMinimalPricing){\\n            _weightingWinner = 3;\\n            return(_weightingWinner);\\n        }else{\\n            if(_highestWhaleBid \\u003e _highestShrimpBid){\\n                _weightingWinner = 1;\\n                _winnerContract = address(whalesContract);\\n            }else if (_highestWhaleBid \\u003c _highestShrimpBid){\\n                _weightingWinner = 2;\\n                _winnerContract = address(shrimpContract);\\n            }else{\\n                if(_whaleBidTime \\u003c _shrimpBidTime){\\n                    _weightingWinner = 1;\\n                    _winnerContract = address(whalesContract);\\n                }else{\\n                    _weightingWinner = 2;\\n                    _winnerContract = address(shrimpContract);\\n                }\\n            }\\n        }\\n\\n        return(_weightingWinner);\\n    }\\n    \\n    function determineWinnerMidAuction(Whales whalesContract, Shrimps shrimpContract)\\n        public\\n        returns(uint, uint)\\n    {\\n        uint _highestWinnerBidMidAuction;\\n        _highestWhaleBid = whalesContract.getHighestBid();\\n        _highestShrimpBid = shrimpContract.getTotalBid();\\n        \\n        _whaleBidTime = whalesContract.getWhaleLastBidTime();\\n        _shrimpBidTime = shrimpContract.getShrimpLastBidTime();\\n        \\n        if(_highestWhaleBid \\u003e _highestShrimpBid){\\n            _weightingWinnerMidAuction = 1;\\n            _highestWinnerBidMidAuction = _highestWhaleBid;\\n        }else if (_highestWhaleBid \\u003c _highestShrimpBid){\\n            _weightingWinnerMidAuction = 2;\\n            _highestWinnerBidMidAuction = _highestShrimpBid;\\n        }else{\\n            if(_whaleBidTime \\u003c _shrimpBidTime){\\n                _weightingWinnerMidAuction = 1;\\n                _highestWinnerBidMidAuction = _highestWhaleBid;\\n            }else{\\n                _weightingWinnerMidAuction = 2;\\n                _highestWinnerBidMidAuction = _highestShrimpBid;\\n            }\\n        }\\n        return(_weightingWinnerMidAuction, _highestWinnerBidMidAuction);\\n    }\\n    \\n    function weightingTransfer(address recipient, uint256 amount)\\n        public \\n        onlyOwner()\\n        afterAuction()\\n        returns (bool) \\n    {\\n        _weightingTransfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n    \\n    function _weightingTransfer(address sender, address recipient, uint256 amount) \\n        internal\\n        virtual \\n    {\\n        require(sender != address(0), \\\"Transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"Transfer to the zero address\\\");\\n        uint256 senderBalance = address(this).balance;\\n        require(senderBalance \\u003e= amount, \\\"Transfer amount exceeds balance\\\");\\n\\n        payable(recipient).transfer(amount);\\n    }\\n    \\n    function weightingWithdrawERC20ContractTokens(IERC20 tokenAddress, address recipient)\\n        public\\n        onlyOwner()\\n        returns(bool)\\n    {\\n        require(msg.sender != address(0), \\\"Sender is address zero\\\");\\n        require(recipient != address(0), \\\"Receiver is address zero\\\");\\n        tokenAddress.approve(address(this), tokenAddress.balanceOf(address(this)));\\n        if(!tokenAddress.transferFrom(address(this), recipient, tokenAddress.balanceOf(address(this)))){\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    function setAuctionEndTime() \\n        external\\n        onlyShrimpsOrWhales()\\n    {\\n        _auctionEndTime = block.timestamp + 15 minutes;\\n    }\\n    \\n    function setPaintingMinimalPricing(uint newPrice) \\n        public\\n        onlyOwner()\\n    {\\n        _paintingMinimalPricing = newPrice;\\n    }\\n    \\n    function setAuctionEndTimeManual(uint256 newtime) \\n        public\\n        onlyOwner()\\n    {\\n        _auctionEndTime = newtime;\\n    }\\n\\n    function confirmWhaleWinner()\\n        public\\n        afterAuction()\\n    {\\n        require(msg.sender == _highestWhaleBidder, \\\"False winner interaction\\\");\\n        _whaleWinnerCheck = true;\\n    }\\n    \\n    function setWhalesContract(address whalesContractAddress) \\n        public\\n        onlyOwner()\\n    {\\n        _whalesContractAddress = whalesContractAddress;\\n    }\\n    \\n    function setShrimpsContract(address shrimpsContractAddress) \\n        public\\n        onlyOwner()\\n    {\\n        _shrimpsContractAddress = shrimpsContractAddress;\\n    }\\n\\n    function _passWinner()\\n        external\\n        view\\n        afterAuction()\\n        returns(uint)\\n    {\\n        return (_weightingWinner);\\n    }\\n    \\n    function getWhaleData(Whales whalesContract)\\n        public\\n        onlyOwner()\\n        returns (address, uint)\\n    {\\n        _highestWhaleBidder = whalesContract.getHighestBidder();\\n        _highestWhaleBid = whalesContract.getHighestBid();\\n        return (_highestWhaleBidder, _highestWhaleBid);\\n    }\\n    \\n    function getShrimpData(Shrimps shrimpContract)\\n        public\\n        onlyOwner()\\n        returns (uint)\\n    {\\n        _highestShrimpBid = shrimpContract.getTotalBid();\\n        return (_highestShrimpBid);\\n    }\\n    \\n    function getBeneficiary() \\n        public\\n        view\\n        returns (address)\\n    {\\n        return _weightingBeneficiary;\\n    }\\n    \\n    function getHighestWhaleBidder() \\n        public\\n        view\\n        returns (address) \\n    {\\n        return _highestWhaleBidder;\\n    }\\n    \\n    function getWinnerContract() \\n        public\\n        view\\n        returns (address)\\n    {\\n        return _winnerContract;\\n    }\\n    \\n    function getHighestWhaleBid() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _highestWhaleBid;\\n    }\\n    \\n    function getHighestShrimpBid() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _highestShrimpBid;\\n    }\\n    \\n    function getAuctionEndTime() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _auctionEndTime;\\n    }\\n    \\n    function whaleWinnerContractInteraction() \\n        public\\n        afterAuction()\\n        view\\n        returns (bool) \\n    {\\n        return _whaleWinnerCheck;\\n    }\\n \\n    function getWeightingContractAddress() \\n        public\\n        view\\n        returns (address) \\n    {\\n        return address(this);\\n    }\\n    \\n    function getShrimpsContractAddress() \\n        public\\n        view\\n        returns (address) \\n    {\\n        return _shrimpsContractAddress;\\n    }\\n    \\n    function getWhalesContractAddress() \\n        public\\n        view\\n        returns (address) \\n    {\\n        return _whalesContractAddress;\\n    }\\n    \\n}\\n\"},\"Whales.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// 2021 (C) SUPER HOW Contracts: superhow.ART Whales bidding v1.0\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./Weighting.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ncontract Whales {\\n   \\n    address payable internal _whaleBeneficiary;\\n    address internal _whaleWeightingContract;\\n    address internal _whaleHighestBidder;\\n    uint internal _highestBid;\\n    uint internal _whaleLastBidTime;\\n    uint internal _minimumWhaleBid;\\n    uint internal _whaleIncrement;\\n    uint internal _whaleReturnFee;\\n    bool private constant NOT_ENTERED = false;\\n    bool private constant ENTERED = true;\\n    Weighting wcon;\\n\\n    receive() external payable {}\\n    fallback() external payable {}\\n   \\n    mapping(address =\\u003e uint) internal _pendingReturns;\\n    mapping(address =\\u003e bool) internal _userWhaleReentrancy;\\n    \\n    modifier whaleMultipleETH(){\\n       require(msg.value % _whaleIncrement == 0, \\\"Only 1 ETH multiples are accepted\\\"); //1 ether\\n       _;\\n    }\\n   \\n    modifier beforeWhaleAuction(uint _time) {\\n        require(block.timestamp \\u003c _time, \\\"Whale auction has ended\\\");\\n        _;\\n    }\\n    \\n    modifier afterWhaleAuction(uint _time) {\\n        require(block.timestamp \\u003e= _time, \\\"Whale auction did not end yet\\\");\\n        _;\\n    }\\n    \\n    modifier notWhaleOwner() {\\n        require(msg.sender != _whaleBeneficiary, \\\"Contract owner can not interract here\\\");\\n        _;\\n    }\\n    \\n    modifier onlyWhaleOwner(address messageSender) {\\n        require(_whaleBeneficiary == messageSender, \\\"Only the owner can use this function\\\");\\n        _;\\n    }\\n    \\n    modifier isWhaleWeighting() {\\n        require(address(_whaleWeightingContract) == msg.sender, \\\"Wrong contract passed. Contract is not Weighting\\\");\\n        _;\\n    }\\n    \\n    modifier cantBeFutureOwner(address newBeneficiaryW) {\\n        require(_whaleHighestBidder != newBeneficiaryW, \\\"Can not pass ownership to highest bidder\\\");\\n        _;\\n    }\\n    \\n    modifier lowestWhaleBidMinimum() {\\n        require(msg.value \\u003e= _minimumWhaleBid/(1 ether), \\\"Minimum bid amount required\\\");\\n        _;\\n    }\\n    \\n    modifier highestBidRequired() {\\n        require(msg.value \\u003e _highestBid, \\\"Highest bidder amount required\\\");\\n        _;\\n    }\\n    \\n    modifier sameBidder() {\\n        require(msg.sender == _whaleHighestBidder, \\\"Only the same bidder can add to amount\\\");\\n        _;   \\n    }\\n    \\n    modifier nonWhaleReentrant() {\\n        require(_userWhaleReentrancy[msg.sender] != ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        _userWhaleReentrancy[msg.sender] = ENTERED;\\n        _;\\n        _userWhaleReentrancy[msg.sender] = NOT_ENTERED;\\n    }\\n\\n    constructor(\\n        address payable whaleBeneficiary,\\n        uint minimumWhaleBid,\\n        address whaleWeightingContract\\n    )\\n    {\\n        _whaleBeneficiary = whaleBeneficiary;\\n        _minimumWhaleBid = minimumWhaleBid;\\n        _whaleWeightingContract = whaleWeightingContract;\\n        wcon = Weighting(payable(_whaleWeightingContract));\\n        \\n        _whaleIncrement = 1 ether;\\n        _whaleReturnFee = 0.01 ether;\\n    }\\n    \\n    function whalesBid()\\n        public\\n        payable\\n        beforeWhaleAuction(wcon.getAuctionEndTime())\\n        notWhaleOwner()\\n        lowestWhaleBidMinimum()\\n        highestBidRequired()\\n        whaleMultipleETH()\\n        nonWhaleReentrant()\\n    {\\n        _whalesBid();\\n    }\\n   \\n    function _whalesBid()\\n        internal\\n    {\\n        if (_highestBid != 0) {\\n            _pendingReturns[_whaleHighestBidder] = _pendingReturns[_whaleHighestBidder] + _highestBid;\\n            uint amount = _pendingReturns[_whaleHighestBidder];\\n            if (amount \\u003e 0) {\\n                _pendingReturns[_whaleHighestBidder] = 0;\\n                if (!payable(_whaleHighestBidder).send(amount)) {\\n                    _pendingReturns[_whaleHighestBidder] = amount;\\n                }\\n            }\\n        }\\n        \\n        _whaleHighestBidder = msg.sender;\\n        _highestBid = msg.value;\\n        \\n        uint timeLeft = wcon.getAuctionEndTime() - block.timestamp;\\n        if(timeLeft \\u003c= 15 minutes){\\n            wcon.setAuctionEndTime();\\n        }\\n        _whaleLastBidTime = block.timestamp;\\n    }\\n    \\n    function addToWhalesBid()\\n        public\\n        payable\\n        beforeWhaleAuction(wcon.getAuctionEndTime())\\n        notWhaleOwner()\\n        sameBidder()\\n        whaleMultipleETH()\\n        nonWhaleReentrant()\\n    {\\n        _addToBid();\\n    }\\n    \\n    function _addToBid()\\n        internal\\n    {\\n        if(msg.value \\u003e 0 \\u0026\\u0026 _highestBid \\u003e 0){\\n            _highestBid = _highestBid + msg.value;\\n            _whaleLastBidTime = block.timestamp;\\n        }\\n    }\\n\\n    function _returnWhaleFunds() \\n        external\\n        payable\\n        isWhaleWeighting()\\n        afterWhaleAuction(wcon.getAuctionEndTime())\\n    {\\n        if (_highestBid \\u003e 0) {\\n            uint amount =  address(this).balance - _whaleReturnFee;\\n            payable(_whaleHighestBidder).transfer(amount);\\n        }\\n    }\\n    \\n    function transferWhaleOwnership(address payable newWhaleBeneficiary)\\n        public\\n        onlyWhaleOwner(msg.sender)\\n        beforeWhaleAuction(wcon.getAuctionEndTime())\\n        cantBeFutureOwner(newWhaleBeneficiary)\\n    {\\n        _transferWhaleOwnership(newWhaleBeneficiary);\\n    }\\n   \\n    function _transferWhaleOwnership(address payable newWhaleBeneficiary)\\n        internal\\n    {\\n        require(newWhaleBeneficiary != address(0));\\n        _whaleBeneficiary = newWhaleBeneficiary;  \\n    }\\n    \\n        \\n    function transferWhaleOwnershipToZero()\\n        public\\n        onlyWhaleOwner(msg.sender)\\n        beforeWhaleAuction(wcon.getAuctionEndTime())\\n    {\\n        _transferWhaleOwnershipToZero();\\n    }\\n   \\n    function _transferWhaleOwnershipToZero()\\n        internal\\n    {\\n        _whaleBeneficiary = payable(address(0));  \\n    }\\n    \\n    function whalesTransfer(address recipient, uint256 amount)\\n        public \\n        onlyWhaleOwner(msg.sender)\\n        afterWhaleAuction(wcon.getAuctionEndTime())\\n        returns (bool) \\n    {\\n        _whalesTransfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n    \\n    function _whalesTransfer(address sender, address recipient, uint256 amount) \\n        internal\\n        virtual \\n    {\\n        require(sender != address(0), \\\"Transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"Transfer to the zero address\\\");\\n        uint256 senderBalance = address(this).balance;\\n        require(senderBalance \\u003e= amount, \\\"Transfer amount exceeds balance\\\");\\n        \\n        if(recipient == _whaleHighestBidder){\\n            _highestBid = _highestBid - amount;\\n            if(_highestBid == 0){\\n                _whaleHighestBidder = address(0);\\n            }\\n        }\\n        payable(recipient).transfer(amount);\\n    }\\n    \\n    function whalesWithdrawERC20ContractTokens(IERC20 tokenAddress, address recipient)\\n        public\\n        onlyWhaleOwner(msg.sender)\\n        returns(bool)\\n    {\\n        require(msg.sender != address(0), \\\"Sender is address zero\\\");\\n        require(recipient != address(0), \\\"Receiver is address zero\\\");\\n        tokenAddress.approve(address(this), tokenAddress.balanceOf(address(this)));\\n        if(!tokenAddress.transferFrom(address(this), recipient, tokenAddress.balanceOf(address(this)))){\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    function resetWhaleReentrancy(address user) \\n        public\\n        onlyWhaleOwner(msg.sender)\\n    {\\n        _userWhaleReentrancy[user] = NOT_ENTERED;\\n    }\\n    \\n    function getPendingReturns(address user) \\n        public\\n        view\\n        onlyWhaleOwner(msg.sender)\\n        returns (uint256) \\n    {\\n        return _pendingReturns[user];\\n    }\\n    \\n    function getWhaleReturnFee() \\n        public\\n        view\\n        returns (uint256) \\n    {\\n        return _whaleReturnFee;\\n    }\\n    \\n    function getWhaleReentrancyStatus(address user) \\n        public\\n        view\\n        onlyWhaleOwner(msg.sender)\\n        returns (bool) \\n    {\\n        return _userWhaleReentrancy[user];\\n    }\\n\\n    function getWhaleBeneficiary() \\n        public\\n        view\\n        returns (address) \\n    {\\n        return _whaleBeneficiary;\\n    }\\n    \\n    function getHighestBidder() \\n        public\\n        view\\n        returns (address) \\n    {\\n        return _whaleHighestBidder;\\n    }\\n    \\n    function getWhaleAuctionEndTime() \\n        public\\n        view\\n        returns (uint)\\n    {\\n        return wcon.getAuctionEndTime();\\n    }\\n    \\n    function getWhaleLastBidTime()\\n        public\\n        view\\n        returns (uint)\\n    {\\n        return _whaleLastBidTime;\\n    }\\n    \\n    function getHighestBid() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _highestBid;\\n    }\\n    \\n    function getWhaleIncrement() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return _whaleIncrement;\\n    }\\n    \\n    function getMinimumWhaleBid() \\n        public\\n        view\\n        returns (uint)\\n    {\\n        return _minimumWhaleBid;\\n    }\\n\\n    function getWhaleContractAddress() \\n        public\\n        view\\n        returns (address)\\n    {\\n        return address(this);\\n    }\\n    \\n    function getWhaleContractBalance() \\n        public\\n        view\\n        returns (uint) \\n    {\\n        return address(this).balance;\\n    }\\n    \\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"whaleBeneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumWhaleBid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"whaleWeightingContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"_returnWhaleFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addToWhalesBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHighestBid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getHighestBidder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMinimumWhaleBid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getPendingReturns\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhaleAuctionEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhaleBeneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhaleContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhaleContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhaleIncrement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhaleLastBidTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getWhaleReentrancyStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhaleReturnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"resetWhaleReentrancy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newWhaleBeneficiary\",\"type\":\"address\"}],\"name\":\"transferWhaleOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferWhaleOwnershipToZero\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whalesBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"whalesTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"whalesWithdrawERC20ContractTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Whales","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000d4b34fad94f12958f31bcc1c06ef5640ff382cb0000000000000000000000000000000000000000000000000de0b6b3a7640000000000000000000000000000bb9339a59f4737a05afb618bbe5be634419cde6d","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f77e1c9f42c92301129785180716f5210cad740a23dce04c077959ca74ab5973"}]}