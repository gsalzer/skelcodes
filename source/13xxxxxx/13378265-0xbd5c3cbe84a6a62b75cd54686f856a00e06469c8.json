{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/C/Users/Public/CREEM/contracts/CREEM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"./DividendPayingToken.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./IterableMapping.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./IUniswapV2Pair.sol\\\";\\r\\nimport \\\"./IUniswapV2Factory.sol\\\";\\r\\nimport \\\"./IUniswapV2Router.sol\\\";\\r\\nimport \\\"./CREEMDividendTracker.sol\\\";\\r\\n\\r\\ncontract CREEM is ERC20, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    IUniswapV2Router02 public uniswapV2Router;\\r\\n    address public uniswapV2Pair;\\r\\n\\r\\n    bool private swapping;\\r\\n\\r\\n    CREEMDividendTracker public dividendTracker;\\r\\n    address public peechToken;\\r\\n    address public liquidityWallet;\\r\\n    address public devWallet;\\r\\n    address public rewardsWallet;\\r\\n    address public immutable deadAddress = address(0x000000000000000000000000000000000000dEaD);\\r\\n    uint256 public constant maxSellTransactionAmount = 10**7 * (10**18); // 10M\\r\\n    uint256 public constant maxBuyTransactionAmount = 2 * 10**6 * (10**18); // 2M\\r\\n    uint256 public constant swapTokensAtAmount = 2 * 10**6 * (10**18); //2M\\r\\n    uint256 public constant devFee = 2;\\r\\n    uint256 public constant rewardsFee = 4;\\r\\n    uint256 public constant buybackFee = 4;\\r\\n    uint256 public constant liquidityFee = 2;\\r\\n    uint256 public constant burnFee = 2;\\r\\n    uint256 public totalFees;\\r\\n\\r\\n    // it can only be activated, once activated, it can't be disabled\\r\\n    bool public isTradingEnabled;\\r\\n\\r\\n    // it can only be disactivated once after the presale;\\r\\n    bool public buyLimit = true;\\r\\n    \\r\\n    // exlcude from fees and max transaction amount\\r\\n    mapping (address => bool) private _isExcludedFromFees;\\r\\n\\r\\n    // addresses that can make transfers before presale is over\\r\\n    mapping (address => bool) private canTransferBeforeTradingIsEnabled;\\r\\n\\r\\n    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\\r\\n    // could be subject to a maximum transfer amount\\r\\n    mapping (address => bool) public automatedMarketMakerPairs;\\r\\n\\r\\n    event UpdateDividendTracker(address indexed newAddress, address indexed oldAddress);\\r\\n\\r\\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\\r\\n\\r\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\r\\n\\r\\n    event ExcludeFromDividends(address indexed account);\\r\\n\\r\\n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\\r\\n    \\r\\n    event ExcludeMultipleAccountsFromDividends(address[7] accounts);\\r\\n\\r\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\r\\n\\r\\n    event LiquidityWalletUpdated(address indexed newLiquidityWallet, address indexed oldLiquidityWallet);\\r\\n\\r\\n    event DevWalletUpdated(address indexed newDevWallet, address indexed oldDevWallet);\\r\\n\\r\\n    event RewardsWalletUpdated(address indexed newRewardsWallet, address indexed oldRewardsWallet);\\r\\n\\r\\n    event SwapAndLiquify(\\r\\n        uint256 tokensSwapped,\\r\\n        uint256 ethReceived,\\r\\n        uint256 tokensIntoLiqudity\\r\\n    );\\r\\n\\r\\n    event SendDividends(\\r\\n    \\tuint256 tokensSwapped,\\r\\n    \\tuint256 amount\\r\\n    );\\r\\n    \\r\\n    event burnTokens(\\r\\n    \\tuint256 tokensSwapped\\r\\n    );\\r\\n\\r\\n    event DepositEthSendDividends(\\r\\n    \\tuint256 amount\\r\\n    );\\r\\n\\r\\n    event ProcessedDividendTracker(\\r\\n    \\tuint256 iterations,\\r\\n    \\tuint256 claims,\\r\\n        uint256 lastProcessedIndex,\\r\\n    \\tbool indexed automatic,\\r\\n    \\tuint256 gas,\\r\\n    \\taddress indexed processor\\r\\n    );\\r\\n\\r\\n    constructor(address _peechToken,\\r\\n                address _liquidityWallet,\\r\\n                address _devWallet,\\r\\n                address _rewardsWallet) ERC20(\\\"CREEM\\\", \\\"CREEM\\\") {\\r\\n        peechToken = _peechToken;\\r\\n        liquidityWallet = _liquidityWallet;\\r\\n        devWallet = _devWallet;\\r\\n        rewardsWallet = _rewardsWallet;\\r\\n        totalFees = rewardsFee.add(liquidityFee).add(devFee).add(burnFee).add(buybackFee);\\r\\n        dividendTracker = new CREEMDividendTracker();\\r\\n        _mint(owner(), 10**9 * 10**uint(decimals()));\\r\\n    \\tIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\r\\n        //  Create a uniswap pair for this new token\\r\\n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\r\\n            .createPair(address(this), _uniswapV2Router.WETH());\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n        uniswapV2Pair = _uniswapV2Pair;\\r\\n        dividendTracker.setPair(_uniswapV2Pair);\\r\\n        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\\r\\n        // exclude from receiving dividends\\r\\n        excludeFromDividends(address(dividendTracker));\\r\\n        excludeFromDividends(address(this));\\r\\n        excludeFromDividends(owner());\\r\\n        excludeFromDividends(address(_uniswapV2Router));\\r\\n        excludeFromDividends(devWallet);\\r\\n        excludeFromDividends(rewardsWallet);\\r\\n        excludeFromDividends(liquidityWallet);\\r\\n        // // exclude from paying fees or having max transaction amount\\r\\n        excludeFromFees(liquidityWallet, true);\\r\\n        excludeFromFees(devWallet, true);\\r\\n        excludeFromFees(rewardsWallet, true);\\r\\n        excludeFromFees(address(this), true);\\r\\n        excludeFromFees(owner(), true);\\r\\n        // // enable owner and fixed-sale wallet to send tokens before presales are over\\r\\n        canTransferBeforeTradingIsEnabled[owner()] = true;\\r\\n        canTransferBeforeTradingIsEnabled[0xF99baEc9220b02C6E34845259bA558E2f55576C5] = true;\\r\\n    }\\r\\n    receive() external payable {\\r\\n  \\t}\\r\\n    function updateDividendTracker(address newAddress) public onlyOwner {\\r\\n        require(newAddress != address(dividendTracker), \\\"CREEM: The dividend tracker already has that address\\\");\\r\\n        CREEMDividendTracker newDividendTracker = CREEMDividendTracker(payable(newAddress));\\r\\n        require(newDividendTracker.owner() == address(this), \\\"CREEM: The new dividend tracker must be owned by the CREEM token contract\\\");\\r\\n        newDividendTracker.excludeFromDividends(address(newDividendTracker));\\r\\n        newDividendTracker.excludeFromDividends(address(this));\\r\\n        newDividendTracker.excludeFromDividends(owner());\\r\\n        newDividendTracker.excludeFromDividends(address(uniswapV2Router));\\r\\n        newDividendTracker.excludeFromDividends(devWallet);\\r\\n        newDividendTracker.excludeFromDividends(rewardsWallet);\\r\\n        newDividendTracker.excludeFromDividends(liquidityWallet);\\r\\n        emit UpdateDividendTracker(newAddress, address(dividendTracker));\\r\\n        dividendTracker = newDividendTracker;\\r\\n    }\\r\\n    function updateUniswapV2Router(address newAddress) public onlyOwner {\\r\\n        require(newAddress != address(uniswapV2Router), \\\"CREEM: The router already has that address\\\");\\r\\n        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));\\r\\n        uniswapV2Router = IUniswapV2Router02(newAddress);\\r\\n    }\\r\\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\r\\n        require(_isExcludedFromFees[account] != excluded, \\\"CREEM: Account is already the value of 'excluded'\\\");\\r\\n        _isExcludedFromFees[account] = excluded;\\r\\n        emit ExcludeFromFees(account, excluded);\\r\\n    }\\r\\n    function excludeFromDividends(address account) public onlyOwner {\\r\\n        require(!dividendTracker.isExcludedFromDividends(account), \\\"CREEM: Account is already excluded from dividends\\\");\\r\\n        dividendTracker.excludeFromDividends(account);\\r\\n        emit ExcludeFromDividends(account);\\r\\n    }\\r\\n    function setPeech(address _newAddress) external onlyOwner {\\r\\n        require(peechToken != _newAddress,\\\"CREEM: peechToken has similar address!\\\");\\r\\n        peechToken = _newAddress;\\r\\n    }\\r\\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\\r\\n        for(uint256 i = 0; i < accounts.length; i++) {\\r\\n            _isExcludedFromFees[accounts[i]] = excluded;\\r\\n        }\\r\\n        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\\r\\n    }\\r\\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\\r\\n        require(pair != uniswapV2Pair, \\\"CREEM: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs\\\");\\r\\n        _setAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\r\\n        require(automatedMarketMakerPairs[pair] != value, \\\"CREEM: Automated market maker pair is already set to that value\\\");\\r\\n        automatedMarketMakerPairs[pair] = value;\\r\\n        if(value) {\\r\\n            dividendTracker.excludeFromDividends(pair);\\r\\n        }\\r\\n        emit SetAutomatedMarketMakerPair(pair, value);\\r\\n    }\\r\\n    function updateLiquidityWallet(address newLiquidityWallet) public onlyOwner {\\r\\n        require(newLiquidityWallet != liquidityWallet, \\\"CREEM: The liquidity wallet is already this address\\\");\\r\\n        excludeFromFees(newLiquidityWallet, true);\\r\\n        emit LiquidityWalletUpdated(newLiquidityWallet, liquidityWallet);\\r\\n        liquidityWallet = newLiquidityWallet;\\r\\n    }\\r\\n    function updateDevWallet(address newDevWallet) public onlyOwner {\\r\\n        require(newDevWallet != devWallet, \\\"CREEM: The development wallet is already this address\\\");\\r\\n        excludeFromFees(newDevWallet, true);\\r\\n        emit DevWalletUpdated(newDevWallet, devWallet);\\r\\n        devWallet = newDevWallet;\\r\\n    }\\r\\n    function updateRewardsWallet(address newRewardsWallet) public onlyOwner {\\r\\n        require(newRewardsWallet != rewardsWallet, \\\"CREEM: The development wallet is already this address\\\");\\r\\n        excludeFromFees(newRewardsWallet, true);\\r\\n        emit RewardsWalletUpdated(newRewardsWallet, rewardsWallet);\\r\\n        rewardsWallet = newRewardsWallet;\\r\\n    }\\r\\n    function getTotalDividendsDistributed() external view returns (uint256) {\\r\\n        return dividendTracker.totalDividendsDistributed();\\r\\n    }\\r\\n    function isExcludedFromFees(address account) public view returns(bool) {\\r\\n        return _isExcludedFromFees[account];\\r\\n    }\\r\\n    function isExcludedFromDividends(address account) public view returns(bool) { \\r\\n        return dividendTracker.isExcludedFromDividends(account);\\r\\n    }\\r\\n    function withdrawnDividendOf(address account) public view returns(uint256) {\\r\\n    \\treturn dividendTracker.withdrawnDividendOf(account);\\r\\n  \\t}\\r\\n\\tfunction dividendTokenBalanceOf(address account) public view returns (uint256) {\\r\\n\\t\\treturn dividendTracker.balanceOf(account);\\r\\n\\t}\\r\\n    function getAccountDividendsInfo(address account)\\r\\n        external view returns (\\r\\n            address,\\r\\n            int256,\\r\\n            uint8,\\r\\n            uint256) {\\r\\n        return dividendTracker.getAccount(account);\\r\\n    }\\r\\n\\tfunction getAccountDividendsInfoAtIndex(uint256 index)\\r\\n        external view returns (\\r\\n            address,\\r\\n            int256,\\r\\n            uint8,\\r\\n            uint256) {\\r\\n    \\treturn dividendTracker.getAccountAtIndex(index);\\r\\n    }\\r\\n    function minimumValueTier(uint8 _tier) public view returns(uint){\\r\\n        return dividendTracker.minimumValueTier(_tier);\\r\\n    }\\r\\n    function minimumTier(uint8 _tier) public view returns(uint){\\r\\n        return dividendTracker.minimumTier(_tier);\\r\\n    }\\r\\n    function minimumRewards(uint8 _tier) public view returns(uint){\\r\\n        return dividendTracker.minimumRewards(_tier);\\r\\n    }\\r\\n    function getNumberOfDividendTokenHolders() external view returns(uint256) {\\r\\n        return dividendTracker.getNumberOfTokenHolders();\\r\\n    }\\r\\n    function activateTrading() external onlyOwner {\\r\\n        require(!isTradingEnabled,\\\"CREEM: trading has already been activated\\\");\\r\\n        isTradingEnabled = true;\\r\\n    }\\r\\n    function disableBuyLimit() external onlyOwner{\\r\\n        require(buyLimit,\\\"CREEM: buy limit already disactivated\\\");\\r\\n        buyLimit = false;\\r\\n    }\\r\\n    function shuffle() external onlyOwner{\\r\\n        dividendTracker.shuffle();\\r\\n    }\\r\\n    // make sure that values are in wei\\r\\n    function setTierRewards(uint tier1, uint tier2, uint tier3, uint tier4) external onlyOwner{\\r\\n        dividendTracker.setTierRewards(tier1,tier2,tier3,tier4);\\r\\n    }\\r\\n    // make sure that values are in wei\\r\\n    function setTierThreshold(uint tier1, uint tier2, uint tier3, uint tier4) external onlyOwner{\\r\\n        dividendTracker.setTierThreshold(tier1,tier2,tier3,tier4);\\r\\n    }\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        \\r\\n        if(!isTradingEnabled) {\\r\\n            require(canTransferBeforeTradingIsEnabled[from], \\\"CREEM: This account cannot send tokens until trading is enabled\\\");\\r\\n        }\\r\\n        if(amount == 0) {\\r\\n            super._transfer(from, to, 0);\\r\\n            return;\\r\\n        }\\r\\n        if( \\r\\n        \\t!swapping &&\\r\\n        \\tisTradingEnabled &&\\r\\n            automatedMarketMakerPairs[to] && // sells only by detecting transfer to automated market maker pair\\r\\n        \\tfrom != address(uniswapV2Router) && //router -> pair is removing liquidity which shouldn't have max\\r\\n            !_isExcludedFromFees[to] //no max for those excluded from fees\\r\\n        ) {\\r\\n            require(amount <= maxSellTransactionAmount, \\\"CREEM: Sell transfer amount exceeds the maxSellTransactionAmount.\\\");\\r\\n        }\\r\\n        if( buyLimit &&\\r\\n        \\t!swapping &&\\r\\n        \\tisTradingEnabled &&\\r\\n            automatedMarketMakerPairs[from] && // buy only by detecting transfer from automated market maker pair\\r\\n        \\tto != address(uniswapV2Router) && //router -> pair is adding liquidity which shouldn't have max\\r\\n            !_isExcludedFromFees[to] //no max for those excluded from fees\\r\\n        ) {\\r\\n            require(amount <= maxBuyTransactionAmount, \\\"CREEM: Buy transfer amount exceeds the maxBuyTransactionAmount.\\\");\\r\\n        }\\r\\n\\t\\tuint256 contractTokenBalance = balanceOf(address(this));\\r\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\r\\n        if(\\r\\n            isTradingEnabled && \\r\\n            canSwap &&\\r\\n            !swapping &&\\r\\n            !automatedMarketMakerPairs[from] &&\\r\\n            from != liquidityWallet &&\\r\\n            to != liquidityWallet\\r\\n        ) {\\r\\n            swapping = true;\\r\\n            uint256 swapLiquidityTokens = contractTokenBalance.mul(liquidityFee).div(totalFees);\\r\\n            swapAndLiquify(swapLiquidityTokens);\\r\\n            uint256 swapDevTokens = contractTokenBalance.mul(devFee).div(totalFees);\\r\\n            swapAndSend(devWallet,swapDevTokens);\\r\\n            uint256 swapBuybackTokens = contractTokenBalance.mul(buybackFee).div(totalFees);\\r\\n            swapAndBurn(swapBuybackTokens);\\r\\n            uint256 swapBurnTokens = contractTokenBalance.mul(burnFee).div(totalFees);\\r\\n            _burn(address(this),swapBurnTokens);\\r\\n            uint256 swapDividendTokens = balanceOf(address(this));\\r\\n            swapAndSend(rewardsWallet,swapDividendTokens);\\r\\n            swapping = false;\\r\\n        }\\r\\n        bool takeFee = isTradingEnabled && !swapping;\\r\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\r\\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\r\\n            takeFee = false;\\r\\n        }\\r\\n        if(takeFee && \\r\\n           (automatedMarketMakerPairs[from] ||\\r\\n           automatedMarketMakerPairs[to])) {\\r\\n        \\tuint256 fees = amount.mul(totalFees).div(100);\\r\\n        \\tamount = amount.sub(fees);\\r\\n            super._transfer(from, address(this), fees);\\r\\n        }\\r\\n        super._transfer(from, to, amount);\\r\\n        try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\\r\\n        try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\\r\\n    }\\r\\n    function swapAndLiquify(uint256 tokens) private {\\r\\n        // split the contract balance into halves\\r\\n        uint256 half = tokens.div(2);\\r\\n        uint256 otherHalf = tokens.sub(half);\\r\\n        \\r\\n        uint256 initialBalance = address(this).balance;\\r\\n        // swap tokens for ETH\\r\\n        swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\\r\\n        // how much ETH did we just swap into?\\r\\n        uint256 newBalance = address(this).balance.sub(initialBalance);\\r\\n        // add liquidity to uniswap\\r\\n        addLiquidity(otherHalf, newBalance);\\r\\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\r\\n    }\\r\\n    function swapTokensForEth(uint256 tokenAmount) private {\\r\\n        // generate the uniswap pair path of token -> weth\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n        // make the swap\\r\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        ); \\r\\n    }\\r\\n    function swapTokensAndBurn(uint256 tokenAmount) private {\\r\\n        // generate the uniswap pair path of token -> weth\\r\\n        address[] memory path = new address[](3);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n        path[2] = peechToken;\\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n        // make the swap\\r\\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0, // accept any amount of ETH\\r\\n            path,\\r\\n            deadAddress,\\r\\n            block.timestamp\\r\\n        ); \\r\\n    }\\r\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\r\\n        // approve token transfer to cover all possible scenarios\\r\\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\r\\n        // add the liquidity\\r\\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            0,\\r\\n            0,\\r\\n            liquidityWallet,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n    function swapAndSend(address wallet, uint256 tokens) private {\\r\\n        swapTokensForEth(tokens);\\r\\n        uint256 dividends = address(this).balance;\\r\\n        (bool success,) = wallet.call{value: dividends}(\\\"\\\");\\r\\n        if(success) {\\r\\n   \\t \\t\\temit SendDividends(tokens, dividends);\\r\\n        }\\r\\n    }\\r\\n    function swapAndBurn(uint256 tokens) private {\\r\\n        swapTokensAndBurn(tokens);\\r\\n   \\t \\temit burnTokens(tokens);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/C/Users/Public/CREEM/contracts/CREEMDividendTracker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"./DividendPayingToken.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./SafeMathUint8.sol\\\";\\r\\nimport \\\"./IterableMapping.sol\\\";\\r\\nimport \\\"./IUniswapV2Pair.sol\\\";\\r\\nimport \\\"./IERC20Metadata.sol\\\";\\r\\ncontract CREEMDividendTracker is DividendPayingToken, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeMathUint8 for uint8;\\r\\n    using IterableMapping for IterableMapping.Map;\\r\\n    \\r\\n    event ExcludeFromDividends(address indexed account);\\r\\n\\r\\n    uint[] public minTiers = [100,500,1000,2000];\\r\\n    uint[] public tiersRewards = [0.1 ether, 0.5 ether, 1 ether, 2 ether];\\r\\n    IterableMapping.Map private tokenHoldersMap;\\r\\n    // to be edited\\r\\n    IUniswapV2Pair USDTPair = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);\\r\\n    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n    IUniswapV2Pair public CreemPair;\\r\\n    mapping (address => bool) public excludedFromDividends;\\r\\n\\r\\n    constructor() DividendPayingToken(\\\"CREEM Dividends\\\", \\\"CREEM_D\\\") {\\r\\n    }\\r\\n    function setPair(address _pair) external onlyOwner {\\r\\n        CreemPair = IUniswapV2Pair(_pair);\\r\\n    }\\r\\n    // make sure that values are in wei\\r\\n    function setTierRewards(uint tier1, uint tier2, uint tier3, uint tier4) external onlyOwner{\\r\\n        require(tier1>0 && tier2>tier1 && tier3>tier2 && tier4>tier3, \\\"CREEM_D: tiers are not in order\\\");\\r\\n        tiersRewards[0] = tier1;\\r\\n        tiersRewards[1] = tier2;\\r\\n        tiersRewards[2] = tier3;\\r\\n        tiersRewards[3] = tier4;\\r\\n    }\\r\\n    // make sure that values are natural numbers which represent the dollar value needed\\r\\n    function setTierThreshold(uint tier1, uint tier2, uint tier3, uint tier4) external onlyOwner{\\r\\n        require(tier1>0 && tier2>tier1 && tier3>tier2 && tier4>tier3, \\\"CREEM_D: tiers are not in order\\\");\\r\\n        minTiers[0] = tier1;\\r\\n        minTiers[1] = tier2;\\r\\n        minTiers[2] = tier3;\\r\\n        minTiers[3] = tier4;\\r\\n    }\\r\\n    function excludeFromDividends(address account) external onlyOwner {\\r\\n    \\trequire(!excludedFromDividends[account],\\\"CREEM_D: Address already excluded from dividends\\\");\\r\\n    \\texcludedFromDividends[account] = true;\\r\\n    \\t_setBalance(account, 0);\\r\\n    \\ttokenHoldersMap.remove(account);\\r\\n    \\ttokenHoldersMap.setTier(account, IterableMapping.Tier.DEFAULT);\\r\\n    \\temit ExcludeFromDividends(account);\\r\\n    }\\r\\n    function setBalance(address payable account, uint256 newBalance) public onlyOwner {\\r\\n    \\tif(excludedFromDividends[account]) return;\\r\\n    \\t\\r\\n        if(newBalance > minimumForDividends(minTiers[0])) {\\r\\n            \\r\\n            _setBalance(account, newBalance);\\r\\n    \\t\\ttokenHoldersMap.set(account, newBalance);\\r\\n    \\t\\t\\r\\n    \\t\\tif(newBalance > minimumForDividends(minTiers[3])){\\r\\n    \\t\\t    tokenHoldersMap.setTier(account,IterableMapping.Tier.TIER4);\\r\\n    \\t\\t}else if(newBalance > minimumForDividends(minTiers[2])){\\r\\n    \\t\\t    tokenHoldersMap.setTier(account,IterableMapping.Tier.TIER3);\\r\\n    \\t\\t}else if(newBalance > minimumForDividends(minTiers[1])){\\r\\n    \\t\\t    tokenHoldersMap.setTier(account,IterableMapping.Tier.TIER2);\\r\\n    \\t\\t}else{\\r\\n    \\t\\t    tokenHoldersMap.setTier(account,IterableMapping.Tier.TIER1);\\r\\n    \\t\\t}\\r\\n    \\t} else {\\r\\n            _setBalance(account, 0);\\r\\n            tokenHoldersMap.setTier(account,IterableMapping.Tier.DEFAULT);\\r\\n    \\t    tokenHoldersMap.remove(account);\\r\\n    \\t}\\r\\n    }\\r\\n    \\r\\n    function shuffle() public onlyOwner{\\r\\n        uint len = tokenHoldersMap.keys.length;\\r\\n        require(len > 0,\\\"CREEM_D: there must be a minimum of 1 dividneds holders\\\");\\r\\n        uint256 amount = getBalance();\\r\\n        require(amount > 0, \\\"CREEM_D: insufficient balance!\\\");\\r\\n        uint size = sizeCalc(amount,tiersRewards[0]);\\r\\n        address[] memory addr = new address[](size);\\r\\n        uint i = randomIndex(len);\\r\\n        for(uint j = 0;j<size;j++){\\r\\n            if(i==len) i = 0;\\r\\n            (address account,,,) = getAccountAtIndex(i);\\r\\n            uint reward = getTierReward(account);\\r\\n            if(amount > reward){\\r\\n                amount.sub(reward);\\r\\n                addr[j] = account;\\r\\n            }else{\\r\\n                amount = 0;\\r\\n                addr[j] = account;\\r\\n                break;\\r\\n            }\\r\\n            i++;\\r\\n        }\\r\\n        address[] memory addrs = sort(addr);\\r\\n        amount = getBalance();\\r\\n        for(uint j = 0 ; j < addrs.length; j++){\\r\\n            address account = addrs[j];\\r\\n            uint reward = getTierReward(account);\\r\\n            if(amount > reward){\\r\\n                amount = amount.sub(reward);\\r\\n                processAccount(payable(account),reward);\\r\\n            }else{\\r\\n                processAccount(payable(account),amount);\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function processAccount(address payable account,uint amount) internal returns (bool) {\\r\\n        uint256 _amount = _withdrawDividendOfUser(account,amount);\\r\\n        return _amount > 0;\\r\\n    }\\r\\n    function getBalance() internal view returns(uint){\\r\\n        return address(this).balance;\\r\\n    }\\r\\n    function getTierReward(address addr) internal view returns(uint){\\r\\n        return tiersRewards[uint(tokenHoldersMap.getTier(addr)).sub(1)];\\r\\n    }\\r\\n    function _transfer(address, address, uint256) internal pure override {\\r\\n        require(false, \\\"CREEM_D: No transfers allowed\\\");\\r\\n    }\\r\\n    function sort(address[] memory arr) internal view returns(address[] memory addr){\\r\\n        uint size = arr.length;\\r\\n        addr = new address[](size);\\r\\n        uint i = 0;\\r\\n        while(size > i){\\r\\n            uint higher = greatest(arr);\\r\\n            addr[i] = arr[higher];\\r\\n            delete arr[higher];\\r\\n            i++;\\r\\n        }\\r\\n    }\\r\\n    function greatest(address[] memory arr) internal view returns(uint){\\r\\n        uint num = 0;\\r\\n        for(uint i=1;i<arr.length;i++){\\r\\n            if(balanceOf(arr[i]) > balanceOf(arr[num])){\\r\\n                num = i;\\r\\n            }\\r\\n        }\\r\\n        return num;\\r\\n    }\\r\\n    function isExcludedFromDividends(address account) public view returns(bool) {\\r\\n        return excludedFromDividends[account];\\r\\n    }\\r\\n\\r\\n    function getNumberOfTokenHolders() public view returns(uint256) {\\r\\n        return tokenHoldersMap.keys.length;\\r\\n    }\\r\\n    function getAccount(address _account)\\r\\n        public view returns (\\r\\n            address account,\\r\\n            int256 index,\\r\\n            uint8 tier,\\r\\n            uint256 totalDividends) {\\r\\n        account = _account;\\r\\n\\r\\n        index = tokenHoldersMap.getIndexOfKey(account);\\r\\n        \\r\\n        tier = uint8(tokenHoldersMap.getTier(_account));\\r\\n        \\r\\n        totalDividends = withdrawnDividendOf(account);\\r\\n    }\\r\\n\\r\\n    function getAccountAtIndex(uint256 index)\\r\\n        public view returns (\\r\\n            address,\\r\\n            int256,\\r\\n            uint8,\\r\\n            uint256) {\\r\\n    \\tif(index >= tokenHoldersMap.size()) return (0x0000000000000000000000000000000000000000, -1, 0, 0);\\r\\n        address account = tokenHoldersMap.getKeyAtIndex(index);\\r\\n        return getAccount(account);\\r\\n    }\\r\\n    function getReservesOnOrder(IUniswapV2Pair pairAddress) internal view returns(uint, uint){\\r\\n        address addr1 = pairAddress.token1();\\r\\n        (uint Res0, uint Res1,) = pairAddress.getReserves();\\r\\n        return (addr1 == WETH) ? (Res0,Res1) : (Res1,Res0);\\r\\n    }\\r\\n    function getTokenPrice(IUniswapV2Pair pairAddress, uint amount, bool isEth) internal view returns(uint){\\r\\n        // isEth check is the amount in is Eth or not\\r\\n        (uint Res0, uint Res1) = getReservesOnOrder(pairAddress);\\r\\n        return isEth ? ((amount*Res0)/Res1) : ((amount*Res1)/Res0);\\r\\n    }\\r\\n    function minimumForDividends(uint min) internal view returns(uint){\\r\\n        address token1 = USDTPair.token0(); \\r\\n        uint ethAmount = getTokenPrice(USDTPair,min * 10** IERC20Metadata(token1).decimals(),false);\\r\\n        return getTokenPrice(CreemPair,ethAmount,true);\\r\\n    }\\r\\n    function randomIndex(uint len) internal view returns (uint256) {\\r\\n        return uint(keccak256(abi.encodePacked(msg.sender, block.difficulty, block.timestamp))) % len;\\r\\n    }\\r\\n    function minimumValueTier(uint8 _tier) public view returns(uint){\\r\\n        require(_tier >= 1 && _tier <= 4,\\\"CREEM_D: invalid tier\\\");\\r\\n        return minimumForDividends(minTiers[_tier.sub(1)]).mul(80).div(100 * 1 ether);\\r\\n    }\\r\\n    function minimumTier(uint8 _tier) public view returns(uint){\\r\\n        require(_tier >= 1 && _tier <= 4,\\\"CREEM_D: invalid tier\\\");\\r\\n        return minTiers[_tier-1];\\r\\n    }\\r\\n    function minimumRewards(uint8 _tier) public view returns(uint){\\r\\n        require(_tier >= 1 && _tier <= 4,\\\"CREEM_D: invalid tier\\\");\\r\\n        return tiersRewards[_tier-1];\\r\\n    }\\r\\n    function sizeCalc(uint256 amount, uint256 parameter) internal pure returns(uint){\\r\\n      if(amount < parameter){\\r\\n        return 1;\\r\\n      }else{\\r\\n        uint256 remainder = amount.mod(parameter) == 0 ? 0 : 1;\\r\\n        return amount.div(parameter).add(remainder);\\r\\n      }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/C/Users/Public/CREEM/contracts/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/C/Users/Public/CREEM/contracts/DividendPayingToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ERC20.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./DividendPayingTokenInterface.sol\\\";\\r\\nimport \\\"./DividendPayingTokenOptionalInterface.sol\\\";\\r\\n\\r\\ncontract DividendPayingToken is ERC20, DividendPayingTokenInterface, DividendPayingTokenOptionalInterface {\\r\\n  using SafeMath for uint256;\\r\\n  mapping(address => uint256) internal withdrawnDividends;\\r\\n\\r\\n  uint256 public totalDividendsDistributed;\\r\\n\\r\\n  constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}\\r\\n\\r\\n  /// @dev Distributes dividends whenever ether is paid to this contract.\\r\\n  receive() external payable {\\r\\n    distributeDividends();\\r\\n  }\\r\\n\\r\\n  /// @notice Distributes ether to token holders as dividends.\\r\\n  function distributeDividends() public override payable {\\r\\n    require(totalSupply() > 0,\\\"dividened totalsupply error\\\");\\r\\n    if (msg.value > 0) {\\r\\n      emit DividendsDistributed(msg.sender, msg.value);\\r\\n      totalDividendsDistributed = totalDividendsDistributed.add(msg.value);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Withdraws the ether distributed to the sender.\\r\\n  /// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn ether is greater than 0.\\r\\n  function _withdrawDividendOfUser(address payable user, uint256 amount) internal returns (uint256) {\\r\\n    if (amount > 0) {\\r\\n      withdrawnDividends[user] = withdrawnDividends[user].add(amount);\\r\\n      (bool success,) = user.call{value: amount}(\\\"\\\");\\r\\n      if(!success) {\\r\\n        withdrawnDividends[user] = withdrawnDividends[user].sub(amount);\\r\\n        return 0;\\r\\n      }\\r\\n      return amount;\\r\\n    }\\r\\n    return 0;\\r\\n  }\\r\\n\\r\\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\\r\\n  /// @param _owner The address of a token holder.\\r\\n  /// @return The amount of dividend in wei that `_owner` has withdrawn.\\r\\n  function withdrawnDividendOf(address _owner) public view override returns(uint256) {\\r\\n    return withdrawnDividends[_owner];\\r\\n  }\\r\\n\\r\\n  function _mint(address account, uint256 value) internal override {\\r\\n    super._mint(account, value);\\r\\n  }\\r\\n\\r\\n  function _burn(address account, uint256 value) internal override {\\r\\n    super._burn(account, value);\\r\\n  }\\r\\n\\r\\n  function _setBalance(address account, uint256 newBalance) internal {\\r\\n    uint256 currentBalance = balanceOf(account);\\r\\n    if(newBalance > currentBalance) {\\r\\n      uint256 mintAmount = newBalance.sub(currentBalance);\\r\\n      _mint(account, mintAmount);\\r\\n    } else if(newBalance < currentBalance) {\\r\\n      uint256 burnAmount = currentBalance.sub(newBalance);\\r\\n      _burn(account, burnAmount);\\r\\n    }\\r\\n  }\\r\\n}\"\r\n    },\r\n    \"/C/Users/Public/CREEM/contracts/DividendPayingTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n/// @title Dividend-Paying Token Interface\\r\\n/// @author Roger Wu (https://github.com/roger-wu)\\r\\n/// @dev An interface for a dividend-paying token contract.\\r\\ninterface DividendPayingTokenInterface {\\r\\n\\r\\n  function distributeDividends() external payable;\\r\\n\\r\\n  event DividendsDistributed(\\r\\n    address indexed from,\\r\\n    uint256 weiAmount\\r\\n  );\\r\\n\\r\\n  event DividendWithdrawn(\\r\\n    address indexed to,\\r\\n    uint256 weiAmount\\r\\n  );\\r\\n}\"\r\n    },\r\n    \"/C/Users/Public/CREEM/contracts/DividendPayingTokenOptionalInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\n/// @title Dividend-Paying Token Optional Interface\\r\\n/// @author Roger Wu (https://github.com/roger-wu)\\r\\n/// @dev OPTIONAL functions for a dividend-paying token contract.\\r\\ninterface DividendPayingTokenOptionalInterface {\\r\\n\\r\\n  function withdrawnDividendOf(address _owner) external view returns(uint256);\\r\\n}\"\r\n    },\r\n    \"/C/Users/Public/CREEM/contracts/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./IERC20Metadata.sol\\\";\\r\\nimport \\\"./Context.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    function name() public view virtual override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view virtual override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view virtual override returns (uint8) {\\r\\n        return 18;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view virtual override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    function burn(uint256 amount) external {\\r\\n        _burn(msg.sender,amount);\\r\\n    }\\r\\n\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) internal virtual {}\\r\\n}\"\r\n    },\r\n    \"/C/Users/Public/CREEM/contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    \\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n    \\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    \\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"\r\n    },\r\n    \"/C/Users/Public/CREEM/contracts/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\r\\n *\\r\\n * _Available since v4.1._\\r\\n */\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function decimals() external view returns (uint8);\\r\\n}\"\r\n    },\r\n    \"/C/Users/Public/CREEM/contracts/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\"\r\n    },\r\n    \"/C/Users/Public/CREEM/contracts/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\"\r\n    },\r\n    \"/C/Users/Public/CREEM/contracts/IUniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n// pragma solidity >=0.6.2;\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountETH);\\r\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountETH);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable;\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n}\"\r\n    },\r\n    \"/C/Users/Public/CREEM/contracts/IterableMapping.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary IterableMapping {\\r\\n    // Iterable mapping from address to uint;\\r\\n    enum Tier{\\r\\n        DEFAULT,TIER1,TIER2,TIER3,TIER4\\r\\n    }\\r\\n    struct Map {\\r\\n        address[] keys;\\r\\n        mapping(address => uint) values;\\r\\n        mapping(address => uint) indexOf;\\r\\n        mapping(address => bool) inserted;\\r\\n        mapping(address => Tier) tier;\\r\\n    }\\r\\n\\r\\n    function get(Map storage map, address key) public view returns (uint) {\\r\\n        return map.values[key];\\r\\n    }\\r\\n    function getTier(Map storage map, address key) public view returns (Tier) {\\r\\n        return map.tier[key];\\r\\n    }\\r\\n    function setTier(Map storage map, address key, Tier val) public {\\r\\n        map.tier[key] = val;\\r\\n    }\\r\\n    function getIndexOfKey(Map storage map, address key) public view returns (int) {\\r\\n        if(!map.inserted[key]) {\\r\\n            return -1;\\r\\n        }\\r\\n        return int(map.indexOf[key]);\\r\\n    }\\r\\n\\r\\n    function getKeyAtIndex(Map storage map, uint index) public view returns (address) {\\r\\n        return map.keys[index];\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function size(Map storage map) public view returns (uint) {\\r\\n        return map.keys.length;\\r\\n    }\\r\\n\\r\\n    function set(Map storage map, address key, uint val) public {\\r\\n        if (map.inserted[key]) {\\r\\n            map.values[key] = val;\\r\\n        } else {\\r\\n            map.inserted[key] = true;\\r\\n            map.values[key] = val;\\r\\n            map.indexOf[key] = map.keys.length;\\r\\n            map.keys.push(key);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function remove(Map storage map, address key) public {\\r\\n        if (!map.inserted[key]) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        delete map.inserted[key];\\r\\n        delete map.values[key];\\r\\n\\r\\n        uint index = map.indexOf[key];\\r\\n        uint lastIndex = map.keys.length - 1;\\r\\n        address lastKey = map.keys[lastIndex];\\r\\n\\r\\n        map.indexOf[lastKey] = index;\\r\\n        delete map.indexOf[key];\\r\\n\\r\\n        map.keys[index] = lastKey;\\r\\n        map.keys.pop();\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/C/Users/Public/CREEM/contracts/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\r\\n\\r\\n// SPDX-License-Identifier: MIT License\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/C/Users/Public/CREEM/contracts/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary SafeMath {\\r\\n \\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/C/Users/Public/CREEM/contracts/SafeMathUint8.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary SafeMathUint8 {\\r\\n \\r\\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(uint8 a, uint8 b, string memory errorMessage) internal pure returns (uint8) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint8 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"/C/Users/Public/CREEM/contracts/IterableMapping.sol\": {\r\n        \"IterableMapping\": \"0x64e324E4e48af3281b961dA1e514eCf196319bb9\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_peechToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositEthSendDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDevWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldDevWallet\",\"type\":\"address\"}],\"name\":\"DevWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ExcludeFromDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[7]\",\"name\":\"accounts\",\"type\":\"address[7]\"}],\"name\":\"ExcludeMultipleAccountsFromDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeMultipleAccountsFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newLiquidityWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldLiquidityWallet\",\"type\":\"address\"}],\"name\":\"LiquidityWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastProcessedIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"}],\"name\":\"ProcessedDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRewardsWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRewardsWallet\",\"type\":\"address\"}],\"name\":\"RewardsWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SendDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateUniswapV2Router\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"}],\"name\":\"burnTokens\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activateTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buybackFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableBuyLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendTokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendTracker\",\"outputs\":[{\"internalType\":\"contract CREEMDividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeMultipleAccountsFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountDividendsInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getAccountDividendsInfoAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfDividendTokenHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDividendsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromDividends\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_tier\",\"type\":\"uint8\"}],\"name\":\"minimumRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_tier\",\"type\":\"uint8\"}],\"name\":\"minimumTier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_tier\",\"type\":\"uint8\"}],\"name\":\"minimumValueTier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"peechToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setPeech\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tier1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tier2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tier3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tier4\",\"type\":\"uint256\"}],\"name\":\"setTierRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tier1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tier2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tier3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tier4\",\"type\":\"uint256\"}],\"name\":\"setTierThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shuffle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDevWallet\",\"type\":\"address\"}],\"name\":\"updateDevWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLiquidityWallet\",\"type\":\"address\"}],\"name\":\"updateLiquidityWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRewardsWallet\",\"type\":\"address\"}],\"name\":\"updateRewardsWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateUniswapV2Router\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawnDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"CREEM","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"00000000000000000000000031d939dc09a6bb55642fcbf9d56166ebc0bdec9a00000000000000000000000066f6d7958049bfded399cd68aff49e0f2a9dcd4f000000000000000000000000240c42b59185ca2b1de9bf2fd54043b00fd774040000000000000000000000003beaae2f6972521f7d3e627ec4448d27207c7a47","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}