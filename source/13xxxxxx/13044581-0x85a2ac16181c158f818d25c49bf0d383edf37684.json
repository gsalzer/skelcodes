{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CompoundExchangeRate.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\nimport \\\"./interfaces/ICToken.sol\\\";\\nimport \\\"./interfaces/ITrigger.sol\\\";\\n\\n/**\\n * @notice Defines a trigger that is toggled if the Compound exchange rate decreases between consecutive checks. Under\\n * normal operation, this value should only increase\\n */\\ncontract CompoundExchangeRate is ITrigger {\\n  uint256 internal constant WAD = 10**18;\\n\\n  /// @notice Address of CToken market protected by this trigger\\n  ICToken public immutable market;\\n\\n  /// @notice Last read exchangeRateStored\\n  uint256 public lastExchangeRate;\\n\\n  /// @dev Due to rounding errors in the Compound Protocol, the exchangeRateStored may occassionally decrease by small\\n  /// amount even when nothing is wrong. A large, very conservative tolerance is applied to ensure we do not\\n  /// accidentally trigger in these cases. Even though a smaller tolerance would likely be ok, a non-trivial exploit\\n  ///  will most likely cause the exchangeRateStored to decrease by more than 10,000 wei\\n  uint256 public constant tolerance = 10000; // 10,000 wei tolerance\\n\\n  /**\\n   * @param _market Is the address of the Compound market this trigger should protect\\n   * @dev For definitions of other constructor parameters, see ITrigger.sol\\n   */\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    string memory _description,\\n    uint256[] memory _platformIds,\\n    address _recipient,\\n    address _market\\n  ) ITrigger(_name, _symbol, _description, _platformIds, _recipient) {\\n    // Set market\\n    market = ICToken(_market);\\n\\n    // Save current exchange rate (immutables can't be read at construction, so we don't use `market` directly)\\n    lastExchangeRate = ICToken(_market).exchangeRateStored();\\n  }\\n\\n  /**\\n   * @dev Checks if a CToken's exchange rate decreased. The exchange rate should never decrease, but may occasionally\\n   * decrease slightly due to rounding errors\\n   * @return True if trigger condition occured (i.e. exchange rate decreased), false otherwise\\n   */\\n  function checkTriggerCondition() internal override returns (bool) {\\n    // Read this blocks exchange rate\\n    uint256 _currentExchangeRate = market.exchangeRateStored();\\n\\n    // Check if current exchange rate is below current exchange rate, accounting for tolerance\\n    bool _status = _currentExchangeRate < (lastExchangeRate - tolerance);\\n\\n    // Save the new exchange rate\\n    lastExchangeRate = _currentExchangeRate;\\n\\n    // Return status\\n    return _status;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\ninterface ICToken {\\n  function totalReserves() external view returns (uint256);\\n\\n  function totalBorrows() external view returns (uint256);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function getCash() external view returns (uint256);\\n\\n  function exchangeRateStored() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITrigger.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\n/**\\n * @notice Abstract contract for creating or interacting with a Trigger contract\\n * @dev All trigger contracts created must inerit from this contract and conform to this interface\\n */\\nabstract contract ITrigger {\\n  /// @notice Trigger name, analgous to an ERC-20 token's name\\n  string public name;\\n\\n  /// @notice Trigger symbol, analgous to an ERC-20 token's symbol\\n  string public symbol;\\n\\n  /// @notice Trigger description\\n  string public description;\\n\\n  /// @notice Array of IDs of platforms covered by this trigger\\n  uint256[] public platformIds;\\n\\n  /// @notice Returns address of recipient who receives subsidies for creating a protection market using this trigger\\n  address public immutable recipient;\\n\\n  /// @notice Returns true if trigger condition has been met\\n  bool public isTriggered;\\n\\n  /// @notice Emitted when the trigger is activated\\n  event TriggerActivated();\\n\\n  /**\\n   * @notice Returns array of IDs, where each ID corresponds to a platform covered by this trigger\\n   * @dev See documentation for mapping of ID numbers to platforms\\n   */\\n  function getPlatformIds() external view returns (uint256[] memory) {\\n    return platformIds;\\n  }\\n\\n  /**\\n   * @dev Executes trigger-specific logic to check if market has been triggered\\n   * @return True if trigger condition occured, false otherwise\\n   */\\n  function checkTriggerCondition() internal virtual returns (bool);\\n\\n  /**\\n   * @notice Checks trigger condition, sets isTriggered flag to true if condition is met, and returns the trigger status\\n   * @return True if trigger condition occured, false otherwise\\n   */\\n  function checkAndToggleTrigger() external returns (bool) {\\n    // Return true if trigger already toggled\\n    if (isTriggered) return true;\\n\\n    // Return false if market has not been triggered\\n    if (!checkTriggerCondition()) return false;\\n\\n    // Otherwise, market has been triggered\\n    emit TriggerActivated();\\n    isTriggered = true;\\n    return isTriggered;\\n  }\\n\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    string memory _description,\\n    uint256[] memory _platformIds,\\n    address _recipient\\n  ) {\\n    name = _name;\\n    description = _description;\\n    symbol = _symbol;\\n    platformIds = _platformIds;\\n    recipient = _recipient;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/YearnV2SharePrice.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\nimport \\\"./interfaces/IYVaultV2.sol\\\";\\nimport \\\"./interfaces/ITrigger.sol\\\";\\n\\n/**\\n * @notice Defines a trigger that is toggled if the price per share for the V2 yVault decreases between consecutive\\n * checks. Under normal operation, this value should only increase\\n */\\ncontract YearnV2SharePrice is ITrigger {\\n  uint256 internal constant WAD = 10**18;\\n\\n  /// @notice Vault this trigger is for\\n  IYVaultV2 public immutable market;\\n\\n  /// @notice Last read pricePerShare\\n  uint256 public lastPricePerShare;\\n\\n  /// @dev In Yearn V2 vaults, the pricePerShare decreases immediately after a harvest, and typically ramps up over the\\n  /// next six hours. Therefore we cannot simply check that the pricePerShare increases. Instead, we consider the vault\\n  /// triggered if the pricePerShare drops by more than 50% from it's previous value. This is conservative, but\\n  /// previous Yearn bugs resulted in pricePerShare drops of 0.5% – 10%, and were only temporary drops with users able\\n  /// to be made whole. Therefore this trigger requires a large 50% drop to minimize false positives. The tolerance\\n  /// is defined such that we trigger if: currentPricePerShare < lastPricePerShare * tolerance / 1e18. This means\\n  /// if you want to trigger after a 20% drop, you should set the tolerance to 1e18 - 0.2e18 = 0.8e18 = 8e17\\n  uint256 public constant tolerance = 5e17; // 50%, represented on a scale where 1e18 = 100%\\n\\n  /**\\n   * @param _market Is the address of the Yearn V2 vault this trigger should protect\\n   * @dev For definitions of other constructor parameters, see ITrigger.sol\\n   */\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    string memory _description,\\n    uint256[] memory _platformIds,\\n    address _recipient,\\n    address _market\\n  ) ITrigger(_name, _symbol, _description, _platformIds, _recipient) {\\n    // Set vault\\n    market = IYVaultV2(_market);\\n\\n    // Save current share price (immutables can't be read at construction, so we don't use `market` directly)\\n    lastPricePerShare = IYVaultV2(_market).pricePerShare();\\n  }\\n\\n  /**\\n   * @dev Checks the yVault pricePerShare\\n   */\\n  function checkTriggerCondition() internal override returns (bool) {\\n    // Read this blocks share price\\n    uint256 _currentPricePerShare = market.pricePerShare();\\n\\n    // Check if current share price is below current share price, accounting for tolerance\\n    bool _status = _currentPricePerShare < ((lastPricePerShare * tolerance) / 1e18);\\n\\n    // Save the new share price\\n    lastPricePerShare = _currentPricePerShare;\\n\\n    // Return status\\n    return _status;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IYVaultV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\ninterface IYVaultV2 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function pricePerShare() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/YearnCrvTwoTokens.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.6;\\n\\nimport \\\"./interfaces/ICurvePool.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/ITrigger.sol\\\";\\nimport \\\"./interfaces/IYVaultV2.sol\\\";\\n\\n/**\\n * @notice Defines a trigger that is toggled if any of the following conditions occur:\\n *   1. The price per share for the V2 yVault significantly decreases between consecutive checks. Under normal\\n *      operation, this value should only increase. A decrease indicates something is wrong with the Yearn vault\\n *   2. Curve Tricrypto token balances are significantly lower than what the pool expects them to be\\n *   3. Curve Tricrypto virtual price drops significantly\\n * @dev This trigger is for Yearn V2 Vaults that use a Curve pool with two underlying tokens\\n */\\ncontract YearnCrvTwoTokens is ITrigger {\\n  // --- Tokens ---\\n  // Token addresses\\n  IERC20 internal immutable token0;\\n  IERC20 internal immutable token1;\\n\\n  // --- Tolerances ---\\n  /// @dev Scale used to define percentages. Percentages are defined as tolerance / scale\\n  uint256 public constant scale = 1000;\\n\\n  /// @dev In Yearn V2 vaults, the pricePerShare decreases immediately after a harvest, and typically ramps up over the\\n  /// next six hours. Therefore we cannot simply check that the pricePerShare increases. Instead, we consider the vault\\n  /// triggered if the pricePerShare drops by more than 50% from it's previous value. This is conservative, but\\n  /// previous Yearn bugs resulted in pricePerShare drops of 0.5% – 10%, and were only temporary drops with users able\\n  /// to be made whole. Therefore this trigger requires a large 50% drop to minimize false positives. The tolerance\\n  /// is defined such that we trigger if: currentPricePerShare < lastPricePerShare * tolerance / 1000. This means\\n  /// if you want to trigger after a 20% drop, you should set the tolerance to 1000 - 200 = 800\\n  uint256 public constant vaultTol = scale - 500; // 50% drop, represented on a scale where 1000 = 100%\\n\\n  /// @dev Consider trigger toggled if Curve virtual price drops by more than this percentage.\\n  uint256 public constant virtualPriceTol = scale - 500; // 50% drop\\n\\n  /// @dev Consider trigger toggled if Curve internal balances are lower than true balances by this percentage\\n  uint256 public constant balanceTol = scale - 500; // 50% drop\\n\\n  // --- Trigger Data ---\\n  /// @notice Yearn vault this trigger is for\\n  IYVaultV2 public immutable vault;\\n\\n  /// @notice Curve tricrypto pool used as a strategy by `vault`\\n  ICurvePool public immutable curve;\\n\\n  /// @notice Last read pricePerShare\\n  uint256 public lastPricePerShare;\\n\\n  /// @notice Last read curve virtual price\\n  uint256 public lastVirtualPrice;\\n\\n  // --- Constructor ---\\n\\n  /**\\n   * @param _vault Address of the Yearn V2 vault this trigger should protect\\n   * @param _curve Address of the Curve Tricrypto pool uses by the above Yearn vault\\n   * @dev For definitions of other constructor parameters, see ITrigger.sol\\n   */\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    string memory _description,\\n    uint256[] memory _platformIds,\\n    address _recipient,\\n    address _vault,\\n    address _curve\\n  ) ITrigger(_name, _symbol, _description, _platformIds, _recipient) {\\n    // Set trigger data\\n    vault = IYVaultV2(_vault);\\n    curve = ICurvePool(_curve);\\n    token0 = IERC20(ICurvePool(_curve).coins(0));\\n    token1 = IERC20(ICurvePool(_curve).coins(1));\\n\\n    // Save current values (immutables can't be read at construction, so we don't use `vault` or `curve` directly)\\n    lastPricePerShare = IYVaultV2(_vault).pricePerShare();\\n    lastVirtualPrice = ICurvePool(_curve).get_virtual_price();\\n  }\\n\\n  // --- Trigger condition ---\\n\\n  /**\\n   * @dev Checks the yVault pricePerShare\\n   */\\n  function checkTriggerCondition() internal override returns (bool) {\\n    // Read this blocks share price and virtual price\\n    uint256 _currentPricePerShare = vault.pricePerShare();\\n    uint256 _currentVirtualPrice = curve.get_virtual_price();\\n\\n    // Check trigger conditions. We could check one at a time and return as soon as one is true, but it is convenient\\n    // to have the data that caused the trigger saved into the state, so we don't do that\\n    bool _statusVault = _currentPricePerShare < ((lastPricePerShare * vaultTol) / scale);\\n    bool _statusVirtualPrice = _currentVirtualPrice < ((lastVirtualPrice * virtualPriceTol) / scale);\\n    bool _statusBalances = checkCurveBalances();\\n\\n    // Save the new data\\n    lastPricePerShare = _currentPricePerShare;\\n    lastVirtualPrice = _currentVirtualPrice;\\n\\n    // Return status\\n    return _statusVault || _statusVirtualPrice || _statusBalances;\\n  }\\n\\n  /**\\n   * @dev Checks if the Curve internal balances are significantly lower than the true balances\\n   * @return True if balances are out of tolerance and trigger should be toggled\\n   */\\n  function checkCurveBalances() internal view returns (bool) {\\n    return\\n      (token0.balanceOf(address(curve)) < ((curve.balances(0) * balanceTol) / scale)) ||\\n      (token1.balanceOf(address(curve)) < ((curve.balances(1) * balanceTol) / scale));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICurvePool.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\ninterface ICurvePool {\\n  /// @notice Computes current virtual price\\n  function get_virtual_price() external view returns (uint256);\\n\\n  /// @notice Cached virtual price, used internally\\n  function virtual_price() external view returns (uint256);\\n\\n  /// @notice Current full profit\\n  function xcp_profit() external view returns (uint256);\\n\\n  /// @notice Full profit at last claim of admin fees\\n  function xcp_profit_a() external view returns (uint256);\\n\\n  /// @notice Pool admin fee\\n  function admin_fee() external view returns (uint256);\\n\\n  /// @notice Returns balance for the token defined by the provided index\\n  function balances(uint256 index) external view returns (uint256);\\n\\n  /// @notice Returns the address of the token for the provided index\\n  function coins(uint256 index) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/YearnCrvTricrypto.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\nimport \\\"./interfaces/ICurvePool.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/ITrigger.sol\\\";\\nimport \\\"./interfaces/IYVaultV2.sol\\\";\\n\\n/**\\n * @notice Defines a trigger that is toggled if any of the following conditions occur:\\n *   1. The price per share for the V2 yVault significantly decreases between consecutive checks. Under normal\\n *      operation, this value should only increase. A decrease indicates something is wrong with the Yearn vault\\n *   2. Curve Tricrypto token balances are significantly lower than what the pool expects them to be\\n *   3. Curve Tricrypto virtual price drops significantly\\n */\\ncontract YearnCrvTricrypto is ITrigger {\\n  // --- Tokens ---\\n  // Token addresses\\n  IERC20 internal constant usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\\n  IERC20 internal constant wbtc = IERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);\\n  IERC20 internal constant weth = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\\n\\n  // Token indices in Curve pool arrays\\n  uint256 internal constant usdtIndex = 0;\\n  uint256 internal constant wbtcIndex = 1;\\n  uint256 internal constant wethIndex = 2;\\n\\n  // --- Tolerances ---\\n  /// @dev Scale used to define percentages. Percentages are defined as tolerance / scale\\n  uint256 public constant scale = 1000;\\n\\n  /// @dev In Yearn V2 vaults, the pricePerShare decreases immediately after a harvest, and typically ramps up over the\\n  /// next six hours. Therefore we cannot simply check that the pricePerShare increases. Instead, we consider the vault\\n  /// triggered if the pricePerShare drops by more than 50% from it's previous value. This is conservative, but\\n  /// previous Yearn bugs resulted in pricePerShare drops of 0.5% – 10%, and were only temporary drops with users able\\n  /// to be made whole. Therefore this trigger requires a large 50% drop to minimize false positives. The tolerance\\n  /// is defined such that we trigger if: currentPricePerShare < lastPricePerShare * tolerance / 1000. This means\\n  /// if you want to trigger after a 20% drop, you should set the tolerance to 1000 - 200 = 800\\n  uint256 public constant vaultTol = scale - 500; // 50% drop, represented on a scale where 1000 = 100%\\n\\n  /// @dev Consider trigger toggled if Curve virtual price drops by this percentage. Similar to the Yearn V2 price\\n  /// per share, the virtual price is expected to decrease during normal operation, but it can never decrease by\\n  /// more than 50% during normal operation. Therefore we check for a 51% drop\\n  uint256 public constant virtualPriceTol = scale - 510; // 51% drop, since 1000-510=490, and multiplying by 0.49 = 51% drop\\n\\n  /// @dev Consider trigger toggled if Curve internal balances are lower than true balances by this percentage\\n  uint256 public constant balanceTol = scale - 500; // 50% drop\\n\\n  // --- Trigger Data ---\\n  /// @notice Yearn vault this trigger is for\\n  IYVaultV2 public immutable vault;\\n\\n  /// @notice Curve tricrypto pool used as a strategy by `vault`\\n  ICurvePool public immutable curve;\\n\\n  /// @notice Last read pricePerShare\\n  uint256 public lastPricePerShare;\\n\\n  /// @notice Last read curve virtual price\\n  uint256 public lastVirtualPrice;\\n\\n  // --- Constructor ---\\n\\n  /**\\n   * @param _vault Address of the Yearn V2 vault this trigger should protect\\n   * @param _curve Address of the Curve Tricrypto pool uses by the above Yearn vault\\n   * @dev For definitions of other constructor parameters, see ITrigger.sol\\n   */\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    string memory _description,\\n    uint256[] memory _platformIds,\\n    address _recipient,\\n    address _vault,\\n    address _curve\\n  ) ITrigger(_name, _symbol, _description, _platformIds, _recipient) {\\n    // Set vault\\n    vault = IYVaultV2(_vault);\\n    curve = ICurvePool(_curve);\\n\\n    // Save current values (immutables can't be read at construction, so we don't use `vault` or `curve` directly)\\n    lastPricePerShare = IYVaultV2(_vault).pricePerShare();\\n    lastVirtualPrice = ICurvePool(_curve).get_virtual_price();\\n  }\\n\\n  // --- Trigger condition ---\\n\\n  /**\\n   * @dev Checks the yVault pricePerShare\\n   */\\n  function checkTriggerCondition() internal override returns (bool) {\\n    // Read this blocks share price and virtual price\\n    uint256 _currentPricePerShare = vault.pricePerShare();\\n    uint256 _currentVirtualPrice = curve.get_virtual_price();\\n\\n    // Check trigger conditions. We could check one at a time and return as soon as one is true, but it is convenient\\n    // to have the data that caused the trigger saved into the state, so we don't do that\\n    bool _statusVault = _currentPricePerShare < ((lastPricePerShare * vaultTol) / scale);\\n    bool _statusVirtualPrice = _currentVirtualPrice < ((lastVirtualPrice * virtualPriceTol) / scale);\\n    bool _statusBalances = checkCurveBalances();\\n\\n    // Save the new data\\n    lastPricePerShare = _currentPricePerShare;\\n    lastVirtualPrice = _currentVirtualPrice;\\n\\n    // Return status\\n    return _statusVault || _statusVirtualPrice || _statusBalances;\\n  }\\n\\n  /**\\n   * @dev Checks if the Curve internal balances are significantly lower than the true balances\\n   * @return True if balances are out of tolerance and trigger should be toggled\\n   */\\n  function checkCurveBalances() internal view returns (bool) {\\n    return\\n      (usdt.balanceOf(address(curve)) < ((curve.balances(usdtIndex) * balanceTol) / scale)) ||\\n      (wbtc.balanceOf(address(curve)) < ((curve.balances(wbtcIndex) * balanceTol) / scale)) ||\\n      (weth.balanceOf(address(curve)) < ((curve.balances(wethIndex) * balanceTol) / scale));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/test/MockCrvTricrypto.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\nimport \\\"../interfaces/ICurvePool.sol\\\";\\n\\n/**\\n * @notice Mock Curve Tricrypto pool, containing the same interface but configurable parameters for testing\\n */\\ncontract MockCrvTricrypto is ICurvePool {\\n  uint256 public override get_virtual_price;\\n  uint256 public override virtual_price;\\n  uint256 public override xcp_profit;\\n  uint256 public override xcp_profit_a;\\n  uint256 public override admin_fee;\\n\\n  constructor() {\\n    // Initializing the values based on the actual values on 2021-07-15\\n    get_virtual_price = 1001041521509972624;\\n    virtual_price = 1001041521509972624;\\n    xcp_profit = 1001056295181177762;\\n    xcp_profit_a = 1001035776942422073;\\n    admin_fee = 5000000000;\\n  }\\n\\n  /**\\n   * @notice Set the pricePerShare\\n   * @param _get_virtual_price New get_virtual_price value\\n   */\\n  function set(uint256 _get_virtual_price) external {\\n    get_virtual_price = _get_virtual_price;\\n  }\\n\\n  function balances(uint256 index) external pure override returns (uint256) {\\n    require(index == 0 || index == 1 || index == 2, \\\"bad index\\\");\\n    return 1;\\n  }\\n\\n  function coins(uint256 index) external pure override returns (address) {\\n    // This method is not used and is just to satisfy the interface this contract inherits from\\n    index; // silence compiler warning about unused variables\\n    return address(0);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/SaddleThreeTokens.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.6;\\n\\nimport \\\"./interfaces/ISaddlePool.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/ITrigger.sol\\\";\\nimport \\\"./interfaces/IYVaultV2.sol\\\";\\n\\n/**\\n * @notice Defines a trigger that is toggled if any of the following conditions occur:\\n *   1. Saddle token balances are significantly lower than what the pool expects them to be\\n *   2. Saddle virtual price drops significantly\\n * @dev This trigger is for Yearn V2 Vaults that use a Saddle pool with two underlying tokens\\n */\\ncontract SaddleThreeTokens is ITrigger {\\n  // --- Tokens ---\\n  // Token addresses\\n  IERC20 internal immutable token0;\\n  IERC20 internal immutable token1;\\n  IERC20 internal immutable token2;\\n\\n  // --- Tolerances ---\\n  /// @dev Scale used to define percentages. Percentages are defined as tolerance / scale\\n  uint256 public constant scale = 1000;\\n\\n  /// @dev Consider trigger toggled if Saddle virtual price drops by more than this percentage.\\n  uint256 public constant virtualPriceTol = scale - 500; // 50% drop\\n\\n  /// @dev Consider trigger toggled if Saddle internal balances are lower than true balances by this percentage\\n  uint256 public constant balanceTol = scale - 500; // 50% drop\\n\\n  // --- Trigger Data ---\\n  /// @notice Saddle pool to protect\\n  ISaddlePool public immutable saddle;\\n\\n  /// @notice Last read Saddle virtual price\\n  uint256 public lastVirtualPrice;\\n\\n  // --- Constructor ---\\n  /**\\n   * @param _saddle Address of the Saddle pool, must contain three underlying tokens\\n   * @dev For definitions of other constructor parameters, see ITrigger.sol\\n   */\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    string memory _description,\\n    uint256[] memory _platformIds,\\n    address _recipient,\\n    address _saddle\\n  ) ITrigger(_name, _symbol, _description, _platformIds, _recipient) {\\n    // Set trigger data\\n    saddle = ISaddlePool(_saddle);\\n    token0 = IERC20(ISaddlePool(_saddle).getToken(0));\\n    token1 = IERC20(ISaddlePool(_saddle).getToken(1));\\n    token2 = IERC20(ISaddlePool(_saddle).getToken(2));\\n\\n    // Save current values (immutables can't be read at construction, so we don't use `vault` or `saddle` directly)\\n    lastVirtualPrice = ISaddlePool(_saddle).getVirtualPrice();\\n  }\\n\\n  // --- Trigger condition ---\\n  /**\\n   * @dev Checks the yVault pricePerShare\\n   */\\n  function checkTriggerCondition() internal override returns (bool) {\\n    // Read this blocks share price and virtual price\\n    uint256 _currentVirtualPrice = saddle.getVirtualPrice();\\n\\n    // Check trigger conditions. We could check one at a time and return as soon as one is true, but it is convenient\\n    // to have the data that caused the trigger saved into the state, so we don't do that\\n    bool _statusVirtualPrice = _currentVirtualPrice < ((lastVirtualPrice * virtualPriceTol) / scale);\\n    bool _statusBalances = checkSaddleBalances();\\n\\n    // Save the new data\\n    lastVirtualPrice = _currentVirtualPrice;\\n\\n    // Return status\\n    return _statusVirtualPrice || _statusBalances;\\n  }\\n\\n  /**\\n   * @dev Checks if the Saddle internal balances are significantly lower than the true balances\\n   * @return True if balances are out of tolerance and trigger should be toggled\\n   */\\n  function checkSaddleBalances() internal view returns (bool) {\\n    return\\n      (token0.balanceOf(address(saddle)) < ((saddle.getTokenBalance(0) * balanceTol) / scale)) ||\\n      (token1.balanceOf(address(saddle)) < ((saddle.getTokenBalance(1) * balanceTol) / scale)) ||\\n      (token2.balanceOf(address(saddle)) < ((saddle.getTokenBalance(2) * balanceTol) / scale));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISaddlePool.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\ninterface ISaddlePool {\\n  /// @notice Computes current virtual price\\n  function getVirtualPrice() external view returns (uint256);\\n\\n  /// @notice Returns balance for the token defined by the provided index\\n  function getTokenBalance(uint8 index) external view returns (uint256);\\n\\n  /// @notice Returns the address of the token for the provided index\\n  function getToken(uint8 index) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/test/MockYVaultV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\nimport \\\"../interfaces/IYVaultV2.sol\\\";\\n\\n/**\\n * @notice Mock yVault, implemented the same way as a Yearn vault, but with configurable parameters for testing\\n */\\ncontract MockYVaultV2 is IYVaultV2 {\\n  uint256 public override pricePerShare;\\n  uint256 public underlyingDecimals = 6; // decimals of USDC underlying\\n  uint256 public override totalSupply; // not used, but needed so this is not an abstract contract\\n\\n  constructor() {\\n    // Initializing the values based on the yUSDC values on 2021-06-03\\n    pricePerShare = 1058448;\\n  }\\n\\n  /**\\n   * @notice Set the pricePerShare\\n   * @param _pricePerShare New pricePerShare value\\n   */\\n  function set(uint256 _pricePerShare) external {\\n    pricePerShare = _pricePerShare;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/test/MockCozyToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\nimport \\\"../interfaces/ITrigger.sol\\\";\\n\\n/**\\n * @notice Mock MockCozyToken, for testing the return value of a trigger's `checkAndToggleTrigger()` method\\n */\\ncontract MockCozyToken {\\n  /// @notice Trigger contract address\\n  address public immutable trigger;\\n\\n  /// @notice In a real Cozy Token, this state variable is toggled when trigger event occues\\n  bool public isTriggered;\\n\\n  constructor(address _trigger) {\\n    // Set the trigger address in the constructor\\n    trigger = _trigger;\\n  }\\n\\n  /**\\n   * @notice Sufficiently mimics the implementation of a Cozy Token's `checkAndToggleTriggerInternal()` method\\n   */\\n  function checkAndToggleTrigger() external {\\n    isTriggered = ITrigger(trigger).checkAndToggleTrigger();\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/MockTrigger.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\nimport \\\"./interfaces/ITrigger.sol\\\";\\n\\ncontract MockTrigger is ITrigger {\\n  /// @notice If true, checkAndToggleTrigger will toggle the trigger on its next call\\n  bool public shouldToggle;\\n\\n  constructor(\\n    string memory _name,\\n    string memory _symbol,\\n    string memory _description,\\n    uint256[] memory _platformIds,\\n    address _recipient,\\n    bool _shouldToggle\\n  ) ITrigger(_name, _symbol, _description, _platformIds, _recipient) {\\n    shouldToggle = _shouldToggle;\\n\\n    // Verify market is not already triggered.\\n    require(!checkTriggerCondition(), \\\"Already triggered\\\");\\n  }\\n\\n  /**\\n   * @notice Special function for this mock trigger to set whether or not the trigger should toggle\\n   */\\n  function setShouldToggle(bool _shouldToggle) external {\\n    require(!isTriggered, \\\"Cannot set after trigger event\\\");\\n    shouldToggle = _shouldToggle;\\n  }\\n\\n  /**\\n   * @notice Returns true if the market has been triggered, false otherwise\\n   */\\n  function checkTriggerCondition() internal view override returns (bool) {\\n    return shouldToggle;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/test/MockCToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.5;\\n\\nimport \\\"../interfaces/ICToken.sol\\\";\\n\\n/**\\n * @notice Mock CToken, implemented the same way as a Compound CToken, but with configurable parameters for testing\\n */\\n\\ncontract MockCToken is ICToken {\\n  uint256 public override totalReserves;\\n  uint256 public override totalBorrows;\\n  uint256 public override totalSupply;\\n  uint256 public override exchangeRateStored;\\n  uint256 internal cash; // this is the balanceOf the underlying ERC20/ETH\\n  uint256 public underlyingDecimals = 6; // decimals of USDC underlying\\n\\n  constructor() {\\n    // Initializing the values based on the cUSDC values on 2021-05-10 (around block 12,409,320)\\n    totalReserves = 5359893964073; // units of USDC\\n    totalBorrows = 3681673803163527; // units of USDC\\n    totalSupply = 20287132947568793418; // units of cUSDC\\n    exchangeRateStored = 219815665774648; // units of 10^(18 + underlyingDecimals - 8)\\n    cash = 783115726329188; // units of USDC\\n  }\\n\\n  /**\\n   * @notice Set the value of a parameter\\n   * @param _name Name of the variable to set\\n   * @param _value Value to set the parameter to\\n   */\\n  function set(bytes32 _name, uint256 _value) external {\\n    if (_name == \\\"totalReserves\\\") totalReserves = _value;\\n    if (_name == \\\"totalBorrows\\\") totalBorrows = _value;\\n    if (_name == \\\"totalSupply\\\") totalSupply = _value;\\n    if (_name == \\\"exchangeRateStored\\\") exchangeRateStored = _value;\\n    if (_name == \\\"cash\\\") cash = _value;\\n  }\\n\\n  /**\\n   * @notice Get cash balance of this cToken in the underlying asset\\n   * @return The quantity of underlying asset owned by this contract\\n   */\\n  function getCash() external view override returns (uint256) {\\n    return cash;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"_platformIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_saddle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TriggerActivated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"balanceTol\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkAndToggleTrigger\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlatformIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTriggered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastVirtualPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"platformIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saddle\",\"outputs\":[{\"internalType\":\"contract ISaddlePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"virtualPriceTol\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SaddleThreeTokens","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000002400000000000000000000000005d2fe9837dc18bdbc2a935dc6803817194880a15000000000000000000000000a6018520eaacc06c30ff2e1b3ee2c7c22e64196a0000000000000000000000000000000000000000000000000000000000000014536164646c6520616c45544820547269676765720000000000000000000000000000000000000000000000000000000000000000000000000000000000000010736164646c65616c4554482d545249470000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d65472696767657273207768656e2074686520536164646c6520616c45544820706f6f6c207669727475616c20707269636520646563726561736573206279206d6f7265207468616e20353025206265747765656e20636f6e736563757469766520636865636b732c206f72207768656e2074686520696e7465726e616c2062616c616e63657320747261636b656420696e2074686520536164646c6520616c45544820706f6f6c20617265206d6f7265207468616e20353025206c6f776572207468616e2074686520747275652062616c616e6365730000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000007","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}