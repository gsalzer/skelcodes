{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/TokenReleaser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// We'll actually use ERC777, but any IERC20 instance (including ERC777)\\n// is supported.\\nimport 'openzeppelin-solidity/contracts/token/ERC20/IERC20.sol';\\n\\n\\ncontract TokenReleaser {\\n\\n\\n\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////\\n    // This smart contract is divided into 3 parts: \\n    //\\n    // - The first part defines the different types of releases (i.e token release for seed round investor,\\n    //   token release for team and advisor ...etc). Here we define the `ReleaseType` and `ReleaseSchedule`\\n    //   types, and the function `setTokenomics` which associate to each ReleaseType its associated \\n    //   `ReleaseSchedule`. The association between the type of release and its schedule is what we call\\n    //   the `tokenomic`. Notice `setTokenomics` is called only once, therefore `tokenomic` behaves like\\n    //   a constant (unfortunately, due to solidity limitations it couldn't get declared as such).\\n    //\\n    // - Second part defines the `Beneficiary`, which represent an user (or more generally an address),\\n    //   that got some tokens booked; and the external function `releaseToken`. A beneficiary will call\\n    //   `releaseToken` to receive tokens, which will be sent according to the Beneficiary's release\\n    //   schedule type. Notice `releaseToken` is the only public function a non-admin user can call. \\n    //\\n    // - The third part defines the admins, and the action they control. Each of these actions\\n    //   is represented by a function and an Event. For security and simplicity reason, we've decide\\n    //   to keep a fixed max number of admins, 3 of them specifically (though by default we only enable 2 \\n    //   of them). At any time, any admin can modify the list of admins. \\n    //\\n    // Types, variables and events are defined right before they are mentioned on code. \\n\\n    IERC20  public tokenContract;\\n    \\n    constructor(address _adminA, address _adminB, IERC20 _contract, uint256 avaliableTokens){\\n        tokenContract  = _contract;\\n        adminA         = _adminA;\\n        adminB         = _adminB;\\n        setTokenomics(avaliableTokens);\\n    }\\n\\n\\n\\n    //////////////////////////////////////////////////////////////////////////////////////////////////////\\n    // First part:\\n\\n\\n    enum ReleaseType\\n      { SEED_ROUND\\n      , PRIVATE_ROUND\\n      , STRATEGIC_ROUND\\n      , PUBLIC_SALE\\n      , COMPANY_RESERVE\\n      , TEAM_AND_ADVISORS\\n      , STRATEGIC_PARTNERS\\n      , FOUNDERS_AND_EARLY_CONTRIBUTORS\\n      , MINING_RESERVE\\n      }\\n\\n    // Information about how an specific ReleaseType will be scheduled.\\n    struct ReleaseSchedule\\n     {  uint256 tokenLockTime             ; // lockup time after the release time starts.\\n\\n        uint256 tokenReleaseDuration      ; // vesting time during which the token will be gradually released.\\n                                            // if 0, it means everything available at once. \\n\\n        uint256 immediateAccessTimeWindow ; // When the release time starts, the beneficiary will have immediate access to \\n     }                                      // all the tokens to be released to him during the his `immediateAccessTimeWindow`.\\n\\n\\n    mapping(ReleaseType => ReleaseSchedule) public tokenomic;\\n    uint256 public avaliableTokensToRelease;\\n    \\n\\n    // Defines the total amount of tokens available to get release, and how the schedule\\n    // for each type of release will be. \\n    function setTokenomics(uint256 avaliableTokens) private{\\n\\n        // NOTICE: we take a month to be equivalent to 30 days, regardless of actual calendar months.\\n        // In particular, 12 month would not sum up a whole year, but 360 days.\\n\\n        tokenomic[ ReleaseType.SEED_ROUND                     ] = ReleaseSchedule\\n         ({ tokenLockTime             :  0 * 30 days\\n          , tokenReleaseDuration      : 24 * 30 days \\n          , immediateAccessTimeWindow :  1 * 30 days\\n          }\\n         );\\n\\n        tokenomic[ ReleaseType.PRIVATE_ROUND                  ] = ReleaseSchedule\\n         ({ tokenLockTime             :  0 * 30 days\\n          , tokenReleaseDuration      : 12 * 30 days\\n          , immediateAccessTimeWindow :  1 * 30 days\\n          }\\n         );\\n\\n        tokenomic[ ReleaseType.STRATEGIC_ROUND                ] = ReleaseSchedule\\n         ({ tokenLockTime             :  0 * 30 days\\n          , tokenReleaseDuration      : 12 * 30 days\\n          , immediateAccessTimeWindow :  1 * 30 days\\n          }\\n         );\\n\\n        tokenomic[ ReleaseType.PUBLIC_SALE                    ] = ReleaseSchedule\\n         ({ tokenLockTime             :  0 * 30 days\\n          , tokenReleaseDuration      :  0 * 30 days\\n          , immediateAccessTimeWindow :  0 * 30 days \\n          } // as `tokenReleaseDuration == 0` everything is available as soon as the release time starts. \\n         );\\n\\n        tokenomic[ ReleaseType.COMPANY_RESERVE                ] = ReleaseSchedule\\n         ({ tokenLockTime             :  0 * 30 days\\n          , tokenReleaseDuration      : 36 * 30 days\\n          , immediateAccessTimeWindow :  1 * 30 days\\n          }\\n         );\\n\\n        tokenomic[ ReleaseType.TEAM_AND_ADVISORS              ] = ReleaseSchedule\\n         ({ tokenLockTime             : 12 * 30 days\\n          , tokenReleaseDuration      : 36 * 30 days\\n          , immediateAccessTimeWindow :  0 * 30 days\\n          }\\n         );\\n\\n        tokenomic[ ReleaseType.STRATEGIC_PARTNERS             ] = ReleaseSchedule\\n         ({ tokenLockTime             : 12 * 30 days\\n          , tokenReleaseDuration      : 36 * 30 days\\n          , immediateAccessTimeWindow :  0 * 30 days\\n          }\\n         );\\n\\n        tokenomic[ ReleaseType.FOUNDERS_AND_EARLY_CONTRIBUTORS] = ReleaseSchedule\\n         ({ tokenLockTime             : 12 * 30 days\\n          , tokenReleaseDuration      : 48 * 30 days\\n          , immediateAccessTimeWindow :  0 * 30 days\\n          }\\n         );\\n\\n        tokenomic[ ReleaseType.MINING_RESERVE                 ] = ReleaseSchedule\\n         ({ tokenLockTime             :  6 * 30 days\\n          , tokenReleaseDuration      : 60 * 30 days\\n          , immediateAccessTimeWindow :  0 * 30 days\\n          }\\n         );\\n\\n        avaliableTokensToRelease = avaliableTokens;\\n    }\\n    \\n    \\n    //////////////////////////////////////////////////////////////////////////////////////////\\n    // Second Part:\\n\\n    struct Beneficiary\\n     {  ReleaseType releaseSchedule       ;     // public sale, seed round ...\\n        uint256     tokensAlreadyReleased ;\\n        uint256     tokenBookedAmount     ;\\n     }\\n\\n    uint256 public releaseStartTime;\\n    mapping(address => Beneficiary) public beneficiaries;\\n\\n    function releaseToken() external{\\n        \\n        require( releaseStartTime > 0\\n               , 'Release time has not started yet'\\n               )\\n        ;\\n\\n        Beneficiary memory beneficiary = beneficiaries[msg.sender];\\n        \\n        require( beneficiary.tokenBookedAmount != 0\\n               , 'Address doesnt belong to a beneficiary set by an admin.'\\n               )\\n        ;\\n\\n\\n        ReleaseSchedule memory releaseSchedule    = tokenomic[beneficiary.releaseSchedule];\\n        \\n        // Date the tokens locktime finish for the beneficiary. \\n        uint256 startTime = releaseSchedule.tokenLockTime + releaseStartTime;\\n        \\n        // After the locktime has finished, there's a time window defined as `tokenReleaseDuration`. \\n        // `timeCompleted` is how much of that time window has been completed.\\n        // A beneficiary can only release a fraction of his token proportional to how much of this time window\\n        // has been completed (or the totality of them if it is completed).\\n        uint256 timeCompleted  = 0;\\n        uint256 unlockedTokens = 0;\\n\\n        if (block.timestamp >= startTime){\\n            timeCompleted = block.timestamp - startTime;\\n\\n            // Time completed is the maximum between the time it has passed since start, and \\n            // the immediateAccessTimeWindow, capped to a max of tokenReleaseDuration.\\n            if (timeCompleted < releaseSchedule.immediateAccessTimeWindow){\\n                timeCompleted = releaseSchedule.immediateAccessTimeWindow;\\n            }\\n        \\n            if (timeCompleted >= releaseSchedule.tokenReleaseDuration){\\n                timeCompleted = releaseSchedule.tokenReleaseDuration;\\n            }\\n\\n            // `tokenReleaseDuration == 0` means everything is available right after the release lock time\\n            if (releaseSchedule.tokenReleaseDuration == 0){\\n                unlockedTokens = beneficiary.tokenBookedAmount;\\n            } else {\\n                unlockedTokens = (timeCompleted * beneficiary.tokenBookedAmount) / releaseSchedule.tokenReleaseDuration;\\n            }\\n        }\\n\\n        uint256 toRelease      =  unlockedTokens - beneficiary.tokensAlreadyReleased;\\n        \\n        beneficiaries[msg.sender].tokensAlreadyReleased += toRelease;\\n        \\n        tokenContract.transfer( msg.sender, toRelease );\\n        \\n    }\\n    \\n    //////////////////////////////////////////////////////////////////////////////////////////\\n    address public adminA; // active admin\\n    address public adminB; // backup admin\\n    address public adminT; // temporary admin, only used during key rotation for one of the other admins.\\n    \\n    modifier adminOnly(){\\n        require( (msg.sender == adminA) || (msg.sender == adminB) || (msg.sender == adminT) \\n               , 'Only admins allowed'\\n               )\\n        ;\\n        _;\\n    }\\n\\n    event NewAdminA(address adminA );\\n    \\n    function changeAdminA(address newAdminA) external adminOnly{\\n        if (adminA != newAdminA){\\n           emit NewAdminA(newAdminA);\\n           adminA = newAdminA;\\n        }\\n        // Notice we don't fail when there's not a NewAdminX defined,\\n        // this is on purpose, so the function becomes idempotent and\\n        // it is easier to programatically interact with while\\n        // deployed on testnet.  \\n    }\\n\\n    event NewAdminB(address adminB );\\n    \\n    function changeAdminB(address newAdminB) external adminOnly{\\n        if (adminB != newAdminB){\\n           emit NewAdminB(newAdminB);\\n           adminB = newAdminB;\\n        }\\n    }\\n\\n    event NewAdminT(address adminT );\\n    \\n    function changeAdminT(address newAdminT) external adminOnly{\\n        if (adminT != newAdminT){\\n           emit NewAdminT(newAdminT);\\n           adminT = newAdminT;\\n        }\\n    }\\n\\n    event TokensBook(address beneficiary , uint256 tokenAmount, ReleaseType releaseSchedule); \\n\\n    function bookTokensFor( address beneficiary , uint256 tokenAmount, ReleaseType releaseSchedule) external adminOnly{\\n        require( avaliableTokensToRelease >= tokenAmount \\n               , 'Not enough token to book'\\n               )\\n        ;\\n        require( beneficiaries[beneficiary].tokenBookedAmount == 0\\n               , 'Beneficiaries can only be set once'\\n               )\\n        ;\\n        require( tokenAmount > 0\\n               , 'More than 0 token needs to be booked to set a beneficiary'\\n               )\\n        ;\\n        avaliableTokensToRelease -= tokenAmount;\\n        \\n        emit TokensBook(beneficiary, tokenAmount, releaseSchedule);\\n        beneficiaries[beneficiary] = Beneficiary(releaseSchedule,0,tokenAmount);\\n\\n    }\\n\\n    event ReleaseTimeStarted();\\n    \\n\\n    function startReleaseTime() external adminOnly{\\n        require( releaseStartTime == 0\\n               , 'Release time has already started'\\n               )\\n        ;\\n        releaseStartTime = block.timestamp;\\n        emit ReleaseTimeStarted();\\n    }\\n\\n    event ImmediateTokensSent(address beneficiary, uint256 amount);\\n\\n    // Release tokens immediately without a release schedule.\\n    function immediateSendTokens(address beneficiary, uint256 amount) external adminOnly{\\n\\n        require( avaliableTokensToRelease >= amount \\n               , 'Not enough token avaliable'\\n               )\\n        ;\\n\\n        avaliableTokensToRelease -= amount;\\n        emit ImmediateTokensSent(beneficiary, amount);\\n        \\n        tokenContract.transfer( beneficiary, amount );\\n    }\\n\\n    //////////////////////////////////////////////////////////////////////////////////////////\\n    \\n\\n}\\n\\n\\n\\n\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adminA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_adminB\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"avaliableTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ImmediateTokensSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adminA\",\"type\":\"address\"}],\"name\":\"NewAdminA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adminB\",\"type\":\"address\"}],\"name\":\"NewAdminB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adminT\",\"type\":\"address\"}],\"name\":\"NewAdminT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ReleaseTimeStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum TokenReleaser.ReleaseType\",\"name\":\"releaseSchedule\",\"type\":\"uint8\"}],\"name\":\"TokensBook\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"adminA\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avaliableTokensToRelease\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"beneficiaries\",\"outputs\":[{\"internalType\":\"enum TokenReleaser.ReleaseType\",\"name\":\"releaseSchedule\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"tokensAlreadyReleased\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBookedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum TokenReleaser.ReleaseType\",\"name\":\"releaseSchedule\",\"type\":\"uint8\"}],\"name\":\"bookTokensFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdminA\",\"type\":\"address\"}],\"name\":\"changeAdminA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdminB\",\"type\":\"address\"}],\"name\":\"changeAdminB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdminT\",\"type\":\"address\"}],\"name\":\"changeAdminT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"immediateSendTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startReleaseTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum TokenReleaser.ReleaseType\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"tokenomic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenLockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenReleaseDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"immediateAccessTimeWindow\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokenReleaser","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"0000000000000000000000003c159347b33cababdb6980081f9408759833129b000000000000000000000000e147f1ae58466a64ca13af6534fc1651ecd0af43000000000000000000000000505b5eda5e25a67e1c24a2bf1a527ed9eb88bf04000000000000000000000000000000000000000018d0bf423c03d8de00000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}