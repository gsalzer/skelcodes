{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity >=0.4.22 <0.9.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n      *\r\n      * Requirements:\r\n      *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n      * - `tokenId` token must exist and be owned by `from`.\r\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n      *\r\n      * Emits a {Transfer} event.\r\n      */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\n\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\nlibrary Counters {\r\n    using SafeMath for uint256;\r\n\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\r\n        counter._value += 1;\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        counter._value = counter._value.sub(1);\r\n    }\r\n}\r\n\r\n\r\nlibrary Math {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Library Functions ============\r\n\r\n    /*\r\n     * Return target * (numerator / denominator).\r\n     */\r\n    function getPartial(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256) {\r\n        return target.mul(numerator).div(denominator);\r\n    }\r\n\r\n    /*\r\n     * Return target * (numerator / denominator), but rounded up.\r\n     */\r\n    function getPartialRoundUp(\r\n        uint256 target,\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256) {\r\n        if (target == 0 || numerator == 0) {\r\n            // SafeMath will check for zero denominator\r\n            return SafeMath.div(0, denominator);\r\n        }\r\n        return target.mul(numerator).sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    function to128(uint256 number) internal pure returns (uint128) {\r\n        uint128 result = uint128(number);\r\n        require(result == number, \"Math: Unsafe cast to uint128\");\r\n        return result;\r\n    }\r\n\r\n    function to96(uint256 number) internal pure returns (uint96) {\r\n        uint96 result = uint96(number);\r\n        require(result == number, \"Math: Unsafe cast to uint96\");\r\n        return result;\r\n    }\r\n\r\n    function to32(uint256 number) internal pure returns (uint32) {\r\n        uint32 result = uint32(number);\r\n        require(result == number, \"Math: Unsafe cast to uint32\");\r\n        return result;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n\r\nlibrary Decimal {\r\n    using SafeMath for uint256;\r\n\r\n    // ============ Constants ============\r\n\r\n    uint256 constant BASE_POW = 18;\r\n    uint256 constant BASE = 10**BASE_POW;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct D256 {\r\n        uint256 value;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    function one() internal pure returns (D256 memory) {\r\n        return D256({value: BASE});\r\n    }\r\n\r\n    function onePlus(D256 memory d) internal pure returns (D256 memory) {\r\n        return D256({value: d.value.add(BASE)});\r\n    }\r\n\r\n    function mul(uint256 target, D256 memory d)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return Math.getPartial(target, d.value, BASE);\r\n    }\r\n\r\n    function div(uint256 target, D256 memory d)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return Math.getPartial(target, BASE, d.value);\r\n    }\r\n}\r\n\r\n\r\ninterface IMarket {\r\n    struct Bid {\r\n        // Amount of the currency being bid\r\n        uint256 amount;\r\n        // Address to the ERC20 token being used to bid\r\n        address currency;\r\n        // Address of the bidder\r\n        address bidder;\r\n        // Address of the recipient\r\n        address recipient;\r\n        // % of the next sale to award the current owner\r\n        Decimal.D256 sellOnShare;\r\n    }\r\n\r\n    struct Ask {\r\n        // Amount of the currency being asked\r\n        uint256 amount;\r\n        // Address to the ERC20 token being asked\r\n        address currency;\r\n    }\r\n\r\n    struct BidShares {\r\n        // % of sale value that goes to the _previous_ owner of the nft\r\n        Decimal.D256 prevOwner;\r\n        // % of sale value that goes to the original creator of the nft\r\n        Decimal.D256 creator;\r\n        // % of sale value that goes to the seller (current owner) of the nft\r\n        Decimal.D256 owner;\r\n    }\r\n\r\n    event BidCreated(uint256 indexed tokenId, Bid bid);\r\n    event BidRemoved(uint256 indexed tokenId, Bid bid);\r\n    event BidFinalized(uint256 indexed tokenId, Bid bid);\r\n    event AskCreated(uint256 indexed tokenId, Ask ask);\r\n    event AskRemoved(uint256 indexed tokenId, Ask ask);\r\n    event BidShareUpdated(uint256 indexed tokenId, BidShares bidShares);\r\n\r\n    function bidForTokenBidder(uint256 tokenId, address bidder)\r\n        external\r\n        view\r\n        returns (Bid memory);\r\n\r\n    function currentAskForToken(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (Ask memory);\r\n\r\n    function bidSharesForToken(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (BidShares memory);\r\n\r\n    function isValidBid(uint256 tokenId, uint256 bidAmount)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function isValidBidShares(BidShares calldata bidShares)\r\n        external\r\n        pure\r\n        returns (bool);\r\n\r\n    function splitShare(Decimal.D256 calldata sharePercentage, uint256 amount)\r\n        external\r\n        pure\r\n        returns (uint256);\r\n\r\n    function configure(address mediaContractAddress) external;\r\n\r\n    function setBidShares(uint256 tokenId, BidShares calldata bidShares)\r\n        external;\r\n\r\n    function setAsk(uint256 tokenId, Ask calldata ask) external;\r\n\r\n    function removeAsk(uint256 tokenId) external;\r\n\r\n    function setBid(\r\n        uint256 tokenId,\r\n        Bid calldata bid,\r\n        address spender\r\n    ) external;\r\n\r\n    function removeBid(uint256 tokenId, address bidder) external;\r\n\r\n    function acceptBid(uint256 tokenId, Bid calldata expectedBid) external;\r\n}\r\n\r\ninterface IMedia {\r\n    struct EIP712Signature {\r\n        uint256 deadline;\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    struct MediaData {\r\n        // A valid URI of the content represented by this token\r\n        string tokenURI;\r\n        // A valid URI of the metadata associated with this token\r\n        string metadataURI;\r\n        // A SHA256 hash of the content pointed to by tokenURI\r\n        bytes32 contentHash;\r\n        // A SHA256 hash of the content pointed to by metadataURI\r\n        bytes32 metadataHash;\r\n    }\r\n\r\n    event TokenURIUpdated(uint256 indexed _tokenId, address owner, string _uri);\r\n    event TokenMetadataURIUpdated(\r\n        uint256 indexed _tokenId,\r\n        address owner,\r\n        string _uri\r\n    );\r\n\r\n    /**\r\n     * @notice Return the metadata URI for a piece of media given the token URI\r\n     */\r\n    function tokenMetadataURI(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (string memory);\r\n\r\n    /**\r\n     * @notice Mint new media for msg.sender.\r\n     */\r\n    function mint(MediaData calldata data, IMarket.BidShares calldata bidShares)\r\n        external;\r\n\r\n    /**\r\n     * @notice EIP-712 mintWithSig method. Mints new media for a creator given a valid signature.\r\n     */\r\n    function mintWithSig(\r\n        address creator,\r\n        MediaData calldata data,\r\n        IMarket.BidShares calldata bidShares,\r\n        EIP712Signature calldata sig\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Transfer the token with the given ID to a given address.\r\n     * Save the previous owner before the transfer, in case there is a sell-on fee.\r\n     * @dev This can only be called by the auction contract specified at deployment\r\n     */\r\n    function auctionTransfer(uint256 tokenId, address recipient) external;\r\n\r\n    /**\r\n     * @notice Set the ask on a piece of media\r\n     */\r\n    function setAsk(uint256 tokenId, IMarket.Ask calldata ask) external;\r\n\r\n    /**\r\n     * @notice Remove the ask on a piece of media\r\n     */\r\n    function removeAsk(uint256 tokenId) external;\r\n\r\n    /**\r\n     * @notice Set the bid on a piece of media\r\n     */\r\n    function setBid(uint256 tokenId, IMarket.Bid calldata bid) external;\r\n\r\n    /**\r\n     * @notice Remove the bid on a piece of media\r\n     */\r\n    function removeBid(uint256 tokenId) external;\r\n\r\n    function getTreasurerAddress() external view returns(address);\r\n\r\n    function owner() external view returns(address);\r\n\r\n    function authorize(address _address) external view returns(bool);\r\n\r\n    function acceptBid(uint256 tokenId, IMarket.Bid calldata bid) external;\r\n\r\n    /**\r\n     * @notice Revoke approval for a piece of media\r\n     */\r\n    function revokeApproval(uint256 tokenId) external;\r\n\r\n    /**\r\n     * @notice Update the token URI\r\n     */\r\n    function updateTokenURI(uint256 tokenId, string calldata tokenURI) external;\r\n\r\n    /**\r\n     * @notice Update the token metadata uri\r\n     */\r\n    function updateTokenMetadataURI(\r\n        uint256 tokenId,\r\n        string calldata metadataURI\r\n    ) external;\r\n\r\n    /**\r\n     * @notice EIP-712 permit method. Sets an approved spender given a valid signature.\r\n     */\r\n    function permit(\r\n        address spender,\r\n        uint256 tokenId,\r\n        EIP712Signature calldata sig\r\n    ) external;\r\n}\r\n\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n}\r\n\r\ninterface IMediaExtended is IMedia {\r\n    function marketContract() external returns(address);\r\n}\r\n\r\ninterface IAuctionHouse {\r\n    struct Auction {\r\n        // ID for the ERC721 token\r\n        uint256 tokenId;\r\n        // Address for the ERC721 contract\r\n        address tokenContract;\r\n        // Whether or not the auction curator has approved the auction to start\r\n        bool approved;\r\n        // The current highest bid amount\r\n        uint256 amount;\r\n        // The length of time to run the auction for, after the first bid was made\r\n        uint256 duration;\r\n        // The time of the first bid\r\n        uint256 firstBidTime;\r\n        // The minimum price of the first bid\r\n        uint256 reservePrice;\r\n        // The sale percentage to send to the curator\r\n        uint8 curatorFeePercentage;\r\n        // The address that should receive the funds once the NFT is sold.\r\n        address tokenOwner;\r\n        // The address of the current highest bid\r\n        address payable bidder;\r\n        // The address of the auction's curator.\r\n        // The curator can reject or approve an auction\r\n        address payable curator;\r\n        // The address of the ERC-20 currency to run the auction with.\r\n        // If set to 0x0, the auction will be run in ETH\r\n        address auctionCurrency;\r\n\r\n        uint256 startTime;\r\n    }\r\n\r\n    event AuctionCreated(\r\n        uint256 indexed auctionId,\r\n        uint256 indexed tokenId,\r\n        address indexed tokenContract,\r\n        uint256 duration,\r\n        uint256 reservePrice,\r\n        address tokenOwner,\r\n        address curator,\r\n        uint8 curatorFeePercentage,\r\n        address auctionCurrency,\r\n        uint256 startTime\r\n    );\r\n\r\n    event AuctionApprovalUpdated(\r\n        uint256 indexed auctionId,\r\n        uint256 indexed tokenId,\r\n        address indexed tokenContract,\r\n        bool approved\r\n        \r\n    );\r\n\r\n    event AuctionReservePriceUpdated(\r\n        uint256 indexed auctionId,\r\n        uint256 indexed tokenId,\r\n        address indexed tokenContract,\r\n        uint256 reservePrice\r\n    );\r\n\r\n    event RescheduleAuctionTime(\r\n        uint256 indexed auctionId,\r\n        uint256 indexed tokenId,\r\n        address indexed tokenContract,\r\n        uint256 newStartTime\r\n        \r\n    );\r\n\r\n\r\n\r\n    event AuctionBid(\r\n        uint256 indexed auctionId,\r\n        uint256 indexed tokenId,\r\n        address indexed tokenContract,\r\n        address sender,\r\n        uint256 value,\r\n        bool firstBid,\r\n        bool extended\r\n    );\r\n\r\n    event AuctionDurationExtended(\r\n        uint256 indexed auctionId,\r\n        uint256 indexed tokenId,\r\n        address indexed tokenContract,\r\n        uint256 duration\r\n    );\r\n\r\n    event AuctionEnded(\r\n        uint256 indexed auctionId,\r\n        uint256 indexed tokenId,\r\n        address indexed tokenContract,\r\n        address tokenOwner,\r\n        address curator,\r\n        address winner,\r\n        uint256 amount,\r\n        uint256 curatorFee,\r\n        address auctionCurrency\r\n    );\r\n\r\n    event AuctionCanceled(\r\n        uint256 indexed auctionId,\r\n        uint256 indexed tokenId,\r\n        address indexed tokenContract,\r\n        address tokenOwner\r\n    );\r\n\r\n    function createAuction(\r\n        uint256 tokenId,\r\n        address tokenContract,\r\n        uint256 duration,\r\n        uint256 reservePrice,\r\n        address payable curator,\r\n        uint8 curatorFeePercentages,\r\n        address auctionCurrency,\r\n        uint256 startTime\r\n    ) external returns (uint256);\r\n\r\n    function setAuctionApproval(uint256 auctionId, bool approved) external;\r\n\r\n    function setAuctionReservePrice(uint256 auctionId, uint256 reservePrice) external;\r\n\r\n    function rescheduleAuctionTime(uint256 auctionId, uint256 newStartTime) external;\r\n\r\n    function createBid(uint256 auctionId, uint256 amount) external payable;\r\n\r\n    function endAuction(uint256 auctionId) external;\r\n\r\n    function cancelAuction(uint256 auctionId) external;\r\n}\r\n\r\n\r\ncontract AuctionHouse is IAuctionHouse, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using Counters for Counters.Counter;\r\n\r\n    // The minimum amount of time left in an auction after a new bid is created\r\n    uint256 public timeBuffer;\r\n\r\n    // The minimum wei difference between the last bid amount and the current bid.\r\n    uint256 public minBidIncrementWei;\r\n\r\n    // The address of the media protocol to use via this contract\r\n    address public media;\r\n\r\n    // / The address of the WETH contract, so that any ETH transferred can be handled as an ERC-20\r\n    address public wethAddress;\r\n\r\n    // A mapping of all of the auctions currently running.\r\n    mapping(uint256 => IAuctionHouse.Auction) public auctions;\r\n\r\n    bytes4 constant interfaceId = 0x80ac58cd; // 721 interface id\r\n\r\n    Counters.Counter private _auctionIdTracker;\r\n\r\n    /**\r\n     * @notice Require that the specified auction exists\r\n     */\r\n    modifier auctionExists(uint256 auctionId) {\r\n        require(_exists(auctionId), \"Auction doesn't exist\");\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * Constructor\r\n     */\r\n    constructor(address _media, address _weth) public {\r\n        require(\r\n            IERC165(_media).supportsInterface(interfaceId),\r\n            \"Doesn't support NFT interface\"\r\n        );\r\n        media = _media;\r\n        wethAddress = _weth;\r\n        timeBuffer = 600; // extend 10 minutes after every bid made in last 10 minutes\r\n        minBidIncrementWei = 10000000000000000; // 0.01 eth\r\n    }\r\n\r\n    function setBufferTime(uint256 _timebuffer) public {\r\n        require (msg.sender == IMedia(media).owner(),\"You are not a Superadmin\" );\r\n        require (_timebuffer > 0,\"must be greater than Zero\");\r\n        timeBuffer = _timebuffer;\r\n    }\r\n\r\n    /**\r\n     * @notice Create an auction.\r\n     * @dev Store the auction details in the auctions mapping and emit an AuctionCreated event.\r\n     * If there is no curator, or if the curator is the auction creator, automatically approve the auction.\r\n     */\r\n    function createAuction(\r\n        uint256 tokenId,\r\n        address tokenContract,\r\n        uint256 duration,\r\n        uint256 reservePrice,\r\n        address payable curator,\r\n        uint8 curatorFeePercentage,\r\n        address auctionCurrency,\r\n        uint256 _startTime\r\n    ) public override nonReentrant returns (uint256) {\r\n        require(\r\n            IERC165(tokenContract).supportsInterface(interfaceId),\r\n            \"tokenContract does not support ERC721 interface\"\r\n        );\r\n        require(curatorFeePercentage < 100, \"curatorFeePercentage must be less than 100\");\r\n        require(tokenContract == media, \"only Atro token place\");\r\n        require(reservePrice >= minBidIncrementWei,\"first bid must be greater than 0.01 eth\");\r\n\r\n        require (_startTime == 0 || _startTime >= block.timestamp,\"Start time must be greater than equal to current time  \");\r\n\r\n        if(_startTime == 0){\r\n            _startTime = block.timestamp;\r\n        }\r\n\r\n        \r\n        address tokenOwner = IERC721(tokenContract).ownerOf(tokenId);\r\n        require(msg.sender == IERC721(tokenContract).getApproved(tokenId) || msg.sender == tokenOwner, \"Caller must be approved or owner for token id\");\r\n        uint256 auctionId = _auctionIdTracker.current();\r\n\r\n        auctions[auctionId] = Auction({\r\n            tokenId: tokenId,\r\n            tokenContract: tokenContract,\r\n            approved: false,\r\n            amount: 0,\r\n            duration: duration,\r\n            firstBidTime: 0,\r\n            reservePrice: reservePrice,\r\n            curatorFeePercentage: curatorFeePercentage,\r\n            tokenOwner: tokenOwner,\r\n            bidder: address(0),\r\n            curator: curator,\r\n            auctionCurrency: auctionCurrency,\r\n            startTime: _startTime\r\n        });\r\n\r\n        IERC721(tokenContract).transferFrom(tokenOwner, address(this), tokenId);\r\n\r\n        _auctionIdTracker.increment();\r\n\r\n        emit AuctionCreated(auctionId, tokenId, tokenContract, duration, reservePrice, tokenOwner, curator, curatorFeePercentage, auctionCurrency,_startTime);\r\n\r\n\r\n        if(auctions[auctionId].curator == address(0) || curator == tokenOwner) {\r\n            _approveAuction(auctionId,true);\r\n        }\r\n\r\n        return auctionId;\r\n    }\r\n\r\n    /**\r\n     * @notice Approve an auction, opening up the auction for bids.\r\n     * @dev Only callable by the curator. Cannot be called if the auction has already started.\r\n     */\r\n    function setAuctionApproval(uint256 auctionId, bool approved) external override auctionExists(auctionId) {\r\n        require(msg.sender == auctions[auctionId].curator, \"Must be auction curator\");\r\n        require(auctions[auctionId].firstBidTime == 0, \"Auction has already started\");\r\n        _approveAuction(auctionId, approved);\r\n    }\r\n\r\n    function setAuctionReservePrice(uint256 auctionId, uint256 reservePrice) external override auctionExists(auctionId) {\r\n        require(msg.sender == auctions[auctionId].curator || msg.sender == auctions[auctionId].tokenOwner, \"Must be auction curator or token owner\");\r\n        require(auctions[auctionId].firstBidTime == 0, \"Auction has already started\");\r\n\r\n        auctions[auctionId].reservePrice = reservePrice;\r\n\r\n        emit AuctionReservePriceUpdated(auctionId, auctions[auctionId].tokenId, auctions[auctionId].tokenContract, reservePrice);\r\n    }\r\n\r\n    function rescheduleAuctionTime(uint256 auctionId, uint256 newStartTime) external override auctionExists(auctionId) {\r\n        require(msg.sender == auctions[auctionId].curator || msg.sender == auctions[auctionId].tokenOwner, \"Must be auction curator or token owner\");\r\n        require(auctions[auctionId].firstBidTime == 0, \"Auction has already started\");\r\n        require(auctions[auctionId].startTime > block.timestamp,\"Enable to Reschedule Auction Time\" );\r\n        require (newStartTime >= block.timestamp,\"Start time must be greater than equal to current time \");\r\n        auctions[auctionId].startTime = newStartTime;\r\n\r\n        emit RescheduleAuctionTime(auctionId, auctions[auctionId].tokenId, auctions[auctionId].tokenContract, newStartTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Create a bid on a token, with a given amount.\r\n     * @dev If provided a valid bid, transfers the provided amount to this contract.\r\n     * If the auction is run in native ETH, the ETH is wrapped so it can be identically to other\r\n     * auction currencies in this contract.\r\n     */\r\n    function createBid(uint256 auctionId, uint256 amount)\r\n    external\r\n    override\r\n    payable\r\n    auctionExists(auctionId)\r\n    nonReentrant\r\n    {\r\n        address payable lastBidder = auctions[auctionId].bidder;\r\n        require(auctions[auctionId].approved, \"Auction must be approved by curator\");\r\n\r\n        require (auctions[auctionId].startTime <= block.timestamp,\"Auction is not begun\");\r\n        \r\n        require(\r\n            block.timestamp <\r\n            auctions[auctionId].startTime.add(auctions[auctionId].duration),\r\n            \"Auction expired\"\r\n        );\r\n        require(\r\n            amount >= auctions[auctionId].reservePrice,\r\n                \"Must send at least reservePrice\"\r\n        );\r\n        require(\r\n            amount >= auctions[auctionId].amount.add(minBidIncrementWei),\r\n            \"Must send more than last bid by minBidIncrementWei amount\"\r\n        );\r\n\r\n        // For Zora Protocol, ensure that the bid is valid for the current bidShare configuration\r\n        if(auctions[auctionId].tokenContract == media) {\r\n            require(\r\n                IMarket(IMediaExtended(media).marketContract()).isValidBid(\r\n                    auctions[auctionId].tokenId,\r\n                    amount\r\n                ),\r\n                \"Bid invalid for share splitting\"\r\n            );\r\n        }\r\n\r\n        // If this is the first valid bid, we should set the starting time now.\r\n        // If it's not, then we should refund the last bidder\r\n        if(auctions[auctionId].firstBidTime == 0) {\r\n            auctions[auctionId].firstBidTime = block.timestamp;\r\n        } else if(lastBidder != address(0)) {\r\n            _handleOutgoingBid(lastBidder, auctions[auctionId].amount, auctions[auctionId].auctionCurrency);\r\n        }\r\n\r\n        _handleIncomingBid(amount, auctions[auctionId].auctionCurrency);\r\n\r\n        auctions[auctionId].amount = amount;\r\n        auctions[auctionId].bidder = msg.sender;\r\n\r\n\r\n        bool extended = false;\r\n        // at this point we know that the timestamp is less than start + duration (since the auction would be over, otherwise)\r\n        // we want to know by how much the timestamp is less than start + duration\r\n        // if the difference is less than the timeBuffer, increase the duration by the timeBuffer\r\n        if (\r\n            auctions[auctionId].startTime.add(auctions[auctionId].duration).sub(\r\n                block.timestamp\r\n            ) < timeBuffer\r\n        ) {\r\n            // Playing code golf for gas optimization:\r\n            // uint256 expectedEnd = auctions[auctionId].startTime.add(auctions[auctionId].duration);\r\n            // uint256 timeRemaining = expectedEnd.sub(block.timestamp);\r\n            // uint256 timeToAdd = timeBuffer.sub(timeRemaining);\r\n            // uint256 newDuration = auctions[auctionId].duration.add(timeToAdd);\r\n            uint256 oldDuration = auctions[auctionId].duration;\r\n            auctions[auctionId].duration =\r\n                oldDuration.add(timeBuffer.sub(auctions[auctionId].startTime.add(oldDuration).sub(block.timestamp)));\r\n            extended = true;\r\n        }\r\n\r\n        emit AuctionBid(\r\n            auctionId,\r\n            auctions[auctionId].tokenId,\r\n            auctions[auctionId].tokenContract,\r\n            msg.sender,\r\n            amount,\r\n            lastBidder == address(0), // firstBid boolean\r\n            extended\r\n        );\r\n\r\n        if (extended) {\r\n            emit AuctionDurationExtended(\r\n                auctionId,\r\n                auctions[auctionId].tokenId,\r\n                auctions[auctionId].tokenContract,\r\n                auctions[auctionId].duration\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice End an auction, finalizing the bid on Zora if applicable and paying out the respective parties.\r\n     * @dev If for some reason the auction cannot be finalized (invalid token recipient, for example),\r\n     * The auction is reset and the NFT is transferred back to the auction creator.\r\n     */\r\n    function endAuction(uint256 auctionId) external override auctionExists(auctionId) nonReentrant {\r\n        require(\r\n            uint256(auctions[auctionId].firstBidTime) != 0,\r\n            \"Auction hasn't begun\"\r\n        );\r\n        require(\r\n            block.timestamp >=\r\n            auctions[auctionId].startTime.add(auctions[auctionId].duration),\r\n            \"Auction hasn't completed\"\r\n        );\r\n\r\n        address currency = auctions[auctionId].auctionCurrency == address(0) ? wethAddress : auctions[auctionId].auctionCurrency;\r\n        uint256 curatorFee = 0;\r\n\r\n        uint256 tokenOwnerProfit = auctions[auctionId].amount;\r\n\r\n        if(auctions[auctionId].tokenContract == media) {\r\n            // If the auction is running on media, settle it on the protocol\r\n            (bool success, uint256 remainingProfit) = _handleZoraAuctionSettlement(auctionId);\r\n            tokenOwnerProfit = remainingProfit;\r\n            if(success != true) {\r\n                _handleOutgoingBid(auctions[auctionId].bidder, auctions[auctionId].amount, auctions[auctionId].auctionCurrency);\r\n                _cancelAuction(auctionId);\r\n                return;\r\n            }\r\n        } else {\r\n            // Otherwise, transfer the token to the winner and pay out the participants below\r\n            try IERC721(auctions[auctionId].tokenContract).safeTransferFrom(address(this), auctions[auctionId].bidder, auctions[auctionId].tokenId) {} catch {\r\n                _handleOutgoingBid(auctions[auctionId].bidder, auctions[auctionId].amount, auctions[auctionId].auctionCurrency);\r\n                _cancelAuction(auctionId);\r\n                return;\r\n            }\r\n        }\r\n\r\n\r\n        if(auctions[auctionId].curator != address(0)) {\r\n            curatorFee = tokenOwnerProfit.mul(auctions[auctionId].curatorFeePercentage).div(100);\r\n            tokenOwnerProfit = tokenOwnerProfit.sub(curatorFee);\r\n            _handleOutgoingBid(auctions[auctionId].curator, curatorFee, auctions[auctionId].auctionCurrency);\r\n        }\r\n\r\n        if(IMedia(media).owner() == auctions[auctionId].tokenOwner || IMedia(media).authorize(auctions[auctionId].tokenOwner)){\r\n            _handleOutgoingBid(IMedia(media).getTreasurerAddress(), tokenOwnerProfit, auctions[auctionId].auctionCurrency);\r\n        }\r\n        \r\n        else{\r\n\r\n            _handleOutgoingBid(auctions[auctionId].tokenOwner, tokenOwnerProfit, auctions[auctionId].auctionCurrency);\r\n        }\r\n\r\n        emit AuctionEnded(\r\n            auctionId,\r\n            auctions[auctionId].tokenId,\r\n            auctions[auctionId].tokenContract,\r\n            auctions[auctionId].tokenOwner,\r\n            auctions[auctionId].curator,\r\n            auctions[auctionId].bidder,\r\n            tokenOwnerProfit,\r\n            curatorFee,\r\n            currency\r\n        );\r\n        delete auctions[auctionId];\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel an auction.\r\n     * @dev Transfers the NFT back to the auction creator and emits an AuctionCanceled event\r\n     */\r\n    function cancelAuction(uint256 auctionId) external override nonReentrant auctionExists(auctionId) {\r\n        require(\r\n            auctions[auctionId].tokenOwner == msg.sender || auctions[auctionId].curator == msg.sender,\r\n            \"Can only be called by auction creator or curator\"\r\n        );\r\n        require(\r\n            uint256(auctions[auctionId].firstBidTime) == 0,\r\n            \"Can't cancel an auction once it's begun\"\r\n        );\r\n        _cancelAuction(auctionId);\r\n    }\r\n\r\n    /**\r\n     * @dev Given an amount and a currency, transfer the currency to this contract.\r\n     * If the currency is ETH (0x0), attempt to wrap the amount as WETH\r\n     */\r\n    function _handleIncomingBid(uint256 amount, address currency) internal {\r\n        // If this is an ETH bid, ensure they sent enough and convert it to WETH under the hood\r\n        if(currency == address(0)) {\r\n            require(msg.value == amount, \"Sent ETH Value does not match specified bid amount\");\r\n            IWETH(wethAddress).deposit{value: amount}();\r\n        } else {\r\n            // We must check the balance that was actually transferred to the auction,\r\n            // as some tokens impose a transfer fee and would not actually transfer the\r\n            // full amount to the market, resulting in potentally locked funds\r\n            IERC20 token = IERC20(currency);\r\n            uint256 beforeBalance = token.balanceOf(address(this));\r\n            token.safeTransferFrom(msg.sender, address(this), amount);\r\n            uint256 afterBalance = token.balanceOf(address(this));\r\n            require(beforeBalance.add(amount) == afterBalance, \"Token transfer call did not transfer expected amount\");\r\n        }\r\n    }\r\n\r\n    function _handleOutgoingBid(address to, uint256 amount, address currency) internal {\r\n        // If the auction is in ETH, unwrap it from its underlying WETH and try to send it to the recipient.\r\n        if(currency == address(0)) {\r\n            IWETH(wethAddress).withdraw(amount);\r\n\r\n            // If the ETH transfer fails (sigh), rewrap the ETH and try send it as WETH.\r\n            if(!_safeTransferETH(to, amount)) {\r\n                IWETH(wethAddress).deposit{value: amount}();\r\n                IERC20(wethAddress).safeTransfer(to, amount);\r\n            }\r\n        } else {\r\n            IERC20(currency).safeTransfer(to, amount);\r\n        }\r\n    }\r\n\r\n    function _safeTransferETH(address to, uint256 value) internal returns (bool) {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        return success;\r\n    }\r\n\r\n    function _cancelAuction(uint256 auctionId) internal {\r\n        address tokenOwner = auctions[auctionId].tokenOwner;\r\n        IERC721(auctions[auctionId].tokenContract).safeTransferFrom(address(this), tokenOwner, auctions[auctionId].tokenId);\r\n\r\n        emit AuctionCanceled(auctionId, auctions[auctionId].tokenId, auctions[auctionId].tokenContract, tokenOwner);\r\n        delete auctions[auctionId];\r\n    }\r\n\r\n    function _approveAuction(uint256 auctionId, bool approved) internal {\r\n        auctions[auctionId].approved = approved;\r\n        emit AuctionApprovalUpdated(auctionId, auctions[auctionId].tokenId, auctions[auctionId].tokenContract, approved);\r\n    }\r\n\r\n    function _exists(uint256 auctionId) internal view returns(bool) {\r\n        return auctions[auctionId].tokenOwner != address(0);\r\n    }\r\n\r\n    function _handleZoraAuctionSettlement(uint256 auctionId) internal returns (bool, uint256) {\r\n        address currency = auctions[auctionId].auctionCurrency == address(0) ? wethAddress : auctions[auctionId].auctionCurrency;\r\n\r\n        IMarket.Bid memory bid = IMarket.Bid({\r\n            amount: auctions[auctionId].amount,\r\n            currency: currency,\r\n            bidder: address(this),\r\n            recipient: auctions[auctionId].bidder,\r\n            sellOnShare: Decimal.D256(0)\r\n        });\r\n\r\n        IERC20(currency).approve(IMediaExtended(media).marketContract(), bid.amount);\r\n        IMedia(media).setBid(auctions[auctionId].tokenId, bid);\r\n        uint256 beforeBalance = IERC20(currency).balanceOf(address(this));\r\n        try IMedia(media).acceptBid(auctions[auctionId].tokenId, bid) {} catch {\r\n            // If the underlying NFT transfer here fails, we should cancel the auction and refund the winner\r\n            IMediaExtended(media).removeBid(auctions[auctionId].tokenId);\r\n            return (false, 0);\r\n        }\r\n\r\n\r\n        uint256 afterBalance = IERC20(currency).balanceOf(address(this));\r\n\r\n        // We have to calculate the amount to send to the token owner here in case there was a\r\n        // sell-on share on the token\r\n        return (true, afterBalance.sub(beforeBalance));\r\n    }\r\n\r\n    // TODO: consider reverting if the message sender is not WETH\r\n    receive() external payable {}\r\n    fallback() external payable {}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_media\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"AuctionApprovalUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"firstBid\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"extended\",\"type\":\"bool\"}],\"name\":\"AuctionBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"AuctionCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"curatorFeePercentage\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"auctionCurrency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"AuctionDurationExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"curator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"curatorFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"auctionCurrency\",\"type\":\"address\"}],\"name\":\"AuctionEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"}],\"name\":\"AuctionReservePriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newStartTime\",\"type\":\"uint256\"}],\"name\":\"RescheduleAuctionTime\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstBidTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"curatorFeePercentage\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"curator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"auctionCurrency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"curator\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"curatorFeePercentage\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"auctionCurrency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"createAuction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"createBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"endAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"media\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBidIncrementWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newStartTime\",\"type\":\"uint256\"}],\"name\":\"rescheduleAuctionTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setAuctionApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reservePrice\",\"type\":\"uint256\"}],\"name\":\"setAuctionReservePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timebuffer\",\"type\":\"uint256\"}],\"name\":\"setBufferTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeBuffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"AuctionHouse","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f2e9db3b8d2af2752865af51a71bcd548bd27834000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://921cf9b85d153789660eae2a51c127a82cc503d25ce1c93708ae688bcfd49c34"}]}