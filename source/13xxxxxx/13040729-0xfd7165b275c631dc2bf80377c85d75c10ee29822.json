{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/treasury/MirrorTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {IDistributionLogic} from \\\"../distribution/interface/IDistributionLogic.sol\\\";\\nimport {ITributaryRegistry} from \\\"../interface/ITributaryRegistry.sol\\\";\\nimport {ITreasuryConfig} from \\\"../interface/ITreasuryConfig.sol\\\";\\nimport {IMirrorTreasury} from \\\"../interface/IMirrorTreasury.sol\\\";\\nimport {Governable} from \\\"../lib/Governable.sol\\\";\\n\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n}\\n\\ncontract MirrorTreasury is IMirrorTreasury, Governable {\\n    // ============ Treasury Configuration ============\\n\\n    // Used to pull the active distribution model.\\n    address public treasuryConfig;\\n\\n    // ============ Tributary Registry ============\\n\\n    // Used to find tributary addresses associated with Economic Producers.\\n    address public tributaryRegistry;\\n\\n    // ============ Structs ============\\n\\n    // Allows governance to execute generic functions.\\n    struct Call {\\n        // The target of the transaction.\\n        address target;\\n        // The value passed into the transaction.\\n        uint96 value;\\n        // Any data passed with the call.\\n        bytes data;\\n    }\\n\\n    // ============ Events ============\\n\\n    // Emitted when the treasury transfers ETH.\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    // Emitted when the treasury transfers an ERC20 token.\\n    event ERC20Transfer(\\n        address indexed token,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount\\n    );\\n\\n    // ============ Constructor ============\\n\\n    // NOTE: Once deployed, tributaryRegistry and treasuryConfig should be set.\\n    constructor(address owner_) Governable(owner_) {}\\n\\n    // ============ Treasury Contributions ============\\n\\n    /**\\n     * A safe, public function for making contributions to the treasury.\\n     * If a tributary is registered for the contributor, then governance\\n     * tokens will be allocated according to the active distribution model.\\n     */\\n    function contribute(uint256 amount) public payable override {\\n        require(msg.value == amount, \\\"msg.value != amount\\\");\\n        _allocateGovernance(msg.sender, amount);\\n    }\\n\\n    // Allows directly contributing with a specify treasury, but the sender\\n    // must be registered as a \\\"singleton producer\\\" - e.g. auctions house.\\n    function contributeWithTributary(address tributary)\\n        public\\n        payable\\n        override\\n    {\\n        // Here we don't revert, but instead just don't allocate goverance\\n        // if the call isn't registered as an economic producer.\\n        if (\\n            ITributaryRegistry(tributaryRegistry).singletonProducer(msg.sender)\\n        ) {\\n            _allocateGovernanceToTributary(tributary, msg.value);\\n        }\\n    }\\n\\n    /**\\n     * Allows receiving ETH, and can mint treasury governance tokens in\\n     * exchange. Uses a registry to specify which addresses are allowed\\n     * to receive gov tokens in exchange for contributing ETH.\\n     */\\n    receive() external payable {\\n        _allocateGovernance(msg.sender, msg.value);\\n    }\\n\\n    // ============ Treasury Configuration ============\\n\\n    function setTreasuryConfig(address treasuryConfig_) public onlyGovernance {\\n        treasuryConfig = treasuryConfig_;\\n    }\\n\\n    // ============ Tributary Registry Configuration ============\\n\\n    function setTributaryRegistry(address tributaryRegistry_)\\n        public\\n        onlyGovernance\\n    {\\n        tributaryRegistry = tributaryRegistry_;\\n    }\\n\\n    // ============ Funds Administration ============\\n\\n    function transferFunds(address payable to, uint256 value)\\n        external\\n        override\\n        onlyGovernance\\n    {\\n        _sendFunds(to, value);\\n        emit Transfer(address(this), to, value);\\n    }\\n\\n    function transferERC20(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external override onlyGovernance {\\n        IERC20(token).transfer(to, amount);\\n        emit ERC20Transfer(token, address(this), to, amount);\\n    }\\n\\n    // ============ Generic Call Execution ============\\n\\n    function executeGeneric(Call memory call) public onlyGovernance {\\n        (bool ok, ) = call.target.call{value: uint256(call.value)}(call.data);\\n\\n        require(ok, \\\"execute transaction failed\\\");\\n    }\\n\\n    // ============ Private Utils ============\\n\\n    function _sendFunds(address payable recipient, uint256 amount) private {\\n        require(\\n            address(this).balance >= amount,\\n            \\\"Insufficient balance for send\\\"\\n        );\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Unable to send value: recipient may have reverted\\\");\\n    }\\n\\n    function _allocateGovernance(address producer, uint256 amount) private {\\n        // Get the tributary that was registered for the given producer.\\n        address tributary = ITributaryRegistry(tributaryRegistry)\\n            .producerToTributary(producer);\\n\\n        _allocateGovernanceToTributary(tributary, amount);\\n    }\\n\\n    function _allocateGovernanceToTributary(address tributary, uint256 amount)\\n        private\\n    {\\n        // If there is a registered tributary to mint Mirror tokens for,\\n        // then, here, we go and mint those tokens! Else, just accept ETH, no sweat.\\n        if (tributary != address(0)) {\\n            address distributionModel = ITreasuryConfig(treasuryConfig)\\n                .distributionModel();\\n\\n            IDistributionLogic(distributionModel).distribute(tributary, amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/distribution/interface/IDistributionLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IDistributionLogic {\\n    function version() external returns (uint256);\\n\\n    function distribute(address tributary, uint256 contribution) external;\\n\\n    function claim(address claimant) external;\\n\\n    function claimable(address claimant) external view returns (uint256);\\n\\n    function increaseAwards(address member, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ITributaryRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ITributaryRegistry {\\n    function addRegistrar(address registrar) external;\\n\\n    function removeRegistrar(address registrar) external;\\n\\n    function addSingletonProducer(address producer) external;\\n\\n    function removeSingletonProducer(address producer) external;\\n\\n    function registerTributary(address producer, address tributary) external;\\n\\n    function producerToTributary(address producer)\\n        external\\n        returns (address tributary);\\n\\n    function singletonProducer(address producer) external returns (bool);\\n\\n    function changeTributary(address producer, address newTributary) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ITreasuryConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ITreasuryConfig {\\n    function treasury() external returns (address payable);\\n\\n    function distributionModel() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IMirrorTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IMirrorTreasury {\\n    function transferFunds(address payable to, uint256 value) external;\\n\\n    function transferERC20(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) external;\\n\\n    function contributeWithTributary(address tributary) external payable;\\n\\n    function contribute(uint256 amount) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {Ownable} from \\\"../lib/Ownable.sol\\\";\\nimport {IGovernable} from \\\"../lib/interface/IGovernable.sol\\\";\\n\\ncontract Governable is Ownable, IGovernable {\\n    // ============ Mutable Storage ============\\n\\n    // Mirror governance contract.\\n    address public override governor;\\n\\n    // ============ Modifiers ============\\n\\n    modifier onlyGovernance() {\\n        require(isOwner() || isGovernor(), \\\"caller is not governance\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovernor() {\\n        require(isGovernor(), \\\"caller is not governor\\\");\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    constructor(address owner_) Ownable(owner_) {}\\n\\n    // ============ Administration ============\\n\\n    function changeGovernor(address governor_) public override onlyGovernance {\\n        governor = governor_;\\n    }\\n\\n    // ============ Utility Functions ============\\n\\n    function isGovernor() public view override returns (bool) {\\n        return msg.sender == governor;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ncontract Ownable {\\n    address public owner;\\n    address private nextOwner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    // modifiers\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"caller is not the owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyNextOwner() {\\n        require(isNextOwner(), \\\"current owner must set caller as next owner.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize contract by setting transaction submitter as initial owner.\\n     */\\n    constructor(address owner_) {\\n        owner = owner_;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Initiate ownership transfer by setting nextOwner.\\n     */\\n    function transferOwnership(address nextOwner_) external onlyOwner {\\n        require(nextOwner_ != address(0), \\\"Next owner is the zero address.\\\");\\n\\n        nextOwner = nextOwner_;\\n    }\\n\\n    /**\\n     * @dev Cancel ownership transfer by deleting nextOwner.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        delete nextOwner;\\n    }\\n\\n    /**\\n     * @dev Accepts ownership transfer by setting owner.\\n     */\\n    function acceptOwnership() external onlyNextOwner {\\n        delete nextOwner;\\n\\n        owner = msg.sender;\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Renounce ownership by setting owner to zero address.\\n     */\\n    function renounceOwnership() external onlyOwner {\\n        owner = address(0);\\n\\n        emit OwnershipTransferred(owner, address(0));\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the next owner.\\n     */\\n    function isNextOwner() public view returns (bool) {\\n        return msg.sender == nextOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/interface/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IGovernable {\\n    function changeGovernor(address governor_) external;\\n\\n    function isGovernor() external view returns (bool);\\n\\n    function governor() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor_\",\"type\":\"address\"}],\"name\":\"changeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"contribute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tributary\",\"type\":\"address\"}],\"name\":\"contributeWithTributary\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct MirrorTreasury.Call\",\"name\":\"call\",\"type\":\"tuple\"}],\"name\":\"executeGeneric\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasuryConfig_\",\"type\":\"address\"}],\"name\":\"setTreasuryConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tributaryRegistry_\",\"type\":\"address\"}],\"name\":\"setTributaryRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tributaryRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MirrorTreasury","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"0000000000000000000000002330ee705ffd040bb0cba8cb7734dfe00e7c4b57","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}