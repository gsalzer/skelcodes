{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PremiaVoteProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IERC20} from \\\"@solidstate/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\nimport {IFeeDiscount} from \\\"./staking/IFeeDiscount.sol\\\";\\r\\nimport {IPremiaStaking} from \\\"./staking/IPremiaStaking.sol\\\";\\r\\n\\r\\ncontract PremiaVoteProxy {\\r\\n    address internal PREMIA;\\r\\n    address internal xPREMIA;\\r\\n    address internal FEE_DISCOUNT;\\r\\n\\r\\n    constructor(\\r\\n        address _premia,\\r\\n        address _xPremia,\\r\\n        address _feeDiscount\\r\\n    ) {\\r\\n        PREMIA = _premia;\\r\\n        xPREMIA = _xPremia;\\r\\n        FEE_DISCOUNT = _feeDiscount;\\r\\n    }\\r\\n\\r\\n    function decimals() external pure returns (uint8) {\\r\\n        return uint8(18);\\r\\n    }\\r\\n\\r\\n    function name() external pure returns (string memory) {\\r\\n        return \\\"PREMIAVOTE\\\";\\r\\n    }\\r\\n\\r\\n    function symbol() external pure returns (string memory) {\\r\\n        return \\\"PREMIAVOTE\\\";\\r\\n    }\\r\\n\\r\\n    function totalSupply() external view returns (uint256) {\\r\\n        return IERC20(PREMIA).totalSupply();\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _voter) external view returns (uint256) {\\r\\n        uint256 _votes = IERC20(PREMIA).balanceOf(_voter);\\r\\n\\r\\n        uint256 totalXPremia = IERC20(xPREMIA).balanceOf(_voter) +\\r\\n            IFeeDiscount(FEE_DISCOUNT).getUserInfo(_voter).balance;\\r\\n\\r\\n        uint256 xPremiaToPremiaRatio = IPremiaStaking(xPREMIA)\\r\\n            .getXPremiaToPremiaRatio();\\r\\n\\r\\n        _votes += (totalXPremia * xPremiaToPremiaRatio) / 1e18;\\r\\n\\r\\n        return _votes;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20Internal } from './IERC20Internal.sol';\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 is IERC20Internal {\\n    /**\\n     * @notice query the total minted token supply\\n     * @return token supply\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice query the token balance of given account\\n     * @param account address to query\\n     * @return token balance\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @notice query the allowance granted from given holder to given spender\\n     * @param holder approver of allowance\\n     * @param spender recipient of allowance\\n     * @return token allowance\\n     */\\n    function allowance(address holder, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice grant approval to spender to spend tokens\\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\\n     * @param spender recipient of allowance\\n     * @param amount quantity of tokens approved for spending\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @notice transfer tokens to given recipient\\n     * @param recipient beneficiary of token transfer\\n     * @param amount quantity of tokens to transfer\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @notice transfer tokens to given recipient on behalf of given holder\\n     * @param holder holder of tokens prior to transfer\\n     * @param recipient beneficiary of token transfer\\n     * @param amount quantity of tokens to transfer\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function transferFrom(\\n        address holder,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/IFeeDiscount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {FeeDiscountStorage} from \\\"./FeeDiscountStorage.sol\\\";\\r\\n\\r\\ninterface IFeeDiscount {\\r\\n    event Staked(\\r\\n        address indexed user,\\r\\n        uint256 amount,\\r\\n        uint256 stakePeriod,\\r\\n        uint256 lockedUntil\\r\\n    );\\r\\n    event Unstaked(address indexed user, uint256 amount);\\r\\n\\r\\n    struct StakeLevel {\\r\\n        uint256 amount; // Amount to stake\\r\\n        uint256 discount; // Discount when amount is reached\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Stake using IERC2612 permit\\r\\n     * @param amount The amount of xPremia to stake\\r\\n     * @param period The lockup period (in seconds)\\r\\n     * @param deadline Deadline after which permit will fail\\r\\n     * @param v V\\r\\n     * @param r R\\r\\n     * @param s S\\r\\n     */\\r\\n    function stakeWithPermit(\\r\\n        uint256 amount,\\r\\n        uint256 period,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Lockup xPremia for protocol fee discounts\\r\\n     *          Longer period of locking will apply a multiplier on the amount staked, in the fee discount calculation\\r\\n     * @param amount The amount of xPremia to stake\\r\\n     * @param period The lockup period (in seconds)\\r\\n     */\\r\\n    function stake(uint256 amount, uint256 period) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Unstake xPremia (If lockup period has ended)\\r\\n     * @param amount The amount of xPremia to unstake\\r\\n     */\\r\\n    function unstake(uint256 amount) external;\\r\\n\\r\\n    //////////\\r\\n    // View //\\r\\n    //////////\\r\\n\\r\\n    /**\\r\\n     * Calculate the stake amount of a user, after applying the bonus from the lockup period chosen\\r\\n     * @param user The user from which to query the stake amount\\r\\n     * @return The user stake amount after applying the bonus\\r\\n     */\\r\\n    function getStakeAmountWithBonus(address user)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate the % of fee discount for user, based on his stake\\r\\n     * @param user The _user for which the discount is for\\r\\n     * @return Percentage of protocol fee discount (in basis point)\\r\\n     *         Ex : 1000 = 10% fee discount\\r\\n     */\\r\\n    function getDiscount(address user) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Get stake levels\\r\\n     * @return Stake levels\\r\\n     *         Ex : 2500 = -25%\\r\\n     */\\r\\n    function getStakeLevels() external returns (StakeLevel[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Get stake period multiplier\\r\\n     * @param period The duration (in seconds) for which tokens are locked\\r\\n     * @return The multiplier for this staking period\\r\\n     *         Ex : 20000 = x2\\r\\n     */\\r\\n    function getStakePeriodMultiplier(uint256 period)\\r\\n        external\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Get staking infos of a user\\r\\n     * @param user The user address for which to get staking infos\\r\\n     * @return The staking infos of the user\\r\\n     */\\r\\n    function getUserInfo(address user)\\r\\n        external\\r\\n        view\\r\\n        returns (FeeDiscountStorage.UserInfo memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/staking/IPremiaStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {PremiaStakingStorage} from \\\"./PremiaStakingStorage.sol\\\";\\r\\n\\r\\ninterface IPremiaStaking {\\r\\n    event Deposit(address indexed user, uint256 amount);\\r\\n    event StartWithdrawal(\\r\\n        address indexed user,\\r\\n        uint256 premiaAmount,\\r\\n        uint256 startDate\\r\\n    );\\r\\n    event Withdrawal(address indexed user, uint256 amount);\\r\\n\\r\\n    /**\\r\\n     * @notice stake PREMIA using IERC2612 permit\\r\\n     * @param amount quantity of PREMIA to stake\\r\\n     * @param deadline timestamp after which permit will fail\\r\\n     * @param v signature \\\"v\\\" value\\r\\n     * @param r signature \\\"r\\\" value\\r\\n     * @param s signature \\\"s\\\" value\\r\\n     */\\r\\n    function depositWithPermit(\\r\\n        uint256 amount,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice stake PREMIA in exchange for xPremia\\r\\n     * @param amount quantity of PREMIA to stake\\r\\n     */\\r\\n    function deposit(uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Initiate the withdrawal process by burning xPremia, starting the delay period\\r\\n     * @param amount quantity of xPremia to unstake\\r\\n     */\\r\\n    function startWithdraw(uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @notice withdraw PREMIA after withdrawal delay has passed\\r\\n     */\\r\\n    function withdraw() external;\\r\\n\\r\\n    /**\\r\\n     * @notice get current withdrawal delay\\r\\n     * @return withdrawal delay\\r\\n     */\\r\\n    function getWithdrawalDelay() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice set current withdrawal delay\\r\\n     * @param delay withdrawal delay\\r\\n     */\\r\\n    function setWithdrawalDelay(uint256 delay) external;\\r\\n\\r\\n    /**\\r\\n     * @notice get the xPREMIA : PREMIA ratio (with 18 decimals)\\r\\n     * @return xPREMIA : PREMIA ratio (with 18 decimals)\\r\\n     */\\r\\n    function getXPremiaToPremiaRatio() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice get pending withdrawal data of a user\\r\\n     * @return amount pending withdrawal amount\\r\\n     * @return startDate start timestamp of withdrawal\\r\\n     * @return unlockDate timestamp at which withdrawal becomes available\\r\\n     */\\r\\n    function getPendingWithdrawal(address user)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 amount,\\r\\n            uint256 startDate,\\r\\n            uint256 unlockDate\\r\\n        );\\r\\n\\r\\n    /**\\r\\n     * @notice get the amount of PREMIA staked (subtracting all pending withdrawals)\\r\\n     * @return amount of PREMIA staked\\r\\n     */\\r\\n    function getStakedPremiaAmount() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial ERC20 interface needed by internal functions\\n */\\ninterface IERC20Internal {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/staking/FeeDiscountStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary FeeDiscountStorage {\\r\\n    bytes32 internal constant STORAGE_SLOT =\\r\\n        keccak256(\\\"premia.contracts.staking.PremiaFeeDiscount\\\");\\r\\n\\r\\n    struct UserInfo {\\r\\n        uint256 balance; // Balance staked by user\\r\\n        uint64 stakePeriod; // Stake period selected by user\\r\\n        uint64 lockedUntil; // Timestamp at which the lock ends\\r\\n    }\\r\\n\\r\\n    struct Layout {\\r\\n        // User data with xPREMIA balance staked and date at which lock ends\\r\\n        mapping(address => UserInfo) userInfo;\\r\\n    }\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/staking/PremiaStakingStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary PremiaStakingStorage {\\r\\n    bytes32 internal constant STORAGE_SLOT =\\r\\n        keccak256(\\\"premia.contracts.staking.PremiaStaking\\\");\\r\\n\\r\\n    struct Withdrawal {\\r\\n        uint256 amount; // Premia amount\\r\\n        uint256 startDate; // Will unlock at startDate + withdrawalDelay\\r\\n    }\\r\\n\\r\\n    struct Layout {\\r\\n        uint256 pendingWithdrawal;\\r\\n        uint256 withdrawalDelay;\\r\\n        mapping(address => Withdrawal) withdrawals;\\r\\n    }\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_premia\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_xPremia\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeDiscount\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PremiaVoteProxy","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006399c842dd2be3de30bf99bc7d1bbf6fa3650e70000000000000000000000000f1bb87563a122211d40d393ebf1c633c330377f9000000000000000000000000f1bb87563a122211d40d393ebf1c633c330377f9","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}