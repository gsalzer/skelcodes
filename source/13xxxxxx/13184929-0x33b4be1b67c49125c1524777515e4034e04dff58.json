{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/multiply/MultiplyProxyActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\r\\n\\r\\n/// MultiplyProxyActions.sol\\r\\n\\r\\n// Copyright (C) 2021-2021 Oazo Apps Limited\\r\\n\\r\\n// This program is free software: you can redistribute it and/or modify\\r\\n// it under the terms of the GNU Affero General Public License as published by\\r\\n// the Free Software Foundation, either version 3 of the License, or\\r\\n// (at your option) any later version.\\r\\n//\\r\\n// This program is distributed in the hope that it will be useful,\\r\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\r\\n// GNU Affero General Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU Affero General Public License\\r\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\r\\n\\r\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\r\\nimport \\\"../interfaces/aaveV2/ILendingPoolAddressesProviderV2.sol\\\";\\r\\nimport \\\"../interfaces/aaveV2/ILendingPoolV2.sol\\\";\\r\\nimport \\\"../utils/SafeMath.sol\\\";\\r\\nimport \\\"../interfaces/IWETH.sol\\\";\\r\\nimport \\\"../interfaces/mcd/IJoin.sol\\\";\\r\\nimport \\\"../interfaces/mcd/IManager.sol\\\";\\r\\nimport \\\"../interfaces/mcd/IVat.sol\\\";\\r\\nimport \\\"../interfaces/mcd/IJug.sol\\\";\\r\\nimport \\\"../interfaces/mcd/IDaiJoin.sol\\\";\\r\\nimport \\\"../interfaces/exchange/IExchange.sol\\\";\\r\\nimport \\\"./ExchangeData.sol\\\";\\r\\n\\r\\npragma solidity >=0.7.6;\\r\\npragma abicoder v2;\\r\\n\\r\\nstruct CdpData {\\r\\n  address gemJoin;\\r\\n  address payable fundsReceiver;\\r\\n  uint256 cdpId;\\r\\n  bytes32 ilk;\\r\\n  uint256 requiredDebt;\\r\\n  uint256 borrowCollateral;\\r\\n  uint256 withdrawCollateral;\\r\\n  uint256 withdrawDai;\\r\\n  uint256 depositDai;\\r\\n  uint256 depositCollateral;\\r\\n  bool skipFL;\\r\\n  string methodName;\\r\\n}\\r\\n\\r\\nstruct AddressRegistry {\\r\\n  address jug;\\r\\n  address manager;\\r\\n  address multiplyProxyActions;\\r\\n  address aaveLendingPoolProvider;\\r\\n  address exchange;\\r\\n}\\r\\n\\r\\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\r\\n// WARNING: These functions meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\\r\\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\r\\n\\r\\ncontract MultiplyProxyActions {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  uint256 constant RAY = 10**27;\\r\\n\\r\\n  address public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\r\\n  address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\r\\n  address public constant DAIJOIN = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\\r\\n  uint16 constant AAVE_REFERRAL = 197;\\r\\n\\r\\n  modifier logMethodName(\\r\\n    string memory name,\\r\\n    CdpData memory data,\\r\\n    address destination\\r\\n  ) {\\r\\n    if (bytes(data.methodName).length == 0) {\\r\\n      data.methodName = name;\\r\\n    }\\r\\n    _;\\r\\n    data.methodName = \\\"\\\";\\r\\n  }\\r\\n\\r\\n  function getAaveLendingPool(address lendingPoolProvider) private view returns (ILendingPoolV2) {\\r\\n    ILendingPoolAddressesProviderV2 provider = ILendingPoolAddressesProviderV2(lendingPoolProvider);\\r\\n    ILendingPoolV2 lendingPool = ILendingPoolV2(provider.getLendingPool());\\r\\n    return lendingPool;\\r\\n  }\\r\\n\\r\\n  function takeAFlashLoan(\\r\\n    AddressRegistry memory addressRegistry,\\r\\n    CdpData memory cdpData,\\r\\n    address[] memory assets,\\r\\n    uint256[] memory amounts,\\r\\n    uint256[] memory modes,\\r\\n    bytes memory paramsData\\r\\n  ) internal {\\r\\n    IManager(addressRegistry.manager).cdpAllow(\\r\\n      cdpData.cdpId,\\r\\n      addressRegistry.multiplyProxyActions,\\r\\n      1\\r\\n    );\\r\\n\\r\\n    ILendingPoolV2 lendingPool = getAaveLendingPool(addressRegistry.aaveLendingPoolProvider);\\r\\n    lendingPool.flashLoan(\\r\\n      addressRegistry.multiplyProxyActions,\\r\\n      assets,\\r\\n      amounts,\\r\\n      modes,\\r\\n      address(this),\\r\\n      paramsData,\\r\\n      AAVE_REFERRAL\\r\\n    );\\r\\n\\r\\n    IManager(addressRegistry.manager).cdpAllow(\\r\\n      cdpData.cdpId,\\r\\n      addressRegistry.multiplyProxyActions,\\r\\n      0\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function toInt256(uint256 x) internal pure returns (int256 y) {\\r\\n    y = int256(x);\\r\\n    require(y >= 0, \\\"int256-overflow\\\");\\r\\n  }\\r\\n\\r\\n  function convertTo18(address gemJoin, uint256 amt) internal returns (uint256 wad) {\\r\\n    // For those collaterals that have less than 18 decimals precision we need to do the conversion before passing to frob function\\r\\n    // Adapters will automatically handle the difference of precision\\r\\n    wad = amt.mul(10**(18 - IJoin(gemJoin).dec()));\\r\\n  }\\r\\n\\r\\n  function _getDrawDart(\\r\\n    address vat,\\r\\n    address jug,\\r\\n    address urn,\\r\\n    bytes32 ilk,\\r\\n    uint256 wad\\r\\n  ) internal returns (int256 dart) {\\r\\n    // Updates stability fee rate\\r\\n    uint256 rate = IJug(jug).drip(ilk);\\r\\n\\r\\n    // Gets DAI balance of the urn in the vat\\r\\n    uint256 dai = IVat(vat).dai(urn);\\r\\n\\r\\n    // If there was already enough DAI in the vat balance, just exits it without adding more debt\\r\\n    if (dai < wad.mul(RAY)) {\\r\\n      // Calculates the needed dart so together with the existing dai in the vat is enough to exit wad amount of DAI tokens\\r\\n      dart = toInt256(wad.mul(RAY).sub(dai) / rate);\\r\\n      // This is neeeded due lack of precision. It might need to sum an extra dart wei (for the given DAI wad amount)\\r\\n      dart = uint256(dart).mul(rate) < wad.mul(RAY) ? dart + 1 : dart;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function openMultiplyVault(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  )\\r\\n    public\\r\\n    payable\\r\\n    logMethodName(\\\"openMultiplyVault\\\", cdpData, addressRegistry.multiplyProxyActions)\\r\\n  {\\r\\n    cdpData.ilk = IJoin(cdpData.gemJoin).ilk();\\r\\n    cdpData.cdpId = IManager(addressRegistry.manager).open(cdpData.ilk, address(this));\\r\\n    increaseMultipleDepositCollateral(exchangeData, cdpData, addressRegistry);\\r\\n  }\\r\\n\\r\\n  function increaseMultipleDepositCollateral(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  )\\r\\n    public\\r\\n    payable\\r\\n    logMethodName(\\r\\n      \\\"increaseMultipleDepositCollateral\\\",\\r\\n      cdpData,\\r\\n      addressRegistry.multiplyProxyActions\\r\\n    )\\r\\n  {\\r\\n    IGem gem = IJoin(cdpData.gemJoin).gem();\\r\\n\\r\\n    if (address(gem) == WETH) {\\r\\n      gem.deposit{value: msg.value}();\\r\\n      if (cdpData.skipFL == false) {\\r\\n        gem.transfer(addressRegistry.multiplyProxyActions, msg.value);\\r\\n      }\\r\\n    } else {\\r\\n      if (cdpData.skipFL == false) {\\r\\n        gem.transferFrom(\\r\\n          msg.sender,\\r\\n          addressRegistry.multiplyProxyActions,\\r\\n          cdpData.depositCollateral\\r\\n        );\\r\\n      } else {\\r\\n        gem.transferFrom(msg.sender, address(this), cdpData.depositCollateral);\\r\\n      }\\r\\n    }\\r\\n    increaseMultipleInternal(exchangeData, cdpData, addressRegistry);\\r\\n  }\\r\\n\\r\\n  function toRad(uint256 wad) internal pure returns (uint256 rad) {\\r\\n    rad = wad.mul(10**27);\\r\\n  }\\r\\n\\r\\n  function drawDaiDebt(\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry,\\r\\n    uint256 amount\\r\\n  ) internal {\\r\\n    address urn = IManager(addressRegistry.manager).urns(cdpData.cdpId);\\r\\n    address vat = IManager(addressRegistry.manager).vat();\\r\\n    IManager(addressRegistry.manager).frob(\\r\\n      cdpData.cdpId,\\r\\n      0,\\r\\n      _getDrawDart(vat, addressRegistry.jug, urn, cdpData.ilk, amount)\\r\\n    );\\r\\n    IManager(addressRegistry.manager).move(cdpData.cdpId, address(this), toRad(amount));\\r\\n    if (IVat(vat).can(address(this), address(DAIJOIN)) == 0) {\\r\\n      IVat(vat).hope(DAIJOIN);\\r\\n    }\\r\\n\\r\\n    IJoin(DAIJOIN).exit(address(this), amount);\\r\\n  }\\r\\n\\r\\n  function increaseMultipleDepositDai(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  )\\r\\n    public\\r\\n    logMethodName(\\\"increaseMultipleDepositDai\\\", cdpData, addressRegistry.multiplyProxyActions)\\r\\n  {\\r\\n    if (cdpData.skipFL) {\\r\\n      IERC20(DAI).transferFrom(msg.sender, address(this), cdpData.depositDai);\\r\\n    } else {\\r\\n      IERC20(DAI).transferFrom(\\r\\n        msg.sender,\\r\\n        addressRegistry.multiplyProxyActions,\\r\\n        cdpData.depositDai\\r\\n      );\\r\\n    }\\r\\n    increaseMultipleInternal(exchangeData, cdpData, addressRegistry);\\r\\n  }\\r\\n\\r\\n  function increaseMultiple(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  ) public logMethodName(\\\"increaseMultiple\\\", cdpData, addressRegistry.multiplyProxyActions) {\\r\\n    increaseMultipleInternal(exchangeData, cdpData, addressRegistry);\\r\\n  }\\r\\n\\r\\n  function increaseMultipleInternal(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  ) internal {\\r\\n    cdpData.ilk = IJoin(cdpData.gemJoin).ilk();\\r\\n\\r\\n    address[] memory assets = new address[](1);\\r\\n    assets[0] = DAI;\\r\\n    uint256[] memory amounts = new uint256[](1);\\r\\n    amounts[0] = cdpData.requiredDebt;\\r\\n    uint256[] memory modes = new uint256[](1);\\r\\n    modes[0] = 0;\\r\\n\\r\\n    bytes memory paramsData = abi.encode(1, exchangeData, cdpData, addressRegistry);\\r\\n\\r\\n    if (cdpData.skipFL) {\\r\\n      //we want to draw our own DAI and use them in the exchange to buy collateral\\r\\n      IGem gem = IJoin(cdpData.gemJoin).gem();\\r\\n      uint256 collBalance = IERC20(address(gem)).balanceOf(address(this));\\r\\n      if (collBalance > 0) {\\r\\n        //if someone provided some collateral during increase\\r\\n        //add it to vault and draw DAI\\r\\n        joinDrawDebt(cdpData, cdpData.requiredDebt, addressRegistry.manager, addressRegistry.jug);\\r\\n      } else {\\r\\n        //just draw DAI\\r\\n        drawDaiDebt(cdpData, addressRegistry, cdpData.requiredDebt);\\r\\n      }\\r\\n      _increaseMP(exchangeData, cdpData, addressRegistry, 0);\\r\\n    } else {\\r\\n      takeAFlashLoan(addressRegistry, cdpData, assets, amounts, modes, paramsData);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function decreaseMultiple(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  ) public logMethodName(\\\"decreaseMultiple\\\", cdpData, addressRegistry.multiplyProxyActions) {\\r\\n    decreaseMultipleInternal(exchangeData, cdpData, addressRegistry);\\r\\n  }\\r\\n\\r\\n  function decreaseMultipleInternal(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  ) internal {\\r\\n    cdpData.ilk = IJoin(cdpData.gemJoin).ilk();\\r\\n\\r\\n    address[] memory assets = new address[](1);\\r\\n    assets[0] = DAI;\\r\\n\\r\\n    uint256[] memory amounts = new uint256[](1);\\r\\n    amounts[0] = cdpData.requiredDebt;\\r\\n\\r\\n    uint256[] memory modes = new uint256[](1);\\r\\n    modes[0] = 0;\\r\\n\\r\\n    bytes memory paramsData = abi.encode(0, exchangeData, cdpData, addressRegistry);\\r\\n\\r\\n    if (cdpData.skipFL) {\\r\\n      _decreaseMP(exchangeData, cdpData, addressRegistry, 0);\\r\\n    } else {\\r\\n      takeAFlashLoan(addressRegistry, cdpData, assets, amounts, modes, paramsData);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function decreaseMultipleWithdrawCollateral(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  )\\r\\n    public\\r\\n    logMethodName(\\r\\n      \\\"decreaseMultipleWithdrawCollateral\\\",\\r\\n      cdpData,\\r\\n      addressRegistry.multiplyProxyActions\\r\\n    )\\r\\n  {\\r\\n    decreaseMultipleInternal(exchangeData, cdpData, addressRegistry);\\r\\n  }\\r\\n\\r\\n  function decreaseMultipleWithdrawDai(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  )\\r\\n    public\\r\\n    logMethodName(\\\"decreaseMultipleWithdrawDai\\\", cdpData, addressRegistry.multiplyProxyActions)\\r\\n  {\\r\\n    decreaseMultipleInternal(exchangeData, cdpData, addressRegistry);\\r\\n  }\\r\\n\\r\\n  function closeVaultExitGeneric(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry,\\r\\n    uint8 mode\\r\\n  ) private {\\r\\n    cdpData.ilk = IJoin(cdpData.gemJoin).ilk();\\r\\n\\r\\n    address urn = IManager(addressRegistry.manager).urns(cdpData.cdpId);\\r\\n    address vat = IManager(addressRegistry.manager).vat();\\r\\n\\r\\n    uint256 wadD = _getWipeAllWad(vat, urn, urn, cdpData.ilk);\\r\\n    cdpData.requiredDebt = wadD;\\r\\n\\r\\n    address[] memory assets = new address[](1);\\r\\n    assets[0] = DAI;\\r\\n\\r\\n    uint256[] memory amounts = new uint256[](1);\\r\\n    amounts[0] = wadD;\\r\\n\\r\\n    uint256[] memory modes = new uint256[](1);\\r\\n    modes[0] = 0;\\r\\n\\r\\n    bytes memory paramsData = abi.encode(mode, exchangeData, cdpData, addressRegistry);\\r\\n\\r\\n    if (cdpData.skipFL == false) {\\r\\n      takeAFlashLoan(addressRegistry, cdpData, assets, amounts, modes, paramsData);\\r\\n    } else {\\r\\n      if (mode == 2) {\\r\\n        _closeWithdrawCollateralSkipFL(exchangeData, cdpData, addressRegistry, cdpData.borrowCollateral);\\r\\n      } else {\\r\\n        require(false, \\\"this code should be unreachable\\\");\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function closeVaultExitCollateral(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  )\\r\\n    public\\r\\n    logMethodName(\\\"closeVaultExitCollateral\\\", cdpData, addressRegistry.multiplyProxyActions)\\r\\n  {\\r\\n    closeVaultExitGeneric(exchangeData, cdpData, addressRegistry, 2);\\r\\n  }\\r\\n\\r\\n  function closeVaultExitDai(\\r\\n    ExchangeData calldata exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry calldata addressRegistry\\r\\n  ) public logMethodName(\\\"closeVaultExitDai\\\", cdpData, addressRegistry.multiplyProxyActions) {\\r\\n    require(cdpData.skipFL == false, \\\"cannot close to DAI if FL not used\\\");\\r\\n    closeVaultExitGeneric(exchangeData, cdpData, addressRegistry, 3);\\r\\n  }\\r\\n\\r\\n  function joinDrawDebt(\\r\\n    CdpData memory cdpData,\\r\\n    uint256 borrowedDai,\\r\\n    address manager,\\r\\n    address jug\\r\\n  ) private {\\r\\n    IGem gem = IJoin(cdpData.gemJoin).gem();\\r\\n\\r\\n    uint256 balance = IERC20(address(gem)).balanceOf(address(this));\\r\\n    gem.approve(address(cdpData.gemJoin), balance);\\r\\n\\r\\n    address urn = IManager(manager).urns(cdpData.cdpId);\\r\\n    address vat = IManager(manager).vat();\\r\\n\\r\\n    IJoin(cdpData.gemJoin).join(urn, balance);\\r\\n\\r\\n    IManager(manager).frob(\\r\\n      cdpData.cdpId,\\r\\n      toInt256(convertTo18(cdpData.gemJoin, balance)),\\r\\n      _getDrawDart(vat, jug, urn, cdpData.ilk, borrowedDai)\\r\\n    );\\r\\n    IManager(manager).move(cdpData.cdpId, address(this), borrowedDai.mul(RAY));\\r\\n\\r\\n    IVat(vat).hope(DAIJOIN);\\r\\n\\r\\n    IJoin(DAIJOIN).exit(address(this), borrowedDai);\\r\\n  }\\r\\n\\r\\n  function getInk(address manager, CdpData memory cdpData) internal view returns (uint256) {\\r\\n    address urn = IManager(manager).urns(cdpData.cdpId);\\r\\n    address vat = IManager(manager).vat();\\r\\n\\r\\n    (uint256 ink, ) = IVat(vat).urns(cdpData.ilk, urn);\\r\\n    return ink;\\r\\n  }\\r\\n\\r\\n  function _getWipeDart(\\r\\n    address vat,\\r\\n    uint256 dai,\\r\\n    address urn,\\r\\n    bytes32 ilk\\r\\n  ) internal view returns (int256 dart) {\\r\\n    // Gets actual rate from the vat\\r\\n    (, uint256 rate, , , ) = IVat(vat).ilks(ilk);\\r\\n    // Gets actual art value of the urn\\r\\n    (, uint256 art) = IVat(vat).urns(ilk, urn);\\r\\n\\r\\n    // Uses the whole dai balance in the vat to reduce the debt\\r\\n    dart = toInt256(dai / rate);\\r\\n    // Checks the calculated dart is not higher than urn.art (total debt), otherwise uses its value\\r\\n    dart = uint256(dart) <= art ? -dart : -toInt256(art);\\r\\n  }\\r\\n\\r\\n  function _getWipeAllWad(\\r\\n    address vat,\\r\\n    address usr,\\r\\n    address urn,\\r\\n    bytes32 ilk\\r\\n  ) internal view returns (uint256 wad) {\\r\\n    // Gets actual rate from the vat\\r\\n    (, uint256 rate, , , ) = IVat(vat).ilks(ilk);\\r\\n    // Gets actual art value of the urn\\r\\n    (, uint256 art) = IVat(vat).urns(ilk, urn);\\r\\n    // Gets actual dai amount in the urn\\r\\n    uint256 dai = IVat(vat).dai(usr);\\r\\n\\r\\n    uint256 rad = art.mul(rate).sub(dai);\\r\\n    wad = rad / RAY;\\r\\n\\r\\n    // If the rad precision has some dust, it will need to request for 1 extra wad wei\\r\\n    wad = wad.mul(RAY) < rad ? wad + 1 : wad;\\r\\n  }\\r\\n\\r\\n  function wipeAndFreeGem(\\r\\n    address manager,\\r\\n    address gemJoin,\\r\\n    uint256 cdp,\\r\\n    uint256 borrowedDai,\\r\\n    uint256 collateralDraw\\r\\n  ) internal {\\r\\n    address vat = IManager(manager).vat();\\r\\n    address urn = IManager(manager).urns(cdp);\\r\\n    bytes32 ilk = IManager(manager).ilks(cdp);\\r\\n\\r\\n    IERC20(DAI).approve(DAIJOIN, borrowedDai);\\r\\n    IDaiJoin(DAIJOIN).join(urn, borrowedDai);\\r\\n\\r\\n    uint256 wadC = convertTo18(gemJoin, collateralDraw);\\r\\n\\r\\n    IManager(manager).frob(cdp, -toInt256(wadC), _getWipeDart(vat, IVat(vat).dai(urn), urn, ilk));\\r\\n\\r\\n    IManager(manager).flux(cdp, address(this), wadC);\\r\\n    IJoin(gemJoin).exit(address(this), collateralDraw);\\r\\n  }\\r\\n\\r\\n  function _withdrawGem(\\r\\n    address gemJoin,\\r\\n    address payable destination,\\r\\n    uint256 amount\\r\\n  ) private {\\r\\n    IGem gem = IJoin(gemJoin).gem();\\r\\n\\r\\n    if (address(gem) == WETH) {\\r\\n      gem.withdraw(amount);\\r\\n      destination.transfer(amount);\\r\\n    } else {\\r\\n      IERC20(address(gem)).transfer(destination, amount);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _increaseMP(\\r\\n    ExchangeData memory exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry memory addressRegistry,\\r\\n    uint256 premium\\r\\n  ) private {\\r\\n    IExchange exchange = IExchange(addressRegistry.exchange);\\r\\n    uint256 borrowedDai = cdpData.requiredDebt.add(premium);\\r\\n    if (cdpData.skipFL) {\\r\\n      borrowedDai = 0; //this DAI are not borrowed and shal not stay after this method execution\\r\\n    }\\r\\n    require(\\r\\n      IERC20(DAI).approve(address(exchange), exchangeData.fromTokenAmount.add(cdpData.depositDai)),\\r\\n      \\\"MPA / Could not approve Exchange for DAI\\\"\\r\\n    );\\r\\n    exchange.swapDaiForToken(\\r\\n      exchangeData.toTokenAddress,\\r\\n      exchangeData.fromTokenAmount.add(cdpData.depositDai),\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.exchangeAddress,\\r\\n      exchangeData._exchangeCalldata\\r\\n    );\\r\\n    //here we add collateral we got from exchange, if skipFL then borrowedDai = 0\\r\\n    joinDrawDebt(cdpData, borrowedDai, addressRegistry.manager, addressRegistry.jug);\\r\\n    //if some DAI are left after exchange return them to the user\\r\\n    uint256 daiLeft = IERC20(DAI).balanceOf(address(this)).sub(borrowedDai);\\r\\n    emit MultipleActionCalled(\\r\\n      cdpData.methodName,\\r\\n      cdpData.cdpId,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.toTokenAmount,\\r\\n      0,\\r\\n      daiLeft\\r\\n    );\\r\\n\\r\\n    if (daiLeft > 0) {\\r\\n      IERC20(DAI).transfer(cdpData.fundsReceiver, daiLeft);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _decreaseMP(\\r\\n    ExchangeData memory exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry memory addressRegistry,\\r\\n    uint256 premium\\r\\n  ) private {\\r\\n    IExchange exchange = IExchange(addressRegistry.exchange);\\r\\n\\r\\n    uint256 debtToBeWiped = cdpData.skipFL ? 0 : cdpData.requiredDebt.sub(cdpData.withdrawDai);\\r\\n\\r\\n    wipeAndFreeGem(\\r\\n      addressRegistry.manager,\\r\\n      cdpData.gemJoin,\\r\\n      cdpData.cdpId,\\r\\n      debtToBeWiped,\\r\\n      cdpData.borrowCollateral.add(cdpData.withdrawCollateral)\\r\\n    );\\r\\n\\r\\n    require(\\r\\n      IERC20(exchangeData.fromTokenAddress).approve(\\r\\n        address(exchange),\\r\\n        exchangeData.fromTokenAmount\\r\\n      ),\\r\\n      \\\"MPA / Could not approve Exchange for Token\\\"\\r\\n    );\\r\\n\\r\\n    exchange.swapTokenForDai(\\r\\n      exchangeData.fromTokenAddress,\\r\\n      exchangeData.fromTokenAmount,\\r\\n      cdpData.requiredDebt.add(premium),\\r\\n      exchangeData.exchangeAddress,\\r\\n      exchangeData._exchangeCalldata\\r\\n    );\\r\\n\\r\\n    uint256 collateralLeft = IERC20(exchangeData.fromTokenAddress).balanceOf(address(this));\\r\\n\\r\\n    uint256 daiLeft = 0;\\r\\n    if (cdpData.skipFL) {\\r\\n      wipeAndFreeGem(\\r\\n        addressRegistry.manager,\\r\\n        cdpData.gemJoin,\\r\\n        cdpData.cdpId,\\r\\n        IERC20(DAI).balanceOf(address(this)).sub(cdpData.withdrawDai),\\r\\n        0\\r\\n      );\\r\\n      daiLeft = cdpData.withdrawDai;\\r\\n    } else {\\r\\n      daiLeft = IERC20(DAI).balanceOf(address(this)).sub(cdpData.requiredDebt.add(premium));\\r\\n    }\\r\\n    emit MultipleActionCalled(\\r\\n      cdpData.methodName,\\r\\n      cdpData.cdpId,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.toTokenAmount,\\r\\n      collateralLeft,\\r\\n      daiLeft\\r\\n    );\\r\\n\\r\\n    if (daiLeft > 0) {\\r\\n      IERC20(DAI).transfer(cdpData.fundsReceiver, daiLeft);\\r\\n    }\\r\\n    if (collateralLeft > 0) {\\r\\n      _withdrawGem(cdpData.gemJoin, cdpData.fundsReceiver, collateralLeft);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _closeWithdrawCollateralSkipFL(\\r\\n    ExchangeData memory exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry memory addressRegistry,\\r\\n    uint256 ink\\r\\n  ) private {\\r\\n    IExchange exchange = IExchange(addressRegistry.exchange);\\r\\n    address gemAddress = address(IJoin(cdpData.gemJoin).gem());\\r\\n\\r\\n    wipeAndFreeGem(\\r\\n      addressRegistry.manager,\\r\\n      cdpData.gemJoin,\\r\\n      cdpData.cdpId,\\r\\n      0,\\r\\n      exchangeData.fromTokenAmount\\r\\n    );\\r\\n    require(\\r\\n      IERC20(exchangeData.fromTokenAddress).approve(address(exchange), ink),\\r\\n      \\\"MPA / Could not approve Exchange for Token\\\"\\r\\n    );\\r\\n    exchange.swapTokenForDai(\\r\\n      exchangeData.fromTokenAddress,\\r\\n      exchangeData.fromTokenAmount,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.exchangeAddress,\\r\\n      exchangeData._exchangeCalldata\\r\\n    );\\r\\n\\r\\n    uint256 daiLeft = IERC20(DAI).balanceOf(address(this));\\r\\n\\r\\n    require(cdpData.requiredDebt <= daiLeft, \\\"cannot repay all debt\\\");\\r\\n    \\r\\n    wipeAndFreeGem(\\r\\n      addressRegistry.manager,\\r\\n      cdpData.gemJoin,\\r\\n      cdpData.cdpId,\\r\\n      cdpData.requiredDebt,\\r\\n      cdpData.withdrawCollateral\\r\\n    );\\r\\n    daiLeft = IERC20(DAI).balanceOf(address(this));\\r\\n\\r\\n    uint256 collateralLeft = IERC20(gemAddress).balanceOf(address(this));\\r\\n\\r\\n    if (daiLeft > 0) {\\r\\n      IERC20(DAI).transfer(cdpData.fundsReceiver, daiLeft);\\r\\n    }\\r\\n    if (collateralLeft > 0) {\\r\\n      _withdrawGem(cdpData.gemJoin, cdpData.fundsReceiver, collateralLeft);\\r\\n    }\\r\\n    emit MultipleActionCalled(\\r\\n      cdpData.methodName,\\r\\n      cdpData.cdpId,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.toTokenAmount,\\r\\n      collateralLeft,\\r\\n      daiLeft\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function _closeWithdrawCollateral(\\r\\n    ExchangeData memory exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry memory addressRegistry,\\r\\n    uint256 borrowedDaiAmount,\\r\\n    uint256 ink\\r\\n  ) private {\\r\\n    IExchange exchange = IExchange(addressRegistry.exchange);\\r\\n    address gemAddress = address(IJoin(cdpData.gemJoin).gem());\\r\\n\\r\\n    wipeAndFreeGem(\\r\\n      addressRegistry.manager,\\r\\n      cdpData.gemJoin,\\r\\n      cdpData.cdpId,\\r\\n      cdpData.requiredDebt,\\r\\n      ink\\r\\n    );\\r\\n\\r\\n    require(\\r\\n      IERC20(exchangeData.fromTokenAddress).approve(address(exchange), ink),\\r\\n      \\\"MPA / Could not approve Exchange for Token\\\"\\r\\n    );\\r\\n    exchange.swapTokenForDai(\\r\\n      exchangeData.fromTokenAddress,\\r\\n      exchangeData.fromTokenAmount,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.exchangeAddress,\\r\\n      exchangeData._exchangeCalldata\\r\\n    );\\r\\n\\r\\n    uint256 daiLeft = IERC20(DAI).balanceOf(address(this)).sub(borrowedDaiAmount);\\r\\n    uint256 collateralLeft = IERC20(gemAddress).balanceOf(address(this));\\r\\n\\r\\n    if (daiLeft > 0) {\\r\\n      IERC20(DAI).transfer(cdpData.fundsReceiver, daiLeft);\\r\\n    }\\r\\n    if (collateralLeft > 0) {\\r\\n      _withdrawGem(cdpData.gemJoin, cdpData.fundsReceiver, collateralLeft);\\r\\n    }\\r\\n    emit MultipleActionCalled(\\r\\n      cdpData.methodName,\\r\\n      cdpData.cdpId,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.toTokenAmount,\\r\\n      collateralLeft,\\r\\n      daiLeft\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function _closeWithdrawDai(\\r\\n    ExchangeData memory exchangeData,\\r\\n    CdpData memory cdpData,\\r\\n    AddressRegistry memory addressRegistry,\\r\\n    uint256 borrowedDaiAmount,\\r\\n    uint256 ink\\r\\n  ) private {\\r\\n    IExchange exchange = IExchange(addressRegistry.exchange);\\r\\n    address gemAddress = address(IJoin(cdpData.gemJoin).gem());\\r\\n\\r\\n    wipeAndFreeGem(\\r\\n      addressRegistry.manager,\\r\\n      cdpData.gemJoin,\\r\\n      cdpData.cdpId,\\r\\n      cdpData.requiredDebt,\\r\\n      ink\\r\\n    );\\r\\n\\r\\n    require(\\r\\n      IERC20(exchangeData.fromTokenAddress).approve(\\r\\n        address(exchange),\\r\\n        IERC20(gemAddress).balanceOf(address(this))\\r\\n      ),\\r\\n      \\\"MPA / Could not approve Exchange for Token\\\"\\r\\n    );\\r\\n    exchange.swapTokenForDai(\\r\\n      exchangeData.fromTokenAddress,\\r\\n      ink,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.exchangeAddress,\\r\\n      exchangeData._exchangeCalldata\\r\\n    );\\r\\n\\r\\n    uint256 daiLeft = IERC20(DAI).balanceOf(address(this)).sub(borrowedDaiAmount);\\r\\n\\r\\n    if (daiLeft > 0) {\\r\\n      IERC20(DAI).transfer(cdpData.fundsReceiver, daiLeft);\\r\\n    }\\r\\n    uint256 collateralLeft = IERC20(gemAddress).balanceOf(address(this));\\r\\n    /*\\r\\n    if (collateralLeft > 0) {\\r\\n      _withdrawGem(cdpData.gemJoin, cdpData.fundsReceiver, collateralLeft);\\r\\n    }*/\\r\\n    emit MultipleActionCalled(\\r\\n      cdpData.methodName,\\r\\n      cdpData.cdpId,\\r\\n      exchangeData.minToTokenAmount,\\r\\n      exchangeData.toTokenAmount,\\r\\n      collateralLeft,\\r\\n      daiLeft\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function executeOperation(\\r\\n    address[] calldata assets,\\r\\n    uint256[] calldata amounts,\\r\\n    uint256[] calldata premiums,\\r\\n    address initiator,\\r\\n    bytes calldata params\\r\\n  ) external returns (bool) {\\r\\n    (\\r\\n      uint8 mode,\\r\\n      ExchangeData memory exchangeData,\\r\\n      CdpData memory cdpData,\\r\\n      AddressRegistry memory addressRegistry\\r\\n    ) = abi.decode(params, (uint8, ExchangeData, CdpData, AddressRegistry));\\r\\n    uint256 borrowedDaiAmount = amounts[0].add(premiums[0]);\\r\\n\\r\\n    emit FLData(IERC20(DAI).balanceOf(address(this)).sub(cdpData.depositDai), borrowedDaiAmount);\\r\\n\\r\\n    uint256 ink = getInk(addressRegistry.manager, cdpData);\\r\\n\\r\\n    require(\\r\\n      cdpData.requiredDebt.add(cdpData.depositDai) <= IERC20(DAI).balanceOf(address(this)),\\r\\n      \\\"requested and received amounts mismatch\\\"\\r\\n    );\\r\\n\\r\\n    if (mode == 0) {\\r\\n      _decreaseMP(exchangeData, cdpData, addressRegistry, premiums[0]);\\r\\n    }\\r\\n    if (mode == 1) {\\r\\n      _increaseMP(exchangeData, cdpData, addressRegistry, premiums[0]);\\r\\n    }\\r\\n    if (mode == 2) {\\r\\n      _closeWithdrawCollateral(exchangeData, cdpData, addressRegistry, borrowedDaiAmount, cdpData.borrowCollateral);\\r\\n    }\\r\\n    if (mode == 3) {\\r\\n      _closeWithdrawDai(exchangeData, cdpData, addressRegistry, borrowedDaiAmount, cdpData.borrowCollateral);\\r\\n    }\\r\\n\\r\\n    IERC20(assets[0]).approve(\\r\\n        address(getAaveLendingPool(addressRegistry.aaveLendingPoolProvider)),\\r\\n        borrowedDaiAmount\\r\\n      );\\r\\n\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  event FLData(uint256 borrowed, uint256 due);\\r\\n  event MultipleActionCalled(\\r\\n    string methodName,\\r\\n    uint256 indexed cdpId,\\r\\n    uint256 swapMinAmount,\\r\\n    uint256 swapOptimistAmount,\\r\\n    uint256 collateralLeft,\\r\\n    uint256 daiLeft\\r\\n  );\\r\\n\\r\\n  fallback() external payable {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n  function totalSupply() external view returns (uint256 supply);\\r\\n\\r\\n  function balanceOf(address _owner) external view returns (uint256 balance);\\r\\n\\r\\n  function transfer(address _to, uint256 _value) external returns (bool success);\\r\\n\\r\\n  function transferFrom(\\r\\n    address _from,\\r\\n    address _to,\\r\\n    uint256 _value\\r\\n  ) external returns (bool success);\\r\\n\\r\\n  function approve(address _spender, uint256 _value) external returns (bool success);\\r\\n\\r\\n  function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\r\\n\\r\\n  function decimals() external view returns (uint256 digits);\\r\\n\\r\\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/aaveV2/ILendingPoolAddressesProviderV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n/**\\r\\n * @title LendingPoolAddressesProvider contract\\r\\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\\r\\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\\r\\n * - Owned by the Aave Governance\\r\\n * @author Aave\\r\\n **/\\r\\ninterface ILendingPoolAddressesProviderV2 {\\r\\n  event LendingPoolUpdated(address indexed newAddress);\\r\\n  event ConfigurationAdminUpdated(address indexed newAddress);\\r\\n  event EmergencyAdminUpdated(address indexed newAddress);\\r\\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\\r\\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\\r\\n  event PriceOracleUpdated(address indexed newAddress);\\r\\n  event LendingRateOracleUpdated(address indexed newAddress);\\r\\n  event ProxyCreated(bytes32 id, address indexed newAddress);\\r\\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\\r\\n\\r\\n  function setAddress(bytes32 id, address newAddress) external;\\r\\n\\r\\n  function setAddressAsProxy(bytes32 id, address impl) external;\\r\\n\\r\\n  function getAddress(bytes32 id) external view returns (address);\\r\\n\\r\\n  function getLendingPool() external view returns (address);\\r\\n\\r\\n  function setLendingPoolImpl(address pool) external;\\r\\n\\r\\n  function getLendingPoolConfigurator() external view returns (address);\\r\\n\\r\\n  function setLendingPoolConfiguratorImpl(address configurator) external;\\r\\n\\r\\n  function getLendingPoolCollateralManager() external view returns (address);\\r\\n\\r\\n  function setLendingPoolCollateralManager(address manager) external;\\r\\n\\r\\n  function getPoolAdmin() external view returns (address);\\r\\n\\r\\n  function setPoolAdmin(address admin) external;\\r\\n\\r\\n  function getEmergencyAdmin() external view returns (address);\\r\\n\\r\\n  function setEmergencyAdmin(address admin) external;\\r\\n\\r\\n  function getPriceOracle() external view returns (address);\\r\\n\\r\\n  function setPriceOracle(address priceOracle) external;\\r\\n\\r\\n  function getLendingRateOracle() external view returns (address);\\r\\n\\r\\n  function setLendingRateOracle(address lendingRateOracle) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/aaveV2/ILendingPoolV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\r\\npragma solidity ^0.7.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport './ILendingPoolAddressesProviderV2.sol';\\r\\n\\r\\nlibrary DataTypes {\\r\\n  // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\r\\n  struct ReserveData {\\r\\n    //stores the reserve configuration\\r\\n    ReserveConfigurationMap configuration;\\r\\n    //the liquidity index. Expressed in ray\\r\\n    uint128 liquidityIndex;\\r\\n    //variable borrow index. Expressed in ray\\r\\n    uint128 variableBorrowIndex;\\r\\n    //the current supply rate. Expressed in ray\\r\\n    uint128 currentLiquidityRate;\\r\\n    //the current variable borrow rate. Expressed in ray\\r\\n    uint128 currentVariableBorrowRate;\\r\\n    //the current stable borrow rate. Expressed in ray\\r\\n    uint128 currentStableBorrowRate;\\r\\n    uint40 lastUpdateTimestamp;\\r\\n    //tokens addresses\\r\\n    address aTokenAddress;\\r\\n    address stableDebtTokenAddress;\\r\\n    address variableDebtTokenAddress;\\r\\n    //address of the interest rate strategy\\r\\n    address interestRateStrategyAddress;\\r\\n    //the id of the reserve. Represents the position in the list of the active reserves\\r\\n    uint8 id;\\r\\n  }\\r\\n\\r\\n  struct ReserveConfigurationMap {\\r\\n    //bit 0-15: LTV\\r\\n    //bit 16-31: Liq. threshold\\r\\n    //bit 32-47: Liq. bonus\\r\\n    //bit 48-55: Decimals\\r\\n    //bit 56: Reserve is active\\r\\n    //bit 57: reserve is frozen\\r\\n    //bit 58: borrowing is enabled\\r\\n    //bit 59: stable rate borrowing enabled\\r\\n    //bit 60-63: reserved\\r\\n    //bit 64-79: reserve factor\\r\\n    uint256 data;\\r\\n  }\\r\\n\\r\\n  struct UserConfigurationMap {\\r\\n    uint256 data;\\r\\n  }\\r\\n\\r\\n  enum InterestRateMode {\\r\\n    NONE,\\r\\n    STABLE,\\r\\n    VARIABLE\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface ILendingPoolV2 {\\r\\n  /**\\r\\n   * @dev Emitted on deposit()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address initiating the deposit\\r\\n   * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\\r\\n   * @param amount The amount deposited\\r\\n   * @param referral The referral code used\\r\\n   **/\\r\\n  event Deposit(\\r\\n    address indexed reserve,\\r\\n    address user,\\r\\n    address indexed onBehalfOf,\\r\\n    uint256 amount,\\r\\n    uint16 indexed referral\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on withdraw()\\r\\n   * @param reserve The address of the underlyng asset being withdrawn\\r\\n   * @param user The address initiating the withdrawal, owner of aTokens\\r\\n   * @param to Address that will receive the underlying\\r\\n   * @param amount The amount to be withdrawn\\r\\n   **/\\r\\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\\r\\n   * @param reserve The address of the underlying asset being borrowed\\r\\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\\r\\n   * initiator of the transaction on flashLoan()\\r\\n   * @param onBehalfOf The address that will be getting the debt\\r\\n   * @param amount The amount borrowed out\\r\\n   * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\\r\\n   * @param borrowRate The numeric rate at which the user has borrowed\\r\\n   * @param referral The referral code used\\r\\n   **/\\r\\n  event Borrow(\\r\\n    address indexed reserve,\\r\\n    address user,\\r\\n    address indexed onBehalfOf,\\r\\n    uint256 amount,\\r\\n    uint256 borrowRateMode,\\r\\n    uint256 borrowRate,\\r\\n    uint16 indexed referral\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on repay()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The beneficiary of the repayment, getting his debt reduced\\r\\n   * @param repayer The address of the user initiating the repay(), providing the funds\\r\\n   * @param amount The amount repaid\\r\\n   **/\\r\\n  event Repay(\\r\\n    address indexed reserve,\\r\\n    address indexed user,\\r\\n    address indexed repayer,\\r\\n    uint256 amount\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on swapBorrowRateMode()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address of the user swapping his rate mode\\r\\n   * @param rateMode The rate mode that the user wants to swap to\\r\\n   **/\\r\\n  event Swap(address indexed reserve, address indexed user, uint256 rateMode);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address of the user enabling the usage as collateral\\r\\n   **/\\r\\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on setUserUseReserveAsCollateral()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address of the user enabling the usage as collateral\\r\\n   **/\\r\\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on rebalanceStableBorrowRate()\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param user The address of the user for which the rebalance has been executed\\r\\n   **/\\r\\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted on flashLoan()\\r\\n   * @param target The address of the flash loan receiver contract\\r\\n   * @param initiator The address initiating the flash loan\\r\\n   * @param asset The address of the asset being flash borrowed\\r\\n   * @param amount The amount flash borrowed\\r\\n   * @param premium The fee flash borrowed\\r\\n   * @param referralCode The referral code used\\r\\n   **/\\r\\n  event FlashLoan(\\r\\n    address indexed target,\\r\\n    address indexed initiator,\\r\\n    address indexed asset,\\r\\n    uint256 amount,\\r\\n    uint256 premium,\\r\\n    uint16 referralCode\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the pause is triggered.\\r\\n   */\\r\\n  event Paused();\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the pause is lifted.\\r\\n   */\\r\\n  event Unpaused();\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\\r\\n   * LendingPoolCollateral manager using a DELEGATECALL\\r\\n   * This allows to have the events in the generated ABI for LendingPool.\\r\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\r\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\r\\n   * @param user The address of the borrower getting liquidated\\r\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\r\\n   * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\\r\\n   * @param liquidator The address of the liquidator\\r\\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\\r\\n   * to receive the underlying collateral asset directly\\r\\n   **/\\r\\n  event LiquidationCall(\\r\\n    address indexed collateralAsset,\\r\\n    address indexed debtAsset,\\r\\n    address indexed user,\\r\\n    uint256 debtToCover,\\r\\n    uint256 liquidatedCollateralAmount,\\r\\n    address liquidator,\\r\\n    bool receiveAToken\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\\r\\n   * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\\r\\n   * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\\r\\n   * gets added to the LendingPool ABI\\r\\n   * @param reserve The address of the underlying asset of the reserve\\r\\n   * @param liquidityRate The new liquidity rate\\r\\n   * @param stableBorrowRate The new stable borrow rate\\r\\n   * @param variableBorrowRate The new variable borrow rate\\r\\n   * @param liquidityIndex The new liquidity index\\r\\n   * @param variableBorrowIndex The new variable borrow index\\r\\n   **/\\r\\n  event ReserveDataUpdated(\\r\\n    address indexed reserve,\\r\\n    uint256 liquidityRate,\\r\\n    uint256 stableBorrowRate,\\r\\n    uint256 variableBorrowRate,\\r\\n    uint256 liquidityIndex,\\r\\n    uint256 variableBorrowIndex\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\r\\n   * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\r\\n   * @param asset The address of the underlying asset to deposit\\r\\n   * @param amount The amount to be deposited\\r\\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\r\\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\r\\n   *   is a different wallet\\r\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\r\\n   *   0 if the action is executed directly by the user, without any middle-man\\r\\n   **/\\r\\n  function deposit(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    address onBehalfOf,\\r\\n    uint16 referralCode\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\r\\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\r\\n   * @param asset The address of the underlying asset to withdraw\\r\\n   * @param amount The underlying amount to be withdrawn\\r\\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\r\\n   * @param to Address that will receive the underlying, same as msg.sender if the user\\r\\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\r\\n   *   different wallet\\r\\n   **/\\r\\n  function withdraw(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    address to\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\\r\\n   * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\\r\\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\\r\\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\\r\\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\\r\\n   * @param asset The address of the underlying asset to borrow\\r\\n   * @param amount The amount to be borrowed\\r\\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\\r\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\r\\n   *   0 if the action is executed directly by the user, without any middle-man\\r\\n   * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\\r\\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\\r\\n   * if he has been given credit delegation allowance\\r\\n   **/\\r\\n  function borrow(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    uint256 interestRateMode,\\r\\n    uint16 referralCode,\\r\\n    address onBehalfOf\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\\r\\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\\r\\n   * @param asset The address of the borrowed underlying asset previously borrowed\\r\\n   * @param amount The amount to repay\\r\\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\\r\\n   * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\\r\\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\\r\\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\\r\\n   * other borrower whose debt should be removed\\r\\n   **/\\r\\n  function repay(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    uint256 rateMode,\\r\\n    address onBehalfOf\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\\r\\n   * @param asset The address of the underlying asset borrowed\\r\\n   * @param rateMode The rate mode that the user wants to swap to\\r\\n   **/\\r\\n  function swapBorrowRateMode(address asset, uint256 rateMode) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\\r\\n   * - Users can be rebalanced if the following conditions are satisfied:\\r\\n   *     1. Usage ratio is above 95%\\r\\n   *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\\r\\n   *        borrowed at a stable rate and depositors are not earning enough\\r\\n   * @param asset The address of the underlying asset borrowed\\r\\n   * @param user The address of the user to be rebalanced\\r\\n   **/\\r\\n  function rebalanceStableBorrowRate(address asset, address user) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Allows depositors to enable/disable a specific deposited asset as collateral\\r\\n   * @param asset The address of the underlying asset deposited\\r\\n   * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\\r\\n   **/\\r\\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\\r\\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\\r\\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\\r\\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\\r\\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\\r\\n   * @param user The address of the borrower getting liquidated\\r\\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\\r\\n   * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\\r\\n   * to receive the underlying collateral asset directly\\r\\n   **/\\r\\n  function liquidationCall(\\r\\n    address collateralAsset,\\r\\n    address debtAsset,\\r\\n    address user,\\r\\n    uint256 debtToCover,\\r\\n    bool receiveAToken\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\\r\\n   * as long as the amount taken plus a fee is returned.\\r\\n   * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\\r\\n   * For further details please visit https://developers.aave.com\\r\\n   * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\\r\\n   * @param assets The addresses of the assets being flash-borrowed\\r\\n   * @param amounts The amounts amounts being flash-borrowed\\r\\n   * @param modes Types of the debt to open if the flash loan is not returned:\\r\\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\\r\\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\r\\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\\r\\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\\r\\n   * @param params Variadic packed params to pass to the receiver as extra information\\r\\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\r\\n   *   0 if the action is executed directly by the user, without any middle-man\\r\\n   **/\\r\\n  function flashLoan(\\r\\n    address receiverAddress,\\r\\n    address[] calldata assets,\\r\\n    uint256[] calldata amounts,\\r\\n    uint256[] calldata modes,\\r\\n    address onBehalfOf,\\r\\n    bytes calldata params,\\r\\n    uint16 referralCode\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the user account data across all the reserves\\r\\n   * @param user The address of the user\\r\\n   * @return totalCollateralETH the total collateral in ETH of the user\\r\\n   * @return totalDebtETH the total debt in ETH of the user\\r\\n   * @return availableBorrowsETH the borrowing power left of the user\\r\\n   * @return currentLiquidationThreshold the liquidation threshold of the user\\r\\n   * @return ltv the loan to value of the user\\r\\n   * @return healthFactor the current health factor of the user\\r\\n   **/\\r\\n  function getUserAccountData(address user)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint256 totalCollateralETH,\\r\\n      uint256 totalDebtETH,\\r\\n      uint256 availableBorrowsETH,\\r\\n      uint256 currentLiquidationThreshold,\\r\\n      uint256 ltv,\\r\\n      uint256 healthFactor\\r\\n    );\\r\\n\\r\\n  function initReserve(\\r\\n    address reserve,\\r\\n    address aTokenAddress,\\r\\n    address stableDebtAddress,\\r\\n    address variableDebtAddress,\\r\\n    address interestRateStrategyAddress\\r\\n  ) external;\\r\\n\\r\\n  function setReserveInterestRateStrategyAddress(address reserve, address rateStrategyAddress)\\r\\n    external;\\r\\n\\r\\n  function setConfiguration(address reserve, uint256 configuration) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the configuration of the reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The configuration of the reserve\\r\\n   **/\\r\\n  function getConfiguration(address asset)\\r\\n    external\\r\\n    view\\r\\n    returns (DataTypes.ReserveConfigurationMap memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the configuration of the user across all the reserves\\r\\n   * @param user The user address\\r\\n   * @return The configuration of the user\\r\\n   **/\\r\\n  function getUserConfiguration(address user)\\r\\n    external\\r\\n    view\\r\\n    returns (DataTypes.UserConfigurationMap memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the normalized income normalized income of the reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The reserve's normalized income\\r\\n   */\\r\\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the normalized variable debt per unit of asset\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The reserve normalized variable debt\\r\\n   */\\r\\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the state and configuration of the reserve\\r\\n   * @param asset The address of the underlying asset of the reserve\\r\\n   * @return The state of the reserve\\r\\n   **/\\r\\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\\r\\n\\r\\n  function finalizeTransfer(\\r\\n    address asset,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 amount,\\r\\n    uint256 balanceFromAfter,\\r\\n    uint256 balanceToBefore\\r\\n  ) external;\\r\\n\\r\\n  function getReservesList() external view returns (address[] memory);\\r\\n\\r\\n  function getAddressesProvider() external view returns (ILendingPoolAddressesProviderV2);\\r\\n\\r\\n  function setPause(bool val) external;\\r\\n\\r\\n  function paused() external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.7.6;\\r\\n\\r\\nlibrary SafeMath {\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    uint256 c = a + b;\\r\\n    require(c >= a, 'SafeMath: addition overflow');\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\r\\n  }\\r\\n\\r\\n  function sub(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (uint256) {\\r\\n    require(b <= a, errorMessage);\\r\\n    uint256 c = a - b;\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\r\\n    // benefit is lost if 'b' is also tested.\\r\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n\\r\\n    uint256 c = a * b;\\r\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return div(a, b, 'SafeMath: division by zero');\\r\\n  }\\r\\n\\r\\n  function div(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (uint256) {\\r\\n    require(b > 0, errorMessage);\\r\\n    uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    return mod(a, b, 'SafeMath: modulo by zero');\\r\\n  }\\r\\n\\r\\n  function mod(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (uint256) {\\r\\n    require(b != 0, errorMessage);\\r\\n    return a % b;\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport './IERC20.sol';\\r\\n\\r\\nabstract contract IWETH {\\r\\n  function allowance(address, address) public virtual returns (uint256);\\r\\n\\r\\n  function balanceOf(address) public virtual returns (uint256);\\r\\n\\r\\n  function approve(address, uint256) public virtual;\\r\\n\\r\\n  function transfer(address, uint256) public virtual returns (bool);\\r\\n\\r\\n  function transferFrom(\\r\\n    address,\\r\\n    address,\\r\\n    uint256\\r\\n  ) public virtual returns (bool);\\r\\n\\r\\n  function deposit() public payable virtual;\\r\\n\\r\\n  function withdraw(uint256) public virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IJoin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport './IGem.sol';\\r\\n\\r\\nabstract contract IJoin {\\r\\n  bytes32 public ilk;\\r\\n\\r\\n  function dec() public view virtual returns (uint256);\\r\\n\\r\\n  function gem() public view virtual returns (IGem);\\r\\n\\r\\n  function join(address, uint256) public payable virtual;\\r\\n\\r\\n  function exit(address, uint256) public virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nabstract contract IManager {\\r\\n  function last(address) public virtual returns (uint256);\\r\\n\\r\\n  function cdpCan(\\r\\n    address,\\r\\n    uint256,\\r\\n    address\\r\\n  ) public view virtual returns (uint256);\\r\\n\\r\\n  function ilks(uint256) public view virtual returns (bytes32);\\r\\n\\r\\n  function owns(uint256) public view virtual returns (address);\\r\\n\\r\\n  function urns(uint256) public view virtual returns (address);\\r\\n\\r\\n  function vat() public view virtual returns (address);\\r\\n\\r\\n  function open(bytes32, address) public virtual returns (uint256);\\r\\n\\r\\n  function give(uint256, address) public virtual;\\r\\n\\r\\n  function cdpAllow(\\r\\n    uint256,\\r\\n    address,\\r\\n    uint256\\r\\n  ) public virtual;\\r\\n\\r\\n  function urnAllow(address, uint256) public virtual;\\r\\n\\r\\n  function frob(\\r\\n    uint256,\\r\\n    int256,\\r\\n    int256\\r\\n  ) public virtual;\\r\\n\\r\\n  function flux(\\r\\n    uint256,\\r\\n    address,\\r\\n    uint256\\r\\n  ) public virtual;\\r\\n\\r\\n  function move(\\r\\n    uint256,\\r\\n    address,\\r\\n    uint256\\r\\n  ) public virtual;\\r\\n\\r\\n  function exit(\\r\\n    address,\\r\\n    uint256,\\r\\n    address,\\r\\n    uint256\\r\\n  ) public virtual;\\r\\n\\r\\n  function quit(uint256, address) public virtual;\\r\\n\\r\\n  function enter(address, uint256) public virtual;\\r\\n\\r\\n  function shift(uint256, uint256) public virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IVat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nabstract contract IVat {\\r\\n  struct Urn {\\r\\n    uint256 ink; // Locked Collateral  [wad]\\r\\n    uint256 art; // Normalised Debt    [wad]\\r\\n  }\\r\\n\\r\\n  struct Ilk {\\r\\n    uint256 Art; // Total Normalised Debt     [wad]\\r\\n    uint256 rate; // Accumulated Rates         [ray]\\r\\n    uint256 spot; // Price with Safety Margin  [ray]\\r\\n    uint256 line; // Debt Ceiling              [rad]\\r\\n    uint256 dust; // Urn Debt Floor            [rad]\\r\\n  }\\r\\n\\r\\n  mapping(bytes32 => mapping(address => Urn)) public urns;\\r\\n  mapping(bytes32 => Ilk) public ilks;\\r\\n  mapping(bytes32 => mapping(address => uint256)) public gem; // [wad]\\r\\n\\r\\n  function can(address, address) public view virtual returns (uint256);\\r\\n\\r\\n  function dai(address) public view virtual returns (uint256);\\r\\n\\r\\n  function frob(\\r\\n    bytes32,\\r\\n    address,\\r\\n    address,\\r\\n    address,\\r\\n    int256,\\r\\n    int256\\r\\n  ) public virtual;\\r\\n\\r\\n  function hope(address) public virtual;\\r\\n\\r\\n  function move(\\r\\n    address,\\r\\n    address,\\r\\n    uint256\\r\\n  ) public virtual;\\r\\n\\r\\n  function fork(\\r\\n    bytes32,\\r\\n    address,\\r\\n    address,\\r\\n    int256,\\r\\n    int256\\r\\n  ) public virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IJug.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nabstract contract IJug {\\r\\n  struct Ilk {\\r\\n    uint256 duty;\\r\\n    uint256 rho;\\r\\n  }\\r\\n\\r\\n  mapping(bytes32 => Ilk) public ilks;\\r\\n\\r\\n  function drip(bytes32) public virtual returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IDaiJoin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nimport './IVat.sol';\\r\\nimport './IGem.sol';\\r\\n\\r\\nabstract contract IDaiJoin {\\r\\n  function vat() public virtual returns (IVat);\\r\\n\\r\\n  function dai() public virtual returns (IGem);\\r\\n\\r\\n  function join(address, uint256) public payable virtual;\\r\\n\\r\\n  function exit(address, uint256) public virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/exchange/IExchange.sol\": {\r\n      \"content\": \"pragma solidity >=0.7.0;\\r\\n\\r\\nabstract contract IExchange {\\r\\n  function swapDaiForToken(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    uint256 receiveAtLeast,\\r\\n    address callee,\\r\\n    bytes calldata withData\\r\\n  ) external virtual;\\r\\n\\r\\n  function swapTokenForDai(\\r\\n    address asset,\\r\\n    uint256 amount,\\r\\n    uint256 receiveAtLeast,\\r\\n    address callee,\\r\\n    bytes calldata withData\\r\\n  ) external virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/multiply/ExchangeData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity >=0.7.6;\\n\\nstruct ExchangeData {\\n  address fromTokenAddress;\\n  address toTokenAddress;\\n  uint256 fromTokenAmount;\\n  uint256 toTokenAmount;\\n  uint256 minToTokenAmount;\\n  address exchangeAddress;\\n  bytes _exchangeCalldata;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IGem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.0;\\r\\n\\r\\nabstract contract IGem {\\r\\n  function dec() public virtual returns (uint256);\\r\\n\\r\\n  function gem() public virtual returns (IGem);\\r\\n\\r\\n  function join(address, uint256) public payable virtual;\\r\\n\\r\\n  function exit(address, uint256) public virtual;\\r\\n\\r\\n  function approve(address, uint256) public virtual;\\r\\n\\r\\n  function transfer(address, uint256) public virtual returns (bool);\\r\\n\\r\\n  function transferFrom(\\r\\n    address,\\r\\n    address,\\r\\n    uint256\\r\\n  ) public virtual returns (bool);\\r\\n\\r\\n  function deposit() public payable virtual;\\r\\n\\r\\n  function withdraw(uint256) public virtual;\\r\\n\\r\\n  function allowance(address, address) public virtual returns (uint256);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"due\",\"type\":\"uint256\"}],\"name\":\"FLData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapMinAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapOptimistAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralLeft\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiLeft\",\"type\":\"uint256\"}],\"name\":\"MultipleActionCalled\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"DAI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAIJOIN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aaveLendingPoolProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"closeVaultExitCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aaveLendingPoolProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"closeVaultExitDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aaveLendingPoolProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"decreaseMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aaveLendingPoolProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"decreaseMultipleWithdrawCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aaveLendingPoolProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"decreaseMultipleWithdrawDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"premiums\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"executeOperation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aaveLendingPoolProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"increaseMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aaveLendingPoolProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"increaseMultipleDepositCollateral\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aaveLendingPoolProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"increaseMultipleDepositDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCollateral\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"skipFL\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"multiplyProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aaveLendingPoolProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"}],\"internalType\":\"struct AddressRegistry\",\"name\":\"addressRegistry\",\"type\":\"tuple\"}],\"name\":\"openMultiplyVault\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"MultiplyProxyActions","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}