{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.6.0;\r\n\r\ninterface ERC721 {\r\n  function safeTransferFrom(address from,address to,uint256 tokenId) external;\r\n}\r\n\r\ninterface ERC20 {\r\n  function transferFrom(address src, address dst, uint wad)\r\n        external\r\n        returns (bool);\r\n}\r\n\r\n\r\ncontract GolomTrader {\r\n  mapping(bytes32 => bool) public orderhashes; // keep tracks of orderhashes that are filled or cancelled so they cant be filled again \r\n  mapping(bytes32 => bool) public offerhashes; // keep tracks of offerhashes that are filled or cancelled so they cant be filled again \r\n  address payable owner;\r\n  ERC20 wethcontract;\r\n  event Orderfilled(address indexed from,address indexed to, bytes32 indexed id, uint ethAmt,address refferer,uint feeAmt,uint royaltyAmt,address royaltyAddress,bool isPrivate);\r\n  event Offerfilled(address indexed from,address indexed to, bytes32 indexed id, uint ethAmt,uint feeAmt,uint royaltyAmt,address royaltyAddress,bool isAny);\r\n  event Ordercancelled(bytes32 indexed id);\r\n  event Offercancelled(bytes32 indexed id);\r\n\r\n  constructor ()\r\n        public\r\n  {\r\n    owner = payable(msg.sender);\r\n    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    wethcontract = ERC20(WETH);\r\n  }\r\n\r\n/// @notice returns eip712domainhash\r\n    function _eip712DomainHash() internal view returns(bytes32 eip712DomainHash) {\r\n        eip712DomainHash = keccak256(\r\n        abi.encode(\r\n            keccak256(\r\n                \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n            ),\r\n            keccak256(bytes(\"GOLOM.IO\")),\r\n            keccak256(bytes(\"1\")),\r\n            1,\r\n            address(this)\r\n        )\r\n    );  \r\n    }\r\n\r\n\r\n\r\n/// @notice called by buyer of ERC721 nft with a valid signature from seller of nft and sending the correct eth in the transaction\r\n/// @param v,r,s EIP712 type signature of signer/seller\r\n/// @param _addressArgs[4] address arguments array \r\n/// @param _uintArgs[6] uint arguments array\r\n/// @dev addressargs->//0 - tokenAddress,//1 - signer,//2 - royaltyaddress,//3 - reffereraddress\r\n/// @dev uintArgs->//0-tokenId ,//1-amount,//2-deadline,//3-feeamt,//4-salt,//5-royaltyamt\r\n/// @dev ethAmt, amount of ether in wei that the seller gets\r\n/// @dev deadline, deadline till order is valid\r\n/// @dev feeamt fee to be paid to owner of contract\r\n/// @dev signer seller of nft and signer of signature\r\n/// @dev salt salt for uniqueness of the order\r\n/// @dev refferer address that reffered the trade\r\n\r\n  function matchOrder(\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    address[4] calldata _addressArgs,\r\n    uint[6] calldata _uintArgs\r\n  ) external payable {\r\n    require(block.timestamp < _uintArgs[2], \"Signed transaction expired\");\r\n\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchorder(address tokenAddress,uint tokenId,uint ethAmt,uint deadline,uint feeAmt,address signer,uint salt,address royaltyAddress,uint royaltyAmt)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4],\r\n          _addressArgs[2],\r\n          _uintArgs[5]\r\n        )\r\n    );\r\n\r\n    bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", _eip712DomainHash(), hashStruct));\r\n    address signaturesigner = ecrecover(hash, v, r, s);\r\n    require(signaturesigner == _addressArgs[1], \"invalid signature\");\r\n    require(msg.value == _uintArgs[1], \"wrong eth amt\");\r\n    require(orderhashes[hashStruct]==false,\"order filled or cancelled\");\r\n    orderhashes[hashStruct]=true; // prevent reentrency and also doesnt allow any order to be filled more then once\r\n    ERC721 nftcontract = ERC721(_addressArgs[0]);\r\n    nftcontract.safeTransferFrom(_addressArgs[1],msg.sender ,_uintArgs[0]); // transfer \r\n    if (_uintArgs[3]>0){\r\n      owner.transfer(_uintArgs[3]); // fee transfer to owner\r\n    }\r\n    if (_uintArgs[5]>0){ // if royalty has to be paid\r\n     payable(_addressArgs[2]).transfer(_uintArgs[5]); // royalty transfer to royaltyaddress\r\n    }\r\n    payable(_addressArgs[1]).transfer(msg.value-_uintArgs[3]-_uintArgs[5]); // transfer of eth to seller of nft\r\n    emit Orderfilled(_addressArgs[1], msg.sender, hashStruct , _uintArgs[1] , _addressArgs[3] ,_uintArgs[3],_uintArgs[5],_addressArgs[2],false);\r\n  }\r\n\r\n\r\n\r\n\r\n/// @notice invalidates an offchain order signature so it cant be filled by anyone\r\n/// @param _addressArgs[4] address arguments array \r\n/// @param _uintArgs[6] uint arguments array\r\n/// @dev addressargs->//0 - tokenAddress,//1 - signer,//2 - royaltyAddress,//3 - reffereraddress\r\n/// @dev uintArgs->//0-tokenid ,//1-ethAmt,//2-deadline,//3-feeAmt,//4-salt,//5-royaltyAmt\r\n\r\n  function cancelOrder(    \r\n    address[4] calldata _addressArgs,\r\n    uint[6] calldata _uintArgs\r\n) external{\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchorder(address tokenAddress,uint tokenId,uint ethAmt,uint deadline,uint feeAmt,address signer,uint salt,address royaltyAddress,uint royaltyAmt)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4],\r\n          _addressArgs[2],\r\n          _uintArgs[5]\r\n        )\r\n    );        \r\n      orderhashes[hashStruct]=true;  // no need to check for signature validation since sender can only invalidate his own order\r\n      emit Offercancelled(hashStruct);\r\n  }\r\n\r\n\r\n\r\n\r\n/// @notice same as order but only vald for 1 orderfiller address\r\n/// @param v,r,s EIP712 type signature of signer/seller\r\n/// @param _addressArgs[4] address arguments array \r\n/// @param _uintArgs[6] uint arguments array\r\n/// @dev addressargs->//0 - contractaddress,//1 - signer,//2 - royaltyaddress,//3 - reffereraddress// 4 - orderFillerAddress \r\n/// @dev uintArgs->//0-tokenid ,//1-ethamt,//2-deadline,//3-feeamt,//4-salt,//5-royaltyamt\r\n\r\n  function privateMatchOrder\r\n  (\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    address[5] calldata _addressArgs,\r\n    uint[6] calldata _uintArgs\r\n  ) external payable {\r\n    require(block.timestamp < _uintArgs[2], \"Signed transaction expired\");\r\n\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchorder(address tokenAddress,uint tokenId,uint ethAmt,uint deadline,uint feeAmt,address signer,uint salt,address royaltyAddress,uint royaltyAmt,address orderFillerAddress)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4],\r\n          _addressArgs[2],\r\n          _uintArgs[5],\r\n          _addressArgs[4]\r\n        )\r\n    );\r\n\r\n    bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", _eip712DomainHash(), hashStruct));\r\n    address signaturesigner = ecrecover(hash, v, r, s);\r\n    require(msg.sender==_addressArgs[4],\"not fillable by this address\");\r\n    require(signaturesigner == _addressArgs[1], \"invalid signature\");\r\n    require(msg.value == _uintArgs[1], \"wrong eth amt\");\r\n    require(orderhashes[hashStruct]==false,\"order filled or cancelled\");\r\n    orderhashes[hashStruct]=true; // prevent reentrency and also doesnt allow any order to be filled more then once\r\n    ERC721 nftcontract = ERC721(_addressArgs[0]);\r\n    nftcontract.safeTransferFrom(_addressArgs[1],msg.sender ,_uintArgs[0]); // transfer \r\n    if (_uintArgs[3]>0){\r\n      owner.transfer(_uintArgs[3]); // fee transfer to owner\r\n    }\r\n    if (_uintArgs[5]>0){ // if royalty has to be paid\r\n     payable(_addressArgs[2]).transfer(_uintArgs[5]); // royalty transfer to royaltyaddress\r\n    }\r\n    payable(_addressArgs[1]).transfer(msg.value-_uintArgs[3]-_uintArgs[5]); // transfer of eth to seller of nft\r\n    emit Orderfilled(_addressArgs[1], msg.sender, hashStruct , _uintArgs[1] , _addressArgs[3] ,_uintArgs[3],_uintArgs[5],_addressArgs[2],true);\r\n  }\r\n\r\n\r\n\r\n\r\n/// @notice invalidates an offchain order signature so it cant be filled by anyone\r\n/// @param _addressArgs[4] address arguments array \r\n/// @param _uintArgs[6] uint arguments array\r\n/// @dev addressargs->//0 - contractaddress,//1 - signer,//2 - royaltyaddress,//3 - reffereraddress// 4 - orderfiller \r\n/// @dev uintArgs->//0-tokenid ,//1-ethamt,//2-deadline,//3-feeamt,//4-salt,//5-royaltyamt\r\n\r\n  function cancelPrivateOrder(    \r\n    address[5] calldata _addressArgs,\r\n    uint[6] calldata _uintArgs\r\n) external{\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchorder(address tokenAddress,uint tokenId,uint ethAmt,uint deadline,uint feeAmt,address signer,uint salt,address royaltyAddress,uint royaltyAmt,address orderFillerAddress)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4],\r\n          _addressArgs[2],\r\n          _uintArgs[5],\r\n          _addressArgs[4]\r\n        )\r\n    );        \r\n      orderhashes[hashStruct]=true;  // no need to check for signature validation since sender can only invalidate his own order\r\n      emit Offercancelled(hashStruct);\r\n  }\r\n\r\n\r\n\r\n\r\n/// @notice called by seller of ERc721NFT when he sees a signed buy offer of ethamt ETH\r\n/// @param v,r,s EIP712 type signature of signer/seller\r\n/// @param _addressArgs[3] address arguments array \r\n/// @param _uintArgs[6] uint arguments array\r\n/// @dev addressargs->//0 - tokenAddress,//1 - signer,//2 - royaltyaddress\r\n/// @dev uintArgs->//0-tokenId ,//1-ethamt,//2-deadline,//3-feeamt,//4-salt,//5-royaltyamt\r\n\r\n  function matchOffer(\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    address[3] calldata _addressArgs,\r\n    uint[6] calldata _uintArgs\r\n  ) external {\r\n    require(block.timestamp < _uintArgs[2], \"Signed transaction expired\");\r\n\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchoffer(address tokenAddress,uint tokenId,uint ethAmt,uint deadline,uint feeAmt,address signer,uint salt)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4]\r\n        )\r\n    );\r\n\r\n\r\n    bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", _eip712DomainHash(), hashStruct));\r\n    address signaturesigner = ecrecover(hash, v, r, s);\r\n    require(signaturesigner == _addressArgs[1], \"invalid signature\");\r\n    require(offerhashes[hashStruct]==false,\"order filled or cancelled\");\r\n    offerhashes[hashStruct]=true;\r\n    if (_uintArgs[3]>0){\r\n      require(wethcontract.transferFrom(_addressArgs[1], owner , _uintArgs[3]),\"error in weth transfer\");\r\n    }\r\n    if (_uintArgs[5]>0){\r\n      require(wethcontract.transferFrom(_addressArgs[1], _addressArgs[2] , _uintArgs[5]),\"error in weth transfer\");\r\n    }\r\n    require(wethcontract.transferFrom(_addressArgs[1], msg.sender, _uintArgs[1]-_uintArgs[5]-_uintArgs[3]),\"error in weth transfer\");\r\n    ERC721 nftcontract = ERC721(_addressArgs[0]);\r\n    nftcontract.safeTransferFrom(msg.sender,_addressArgs[1] ,_uintArgs[0]);\r\n    emit Offerfilled(_addressArgs[1], msg.sender, hashStruct , _uintArgs[1] ,_uintArgs[3],_uintArgs[5],_addressArgs[2],false);\r\n  }\r\n\r\n\r\n\r\n/// @notice invalidates an offchain offer signature so it cant be filled by anyone\r\n\r\n  function cancelOffer(    \r\n    address[3] calldata _addressArgs,\r\n    uint[6] calldata _uintArgs\r\n) external{\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchoffer(address tokenAddress,uint tokenId,uint ethAmt,uint deadline,uint feeAmt,address signer,uint salt)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4]\r\n        )\r\n    );\r\n\r\n      offerhashes[hashStruct]=true;  \r\n      emit Offercancelled(hashStruct);\r\n  }\r\n\r\n\r\n/// @notice called by seller of ERc721NFT when he sees a signed buy offer, this is for any tokenid of a particular collection(floor buyer)\r\n/// @param v,r,s EIP712 type signature of signer/seller\r\n/// @param _addressArgs[3] address arguments array \r\n/// @param _uintArgs[6] uint arguments array\r\n/// @dev addressargs->//0 - tokenAddress,//1 - signer,//2 - royaltyaddress\r\n/// @dev uintArgs->//0-tokenid ,//1-ethamt,//2-deadline,//3-feeamt,//4-salt,//5-royaltyamt\r\n\r\n  function matchOfferAny(\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    address[3] calldata _addressArgs,\r\n    uint[6] calldata _uintArgs\r\n  ) external {\r\n    require(block.timestamp < _uintArgs[2], \"Signed transaction expired\");\r\n\r\n    // the hash here doesnt take tokenid so allows seller to fill the offer with any token id of the collection (floor buyer)\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchoffer(address tokenAddress,uint ethamt,uint deadline,uint feeAmt,address signer,uint salt)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4]\r\n        )\r\n    );\r\n\r\n\r\n    bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", _eip712DomainHash(), hashStruct));\r\n    address signaturesigner = ecrecover(hash, v, r, s);\r\n    require(signaturesigner == _addressArgs[1], \"invalid signature\");\r\n    require(offerhashes[hashStruct]==false,\"order filled or cancelled\");\r\n    offerhashes[hashStruct]=true;\r\n    if (_uintArgs[3]>0){\r\n      require(wethcontract.transferFrom(_addressArgs[1], owner , _uintArgs[3]),\"error in weth transfer\");\r\n    }\r\n    if (_uintArgs[5]>0){\r\n      require(wethcontract.transferFrom(_addressArgs[1], _addressArgs[2] , _uintArgs[5]),\"error in weth transfer\");\r\n    }\r\n    require(wethcontract.transferFrom(_addressArgs[1], msg.sender, _uintArgs[1]-_uintArgs[5]-_uintArgs[3]),\"error in weth transfer\");\r\n    ERC721 nftcontract = ERC721(_addressArgs[0]);\r\n    nftcontract.safeTransferFrom(msg.sender,_addressArgs[1] ,_uintArgs[0]);\r\n    emit Offerfilled(_addressArgs[1], msg.sender, hashStruct , _uintArgs[1] ,_uintArgs[3],_uintArgs[5],_addressArgs[2],true);\r\n  }\r\n\r\n\r\n/// @notice invalidates an offchain offerany signature so it cant be filled by anyone\r\n  function cancelOfferAny(    \r\n    address[3] calldata _addressArgs,\r\n    uint[6] calldata _uintArgs\r\n) external{\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchoffer(address tokenAddress,uint ethamt,uint deadline,uint feeAmt,address signer,uint salt)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4]\r\n        )\r\n    );\r\n\r\n      offerhashes[hashStruct]=true;  \r\n      emit Offercancelled(hashStruct);\r\n  }\r\n\r\n\r\n///@notice returns Keccak256 hash of an order\r\n  function orderHash(   \r\n    address[4] memory _addressArgs,\r\n    uint[6] memory _uintArgs\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchorder(address tokenAddress,uint tokenId,uint ethAmt,uint deadline,uint feeAmt,address signer,uint salt,address royaltyAddress,uint royaltyAmt)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4],\r\n          _addressArgs[2],\r\n          _uintArgs[5]\r\n        )\r\n    );\r\n    }\r\n\r\n\r\n///@notice returns Keccak256 hash of an order\r\n  function privateOrderHash(   \r\n    address[5] memory _addressArgs,\r\n    uint[6] memory _uintArgs\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchorder(address tokenAddress,uint tokenId,uint ethAmt,uint deadline,uint feeAmt,address signer,uint salt,address royaltyAddress,uint royaltyAmt,address orderFillerAddress)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4],\r\n          _addressArgs[2],\r\n          _uintArgs[5],\r\n          _addressArgs[4]\r\n        )\r\n    );\r\n    }\r\n\r\n\r\n  ///@notice returns Keccak256 hash of an offer\r\n  function offerHash(   \r\n    address[3] memory _addressArgs,\r\n    uint[6] memory _uintArgs\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchoffer(address tokenAddress,uint tokenId,uint ethAmt,uint deadline,uint feeAmt,address signer,uint salt)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4],\r\n          _addressArgs[2],\r\n          _uintArgs[5]\r\n        )\r\n    );\r\n    }\r\n\r\n  ///@notice returns Keccak256 hash of an offerAny\r\n  function offerAnyHash(   \r\n    address[3] memory _addressArgs,\r\n    uint[6] memory _uintArgs\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchoffer(address tokenAddress,uint ethamt,uint deadline,uint feeAmt,address signer,uint salt)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4]\r\n          )\r\n    );\r\n    }\r\n\r\n\r\n// ALREADY FILLED OR CANCELLED - 1\r\n// deadline PASSED- 2  EXPIRED\r\n// sign INVALID - 0\r\n// VALID - 3\r\n/// @notice returns status of an order\r\n/// @param v,r,s EIP712 type signature of signer/seller\r\n/// @param _addressArgs[4] address arguments array \r\n/// @param _uintArgs[6] uint arguments array\r\n/// @dev addressargs->//0 - contractaddress,//1 - signer,//2 - royaltyaddress,//3 - reffereraddress\r\n/// @dev uintArgs->//0-tokenid ,//1-ethamt,//2-deadline,//3-feeamt,//4-salt,//5-royaltyamt\r\n\r\n  function orderStatus(\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    address[4] memory _addressArgs,\r\n    uint[6] memory _uintArgs\r\n  ) public view returns (uint256) {\r\n    if (block.timestamp > _uintArgs[2]){\r\n      return 2;\r\n    }\r\n\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchorder(address tokenAddress,uint tokenId,uint ethAmt,uint deadline,uint feeAmt,address signer,uint salt,address royaltyAddress,uint royaltyAmt)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4],\r\n          _addressArgs[2],\r\n          _uintArgs[5]\r\n        )\r\n    );\r\n\r\n    bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", _eip712DomainHash(), hashStruct));\r\n    address signaturesigner = ecrecover(hash, v, r, s);\r\n\r\n    if (signaturesigner != _addressArgs[1]){\r\n      return 0;\r\n    }\r\n    if (orderhashes[hashStruct]==true){\r\n      return 1;\r\n    }\r\n\r\n    return 3;\r\n\r\n  }\r\n\r\n\r\n// ALREADY FILLED OR CANCELLED - 1\r\n// deadline PASSED- 2  EXPIRED\r\n// sign INVALID - 0\r\n// VALID - 3\r\n\r\n  function privateOrderStatus(\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    address[5] memory _addressArgs,\r\n    uint[6] memory _uintArgs\r\n  ) public view returns (uint256) {\r\n    if (block.timestamp > _uintArgs[2]){\r\n      return 2;\r\n    }\r\n\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchorder(address tokenAddress,uint tokenId,uint ethAmt,uint deadline,uint feeAmt,address signer,uint salt,address royaltyAddress,uint royaltyAmt,address orderFillerAddress)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4],\r\n          _addressArgs[2],\r\n          _uintArgs[5],\r\n          _addressArgs[4]\r\n        )\r\n    );\r\n\r\n    bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", _eip712DomainHash(), hashStruct));\r\n    address signaturesigner = ecrecover(hash, v, r, s);\r\n\r\n    if (signaturesigner != _addressArgs[1]){\r\n      return 0;\r\n    }\r\n    if (orderhashes[hashStruct]==true){\r\n      return 1;\r\n    }\r\n\r\n    return 3;\r\n\r\n  }\r\n\r\n\r\n// ALREADY FILLED OR CANCELLED - 1\r\n// deadline PASSED- 2  EXPIRED\r\n// sign INVALID - 0\r\n// VALID - 3\r\n/// @notice returns status of an order\r\n\r\n  function offerStatus(\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    address[3] memory _addressArgs,\r\n    uint[6] memory _uintArgs\r\n  ) public view returns (uint256) {\r\n    if (block.timestamp > _uintArgs[2]){\r\n      return 2;\r\n    }\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchoffer(address tokenAddress,uint tokenId,uint ethAmt,uint deadline,uint feeAmt,address signer,uint salt)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4]\r\n        )\r\n    );\r\n\r\n    bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", _eip712DomainHash(), hashStruct));\r\n    address signaturesigner = ecrecover(hash, v, r, s);\r\n\r\n    if (signaturesigner != _addressArgs[1]){\r\n      return 0;\r\n    }\r\n    if (offerhashes[hashStruct]==true){\r\n      return 1;\r\n    }\r\n    return 3;\r\n\r\n  }\r\n\r\n  // ALREADY FILLED OR CANCELLED - 1\r\n// deadline PASSED- 2  EXPIRED\r\n// sign INVALID - 0\r\n// VALID - 3\r\n/// @notice returns status of an order\r\n\r\n  function offerAnyStatus(\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    address[3] memory _addressArgs,\r\n    uint[6] memory _uintArgs\r\n  ) public view returns (uint256) {\r\n    if (block.timestamp > _uintArgs[2]){\r\n      return 2;\r\n    }\r\n    bytes32 hashStruct = keccak256(\r\n      abi.encode(\r\n          keccak256(\"matchoffer(address tokenAddress,uint ethamt,uint deadline,uint feeAmt,address signer,uint salt)\"),\r\n          _addressArgs[0],\r\n          _uintArgs[1],\r\n          _uintArgs[2],\r\n          _uintArgs[3],\r\n          _addressArgs[1],\r\n          _uintArgs[4]\r\n        )\r\n    );\r\n\r\n    bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", _eip712DomainHash(), hashStruct));\r\n    address signaturesigner = ecrecover(hash, v, r, s);\r\n\r\n    if (signaturesigner != _addressArgs[1]){\r\n      return 0;\r\n    }\r\n    if (offerhashes[hashStruct]==true){\r\n      return 1;\r\n    }\r\n    return 3;\r\n\r\n  }\r\n\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"Offercancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royaltyAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"royaltyAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAny\",\"type\":\"bool\"}],\"name\":\"Offerfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"Ordercancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"refferer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royaltyAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"royaltyAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPrivate\",\"type\":\"bool\"}],\"name\":\"Orderfilled\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[3]\",\"name\":\"_addressArgs\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"cancelOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[3]\",\"name\":\"_addressArgs\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"cancelOfferAny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[4]\",\"name\":\"_addressArgs\",\"type\":\"address[4]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[5]\",\"name\":\"_addressArgs\",\"type\":\"address[5]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"cancelPrivateOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address[3]\",\"name\":\"_addressArgs\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"matchOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address[3]\",\"name\":\"_addressArgs\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"matchOfferAny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address[4]\",\"name\":\"_addressArgs\",\"type\":\"address[4]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"matchOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[3]\",\"name\":\"_addressArgs\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"offerAnyHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address[3]\",\"name\":\"_addressArgs\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"offerAnyStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[3]\",\"name\":\"_addressArgs\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"offerHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address[3]\",\"name\":\"_addressArgs\",\"type\":\"address[3]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"offerStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"offerhashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[4]\",\"name\":\"_addressArgs\",\"type\":\"address[4]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"orderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address[4]\",\"name\":\"_addressArgs\",\"type\":\"address[4]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"orderStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderhashes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address[5]\",\"name\":\"_addressArgs\",\"type\":\"address[5]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"privateMatchOrder\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[5]\",\"name\":\"_addressArgs\",\"type\":\"address[5]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"privateOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"address[5]\",\"name\":\"_addressArgs\",\"type\":\"address[5]\"},{\"internalType\":\"uint256[6]\",\"name\":\"_uintArgs\",\"type\":\"uint256[6]\"}],\"name\":\"privateOrderStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"GolomTrader","CompilerVersion":"v0.6.0+commit.26b70077","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8bf895b8fc7edebffca788cf0e39d7ea0239fe70e511f73e7bb3139d2a630083"}]}