{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.8.6;\r\n\r\n\r\nlibrary SafeCast {\r\n    /**\r\n     * @dev Returns the downcasted uint224 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint224).\r\n     *\r\n     * Counterpart to Solidity's `uint224` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 224 bits\r\n     */\r\n    function toUint224(uint256 value) internal pure returns (uint224) {\r\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\r\n        return uint224(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint96 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint96).\r\n     *\r\n     * Counterpart to Solidity's `uint96` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 96 bits\r\n     */\r\n    function toUint96(uint256 value) internal pure returns (uint96) {\r\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\r\n        return uint96(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\r\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\ninterface IGovernanceHook {\r\n    function moveVotingPowerHook(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IRewardsDistributionRecipient {\r\n    function notifyRewardAmount(uint256 reward) external;\r\n\r\n    function getRewardToken() external view returns (IERC20);\r\n}\r\n\r\ninterface IVotes {\r\n    function getVotes(address account) external view returns (uint256);\r\n}\r\n\r\ncontract ModuleKeys {\r\n    // Governance\r\n    // ===========\r\n    // keccak256(\"Governance\");\r\n    bytes32 internal constant KEY_GOVERNANCE =\r\n        0x9409903de1e6fd852dfc61c9dacb48196c48535b60e25abf92acc92dd689078d;\r\n    //keccak256(\"Staking\");\r\n    bytes32 internal constant KEY_STAKING =\r\n        0x1df41cd916959d1163dc8f0671a666ea8a3e434c13e40faef527133b5d167034;\r\n    //keccak256(\"ProxyAdmin\");\r\n    bytes32 internal constant KEY_PROXY_ADMIN =\r\n        0x96ed0203eb7e975a4cbcaa23951943fa35c5d8288117d50c12b3d48b0fab48d1;\r\n\r\n    // mStable\r\n    // =======\r\n    // keccak256(\"OracleHub\");\r\n    bytes32 internal constant KEY_ORACLE_HUB =\r\n        0x8ae3a082c61a7379e2280f3356a5131507d9829d222d853bfa7c9fe1200dd040;\r\n    // keccak256(\"Manager\");\r\n    bytes32 internal constant KEY_MANAGER =\r\n        0x6d439300980e333f0256d64be2c9f67e86f4493ce25f82498d6db7f4be3d9e6f;\r\n    //keccak256(\"Recollateraliser\");\r\n    bytes32 internal constant KEY_RECOLLATERALISER =\r\n        0x39e3ed1fc335ce346a8cbe3e64dd525cf22b37f1e2104a755e761c3c1eb4734f;\r\n    //keccak256(\"MetaToken\");\r\n    bytes32 internal constant KEY_META_TOKEN =\r\n        0xea7469b14936af748ee93c53b2fe510b9928edbdccac3963321efca7eb1a57a2;\r\n    // keccak256(\"SavingsManager\");\r\n    bytes32 internal constant KEY_SAVINGS_MANAGER =\r\n        0x12fe936c77a1e196473c4314f3bed8eeac1d757b319abb85bdda70df35511bf1;\r\n    // keccak256(\"Liquidator\");\r\n    bytes32 internal constant KEY_LIQUIDATOR =\r\n        0x1e9cb14d7560734a61fa5ff9273953e971ff3cd9283c03d8346e3264617933d4;\r\n    // keccak256(\"InterestValidator\");\r\n    bytes32 internal constant KEY_INTEREST_VALIDATOR =\r\n        0xc10a28f028c7f7282a03c90608e38a4a646e136e614e4b07d119280c5f7f839f;\r\n    // keccak256(\"Keeper\");\r\n    bytes32 internal constant KEY_KEEPER =\r\n        0x4f78afe9dfc9a0cb0441c27b9405070cd2a48b490636a7bdd09f355e33a5d7de;\r\n}\r\n\r\ninterface INexus {\r\n    function governor() external view returns (address);\r\n\r\n    function getModule(bytes32 key) external view returns (address);\r\n\r\n    function proposeModule(bytes32 _key, address _addr) external;\r\n\r\n    function cancelProposedModule(bytes32 _key) external;\r\n\r\n    function acceptProposedModule(bytes32 _key) external;\r\n\r\n    function acceptProposedModules(bytes32[] calldata _keys) external;\r\n\r\n    function requestLockModule(bytes32 _key) external;\r\n\r\n    function cancelLockModule(bytes32 _key) external;\r\n\r\n    function lockModule(bytes32 _key) external;\r\n}\r\n\r\nabstract contract ImmutableModule is ModuleKeys {\r\n    INexus public immutable nexus;\r\n\r\n    /**\r\n     * @dev Initialization function for upgradable proxy contracts\r\n     * @param _nexus Nexus contract address\r\n     */\r\n    constructor(address _nexus) {\r\n        require(_nexus != address(0), \"Nexus address is zero\");\r\n        nexus = INexus(_nexus);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Governor.\r\n     */\r\n    modifier onlyGovernor() {\r\n        _onlyGovernor();\r\n        _;\r\n    }\r\n\r\n    function _onlyGovernor() internal view {\r\n        require(msg.sender == _governor(), \"Only governor can execute\");\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Governor or the Keeper EOA.\r\n     */\r\n    modifier onlyKeeperOrGovernor() {\r\n        _keeperOrGovernor();\r\n        _;\r\n    }\r\n\r\n    function _keeperOrGovernor() internal view {\r\n        require(msg.sender == _keeper() || msg.sender == _governor(), \"Only keeper or governor\");\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Governance.\r\n     *      Governance is either Governor address or Governance address.\r\n     */\r\n    modifier onlyGovernance() {\r\n        require(\r\n            msg.sender == _governor() || msg.sender == _governance(),\r\n            \"Only governance can execute\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns Governor address from the Nexus\r\n     * @return Address of Governor Contract\r\n     */\r\n    function _governor() internal view returns (address) {\r\n        return nexus.governor();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns Governance Module address from the Nexus\r\n     * @return Address of the Governance (Phase 2)\r\n     */\r\n    function _governance() internal view returns (address) {\r\n        return nexus.getModule(KEY_GOVERNANCE);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Keeper address from the Nexus.\r\n     *      This account is used for operational transactions that\r\n     *      don't need multiple signatures.\r\n     * @return  Address of the Keeper externally owned account.\r\n     */\r\n    function _keeper() internal view returns (address) {\r\n        return nexus.getModule(KEY_KEEPER);\r\n    }\r\n\r\n    /**\r\n     * @dev Return SavingsManager Module address from the Nexus\r\n     * @return Address of the SavingsManager Module contract\r\n     */\r\n    function _savingsManager() internal view returns (address) {\r\n        return nexus.getModule(KEY_SAVINGS_MANAGER);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Recollateraliser Module address from the Nexus\r\n     * @return  Address of the Recollateraliser Module contract (Phase 2)\r\n     */\r\n    function _recollateraliser() internal view returns (address) {\r\n        return nexus.getModule(KEY_RECOLLATERALISER);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Liquidator Module address from the Nexus\r\n     * @return  Address of the Liquidator Module contract\r\n     */\r\n    function _liquidator() internal view returns (address) {\r\n        return nexus.getModule(KEY_LIQUIDATOR);\r\n    }\r\n\r\n    /**\r\n     * @dev Return ProxyAdmin Module address from the Nexus\r\n     * @return Address of the ProxyAdmin Module contract\r\n     */\r\n    function _proxyAdmin() internal view returns (address) {\r\n        return nexus.getModule(KEY_PROXY_ADMIN);\r\n    }\r\n}\r\n\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-or-later\r\nstruct HistoricVotes {\r\n    // Number of votes directed to this dial\r\n    uint128 votes;\r\n    // The start of the distribution period in seconds divided by 604,800 seconds in a week\r\n    uint32 epoch;\r\n}\r\n\r\nstruct DialData {\r\n    // If true, no rewards are distributed to the dial recipient and any votes on this dial are ignored\r\n    bool disabled;\r\n    // If true, `notifyRewardAmount` on the recipient contract is called\r\n    bool notify;\r\n    // Cap on distribution % where 1% = 1\r\n    uint8 cap;\r\n    // Dial rewards that are waiting to be distributed to recipient\r\n    uint96 balance;\r\n    // Account rewards are distributed to\r\n    address recipient;\r\n    // List of weighted votes in each distribution period\r\n    HistoricVotes[] voteHistory;\r\n}\r\n\r\nstruct Preference {\r\n    // ID of the dial (array position)\r\n    uint256 dialId;\r\n    // % weight applied to this dial, where 200 = 100% and 1 = 0.5%\r\n    uint256 weight;\r\n}\r\n\r\nstruct VoterPreferences {\r\n    // A array of 16 Preferences, which contain a dialId and weight of 8 bits each.\r\n    // That's 16 bits per item, which is 16 * 16 = 256 bits = 1 slot.\r\n    // The first item, index 0, is right ended.\r\n    // Each item is a dialId and weight.\r\n    // The array is stored as a uint256\r\n    uint256 dialWeights;\r\n    // Total voting power cast by this voter across the staking contracts.\r\n    uint128 votesCast;\r\n    // Last time balance was looked up across all staking contracts\r\n    uint32 lastSourcePoke;\r\n}\r\n\r\nstruct TopLevelConfig {\r\n    int256 A;\r\n    int256 B;\r\n    int256 C;\r\n    int256 D;\r\n    uint128 EPOCHS;\r\n}\r\n\r\nstruct EpochHistory {\r\n    // First weekly epoch of this contract.\r\n    uint32 startEpoch;\r\n    // The last weekly epoch to have rewards distributed.\r\n    uint32 lastEpoch;\r\n}\r\n\r\n/**\r\n * @title  EmissionsController\r\n * @author mStable\r\n * @notice Allows governors to vote on the weekly distribution of $MTA. Rewards are distributed between\r\n *         `n` \"Dials\" proportionately to the % of votes the dial receives. Vote weight derives from multiple\r\n *         whitelisted \"Staking contracts\". Voters can distribute their vote across (0 <= n <= 16 dials), at 0.5%\r\n *         increments in voting weight. Once their preferences are cast, each time their voting weight changes\r\n *         it is reflected here through a hook.\r\n * @dev    VERSION: 1.0\r\n *         DATE:    2021-10-28\r\n */\r\ncontract EmissionsController is IGovernanceHook, Initializable, ImmutableModule {\r\n    using SafeERC20 for IERC20;\r\n\r\n    /// @notice Minimum time between distributions.\r\n    uint32 constant DISTRIBUTION_PERIOD = 1 weeks;\r\n    /// @notice Scale of dial weights. 200 = 100%, 2 = 1%, 1 = 0.5%\r\n    uint256 constant SCALE = 200;\r\n    /// @notice Polynomial top level emission function parameters\r\n    int256 immutable A;\r\n    int256 immutable B;\r\n    int256 immutable C;\r\n    int256 immutable D;\r\n    uint128 immutable EPOCHS;\r\n\r\n    /// @notice Address of rewards token. ie MTA token\r\n    IERC20 public immutable REWARD_TOKEN;\r\n\r\n    /// @notice Epoch history in storage\r\n    ///         An epoch is the number of weeks since 1 Jan 1970. The week starts on Thursday 00:00 UTC.\r\n    ///         epoch = start of the distribution period in seconds divided by 604,800 seconds in a week\r\n    EpochHistory public epochs;\r\n\r\n    /// @notice Flags the timestamp that a given staking contract was added\r\n    mapping(address => uint32) public stakingContractAddTime;\r\n    /// @notice List of staking contract addresses.\r\n    IVotes[] public stakingContracts;\r\n\r\n    /// @notice List of dial data including votes, rewards balance, recipient contract and disabled flag.\r\n    DialData[] public dials;\r\n\r\n    /// @notice Mapping of staker addresses to an list of voter dial weights.\r\n    /// @dev    The sum of the weights for each staker must not be greater than SCALE = 200.\r\n    ///         A user can issue a subset of their voting power. eg only 20% of their voting power.\r\n    ///         A user can not issue more than 100% of their voting power across dials.\r\n    mapping(address => VoterPreferences) public voterPreferences;\r\n\r\n    event AddedDial(uint256 indexed dialId, address indexed recipient);\r\n    event UpdatedDial(uint256 indexed dialId, bool disabled, bool _notify);\r\n    event AddStakingContract(address indexed stakingContract);\r\n\r\n    event PeriodRewards(uint256[] amounts);\r\n    event DonatedRewards(uint256 indexed dialId, uint256 amount);\r\n    event DistributedReward(uint256 indexed dialId, uint256 amount);\r\n\r\n    event PreferencesChanged(address indexed voter, Preference[] preferences);\r\n    event VotesCast(\r\n        address stakingContract,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n    event SourcesPoked(address indexed voter, uint256 newVotesCast);\r\n\r\n    /***************************************\r\n                    INIT\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Recipient is a module, governed by mStable governance.\r\n     * @param _nexus        System Nexus that resolves module addresses.\r\n     * @param _rewardToken  Token that rewards are distributed in. eg MTA.\r\n     * @param _config       Arguments for polynomial top level emission function (raw, not scaled).\r\n     */\r\n    constructor(\r\n        address _nexus,\r\n        address _rewardToken,\r\n        TopLevelConfig memory _config\r\n    ) ImmutableModule(_nexus) {\r\n        require(_rewardToken != address(0), \"Reward token address is zero\");\r\n        REWARD_TOKEN = IERC20(_rewardToken);\r\n        A = _config.A * 1e3;\r\n        B = _config.B * 1e3;\r\n        C = _config.C * 1e3;\r\n        D = _config.D * 1e3;\r\n        EPOCHS = _config.EPOCHS;\r\n    }\r\n\r\n    /**\r\n     * @dev Initialisation function to configure the first dials. All recipient contracts with _notifies = true need to\r\n     *      implement the `IRewardsDistributionRecipient` interface.\r\n     * @param _recipients        List of dial contract addresses that can receive rewards.\r\n     * @param _caps              Limit on the percentage of the weekly top line emission the corresponding dial can receive (where 10% = 10 and uncapped = 0).\r\n     * @param _notifies          If true, `notifyRewardAmount` is called in the `distributeRewards` function.\r\n     * @param _stakingContracts  Initial staking contracts used for voting power lookup.\r\n     */\r\n    function initialize(\r\n        address[] memory _recipients,\r\n        uint8[] memory _caps,\r\n        bool[] memory _notifies,\r\n        address[] memory _stakingContracts\r\n    ) external initializer {\r\n        uint256 len = _recipients.length;\r\n        require(_notifies.length == len && _caps.length == len, \"Initialize args mismatch\");\r\n\r\n        // 1.0 - Set the last epoch storage variable to the immutable start epoch\r\n        //       Set the weekly epoch this contract starts distributions which will be 1 - 2 week after deployment.\r\n        uint32 startEpoch = _epoch(block.timestamp) + 1;\r\n        epochs = EpochHistory({ startEpoch: startEpoch, lastEpoch: startEpoch });\r\n\r\n        // 2.0 - Add each of the dials\r\n        for (uint256 i = 0; i < len; i++) {\r\n            _addDial(_recipients[i], _caps[i], _notifies[i]);\r\n        }\r\n\r\n        // 3.0 - Initialize the staking contracts\r\n        for (uint256 i = 0; i < _stakingContracts.length; i++) {\r\n            _addStakingContract(_stakingContracts[i]);\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                    VIEW\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Gets the users aggregate voting power across all voting contracts.\r\n     * @dev    Voting power can be from staking or it could be delegated to the account.\r\n     * @param account       For which to fetch voting power.\r\n     * @return votingPower  Units of voting power owned by account.\r\n     */\r\n    function getVotes(address account) public view returns (uint256 votingPower) {\r\n        // For each configured staking contract\r\n        for (uint256 i = 0; i < stakingContracts.length; i++) {\r\n            votingPower += stakingContracts[i].getVotes(account);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates top line distribution amount for the current epoch as per the polynomial.\r\n     *          (f(x)=A*(x/div)^3+B*(x/div)^2+C*(x/div)+D)\r\n     * @dev    Values are effectively scaled to 1e12 to avoid integer overflow on pow.\r\n     * @param epoch              The number of weeks since 1 Jan 1970.\r\n     * @return emissionForEpoch  Units of MTA to be distributed at this epoch.\r\n     */\r\n    function topLineEmission(uint32 epoch) public view returns (uint256 emissionForEpoch) {\r\n        require(\r\n            epochs.startEpoch < epoch && epoch <= epochs.startEpoch + 312,\r\n            \"Wrong epoch number\"\r\n        );\r\n        // e.g. week 1, A = -166000e12, B = 168479942061125e3, C = -168479942061125e3, D = 166000e12\r\n        // e.g. epochDelta = 1\r\n        uint128 epochDelta = (epoch - epochs.startEpoch);\r\n        // e.g. x = 1e12 / 312 = 3205128205\r\n        int256 x = SafeCast.toInt256((epochDelta * 1e12) / EPOCHS);\r\n        emissionForEpoch =\r\n            SafeCast.toUint256(\r\n                ((A * (x**3)) / 1e36) + // e.g. -166000e12         * (3205128205 ^ 3) / 1e36 = -5465681315\r\n                    ((B * (x**2)) / 1e24) + // e.g.  168479942061125e3 * (3205128205 ^ 2) / 1e24 =  1730768635433\r\n                    ((C * (x)) / 1e12) + // e.g. -168479942061125e3 *  3205128205      / 1e12 = -539999814276877\r\n                    D // e.g.  166000e12\r\n            ) *\r\n            1e6; // e.g. SUM = 165461725488677241 * 1e6 = 165461e18\r\n    }\r\n\r\n    /**\r\n     * @notice Gets a dial's recipient address.\r\n     * @param dialId      Dial identifier starting from 0.\r\n     * @return recipient  Address of the recipient account associated with.\r\n     */\r\n    function getDialRecipient(uint256 dialId) public view returns (address recipient) {\r\n        recipient = dials[dialId].recipient;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets a dial's weighted votes for each distribution period.\r\n     * @param dialId        Dial identifier starting from 0.\r\n     * @return voteHistory  List of weighted votes with the first distribution at index 0.\r\n     */\r\n    function getDialVoteHistory(uint256 dialId)\r\n        public\r\n        view\r\n        returns (HistoricVotes[] memory voteHistory)\r\n    {\r\n        voteHistory = dials[dialId].voteHistory;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the latest weighted votes for each dial.\r\n     *         This will include disabled dials and their current weighted votes.\r\n     * @return dialVotes A list of dial weighted votes. The index of the array is the dialId.\r\n     */\r\n    function getDialVotes() public view returns (uint256[] memory dialVotes) {\r\n        uint256 dialLen = dials.length;\r\n        dialVotes = new uint256[](dialLen);\r\n\r\n        for (uint256 i = 0; i < dialLen; i++) {\r\n            DialData memory dialData = dials[i];\r\n\r\n            uint256 voteHistoryLen = dialData.voteHistory.length;\r\n\r\n            // If no distributions for this dial yet\r\n            if (voteHistoryLen == 0) {\r\n                continue;\r\n            }\r\n\r\n            dialVotes[i] = dialData.voteHistory[voteHistoryLen - 1].votes;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Gets a voter's weights for each dial.\r\n     * @dev    A dial identifier of 255 marks the end  of the array. It should be ignored.\r\n     * @param voter         Address of the voter that has set weights.\r\n     * @return preferences  List of dial identifiers and weights where a weight of 100% = 200.\r\n     */\r\n    function getVoterPreferences(address voter)\r\n        public\r\n        view\r\n        returns (Preference[16] memory preferences)\r\n    {\r\n        for (uint256 i = 0; i < 16; i++) {\r\n            preferences[i].weight = uint8(voterPreferences[voter].dialWeights >> (i * 16));\r\n            preferences[i].dialId = uint8(voterPreferences[voter].dialWeights >> ((i * 16) + 8));\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                    ADMIN\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Adds a new dial that can be voted on to receive weekly rewards. Callable by system governor.\r\n     * @param _recipient  Address of the contract that will receive rewards.\r\n     * @param _cap        Cap where 0 = uncapped and 10 = 10%.\r\n     * @param _notify     If true, `notifyRewardAmount` is called in the `distributeRewards` function.\r\n     */\r\n    function addDial(\r\n        address _recipient,\r\n        uint8 _cap,\r\n        bool _notify\r\n    ) external onlyGovernor {\r\n        _addDial(_recipient, _cap, _notify);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal dial addition fn, see parent fn for details.\r\n     */\r\n    function _addDial(\r\n        address _recipient,\r\n        uint8 _cap,\r\n        bool _notify\r\n    ) internal {\r\n        require(_recipient != address(0), \"Dial address is zero\");\r\n        require(_cap < 100, \"Invalid cap\");\r\n\r\n        uint256 len = dials.length;\r\n        require(len < 254, \"Max dial count reached\");\r\n        for (uint256 i = 0; i < len; i++) {\r\n            require(dials[i].recipient != _recipient, \"Dial already exists\");\r\n        }\r\n\r\n        dials.push();\r\n        DialData storage newDialData = dials[len];\r\n        newDialData.recipient = _recipient;\r\n        newDialData.notify = _notify;\r\n        newDialData.cap = _cap;\r\n        uint32 currentEpoch = _epoch(block.timestamp);\r\n        if (currentEpoch < epochs.startEpoch) {\r\n            currentEpoch = epochs.startEpoch;\r\n        }\r\n        newDialData.voteHistory.push(HistoricVotes({ votes: 0, epoch: currentEpoch }));\r\n\r\n        emit AddedDial(len, _recipient);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates a dials recipient contract and/or disabled flag.\r\n     * @param _dialId    Dial identifier which is the index of the dials array.\r\n     * @param _disabled  If true, no rewards will be distributed to this dial.\r\n     * @param _notify  If true, `notifyRewardAmount` is called on the dial recipient contract.\r\n     */\r\n    function updateDial(uint256 _dialId, bool _disabled, bool _notify) external onlyGovernor {\r\n        require(_dialId < dials.length, \"Invalid dial id\");\r\n\r\n        dials[_dialId].disabled = _disabled;\r\n        dials[_dialId].notify = _notify;\r\n\r\n        emit UpdatedDial(_dialId, _disabled, _notify);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a new contract to the list of approved staking contracts.\r\n     * @param _stakingContract Address of the new staking contract\r\n     */\r\n    function addStakingContract(address _stakingContract) external onlyGovernor {\r\n        _addStakingContract(_stakingContract);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a staking contract by setting it's addition time to current timestamp.\r\n     */\r\n    function _addStakingContract(address _stakingContract) internal {\r\n        require(_stakingContract != address(0), \"Staking contract address is zero\");\r\n\r\n        uint256 len = stakingContracts.length;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            require(\r\n                address(stakingContracts[i]) != _stakingContract,\r\n                \"StakingContract already exists\"\r\n            );\r\n        }\r\n\r\n        stakingContractAddTime[_stakingContract] = SafeCast.toUint32(block.timestamp);\r\n        stakingContracts.push(IVotes(_stakingContract));\r\n\r\n        emit AddStakingContract(_stakingContract);\r\n    }\r\n\r\n    /***************************************\r\n                REWARDS-EXTERNAL\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Allows arbitrary reward donation to a dial on top of the weekly rewards.\r\n     * @param _dialIds  Dial identifiers that will receive donated rewards.\r\n     * @param _amounts  Units of rewards to be sent to each dial including decimals.\r\n     */\r\n    function donate(uint256[] memory _dialIds, uint256[] memory _amounts) external {\r\n        uint256 dialLen = _dialIds.length;\r\n        require(dialLen > 0 && _amounts.length == dialLen, \"Invalid inputs\");\r\n\r\n        uint256 totalAmount;\r\n\r\n        // For each specified dial\r\n        uint256 dialId;\r\n        for (uint256 i = 0; i < dialLen; i++) {\r\n            dialId = _dialIds[i];\r\n            require(dialId < dials.length, \"Invalid dial id\");\r\n\r\n            // Sum the rewards for each dial\r\n            totalAmount += _amounts[i];\r\n            // Add rewards to the dial's rewards balance\r\n            dials[dialId].balance += SafeCast.toUint96(_amounts[i]);\r\n\r\n            emit DonatedRewards(dialId, _amounts[i]);\r\n        }\r\n\r\n        // Transfer the total donated rewards to this Emissions Controller contract\r\n        REWARD_TOKEN.safeTransferFrom(msg.sender, address(this), totalAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the rewards to be distributed to each dial for the next weekly period.\r\n     * @dev    Callable once an epoch has fully passed. Top level emission for the epoch is distributed\r\n     *         proportionately to vote count with the following exceptions:\r\n     *          - Disabled dials are ignored and votes not counted.\r\n     *          - Dials with a cap are capped and their votes/emission removed (effectively redistributing rewards).\r\n     */\r\n    function calculateRewards() external {\r\n        // 1 - Calculate amount of rewards to distribute this week\r\n        uint32 epoch = _epoch(block.timestamp);\r\n        require(epoch > epochs.lastEpoch, \"Must wait for new period\");\r\n        //     Update storage with new last epoch\r\n        epochs.lastEpoch = epoch;\r\n        uint256 emissionForEpoch = topLineEmission(epoch);\r\n\r\n        // 2.0 - Calculate the total amount of dial votes ignoring any disabled dials\r\n        uint256 totalDialVotes;\r\n        uint256 dialLen = dials.length;\r\n        uint256[] memory dialVotes = new uint256[](dialLen);\r\n        for (uint256 i = 0; i < dialLen; i++) {\r\n            DialData memory dialData = dials[i];\r\n            if (dialData.disabled) continue;\r\n\r\n            // Get the relevant votes for the dial. Possibilities:\r\n            //   - No new votes cast in period, therefore relevant votes are at pos len - 1\r\n            //   - Votes already cast in period, therefore relevant is at pos len - 2\r\n            uint256 end = dialData.voteHistory.length - 1;\r\n            HistoricVotes memory latestVote = dialData.voteHistory[end];\r\n            if (latestVote.epoch < epoch) {\r\n                dialVotes[i] = latestVote.votes;\r\n                totalDialVotes += latestVote.votes;\r\n                // Create a new weighted votes for the current distribution period\r\n                dials[i].voteHistory.push(\r\n                    HistoricVotes({ votes: latestVote.votes, epoch: SafeCast.toUint32(epoch) })\r\n                );\r\n            } else if (latestVote.epoch == epoch && end > 0) {\r\n                uint256 votes = dialData.voteHistory[end - 1].votes;\r\n                dialVotes[i] = votes;\r\n                totalDialVotes += votes;\r\n            }\r\n        }\r\n\r\n        // 3.0 - Deal with the capped dials\r\n        uint256[] memory distributionAmounts = new uint256[](dialLen);\r\n        uint256 postCappedVotes = totalDialVotes;\r\n        uint256 postCappedEmission = emissionForEpoch;\r\n        for (uint256 k = 0; k < dialLen; k++) {\r\n            DialData memory dialData = dials[k];\r\n            // 3.1 - If the dial has a cap and isn't disabled, check if it's over the threshold\r\n            if (dialData.cap > 0 && !dialData.disabled) {\r\n                uint256 maxVotes = (dialData.cap * totalDialVotes) / 100;\r\n                // If dial has move votes than its cap\r\n                if (dialVotes[k] > maxVotes) {\r\n                    // Calculate amount of rewards for the dial\r\n                    distributionAmounts[k] = (dialData.cap * emissionForEpoch) / 100;\r\n                    // Add dial rewards to balance in storage.\r\n                    // Is addition and not set as rewards could have been donated.\r\n                    dials[k].balance += SafeCast.toUint96(distributionAmounts[k]);\r\n\r\n                    // Remove dial votes from total votes\r\n                    postCappedVotes -= dialVotes[k];\r\n                    // Remove capped rewards from total reward\r\n                    postCappedEmission -= distributionAmounts[k];\r\n                    // Set to zero votes so it'll be skipped in the next loop\r\n                    dialVotes[k] = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        // 4.0 - Calculate the distribution amounts for each dial\r\n        for (uint256 l = 0; l < dialLen; l++) {\r\n            // Skip dial if no votes, disabled or was over cap\r\n            if (dialVotes[l] == 0) {\r\n                continue;\r\n            }\r\n\r\n            // Calculate amount of rewards for the dial & set storage\r\n            distributionAmounts[l] = (dialVotes[l] * postCappedEmission) / postCappedVotes;\r\n            dials[l].balance += SafeCast.toUint96(distributionAmounts[l]);\r\n        }\r\n\r\n        emit PeriodRewards(distributionAmounts);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers all accrued rewards to dials and notifies them of the amount.\r\n     * @param _dialIds  Dial identifiers for which to distribute rewards.\r\n     */\r\n    function distributeRewards(uint256[] memory _dialIds) external {\r\n        // For each specified dial\r\n        uint256 len = _dialIds.length;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            require(_dialIds[i] < dials.length, \"Invalid dial id\");\r\n            DialData memory dialData = dials[_dialIds[i]];\r\n\r\n            // 1.0 - Get the dial's reward balance\r\n            if (dialData.balance == 0) {\r\n                continue;\r\n            }\r\n            // 2.0 - Reset the balance in storage back to 0\r\n            dials[_dialIds[i]].balance = 0;\r\n\r\n            // 3.0 - Send the rewards the to the dial recipient\r\n            REWARD_TOKEN.safeTransfer(dialData.recipient, dialData.balance);\r\n\r\n            // 4.0 - Notify the dial of the new rewards if configured to\r\n            //       Only after successful transer tx\r\n            if (dialData.notify) {\r\n                IRewardsDistributionRecipient(dialData.recipient).notifyRewardAmount(\r\n                    dialData.balance\r\n                );\r\n            }\r\n\r\n            emit DistributedReward(_dialIds[i], dialData.balance);\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                VOTING-EXTERNAL\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Re-cast a voters votes by retrieving balance across all staking contracts\r\n     *         and updating `lastSourcePoke`.\r\n     * @dev    This would need to be called if a staking contract was added to the emissions controller\r\n     * when a voter already had voting power in the new staking contract and they had already set voting preferences.\r\n     * @param _voter    Address of the voter for which to re-cast.\r\n     */\r\n    function pokeSources(address _voter) public {\r\n        // Only poke if voter has previously set voting preferences\r\n        if (voterPreferences[_voter].lastSourcePoke > 0) {\r\n            uint256 votesCast = voterPreferences[_voter].votesCast;\r\n            uint256 newVotesCast = getVotes(_voter) - votesCast;\r\n            _moveVotingPower(_voter, newVotesCast, _add);\r\n            voterPreferences[_voter].lastSourcePoke = SafeCast.toUint32(block.timestamp);\r\n\r\n            emit SourcesPoked(_voter, newVotesCast);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allows a staker to cast their voting power across a number of dials.\r\n     * @dev    A staker can proportion their voting power even if they currently have zero voting power.\r\n     *         For example, they have delegated their votes. When they do have voting power (e.g. they undelegate),\r\n     *         their set weights will proportion their voting power.\r\n     * @param _preferences  Structs containing dialId & voting weights, with 0 <= n <= 16 entries.\r\n     */\r\n    function setVoterDialWeights(Preference[] memory _preferences) external {\r\n        require(_preferences.length <= 16, \"Max of 16 preferences\");\r\n\r\n        // 1.0 - Get staker's previous total votes cast\r\n        uint256 votesCast = voterPreferences[msg.sender].votesCast;\r\n        // 1.1 - Adjust dial votes from removed staker votes\r\n        _moveVotingPower(msg.sender, votesCast, _subtract);\r\n        //       Clear the old weights as they will be added back below\r\n        delete voterPreferences[msg.sender];\r\n\r\n        // 2.0 - Log new preferences\r\n        uint256 newTotalWeight;\r\n        uint256 newDialWeights;\r\n        for (uint256 i = 0; i < _preferences.length; i++) {\r\n            require(_preferences[i].dialId < dials.length, \"Invalid dial id\");\r\n            require(_preferences[i].weight > 0, \"Must give a dial some weight\");\r\n            newTotalWeight += _preferences[i].weight;\r\n\r\n            // Add staker's dial weight\r\n            newDialWeights |= uint256(_preferences[i].weight) << (i * 16);\r\n            // Add staker's dial id\r\n            newDialWeights |= uint256(_preferences[i].dialId) << ((i * 16) + 8);\r\n        }\r\n\r\n        // 2.1 - In the likely scenario less than 16 preferences are given, add a breaker with max uint\r\n        //       to signal that this is the end of array.\r\n        if (_preferences.length < 16) {\r\n            // Set dialId to 255\r\n            newDialWeights |= uint256(255) << ((_preferences.length * 16) + 8);\r\n        }\r\n        require(newTotalWeight <= SCALE, \"Imbalanced weights\");\r\n        // Update storage with the array of 16 Preferences stored as an uint256\r\n        voterPreferences[msg.sender].dialWeights = newDialWeights;\r\n\r\n        // Need to set before calling _moveVotingPower for the second time\r\n        voterPreferences[msg.sender].lastSourcePoke = SafeCast.toUint32(block.timestamp);\r\n\r\n        // 3.0 - Cast votes on these new preferences\r\n        _moveVotingPower(msg.sender, getVotes(msg.sender), _add);\r\n\r\n        emit PreferencesChanged(msg.sender, _preferences);\r\n    }\r\n\r\n    /**\r\n     * @notice  Called by the staking contracts when a staker has modified voting power.\r\n     * @dev     This can be called when staking, cooling down for withdraw or delegating.\r\n     * @param from    Account that votes moved from. If a mint the account will be a zero address.\r\n     * @param to      Account that votes moved to. If a burn the account will be a zero address.\r\n     * @param amount  The number of votes moved including the decimal places.\r\n     */\r\n    function moveVotingPowerHook(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external override {\r\n        if (amount > 0) {\r\n            bool votesCast;\r\n            // Require that the caller of this function is a whitelisted staking contract\r\n            uint32 addTime = stakingContractAddTime[msg.sender];\r\n            require(addTime > 0, \"Caller must be staking contract\");\r\n\r\n            // If burning (withdraw) or transferring delegated votes from a staker\r\n            if (from != address(0)) {\r\n                uint32 lastSourcePoke = voterPreferences[from].lastSourcePoke;\r\n                if (lastSourcePoke > addTime) {\r\n                    _moveVotingPower(from, amount, _subtract);\r\n                    votesCast = true;\r\n                } else if (lastSourcePoke > 0) {\r\n                    // If preferences were set before the calling staking contract\r\n                    // was added to the EmissionsController\r\n                    pokeSources(from);\r\n                }\r\n                // Don't need to do anything if staker has not set preferences before.\r\n            }\r\n            // If minting (staking) or transferring delegated votes to a staker\r\n            if (to != address(0)) {\r\n                uint32 lastSourcePoke = voterPreferences[to].lastSourcePoke;\r\n                if (lastSourcePoke > addTime) {\r\n                    _moveVotingPower(to, amount, _add);\r\n                    votesCast = true;\r\n                } else if (lastSourcePoke > 0) {\r\n                    // If preferences were set before the calling staking contract\r\n                    // was added to the EmissionsController\r\n                    pokeSources(to);\r\n                }\r\n                // Don't need to do anything if staker has not set preferences before.\r\n            }\r\n\r\n            // Only emit if voting power was moved.\r\n            if (votesCast) {\r\n                emit VotesCast(msg.sender, from, to, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                VOTING-INTERNAL\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Internal voting power updater. Adds/subtracts votes across the array of user preferences.\r\n     * @param _voter    Address of the source of movement.\r\n     * @param _amount   Total amount of votes to be added/removed (proportionately across the user preferences).\r\n     * @param _op       Function (either addition or subtraction) that dictates how the `_amount` of votes affects balance.\r\n     */\r\n    function _moveVotingPower(\r\n        address _voter,\r\n        uint256 _amount,\r\n        function(uint256, uint256) pure returns (uint256) _op\r\n    ) internal {\r\n        // 0.0 - Get preferences and epoch data\r\n        VoterPreferences memory preferences = voterPreferences[_voter];\r\n\r\n        // 0.1 - If no preferences have been set then there is nothing to do\r\n        // This prevent doing 16 iterations below as dialId 255 will not be set\r\n        if (preferences.lastSourcePoke == 0) return;\r\n\r\n        // 0.2 - If in the first launch week\r\n        uint32 currentEpoch = _epoch(block.timestamp);\r\n\r\n        // 0.3 - Update the total amount of votes cast by the voter\r\n        voterPreferences[_voter].votesCast = SafeCast.toUint128(\r\n            _op(preferences.votesCast, _amount)\r\n        );\r\n\r\n        // 1.0 - Loop through voter preferences until dialId == 255 or until end\r\n        for (uint256 i = 0; i < 16; i++) {\r\n            uint256 dialId = uint8(preferences.dialWeights >> ((i * 16) + 8));\r\n            if (dialId == 255) break;\r\n\r\n            uint256 weight = uint8(preferences.dialWeights >> (i * 16));\r\n\r\n            // 1.1 - Scale the vote by dial weight\r\n            //       e.g. 5e17 * 1e18 / 1e18 * 100e18 / 1e18 = 50e18\r\n            uint256 amountToChange = (weight * _amount) / SCALE;\r\n\r\n            // 1.2 - Fetch voting history for this dial\r\n            HistoricVotes[] storage voteHistory = dials[dialId].voteHistory;\r\n            uint256 len = voteHistory.length;\r\n            HistoricVotes storage latestHistoricVotes = voteHistory[len - 1];\r\n\r\n            // 1.3 - Determine new votes cast for dial\r\n            uint128 newVotes = SafeCast.toUint128(_op(latestHistoricVotes.votes, amountToChange));\r\n\r\n            // 1.4 - Update dial vote count. If first vote in new epoch, create new entry\r\n            if (latestHistoricVotes.epoch < currentEpoch) {\r\n                // Add a new weighted votes epoch for the dial\r\n                voteHistory.push(HistoricVotes({ votes: newVotes, epoch: currentEpoch }));\r\n            } else {\r\n                // Epoch already exists for this dial so just update the dial's weighted votes\r\n                latestHistoricVotes.votes = newVotes;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the epoch index the timestamp is on.\r\n     *         This is the number of weeks since 1 Jan 1970. ie the timestamp / 604800 seconds in a week.\r\n     * @dev    Each week starts on Thursday 00:00 UTC.\r\n     * @param timestamp UNIX time in seconds.\r\n     * @return epoch    The number of weeks since 1 Jan 1970.\r\n     */\r\n    function _epoch(uint256 timestamp) internal pure returns (uint32 epoch) {\r\n        epoch = SafeCast.toUint32(timestamp) / DISTRIBUTION_PERIOD;\r\n    }\r\n\r\n    /**\r\n     * @dev Simple addition function, used in the `_moveVotingPower` fn.\r\n     */\r\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Simple subtraction function, used in the `_moveVotingPower` fn.\r\n     */\r\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nexus\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int256\",\"name\":\"A\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"B\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"C\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"D\",\"type\":\"int256\"},{\"internalType\":\"uint128\",\"name\":\"EPOCHS\",\"type\":\"uint128\"}],\"internalType\":\"struct TopLevelConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakingContract\",\"type\":\"address\"}],\"name\":\"AddStakingContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dialId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"AddedDial\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dialId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DistributedReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dialId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DonatedRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"PeriodRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dialId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Preference[]\",\"name\":\"preferences\",\"type\":\"tuple[]\"}],\"name\":\"PreferencesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVotesCast\",\"type\":\"uint256\"}],\"name\":\"SourcesPoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dialId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_notify\",\"type\":\"bool\"}],\"name\":\"UpdatedDial\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"stakingContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VotesCast\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"REWARD_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_cap\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"_notify\",\"type\":\"bool\"}],\"name\":\"addDial\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingContract\",\"type\":\"address\"}],\"name\":\"addStakingContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dials\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"notify\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"cap\",\"type\":\"uint8\"},{\"internalType\":\"uint96\",\"name\":\"balance\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_dialIds\",\"type\":\"uint256[]\"}],\"name\":\"distributeRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_dialIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochs\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"startEpoch\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lastEpoch\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dialId\",\"type\":\"uint256\"}],\"name\":\"getDialRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dialId\",\"type\":\"uint256\"}],\"name\":\"getDialVoteHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"votes\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"}],\"internalType\":\"struct HistoricVotes[]\",\"name\":\"voteHistory\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDialVotes\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"dialVotes\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getVoterPreferences\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dialId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"internalType\":\"struct Preference[16]\",\"name\":\"preferences\",\"type\":\"tuple[16]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"votingPower\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"_caps\",\"type\":\"uint8[]\"},{\"internalType\":\"bool[]\",\"name\":\"_notifies\",\"type\":\"bool[]\"},{\"internalType\":\"address[]\",\"name\":\"_stakingContracts\",\"type\":\"address[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"moveVotingPowerHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nexus\",\"outputs\":[{\"internalType\":\"contract INexus\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"pokeSources\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dialId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"internalType\":\"struct Preference[]\",\"name\":\"_preferences\",\"type\":\"tuple[]\"}],\"name\":\"setVoterDialWeights\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakingContractAddTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakingContracts\",\"outputs\":[{\"internalType\":\"contract IVotes\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"}],\"name\":\"topLineEmission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"emissionForEpoch\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dialId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_disabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_notify\",\"type\":\"bool\"}],\"name\":\"updateDial\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voterPreferences\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dialWeights\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"votesCast\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"lastSourcePoke\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"EmissionsController","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000afce80b19a8ce13dec0739a1aab7a028d6845eb3000000000000000000000000a3bed4e1c75d00fa6f4e5e6922db7261b5e9acd2ffffffffffffffffffffffffffffffffffffffffffffffffffff69061cf7a0000000000000000000000000000000000000000000000000000000993b4b192c45ffffffffffffffffffffffffffffffffffffffffffffffffffff66c4b4e6d3bb000000000000000000000000000000000000000000000000000096f9e30860000000000000000000000000000000000000000000000000000000000000000138","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://04ab9554eaca66b12cffa0736cd8c10f9e9939effc41283bc57047dffeeb7dac"}]}