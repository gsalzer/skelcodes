// SPDX-License-Identifier: MIT
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNX00KKXXNWWMMXO0NMMMMMMMMMWWWWMMMMMMMMWWMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWX00KNMMMMMMMMN0OKKKKK0KNWMNd,lXWWNNNWWWWWWWWWWWWWWWNO0WMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNOl:;;:lkXWW0xdk000KKKKKXNWWNd'.'o0XXNWWWWWWWWNWWWWWWKdckWMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMWOoxNMMMXo;,,',,,;col,',cdxk0XXXNWMMMO,.  .':xXWNWNKkxxk0KNWWOc,;xWMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMNx,.;OWWKl,,;cc:;,,,'...';c:cx0KNMMMMMXc..   ..cdloo:,',;ckX0d;'':0MMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMWk'.':oo:'',:ll;,,,,,,'....''',;xNMMMMWk,.......''''.....:lc;..',dNMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMXc...'''''.',,'',;,,,,'...''''':0MMMMMWk;.........''.......''..:0MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMWKo:,;;'...........''''''...''.:0MMMMMMKxl'......';:;,...'...'l0WMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMWNXN0:.................''''',dNMMMMMWOdk:.......'''''''....oNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMO, ........''.....,xOOO0KNMMMMMMMKOk:....''............lXMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
// MMWNWWWWWWNNNNWMMMMMMMMMMWXXXXKd;.,;,'',..;ccc;'..:cdXMMMMMMMMMMWOl,....''''..........'dXMMMMMMMMMMMMMMMWNNNNNNWWWNNWMMM
// MWKxoodddooooloKMMMMMMMMKc'''''.';cc;.........''....'kWMMMMMMMMMNo... ..''''''........',lONMMMMMMMMMMMWOlccccclllclxXMMM
// MMWXxc:ccc:::,:OMMMMMMMMk.        ..          .... ..oNMMMMMMMMMKc.. ...'',,';;.......',,cOWMMMMMMMMMMWx'.',,,,,,:xXWMMM
// MMMMWOc;;;;,;lOWMMMMMMMMX:        ...         .'.. ..lXMMMMMMMMM0:.. ..''',,,;,'......',;oKWMMMMMMMMMMMNx,.....'cKWMMMMM
// MMMMMWO:'..;kNMMMMMMMMMMWO;.     .''...      .:c'....cXMMMMMMMMM0;.....,'..'''''.''.'''''c0WMMMWWWWMMMMMWKl. ..;0MMMMMMM
// MMMMMMO,...lNMMMMMMMMMMMMWNd''''','',;;'  ...,,,... .oNMMMMMMMMMXl. ...'''.....',''.''''''cKMMNXXXWMMMMMMMKc...:KMMMMMMM
// MMMMMNo,':kNMMMMMMMMMMMMMMXl''..'..'',,...''.,,.... 'OMMMMMMMMMMWx......''.'..............,dXNXK00XWMMMMMMWXx;.,xNMMMMMM
// MMMMNx;,,dWMMMMMMMMMMMMMMMO,..............:c'';... .:KMMMMMMMMMMMO;. ..','';'..............;OXK0KXNWMMMMMMMMKc'';oONMMMM
// MMMNd;;;'dWMMMMMMMMMMWWWWW0c',;;,,,,......,;....   ,kWMMMMMMMMMMMNx'. .....,...............;ONXKKXWMMMMMMMMMKc,;;;:OWMMM
// MMWk,''''dWMMMMMMMMMW0occc;,;:ldxxkxdc;''''....  .'oXMMMMMMMMMMMMWKc..  ...'...............';cco0WMMMMMMMMMM0c,;;;;lKMMM
// MMXl;c:::lKMMMMMMMMMWN0000Od:',:cloolc::::;,;,.  .lXMMMMMMMMMMMMMMM0:. ..,,,'.............,lxdoxXMMMMMMMMMMNd;;::;;:OMMM
// MM0cclll:,oNMMWNXXNWWXKOO0KXOc'.'.''....';:::,. .;kNMMMMMMMMMMMMMMWXd;'.';;;;,'.........':kXXK0KKXXKKKXNWMM0c,;::;;:kWMM
// MWk,,:clc;:x0Ol'.,oxxxdool;;l;'.......',:::,..,.'c,:xOKNMMMMMMWX0kdc:::;,',;::;,......,,;ldolcccllllcclodxxl;;;:;,,;kWMM
// MWx;;cloc;..;c'. .cooddxkx,.,.c;  ..'',;,'.. ,d,,;.:xxdddOXK0Oxlccc:;;cl:,'.',;;,'..'::;:cccccccccccccccc:;;;;::;,,,dNMM
// MWx,,:lol,';co:. .cllllc:,.,;'c,,o,.....  ;o';d,,:..;:okxlccccclllllc:;:llc;,'.',;:cc:;:cccccccccccccccccc::::::;;,,lXMM
// MNd::codol::lo:. ,ddddooo;.:;'c'c0:.'..'..d0,;x,,c',xo;,;cccccllcccllc:;;clc:;,;::lc:;:::ccccccccccccccccc::::::;;;;:kWM
// MKl,;loc::,;c:,. .coolc:,..l,'l'cO;;kc,ko.dO,;k:.l;.xXXd;;:::ccc::cccccc:;;;::;::;;:;:::c::::::::::::::::::::;;;;;;;:xWM
// MWKkdxo,.'.,:,.  :O0Okl;'.,l.;o'ck,;Oc,Od.o0;,ko.:c..:kKo;:::::::;;::::ccc::cc;::c:::::c::::::::;;;;;;;;;;;;,,'';:ldONMM
// MMMMMWWKOdlloc'.'cxOKX0d;.;c.co.lO;;Oc,Ox.oKc'xx.;c.,:';c::::;;;;;;::::::c::::;;::::::::::;;::;cdOkdlc;;;;::cldk0NWMMMMM
// MMMMMMMMMMMWWNXKXNMMMMMKc.;:.cl.o0;;Oc,0k'lXo.dx.::.c0x,',...........''...............';:;;;:;l0WMMMWNXKKKXNWWMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMNo.;:.cc.xK;;O:,0O'cXo.dd.::.,ll;,....... .. .... ..  .......  .,::;:::kWMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMWd.;:.c:.x0,;O:,0k'lKl.xd.cc. ..';...........................  .,:::::c0MMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMM0,;:.::.xO':0:,0x.lKc'kd.:c..'';;..........'..'.............  .,::;:;l0MMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMWdc:.::.xk'c0;,0d.l0:.dd.,c..',;:.  ........................  .,;,,;;:0MMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMM0o:.;;.xk'l0;,0x.cO:.lo.'l'..,::..........''',,'...........  .',,,;;;xWMMMMMMMMMMMMMMMMMMMMMMMM
// MMMMMMMMMMMMMMMMMMMMMMMMMKo;.;,.xx'o0;;0x.:Oc.co..l,.',:;. ................''.......  .',,,;;,oNMMMMMMMMMMMMMMMMMMMMMMMM

pragma solidity ^0.8.6;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract MZS is Ownable, ReentrancyGuard, ERC721Enumerable {
    using SafeMath for uint256;
    using Strings for uint256;
    using ECDSA for bytes32;

    // Public variables
    uint256 public MAX_NFT_SUPPLY = 9999;
    uint256 private constant HARD_LIMIT = 9999;
    uint256[3] public MINT_PRICE = [35*10**15, 50*10**15, 15*10**15]; // presale, public, collab
    uint256 public state;
    string public _baseTokenURI;
    uint256 public shiftIndex;
    bool public isCollabGAAllowed = false;
    uint256 private _randomNum = 626;
    string public PROVENANCE;
    address private signerAddress;
    bool public isAllowedSupplyChange = true;
    mapping (address => uint256) private wlBalance;

    // Team
    address[] public payees;
    mapping(address => uint256) private shares;
    uint256 private totalShares;

    // Events
    event ChangeState(uint256 currentState);
    event Mint(address minter, uint256 quantity);
    event Reveal(uint256 index);

    /**
     * @dev Initialize
     */
    constructor(string memory baseURI, address[] memory _team, uint256[] memory _shares, address _signerAddress) 
        ERC721("Flexin Zebras", "FZ"){

        // splitter
        require(_team.length == _shares.length, "Payees and shares length mismatch");
        require(_team.length > 0, "No payees");
        for (uint256 i = 0; i < _team.length; i++) {
            addPayee(_team[i], _shares[i]);
        }

        // set url
        setBaseURI(baseURI);

        // signer address
        setSignerAddress(_signerAddress);
    }

    /**
     * @dev Switcher, if called changeNFTSupply is not available anymore
     */
    function turnOffAdaptiveSupply() public onlyOwner {
        require(isAllowedSupplyChange == true, "Could only be switched once");
        isAllowedSupplyChange = false;
    }

    /**
     * @dev Soldout supply guarantee
     */
    function changeNFTSupply(uint256 new_limit) public onlyOwner {
        require(isAllowedSupplyChange == true, "Max supply is freezed forever");
        require(totalSupply()<= new_limit, "New limit cant be less than total supply");
        require(new_limit<= HARD_LIMIT, "Cant be > 9999");
        MAX_NFT_SUPPLY = new_limit;
    }

    /**
     * @dev Changes signer address. In case of emergency
     */
    function setSignerAddress(address addr) public onlyOwner {
        signerAddress = addr;
    }

    /**
     * @dev Sets setIsCollabGAAllowed switcher. In case of emergency
     */
    function setIsCollabGAAllowed(bool newVal) external onlyOwner {
        isCollabGAAllowed = newVal;
    }

    /**
     * @dev Gets base url
     */
    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @dev Sets base url. In case of emergency
     */
    function setBaseURI(string memory baseURI) public onlyOwner {
        _baseTokenURI = baseURI;
    }

    /**
     * @dev Sets price. In case of emergency
     */
    function setPrice(uint256 index, uint256 _price) public onlyOwner {
        MINT_PRICE[index] = _price;
    }

    /**
    * @dev Sets state.  0 - sales are paused; 1 - prsale,  2 - sale
    */
    function setState(uint256 val) external onlyOwner {
       state = val;

       // event
       emit ChangeState(val);
    }

    /**
     * @dev Finalize shift index 
     */
    function reveal() external onlyOwner {
        require(shiftIndex == 0, "Shift index is already set");
        shiftIndex = _randomNum.mod(HARD_LIMIT);

        // Prevent default shift index = 0.
        if (shiftIndex == 0) {
            shiftIndex.add(626);
        }

        // event
        emit Reveal(shiftIndex);
    }

    /**
     * @dev Ipfs CID of metas is set
    */
    function setProvenanceHash(string memory provenanceHash) external onlyOwner {
        PROVENANCE = provenanceHash;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");

        if (shiftIndex != 0){
            uint256 shiftedId = tokenId.add(shiftIndex).mod(HARD_LIMIT);
            return string(abi.encodePacked(_baseURI(), shiftedId.toString()));
        } else {
            return string(abi.encodePacked(_baseURI(), "not_revealed"));
        }
    }

    /**
    * @dev List NFTs owned by address
    */
    function listNFTs(address _owner) external view returns(uint256[] memory) {
        uint256 tokenCount = balanceOf(_owner);

        uint256[] memory tokensId = new uint256[](tokenCount);
        for(uint256 i; i < tokenCount; i++){
            tokensId[i] = tokenOfOwnerByIndex(_owner, i);
        }
        return tokensId;
    }

    /**
    * @dev Recover signer address
    */
    function recoverAddr(address addr, string memory str, bytes memory _signature) public pure returns (address) {
        return keccak256(abi.encode(str, addr)).toEthSignedMessageHash().recover(_signature);
    }

    /**
    * @dev Mints for public launch
    */
    function mint(uint256 quantity) external nonReentrant payable {
        require(state == 2, "Sale is paused");
        require(quantity>= 1 && quantity<= 20, "Amount of minted NFTs at once should be in [1,20] interval");
        require(msg.value == MINT_PRICE[1].mul(quantity), "Wrong ETH amount");

        // shiftIndex is only influenced by ordinary mints
        _randomNum = _randomNum.add(uint256(keccak256(abi.encode(blockhash(block.number),
                                                        block.coinbase,
                                                        block.difficulty,
                                                        _msgSender(),
                                                        totalSupply(),
                                                        quantity
                                    ))).mod(HARD_LIMIT));

        // mint
        _mintBase(_msgSender(), quantity);

        // event
        emit Mint(_msgSender(), quantity);
    }

    /**
    * @dev Mints for airdrops
    */
    function mintAirdrop(uint256 quantity, address reciever) external onlyOwner {
        // Just natural limit in case of typo
        require(quantity>= 1 && quantity<= 100, "Amount of minted NFTs at once should be in [1,100] interval");
        _mintBase(reciever, quantity);
    }

    /**
    * @dev Mints for presale
    */
    function presaleMint(uint256 quantity, bytes memory _signature) external nonReentrant payable {
        require(state == 1, "Presale is paused");
        require(quantity>= 1, "Amount of minted NFTs should be > 0");
        require(msg.value == MINT_PRICE[0].mul(quantity), "Wrong ETH amount");
        require(signerAddress == recoverAddr(_msgSender(), "presaleMint", _signature), "Not authorized. You need to be whitelisted on Discord");

        // mint
        _mintBase(_msgSender(), quantity);

        // add to wl balance
        wlBalance[_msgSender()] = wlBalance[_msgSender()].add(quantity);

        // check 10 mints per wallet
        require(wlBalance[_msgSender()] <= 10, "You can presale mint only 10 NFTs in total");

        // event
        emit Mint(_msgSender(), quantity);
    }

    /**
    * @dev Mints for collabs
    */
    function collabMint(uint256 quantity, bytes memory _signature) external nonReentrant payable {
        require(isCollabGAAllowed == true, "Collab mint is paused");
        require(quantity>= 1, "Amount of minted NFTs should be > 0");
        require(signerAddress == recoverAddr(_msgSender(), "collabMint", _signature), "Not authorized. You need to be whitelisted on Discord");
        require(msg.value == MINT_PRICE[2].mul(quantity), "Wrong ETH amount");

        // mint
        _mintBase(_msgSender(), quantity);

        // add to wl balance
        wlBalance[_msgSender()] = wlBalance[_msgSender()].add(quantity);

        // check 2 mints per wallet
        require(wlBalance[_msgSender()] <= 2, "You can collab mint only 2 Zebras in total and only possible if you haven't yet minted one from WL");

        // event
        emit Mint(_msgSender(), quantity);
    }

    /**
    * @dev base mint
    */
    function _mintBase(address to, uint256 quantity) private {
        for (uint i=0; i<quantity; i++){
            // mint
            uint256 mintIndex = totalSupply();
            _safeMint(to, mintIndex);
            require(totalSupply() <= MAX_NFT_SUPPLY, "Sale has already ended OR not enough NFTs left");
        }
    }

    /**
    * @dev Withdraw ether
    */
    function withdraw() public {
        require(shares[_msgSender()] > 0, "Only team members are allowed");
        // get balance 
        uint256 balance = address(this).balance;
        require(balance > 0, "Nothing to withdraw");
        for (uint256 i = 0; i < payees.length; i++) {
            Address.sendValue(payable(payees[i]), balance.div(totalShares).mul(shares[payees[i]]));
        }
    }

    /**
     * @dev Withdraw ERC20
    */
    function withdrawERC20(address tokenAddress) public {
        require(shares[_msgSender()] > 0, "Only team members are allowed");
        // get balance 
        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));
        require(balance > 0, "Nothing to withdraw");
        for (uint256 i = 0; i < payees.length; i++) {
            IERC20(tokenAddress).transfer(payees[i], balance.div(totalShares).mul(shares[payees[i]]));
        }
    }

    /**
    * @dev Add Payee
    */
    function addPayee(address account, uint256 shares_) private {
        require(account != address(0), "Account is the zero address");
        require(shares_ > 0, "Shares are 0");
        require(shares[account] == 0, "Account already has shares");

        payees.push(account);
        shares[account] = shares_;
        totalShares = totalShares.add(shares_);
    }

    fallback() external payable {
    }
    
    receive() external payable {
    }
}

