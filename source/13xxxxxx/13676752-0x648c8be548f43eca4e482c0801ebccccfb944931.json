{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0\r\n// File: contracts/TrustedCaller.sol\r\n\r\n// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @author psirex\r\n/// @notice A helper contract contains logic to validate that only a trusted caller has access to certain methods.\r\n/// @dev Trusted caller set once on deployment and can't be changed.\r\ncontract TrustedCaller {\r\n    string private constant ERROR_TRUSTED_CALLER_IS_ZERO_ADDRESS = \"TRUSTED_CALLER_IS_ZERO_ADDRESS\";\r\n    string private constant ERROR_CALLER_IS_FORBIDDEN = \"CALLER_IS_FORBIDDEN\";\r\n\r\n    address public immutable trustedCaller;\r\n\r\n    constructor(address _trustedCaller) {\r\n        require(_trustedCaller != address(0), ERROR_TRUSTED_CALLER_IS_ZERO_ADDRESS);\r\n        trustedCaller = _trustedCaller;\r\n    }\r\n\r\n    modifier onlyTrustedCaller(address _caller) {\r\n        require(_caller == trustedCaller, ERROR_CALLER_IS_FORBIDDEN);\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IFinance.sol\r\n\r\n// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @author psirex\r\n/// @notice Interface of method from Aragon's Finance contract to create a new payment\r\ninterface IFinance {\r\n    function newImmediatePayment(\r\n        address _token,\r\n        address _receiver,\r\n        uint256 _amount,\r\n        string memory _reference\r\n    ) external;\r\n}\r\n\r\n// File: contracts/libraries/EVMScriptCreator.sol\r\n\r\n// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @author psirex\r\n/// @notice Contains methods for convenient creation\r\n/// of EVMScripts in EVMScript factories contracts\r\nlibrary EVMScriptCreator {\r\n    // Id of default CallsScript Aragon's executor.\r\n    bytes4 private constant SPEC_ID = hex\"00000001\";\r\n\r\n    /// @notice Encodes one method call as EVMScript\r\n    function createEVMScript(\r\n        address _to,\r\n        bytes4 _methodId,\r\n        bytes memory _evmScriptCallData\r\n    ) internal pure returns (bytes memory _commands) {\r\n        return\r\n            abi.encodePacked(\r\n                SPEC_ID,\r\n                _to,\r\n                uint32(_evmScriptCallData.length) + 4,\r\n                _methodId,\r\n                _evmScriptCallData\r\n            );\r\n    }\r\n\r\n    /// @notice Encodes multiple calls of the same method on one contract as EVMScript\r\n    function createEVMScript(\r\n        address _to,\r\n        bytes4 _methodId,\r\n        bytes[] memory _evmScriptCallData\r\n    ) internal pure returns (bytes memory _evmScript) {\r\n        for (uint256 i = 0; i < _evmScriptCallData.length; ++i) {\r\n            _evmScript = bytes.concat(\r\n                _evmScript,\r\n                abi.encodePacked(\r\n                    _to,\r\n                    uint32(_evmScriptCallData[i].length) + 4,\r\n                    _methodId,\r\n                    _evmScriptCallData[i]\r\n                )\r\n            );\r\n        }\r\n        _evmScript = bytes.concat(SPEC_ID, _evmScript);\r\n    }\r\n\r\n    /// @notice Encodes multiple calls to different methods within the same contract as EVMScript\r\n    function createEVMScript(\r\n        address _to,\r\n        bytes4[] memory _methodIds,\r\n        bytes[] memory _evmScriptCallData\r\n    ) internal pure returns (bytes memory _evmScript) {\r\n        require(_methodIds.length == _evmScriptCallData.length, \"LENGTH_MISMATCH\");\r\n\r\n        for (uint256 i = 0; i < _methodIds.length; ++i) {\r\n            _evmScript = bytes.concat(\r\n                _evmScript,\r\n                abi.encodePacked(\r\n                    _to,\r\n                    uint32(_evmScriptCallData[i].length) + 4,\r\n                    _methodIds[i],\r\n                    _evmScriptCallData[i]\r\n                )\r\n            );\r\n        }\r\n        _evmScript = bytes.concat(SPEC_ID, _evmScript);\r\n    }\r\n\r\n    /// @notice Encodes multiple calls to different contracts as EVMScript\r\n    function createEVMScript(\r\n        address[] memory _to,\r\n        bytes4[] memory _methodIds,\r\n        bytes[] memory _evmScriptCallData\r\n    ) internal pure returns (bytes memory _evmScript) {\r\n        require(_to.length == _methodIds.length, \"LENGTH_MISMATCH\");\r\n        require(_to.length == _evmScriptCallData.length, \"LENGTH_MISMATCH\");\r\n\r\n        for (uint256 i = 0; i < _to.length; ++i) {\r\n            _evmScript = bytes.concat(\r\n                _evmScript,\r\n                abi.encodePacked(\r\n                    _to[i],\r\n                    uint32(_evmScriptCallData[i].length) + 4,\r\n                    _methodIds[i],\r\n                    _evmScriptCallData[i]\r\n                )\r\n            );\r\n        }\r\n        _evmScript = bytes.concat(SPEC_ID, _evmScript);\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IEVMScriptFactory.sol\r\n\r\n// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @author psirex\r\n/// @notice Interface which every EVMScript factory used in EasyTrack contract has to implement\r\ninterface IEVMScriptFactory {\r\n    function createEVMScript(address _creator, bytes memory _evmScriptCallData)\r\n        external\r\n        returns (bytes memory);\r\n}\r\n\r\n// File: contracts/EVMScriptFactories/TopUpLegoProgram.sol\r\n\r\n// SPDX-FileCopyrightText: 2021 Lido <info@lido.fi>\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\n\r\n/// @author psirex\r\n/// @notice Creates EVMScript to top up the address of the LEGO program\r\ncontract TopUpLegoProgram is TrustedCaller, IEVMScriptFactory {\r\n    // -------------\r\n    // ERRORS\r\n    // -------------\r\n    string private constant ERROR_LENGTH_MISMATCH = \"LENGTH_MISMATCH\";\r\n    string private constant ERROR_EMPTY_DATA = \"EMPTY_DATA\";\r\n    string private constant ERROR_ZERO_AMOUNT = \"ZERO_AMOUNT\";\r\n\r\n    // -------------\r\n    // VARIABLES\r\n    // -------------\r\n\r\n    /// @notice Address of Aragon's Finance contract\r\n    IFinance public immutable finance;\r\n\r\n    /// @notice Address of LEGO program\r\n    address public immutable legoProgram;\r\n\r\n    // -------------\r\n    // CONSTRUCTOR\r\n    // -------------\r\n\r\n    constructor(\r\n        address _trustedCaller,\r\n        IFinance _finance,\r\n        address _legoProgram\r\n    ) TrustedCaller(_trustedCaller) {\r\n        finance = _finance;\r\n        legoProgram = _legoProgram;\r\n    }\r\n\r\n    // -------------\r\n    // EXTERNAL METHODS\r\n    // -------------\r\n\r\n    /// @notice Creates EVMScript to top up the address of the LEGO program\r\n    /// @param _creator Address who creates EVMScript\r\n    /// @param _evmScriptCallData Encoded tuple: (address[] _rewardTokens, uint256[] _amounts) where\r\n    /// _rewardTokens - addresses of ERC20 tokens (zero address for ETH) to transfer\r\n    /// _amounts - corresponding amount of tokens to transfer\r\n    function createEVMScript(address _creator, bytes memory _evmScriptCallData)\r\n        external\r\n        view\r\n        override\r\n        onlyTrustedCaller(_creator)\r\n        returns (bytes memory)\r\n    {\r\n        (address[] memory rewardTokens, uint256[] memory amounts) =\r\n            _decodeEVMScriptCallData(_evmScriptCallData);\r\n        _validateEVMScriptCallData(rewardTokens, amounts);\r\n\r\n        bytes[] memory paymentsCallData = new bytes[](rewardTokens.length);\r\n        for (uint256 i = 0; i < rewardTokens.length; ++i) {\r\n            paymentsCallData[i] = abi.encode(\r\n                rewardTokens[i],\r\n                legoProgram,\r\n                amounts[i],\r\n                \"Lego Program Transfer\"\r\n            );\r\n        }\r\n\r\n        return\r\n            EVMScriptCreator.createEVMScript(\r\n                address(finance),\r\n                finance.newImmediatePayment.selector,\r\n                paymentsCallData\r\n            );\r\n    }\r\n\r\n    /// @notice Decodes call data used by createEVMScript method\r\n    /// @param _evmScriptCallData Encoded tuple: (address[] _rewardTokens, uint256[] _amounts) where\r\n    /// _rewardTokens - addresses of ERC20 tokens (zero address for ETH) to transfer\r\n    /// _amounts - corresponding amount of tokens to transfer\r\n    /// @return _rewardTokens Addresses of ERC20 tokens (zero address for ETH) to transfer\r\n    /// @return _amounts Amounts of tokens to transfer\r\n    function decodeEVMScriptCallData(bytes memory _evmScriptCallData)\r\n        external\r\n        pure\r\n        returns (address[] memory _rewardTokens, uint256[] memory _amounts)\r\n    {\r\n        return _decodeEVMScriptCallData(_evmScriptCallData);\r\n    }\r\n\r\n    // ------------------\r\n    // PRIVATE METHODS\r\n    // ------------------\r\n\r\n    function _validateEVMScriptCallData(address[] memory _rewardTokens, uint256[] memory _amounts)\r\n        private\r\n        pure\r\n    {\r\n        require(_rewardTokens.length == _amounts.length, ERROR_LENGTH_MISMATCH);\r\n        require(_rewardTokens.length > 0, ERROR_EMPTY_DATA);\r\n        for (uint256 i = 0; i < _rewardTokens.length; ++i) {\r\n            require(_amounts[i] > 0, ERROR_ZERO_AMOUNT);\r\n        }\r\n    }\r\n\r\n    function _decodeEVMScriptCallData(bytes memory _evmScriptCallData)\r\n        private\r\n        pure\r\n        returns (address[] memory _rewardTokens, uint256[] memory _amounts)\r\n    {\r\n        return abi.decode(_evmScriptCallData, (address[], uint256[]));\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trustedCaller\",\"type\":\"address\"},{\"internalType\":\"contract IFinance\",\"name\":\"_finance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_legoProgram\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_evmScriptCallData\",\"type\":\"bytes\"}],\"name\":\"createEVMScript\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_evmScriptCallData\",\"type\":\"bytes\"}],\"name\":\"decodeEVMScriptCallData\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finance\",\"outputs\":[{\"internalType\":\"contract IFinance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"legoProgram\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trustedCaller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TopUpLegoProgram","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000012a43b049a7d330cb8aeab5113032d18ae9a9030000000000000000000000000b9e5cbb9ca5b0d659238807e84d0176930753d8600000000000000000000000012a43b049a7d330cb8aeab5113032d18ae9a9030","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://42e9c69e18c88cb68f677666a0c2fa0c1dda4270f536fc313b9c71e97b2c1e9c"}]}