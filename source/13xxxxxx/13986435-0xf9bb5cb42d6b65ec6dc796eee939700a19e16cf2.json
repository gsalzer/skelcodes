{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.4;\r\n\r\n/*\r\n\r\n            O\r\n            _\r\n     ---\\ _|.|_ /---\r\n      ---|  |  |---\r\n         |_/ \\_|\r\n          |   |\r\n          |   |\r\n          |___|\r\n           | |\r\n           / \\\r\n\r\n       SNUFFY 500\r\n\r\n*/\r\n\r\n/**\r\n * @title SNUFFY 500\r\n * @author CXIP-Labs\r\n * @notice A smart contract for minting and managing SNUFFY 500 ERC721 NFTs.\r\n * @dev The entire logic and functionality of the smart contract is self-contained.\r\n */\r\ncontract SNUFFY500 {\r\n    /**\r\n     * @dev Stores default collection data: name, symbol, and royalties.\r\n     */\r\n    CollectionData private _collectionData;\r\n\r\n    /**\r\n     * @dev Internal last minted token id, to allow for auto-increment.\r\n     */\r\n    uint256 private _currentTokenId;\r\n\r\n    /**\r\n     * @dev Array of all token ids in collection.\r\n     */\r\n    uint256[] private _allTokens;\r\n\r\n    /**\r\n     * @dev Map of token id to array index of _ownedTokens.\r\n     */\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    /**\r\n     * @dev Token id to wallet (owner) address map.\r\n     */\r\n    mapping(uint256 => address) private _tokenOwner;\r\n\r\n    /**\r\n     * @dev 1-to-1 map of token id that was assigned an approved operator address.\r\n     */\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    /**\r\n     * @dev Map of total tokens owner by a specific address.\r\n     */\r\n    mapping(address => uint256) private _ownedTokensCount;\r\n\r\n    /**\r\n     * @dev Map of array of token ids owned by a specific address.\r\n     */\r\n    mapping(address => uint256[]) private _ownedTokens;\r\n\r\n    /**\r\n     * @notice Map of full operator approval for a particular address.\r\n     * @dev Usually utilised for supporting marketplace proxy wallets.\r\n     */\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    /**\r\n     * @dev Token data mapped by token id.\r\n     */\r\n    mapping(uint256 => TokenData) private _tokenData;\r\n\r\n    /**\r\n     * @dev Address of admin user. Primarily used as an additional recover address.\r\n     */\r\n    address private _admin;\r\n\r\n    /**\r\n     * @dev Address of contract owner. This address can run all onlyOwner functions.\r\n     */\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev Simple tracker of all minted (not-burned) tokens.\r\n     */\r\n    uint256 private _totalTokens;\r\n\r\n    /**\r\n     * @dev Mapping from token id to position in the allTokens array.\r\n     */\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    /**\r\n     * @notice Event emitted when an token is minted, transfered, or burned.\r\n     * @dev If from is empty, it's a mint. If to is empty, it's a burn. Otherwise, it's a transfer.\r\n     * @param from Address from where token is being transfered.\r\n     * @param to Address to where token is being transfered.\r\n     * @param tokenId Token id that is being minted, Transfered, or burned.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @notice Event emitted when an address delegates power, for a token, to another address.\r\n     * @dev Emits event that informs of address approving a third-party operator for a particular token.\r\n     * @param wallet Address of the wallet configuring a token operator.\r\n     * @param operator Address of the third-party operator approved for interaction.\r\n     * @param tokenId A specific token id that is being authorised to operator.\r\n     */\r\n    event Approval(address indexed wallet, address indexed operator, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @notice Event emitted when an address authorises an operator (third-party).\r\n     * @dev Emits event that informs of address approving/denying a third-party operator.\r\n     * @param wallet Address of the wallet configuring it's operator.\r\n     * @param operator Address of the third-party operator that interacts on behalf of the wallet.\r\n     * @param approved A boolean indicating whether approval was granted or revoked.\r\n     */\r\n    event ApprovalForAll(address indexed wallet, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @notice Event emitted to signal to OpenSea that a permanent URI was created.\r\n     * @dev Even though OpenSea advertises support for this, they do not listen to this event, and do not respond to it.\r\n     * @param uri The permanent/static URL of the NFT. Cannot ever be changed again.\r\n     * @param id Token id of the NFT.\r\n     */\r\n    event PermanentURI(string uri, uint256 indexed id);\r\n\r\n    /**\r\n     * @notice Constructor is empty and not utilised.\r\n     * @dev To make exact CREATE2 deployment possible, constructor is left empty. We utilize the \"init\" function instead.\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * @notice Gets the configs for each state.\r\n     * @dev Currently only max and limit are being utilised. Four more future values are reserved for later use.\r\n     * @return max maximum number of token states ever possible.\r\n     * @return limit currently imposed hardcap/limit of token states.\r\n     * @return future0 reserved for a future value.\r\n     * @return future1 reserved for a future value.\r\n     * @return future2 reserved for a future value.\r\n     * @return future3 reserved for a future value.\r\n     */\r\n    function getStatesConfig() public view returns (uint256 max, uint256 limit, uint256 future0, uint256 future1, uint256 future2, uint256 future3) {\r\n        return SnuffyToken.getStatesConfig();\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the configs for each state.\r\n     * @dev Currently only max and limit are being utilised. Four more future values are reserved for later use.\r\n     * @param max maximum number of token states ever possible.\r\n     * @param limit currently imposed hardcap/limit of token states.\r\n     * @param future0 reserved for a future value.\r\n     * @param future1 reserved for a future value.\r\n     * @param future2 reserved for a future value.\r\n     * @param future3 reserved for a future value.\r\n     */\r\n    function setStatesConfig(uint256 max, uint256 limit, uint256 future0, uint256 future1, uint256 future2, uint256 future3) public onlyOwner {\r\n        SnuffyToken.setStatesConfig(max, limit, future0, future1, future2, future3);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the times that each state is valid for.\r\n     * @dev All state times are stacked to identify the current state based on last timestamp.\r\n     * @return UNIX timestamps in seconds for each state's time.\r\n     */\r\n    function getStateTimestamps() public view returns (uint256[8] memory) {\r\n        return SnuffyToken.getStateTimestamps();\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the times that each state is valid for.\r\n     * @dev All state times are stacked to identify the current state based on last timestamp.\r\n     * @param _timestamps UNIX timestamps in seconds for each state's time.\r\n     */\r\n    function setStateTimestamps(uint256[8] memory _timestamps) public onlyOwner {\r\n        SnuffyToken.setStateTimestamps(_timestamps);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the mutation requirements for each state.\r\n     * @dev Each state has it's own required amount of tokens to stack before a mutation can be forced.\r\n     * @return An array with numbers of tokens to stack for each state's mutation.\r\n     */\r\n    function getMutationRequirements() public view returns (uint256[8] memory) {\r\n        return SnuffyToken.getMutationRequirements();\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the mutation requirements for each state.\r\n     * @dev Each state has it's own required amount of tokens to stack before a mutation can be forced.\r\n     * @param _limits An array with numbers of tokens to stack for each state's mutation.\r\n     */\r\n    function setMutationRequirements(uint256[8] memory _limits) public onlyOwner {\r\n        SnuffyToken.setMutationRequirements(_limits);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the authorised broker for minting.\r\n     * @dev In order to allow for custom airdrop type minting/claims, an external broker smart contract is used.\r\n     * @return Address of wallet or smart contract that can mint tokens.\r\n     */\r\n    function getBroker() public view returns (address) {\r\n        return SnuffyToken.getBroker();\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the authorised broker for minting.\r\n     * @dev In order to allow for custom airdrop type minting/claims, an external broker smart contract is used.\r\n     * @param broker Address of wallet or smart contract that can mint tokens.\r\n     */\r\n    function setBroker(address broker) public onlyOwner {\r\n        SnuffyToken.setBroker(broker);\r\n    }\r\n\r\n    function getTokenState(uint256 tokenId) public view returns (uint256) {\r\n        return SnuffyToken.getTokenState(tokenId);\r\n    }\r\n\r\n    function getTokenDataIndex(uint256 tokenId) public view returns (uint256) {\r\n        return SnuffyToken.calculateState(tokenId);\r\n    }\r\n\r\n    function getTokenData(uint256 tokenId) public view returns (uint256, uint256, uint256) {\r\n        return SnuffyToken.getTokenData(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"CXIP: caller not an owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Left empty to accomodate old contracts with limited transfer gas amounts.\r\n     */\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @notice Enables royaltiy functionality at the ERC721 level no other function matches the call.\r\n     * @dev See implementation of _royaltiesFallback.\r\n     */\r\n    fallback() external {\r\n        _royaltiesFallback();\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the URI of the NFT on Arweave.\r\n     * @dev Concatenates 2 sections of the arweave URI.\r\n     * @return string The URI.\r\n     */\r\n    function arweaveURI(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId), \"CXIP: token does not exist\");\r\n        uint256 index = SnuffyToken.calculateState(tokenId);\r\n        return string(abi.encodePacked(\"https://arweave.net/\", _tokenData[index].arweave, _tokenData[index].arweave2));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the URI of the NFT backup from CXIP.\r\n     * @dev Concatenates to https://nft.cxip.io/.\r\n     * @return string The URI.\r\n     */\r\n    function contractURI() external view returns (string memory) {\r\n        return string(abi.encodePacked(\"https://nft.cxip.io/\", Strings.toHexString(address(this)), \"/\"));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the creator's address.\r\n     * @dev If the token Id doesn't exist it will return zero address.\r\n     * @return address Creator's address.\r\n     */\r\n    function creator(uint256 tokenId) external view returns (address) {\r\n        require(_exists(tokenId), \"CXIP: token does not exist\");\r\n        uint256 index = SnuffyToken.calculateState(tokenId);\r\n        return _tokenData[index].creator;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the HTTP URI of the token.\r\n     * @dev Concatenates to the baseURI.\r\n     * @return string The URI.\r\n     */\r\n    function httpURI(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId), \"CXIP: token does not exist\");\r\n        return string(abi.encodePacked(baseURI(), \"/\", Strings.toHexString(tokenId)));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the IPFS URI\r\n     * @dev Concatenates to the IPFS domain.\r\n     * @return string The URI.\r\n     */\r\n    function ipfsURI(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId), \"CXIP: token does not exist\");\r\n        uint256 index = SnuffyToken.calculateState(tokenId);\r\n        return string(abi.encodePacked(\"https://ipfs.io/ipfs/\", _tokenData[index].ipfs, _tokenData[index].ipfs2));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the name of the collection.\r\n     * @dev Uses two names to extend the max length of the collection name in bytes\r\n     * @return string The collection name.\r\n     */\r\n    function name() external view returns (string memory) {\r\n        return string(abi.encodePacked(Bytes.trim(_collectionData.name), Bytes.trim(_collectionData.name2)));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the hash of the NFT data used to create it.\r\n     * @dev Payload is used for verification.\r\n     * @param tokenId The Id of the token.\r\n     * @return bytes32 The hash.\r\n     */\r\n    function payloadHash(uint256 tokenId) external view returns (bytes32) {\r\n        require(_exists(tokenId), \"CXIP: token does not exist\");\r\n        uint256 index = SnuffyToken.calculateState(tokenId);\r\n        return _tokenData[index].payloadHash;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the signature of the signed NFT data used to create it.\r\n     * @dev Used for signature verification.\r\n     * @param tokenId The Id of the token.\r\n     * @return Verification a struct containing v, r, s values of the signature.\r\n     */\r\n    function payloadSignature(uint256 tokenId) external view returns (Verification memory) {\r\n        require(_exists(tokenId), \"CXIP: token does not exist\");\r\n        uint256 index = SnuffyToken.calculateState(tokenId);\r\n        return _tokenData[index].payloadSignature;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the address of the creator.\r\n     * @dev The creator signs a payload while creating the NFT.\r\n     * @param tokenId The Id of the token.\r\n     * @return address The creator.\r\n     */\r\n    function payloadSigner(uint256 tokenId) external view returns (address) {\r\n        require(_exists(tokenId), \"CXIP: token does not exist\");\r\n        uint256 index = SnuffyToken.calculateState(tokenId);\r\n        return _tokenData[index].creator;\r\n    }\r\n\r\n    /**\r\n     * @notice Shows the interfaces the contracts support\r\n     * @dev Must add new 4 byte interface Ids here to acknowledge support\r\n     * @param interfaceId ERC165 style 4 byte interfaceId.\r\n     * @return bool True if supported.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\r\n        if (\r\n            interfaceId == 0x01ffc9a7 || // ERC165\r\n            interfaceId == 0x80ac58cd || // ERC721\r\n            interfaceId == 0x780e9d63 || // ERC721Enumerable\r\n            interfaceId == 0x5b5e139f || // ERC721Metadata\r\n            interfaceId == 0x150b7a02 || // ERC721TokenReceiver\r\n            interfaceId == 0xe8a3d485 || // contractURI()\r\n            IPA1D(getRegistry().getPA1D()).supportsInterface(interfaceId)\r\n        ) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the collection's symbol.\r\n     * @dev Trims the symbol.\r\n     * @return string The symbol.\r\n     */\r\n    function symbol() external view returns (string memory) {\r\n        return string(Bytes.trim(_collectionData.symbol));\r\n    }\r\n\r\n    /**\r\n     * @notice Get's the URI of the token.\r\n     * @dev Defaults the the Arweave URI\r\n     * @return string The URI.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\r\n        require(_exists(tokenId), \"CXIP: token does not exist\");\r\n        uint256 index = SnuffyToken.calculateState(tokenId);\r\n        return string(abi.encodePacked(\"https://arweave.net/\", _tokenData[index].arweave, _tokenData[index].arweave2));\r\n    }\r\n\r\n    /**\r\n     * @notice Get list of tokens owned by wallet.\r\n     * @param wallet The wallet address to get tokens for.\r\n     * @return uint256[] Returns an array of token ids owned by wallet.\r\n     */\r\n    function tokensOfOwner(address wallet) external view returns (uint256[] memory) {\r\n        return _ownedTokens[wallet];\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if a given hash matches a payload hash.\r\n     * @dev Uses sha256 instead of keccak.\r\n     * @param hash The hash to check.\r\n     * @param payload The payload prehashed.\r\n     * @return bool True if the hashes match.\r\n     */\r\n    function verifySHA256(bytes32 hash, bytes calldata payload) external pure returns (bool) {\r\n        bytes32 thePayloadHash = sha256(payload);\r\n        return hash == thePayloadHash;\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a new address to the token's approval list.\r\n     * @dev Requires the sender to be in the approved addresses.\r\n     * @param to The address to approve.\r\n     * @param tokenId The affected token.\r\n     */\r\n    function approve(address to, uint256 tokenId) public {\r\n        address tokenOwner = _tokenOwner[tokenId];\r\n        require(to != tokenOwner, \"CXIP: can't approve self\");\r\n        require(_isApproved(msg.sender, tokenId), \"CXIP: not approved sender\");\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(tokenOwner, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Burns the token.\r\n     * @dev The sender must be the owner or approved.\r\n     * @param tokenId The token to burn.\r\n     */\r\n    function burn(uint256 tokenId) public {\r\n        require(_isApproved(msg.sender, tokenId), \"CXIP: not approved sender\");\r\n        address wallet = _tokenOwner[tokenId];\r\n        _clearApproval(tokenId);\r\n        _tokenOwner[tokenId] = address(0);\r\n        emit Transfer(wallet, address(0), tokenId);\r\n        _removeTokenFromOwnerEnumeration(wallet, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Initializes the collection.\r\n     * @dev Special function to allow a one time initialisation on deployment. Also configures and deploys royalties.\r\n     * @param newOwner The owner of the collection.\r\n     * @param collectionData The collection data.\r\n     */\r\n    function init(address newOwner, CollectionData calldata collectionData) public {\r\n        require(Address.isZero(_admin), \"CXIP: already initialized\");\r\n        _admin = msg.sender;\r\n        // temporary set to self, to pass rarible royalties logic trap\r\n        _owner = address(this);\r\n        _collectionData = collectionData;\r\n        IPA1D(address(this)).init (0, payable(collectionData.royalties), collectionData.bps);\r\n        // set to actual owner\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     * @param from cannot be the zero address.\r\n     * @param to cannot be the zero address.\r\n     * @param tokenId token must exist and be owned by `from`.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public payable {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     * @param from cannot be the zero address.\r\n     * @param to cannot be the zero address.\r\n     * @param tokenId token must exist and be owned by `from`.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) public payable {\r\n        require(_isApproved(msg.sender, tokenId), \"CXIP: not approved sender\");\r\n        _transferFrom(from, to, tokenId);\r\n        if (Address.isContract(to)) {\r\n            require(\r\n                ICxipERC721(to).onERC721Received(address(this), from, tokenId, data) == 0x150b7a02,\r\n                \"CXIP: onERC721Received fail\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a new approved operator.\r\n     * @dev Allows platforms to sell/transfer all your NFTs. Used with proxy contracts like OpenSea/Rarible.\r\n     * @param to The address to approve.\r\n     * @param approved Turn on or off approval status.\r\n     */\r\n    function setApprovalForAll(address to, bool approved) public {\r\n        require(to != msg.sender, \"CXIP: can't approve self\");\r\n        _operatorApprovals[msg.sender][to] = approved;\r\n        emit ApprovalForAll(msg.sender, to, approved);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers `tokenId` token from `msg.sender` to `to`.\r\n     * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     * @param to cannot be the zero address.\r\n     * @param tokenId token must be owned by `from`.\r\n     */\r\n    function transfer(\r\n        address to,\r\n        uint256 tokenId\r\n    ) public payable {\r\n        transferFrom(msg.sender, to, tokenId, \"\");\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Transfers `tokenId` token from `from` to `to`.\r\n     * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     * @param from  cannot be the zero address.\r\n     * @param to cannot be the zero address.\r\n     * @param tokenId token must be owned by `from`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public payable {\r\n        transferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers `tokenId` token from `from` to `to`.\r\n     * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\r\n     * @param from  cannot be the zero address.\r\n     * @param to cannot be the zero address.\r\n     * @param tokenId token must be owned by `from`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory /*_data*/\r\n    ) public payable {\r\n        require(_isApproved(msg.sender, tokenId), \"CXIP: not approved sender\");\r\n        _transferFrom(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Mints a token directly to creator wallet, or to a recipient.\r\n     * @dev Function can be called by the owner or by an authorised broker.\r\n     * @dev If a token limit is set, then it is enforced, and minting is closed on last mint.\r\n     * @param tokenId The specific token id to use. Mandatory.\r\n     * @param tokenData Array of details for each state of the token being minted.\r\n     * @param signer the address of the wallet that signed this.\r\n     * @param verification Broker has to include a signature made by any of the identity's wallets.\r\n     * @param recipient Optional parameter, to send the token to a recipient right after minting.\r\n     */\r\n    function mint(uint256 state, uint256 tokenId, TokenData[] memory tokenData, address signer, Verification memory verification, address recipient) public {\r\n        require(isOwner() || msg.sender == getBroker(), \"CXIP: only owner/broker can mint\");\r\n        require(_allTokens.length < getTokenLimit(), \"CXIP: over token limit\");\r\n        require(isIdentityWallet(tokenData[0].creator), \"CXIP: creator not in identity\");\r\n        if (!isOwner()) {\r\n            require(isIdentityWallet(signer), \"CXIP: invalid signer\");\r\n            bytes memory encoded = abi.encode(\r\n                tokenData[0].creator,\r\n                tokenId,\r\n                tokenData\r\n            );\r\n            require(Signature.Valid(\r\n                signer,\r\n                verification.r,\r\n                verification.s,\r\n                verification.v,\r\n                encoded\r\n            ), \"CXIP: invalid signature\");\r\n        }\r\n        if (!Address.isZero(recipient)) {\r\n            require(!_exists(tokenId), \"CXIP: token already exists\");\r\n            emit Transfer(address(0), tokenData[0].creator, tokenId);\r\n            emit Transfer(tokenData[0].creator, recipient, tokenId);\r\n            _tokenOwner[tokenId] = recipient;\r\n            _addTokenToOwnerEnumeration(recipient, tokenId);\r\n        } else {\r\n            _mint(tokenData[0].creator, tokenId);\r\n        }\r\n        if (_allTokens.length == getTokenLimit()) {\r\n            setMintingClosed();\r\n        }\r\n        (uint256 max,/* uint256 limit*/,/* uint256 future0*/,/* uint256 future1*/,/* uint256 future2*/,/* uint256 future3*/) = SnuffyToken.getStatesConfig();\r\n        require(tokenData.length <= max, \"CXIP: token data states too long\");\r\n        uint256 index = max * tokenId;\r\n        for (uint256 i = 0; i < tokenData.length; i++) {\r\n            _tokenData[index] = tokenData[i];\r\n            index++;\r\n        }\r\n        SnuffyToken.setTokenData(tokenId, state, block.timestamp, tokenId);\r\n    }\r\n\r\n    function evolve(uint256 tokenId, uint256[] calldata tokenIds) public {\r\n        uint256 state = SnuffyToken.getTokenState(tokenId);\r\n        (/*uint256 max*/, uint256 limit,/* uint256 future0*/,/* uint256 future1*/,/* uint256 future2*/,/* uint256 future3*/) = SnuffyToken.getStatesConfig();\r\n        require(state < (limit - 1), \"CXIP: token evolved to max\");\r\n        uint256[8] memory _limits = SnuffyToken.getMutationRequirements();\r\n        require(tokenIds.length == _limits[state], \"CXIP: incorrect tokens amount\");\r\n        bool included;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            require(ownerOf(tokenIds[i]) == msg.sender, \"CXIP: not owner of token\");\r\n            require(SnuffyToken.getTokenState(tokenIds[i]) >= state, \"CXIP: token level too low\");\r\n            if (!included && tokenId == tokenIds[i]) {\r\n                SnuffyToken.setTokenData(tokenId, state + 1, block.timestamp, tokenId);\r\n                included = true;\r\n            } else {\r\n                SnuffyToken.setTokenData(tokenIds[i], 0, block.timestamp, tokenIds[i]);\r\n                _transferFrom(msg.sender, SnuffyToken.getBroker(), tokenIds[i]);\r\n            }\r\n        }\r\n        require(included, \"CXIP: missing evolving token\");\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the minting status from storage slot.\r\n     * @return mintingClosed Whether minting is open or closed permanently.\r\n     */\r\n    function getMintingClosed() public view returns (bool mintingClosed) {\r\n        // The slot hash has been precomputed for gas optimizaion\r\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.SNUFFY500.mintingClosed')) - 1);\r\n        uint256 data;\r\n        assembly {\r\n            data := sload(\r\n                /* slot */\r\n                0x82d37688748a8833e0d222efdc792424f8a1acdd6c8351cb26b314a4ceee6a84\r\n            )\r\n        }\r\n        mintingClosed = (data == 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the minting status to closed in storage slot.\r\n     */\r\n    function setMintingClosed() public onlyOwner {\r\n        // The slot hash has been precomputed for gas optimizaion\r\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.SNUFFY500.mintingClosed')) - 1);\r\n        uint256 data = 1;\r\n        assembly {\r\n            sstore(\r\n                /* slot */\r\n                0x82d37688748a8833e0d222efdc792424f8a1acdd6c8351cb26b314a4ceee6a84,\r\n                data\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the token limit from storage slot.\r\n     * @return tokenLimit Maximum number of tokens that can be minted.\r\n     */\r\n    function getTokenLimit() public view returns (uint256 tokenLimit) {\r\n        // The slot hash has been precomputed for gas optimizaion\r\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.SNUFFY500.tokenLimit')) - 1);\r\n        assembly {\r\n            tokenLimit := sload(\r\n                /* slot */\r\n                0xd7cccb4858870420bddc578f86437fd66f8949091f61f21bd40e4390dc953953\r\n            )\r\n        }\r\n        if (tokenLimit == 0) {\r\n            tokenLimit = type(uint256).max;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the token limit to storage slot.\r\n     * @param tokenLimit Maximum number of tokens that can be minted.\r\n     */\r\n    function setTokenLimit(uint256 tokenLimit) public onlyOwner {\r\n        require(getTokenLimit() == 0, \"CXIP: token limit already set\");\r\n        // The slot hash has been precomputed for gas optimizaion\r\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.SNUFFY500.tokenLimit')) - 1);\r\n        assembly {\r\n            sstore(\r\n                /* slot */\r\n                0xd7cccb4858870420bddc578f86437fd66f8949091f61f21bd40e4390dc953953,\r\n                tokenLimit\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Set an NFT state.\r\n     * @dev Time-based states will be retrieved by index.\r\n     * @param id The index of time slot to set for.\r\n     * @param tokenData The token data for the particular time slot.\r\n     */\r\n    function prepareMintData(uint256 id, TokenData calldata tokenData) public onlyOwner {\r\n        require(Address.isZero(_tokenData[id].creator), \"CXIP: token data already set\");\r\n        _tokenData[id] = tokenData;\r\n    }\r\n\r\n    function prepareMintDataBatch(uint256[] calldata ids, TokenData[] calldata tokenData) public onlyOwner {\r\n        require(ids.length == tokenData.length, \"CXIP: array lengths missmatch\");\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            require(Address.isZero(_tokenData[ids[i]].creator), \"CXIP: token data already set\");\r\n            _tokenData[ids[i]] = tokenData[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Sets a name for the collection.\r\n     * @dev The name is split in two for gas optimization.\r\n     * @param newName First part of name.\r\n     * @param newName2 Second part of name.\r\n     */\r\n    function setName(bytes32 newName, bytes32 newName2) public onlyOwner {\r\n        _collectionData.name = newName;\r\n        _collectionData.name2 = newName2;\r\n    }\r\n\r\n    /**\r\n     * @notice Set a symbol for the collection.\r\n     * @dev This is the ticker symbol for smart contract that shows up on EtherScan.\r\n     * @param newSymbol The ticker symbol to set for smart contract.\r\n     */\r\n    function setSymbol(bytes32 newSymbol) public onlyOwner {\r\n        _collectionData.symbol = newSymbol;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership of the collection.\r\n     * @dev Can't be the zero address.\r\n     * @param newOwner Address of new owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(!Address.isZero(newOwner), \"CXIP: zero address\");\r\n        _owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Get total number of tokens owned by wallet.\r\n     * @dev Used to see total amount of tokens owned by a specific wallet.\r\n     * @param wallet Address for which to get token balance.\r\n     * @return uint256 Returns an integer, representing total amount of tokens held by address.\r\n     */\r\n    function balanceOf(address wallet) public view returns (uint256) {\r\n        require(!Address.isZero(wallet), \"CXIP: zero address\");\r\n        return _ownedTokensCount[wallet];\r\n    }\r\n\r\n    /**\r\n     * @notice Get a base URI for the token.\r\n     * @dev Concatenates with the CXIP domain name.\r\n     * @return string the token URI.\r\n     */\r\n    function baseURI() public view returns (string memory) {\r\n        return string(abi.encodePacked(\"https://nft.cxip.io/\", Strings.toHexString(address(this))));\r\n    }\r\n\r\n    function exists(uint256 tokenId) public view returns (bool) {\r\n        return !Address.isZero(_tokenOwner[tokenId]);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the approved address for the token.\r\n     * @dev Single operator set for a specific token. Usually used for one-time very specific authorisations.\r\n     * @param tokenId Token id to get approved operator for.\r\n     * @return address Approved address for token.\r\n     */\r\n    function getApproved(uint256 tokenId) public view returns (address) {\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the associated identity for the collection.\r\n     * @dev Goes up the chain to read from the registry.\r\n     * @return address Identity contract address.\r\n     */\r\n    function getIdentity() public view returns (address) {\r\n        return ICxipProvenance(getRegistry().getProvenance()).getWalletIdentity(_owner);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the address is approved.\r\n     * @dev Includes references to OpenSea and Rarible marketplace proxies.\r\n     * @param wallet Address of the wallet.\r\n     * @param operator Address of the marketplace operator.\r\n     * @return bool True if approved.\r\n     */\r\n    function isApprovedForAll(address wallet, address operator) public view returns (bool) {\r\n        // pre-approved OpenSea and Rarible proxies removed, per Nifty Gateway's request\r\n        return (_operatorApprovals[wallet][operator]/* ||\r\n            // Rarible Transfer Proxy\r\n            0x4feE7B061C97C9c496b01DbcE9CDb10c02f0a0Be == operator ||\r\n            // OpenSea Transfer Proxy\r\n            address(OpenSeaProxyRegistry(0xa5409ec958C83C3f309868babACA7c86DCB077c1).proxies(wallet)) == operator*/);\r\n    }\r\n\r\n    /**\r\n     * @notice Check if the sender is the owner.\r\n     * @dev The owner could also be the admin or identity contract of the owner.\r\n     * @return bool True if owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return (msg.sender == _owner || msg.sender == _admin || isIdentityWallet(msg.sender));\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the owner's address.\r\n     * @dev _owner is first set in init.\r\n     * @return address Of ower.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @notice Checks who the owner of a token is.\r\n     * @dev The token must exist.\r\n     * @param tokenId The token to look up.\r\n     * @return address Owner of the token.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view returns (address) {\r\n        address tokenOwner = _tokenOwner[tokenId];\r\n        require(!Address.isZero(tokenOwner), \"ERC721: token does not exist\");\r\n        return tokenOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Get token by index.\r\n     * @dev Used in conjunction with totalSupply function to iterate over all tokens in collection.\r\n     * @param index Index of token in array.\r\n     * @return uint256 Returns the token id of token located at that index.\r\n     */\r\n    function tokenByIndex(uint256 index) public view returns (uint256) {\r\n        require(index < totalSupply(), \"CXIP: index out of bounds\");\r\n        return _allTokens[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Get token from wallet by index instead of token id.\r\n     * @dev Helpful for wallet token enumeration where token id info is not yet available. Use in conjunction with balanceOf function.\r\n     * @param wallet Specific address for which to get token for.\r\n     * @param index Index of token in array.\r\n     * @return uint256 Returns the token id of token located at that index in specified wallet.\r\n     */\r\n    function tokenOfOwnerByIndex(\r\n        address wallet,\r\n        uint256 index\r\n    ) public view returns (uint256) {\r\n        require(index < balanceOf(wallet));\r\n        return _ownedTokens[wallet][index];\r\n    }\r\n\r\n    /**\r\n     * @notice Total amount of tokens in the collection.\r\n     * @dev Ignores burned tokens.\r\n     * @return uint256 Returns the total number of active (not burned) tokens.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Empty function that is triggered by external contract on NFT transfer.\r\n     * @dev We have this blank function in place to make sure that external contract sending in NFTs don't error out.\r\n     * @dev Since it's not being used, the _operator variable is commented out to avoid compiler warnings.\r\n     * @dev Since it's not being used, the _from variable is commented out to avoid compiler warnings.\r\n     * @dev Since it's not being used, the _tokenId variable is commented out to avoid compiler warnings.\r\n     * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\r\n     * @return bytes4 Returns the interfaceId of onERC721Received.\r\n     */\r\n    function onERC721Received(\r\n        address, /*_operator*/\r\n        address, /*_from*/\r\n        uint256, /*_tokenId*/\r\n        bytes calldata /*_data*/\r\n    ) public pure returns (bytes4) {\r\n        return 0x150b7a02;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows retrieval of royalties from the contract.\r\n     * @dev This is a default fallback to ensure the royalties are available.\r\n     */\r\n    function _royaltiesFallback() internal {\r\n        address _target = getRegistry().getPA1D();\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch result\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if an address is an identity contract.\r\n     * @dev It must also be registred.\r\n     * @param sender Address to check if registered to identity.\r\n     * @return bool True if registred identity.\r\n     */\r\n    function isIdentityWallet(address sender) internal view returns (bool) {\r\n        address identity = getIdentity();\r\n        if (Address.isZero(identity)) {\r\n            return false;\r\n        }\r\n        return ICxipIdentity(identity).isWalletRegistered(sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the top-level CXIP Registry smart contract. Function must always be internal to prevent miss-use/abuse through bad programming practices.\r\n     * @return ICxipRegistry The address of the top-level CXIP Registry smart contract.\r\n     */\r\n    function getRegistry() internal pure returns (ICxipRegistry) {\r\n        return ICxipRegistry(0xC267d41f81308D7773ecB3BDd863a902ACC01Ade);\r\n    }\r\n\r\n    /**\r\n     * @dev Add a newly minted token into managed list of tokens.\r\n     * @param to Address of token owner for which to add the token.\r\n     * @param tokenId Id of token to add.\r\n     */\r\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n        _ownedTokensIndex[tokenId] = _ownedTokensCount[to];\r\n        _ownedTokensCount[to]++;\r\n        _ownedTokens[to].push(tokenId);\r\n        _allTokensIndex[tokenId] = _allTokens.length;\r\n        _allTokens.push(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Deletes a token from the approval list.\r\n     * @dev Removes from count.\r\n     * @param tokenId T.\r\n     */\r\n    function _clearApproval(uint256 tokenId) private {\r\n        delete _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @notice Mints an NFT.\r\n     * @dev Can to mint the token to the zero address and the token cannot already exist.\r\n     * @param to Address to mint to.\r\n     * @param tokenId The new token.\r\n     */\r\n    function _mint(address to, uint256 tokenId) private {\r\n        require(!Address.isZero(to), \"CXIP: can't mint a burn\");\r\n        require(!_exists(tokenId), \"CXIP: token already exists\");\r\n        _tokenOwner[tokenId] = to;\r\n        emit Transfer(address(0), to, tokenId);\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n    }\r\n\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n        uint256 lastTokenIndex = _allTokens.length - 1;\r\n        uint256 tokenIndex = _allTokensIndex[tokenId];\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n        _allTokens[tokenIndex] = lastTokenId;\r\n        _allTokensIndex[lastTokenId] = tokenIndex;\r\n        delete _allTokensIndex[tokenId];\r\n        delete _allTokens[lastTokenIndex];\r\n        _allTokens.pop();\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a token from managed list of tokens.\r\n     * @param from Address of token owner for which to remove the token.\r\n     * @param tokenId Id of token to remove.\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(\r\n        address from,\r\n        uint256 tokenId\r\n    ) private {\r\n        _removeTokenFromAllTokensEnumeration(tokenId);\r\n        _ownedTokensCount[from]--;\r\n        uint256 lastTokenIndex = _ownedTokensCount[from];\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n        if(tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n            _ownedTokens[from][tokenIndex] = lastTokenId;\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\r\n        }\r\n        if(lastTokenIndex == 0) {\r\n            delete _ownedTokens[from];\r\n        } else {\r\n            delete _ownedTokens[from][lastTokenIndex];\r\n            _ownedTokens[from].pop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Primary internal function that handles the transfer/mint/burn functionality.\r\n     * @param from Address from where token is being transferred. Zero address means it is being minted.\r\n     * @param to Address to whom the token is being transferred. Zero address means it is being burned.\r\n     * @param tokenId Id of token that is being transferred/minted/burned.\r\n     */\r\n    function _transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) private {\r\n        require(_tokenOwner[tokenId] == from, \"CXIP: not from's token\");\r\n        require(!Address.isZero(to), \"CXIP: use burn instead\");\r\n        _clearApproval(tokenId);\r\n        _tokenOwner[tokenId] = to;\r\n        emit Transfer(from, to, tokenId);\r\n        _removeTokenFromOwnerEnumeration(from, tokenId);\r\n        _addTokenToOwnerEnumeration(to, tokenId);\r\n        SnuffyToken.setTokenData(tokenId, SnuffyToken.getTokenState(tokenId), block.timestamp, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the token owner exists.\r\n     * @dev If the address is the zero address no owner exists.\r\n     * @param tokenId The affected token.\r\n     * @return bool True if it exists.\r\n     */\r\n    function _exists(uint256 tokenId) private view returns (bool) {\r\n        address tokenOwner = _tokenOwner[tokenId];\r\n        return !Address.isZero(tokenOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks if the address is an approved one.\r\n     * @dev Uses inlined checks for different usecases of approval.\r\n     * @param spender Address of the spender.\r\n     * @param tokenId The affected token.\r\n     * @return bool True if approved.\r\n     */\r\n    function _isApproved(address spender, uint256 tokenId) private view returns (bool) {\r\n        require(_exists(tokenId));\r\n        address tokenOwner = _tokenOwner[tokenId];\r\n        return (\r\n            spender == tokenOwner ||\r\n            getApproved(tokenId) == spender ||\r\n            isApprovedForAll(tokenOwner, spender)\r\n        );\r\n    }\r\n}\r\n\r\nlibrary SnuffyToken {\r\n\r\n/*\r\n\r\n    // current hard cap for the states and amount of mutations possible\r\n        uint256 statesLimit = 6;\r\n\r\n    // hardware limit of maximum number of mutations possible\r\n        uint256 maxStates = 8;\r\n\r\n*/\r\n\r\n    /**\r\n     * @notice Gets the configs for each state.\r\n     * @dev Currently only max and limit are being utilised. Four more future values are reserved for later use.\r\n     * @return max maximum number of token states ever possible.\r\n     * @return limit currently imposed hardcap/limit of token states.\r\n     * @return future0 reserved for a future value.\r\n     * @return future1 reserved for a future value.\r\n     * @return future2 reserved for a future value.\r\n     * @return future3 reserved for a future value.\r\n     */\r\n    function getStatesConfig() internal view returns (uint256 max, uint256 limit, uint256 future0, uint256 future1, uint256 future2, uint256 future3) {\r\n        uint256 unpacked;\r\n        // The slot hash has been precomputed for gas optimizaion\r\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.SnuffyToken.statesConfig')) - 1);\r\n        assembly {\r\n            unpacked := sload(\r\n                /* slot */\r\n                0x320f7df63ad3c1fb03163fc8f47010f96d0a4b028d5ed2c9bdbc6b577caddacf\r\n            )\r\n        }\r\n        max = uint256(uint32(unpacked >> 0));\r\n        limit = uint256(uint32(unpacked >> 32));\r\n        future0 = uint256(uint32(unpacked >> 64));\r\n        future1 = uint256(uint32(unpacked >> 96));\r\n        future2 = uint256(uint32(unpacked >> 128));\r\n        future3 = uint256(uint32(unpacked >> 160));\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the configs for each state.\r\n     * @dev Currently only max and limit are being utilised. Four more future values are reserved for later use.\r\n     * @param max maximum number of token states ever possible.\r\n     * @param limit currently imposed hardcap/limit of token states.\r\n     * @param future0 reserved for a future value.\r\n     * @param future1 reserved for a future value.\r\n     * @param future2 reserved for a future value.\r\n     * @param future3 reserved for a future value.\r\n     */\r\n    function setStatesConfig(uint256 max, uint256 limit, uint256 future0, uint256 future1, uint256 future2, uint256 future3) internal {\r\n        // The slot hash has been precomputed for gas optimizaion\r\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.SnuffyToken.statesConfig')) - 1);\r\n        uint256 packed;\r\n        packed = packed | max << 0;\r\n        packed = packed | limit << 32;\r\n        packed = packed | future0 << 64;\r\n        packed = packed | future1 << 96;\r\n        packed = packed | future2 << 128;\r\n        packed = packed | future3 << 160;\r\n        assembly {\r\n            sstore(\r\n                /* slot */\r\n                0x320f7df63ad3c1fb03163fc8f47010f96d0a4b028d5ed2c9bdbc6b577caddacf,\r\n                packed\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the timestamps for duration of each state from storage slot.\r\n     * @return _timestamps UNIX timestamps for controlling each state's maximum duration.\r\n     */\r\n    function getStateTimestamps() internal view returns (uint256[8] memory _timestamps) {\r\n        uint256 data;\r\n        // The slot hash has been precomputed for gas optimizaion\r\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.SnuffyToken.stateTimestamps')) - 1);\r\n        assembly {\r\n            data := sload(\r\n                /* slot */\r\n                0xb3272806717bb124fff9d338a5d6ec1182c08fc56784769d91b37c01055db8e2\r\n            )\r\n        }\r\n        for (uint256 i = 0; i < 8; i++) {\r\n            _timestamps[i] = uint256(uint32(data >> (32 * i)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the timestamps for duration of each state to storage slot.\r\n     * @param _timestamps timestamps for controlling each state's maximum duration.\r\n     */\r\n    function setStateTimestamps(uint256[8] memory _timestamps) internal {\r\n        uint256 packed;\r\n        for (uint256 i = 0; i < 8; i++) {\r\n            packed = packed | _timestamps[i] << (32 * i);\r\n        }\r\n        // The slot hash has been precomputed for gas optimizaion\r\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.SnuffyToken.stateTimestamps')) - 1);\r\n        assembly {\r\n            sstore(\r\n                /* slot */\r\n                0xb3272806717bb124fff9d338a5d6ec1182c08fc56784769d91b37c01055db8e2,\r\n                packed\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the number of tokens needed for a forced mutation from storage slot.\r\n     * @return _limits An array of number of tokens required for a forced mutation.\r\n     */\r\n    function getMutationRequirements() internal view returns (uint256[8] memory _limits) {\r\n        uint256 data;\r\n        // The slot hash has been precomputed for gas optimizaion\r\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.SnuffyToken.mutationRequirements')) - 1);\r\n        assembly {\r\n            data := sload(\r\n                /* slot */\r\n                0x6ab8a5e4f8314f5c905e9eb234db45800102f76ee29724ea1039076fe1c57441\r\n            )\r\n        }\r\n        for (uint256 i = 0; i < 8; i++) {\r\n            _limits[i] = uint256(uint32(data >> (32 * i)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the number of tokens needed for a forced mutation to storage slot.\r\n     * @param _limits An array of number of tokens required for a forced mutation.\r\n     */\r\n    function setMutationRequirements(uint256[8] memory _limits) internal {\r\n        uint256 packed;\r\n        for (uint256 i = 0; i < 8; i++) {\r\n            packed = packed | _limits[i] << (32 * i);\r\n        }\r\n        // The slot hash has been precomputed for gas optimizaion\r\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.SnuffyToken.mutationRequirements')) - 1);\r\n        assembly {\r\n            sstore(\r\n                /* slot */\r\n                0x6ab8a5e4f8314f5c905e9eb234db45800102f76ee29724ea1039076fe1c57441,\r\n                packed\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the authorised broker from storage slot.\r\n     * @return broker Address of authorised broker.\r\n     */\r\n    function getBroker() internal view returns (address broker) {\r\n        // The slot hash has been precomputed for gas optimizaion\r\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.SnuffyToken.broker')) - 1);\r\n        assembly {\r\n            broker := sload(\r\n                /* slot */\r\n                0x71ad4b54125645bc093479b790dba1d002be6ff1fc59f46b726e598257e1e3c1\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Sets authorised broker to storage slot.\r\n     * @param broker Address of authorised broker.\r\n     */\r\n    function setBroker(address broker) internal {\r\n        // The slot hash has been precomputed for gas optimizaion\r\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.SnuffyToken.broker')) - 1);\r\n        assembly {\r\n            sstore(\r\n                /* slot */\r\n                0x71ad4b54125645bc093479b790dba1d002be6ff1fc59f46b726e598257e1e3c1,\r\n                broker\r\n            )\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the configuration/mapping for tokenId to stencilId from storage slot.\r\n     * @return state The latest permanent state that the token was transferred with.\r\n     * @return timestamp The UNIX timestamp of when last transfer occurred.\r\n     * @return stencilId Mapping for which stencil the token id was assigned.\r\n     */\r\n    function getTokenData(uint256 tokenId) internal view returns (uint256 state, uint256 timestamp, uint256 stencilId) {\r\n        uint256 unpacked;\r\n        bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(\"eip1967.CXIP.SnuffyToken.tokenData.\", tokenId))) - 1);\r\n        assembly {\r\n            unpacked := sload(slot)\r\n        }\r\n        state = uint256(uint32(unpacked >> 0));\r\n        timestamp = uint256(uint32(unpacked >> 32));\r\n        stencilId = uint256(uint32(unpacked >> 64));\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the configuration/mapping for tokenId to stencilId to storage slot.\r\n     * @param state The latest permanent state that the token was transferred with.\r\n     * @param timestamp The UNIX timestamp of when last transfer occurred.\r\n     * @param stencilId Mapping for which stencil the token id was assigned.\r\n     */\r\n    function setTokenData(uint256 tokenId, uint256 state, uint256 timestamp, uint256 stencilId) internal {\r\n        bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(\"eip1967.CXIP.SnuffyToken.tokenData.\", tokenId))) - 1);\r\n        uint256 packed;\r\n        packed = packed | state << 0;\r\n        packed = packed | timestamp << 32;\r\n        packed = packed | stencilId << 64;\r\n        assembly {\r\n            sstore(slot, packed)\r\n        }\r\n    }\r\n\r\n    function calculateState(uint256 tokenId) internal view returns (uint256 dataIndex) {\r\n        (uint256 max,/* uint256 limit*/,/* uint256 future0*/,/* uint256 future1*/,/* uint256 future2*/,/* uint256 future3*/) = getStatesConfig();\r\n        (/*uint256 state*/,/* uint256 timestamp*/, uint256 stencilId) = getTokenData(tokenId);\r\n        dataIndex = max * stencilId;\r\n        return dataIndex + getTokenState(tokenId);\r\n    }\r\n\r\n    function getTokenState(uint256 tokenId) internal view returns (uint256 dataIndex) {\r\n        (/*uint256 max*/, uint256 limit,/* uint256 future0*/,/* uint256 future1*/,/* uint256 future2*/,/* uint256 future3*/) = getStatesConfig();\r\n        (uint256[8] memory _timestamps) = getStateTimestamps();\r\n        (uint256 state, uint256 timestamp,/* uint256 stencilId*/) = getTokenData(tokenId);\r\n        uint256 duration = block.timestamp - timestamp;\r\n        for (uint256 i = state; i < limit; i++) {\r\n            if (duration < _timestamps[i]) {\r\n                return i;\r\n            }\r\n            duration -= _timestamps[i];\r\n        }\r\n        return limit - 1;\r\n    }\r\n\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\r\n    }\r\n\r\n    function isZero(address account) internal pure returns (bool) {\r\n        return (account == address(0));\r\n    }\r\n}\r\n\r\nlibrary Bytes {\r\n    function getBoolean(uint192 _packedBools, uint192 _boolNumber) internal pure returns (bool) {\r\n        uint192 flag = (_packedBools >> _boolNumber) & uint192(1);\r\n        return (flag == 1 ? true : false);\r\n    }\r\n\r\n    function setBoolean(\r\n        uint192 _packedBools,\r\n        uint192 _boolNumber,\r\n        bool _value\r\n    ) internal pure returns (uint192) {\r\n        if (_value) {\r\n            return _packedBools | (uint192(1) << _boolNumber);\r\n        } else {\r\n            return _packedBools & ~(uint192(1) << _boolNumber);\r\n        }\r\n    }\r\n\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint256 _start,\r\n        uint256 _length\r\n    ) internal pure returns (bytes memory) {\r\n        require(_length + 31 >= _length, \"slice_overflow\");\r\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\r\n        bytes memory tempBytes;\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                tempBytes := mload(0x40)\r\n                let lengthmod := and(_length, 31)\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n                for {\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n                mstore(tempBytes, _length)\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            default {\r\n                tempBytes := mload(0x40)\r\n                mstore(tempBytes, 0)\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n        return tempBytes;\r\n    }\r\n\r\n    function trim(bytes32 source) internal pure returns (bytes memory) {\r\n        uint256 temp = uint256(source);\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return slice(abi.encodePacked(source), 32 - length, length);\r\n    }\r\n}\r\n\r\nlibrary Signature {\r\n    function Derive(\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v,\r\n        bytes memory encoded\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            address derived1,\r\n            address derived2,\r\n            address derived3,\r\n            address derived4\r\n        )\r\n    {\r\n        bytes32 encoded32;\r\n        assembly {\r\n            encoded32 := mload(add(encoded, 32))\r\n        }\r\n        derived1 = ecrecover(encoded32, v, r, s);\r\n        derived2 = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", encoded32)), v, r, s);\r\n        encoded32 = keccak256(encoded);\r\n        derived3 = ecrecover(encoded32, v, r, s);\r\n        encoded32 = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", encoded32));\r\n        derived4 = ecrecover(encoded32, v, r, s);\r\n    }\r\n\r\n    function PackMessage(bytes memory encoded, bool geth) internal pure returns (bytes32) {\r\n        bytes32 hash = keccak256(encoded);\r\n        if (geth) {\r\n            hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n        }\r\n        return hash;\r\n    }\r\n\r\n    function Valid(\r\n        address target,\r\n        bytes32 r,\r\n        bytes32 s,\r\n        uint8 v,\r\n        bytes memory encoded\r\n    ) internal pure returns (bool) {\r\n        bytes32 encoded32;\r\n        address derived;\r\n        if (encoded.length == 32) {\r\n            assembly {\r\n                encoded32 := mload(add(encoded, 32))\r\n            }\r\n            derived = ecrecover(encoded32, v, r, s);\r\n            if (target == derived) {\r\n                return true;\r\n            }\r\n            derived = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", encoded32)), v, r, s);\r\n            if (target == derived) {\r\n                return true;\r\n            }\r\n        }\r\n        bytes32 hash = keccak256(encoded);\r\n        derived = ecrecover(hash, v, r, s);\r\n        if (target == derived) {\r\n            return true;\r\n        }\r\n        hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n        derived = ecrecover(hash, v, r, s);\r\n        return target == derived;\r\n    }\r\n}\r\n\r\nlibrary Strings {\r\n    function toHexString(address account) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(account)));\r\n    }\r\n\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = bytes16(\"0123456789abcdef\")[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\nstruct CollectionData {\r\n    bytes32 name;\r\n    bytes32 name2;\r\n    bytes32 symbol;\r\n    address royalties;\r\n    uint96 bps;\r\n}\r\n\r\nstruct Token {\r\n    address collection;\r\n    uint256 tokenId;\r\n    InterfaceType tokenType;\r\n    address creator;\r\n}\r\n\r\nstruct TokenData {\r\n    bytes32 payloadHash;\r\n    Verification payloadSignature;\r\n    address creator;\r\n    bytes32 arweave;\r\n    bytes11 arweave2;\r\n    bytes32 ipfs;\r\n    bytes14 ipfs2;\r\n}\r\n\r\nstruct Verification {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n}\r\n\r\n// This is a 256 value limit (uint8)\r\nenum InterfaceType {\r\n    NULL, // 0\r\n    ERC20, // 1\r\n    ERC721, // 2\r\n    ERC1155 // 3\r\n}\r\n\r\n// This is a 256 value limit (uint8)\r\nenum UriType {\r\n    ARWEAVE, // 0\r\n    IPFS, // 1\r\n    HTTP // 2\r\n}\r\n\r\ninterface ICxipERC721 {\r\n    function arweaveURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    function contractURI() external view returns (string memory);\r\n\r\n    function creator(uint256 tokenId) external view returns (address);\r\n\r\n    function httpURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    function ipfsURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function payloadHash(uint256 tokenId) external view returns (bytes32);\r\n\r\n    function payloadSignature(uint256 tokenId) external view returns (Verification memory);\r\n\r\n    function payloadSigner(uint256 tokenId) external view returns (address);\r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n    /* Disabled due to tokenEnumeration not enabled.\r\n    function tokensOfOwner(\r\n        address wallet\r\n    ) external view returns (uint256[] memory);\r\n    */\r\n\r\n    function verifySHA256(bytes32 hash, bytes calldata payload) external pure returns (bool);\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function burn(uint256 tokenId) external;\r\n\r\n    function init(address newOwner, CollectionData calldata collectionData) external;\r\n\r\n    /* Disabled since this flow has not been agreed on.\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n    */\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external payable;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) external payable;\r\n\r\n    function setApprovalForAll(address to, bool approved) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external payable;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) external payable;\r\n\r\n    function cxipMint(uint256 id, TokenData calldata tokenData) external returns (uint256);\r\n\r\n    function setApprovalForAll(\r\n        address from,\r\n        address to,\r\n        bool approved\r\n    ) external;\r\n\r\n    function setName(bytes32 newName, bytes32 newName2) external;\r\n\r\n    function setSymbol(bytes32 newSymbol) external;\r\n\r\n    function transferOwnership(address newOwner) external;\r\n\r\n    /*\r\n    // Disabled due to tokenEnumeration not enabled.\r\n    function balanceOf(address wallet) external view returns (uint256);\r\n    */\r\n    function baseURI() external view returns (string memory);\r\n\r\n    function getApproved(uint256 tokenId) external view returns (address);\r\n\r\n    function getIdentity() external view returns (address);\r\n\r\n    function isApprovedForAll(address wallet, address operator) external view returns (bool);\r\n\r\n    function isOwner() external view returns (bool);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n\r\n    /* Disabled due to tokenEnumeration not enabled.\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n    */\r\n\r\n    /* Disabled due to tokenEnumeration not enabled.\r\n    function tokenOfOwnerByIndex(\r\n        address wallet,\r\n        uint256 index\r\n    ) external view returns (uint256);\r\n    */\r\n\r\n    /* Disabled due to tokenEnumeration not enabled.\r\n    function totalSupply() external view returns (uint256);\r\n    */\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external pure returns (bytes4);\r\n}\r\n\r\ninterface ICxipIdentity {\r\n    function addSignedWallet(\r\n        address newWallet,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    function addWallet(address newWallet) external;\r\n\r\n    function connectWallet() external;\r\n\r\n    function createERC721Token(\r\n        address collection,\r\n        uint256 id,\r\n        TokenData calldata tokenData,\r\n        Verification calldata verification\r\n    ) external returns (uint256);\r\n\r\n    function createERC721Collection(\r\n        bytes32 saltHash,\r\n        address collectionCreator,\r\n        Verification calldata verification,\r\n        CollectionData calldata collectionData\r\n    ) external returns (address);\r\n\r\n    function createCustomERC721Collection(\r\n        bytes32 saltHash,\r\n        address collectionCreator,\r\n        Verification calldata verification,\r\n        CollectionData calldata collectionData,\r\n        bytes32 slot,\r\n        bytes memory bytecode\r\n    ) external returns (address);\r\n\r\n    function init(address wallet, address secondaryWallet) external;\r\n\r\n    function getAuthorizer(address wallet) external view returns (address);\r\n\r\n    function getCollectionById(uint256 index) external view returns (address);\r\n\r\n    function getCollectionType(address collection) external view returns (InterfaceType);\r\n\r\n    function getWallets() external view returns (address[] memory);\r\n\r\n    function isCollectionCertified(address collection) external view returns (bool);\r\n\r\n    function isCollectionRegistered(address collection) external view returns (bool);\r\n\r\n    function isNew() external view returns (bool);\r\n\r\n    function isOwner() external view returns (bool);\r\n\r\n    function isTokenCertified(address collection, uint256 tokenId) external view returns (bool);\r\n\r\n    function isTokenRegistered(address collection, uint256 tokenId) external view returns (bool);\r\n\r\n    function isWalletRegistered(address wallet) external view returns (bool);\r\n\r\n    function listCollections(uint256 offset, uint256 length) external view returns (address[] memory);\r\n\r\n    function nextNonce(address wallet) external view returns (uint256);\r\n\r\n    function totalCollections() external view returns (uint256);\r\n\r\n    function isCollectionOpen(address collection) external pure returns (bool);\r\n}\r\n\r\ninterface ICxipProvenance {\r\n    function createIdentity(\r\n        bytes32 saltHash,\r\n        address wallet,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256, address);\r\n\r\n    function createIdentityBatch(\r\n        bytes32 saltHash,\r\n        address[] memory wallets,\r\n        uint8[] memory V,\r\n        bytes32[] memory RS\r\n    ) external returns (uint256, address);\r\n\r\n    function getIdentity() external view returns (address);\r\n\r\n    function getWalletIdentity(address wallet) external view returns (address);\r\n\r\n    function informAboutNewWallet(address newWallet) external;\r\n\r\n    function isIdentityValid(address identity) external view returns (bool);\r\n\r\n    function nextNonce(address wallet) external view returns (uint256);\r\n}\r\n\r\ninterface ICxipRegistry {\r\n    function getAsset() external view returns (address);\r\n\r\n    function getAssetSigner() external view returns (address);\r\n\r\n    function getAssetSource() external view returns (address);\r\n\r\n    function getCopyright() external view returns (address);\r\n\r\n    function getCopyrightSource() external view returns (address);\r\n\r\n    function getCustomSource(bytes32 name) external view returns (address);\r\n\r\n    function getCustomSourceFromString(string memory name) external view returns (address);\r\n\r\n    function getERC1155CollectionSource() external view returns (address);\r\n\r\n    function getERC721CollectionSource() external view returns (address);\r\n\r\n    function getIdentitySource() external view returns (address);\r\n\r\n    function getPA1D() external view returns (address);\r\n\r\n    function getPA1DSource() external view returns (address);\r\n\r\n    function getProvenance() external view returns (address);\r\n\r\n    function getProvenanceSource() external view returns (address);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function setAsset(address proxy) external;\r\n\r\n    function setAssetSigner(address source) external;\r\n\r\n    function setAssetSource(address source) external;\r\n\r\n    function setCopyright(address proxy) external;\r\n\r\n    function setCopyrightSource(address source) external;\r\n\r\n    function setCustomSource(string memory name, address source) external;\r\n\r\n    function setERC1155CollectionSource(address source) external;\r\n\r\n    function setERC721CollectionSource(address source) external;\r\n\r\n    function setIdentitySource(address source) external;\r\n\r\n    function setPA1D(address proxy) external;\r\n\r\n    function setPA1DSource(address source) external;\r\n\r\n    function setProvenance(address proxy) external;\r\n\r\n    function setProvenanceSource(address source) external;\r\n}\r\n\r\ninterface IPA1D {\r\n    function init(\r\n        uint256 tokenId,\r\n        address payable receiver,\r\n        uint256 bp\r\n    ) external;\r\n\r\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool);\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"PermanentURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"arweaveURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"evolve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBroker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIdentity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintingClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"mintingClosed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMutationRequirements\",\"outputs\":[{\"internalType\":\"uint256[8]\",\"name\":\"\",\"type\":\"uint256[8]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStateTimestamps\",\"outputs\":[{\"internalType\":\"uint256[8]\",\"name\":\"\",\"type\":\"uint256[8]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStatesConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"future0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"future1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"future2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"future3\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenDataIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenLimit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"httpURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"name2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"symbol\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"royalties\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"bps\",\"type\":\"uint96\"}],\"internalType\":\"struct CollectionData\",\"name\":\"collectionData\",\"type\":\"tuple\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ipfsURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"payloadSignature\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"arweave\",\"type\":\"bytes32\"},{\"internalType\":\"bytes11\",\"name\":\"arweave2\",\"type\":\"bytes11\"},{\"internalType\":\"bytes32\",\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"internalType\":\"bytes14\",\"name\":\"ipfs2\",\"type\":\"bytes14\"}],\"internalType\":\"struct TokenData[]\",\"name\":\"tokenData\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"verification\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"payloadHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"payloadSignature\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"payloadSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"payloadSignature\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"arweave\",\"type\":\"bytes32\"},{\"internalType\":\"bytes11\",\"name\":\"arweave2\",\"type\":\"bytes11\"},{\"internalType\":\"bytes32\",\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"internalType\":\"bytes14\",\"name\":\"ipfs2\",\"type\":\"bytes14\"}],\"internalType\":\"struct TokenData\",\"name\":\"tokenData\",\"type\":\"tuple\"}],\"name\":\"prepareMintData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"payloadSignature\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"arweave\",\"type\":\"bytes32\"},{\"internalType\":\"bytes11\",\"name\":\"arweave2\",\"type\":\"bytes11\"},{\"internalType\":\"bytes32\",\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"internalType\":\"bytes14\",\"name\":\"ipfs2\",\"type\":\"bytes14\"}],\"internalType\":\"struct TokenData[]\",\"name\":\"tokenData\",\"type\":\"tuple[]\"}],\"name\":\"prepareMintDataBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"broker\",\"type\":\"address\"}],\"name\":\"setBroker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setMintingClosed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[8]\",\"name\":\"_limits\",\"type\":\"uint256[8]\"}],\"name\":\"setMutationRequirements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newName\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"newName2\",\"type\":\"bytes32\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[8]\",\"name\":\"_timestamps\",\"type\":\"uint256[8]\"}],\"name\":\"setStateTimestamps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"future0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"future1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"future2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"future3\",\"type\":\"uint256\"}],\"name\":\"setStatesConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newSymbol\",\"type\":\"bytes32\"}],\"name\":\"setSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenLimit\",\"type\":\"uint256\"}],\"name\":\"setTokenLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"verifySHA256\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SNUFFY500","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6849c6ad41264d9410fe26661f44f9bfa266cd128fb5323adb2ee68ad9c59042"}]}