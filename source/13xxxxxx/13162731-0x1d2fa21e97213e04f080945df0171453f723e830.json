{"status":"1","message":"OK","result":[{"SourceCode":"{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n  \\n\\n\\t/**\\n\\t* @dev Returns true if `account` is a contract.\\n\\t*\\n\\t* [IMPORTANT]\\n\\t* ====\\n\\t* It is unsafe to assume that an address for which this function returns\\n\\t* false is an externally-owned account (EOA) and not a contract.\\n\\t*\\n\\t* Among others, `isContract` will return false for the following\\n\\t* types of addresses:\\n\\t*\\n\\t*  - an externally-owned account\\n\\t*  - a contract in construction\\n\\t*  - an address where a contract will be created\\n\\t*  - an address where a contract lived, but was destroyed\\n\\t* ====\\n\\t*/\\n\\tfunction isContract(address account) internal view returns (bool) {\\n\\t// This method relies on extcodesize, which returns 0 for contracts in\\n\\t// construction, since the code is only stored at the end of the\\n\\t// constructor execution.\\n\\n\\tuint256 size;\\n\\t// solhint-disable-next-line no-inline-assembly\\n\\tassembly { size := extcodesize(account) }\\n\\treturn size \\u003e 0;\\n\\t}\\n\\n\\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n\\t\\treturn functionCall(target, data, \\\"Address: low-level call failed\\\");\\n\\t}\\n\\n\\t/**\\n\\t\\t* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n\\t\\t* `errorMessage` as a fallback revert reason when `target` reverts.\\n\\t\\t*\\n\\t\\t* _Available since v3.1._\\n\\t\\t*/\\n\\tfunction functionCall(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tstring memory errorMessage\\n\\t) internal returns (bytes memory) {\\n\\t\\treturn functionCallWithValue(target, data, 0, errorMessage);\\n\\t}\\n\\n\\t/**\\n\\t\\t* @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n\\t\\t* but also transferring `value` wei to `target`.\\n\\t\\t*\\n\\t\\t* Requirements:\\n\\t\\t*\\n\\t\\t* - the calling contract must have an ETH balance of at least `value`.\\n\\t\\t* - the called Solidity function must be `payable`.\\n\\t\\t*\\n\\t\\t* _Available since v3.1._\\n\\t\\t*/\\n\\tfunction functionCallWithValue(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tuint256 value\\n\\t) internal returns (bytes memory) {\\n\\t\\treturn functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n\\t}\\n\\n\\n\\t/**\\n\\t\\t* @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n\\t\\t* with `errorMessage` as a fallback revert reason when `target` reverts.\\n\\t\\t*\\n\\t\\t* _Available since v3.1._\\n\\t\\t*/\\n\\tfunction functionCallWithValue(\\n\\t\\taddress target,\\n\\t\\tbytes memory data,\\n\\t\\tuint256 value,\\n\\t\\tstring memory errorMessage\\n\\t) internal returns (bytes memory) {\\n\\t\\trequire(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n\\t\\trequire(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n\\t\\t(bool success, bytes memory returndata) = target.call{value: value}(data);\\n\\t\\treturn verifyCallResult(success, returndata, errorMessage);\\n\\t}\\n\\n\\n\\t/**\\n\\t\\t* @dev Tool to verifies that a low level call was successful, and revert if it wasn\\u0027t, either by bubbling the\\n\\t\\t* revert reason using the provided one.\\n\\t\\t*\\n\\t\\t* _Available since v4.3._\\n\\t\\t*/\\n\\tfunction verifyCallResult(\\n\\t\\tbool success,\\n\\t\\tbytes memory returndata,\\n\\t\\tstring memory errorMessage\\n\\t) internal pure returns (bytes memory) {\\n\\t\\tif (success) {\\n\\t\\t\\treturn returndata;\\n\\t\\t} else {\\n\\t\\t\\t// Look for revert reason and bubble it up if present\\n\\t\\t\\tif (returndata.length \\u003e 0) {\\n\\t\\t\\t\\t// The easiest way to bubble the revert reason is using memory via assembly\\n\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tlet returndata_size := mload(returndata)\\n\\t\\t\\t\\t\\trevert(add(32, returndata), returndata_size)\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trevert(errorMessage);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nabstract contract IERC20 {\\n  function transfer(address to, uint tokens) public virtual returns (bool success);\\n  function balanceOf(address _sender) public virtual view returns (uint _bal);\\n  function allowance(address tokenOwner, address spender) public virtual view returns (uint remaining);\\n  event Transfer(address indexed from, address indexed to, uint tokens);\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n  function transferFrom(address from, address to, uint tokens) public virtual returns (bool success);\\n}\"},\"MarktPlace.sol\":{\"content\":\"\\n// SPDX-License-Identifier: MIT\\n\\n// This version supports ETH and ERC20\\npragma solidity 0.8.0;\\nimport \\\"./SafeErc20.sol\\\";\\n\\ninterface IERC721 {\\n  function transferFrom(address _from, address _to, uint256 _tokenId) external;\\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _value, bytes calldata _data) external;\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ninterface IERC1155 {\\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n}\\n\\ninterface ISecondaryMarketFees {\\n  struct Fee {\\n    address recipient;\\n    uint256 value;\\n  }\\n  function getFeeRecipients(uint256 tokenId) external view returns(address[] memory);\\n  function getFeeBps(uint256 tokenId) external view returns(uint256[] memory);\\n}\\n\\ncontract Marketplace {\\n\\n  using SafeERC20 for IERC20;\\n  bytes4 private constant INTERFACE_ID_FEES = 0xb7799584;\\n  address public beneficiary;\\n  address public orderSigner;\\n  address public owner;\\n\\n  enum AssetType { ETH, ERC20, ERC721, ERC1155, ERC721Deprecated }\\n  enum OrderStatus { LISTED, COMPLETED, CANCELLED }\\n\\n  struct Asset {\\n    address contractAddress;\\n    uint256 tokenId;\\n    AssetType assetType;\\n    uint256 value;\\n  }\\n\\n  struct Order {\\n    address seller;\\n    Asset sellAsset;\\n    Asset buyAsset;\\n    uint256 salt;\\n  }\\n\\n  struct Signature {\\n    bytes32 r;\\n    bytes32 s;\\n    uint8 v;\\n  }\\n\\n  mapping(bytes32 =\\u003e Order) orders;\\n  mapping(bytes32 =\\u003e OrderStatus) public orderStatus;\\n\\n  event Buy(\\n    address indexed sellContract, uint256 indexed sellTokenId, uint256 sellValue,\\n    address owner,\\n    address buyContract, uint256 buyTokenId, uint256 buyValue,\\n    address buyer,\\n    uint256 salt\\n  );\\n\\n  modifier onlyOwner() {\\n    require(msg.sender == owner, \\\"Only owner is allowed\\\");\\n    _;\\n  }\\n\\n  constructor(address _beneficiary, address _orderSigner) {\\n    beneficiary = _beneficiary;\\n    orderSigner = _orderSigner;\\n    owner = msg.sender;\\n  }\\n\\n  function updateOrderSigner(address newOrderSigner) public onlyOwner {\\n    orderSigner =  newOrderSigner;\\n  }\\n\\n  function updateBeneficiary(address newBeneficiary) public onlyOwner {\\n    beneficiary = newBeneficiary;\\n  }\\n\\n   function exchange(\\n    Order calldata order,\\n    Signature calldata sellerSignature,\\n    Signature calldata buyerSignature,\\n    address buyer,\\n    uint256 sellerFee,\\n    uint256 buyerFee\\n  ) public payable {\\n    if(buyer == address(0)) buyer = msg.sender;\\n\\n    validateSellerSignature(order, sellerFee, sellerSignature);\\n    validateBuyerSignature(order, buyer, buyerFee, buyerSignature);\\n    \\n    require(order.sellAsset.assetType == AssetType.ERC721 || order.sellAsset.assetType == AssetType.ERC1155  , \\\"Only ERC721 are supported on seller side\\\");\\n    require(order.buyAsset.assetType == AssetType.ETH || order.buyAsset.assetType == AssetType.ERC20, \\\"Only Eth/ERC20 supported on buy side\\\");\\n    require(order.buyAsset.tokenId == 0, \\\"Buy token id must be UINT256_MAX\\\");\\n    if(order.buyAsset.assetType == AssetType.ETH) {\\n      validateEthTransfer(order.buyAsset.value, buyerFee);\\n    }\\n\\n    uint256 remainingAmount = transferFeeToBeneficiary(\\n      order.buyAsset, \\n      buyer,\\n      order.buyAsset.value,\\n      sellerFee,\\n      buyerFee\\n    );\\n\\n    transfer(order.sellAsset, order.seller, buyer, order.sellAsset.value);\\n    transferWithFee(order.buyAsset, buyer, order.seller, remainingAmount, order.sellAsset);\\n    emitBuy(order, buyer);\\n  }\\n\\n  \\n  function transferFeeToBeneficiary(\\n    Asset memory asset, address from, uint256 amount, uint256 sellerFee, uint256 buyerFee\\n  ) internal returns(uint256) {\\n    uint256 sellerCommission = getPercentageCalc(amount, sellerFee);\\n    uint256 buyerCommission = getPercentageCalc(amount, buyerFee);\\n    require(sellerCommission \\u003c= amount, \\\"Seller commission exceeds amount\\\");\\n    uint256 totalCommission = sellerCommission + buyerCommission;\\n    if(totalCommission \\u003e 0) {\\n      transfer(asset, from, beneficiary, totalCommission);\\n    }\\n    return amount - sellerCommission;\\n  }\\n\\n  function transferWithFee(\\n    Asset memory _primaryAsset,\\n    address from,\\n    address to,\\n    uint256 amount,\\n    Asset memory _secondaryAsset\\n  ) internal {\\n    uint256 remainingAmount = amount;\\n    if(supportsSecondaryFees(_secondaryAsset)) {\\n      ISecondaryMarketFees _secondaryMktContract = ISecondaryMarketFees(_secondaryAsset.contractAddress);\\n      address[] memory recipients = _secondaryMktContract.getFeeRecipients(_secondaryAsset.tokenId);\\n      uint[] memory fees = _secondaryMktContract.getFeeBps(_secondaryAsset.tokenId);\\n      require(fees.length == recipients.length, \\\"Invalid fees arguments\\\");\\n      for(uint256 i=0; i\\u003cfees.length; i++) {\\n        uint256 _fee = getPercentageCalc(_primaryAsset.value, fees[i]);\\n        remainingAmount = remainingAmount - _fee;\\n        transfer(_primaryAsset, from, recipients[i], _fee);\\n      }\\n    }\\n    transfer(_primaryAsset, from, to, remainingAmount);\\n  }\\n\\n  function transfer(Asset memory _asset, address from, address to, uint256 value) internal {\\n    if(_asset.assetType == AssetType.ETH) {\\n      payable(to).transfer(value);\\n    } else if(_asset.assetType == AssetType.ERC20) {\\n      IERC20(_asset.contractAddress).safeTransferFrom(from, to, value);\\n    } else if(_asset.assetType == AssetType.ERC721) {\\n      require(value == 1, \\\"value should be 1 for ERC-721\\\");\\n      IERC721(_asset.contractAddress).safeTransferFrom(from, to, _asset.tokenId);\\n    } else if(_asset.assetType == AssetType.ERC1155) {\\n      IERC1155(_asset.contractAddress).safeTransferFrom(from, to, _asset.tokenId, value, \\\"0x\\\");\\n    } else {\\n      require(value == 1, \\\"value should be 1 for ERC-721\\\");\\n      IERC721(_asset.contractAddress).transferFrom(from, to, _asset.tokenId);\\n    }\\n  }\\n\\n  function validateEthTransfer(uint amount, uint buyerFee) internal view {\\n    uint256 buyerCommission =  getPercentageCalc(amount, buyerFee);\\n    require(msg.value == amount + buyerCommission, \\\"msg.value is incorrect\\\");\\n  }\\n\\n  function validateSellerSignature(Order calldata _order, uint256 sellerFee, Signature calldata _sig) public pure {\\n    bytes32 signature = getMessageForSeller(_order, sellerFee);\\n    require(getSigner(signature, _sig) == _order.seller, \\\"Seller must sign order data\\\");\\n  }\\n\\n  function validateBuyerSignature(Order calldata order, address buyer, uint256 buyerFee,\\n    Signature calldata sig) public view {\\n    bytes32 message = getMessageForBuyer(order, buyer, buyerFee);\\n    require(getSigner(message, sig) == orderSigner, \\\"Order signer must sign\\\");\\n  }\\n\\n  function getMessageForSeller(Order calldata order, uint256 sellerFee) public pure returns(bytes32) {\\n    return keccak256(abi.encode(order, sellerFee));\\n  }\\n\\n  function getMessageForBuyer(Order calldata order, address buyer, uint256 buyerFee) public pure returns(bytes32) {\\n    return keccak256(abi.encode(order, buyer, buyerFee));\\n  }\\n\\n  function getSigner(bytes32 message, Signature memory _sig) public pure returns (address){\\n    bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\n    return ecrecover(keccak256(abi.encodePacked(prefix, message)),_sig.v, _sig.r, _sig.s);\\n  }\\n\\n  function emitBuy(Order calldata order, address buyer) internal {\\n    emit Buy(\\n      order.sellAsset.contractAddress,\\n      order.sellAsset.tokenId,\\n      order.sellAsset.value,\\n      order.seller,\\n      order.buyAsset.contractAddress,\\n      order.buyAsset.tokenId,\\n      order.buyAsset.value,\\n      buyer,\\n      order.salt\\n    );\\n  }\\n\\n  function getPercentageCalc(uint256 totalValue, uint _percentage) internal pure returns(uint256) {\\n    return (totalValue * _percentage) / 1000 / 100;\\n  }\\n  \\n  function supportsSecondaryFees(Asset memory asset) internal view returns(bool) {\\n    return (\\n      (asset.assetType == AssetType.ERC1155 \\u0026\\u0026\\n      IERC1155(asset.contractAddress).supportsInterface(INTERFACE_ID_FEES)) ||\\n      ( isERC721(asset.assetType) \\u0026\\u0026\\n      IERC721(asset.contractAddress).supportsInterface(INTERFACE_ID_FEES))\\n    );\\n  }\\n  \\n  function isERC721(AssetType assetType) internal pure returns(bool){\\n    return assetType == AssetType.ERC721 || assetType == AssetType.ERC721Deprecated;\\n  }\\n\\n}\"},\"SafeErc20.sol\":{\"content\":\"\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    \\n\\tusing Address for address;\\n\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n  \\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n        // we\\u0027re implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n        // functionCall(target, data, \\\"Address: low-level call failed\\\")\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length \\u003e 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_orderSigner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sellContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"sellTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum Marketplace.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum Marketplace.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Marketplace.Signature\",\"name\":\"sellerSignature\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Marketplace.Signature\",\"name\":\"buyerSignature\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyerFee\",\"type\":\"uint256\"}],\"name\":\"exchange\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum Marketplace.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum Marketplace.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buyerFee\",\"type\":\"uint256\"}],\"name\":\"getMessageForBuyer\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum Marketplace.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum Marketplace.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"sellerFee\",\"type\":\"uint256\"}],\"name\":\"getMessageForSeller\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"message\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Marketplace.Signature\",\"name\":\"_sig\",\"type\":\"tuple\"}],\"name\":\"getSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderStatus\",\"outputs\":[{\"internalType\":\"enum Marketplace.OrderStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"updateBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOrderSigner\",\"type\":\"address\"}],\"name\":\"updateOrderSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum Marketplace.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum Marketplace.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buyerFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Marketplace.Signature\",\"name\":\"sig\",\"type\":\"tuple\"}],\"name\":\"validateBuyerSignature\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum Marketplace.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Asset\",\"name\":\"sellAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum Marketplace.AssetType\",\"name\":\"assetType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Asset\",\"name\":\"buyAsset\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"internalType\":\"struct Marketplace.Order\",\"name\":\"_order\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"sellerFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Marketplace.Signature\",\"name\":\"_sig\",\"type\":\"tuple\"}],\"name\":\"validateSellerSignature\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"Marketplace","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000a1df4a4896d6c95b4f940b113e59e262badadde50000000000000000000000003d66572794966c4e8bae5021219929482e1914f1","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://ae2f776dbf7ac2d8209bab108ef6bd2dff2d372705489cf59fb857b2bda6a733"}]}