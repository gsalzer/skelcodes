{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Exchange_V6.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.11;\\n\\nimport \\\"./interface/IAzimuth.sol\\\";\\nimport \\\"./interface/IEcliptic.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n\\ncontract UrbitexExchange is Context, Ownable {\\n\\n    //  azimuth: points state data store\\n    //\\n    IAzimuth public azimuth;\\n    \\n    // fee: exchange transaction fee \\n    // \\n    uint32 public fee;\\n\\n    // priceMin: the minimum price allowed to be set for a point\\n    // \\n    uint256 public priceMin;\\n\\n    // ListedAsset: struct which stores the price and seller's address for a point listed in the marketplace\\n    // \\n    struct ListedAsset {\\n        address addr;\\n        uint256 price;\\n    }\\n\\n    // assets: registry which stores the ListedAsset entries\\n    //\\n    mapping(uint32 => ListedAsset) assets;\\n\\n    // EVENTS\\n\\n    event MarketPurchase(\\n        address indexed _from,\\n        address indexed _to,\\n        uint32 _point,\\n        uint256 _price\\n    );\\n\\n    event ListingRemoved(\\n        uint32 _point\\n    );\\n\\n    event ListingAdded(\\n        uint32 _point,\\n        uint256 _price \\n    );\\n\\n    // IMPLEMENTATION\\n\\n    //  constructor(): configure the points data store, exchange fee, and minimum listing price.\\n    //\\n    constructor(IAzimuth _azimuth, uint32 _fee, uint256 _priceMin) \\n        payable \\n    {     \\n        azimuth = _azimuth;\\n        setFee(_fee);\\n        setPriceMin(_priceMin);\\n    }\\n\\n    // setRegistryEntry(): utility function to add or remove entries in the registry\\n    function setRegistryEntry(uint32 _point, address _address, uint256 _price) internal\\n    {\\n        ListedAsset memory asset = assets[_point];\\n\\n        asset = ListedAsset({\\n             addr: _address,\\n             price: _price\\n          });\\n\\n        assets[_point] = asset;\\n    }\\n\\n    //  purchase(): purchase and transfer point from the seller to the buyer\\n    //\\n    function purchase(uint32 _point)\\n        external\\n        payable\\n    {\\n        IEcliptic ecliptic = IEcliptic(azimuth.owner());\\n        \\n        // get the point's owner \\n        address payable seller = payable(azimuth.getOwner(_point));\\n\\n        // get the point's information from the registry\\n        ListedAsset memory asset = assets[_point];\\n\\n        // check that the address in the registry matches the point's current owner\\n        require(asset.addr == seller, \\\"seller address does not match registry\\\");\\n\\n        // buyer must pay the exact price as what's stored in the registry for that point\\n        require(msg.value == asset.price, \\\"Amount transferred does not match price in registry\\\");\\n\\n        // in order to save on gas fees, a check that the seller has approved the exchange as a \\n        // transfer proxy can happen off-chain. \\n\\n        // when all conditions are met, transfer the point from the seller to the buyer\\n        ecliptic.transferFrom(seller, _msgSender(), _point); \\n\\n        // set the price of the point in the registry to 0 and clear the associated address.\\n        // 'asset' already declared in memory so not using the utility function this time\\n        // \\n        asset = ListedAsset({\\n             addr: address(0),\\n             price: 0\\n          });\\n\\n        assets[_point] = asset;\\n\\n        // deduct exchange fee and transfer remaining amount to the seller\\n        seller.transfer(msg.value/100000*(100000-fee));    \\n\\n        emit MarketPurchase(seller, _msgSender(), _point, msg.value);\\n    }\\n\\n    // addListing(): add a point to the registry, including its corresponding price and owner address\\n    //\\n    function addListing(uint32 _point, uint256 _price) external\\n    {\\n        // intentionally using isOwner() instead of canTransfer(), which excludes third-party proxy addresses.\\n        // this will ensure the exchange owner also cannot maliciously list an owner's points.\\n        // \\n        require(azimuth.isOwner(_point, _msgSender()), \\\"The message sender is not the point owner\\\");\\n        \\n        // listed price must be greater than the minimum price set by the exchange\\n        require(priceMin < _price, \\\"The listed price must exceed the minimum price set by the exchange\\\");\\n\\n        // add the price of the point and the seller address to the registry\\n        //         \\n        setRegistryEntry(_point, _msgSender(), _price);        \\n        \\n        emit ListingAdded(_point, _price);\\n\\n    }\\n\\n    // removeListing(): clear the information for this point in the registry. This function has also been made available\\n    // to the exchange owner to remove stale listings.\\n    //\\n    function removeListing(uint32 _point) external \\n    {   \\n        require(azimuth.isOwner(_point, _msgSender()) || _msgSender() == owner(), \\\"The message sender is not the point owner or the exchange owner\\\");\\n        \\n        setRegistryEntry(_point, address(0), 0);\\n\\n        emit ListingRemoved(_point);\\n    }\\n\\n    // getPointInfo(): check the listed price and seller address of a point \\n    // \\n    function getPointInfo(uint32 _point) external view returns (address, uint256) {\\n        return (assets[_point].addr, assets[_point].price);\\n    }\\n\\n    // EXCHANGE OWNER OPERATIONS\\n     \\n    // setFee(): the fee calculation is a percentage of the listed price.\\n    // for example, an input of 2500 here will be 2.5%\\n    // \\n    function setFee(uint32 _fee) public onlyOwner  {\\n        require(100000 > _fee, \\\"Input value must be less than 100000\\\");\\n        fee = _fee;\\n    }\\n    // setPriceMin(): the minimum listed price allowed by the exchange\\n    function setPriceMin(uint256 _priceMin) public onlyOwner  {\\n        require(0 < _priceMin, \\\"Minimum price must be greater than 0\\\");\\n        priceMin = _priceMin;\\n    }\\n             \\n    function withdraw(address payable _target) external onlyOwner  {\\n        require(address(0) != _target);\\n        _target.transfer(address(this).balance);\\n    }\\n\\n    function close(address payable _target) external onlyOwner  {\\n        require(address(0) != _target);\\n        selfdestruct(_target);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IAzimuth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IAzimuth {\\n    function owner() external returns (address);\\n    function isSpawnProxy(uint32, address) external returns (bool);\\n    function hasBeenLinked(uint32) external returns (bool);\\n    function getPrefix(uint32) external returns (uint16);\\n    function getOwner(uint32) view external returns (address);\\n    function canTransfer(uint32, address) view external returns (bool);\\n    function isOwner(uint32, address) view external returns (bool);\\n}    \\n\"\r\n    },\r\n    \"contracts/interface/IEcliptic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IEcliptic {\\n    function isApprovedForAll(address, address) external returns (bool);\\n    function transferFrom(address, address, uint256) external;\\n    function spawn(uint32, address) external;\\n    function transferPoint(uint32, address, bool) external;\\n\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IAzimuth\",\"name\":\"_azimuth\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_fee\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_priceMin\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_point\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"ListingAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_point\",\"type\":\"uint32\"}],\"name\":\"ListingRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_point\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"MarketPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_point\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"addListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"azimuth\",\"outputs\":[{\"internalType\":\"contract IAzimuth\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"close\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_point\",\"type\":\"uint32\"}],\"name\":\"getPointInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_point\",\"type\":\"uint32\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_point\",\"type\":\"uint32\"}],\"name\":\"removeListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_fee\",\"type\":\"uint32\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_priceMin\",\"type\":\"uint256\"}],\"name\":\"setPriceMin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"UrbitexExchange","CompilerVersion":"v0.8.11+commit.d7f03943","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"000000000000000000000000223c067f8cf28ae173ee5cafea60ca44c335fecb000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005af3107a4000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}