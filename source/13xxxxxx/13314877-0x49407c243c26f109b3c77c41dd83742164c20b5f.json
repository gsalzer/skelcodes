{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/LP_Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.1;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ncontract LP_Staking {\\n  // balances are stored as uint168 so the structs take up one storage\\n  // slot instead of two\\n  struct User {\\n    bool has_prerewards;\\n    uint8 epoch_start;\\n    uint168 balance;\\n  }\\n\\n  // Track the total balance for each epoch, such that a per user reward share\\n  // can be calculated effectively\\n  struct Epoch {\\n    uint8 epoch_number;\\n    uint248 balance;\\n  }\\n\\n  // Prerewards are compensation for LP holders before this contract was\\n  // deployed. The shares are calculated off-chain and added after deployment.\\n  // We use 20 bytes for address and 12 bytes for share\\n  struct Prereward {\\n    address user;\\n    uint104 share;\\n  }\\n\\n  uint256 public immutable staking_start;\\n  uint256 public immutable staking_end;\\n\\n  uint256 public immutable epoch_seconds;\\n  uint8 public immutable epoch_count;\\n\\n  uint256 public immutable epoch_reward;\\n\\n  IERC20 public immutable trusted_lp_token;\\n  IERC20 public immutable trusted_reward_token;\\n\\n  address immutable rewards_refund;\\n\\n  // List of epochs. Note that this array can have \\\"gaps\\\", such that successive\\n  // epochs are always monotonically increasing, but many to be exactly one\\n  // increment after the other\\n  Epoch[] public epochs;\\n  mapping (address => User) public users;\\n\\n  uint256 prerewards_total;\\n  // We promote the uint104 share to uint256\\n  mapping (address => uint256) public prerewards;\\n\\n  // Precision here is based on our cap of 168 bits per user balance.\\n  // Read this as '88 bits', as we use bit shift to move the precision up and\\n  // down in the rewards calculation\\n  uint256 constant PRECISION = 88;\\n\\n  // This precision is directly controlled as we store 104 bits of share data\\n  uint256 PREREWARD_PRECISION = 88;\\n\\n  address controller;\\n\\n  constructor (\\n    address lp_token_address,\\n    address reward_token_address,\\n    uint8 _epoch_count,\\n    uint256 _epoch_seconds,\\n    uint256 _epoch_reward,\\n    address _rewards_refund\\n  ) {\\n    staking_start = block.timestamp;\\n    staking_end = block.timestamp + _epoch_count * _epoch_seconds;\\n\\n    epoch_count = _epoch_count;\\n    epoch_seconds = _epoch_seconds;\\n    epoch_reward = _epoch_reward;\\n\\n    trusted_lp_token = IERC20(lp_token_address);\\n    trusted_reward_token = IERC20(reward_token_address);\\n\\n    // We add the first epoch as our base-case.\\n    // I believe this could be optimised to just manipulate the length\\n    // of epochs\\n    epochs.push(Epoch(0, 0));\\n\\n    controller = msg.sender;\\n    rewards_refund = _rewards_refund;\\n  }\\n\\n  function get_current_epoch_number () public view returns (uint8) {\\n    // First statement here is unreacable as block.timestamp is always monotonic\\n    // increasing\\n    // if (block.timestamp < staking_start) return 0;\\n    if (block.timestamp > staking_end) return epoch_count;\\n\\n    return uint8((block.timestamp - staking_start) / epoch_seconds);\\n  }\\n\\n  function total_staked_for_user (\\n    address user\\n  ) external view returns (\\n    uint256\\n  ) {\\n    return uint256(users[user].balance);\\n  }\\n\\n  function get_available_reward (address user) external view returns (uint256) {\\n    return _reward_balance(user);\\n  }\\n\\n  function total_staked () external view returns (uint256) {\\n    return uint256(epochs[epochs.length - 1].balance);\\n  }\\n\\n  function init_prerewards (\\n    Prereward[] calldata _users,\\n    uint256 _prerewards_total\\n  ) external only_controller {\\n    prerewards_total = _prerewards_total;\\n    for (uint idx = 0; idx < _users.length; idx++) {\\n      Prereward calldata pr = _users[idx];\\n\\n      users[pr.user].has_prerewards = true;\\n      prerewards[pr.user] = pr.share;\\n    }\\n  }\\n\\n  // Notes:\\n  // - You cannot stake 0 tokens\\n  // - You must unstake before you can restake\\n  // - You cannot stake more than 2**168\\n  //   (rather no more than 2**248 can be staked in total)\\n  // - You cannot stake in the very last epoch\\n  function stake (uint168 value) external returns (bool) {\\n    require(value > 0, \\\"Must provide positive stake amount\\\");\\n\\n    User storage user = users[msg.sender];\\n    require(user.balance == 0, \\\"Must unstake before stake\\\");\\n\\n    uint8 epoch_number = get_current_epoch_number();\\n    require(epoch_number < epoch_count, \\\"Staking has ended\\\");\\n\\n    Epoch storage latest_epoch = epochs[epochs.length - 1];\\n    // Check for overflow before we mutate anything\\n    require(type(uint248).max - latest_epoch.balance >= value, \\\"Total stake is too high\\\");\\n\\n    trusted_lp_token.transferFrom(msg.sender, address(this), value);\\n\\n    user.epoch_start = epoch_number;\\n    user.balance = value;\\n\\n    if (latest_epoch.epoch_number == epoch_number) {\\n      latest_epoch.balance += value;\\n    } else {\\n      epochs.push(Epoch(epoch_number, latest_epoch.balance + value));\\n    }\\n\\n    return true;\\n  }\\n\\n  function unstake () external returns (bool) {\\n    User storage user = users[msg.sender];\\n    uint168 balance = user.balance;\\n    require(balance > 0, \\\"Must stake before unstake\\\");\\n    uint256 reward = _reward_balance(msg.sender);\\n\\n    // This is the tricky part about working with epochs, so please read\\n    // carefully. We have to remember that the array of epochs is always\\n    // in order of increasing epoch_number, but can have gaps between\\n    // epochs, eg: [e0, e2, e3, e7]. Epochs are only inserted when someone\\n    // stakes or unstakes, which allows us to make some assumptions below.\\n    // From hereon forward, withdrawing rewards is the same as staking, as\\n    // that operation essentially moves up the time a user started staking to\\n    // the previous epoch.\\n    //\\n    // When looking at eg. e0, the balance is actually the total balance\\n    // staked for the next epoch, as you will only get rewarded for full\\n    // epochs. When the epoch counter increments (by virtue of time),\\n    // the latest epoch is simply \\\"drawn forward\\\", as the balance must\\n    // have been the same until someone decided to either stake or\\n    // unstake, at which point a new epoch struct must be created and\\n    // the balance updated.\\n    uint8 epoch_number = get_current_epoch_number();\\n    uint256 epoch_len = epochs.length;\\n    Epoch storage latest_epoch = epochs[epoch_len - 1];\\n\\n    // Rewards are paid for full epochs which have been staked, which gives a\\n    // couple of scenarios:\\n    //\\n    // 1. User stakes in e0 and unstakes in e0, giving no reward\\n    // 2. User stakes in e0 and unstakes in e1, giving no reward\\n    // 3. user stakes in e0 and unstakes in eN, giving rewards for e1 to e(N-1)\\n    //    both of those epochs incluseive.\\n    //\\n    // This means that unless we are in case 1. above, we have to change the\\n    // balance of two epochs for the ratio of user balance to total balance, to\\n    // be fair. This is a little subtle, but we need this as we draw balances\\n    // forward into epochs that have not vested yet, however we do not want to\\n    // compensate someone for joining the end of e0 and leaving at the start of\\n    // e1\\n\\n    // When unstaking we have two overarching cases to cover:\\n    //  1. The user staked and unstaked in the latest epoch\\n    //  2. The user staked in a previous epoch than the latest\\n\\n    // Here we cover case 1. which is the simplest, since the epoch that\\n    // the user staked in, is also the one they unstake in. `epoch_start`\\n    // can be set by `stake` and `withdraw_rewards`, however the latter\\n    // will always set it in the past, hence the strict equality can\\n    // never be true in that case. Therefore we know that the two can\\n    // only be equal, if in fact the user staked and unstaked in the\\n    // same epoch\\n    if (epoch_number == user.epoch_start) {\\n      latest_epoch.balance -= balance;\\n    }\\n    // Now we get to case 2. where the user staked in any previous epoch\\n    // and we have fix more than one epoch balance\\n    else {\\n\\n      // Let's explain the situation. We can have a couple of complicated\\n      // cases here, but remember that epochs are always in order.\\n      //\\n      // 1. Zero epochs have elapsed since someone either staked or unstaked\\n      // 2. One epoch has elapsed since someone either staked or unstaked\\n      // 3. Two or more epochs have elapsed since someone staked or unstaked\\n\\n\\n      // We're at the latest epoch\\n      if (latest_epoch.epoch_number == epoch_number) {\\n        latest_epoch.balance -= balance;\\n\\n        // We need to look at the previous epoch\\n        // There must be at least two epochs, since the latest epoch\\n        // is not the one the user staked in, but the earlies epoch someone\\n        // could stake is e0, so we must have at least e0 and e1 (or any other\\n        // combination)\\n        Epoch storage previous_epoch = epochs[epoch_len - 2];\\n        // We were lucky and they were in sequence\\n        if (previous_epoch.epoch_number == epoch_number - 1) {\\n          previous_epoch.balance -= balance;\\n        }\\n        // We have to duplicate the latest epoch and fix it up\\n        else {\\n          // This part is very subtle\\n          // We essentially clone the latest epoch by pushing it on\\n          epochs.push(latest_epoch);\\n          // then decrement the 2nd to last epoch to have two in sequence\\n          latest_epoch.epoch_number--;\\n          // We do not need to decrement the balance, as that was done\\n          // before duplicating\\n\\n          // Example:\\n          // We have: [..., e6, e8]\\n          // We then push: [..., e6, e8, e8]\\n          // And then decr: [..., e6, e8--, e8]\\n          // To get: [..., e6, e7, e8]\\n        }\\n      }\\n      // We're just one short\\n      else if (latest_epoch.epoch_number == epoch_number - 1) {\\n        // Again we can duplicate the epoch after decrementing the balance\\n        latest_epoch.balance -= balance;\\n        epochs.push(Epoch(epoch_number, latest_epoch.balance));\\n      }\\n      // We're way in the past and can add both new epochs\\n      else {\\n        epochs.push(Epoch(epoch_number - 1, latest_epoch.balance - balance));\\n        epochs.push(Epoch(epoch_number, latest_epoch.balance - balance));\\n      }\\n    }\\n\\n    // Deleting the user gives a gas refund, and there's no reason to keep their\\n    // state\\n    if (user.has_prerewards) {\\n      delete prerewards[msg.sender];\\n    }\\n\\n    delete users[msg.sender];\\n\\n    trusted_lp_token.transfer(msg.sender, balance);\\n    trusted_reward_token.transfer(msg.sender, reward);\\n    return true;\\n  }\\n\\n  function withdraw_rewards () external returns (bool) {\\n    uint256 reward = _reward_balance(msg.sender);\\n    if (reward == 0) return true;\\n\\n    uint8 epoch_number = get_current_epoch_number();\\n    User storage user = users[msg.sender];\\n    // First condition here ensures we don't underflow, as the user may\\n    // be able to withdraw rewards that come from prerewards. 2nd condition\\n    // indirectly checks that the rewards were in fact prerewards\\n    if (epoch_number > 0 && user.balance > 0) {\\n      user.epoch_start = epoch_number - 1;\\n    }\\n\\n    if (user.has_prerewards) {\\n      user.has_prerewards = false;\\n      delete prerewards[msg.sender];\\n    }\\n\\n    trusted_reward_token.transfer(msg.sender, reward);\\n    return true;\\n  }\\n\\n  function _reward_balance (address _user) internal view returns (uint256) {\\n    uint256 staking_reward = 0;\\n    User memory user = users[_user];\\n\\n    if (user.has_prerewards) {\\n      staking_reward +=\\n        (prerewards[_user] * prerewards_total) >> PREREWARD_PRECISION;\\n    }\\n\\n    // We know that zero user balance, means no rewards\\n    if (user.balance == 0) return staking_reward;\\n\\n    uint8 epoch_number = get_current_epoch_number();\\n    // We also know that at least one full epoch must elaps for there to be\\n    // any rewards. Eg. stake at t0, does not give any rewards until t2\\n    if (epoch_number <= user.epoch_start) return staking_reward;\\n\\n    uint epoch_len = epochs.length - 1;\\n    Epoch memory epoch_u = epochs[epoch_len];\\n    // The next check is kept for completeness but is redundant. If any\\n    // execution can make it to this step, the balance cannot by definiton be\\n    // zero, because some user must have balance\\n    // if (epoch_u.balance == 0) return 0;\\n\\n    // By the rules of how rewards are calculated, we only pay rewards for\\n    // elapsed epochs, so if we are looking at the current epoch, we must go\\n    // back before that. This can happen if someone stakes or unstakes before we\\n    // calculate rewards\\n    if (epoch_u.epoch_number == epoch_number) {\\n      epoch_len--;\\n      epoch_u = epochs[epoch_len];\\n    }\\n\\n    // If the latest epoch is not the one that just elapsed, it means we must\\n    // be looking at a gap, eg. we are at e6, but the array is [e0], so we must\\n    // create a \\\"fake\\\" e5, and \\\"push back\\\" e0 into the array\\n    if (epoch_u.epoch_number < epoch_number - 1) {\\n      // \\\"push back\\\", so we look at this epoch again in the loop\\n      epoch_len++;\\n      // create the fake epoch\\n      epoch_u = Epoch(epoch_number - 1, epoch_u.balance);\\n    }\\n\\n    // We can sum up just part of the calculation, as other parts are constant\\n    uint256 aggregate_reward_share = 0;\\n\\n    // We use a while loop here as Solidity has a bug where it will decrement\\n    // below zero before checking the condition, causing the new overflow\\n    // protection to revert\\n    uint idx = epoch_len;\\n    while (epoch_u.epoch_number > user.epoch_start) {\\n      Epoch memory epoch_l = epochs[idx - 1];\\n\\n      // Since withdraw_rewards might set the `epoch_start` to something that\\n      // does not exist, we may have to add a fake epoch here\\n      if (epoch_l.epoch_number < user.epoch_start) {\\n        epoch_l = Epoch(user.epoch_start, epoch_l.balance);\\n        idx = 0; // defer break\\n      }\\n\\n      uint256 epochSpan = uint256(epoch_u.epoch_number - epoch_l.epoch_number);\\n\\n      // user.balance is constant, however precision errors arise if moved\\n      // outside the loop. `<< PRECISION` is the same as `* 2**PRECISION`\\n      // but cheaper\\n      aggregate_reward_share +=\\n        ((user.balance * epochSpan) << PRECISION) / epoch_l.balance;\\n\\n      if (idx == 0) break;\\n\\n      // swap places\\n      epoch_u = epoch_l;\\n      // This can never underflow, as the break above will always trigger at the\\n      // latest on e0\\n      idx--;\\n    }\\n\\n    staking_reward += (aggregate_reward_share * epoch_reward) >> PRECISION;\\n\\n    return staking_reward;\\n  }\\n\\n  // This function is for emergency use only. It specifically only looks at\\n  // stored data and does not perform any of the algorithmic reward calculations\\n  // to prevent any reverts causing the contract to lock up. User addresses must\\n  // be collected off-chain to issue refunds back to the wallets that did the\\n  // staking. This means we have no authority to take away tokens, only to\\n  // return them. An additional rewards_refund addres must be provided to\\n  // receive the remaining rewards tokens, as this contract \\\"owns\\\" those tokens.\\n  // Calling this function is \\\"idempotent\\\", albeit wasteful\\n  function emergency_refund (\\n    address[] calldata _users\\n  ) external only_controller {\\n\\n    uint248 total_balance = 0;\\n    for (uint idx = 0; idx < _users.length; idx++) {\\n      address addr = _users[idx];\\n      uint168 balance = users[addr].balance;\\n      total_balance += balance;\\n\\n      delete users[addr];\\n      trusted_lp_token.transfer(addr, balance);\\n    }\\n\\n    uint8 epoch_number = get_current_epoch_number();\\n    Epoch storage latest_epoch = epochs[epochs.length - 1];\\n    if (latest_epoch.epoch_number == epoch_number) {\\n      latest_epoch.balance -= total_balance;\\n    } else {\\n      epochs.push(Epoch(epoch_number, latest_epoch.balance - total_balance));\\n    }\\n\\n    trusted_reward_token.transfer(\\n      rewards_refund,\\n      trusted_reward_token.balanceOf(address(this))\\n    );\\n  }\\n\\n  function set_controller(address new_controller) external only_controller {\\n    require(new_controller != address(0), \\\"Controller cannot be address(0)\\\");\\n    controller = new_controller;\\n  }\\n\\n  modifier only_controller () {\\n    require(msg.sender == controller, \\\"Only controller can invoke this function\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"/contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lp_token_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reward_token_address\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_epoch_count\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_epoch_seconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_epoch_reward\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_rewards_refund\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"emergency_refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch_count\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch_reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epoch_seconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochs\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"epoch_number\",\"type\":\"uint8\"},{\"internalType\":\"uint248\",\"name\":\"balance\",\"type\":\"uint248\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"get_available_reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_current_epoch_number\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint104\",\"name\":\"share\",\"type\":\"uint104\"}],\"internalType\":\"struct LP_Staking.Prereward[]\",\"name\":\"_users\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_prerewards_total\",\"type\":\"uint256\"}],\"name\":\"init_prerewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"prerewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_controller\",\"type\":\"address\"}],\"name\":\"set_controller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint168\",\"name\":\"value\",\"type\":\"uint168\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking_end\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking_start\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_staked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"total_staked_for_user\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trusted_lp_token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trusted_reward_token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"has_prerewards\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"epoch_start\",\"type\":\"uint8\"},{\"internalType\":\"uint168\",\"name\":\"balance\",\"type\":\"uint168\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw_rewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LP_Staking","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"00000000000000000000000042b7b8f8f83fa5cbf0176f8c24ad51ebcd4b5f17000000000000000000000000cb84d72e61e383767c4dfeb2d8ff7f4fb89abc6e00000000000000000000000000000000000000000000000000000000000000410000000000000000000000000000000000000000000000000000000000015180000000000000000000000000000000000000000000000060c3d9eaaa28440000000000000000000000000000dc9fa6cd64f6e0ffa36cca96d2109d8d97e44b7e","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}