{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/adapters/Opyn/Opyn.1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//  ______   ______     _____\\n// /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\  __-.\\n// \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\/\\\\ \\\\\\n//    \\\\ \\\\_\\\\  \\\\ \\\\_____\\\\  \\\\ \\\\____-\\n//     \\\\/_/   \\\\/_____/   \\\\/____/\\n//\\npragma solidity 0.8.6;\\n\\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport '../../Versioned.sol';\\nimport '../../Pausable.sol';\\nimport '../Adapter.sol';\\nimport './interfaces/IZeroExV4Exchange.sol';\\n\\n//\\n//   ___ _ __ _ __ ___  _ __ ___\\n//  / _ \\\\ '__| '__/ _ \\\\| '__/ __|\\n// |  __/ |  | | | (_) | |  \\\\__ \\\\\\n//  \\\\___|_|  |_|  \\\\___/|_|  |___/\\n//\\n// OpynAdapterV1_1 => No oToken were purchased\\n\\ncontract OpynAdapterV1 is Versioned, Pausable, Adapter {\\n    //\\n    //      _        _\\n    //  ___| |_ __ _| |_ ___\\n    // / __| __/ _` | __/ _ \\\\\\n    // \\\\__ \\\\ || (_| | ||  __/\\n    // |___/\\\\__\\\\__,_|\\\\__\\\\___|\\n    //\\n\\n    // Address of 0x exchange\\n    IZeroExV4Exchange public zeroExV4Exchange;\\n\\n    //\\n    //  _       _                        _\\n    // (_)_ __ | |_ ___ _ __ _ __   __ _| |___\\n    // | | '_ \\\\| __/ _ \\\\ '__| '_ \\\\ / _` | / __|\\n    // | | | | | ||  __/ |  | | | | (_| | \\\\__ \\\\\\n    // |_|_| |_|\\\\__\\\\___|_|  |_| |_|\\\\__,_|_|___/\\n    //\\n\\n    /// @dev Perform an option purchase\\n    /// @param caller Address purchasing the option\\n    /// @param currencies List of usable currencies\\n    /// @param amounts List of usable currencies amounts\\n    /// @param data Extra data usable by adapter\\n    /// @return A tuple containing used amounts and output data\\n    function purchase(\\n        address caller,\\n        address[] memory currencies,\\n        uint256[] memory amounts,\\n        bytes calldata data\\n    ) internal override returns (uint256[] memory, bytes memory) {\\n        address token;\\n        address takerToken;\\n        bool success;\\n        uint256 takerTokenAmount;\\n        uint128 takerTokenFilledAmount;\\n        uint128 makerTokenFilledAmount;\\n\\n        {\\n            uint256 etherValue;\\n            bytes memory callData;\\n\\n            (token, callData) = abi.decode(data, (address, bytes));\\n\\n            for (uint256 idx = 0; idx < currencies.length; ++idx) {\\n                if (currencies[idx] == address(0)) {\\n                    etherValue = amounts[idx];\\n                } else {\\n                    takerTokenAmount = amounts[idx];\\n                    takerToken = currencies[idx];\\n                    IERC20(currencies[idx]).approve(address(zeroExV4Exchange), takerTokenAmount);\\n                }\\n            }\\n            (success, callData) = address(zeroExV4Exchange).call{value: etherValue}(callData);\\n            require(success, string(callData));\\n            (takerTokenFilledAmount, makerTokenFilledAmount) = abi.decode(callData, (uint128, uint128));\\n            require(makerTokenFilledAmount > 0, 'OpynAdapterV1_1');\\n        }\\n\\n        if (takerTokenAmount > takerTokenFilledAmount) {\\n            IERC20(takerToken).transfer(caller, takerTokenAmount - takerTokenFilledAmount);\\n        }\\n\\n        IERC20(token).transfer(caller, makerTokenFilledAmount);\\n\\n        return (\\n            amounts,\\n            abi.encode(takerToken, token, uint256(takerTokenFilledAmount), uint256(makerTokenFilledAmount))\\n        );\\n    }\\n\\n    //\\n    //            _                        _\\n    //   _____  _| |_ ___ _ __ _ __   __ _| |___\\n    //  / _ \\\\ \\\\/ / __/ _ \\\\ '__| '_ \\\\ / _` | / __|\\n    // |  __/>  <| ||  __/ |  | | | | (_| | \\\\__ \\\\\\n    //  \\\\___/_/\\\\_\\\\\\\\__\\\\___|_|  |_| |_|\\\\__,_|_|___/\\n    //\\n\\n    /// @dev Retrieve adapter name\\n    /// @return Adapter name\\n    function name() external pure override returns (string memory) {\\n        return 'OpynV1';\\n    }\\n\\n    //\\n    //  _       _ _\\n    // (_)_ __ (_) |_\\n    // | | '_ \\\\| | __|\\n    // | | | | | | |_\\n    // |_|_| |_|_|\\\\__|\\n    //\\n\\n    function __OpynAdapterV1__constructor(address _gateway, IZeroExV4Exchange _zeroExV4Exchange) public initVersion(1) {\\n        zeroExV4Exchange = _zeroExV4Exchange;\\n        setGateway(_gateway);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/Versioned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//  ______   ______     _____\\n// /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\  __-.\\n// \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\/\\\\ \\\\\\n//    \\\\ \\\\_\\\\  \\\\ \\\\_____\\\\  \\\\ \\\\____-\\n//     \\\\/_/   \\\\/_____/   \\\\/____/\\n//\\npragma solidity 0.8.6;\\n\\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\\n\\n//\\n//   ___ _ __ _ __ ___  _ __ ___\\n//  / _ \\\\ '__| '__/ _ \\\\| '__/ __|\\n// |  __/ |  | | | (_) | |  \\\\__ \\\\\\n//  \\\\___|_|  |_|  \\\\___/|_|  |___/\\n//\\n// V1 => Already initializing\\n// V2 => Invalid version received. Expected current\\n\\n/// @title Versioned\\n/// @author Iulian Rotaru\\n/// @notice Initialized for multiple versions\\ncontract Versioned {\\n    //\\n    //      _        _\\n    //  ___| |_ __ _| |_ ___\\n    // / __| __/ _` | __/ _ \\\\\\n    // \\\\__ \\\\ || (_| | ||  __/\\n    // |___/\\\\__\\\\__,_|\\\\__\\\\___|\\n    //\\n\\n    // Stores the current implementation version\\n    uint256 version;\\n\\n    // Stores the initializing state for each version\\n    bool private _initializing;\\n\\n    //\\n    //                      _ _  __ _\\n    //  _ __ ___   ___   __| (_)/ _(_) ___ _ __ ___\\n    // | '_ ` _ \\\\ / _ \\\\ / _` | | |_| |/ _ \\\\ '__/ __|\\n    // | | | | | | (_) | (_| | |  _| |  __/ |  \\\\__ \\\\\\n    // |_| |_| |_|\\\\___/ \\\\__,_|_|_| |_|\\\\___|_|  |___/\\n    //\\n\\n    // Allows to be called only if version number is current version + 1\\n    modifier initVersion(uint256 _version) {\\n        require(!_initializing, 'V1');\\n        require(_version == version + 1, 'V2');\\n        version = _version;\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    //\\n    //            _                        _\\n    //   _____  _| |_ ___ _ __ _ __   __ _| |___\\n    //  / _ \\\\ \\\\/ / __/ _ \\\\ '__| '_ \\\\ / _` | / __|\\n    // |  __/>  <| ||  __/ |  | | | | (_| | \\\\__ \\\\\\n    //  \\\\___/_/\\\\_\\\\\\\\__\\\\___|_|  |_| |_|\\\\__,_|_|___/\\n    //\\n\\n    /// @dev Retrieves current implementation version\\n    /// @return Implementatiomn version\\n    function getVersion() public view returns (uint256) {\\n        return version;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//  ______   ______     _____\\n// /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\  __-.\\n// \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\/\\\\ \\\\\\n//    \\\\ \\\\_\\\\  \\\\ \\\\_____\\\\  \\\\ \\\\____-\\n//     \\\\/_/   \\\\/_____/   \\\\/____/\\n//\\npragma solidity 0.8.6;\\n\\nimport '@openzeppelin/contracts/utils/StorageSlot.sol';\\n\\n//\\n//   ___ _ __ _ __ ___  _ __ ___\\n//  / _ \\\\ '__| '__/ _ \\\\| '__/ __|\\n// |  __/ |  | | | (_) | |  \\\\__ \\\\\\n//  \\\\___|_|  |_|  \\\\___/|_|  |___/\\n//\\n// P1 => Contract is not paused\\n// P2 => Contract is paused\\n\\n/// @title Pausable\\n/// @author Iulian Rotaru\\n/// @notice Pausable logics, reading storage slot to retrieve pause state\\ncontract Pausable {\\n    //\\n    //                      _              _\\n    //   ___ ___  _ __  ___| |_ __ _ _ __ | |_ ___\\n    //  / __/ _ \\\\| '_ \\\\/ __| __/ _` | '_ \\\\| __/ __|\\n    // | (_| (_) | | | \\\\__ \\\\ || (_| | | | | |_\\\\__ \\\\\\n    //  \\\\___\\\\___/|_| |_|___/\\\\__\\\\__,_|_| |_|\\\\__|___/\\n    //\\n\\n    // Storage slot for the Paused state\\n    bytes32 internal constant _PAUSED_SLOT = 0x8dea8703c3cf94703383ce38a9c894669dccd4ca8e65ddb43267aa0248711450;\\n\\n    //\\n    //                      _ _  __ _\\n    //  _ __ ___   ___   __| (_)/ _(_) ___ _ __ ___\\n    // | '_ ` _ \\\\ / _ \\\\ / _` | | |_| |/ _ \\\\ '__/ __|\\n    // | | | | | | (_) | (_| | |  _| |  __/ |  \\\\__ \\\\\\n    // |_| |_| |_|\\\\___/ \\\\__,_|_|_| |_|\\\\___|_|  |___/\\n    //\\n\\n    // Allows methods to be called if paused\\n    modifier whenPaused() {\\n        require(StorageSlot.getBooleanSlot(_PAUSED_SLOT).value == true, 'P1');\\n        _;\\n    }\\n\\n    // Allows methods to be called if not paused\\n    modifier whenNotPaused() {\\n        require(StorageSlot.getBooleanSlot(_PAUSED_SLOT).value == false, 'P1');\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/Adapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//  ______   ______     _____\\n// /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\  __-.\\n// \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\/\\\\ \\\\\\n//    \\\\ \\\\_\\\\  \\\\ \\\\_____\\\\  \\\\ \\\\____-\\n//     \\\\/_/   \\\\/_____/   \\\\/____/\\n//\\npragma solidity 0.8.6;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport '../Owned.sol';\\n\\n//\\n//   ___ _ __ _ __ ___  _ __ ___\\n//  / _ \\\\ '__| '__/ _ \\\\| '__/ __|\\n// |  __/ |  | | | (_) | |  \\\\__ \\\\\\n//  \\\\___|_|  |_|  \\\\___/|_|  |___/\\n//\\n// A1 => Useless call, not changing address\\n// A2 => Invalid currencies and amount length\\n// A3 => Received amount of ETH too low\\n\\n/// @title Adapter\\n/// @author Iulian Rotaru\\n/// @notice Adapter base logics\\nabstract contract Adapter is Owned {\\n\\n    address public gateway;\\n\\n    modifier isGateway() {\\n      require(msg.sender == gateway, 'A1');\\n      _;\\n    }\\n\\n    //\\n    //  _       _                        _\\n    // (_)_ __ | |_ ___ _ __ _ __   __ _| |___\\n    // | | '_ \\\\| __/ _ \\\\ '__| '_ \\\\ / _` | / __|\\n    // | | | | | ||  __/ |  | | | | (_| | \\\\__ \\\\\\n    // |_|_| |_|\\\\__\\\\___|_|  |_| |_|\\\\__,_|_|___/\\n    //\\n\\n    /// @dev Changes gateway address\\n    /// @param newGateway Address of new gateway\\n    function setGateway(address newGateway) internal {\\n      require(gateway != newGateway, 'A1');\\n      gateway = newGateway;\\n    }\\n\\n    /// @dev Perform an internal option purchase\\n    /// @param caller Address purchasing the option\\n    /// @param currencies List of usable currencies\\n    /// @param amounts List of usable currencies amounts\\n    /// @param data Extra data usable by adapter\\n    /// @return A tuple containing used amounts and output data\\n    function purchase(\\n        address caller,\\n        address[] memory currencies,\\n        uint256[] memory amounts,\\n        bytes calldata data\\n    ) internal virtual returns (uint256[] memory, bytes memory);\\n\\n    function _preparePayment(address[] memory currencies, uint256[] memory amounts) internal {\\n        require(currencies.length == amounts.length, 'A2');\\n        for (uint256 currencyIdx = 0; currencyIdx < currencies.length; ++currencyIdx) {\\n            if (currencies[currencyIdx] == address(0)) {\\n                require(msg.value >= amounts[currencyIdx], 'A3');\\n            } else {\\n                IERC20(currencies[currencyIdx]).transferFrom(msg.sender, address(this), amounts[currencyIdx]);\\n            }\\n        }\\n    }\\n\\n    //\\n    //            _                        _\\n    //   _____  _| |_ ___ _ __ _ __   __ _| |___\\n    //  / _ \\\\ \\\\/ / __/ _ \\\\ '__| '_ \\\\ / _` | / __|\\n    // |  __/>  <| ||  __/ |  | | | | (_| | \\\\__ \\\\\\n    //  \\\\___/_/\\\\_\\\\\\\\__\\\\___|_|  |_| |_|\\\\__,_|_|___/\\n    //\\n\\n    /// @dev Perform an option purchase\\n    /// @param caller Address purchasing the option\\n    /// @param currencies List of usable currencies\\n    /// @param amounts List of usable currencies amounts\\n    /// @param data Extra data usable by adapter\\n    /// @return A tuple containing used amounts and output data\\n    function run(\\n        address caller,\\n        address[] memory currencies,\\n        uint256[] memory amounts,\\n        bytes calldata data\\n    ) external payable isGateway returns (uint256[] memory, bytes memory) {\\n        _preparePayment(currencies, amounts);\\n        return purchase(caller, currencies, amounts, data);\\n    }\\n\\n    function name() external view virtual returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/Opyn/interfaces/IZeroExV4Exchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//  ______   ______     _____\\n// /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\  __-.\\n// \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\/\\\\ \\\\\\n//    \\\\ \\\\_\\\\  \\\\ \\\\_____\\\\  \\\\ \\\\____-\\n//     \\\\/_/   \\\\/_____/   \\\\/____/\\n//\\npragma solidity 0.8.6;\\n\\ninterface IZeroExV4Exchange {\\n    //\\n    //      _                   _\\n    //  ___| |_ _ __ _   _  ___| |_ ___\\n    // / __| __| '__| | | |/ __| __/ __|\\n    // \\\\__ \\\\ |_| |  | |_| | (__| |_\\\\__ \\\\\\n    // |___/\\\\__|_|   \\\\__,_|\\\\___|\\\\__|___/\\n    //\\n    //\\n\\n    struct RfqOrder {\\n        address makerToken;\\n        address takerToken;\\n        uint128 makerAmount;\\n        uint128 takerAmount;\\n        address maker;\\n        address taker;\\n        address txOrigin;\\n        bytes32 pool;\\n        uint64 expiry;\\n        uint256 salt;\\n    }\\n\\n    struct Signature {\\n        SignatureType signatureType;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    //\\n    //   ___ _ __  _   _ _ __ ___  ___\\n    //  / _ \\\\ '_ \\\\| | | | '_ ` _ \\\\/ __|\\n    // |  __/ | | | |_| | | | | | \\\\__ \\\\\\n    //  \\\\___|_| |_|\\\\__,_|_| |_| |_|___/\\n    //\\n\\n    enum SignatureType {\\n        ILLEGAL,\\n        INVALID,\\n        EIP712,\\n        ETHSIGN\\n    }\\n\\n    function fillRfqOrder(\\n        RfqOrder memory order,\\n        Signature memory signature,\\n        uint128 takerTokenFillAmount\\n    ) external returns (uint128 takerTokenFilledAmount, uint128 makerTokenFilledAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//  ______   ______     _____\\n// /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\  __-.\\n// \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\/\\\\ \\\\\\n//    \\\\ \\\\_\\\\  \\\\ \\\\_____\\\\  \\\\ \\\\____-\\n//     \\\\/_/   \\\\/_____/   \\\\/____/\\n//\\npragma solidity 0.8.6;\\n\\nimport '@openzeppelin/contracts/utils/StorageSlot.sol';\\n\\n//\\n//   ___ _ __ _ __ ___  _ __ ___\\n//  / _ \\\\ '__| '__/ _ \\\\| '__/ __|\\n// |  __/ |  | | | (_) | |  \\\\__ \\\\\\n//  \\\\___|_|  |_|  \\\\___/|_|  |___/\\n//\\n// O1 => Caller is not admin\\n\\n/// @title Owned\\n/// @author Iulian Rotaru\\n/// @notice Owner logics, reading storage slot to retrieve admin\\ncontract Owned {\\n    //\\n    //                      _              _\\n    //   ___ ___  _ __  ___| |_ __ _ _ __ | |_ ___\\n    //  / __/ _ \\\\| '_ \\\\/ __| __/ _` | '_ \\\\| __/ __|\\n    // | (_| (_) | | | \\\\__ \\\\ || (_| | | | | |_\\\\__ \\\\\\n    //  \\\\___\\\\___/|_| |_|___/\\\\__\\\\__,_|_| |_|\\\\__|___/\\n    //\\n\\n    // Storage slot for the Admin address\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    //\\n    //                      _ _  __ _\\n    //  _ __ ___   ___   __| (_)/ _(_) ___ _ __ ___\\n    // | '_ ` _ \\\\ / _ \\\\ / _` | | |_| |/ _ \\\\ '__/ __|\\n    // | | | | | | (_) | (_| | |  _| |  __/ |  \\\\__ \\\\\\n    // |_| |_| |_|\\\\___/ \\\\__,_|_|_| |_|\\\\___|_|  |___/\\n    //\\n\\n    // Modifier allowing only admins to call methods\\n    modifier isAdmin() {\\n        require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, 'O1');\\n        _;\\n    }\\n\\n    //\\n    //            _                        _\\n    //   _____  _| |_ ___ _ __ _ __   __ _| |___\\n    //  / _ \\\\ \\\\/ / __/ _ \\\\ '__| '_ \\\\ / _` | / __|\\n    // |  __/>  <| ||  __/ |  | | | | (_| | \\\\__ \\\\\\n    //  \\\\___/_/\\\\_\\\\\\\\__\\\\___|_|  |_| |_|\\\\__,_|_|___/\\n    //\\n\\n    /// @dev Retrieves Admin address\\n    /// @return Admin address\\n    function getAdmin() public view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gateway\",\"type\":\"address\"},{\"internalType\":\"contract IZeroExV4Exchange\",\"name\":\"_zeroExV4Exchange\",\"type\":\"address\"}],\"name\":\"__OpynAdapterV1__constructor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateway\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"currencies\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"run\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zeroExV4Exchange\",\"outputs\":[{\"internalType\":\"contract IZeroExV4Exchange\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"OpynAdapterV1","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}