{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PRBProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\npragma solidity >=0.8.4;\\n\\nimport \\\"./IPRBProxy.sol\\\";\\nimport \\\"./IPRBProxyFactory.sol\\\";\\n\\n/// @notice Emitted when the deployment of an EIP-1167 clone with CREATE2 fails.\\nerror PRBProxyFactory__CloneFailed(bytes32 finalSalt);\\n\\n/// @title PRBProxyFactory\\n/// @author Paul Razvan Berg\\ncontract PRBProxyFactory is IPRBProxyFactory {\\n    /// PUBLIC STORAGE ///\\n\\n    /// @inheritdoc IPRBProxyFactory\\n    IPRBProxy public immutable override implementation;\\n\\n    /// INTERNAL STORAGE ///\\n\\n    /// @dev Internal mapping to track all deployed proxies.\\n    mapping(address => bool) internal proxies;\\n\\n    /// @dev Internal mapping to track the next salt to be used by an EOA.\\n    mapping(address => bytes32) internal nextSalts;\\n\\n    /// CONSTRUCTOR ///\\n\\n    constructor(IPRBProxy implementation_) {\\n        implementation = implementation_;\\n    }\\n\\n    /// PUBLIC CONSTANT FUNCTIONS ///\\n\\n    /// @inheritdoc IPRBProxyFactory\\n    function getNextSalt(address eoa) external view override returns (bytes32 nextSalt) {\\n        nextSalt = nextSalts[eoa];\\n    }\\n\\n    /// @inheritdoc IPRBProxyFactory\\n    function isProxy(address proxy) external view override returns (bool result) {\\n        result = proxies[proxy];\\n    }\\n\\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\\n\\n    /// @inheritdoc IPRBProxyFactory\\n    function deploy() external override returns (address payable proxy) {\\n        proxy = deployFor(msg.sender);\\n    }\\n\\n    /// @inheritdoc IPRBProxyFactory\\n    function deployFor(address owner) public override returns (address payable proxy) {\\n        bytes32 salt = nextSalts[tx.origin];\\n\\n        // Prevent front-running the salt by hashing the concatenation of \\\"tx.origin\\\" and the user-provided salt.\\n        bytes32 finalSalt = keccak256(abi.encode(tx.origin, salt));\\n\\n        // Deploy the proxy as an EIP-1167 clone, via CREATE2.\\n        proxy = clone(finalSalt);\\n\\n        // Initialize the proxy.\\n        IPRBProxy(proxy).initialize(owner);\\n\\n        // Mark the proxy as deployed.\\n        proxies[proxy] = true;\\n\\n        // Increment the salt.\\n        unchecked {\\n            nextSalts[tx.origin] = bytes32(uint256(salt) + 1);\\n        }\\n\\n        // Log the proxy via en event.\\n        emit DeployProxy(tx.origin, msg.sender, owner, salt, finalSalt, address(proxy));\\n    }\\n\\n    /// INTERNAL NON-CONSTANT FUNCTIONS ///\\n\\n    /// @dev Deploys an EIP-1167 clone that mimics the behavior of `implementation`.\\n    function clone(bytes32 finalSalt) internal returns (address payable proxy) {\\n        bytes20 impl = bytes20(address(implementation));\\n        assembly {\\n            let bytecode := mload(0x40)\\n            mstore(bytecode, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(bytecode, 0x14), impl)\\n            mstore(add(bytecode, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            proxy := create2(0, bytecode, 0x37, finalSalt)\\n        }\\n        if (proxy == address(0)) {\\n            revert PRBProxyFactory__CloneFailed(finalSalt);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IPRBProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\npragma solidity >=0.8.4;\\n\\nimport \\\"./access/IOwnable.sol\\\";\\n\\n/// @title IPRBProxy\\n/// @author Paul Razvan Berg\\n/// @notice Proxy contract to compose transactions on owner's behalf.\\ninterface IPRBProxy is IOwnable {\\n    /// EVENTS ///\\n\\n    event Execute(address indexed target, bytes data, bytes response);\\n\\n    /// PUBLIC CONSTANT FUNCTIONS ///\\n\\n    /// @notice How much gas should remain for executing the remainder of the assembly code.\\n    function minGasReserve() external view returns (uint256);\\n\\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\\n\\n    /// @notice Delegate calls to the target contract by forwarding the call data. This function returns\\n    /// the data it gets back, including when the contract call reverts with a reason or custom error.\\n    ///\\n    /// @dev Requirements:\\n    /// - The caller must be the owner.\\n    /// - `target` must be a contract.\\n    ///\\n    /// @param target The address of the target contract.\\n    /// @param data Function selector plus ABI encoded data.\\n    /// @return response The response received from the target contract.\\n    function execute(address target, bytes memory data) external payable returns (bytes memory response);\\n\\n    /// @notice Initializes the contract by setting the address of the owner of the proxy.\\n    ///\\n    /// @dev Supposed to be called by an EIP-1167 clone.\\n    ///\\n    /// Requirements:\\n    /// - Can only be called once.\\n    ///\\n    /// @param owner_ The address of the owner of the proxy.\\n    function initialize(address owner_) external;\\n\\n    /// @notice Sets a new value for the `minGasReserve` storage variable.\\n    /// @dev Requirements:\\n    /// - The caller must be the owner.\\n    function setMinGasReserve(uint256 newMinGasReserve) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IPRBProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\npragma solidity >=0.8.4;\\n\\nimport \\\"./IPRBProxy.sol\\\";\\n\\n/// @title IPRBProxyFactory\\n/// @author Paul Razvan Berg\\n/// @notice Deploys new proxy instances with CREATE2.\\ninterface IPRBProxyFactory {\\n    /// EVENTS ///\\n\\n    event DeployProxy(\\n        address indexed origin,\\n        address indexed deployer,\\n        address indexed owner,\\n        bytes32 salt,\\n        bytes32 finalSalt,\\n        address proxy\\n    );\\n\\n    /// PUBLIC CONSTANT FUNCTIONS ///\\n\\n    /// @notice Gets the next salt that will be used to deploy the proxy.\\n    /// @param eoa The externally owned account which deployed proxies.\\n    function getNextSalt(address eoa) external view returns (bytes32 result);\\n\\n    /// @notice The address of the implementation of PRBProxy.\\n    function implementation() external view returns (IPRBProxy proxy);\\n\\n    /// @notice Mapping to track all deployed proxies.\\n    /// @param proxy The address of the proxy to make the check for.\\n    function isProxy(address proxy) external view returns (bool result);\\n\\n    /// PUBLIC NON-CONSTANT FUNCTIONS ///\\n\\n    /// @notice Deploys a new proxy as an EIP-1167 clone deployed via CREATE2.\\n    /// @dev Sets \\\"msg.sender\\\" as the owner of the proxy.\\n    /// @return proxy The address of the newly deployed proxy contract.\\n    function deploy() external returns (address payable proxy);\\n\\n    /// @notice Deploys a new proxy as an EIP-1167 clone deployed via CREATE2, for a specific owner.\\n    ///\\n    /// @dev Requirements:\\n    /// - The CREATE2 must not have been used.\\n    ///\\n    /// @param owner The owner of the proxy.\\n    /// @return proxy The address of the newly deployed proxy contract.\\n    function deployFor(address owner) external returns (address payable proxy);\\n}\\n\"\r\n    },\r\n    \"contracts/access/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\npragma solidity >=0.8.4;\\n\\n/// @title IOwnable\\n/// @author Paul Razvan Berg\\n/// @notice Contract module that provides a basic access control mechanism, where there is an\\n/// account (an owner) that can be granted exclusive access to specific functions.\\n///\\n/// By default, the owner account will be the one that deploys the contract. This can later be\\n/// changed with {transfer}.\\n///\\n/// This module is used through inheritance. It will make available the modifier `onlyOwner`,\\n/// which can be applied to your functions to restrict their use to the owner.\\n///\\n/// @dev Forked from OpenZeppelin\\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/access/Ownable.sol\\ninterface IOwnable {\\n    /// EVENTS ///\\n\\n    /// @notice Emitted when ownership is transferred.\\n    /// @param oldOwner The address of the old owner.\\n    /// @param newOwner The address of the new owner.\\n    event TransferOwnership(address indexed oldOwner, address indexed newOwner);\\n\\n    /// NON-CONSTANT FUNCTIONS ///\\n\\n    /// @notice Leaves the contract without owner, so it will not be possible to call `onlyOwner`\\n    /// functions anymore.\\n    ///\\n    /// WARNING: Doing this will leave the contract without an owner, thereby removing any\\n    /// functionality that is only available to the owner.\\n    ///\\n    /// Requirements:\\n    ///\\n    /// - The caller must be the owner.\\n    function renounceOwnership() external;\\n\\n    /// @notice Transfers the owner of the contract to a new account (`newOwner`). Can only be\\n    /// called by the current owner.\\n    /// @param newOwner The acount of the new owner.\\n    function transferOwnership(address newOwner) external;\\n\\n    /// CONSTANT FUNCTIONS ///\\n\\n    /// @notice The address of the owner account or contract.\\n    /// @return The address of the owner.\\n    function owner() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IPRBProxy\",\"name\":\"implementation_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"finalSalt\",\"type\":\"bytes32\"}],\"name\":\"PRBProxyFactory__CloneFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"finalSalt\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"DeployProxy\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"deployFor\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"eoa\",\"type\":\"address\"}],\"name\":\"getNextSalt\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"nextSalt\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"contract IPRBProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"isProxy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PRBProxyFactory","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000427fa23ea53225ac1b7510194e51979510a68007","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}