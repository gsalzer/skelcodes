{"status":"1","message":"OK","result":[{"SourceCode":"{\"LERC20.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.0;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface ILosslessController {\\n    function beforeTransfer(address sender, address recipient, uint256 amount) external;\\n\\n    function beforeTransferFrom(address sender, address recipient, uint256 amount) external;\\n\\n    function beforeApprove(address sender, address spender, uint256 amount) external;\\n\\n    function beforeIncreaseAllowance(address msgSender, address spender, uint256 addedValue) external;\\n\\n    function beforeDecreaseAllowance(address msgSender, address spender, uint256 subtractedValue) external;\\n}\\n\\ncontract LERC20 is Context, IERC20 {\\n    mapping (address =\\u003e uint256) private _balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n    uint256 private _totalSupply;\\n    string private _name;\\n    string private _symbol;\\n\\n    address public recoveryAdmin;\\n    address private recoveryAdminCanditate;\\n    bytes32 private recoveryAdminKeyHash;\\n    address public admin;\\n    uint256 public timelockPeriod;\\n    uint256 public losslessTurnOffTimestamp;\\n    bool public isLosslessTurnOffProposed;\\n    bool public isLosslessOn = true;\\n    ILosslessController public lossless;\\n\\n    event AdminChanged(address indexed previousAdmin, address indexed newAdmin);\\n    event RecoveryAdminChangeProposed(address indexed candidate);\\n    event RecoveryAdminChanged(address indexed previousAdmin, address indexed newAdmin);\\n    event LosslessTurnOffProposed(uint256 turnOffDate);\\n    event LosslessTurnedOff();\\n    event LosslessTurnedOn();\\n\\n    constructor(uint256 totalSupply_, string memory name_, string memory symbol_, address admin_, address recoveryAdmin_, uint256 timelockPeriod_, address lossless_) {\\n        _mint(_msgSender(), totalSupply_);\\n        _name = name_;\\n        _symbol = symbol_;\\n        admin = admin_;\\n        recoveryAdmin = recoveryAdmin_;\\n        timelockPeriod = timelockPeriod_;\\n        lossless = ILosslessController(lossless_);\\n    }\\n\\n    // --- LOSSLESS modifiers ---\\n\\n    modifier lssAprove(address spender, uint256 amount) {\\n        if (isLosslessOn) {\\n            lossless.beforeApprove(_msgSender(), spender, amount);\\n        } \\n        _;\\n    }\\n\\n    modifier lssTransfer(address recipient, uint256 amount) {\\n        if (isLosslessOn) {\\n            lossless.beforeTransfer(_msgSender(), recipient, amount);\\n        } \\n        _;\\n    }\\n\\n    modifier lssTransferFrom(address sender, address recipient, uint256 amount) {\\n        if (isLosslessOn) {\\n            lossless.beforeTransferFrom(sender, recipient, amount);\\n        }\\n        _;\\n    }\\n\\n    modifier lssIncreaseAllowance(address spender, uint256 addedValue) {\\n        if (isLosslessOn) {\\n            lossless.beforeIncreaseAllowance(_msgSender(), spender, addedValue);\\n        }\\n        _;\\n    }\\n\\n    modifier lssDecreaseAllowance(address spender, uint256 subtractedValue) {\\n        if (isLosslessOn) {\\n            lossless.beforeDecreaseAllowance(_msgSender(), spender, subtractedValue);\\n        }\\n        _;\\n    }\\n\\n    modifier onlyRecoveryAdmin() {\\n        require(_msgSender() == recoveryAdmin, \\\"LERC20: Must be recovery admin\\\");\\n        _;\\n    }\\n\\n    // --- LOSSLESS management ---\\n\\n    function getAdmin() external view returns (address) {\\n        return admin;\\n    }\\n\\n    function transferOutBlacklistedFunds(address[] calldata from) external {\\n        require(_msgSender() == address(lossless), \\\"LERC20: Only lossless contract\\\");\\n        for (uint i = 0; i \\u003c from.length; i++) {\\n            _transfer(from[i], address(lossless), balanceOf(from[i]));\\n        }\\n    }\\n\\n    function setLosslessAdmin(address newAdmin) external onlyRecoveryAdmin {\\n        require(newAdmin != address(0), \\\"LERC20: Cannot be zero address\\\");\\n        emit AdminChanged(admin, newAdmin);\\n        admin = newAdmin;\\n    }\\n\\n    function transferRecoveryAdminOwnership(address candidate, bytes32 keyHash) external onlyRecoveryAdmin {\\n        require(candidate != address(0), \\\"LERC20: Cannot be zero address\\\");\\n        recoveryAdminCanditate = candidate;\\n        recoveryAdminKeyHash = keyHash;\\n        emit RecoveryAdminChangeProposed(candidate);\\n    }\\n\\n    function acceptRecoveryAdminOwnership(bytes memory key) external {\\n        require(_msgSender() == recoveryAdminCanditate, \\\"LERC20: Must be canditate\\\");\\n        require(keccak256(key) == recoveryAdminKeyHash, \\\"LERC20: Invalid key\\\");\\n        emit RecoveryAdminChanged(recoveryAdmin, recoveryAdminCanditate);\\n        recoveryAdmin = recoveryAdminCanditate;\\n    }\\n\\n    function proposeLosslessTurnOff() external onlyRecoveryAdmin {\\n        losslessTurnOffTimestamp = block.timestamp + timelockPeriod;\\n        isLosslessTurnOffProposed = true;\\n        emit LosslessTurnOffProposed(losslessTurnOffTimestamp);\\n    }\\n\\n    function executeLosslessTurnOff() external onlyRecoveryAdmin {\\n        require(isLosslessTurnOffProposed, \\\"LERC20: TurnOff not proposed\\\");\\n        require(losslessTurnOffTimestamp \\u003c= block.timestamp, \\\"LERC20: Time lock in progress\\\");\\n        isLosslessOn = false;\\n        isLosslessTurnOffProposed = false;\\n        emit LosslessTurnedOff();\\n    }\\n\\n    function executeLosslessTurnOn() external onlyRecoveryAdmin {\\n        isLosslessTurnOffProposed = false;\\n        isLosslessOn = true;\\n        emit LosslessTurnedOn();\\n    }\\n\\n    // --- ERC20 methods ---\\n\\n    function name() external view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() external view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() external view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() external view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) external virtual override lssTransfer(recipient, amount) returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) external view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) external virtual override lssAprove(spender, amount) returns (bool) {\\n        require((amount == 0) || (_allowances[_msgSender()][spender] == 0), \\\"LERC20: Cannot change non zero allowance\\\");\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external virtual override lssTransferFrom(sender, recipient, amount) returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance \\u003e= amount, \\\"LERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external virtual lssIncreaseAllowance(spender, addedValue) returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual lssDecreaseAllowance(spender, subtractedValue) returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance \\u003e= subtractedValue, \\\"LERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"LERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"LERC20: transfer to the zero address\\\");\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance \\u003e= amount, \\\"LERC20: transfer amount exceeds balance\\\");\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"LERC20: mint to the zero address\\\");\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"LERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"LERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n}\"},\"LosslessGuardian.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport \\\"./LERC20.sol\\\";\\n\\ninterface LosslessController {\\n    function setProtectedAddress(address token, address guardedAddress, address strategy) external;\\n\\n    function removeProtectedAddress(address token, address guardedAddress) external;\\n\\n    function admin() external returns(address);\\n\\n    function pauseAdmin() external returns(address);\\n}\\n\\ncontract LosslessGuardian {\\n    mapping(address =\\u003e address) public protectionAdmin;\\n    mapping(address =\\u003e bool) public verifiedStrategies;\\n    mapping(address =\\u003e bool) public verifiedTokens;\\n    mapping(address =\\u003e VerifiedAddress) private verifiedAddresses;\\n    LosslessController public lossless;\\n\\n    struct VerifiedAddress {\\n        mapping(address =\\u003e bool) verified;\\n    }\\n\\n    // --- EVENTS ---\\n\\n    event TokenVerified(address indexed token, bool value);\\n    event AddressVerified(address indexed token, address indexed verifiedAddress, bool value);\\n    event ProtectionAdminSet(address indexed token, address indexed admin);\\n    event StrategyVerified(address indexed strategy, bool value);\\n\\n    constructor(address _lossless) {\\n        lossless = LosslessController(_lossless);\\n    }\\n\\n    // --- MODIFIERS ---\\n\\n    modifier onlyLosslessAdmin() {\\n        require(msg.sender == lossless.admin(),\\\"LOSSLESS: Not lossless admin\\\");\\n        _;\\n    }\\n\\n    modifier onlyVerifiedStrategy() {\\n        require(verifiedStrategies[msg.sender], \\\"LOSSLESS: Strategy not verified\\\");\\n        _;\\n    }\\n\\n    modifier onlyVerifiedToken(address token) {\\n        require(verifiedTokens[token], \\\"LOSSLESS: Token not verified\\\");\\n        _;\\n    }\\n\\n    // --- VIEWS ---\\n\\n    function isAddressVerified(address token, address addressToCheck) external view returns(bool) {\\n        return verifiedAddresses[token].verified[addressToCheck];\\n    }\\n\\n    // --- METHODS\\n\\n    // @dev Strategies are where all the protection implementation logic lives.\\n    function verifyStrategies(address[] calldata strategies, bool value) external onlyLosslessAdmin {\\n        for(uint8 i = 0; i \\u003c strategies.length; i++) {\\n            verifiedStrategies[strategies[i]] = value;\\n            emit StrategyVerified(strategies[i], value);\\n        }\\n    }\\n\\n    // @dev Lossless team has to verify projects that can use protection functionality.\\n    function verifyToken(address token, bool value) external onlyLosslessAdmin {\\n        verifiedTokens[token] = value;\\n        emit TokenVerified(token, value);\\n    }\\n\\n    // @dev Lossless team has to verify addresses that projects want to protect.\\n    function verifyAddress(address token, address verifiedAddress, bool value) external onlyLosslessAdmin onlyVerifiedToken(token) {\\n        verifiedAddresses[token].verified[verifiedAddress] = value;\\n        emit AddressVerified(token, verifiedAddress, value);\\n    }   \\n\\n    // @notice Token admin sets up another admin that is responsible for managing protection.\\n    function setProtectionAdmin(address token, address admin) external onlyVerifiedToken(token) {\\n        require(LERC20(token).getAdmin() == msg.sender, \\\"LOSSLESS: Not token admin\\\");\\n        protectionAdmin[token] = admin;\\n        emit ProtectionAdminSet(token, admin);\\n    }\\n\\n    // @dev This is called from strategy conctract and forwards that call to the controller.\\n    function setProtectedAddress(address token, address guardedAddress) external onlyVerifiedStrategy {\\n        require(verifiedAddresses[token].verified[guardedAddress], \\\"LOSSLESS: Address not verified\\\");\\n        lossless.setProtectedAddress(token, guardedAddress, msg.sender);\\n    }\\n    \\n    // @dev This is called from strategy conctract or protection admin and forwards that call to the controller.\\n    function removeProtectedAddresses(address token, address protectedAddress) external {\\n        require(verifiedStrategies[msg.sender] || (msg.sender == protectionAdmin[token] \\u0026\\u0026 msg.sender != address(0)), \\\"LOSSLESS: Unauthorized access\\\");\\n        lossless.removeProtectedAddress(token, protectedAddress);\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lossless\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"verifiedAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"AddressVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"ProtectionAdminSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"StrategyVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"TokenVerified\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addressToCheck\",\"type\":\"address\"}],\"name\":\"isAddressVerified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lossless\",\"outputs\":[{\"internalType\":\"contract LosslessController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"protectionAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"protectedAddress\",\"type\":\"address\"}],\"name\":\"removeProtectedAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guardedAddress\",\"type\":\"address\"}],\"name\":\"setProtectedAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"setProtectionAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"verifiedStrategies\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"verifiedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"verifiedAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"verifyAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"verifyStrategies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"verifyToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LosslessGuardian","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e91d7cebce484070fc70777cb04f7e2efae31db4","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f54f06e67b305341947a27cdcd54644d944c9becd8dfcf1ccfab1abfd3054ed4"}]}