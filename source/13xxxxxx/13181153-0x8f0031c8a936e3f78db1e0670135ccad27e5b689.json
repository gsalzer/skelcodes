{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/discovery/GNS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../base/Multicall.sol\\\";\\nimport \\\"../bancor/BancorFormula.sol\\\";\\nimport \\\"../upgrades/GraphUpgradeable.sol\\\";\\nimport \\\"../utils/TokenUtils.sol\\\";\\n\\nimport \\\"./IGNS.sol\\\";\\nimport \\\"./GNSStorage.sol\\\";\\n\\n/**\\n * @title GNS\\n * @dev The Graph Name System contract provides a decentralized naming system for subgraphs\\n * used in the scope of the Graph Network. It translates subgraph names into subgraph versions.\\n * Each version is associated with a Subgraph Deployment. The contract has no knowledge of\\n * human-readable names. All human readable names emitted in events.\\n * The contract implements a multicall behaviour to support batching multiple calls in a single\\n * transaction.\\n */\\ncontract GNS is GNSV1Storage, GraphUpgradeable, IGNS, Multicall {\\n    using SafeMath for uint256;\\n\\n    // -- Constants --\\n\\n    uint256 private constant MAX_UINT256 = 2**256 - 1;\\n\\n    // 100% in parts per million\\n    uint32 private constant MAX_PPM = 1000000;\\n\\n    // Equates to Connector weight on bancor formula to be CW = 1\\n    uint32 private constant defaultReserveRatio = 1000000;\\n\\n    // -- Events --\\n\\n    /**\\n     * @dev Emitted when graph account sets its default name\\n     */\\n    event SetDefaultName(\\n        address indexed graphAccount,\\n        uint256 nameSystem, // only ENS for now\\n        bytes32 nameIdentifier,\\n        string name\\n    );\\n\\n    /**\\n     * @dev Emitted when graph account sets a subgraphs metadata on IPFS\\n     */\\n    event SubgraphMetadataUpdated(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        bytes32 subgraphMetadata\\n    );\\n\\n    /**\\n     * @dev Emitted when a `graph account` publishes a `subgraph` with a `version`.\\n     * Every time this event is emitted, indicates a new version has been created.\\n     * The event also emits a `metadataHash` with subgraph details and version details.\\n     */\\n    event SubgraphPublished(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        bytes32 indexed subgraphDeploymentID,\\n        bytes32 versionMetadata\\n    );\\n\\n    /**\\n     * @dev Emitted when a graph account deprecated one of its subgraphs\\n     */\\n    event SubgraphDeprecated(address indexed graphAccount, uint256 indexed subgraphNumber);\\n\\n    /**\\n     * @dev Emitted when a graphAccount creates an nSignal bonding curve that\\n     * points to a subgraph deployment\\n     */\\n    event NameSignalEnabled(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        bytes32 indexed subgraphDeploymentID,\\n        uint32 reserveRatio\\n    );\\n\\n    /**\\n     * @dev Emitted when a name curator deposits its vSignal into an nSignal curve to mint nSignal\\n     */\\n    event NSignalMinted(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        address indexed nameCurator,\\n        uint256 nSignalCreated,\\n        uint256 vSignalCreated,\\n        uint256 tokensDeposited\\n    );\\n\\n    /**\\n     * @dev Emitted when a name curator burns its nSignal, which in turn burns\\n     * the vSignal, and receives GRT\\n     */\\n    event NSignalBurned(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        address indexed nameCurator,\\n        uint256 nSignalBurnt,\\n        uint256 vSignalBurnt,\\n        uint256 tokensReceived\\n    );\\n\\n    /**\\n     * @dev Emitted when a graph account upgrades its nSignal curve to point to a new\\n     * subgraph deployment, burning all the old vSignal and depositing the GRT into the\\n     * new vSignal curve, creating new nSignal\\n     */\\n    event NameSignalUpgrade(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        uint256 newVSignalCreated,\\n        uint256 tokensSignalled,\\n        bytes32 indexed subgraphDeploymentID\\n    );\\n\\n    /**\\n     * @dev Emitted when an nSignal curve has been permanently disabled\\n     */\\n    event NameSignalDisabled(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        uint256 withdrawableGRT\\n    );\\n\\n    /**\\n     * @dev Emitted when a nameCurator withdraws its GRT from a deprecated name signal pool\\n     */\\n    event GRTWithdrawn(\\n        address indexed graphAccount,\\n        uint256 indexed subgraphNumber,\\n        address indexed nameCurator,\\n        uint256 nSignalBurnt,\\n        uint256 withdrawnGRT\\n    );\\n\\n    // -- Modifiers --\\n\\n    /**\\n     * @dev Check if the owner is the graph account\\n     * @param _graphAccount Address of the graph account\\n     */\\n    function _isGraphAccountOwner(address _graphAccount) private view {\\n        address graphAccountOwner = erc1056Registry.identityOwner(_graphAccount);\\n        require(graphAccountOwner == msg.sender, \\\"GNS: Only graph account owner can call\\\");\\n    }\\n\\n    /**\\n     * @dev Modifier that allows a function to be called by owner of a graph account\\n     * @param _graphAccount Address of the graph account\\n     */\\n    modifier onlyGraphAccountOwner(address _graphAccount) {\\n        _isGraphAccountOwner(_graphAccount);\\n        _;\\n    }\\n\\n    // -- Functions --\\n\\n    /**\\n     * @dev Initialize this contract.\\n     */\\n    function initialize(\\n        address _controller,\\n        address _bondingCurve,\\n        address _didRegistry\\n    ) external onlyImpl {\\n        Managed._initialize(_controller);\\n\\n        bondingCurve = _bondingCurve;\\n        erc1056Registry = IEthereumDIDRegistry(_didRegistry);\\n\\n        // Settings\\n        _setOwnerTaxPercentage(500000);\\n    }\\n\\n    /**\\n     * @dev Approve curation contract to pull funds.\\n     */\\n    function approveAll() external override {\\n        graphToken().approve(address(curation()), MAX_UINT256);\\n    }\\n\\n    /**\\n     * @dev Set the owner fee percentage. This is used to prevent a subgraph owner to drain all\\n     * the name curators tokens while upgrading or deprecating and is configurable in parts per hundred.\\n     * @param _ownerTaxPercentage Owner tax percentage\\n     */\\n    function setOwnerTaxPercentage(uint32 _ownerTaxPercentage) external override onlyGovernor {\\n        _setOwnerTaxPercentage(_ownerTaxPercentage);\\n    }\\n\\n    /**\\n     * @dev Internal: Set the owner tax percentage. This is used to prevent a subgraph owner to drain all\\n     * the name curators tokens while upgrading or deprecating and is configurable in parts per hundred.\\n     * @param _ownerTaxPercentage Owner tax percentage\\n     */\\n    function _setOwnerTaxPercentage(uint32 _ownerTaxPercentage) private {\\n        require(_ownerTaxPercentage <= MAX_PPM, \\\"Owner tax must be MAX_PPM or less\\\");\\n        ownerTaxPercentage = _ownerTaxPercentage;\\n        emit ParameterUpdated(\\\"ownerTaxPercentage\\\");\\n    }\\n\\n    /**\\n     * @dev Allows a graph account to set a default name\\n     * @param _graphAccount Account that is setting its name\\n     * @param _nameSystem Name system account already has ownership of a name in\\n     * @param _nameIdentifier The unique identifier that is used to identify the name in the system\\n     * @param _name The name being set as default\\n     */\\n    function setDefaultName(\\n        address _graphAccount,\\n        uint8 _nameSystem,\\n        bytes32 _nameIdentifier,\\n        string calldata _name\\n    ) external override onlyGraphAccountOwner(_graphAccount) {\\n        emit SetDefaultName(_graphAccount, _nameSystem, _nameIdentifier, _name);\\n    }\\n\\n    /**\\n     * @dev Allows a graph account update the metadata of a subgraph they have published\\n     * @param _graphAccount Account that owns the subgraph\\n     * @param _subgraphNumber Subgraph number\\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\\n     */\\n    function updateSubgraphMetadata(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        bytes32 _subgraphMetadata\\n    ) public override onlyGraphAccountOwner(_graphAccount) {\\n        emit SubgraphMetadataUpdated(_graphAccount, _subgraphNumber, _subgraphMetadata);\\n    }\\n\\n    /**\\n     * @dev Allows a graph account to publish a new subgraph, which means a new subgraph number\\n     * will be used.\\n     * @param _graphAccount Account that is publishing the subgraph\\n     * @param _subgraphDeploymentID Subgraph deployment ID of the version, linked to the name\\n     * @param _versionMetadata IPFS hash for the subgraph version metadata\\n     * @param _subgraphMetadata IPFS hash for the subgraph metadata\\n     */\\n    function publishNewSubgraph(\\n        address _graphAccount,\\n        bytes32 _subgraphDeploymentID,\\n        bytes32 _versionMetadata,\\n        bytes32 _subgraphMetadata\\n    ) external override notPaused onlyGraphAccountOwner(_graphAccount) {\\n        uint256 subgraphNumber = graphAccountSubgraphNumbers[_graphAccount];\\n        _publishVersion(_graphAccount, subgraphNumber, _subgraphDeploymentID, _versionMetadata);\\n        graphAccountSubgraphNumbers[_graphAccount] = graphAccountSubgraphNumbers[_graphAccount].add(\\n            1\\n        );\\n        updateSubgraphMetadata(_graphAccount, subgraphNumber, _subgraphMetadata);\\n        _enableNameSignal(_graphAccount, subgraphNumber);\\n    }\\n\\n    /**\\n     * @dev Allows a graph account to publish a new version of its subgraph.\\n     * Version is derived from the occurrence of SubgraphPublished being emitted.\\n     * The first time SubgraphPublished is called would be Version 0\\n     * @param _graphAccount Account that is publishing the subgraph\\n     * @param _subgraphNumber Subgraph number for the account\\n     * @param _subgraphDeploymentID Subgraph deployment ID of the version, linked to the name\\n     * @param _versionMetadata IPFS hash for the subgraph version metadata\\n     */\\n    function publishNewVersion(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        bytes32 _subgraphDeploymentID,\\n        bytes32 _versionMetadata\\n    ) external override notPaused onlyGraphAccountOwner(_graphAccount) {\\n        require(\\n            isPublished(_graphAccount, _subgraphNumber),\\n            \\\"GNS: Cannot update version if not published, or has been deprecated\\\"\\n        );\\n        bytes32 oldSubgraphDeploymentID = subgraphs[_graphAccount][_subgraphNumber];\\n        require(\\n            _subgraphDeploymentID != oldSubgraphDeploymentID,\\n            \\\"GNS: Cannot publish a new version with the same subgraph deployment ID\\\"\\n        );\\n\\n        _publishVersion(_graphAccount, _subgraphNumber, _subgraphDeploymentID, _versionMetadata);\\n        _upgradeNameSignal(_graphAccount, _subgraphNumber, _subgraphDeploymentID);\\n    }\\n\\n    /**\\n     * @dev Private function used by both external publishing functions\\n     * @param _graphAccount Account that is publishing the subgraph\\n     * @param _subgraphNumber Subgraph number for the account\\n     * @param _subgraphDeploymentID Subgraph deployment ID of the version, linked to the name\\n     * @param _versionMetadata IPFS hash for the subgraph version metadata\\n     */\\n    function _publishVersion(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        bytes32 _subgraphDeploymentID,\\n        bytes32 _versionMetadata\\n    ) private {\\n        require(_subgraphDeploymentID != 0, \\\"GNS: Cannot set deploymentID to 0 in publish\\\");\\n\\n        // Stores a subgraph deployment ID, which indicates a version has been created\\n        subgraphs[_graphAccount][_subgraphNumber] = _subgraphDeploymentID;\\n\\n        // Emit version and name data\\n        emit SubgraphPublished(\\n            _graphAccount,\\n            _subgraphNumber,\\n            _subgraphDeploymentID,\\n            _versionMetadata\\n        );\\n    }\\n\\n    /**\\n     * @dev Deprecate a subgraph. Can only be done by the graph account owner.\\n     * @param _graphAccount Account that is deprecating the subgraph\\n     * @param _subgraphNumber Subgraph number for the account\\n     */\\n    function deprecateSubgraph(address _graphAccount, uint256 _subgraphNumber)\\n        external\\n        override\\n        notPaused\\n        onlyGraphAccountOwner(_graphAccount)\\n    {\\n        require(\\n            isPublished(_graphAccount, _subgraphNumber),\\n            \\\"GNS: Cannot deprecate a subgraph which does not exist\\\"\\n        );\\n\\n        delete subgraphs[_graphAccount][_subgraphNumber];\\n        emit SubgraphDeprecated(_graphAccount, _subgraphNumber);\\n\\n        _disableNameSignal(_graphAccount, _subgraphNumber);\\n    }\\n\\n    /**\\n     * @dev Enable name signal on a graph accounts numbered subgraph, which points to a subgraph\\n     * deployment\\n     * @param _graphAccount Graph account enabling name signal\\n     * @param _subgraphNumber Subgraph number being used\\n     */\\n    function _enableNameSignal(address _graphAccount, uint256 _subgraphNumber) private {\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        namePool.subgraphDeploymentID = subgraphs[_graphAccount][_subgraphNumber];\\n        namePool.reserveRatio = defaultReserveRatio;\\n\\n        emit NameSignalEnabled(\\n            _graphAccount,\\n            _subgraphNumber,\\n            namePool.subgraphDeploymentID,\\n            namePool.reserveRatio\\n        );\\n    }\\n\\n    /**\\n     * @dev Update a name signal on a graph accounts numbered subgraph\\n     * @param _graphAccount Graph account updating name signal\\n     * @param _subgraphNumber Subgraph number being used\\n     * @param _newSubgraphDeploymentID Deployment ID being upgraded to\\n     */\\n    function _upgradeNameSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        bytes32 _newSubgraphDeploymentID\\n    ) private {\\n        // This is to prevent the owner from front running its name curators signal by posting\\n        // its own signal ahead, bringing the name curators in, and dumping on them\\n        ICuration curation = curation();\\n        require(\\n            !curation.isCurated(_newSubgraphDeploymentID),\\n            \\\"GNS: Owner cannot point to a subgraphID that has been pre-curated\\\"\\n        );\\n\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        require(\\n            namePool.nSignal > 0,\\n            \\\"GNS: There must be nSignal on this subgraph for curve math to work\\\"\\n        );\\n        require(namePool.disabled == false, \\\"GNS: Cannot be disabled\\\");\\n\\n        // Burn all version signal in the name pool for tokens\\n        uint256 tokens = curation.burn(namePool.subgraphDeploymentID, namePool.vSignal, 0);\\n\\n        // Take the owner cut of the curation tax, add it to the total\\n        uint32 curationTaxPercentage = curation.curationTaxPercentage();\\n        uint256 tokensWithTax = _chargeOwnerTax(tokens, _graphAccount, curationTaxPercentage);\\n\\n        // Update pool: constant nSignal, vSignal can change\\n        namePool.subgraphDeploymentID = _newSubgraphDeploymentID;\\n        (namePool.vSignal, ) = curation.mint(namePool.subgraphDeploymentID, tokensWithTax, 0);\\n\\n        emit NameSignalUpgrade(\\n            _graphAccount,\\n            _subgraphNumber,\\n            namePool.vSignal,\\n            tokensWithTax,\\n            _newSubgraphDeploymentID\\n        );\\n    }\\n\\n    /**\\n     * @dev Allow a name curator to mint some nSignal by depositing GRT\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number\\n     * @param _tokensIn The amount of tokens the nameCurator wants to deposit\\n     * @param _nSignalOutMin Expected minimum amount of name signal to receive\\n     */\\n    function mintNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _tokensIn,\\n        uint256 _nSignalOutMin\\n    ) external override notPartialPaused {\\n        // Pool checks\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        require(namePool.disabled == false, \\\"GNS: Cannot be disabled\\\");\\n        require(\\n            namePool.subgraphDeploymentID != 0,\\n            \\\"GNS: Must deposit on a name signal that exists\\\"\\n        );\\n\\n        // Pull tokens from sender\\n        TokenUtils.pullTokens(graphToken(), msg.sender, _tokensIn);\\n\\n        // Get name signal to mint for tokens deposited\\n        (uint256 vSignal, ) = curation().mint(namePool.subgraphDeploymentID, _tokensIn, 0);\\n        uint256 nSignal = vSignalToNSignal(_graphAccount, _subgraphNumber, vSignal);\\n\\n        // Slippage protection\\n        require(nSignal >= _nSignalOutMin, \\\"GNS: Slippage protection\\\");\\n\\n        // Update pools\\n        namePool.vSignal = namePool.vSignal.add(vSignal);\\n        namePool.nSignal = namePool.nSignal.add(nSignal);\\n        namePool.curatorNSignal[msg.sender] = namePool.curatorNSignal[msg.sender].add(nSignal);\\n\\n        emit NSignalMinted(_graphAccount, _subgraphNumber, msg.sender, nSignal, vSignal, _tokensIn);\\n    }\\n\\n    /**\\n     * @dev Allow a nameCurator to burn some of its nSignal and get GRT in return\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number which was curated on by nameCurators\\n     * @param _nSignal The amount of nSignal the nameCurator wants to burn\\n     * @param _tokensOutMin Expected minimum amount of tokens to receive\\n     */\\n    function burnNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _nSignal,\\n        uint256 _tokensOutMin\\n    ) external override notPartialPaused {\\n        // Pool checks\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        require(namePool.disabled == false, \\\"GNS: Cannot be disabled\\\");\\n\\n        // Curator balance checks\\n        uint256 curatorNSignal = namePool.curatorNSignal[msg.sender];\\n        require(\\n            _nSignal <= curatorNSignal,\\n            \\\"GNS: Curator cannot withdraw more nSignal than they have\\\"\\n        );\\n\\n        // Get tokens for name signal amount to burn\\n        uint256 vSignal = nSignalToVSignal(_graphAccount, _subgraphNumber, _nSignal);\\n        uint256 tokens = curation().burn(namePool.subgraphDeploymentID, vSignal, _tokensOutMin);\\n\\n        // Update pools\\n        namePool.vSignal = namePool.vSignal.sub(vSignal);\\n        namePool.nSignal = namePool.nSignal.sub(_nSignal);\\n        namePool.curatorNSignal[msg.sender] = namePool.curatorNSignal[msg.sender].sub(_nSignal);\\n\\n        // Return the tokens to the curator\\n        TokenUtils.pushTokens(graphToken(), msg.sender, tokens);\\n\\n        emit NSignalBurned(_graphAccount, _subgraphNumber, msg.sender, _nSignal, vSignal, tokens);\\n    }\\n\\n    /**\\n     * @dev Owner disables the subgraph. This means the subgraph-number combination can no longer\\n     * be used for name signal. The nSignal curve is destroyed, the vSignal is burned, and the GNS\\n     * contract holds the GRT from burning the vSignal, which all curators can withdraw manually.\\n     * @param _graphAccount Account that is deprecating its name curation\\n     * @param _subgraphNumber Subgraph number\\n     */\\n    function _disableNameSignal(address _graphAccount, uint256 _subgraphNumber) private {\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n\\n        // If no nSignal, then no need to burn vSignal\\n        if (namePool.nSignal != 0) {\\n            // Note: No slippage, burn at any cost\\n            namePool.withdrawableGRT = curation().burn(\\n                namePool.subgraphDeploymentID,\\n                namePool.vSignal,\\n                0\\n            );\\n            namePool.vSignal = 0;\\n        }\\n\\n        // Set the NameCurationPool fields to make it disabled\\n        namePool.disabled = true;\\n\\n        emit NameSignalDisabled(_graphAccount, _subgraphNumber, namePool.withdrawableGRT);\\n    }\\n\\n    /**\\n     * @dev When the subgraph curve is disabled, all nameCurators can call this function and\\n     * withdraw the GRT they are entitled for its original deposit of vSignal\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number which was curated on by nameCurators\\n     */\\n    function withdraw(address _graphAccount, uint256 _subgraphNumber)\\n        external\\n        override\\n        notPartialPaused\\n    {\\n        // Pool checks\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        require(namePool.disabled == true, \\\"GNS: Name bonding curve must be disabled first\\\");\\n        require(namePool.withdrawableGRT > 0, \\\"GNS: No more GRT to withdraw\\\");\\n\\n        // Curator balance checks\\n        uint256 curatorNSignal = namePool.curatorNSignal[msg.sender];\\n        require(curatorNSignal > 0, \\\"GNS: Curator must have some nSignal to withdraw GRT\\\");\\n\\n        // Get curator share of tokens to be withdrawn\\n        uint256 tokensOut = curatorNSignal.mul(namePool.withdrawableGRT).div(namePool.nSignal);\\n        namePool.curatorNSignal[msg.sender] = 0;\\n        namePool.nSignal = namePool.nSignal.sub(curatorNSignal);\\n        namePool.withdrawableGRT = namePool.withdrawableGRT.sub(tokensOut);\\n\\n        // Return tokens to the curator\\n        TokenUtils.pushTokens(graphToken(), msg.sender, tokensOut);\\n\\n        emit GRTWithdrawn(_graphAccount, _subgraphNumber, msg.sender, curatorNSignal, tokensOut);\\n    }\\n\\n    /**\\n     * @dev Calculate tax that owner will have to cover for upgrading or deprecating.\\n     * @param _tokens Tokens that were received from deprecating the old subgraph\\n     * @param _owner Subgraph owner\\n     * @param _curationTaxPercentage Tax percentage on curation deposits from Curation contract\\n     * @return Total tokens that will be sent to curation, _tokens + ownerTax\\n     */\\n    function _chargeOwnerTax(\\n        uint256 _tokens,\\n        address _owner,\\n        uint32 _curationTaxPercentage\\n    ) private returns (uint256) {\\n        if (_curationTaxPercentage == 0 || ownerTaxPercentage == 0) {\\n            return 0;\\n        }\\n\\n        // Tax on the total bonding curve funds\\n        uint256 taxOnOriginal = _tokens.mul(_curationTaxPercentage).div(MAX_PPM);\\n        // Total after the tax\\n        uint256 totalWithoutOwnerTax = _tokens.sub(taxOnOriginal);\\n        // The portion of tax that the owner will pay\\n        uint256 ownerTax = taxOnOriginal.mul(ownerTaxPercentage).div(MAX_PPM);\\n\\n        uint256 totalWithOwnerTax = totalWithoutOwnerTax.add(ownerTax);\\n\\n        // The total after tax, plus owner partial repay, divided by\\n        // the tax, to adjust it slightly upwards. ex:\\n        // 100 GRT, 5 GRT Tax, owner pays 100% --> 5 GRT\\n        // To get 100 in the protocol after tax, Owner deposits\\n        // ~5.26, as ~105.26 * .95 = 100\\n        uint256 totalAdjustedUp = totalWithOwnerTax.mul(MAX_PPM).div(\\n            uint256(MAX_PPM).sub(uint256(_curationTaxPercentage))\\n        );\\n\\n        uint256 ownerTaxAdjustedUp = totalAdjustedUp.sub(_tokens);\\n\\n        // Get the owner of the subgraph to reimburse the curation tax\\n        TokenUtils.pullTokens(graphToken(), _owner, ownerTaxAdjustedUp);\\n\\n        return totalAdjustedUp;\\n    }\\n\\n    /**\\n     * @dev Calculate name signal to be returned for an amount of tokens.\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number which was curated on by nameCurators\\n     * @param _tokensIn Tokens being exchanged for name signal\\n     * @return Amount of name signal and curation tax\\n     */\\n    function tokensToNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _tokensIn\\n    )\\n        public\\n        view\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        (uint256 vSignal, uint256 curationTax) = curation().tokensToSignal(\\n            namePool.subgraphDeploymentID,\\n            _tokensIn\\n        );\\n        uint256 nSignal = vSignalToNSignal(_graphAccount, _subgraphNumber, vSignal);\\n        return (vSignal, nSignal, curationTax);\\n    }\\n\\n    /**\\n     * @dev Calculate tokens returned for an amount of name signal.\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number which was curated on by nameCurators\\n     * @param _nSignalIn Name signal being exchanged for tokens\\n     * @return Amount of tokens returned for an amount of nSignal\\n     */\\n    function nSignalToTokens(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _nSignalIn\\n    ) public view override returns (uint256, uint256) {\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        uint256 vSignal = nSignalToVSignal(_graphAccount, _subgraphNumber, _nSignalIn);\\n        uint256 tokensOut = curation().signalToTokens(namePool.subgraphDeploymentID, vSignal);\\n        return (vSignal, tokensOut);\\n    }\\n\\n    /**\\n     * @dev Calculate nSignal to be returned for an amount of vSignal.\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number which was curated on by nameCurators\\n     * @param _vSignalIn Amount of vSignal to exchange for name signal\\n     * @return Amount of nSignal that can be bought\\n     */\\n    function vSignalToNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _vSignalIn\\n    ) public view override returns (uint256) {\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n\\n        // Handle initialization by using 1:1 version to name signal\\n        if (namePool.vSignal == 0) {\\n            return _vSignalIn;\\n        }\\n\\n        return\\n            BancorFormula(bondingCurve).calculatePurchaseReturn(\\n                namePool.nSignal,\\n                namePool.vSignal,\\n                namePool.reserveRatio,\\n                _vSignalIn\\n            );\\n    }\\n\\n    /**\\n     * @dev Calculate vSignal to be returned for an amount of name signal.\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number which was curated on by nameCurators\\n     * @param _nSignalIn Name signal being exchanged for vSignal\\n     * @return Amount of vSignal that can be returned\\n     */\\n    function nSignalToVSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _nSignalIn\\n    ) public view override returns (uint256) {\\n        NameCurationPool storage namePool = nameSignals[_graphAccount][_subgraphNumber];\\n        return\\n            BancorFormula(bondingCurve).calculateSaleReturn(\\n                namePool.nSignal,\\n                namePool.vSignal,\\n                namePool.reserveRatio,\\n                _nSignalIn\\n            );\\n    }\\n\\n    /**\\n     * @dev Get the amount of name signal a curator has on a name pool.\\n     * @param _graphAccount Subgraph owner\\n     * @param _subgraphNumber Subgraph owners subgraph number which was curated on by nameCurators\\n     * @param _curator Curator to look up to see n signal balance\\n     * @return Amount of name signal owned by a curator for the name pool\\n     */\\n    function getCuratorNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        address _curator\\n    ) public view override returns (uint256) {\\n        return nameSignals[_graphAccount][_subgraphNumber].curatorNSignal[_curator];\\n    }\\n\\n    /**\\n     * @dev Return whether a subgraph name is published.\\n     * @param _graphAccount Account being checked\\n     * @param _subgraphNumber Subgraph number being checked for publishing\\n     * @return Return true if subgraph is currently published\\n     */\\n    function isPublished(address _graphAccount, uint256 _subgraphNumber)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return subgraphs[_graphAccount][_subgraphNumber] != 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/base/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IMulticall.sol\\\";\\n\\n// Inspired by https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol\\n// Note: Removed payable from the multicall\\n\\n/**\\n * @title Multicall\\n * @notice Enables calling multiple methods in a single call to the contract\\n */\\nabstract contract Multicall is IMulticall {\\n    /// @inheritdoc IMulticall\\n    function multicall(bytes[] calldata data) external override returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n\\n            if (!success) {\\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\\n                if (result.length < 68) revert();\\n                assembly {\\n                    result := add(result, 0x04)\\n                }\\n                revert(abi.decode(result, (string)));\\n            }\\n\\n            results[i] = result;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/bancor/BancorFormula.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract BancorFormula {\\n    using SafeMath for uint256;\\n\\n    uint16 public constant version = 6;\\n\\n    uint256 private constant ONE = 1;\\n    uint32 private constant MAX_RATIO = 1000000;\\n    uint8 private constant MIN_PRECISION = 32;\\n    uint8 private constant MAX_PRECISION = 127;\\n\\n    /**\\n     * @dev Auto-generated via 'PrintIntScalingFactors.py'\\n     */\\n    uint256 private constant FIXED_1 = 0x080000000000000000000000000000000;\\n    uint256 private constant FIXED_2 = 0x100000000000000000000000000000000;\\n    uint256 private constant MAX_NUM = 0x200000000000000000000000000000000;\\n\\n    /**\\n     * @dev Auto-generated via 'PrintLn2ScalingFactors.py'\\n     */\\n    uint256 private constant LN2_NUMERATOR = 0x3f80fe03f80fe03f80fe03f80fe03f8;\\n    uint256 private constant LN2_DENOMINATOR = 0x5b9de1d10bf4103d647b0955897ba80;\\n\\n    /**\\n     * @dev Auto-generated via 'PrintFunctionOptimalLog.py' and 'PrintFunctionOptimalExp.py'\\n     */\\n    uint256 private constant OPT_LOG_MAX_VAL = 0x15bf0a8b1457695355fb8ac404e7a79e3;\\n    uint256 private constant OPT_EXP_MAX_VAL = 0x800000000000000000000000000000000;\\n\\n    /**\\n     * @dev Auto-generated via 'PrintFunctionConstructor.py'\\n     */\\n    uint256[128] private maxExpArray;\\n\\n    constructor() {\\n        //  maxExpArray[  0] = 0x6bffffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  1] = 0x67ffffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  2] = 0x637fffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  3] = 0x5f6fffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  4] = 0x5b77ffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  5] = 0x57b3ffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  6] = 0x5419ffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  7] = 0x50a2ffffffffffffffffffffffffffffff;\\n        //  maxExpArray[  8] = 0x4d517fffffffffffffffffffffffffffff;\\n        //  maxExpArray[  9] = 0x4a233fffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 10] = 0x47165fffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 11] = 0x4429afffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 12] = 0x415bc7ffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 13] = 0x3eab73ffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 14] = 0x3c1771ffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 15] = 0x399e96ffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 16] = 0x373fc47fffffffffffffffffffffffffff;\\n        //  maxExpArray[ 17] = 0x34f9e8ffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 18] = 0x32cbfd5fffffffffffffffffffffffffff;\\n        //  maxExpArray[ 19] = 0x30b5057fffffffffffffffffffffffffff;\\n        //  maxExpArray[ 20] = 0x2eb40f9fffffffffffffffffffffffffff;\\n        //  maxExpArray[ 21] = 0x2cc8340fffffffffffffffffffffffffff;\\n        //  maxExpArray[ 22] = 0x2af09481ffffffffffffffffffffffffff;\\n        //  maxExpArray[ 23] = 0x292c5bddffffffffffffffffffffffffff;\\n        //  maxExpArray[ 24] = 0x277abdcdffffffffffffffffffffffffff;\\n        //  maxExpArray[ 25] = 0x25daf6657fffffffffffffffffffffffff;\\n        //  maxExpArray[ 26] = 0x244c49c65fffffffffffffffffffffffff;\\n        //  maxExpArray[ 27] = 0x22ce03cd5fffffffffffffffffffffffff;\\n        //  maxExpArray[ 28] = 0x215f77c047ffffffffffffffffffffffff;\\n        //  maxExpArray[ 29] = 0x1fffffffffffffffffffffffffffffffff;\\n        //  maxExpArray[ 30] = 0x1eaefdbdabffffffffffffffffffffffff;\\n        //  maxExpArray[ 31] = 0x1d6bd8b2ebffffffffffffffffffffffff;\\n        maxExpArray[32] = 0x1c35fedd14ffffffffffffffffffffffff;\\n        maxExpArray[33] = 0x1b0ce43b323fffffffffffffffffffffff;\\n        maxExpArray[34] = 0x19f0028ec1ffffffffffffffffffffffff;\\n        maxExpArray[35] = 0x18ded91f0e7fffffffffffffffffffffff;\\n        maxExpArray[36] = 0x17d8ec7f0417ffffffffffffffffffffff;\\n        maxExpArray[37] = 0x16ddc6556cdbffffffffffffffffffffff;\\n        maxExpArray[38] = 0x15ecf52776a1ffffffffffffffffffffff;\\n        maxExpArray[39] = 0x15060c256cb2ffffffffffffffffffffff;\\n        maxExpArray[40] = 0x1428a2f98d72ffffffffffffffffffffff;\\n        maxExpArray[41] = 0x13545598e5c23fffffffffffffffffffff;\\n        maxExpArray[42] = 0x1288c4161ce1dfffffffffffffffffffff;\\n        maxExpArray[43] = 0x11c592761c666fffffffffffffffffffff;\\n        maxExpArray[44] = 0x110a688680a757ffffffffffffffffffff;\\n        maxExpArray[45] = 0x1056f1b5bedf77ffffffffffffffffffff;\\n        maxExpArray[46] = 0x0faadceceeff8bffffffffffffffffffff;\\n        maxExpArray[47] = 0x0f05dc6b27edadffffffffffffffffffff;\\n        maxExpArray[48] = 0x0e67a5a25da4107fffffffffffffffffff;\\n        maxExpArray[49] = 0x0dcff115b14eedffffffffffffffffffff;\\n        maxExpArray[50] = 0x0d3e7a392431239fffffffffffffffffff;\\n        maxExpArray[51] = 0x0cb2ff529eb71e4fffffffffffffffffff;\\n        maxExpArray[52] = 0x0c2d415c3db974afffffffffffffffffff;\\n        maxExpArray[53] = 0x0bad03e7d883f69bffffffffffffffffff;\\n        maxExpArray[54] = 0x0b320d03b2c343d5ffffffffffffffffff;\\n        maxExpArray[55] = 0x0abc25204e02828dffffffffffffffffff;\\n        maxExpArray[56] = 0x0a4b16f74ee4bb207fffffffffffffffff;\\n        maxExpArray[57] = 0x09deaf736ac1f569ffffffffffffffffff;\\n        maxExpArray[58] = 0x0976bd9952c7aa957fffffffffffffffff;\\n        maxExpArray[59] = 0x09131271922eaa606fffffffffffffffff;\\n        maxExpArray[60] = 0x08b380f3558668c46fffffffffffffffff;\\n        maxExpArray[61] = 0x0857ddf0117efa215bffffffffffffffff;\\n        maxExpArray[62] = 0x07ffffffffffffffffffffffffffffffff;\\n        maxExpArray[63] = 0x07abbf6f6abb9d087fffffffffffffffff;\\n        maxExpArray[64] = 0x075af62cbac95f7dfa7fffffffffffffff;\\n        maxExpArray[65] = 0x070d7fb7452e187ac13fffffffffffffff;\\n        maxExpArray[66] = 0x06c3390ecc8af379295fffffffffffffff;\\n        maxExpArray[67] = 0x067c00a3b07ffc01fd6fffffffffffffff;\\n        maxExpArray[68] = 0x0637b647c39cbb9d3d27ffffffffffffff;\\n        maxExpArray[69] = 0x05f63b1fc104dbd39587ffffffffffffff;\\n        maxExpArray[70] = 0x05b771955b36e12f7235ffffffffffffff;\\n        maxExpArray[71] = 0x057b3d49dda84556d6f6ffffffffffffff;\\n        maxExpArray[72] = 0x054183095b2c8ececf30ffffffffffffff;\\n        maxExpArray[73] = 0x050a28be635ca2b888f77fffffffffffff;\\n        maxExpArray[74] = 0x04d5156639708c9db33c3fffffffffffff;\\n        maxExpArray[75] = 0x04a23105873875bd52dfdfffffffffffff;\\n        maxExpArray[76] = 0x0471649d87199aa990756fffffffffffff;\\n        maxExpArray[77] = 0x04429a21a029d4c1457cfbffffffffffff;\\n        maxExpArray[78] = 0x0415bc6d6fb7dd71af2cb3ffffffffffff;\\n        maxExpArray[79] = 0x03eab73b3bbfe282243ce1ffffffffffff;\\n        maxExpArray[80] = 0x03c1771ac9fb6b4c18e229ffffffffffff;\\n        maxExpArray[81] = 0x0399e96897690418f785257fffffffffff;\\n        maxExpArray[82] = 0x0373fc456c53bb779bf0ea9fffffffffff;\\n        maxExpArray[83] = 0x034f9e8e490c48e67e6ab8bfffffffffff;\\n        maxExpArray[84] = 0x032cbfd4a7adc790560b3337ffffffffff;\\n        maxExpArray[85] = 0x030b50570f6e5d2acca94613ffffffffff;\\n        maxExpArray[86] = 0x02eb40f9f620fda6b56c2861ffffffffff;\\n        maxExpArray[87] = 0x02cc8340ecb0d0f520a6af58ffffffffff;\\n        maxExpArray[88] = 0x02af09481380a0a35cf1ba02ffffffffff;\\n        maxExpArray[89] = 0x0292c5bdd3b92ec810287b1b3fffffffff;\\n        maxExpArray[90] = 0x0277abdcdab07d5a77ac6d6b9fffffffff;\\n        maxExpArray[91] = 0x025daf6654b1eaa55fd64df5efffffffff;\\n        maxExpArray[92] = 0x0244c49c648baa98192dce88b7ffffffff;\\n        maxExpArray[93] = 0x022ce03cd5619a311b2471268bffffffff;\\n        maxExpArray[94] = 0x0215f77c045fbe885654a44a0fffffffff;\\n        maxExpArray[95] = 0x01ffffffffffffffffffffffffffffffff;\\n        maxExpArray[96] = 0x01eaefdbdaaee7421fc4d3ede5ffffffff;\\n        maxExpArray[97] = 0x01d6bd8b2eb257df7e8ca57b09bfffffff;\\n        maxExpArray[98] = 0x01c35fedd14b861eb0443f7f133fffffff;\\n        maxExpArray[99] = 0x01b0ce43b322bcde4a56e8ada5afffffff;\\n        maxExpArray[100] = 0x019f0028ec1fff007f5a195a39dfffffff;\\n        maxExpArray[101] = 0x018ded91f0e72ee74f49b15ba527ffffff;\\n        maxExpArray[102] = 0x017d8ec7f04136f4e5615fd41a63ffffff;\\n        maxExpArray[103] = 0x016ddc6556cdb84bdc8d12d22e6fffffff;\\n        maxExpArray[104] = 0x015ecf52776a1155b5bd8395814f7fffff;\\n        maxExpArray[105] = 0x015060c256cb23b3b3cc3754cf40ffffff;\\n        maxExpArray[106] = 0x01428a2f98d728ae223ddab715be3fffff;\\n        maxExpArray[107] = 0x013545598e5c23276ccf0ede68034fffff;\\n        maxExpArray[108] = 0x01288c4161ce1d6f54b7f61081194fffff;\\n        maxExpArray[109] = 0x011c592761c666aa641d5a01a40f17ffff;\\n        maxExpArray[110] = 0x0110a688680a7530515f3e6e6cfdcdffff;\\n        maxExpArray[111] = 0x01056f1b5bedf75c6bcb2ce8aed428ffff;\\n        maxExpArray[112] = 0x00faadceceeff8a0890f3875f008277fff;\\n        maxExpArray[113] = 0x00f05dc6b27edad306388a600f6ba0bfff;\\n        maxExpArray[114] = 0x00e67a5a25da41063de1495d5b18cdbfff;\\n        maxExpArray[115] = 0x00dcff115b14eedde6fc3aa5353f2e4fff;\\n        maxExpArray[116] = 0x00d3e7a3924312399f9aae2e0f868f8fff;\\n        maxExpArray[117] = 0x00cb2ff529eb71e41582cccd5a1ee26fff;\\n        maxExpArray[118] = 0x00c2d415c3db974ab32a51840c0b67edff;\\n        maxExpArray[119] = 0x00bad03e7d883f69ad5b0a186184e06bff;\\n        maxExpArray[120] = 0x00b320d03b2c343d4829abd6075f0cc5ff;\\n        maxExpArray[121] = 0x00abc25204e02828d73c6e80bcdb1a95bf;\\n        maxExpArray[122] = 0x00a4b16f74ee4bb2040a1ec6c15fbbf2df;\\n        maxExpArray[123] = 0x009deaf736ac1f569deb1b5ae3f36c130f;\\n        maxExpArray[124] = 0x00976bd9952c7aa957f5937d790ef65037;\\n        maxExpArray[125] = 0x009131271922eaa6064b73a22d0bd4f2bf;\\n        maxExpArray[126] = 0x008b380f3558668c46c91c49a2f8e967b9;\\n        maxExpArray[127] = 0x00857ddf0117efa215952912839f6473e6;\\n    }\\n\\n    /**\\n     * @dev given a token supply, reserve balance, ratio and a deposit amount (in the reserve token),\\n     * calculates the return for a given conversion (in the main token)\\n     *\\n     * Formula:\\n     * Return = _supply * ((1 + _depositAmount / _reserveBalance) ^ (_reserveRatio / 1000000) - 1)\\n     *\\n     * @param _supply              token total supply\\n     * @param _reserveBalance      total reserve balance\\n     * @param _reserveRatio        reserve ratio, represented in ppm, 1-1000000\\n     * @param _depositAmount       deposit amount, in reserve token\\n     *\\n     * @return purchase return amount\\n     */\\n    function calculatePurchaseReturn(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _reserveRatio,\\n        uint256 _depositAmount\\n    ) public view returns (uint256) {\\n        // validate input\\n        require(\\n            _supply > 0 && _reserveBalance > 0 && _reserveRatio > 0 && _reserveRatio <= MAX_RATIO,\\n            \\\"invalid parameters\\\"\\n        );\\n\\n        // special case for 0 deposit amount\\n        if (_depositAmount == 0) return 0;\\n\\n        // special case if the ratio = 100%\\n        if (_reserveRatio == MAX_RATIO) return _supply.mul(_depositAmount) / _reserveBalance;\\n\\n        uint256 result;\\n        uint8 precision;\\n        uint256 baseN = _depositAmount.add(_reserveBalance);\\n        (result, precision) = power(baseN, _reserveBalance, _reserveRatio, MAX_RATIO);\\n        uint256 temp = _supply.mul(result) >> precision;\\n        return temp - _supply;\\n    }\\n\\n    /**\\n     * @dev given a token supply, reserve balance, ratio and a sell amount (in the main token),\\n     * calculates the return for a given conversion (in the reserve token)\\n     *\\n     * Formula:\\n     * Return = _reserveBalance * (1 - (1 - _sellAmount / _supply) ^ (1000000 / _reserveRatio))\\n     *\\n     * @param _supply              token total supply\\n     * @param _reserveBalance      total reserve\\n     * @param _reserveRatio        constant reserve Ratio, represented in ppm, 1-1000000\\n     * @param _sellAmount          sell amount, in the token itself\\n     *\\n     * @return sale return amount\\n     */\\n    function calculateSaleReturn(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _reserveRatio,\\n        uint256 _sellAmount\\n    ) public view returns (uint256) {\\n        // validate input\\n        require(\\n            _supply > 0 &&\\n                _reserveBalance > 0 &&\\n                _reserveRatio > 0 &&\\n                _reserveRatio <= MAX_RATIO &&\\n                _sellAmount <= _supply,\\n            \\\"invalid parameters\\\"\\n        );\\n\\n        // special case for 0 sell amount\\n        if (_sellAmount == 0) return 0;\\n\\n        // special case for selling the entire supply\\n        if (_sellAmount == _supply) return _reserveBalance;\\n\\n        // special case if the ratio = 100%\\n        if (_reserveRatio == MAX_RATIO) return _reserveBalance.mul(_sellAmount) / _supply;\\n\\n        uint256 result;\\n        uint8 precision;\\n        uint256 baseD = _supply - _sellAmount;\\n        (result, precision) = power(_supply, baseD, MAX_RATIO, _reserveRatio);\\n        uint256 temp1 = _reserveBalance.mul(result);\\n        uint256 temp2 = _reserveBalance << precision;\\n        return (temp1 - temp2) / result;\\n    }\\n\\n    /**\\n     * @dev given two reserve balances/ratios and a sell amount (in the first reserve token),\\n     * calculates the return for a conversion from the first reserve token to the second reserve token (in the second reserve token)\\n     * note that prior to version 4, you should use 'calculateCrossConnectorReturn' instead\\n     *\\n     * Formula:\\n     * Return = _toReserveBalance * (1 - (_fromReserveBalance / (_fromReserveBalance + _amount)) ^ (_fromReserveRatio / _toReserveRatio))\\n     *\\n     * @param _fromReserveBalance      input reserve balance\\n     * @param _fromReserveRatio        input reserve ratio, represented in ppm, 1-1000000\\n     * @param _toReserveBalance        output reserve balance\\n     * @param _toReserveRatio          output reserve ratio, represented in ppm, 1-1000000\\n     * @param _amount                  input reserve amount\\n     *\\n     * @return second reserve amount\\n     */\\n    function calculateCrossReserveReturn(\\n        uint256 _fromReserveBalance,\\n        uint32 _fromReserveRatio,\\n        uint256 _toReserveBalance,\\n        uint32 _toReserveRatio,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        // validate input\\n        require(\\n            _fromReserveBalance > 0 &&\\n                _fromReserveRatio > 0 &&\\n                _fromReserveRatio <= MAX_RATIO &&\\n                _toReserveBalance > 0 &&\\n                _toReserveRatio > 0 &&\\n                _toReserveRatio <= MAX_RATIO\\n        );\\n\\n        // special case for equal ratios\\n        if (_fromReserveRatio == _toReserveRatio)\\n            return _toReserveBalance.mul(_amount) / _fromReserveBalance.add(_amount);\\n\\n        uint256 result;\\n        uint8 precision;\\n        uint256 baseN = _fromReserveBalance.add(_amount);\\n        (result, precision) = power(baseN, _fromReserveBalance, _fromReserveRatio, _toReserveRatio);\\n        uint256 temp1 = _toReserveBalance.mul(result);\\n        uint256 temp2 = _toReserveBalance << precision;\\n        return (temp1 - temp2) / result;\\n    }\\n\\n    /**\\n     * @dev given a smart token supply, reserve balance, total ratio and an amount of requested smart tokens,\\n     * calculates the amount of reserve tokens required for purchasing the given amount of smart tokens\\n     *\\n     * Formula:\\n     * Return = _reserveBalance * (((_supply + _amount) / _supply) ^ (MAX_RATIO / _totalRatio) - 1)\\n     *\\n     * @param _supply              smart token supply\\n     * @param _reserveBalance      reserve token balance\\n     * @param _totalRatio          total ratio, represented in ppm, 2-2000000\\n     * @param _amount              requested amount of smart tokens\\n     *\\n     * @return amount of reserve tokens\\n     */\\n    function calculateFundCost(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _totalRatio,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        // validate input\\n        require(\\n            _supply > 0 && _reserveBalance > 0 && _totalRatio > 1 && _totalRatio <= MAX_RATIO * 2\\n        );\\n\\n        // special case for 0 amount\\n        if (_amount == 0) return 0;\\n\\n        // special case if the total ratio = 100%\\n        if (_totalRatio == MAX_RATIO) return (_amount.mul(_reserveBalance) - 1) / _supply + 1;\\n\\n        uint256 result;\\n        uint8 precision;\\n        uint256 baseN = _supply.add(_amount);\\n        (result, precision) = power(baseN, _supply, MAX_RATIO, _totalRatio);\\n        uint256 temp = ((_reserveBalance.mul(result) - 1) >> precision) + 1;\\n        return temp - _reserveBalance;\\n    }\\n\\n    /**\\n     * @dev given a smart token supply, reserve balance, total ratio and an amount of smart tokens to liquidate,\\n     * calculates the amount of reserve tokens received for selling the given amount of smart tokens\\n     *\\n     * Formula:\\n     * Return = _reserveBalance * (1 - ((_supply - _amount) / _supply) ^ (MAX_RATIO / _totalRatio))\\n     *\\n     * @param _supply              smart token supply\\n     * @param _reserveBalance      reserve token balance\\n     * @param _totalRatio          total ratio, represented in ppm, 2-2000000\\n     * @param _amount              amount of smart tokens to liquidate\\n     *\\n     * @return amount of reserve tokens\\n     */\\n    function calculateLiquidateReturn(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _totalRatio,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        // validate input\\n        require(\\n            _supply > 0 &&\\n                _reserveBalance > 0 &&\\n                _totalRatio > 1 &&\\n                _totalRatio <= MAX_RATIO * 2 &&\\n                _amount <= _supply\\n        );\\n\\n        // special case for 0 amount\\n        if (_amount == 0) return 0;\\n\\n        // special case for liquidating the entire supply\\n        if (_amount == _supply) return _reserveBalance;\\n\\n        // special case if the total ratio = 100%\\n        if (_totalRatio == MAX_RATIO) return _amount.mul(_reserveBalance) / _supply;\\n\\n        uint256 result;\\n        uint8 precision;\\n        uint256 baseD = _supply - _amount;\\n        (result, precision) = power(_supply, baseD, MAX_RATIO, _totalRatio);\\n        uint256 temp1 = _reserveBalance.mul(result);\\n        uint256 temp2 = _reserveBalance << precision;\\n        return (temp1 - temp2) / result;\\n    }\\n\\n    /**\\n     * @dev General Description:\\n     *     Determine a value of precision.\\n     *     Calculate an integer approximation of (_baseN / _baseD) ^ (_expN / _expD) * 2 ^ precision.\\n     *     Return the result along with the precision used.\\n     *\\n     * Detailed Description:\\n     *     Instead of calculating \\\"base ^ exp\\\", we calculate \\\"e ^ (log(base) * exp)\\\".\\n     *     The value of \\\"log(base)\\\" is represented with an integer slightly smaller than \\\"log(base) * 2 ^ precision\\\".\\n     *     The larger \\\"precision\\\" is, the more accurately this value represents the real value.\\n     *     However, the larger \\\"precision\\\" is, the more bits are required in order to store this value.\\n     *     And the exponentiation function, which takes \\\"x\\\" and calculates \\\"e ^ x\\\", is limited to a maximum exponent (maximum value of \\\"x\\\").\\n     *     This maximum exponent depends on the \\\"precision\\\" used, and it is given by \\\"maxExpArray[precision] >> (MAX_PRECISION - precision)\\\".\\n     *     Hence we need to determine the highest precision which can be used for the given input, before calling the exponentiation function.\\n     *     This allows us to compute \\\"base ^ exp\\\" with maximum accuracy and without exceeding 256 bits in any of the intermediate computations.\\n     *     This functions assumes that \\\"_expN < 2 ^ 256 / log(MAX_NUM - 1)\\\", otherwise the multiplication should be replaced with a \\\"safeMul\\\".\\n     *     Since we rely on unsigned-integer arithmetic and \\\"base < 1\\\" ==> \\\"log(base) < 0\\\", this function does not support \\\"_baseN < _baseD\\\".\\n     */\\n    function power(\\n        uint256 _baseN,\\n        uint256 _baseD,\\n        uint32 _expN,\\n        uint32 _expD\\n    ) internal view returns (uint256, uint8) {\\n        require(_baseN < MAX_NUM);\\n\\n        uint256 baseLog;\\n        uint256 base = (_baseN * FIXED_1) / _baseD;\\n        if (base < OPT_LOG_MAX_VAL) {\\n            baseLog = optimalLog(base);\\n        } else {\\n            baseLog = generalLog(base);\\n        }\\n\\n        uint256 baseLogTimesExp = (baseLog * _expN) / _expD;\\n        if (baseLogTimesExp < OPT_EXP_MAX_VAL) {\\n            return (optimalExp(baseLogTimesExp), MAX_PRECISION);\\n        } else {\\n            uint8 precision = findPositionInMaxExpArray(baseLogTimesExp);\\n            return (\\n                generalExp(baseLogTimesExp >> (MAX_PRECISION - precision), precision),\\n                precision\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev computes log(x / FIXED_1) * FIXED_1.\\n     * This functions assumes that \\\"x >= FIXED_1\\\", because the output would be negative otherwise.\\n     */\\n    function generalLog(uint256 x) internal pure returns (uint256) {\\n        uint256 res = 0;\\n\\n        // If x >= 2, then we compute the integer part of log2(x), which is larger than 0.\\n        if (x >= FIXED_2) {\\n            uint8 count = floorLog2(x / FIXED_1);\\n            x >>= count; // now x < 2\\n            res = count * FIXED_1;\\n        }\\n\\n        // If x > 1, then we compute the fraction part of log2(x), which is larger than 0.\\n        if (x > FIXED_1) {\\n            for (uint8 i = MAX_PRECISION; i > 0; --i) {\\n                x = (x * x) / FIXED_1; // now 1 < x < 4\\n                if (x >= FIXED_2) {\\n                    x >>= 1; // now 1 < x < 2\\n                    res += ONE << (i - 1);\\n                }\\n            }\\n        }\\n\\n        return (res * LN2_NUMERATOR) / LN2_DENOMINATOR;\\n    }\\n\\n    /**\\n     * @dev computes the largest integer smaller than or equal to the binary logarithm of the input.\\n     */\\n    function floorLog2(uint256 _n) internal pure returns (uint8) {\\n        uint8 res = 0;\\n\\n        if (_n < 256) {\\n            // At most 8 iterations\\n            while (_n > 1) {\\n                _n >>= 1;\\n                res += 1;\\n            }\\n        } else {\\n            // Exactly 8 iterations\\n            for (uint8 s = 128; s > 0; s >>= 1) {\\n                if (_n >= (ONE << s)) {\\n                    _n >>= s;\\n                    res |= s;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @dev the global \\\"maxExpArray\\\" is sorted in descending order, and therefore the following statements are equivalent:\\n     * - This function finds the position of [the smallest value in \\\"maxExpArray\\\" larger than or equal to \\\"x\\\"]\\n     * - This function finds the highest position of [a value in \\\"maxExpArray\\\" larger than or equal to \\\"x\\\"]\\n     */\\n    function findPositionInMaxExpArray(uint256 _x) internal view returns (uint8) {\\n        uint8 lo = MIN_PRECISION;\\n        uint8 hi = MAX_PRECISION;\\n\\n        while (lo + 1 < hi) {\\n            uint8 mid = (lo + hi) / 2;\\n            if (maxExpArray[mid] >= _x) lo = mid;\\n            else hi = mid;\\n        }\\n\\n        if (maxExpArray[hi] >= _x) return hi;\\n        if (maxExpArray[lo] >= _x) return lo;\\n\\n        require(false);\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev this function can be auto-generated by the script 'PrintFunctionGeneralExp.py'.\\n     * it approximates \\\"e ^ x\\\" via maclaurin summation: \\\"(x^0)/0! + (x^1)/1! + ... + (x^n)/n!\\\".\\n     * it returns \\\"e ^ (x / 2 ^ precision) * 2 ^ precision\\\", that is, the result is upshifted for accuracy.\\n     * the global \\\"maxExpArray\\\" maps each \\\"precision\\\" to \\\"((maximumExponent + 1) << (MAX_PRECISION - precision)) - 1\\\".\\n     * the maximum permitted value for \\\"x\\\" is therefore given by \\\"maxExpArray[precision] >> (MAX_PRECISION - precision)\\\".\\n     */\\n    function generalExp(uint256 _x, uint8 _precision) internal pure returns (uint256) {\\n        uint256 xi = _x;\\n        uint256 res = 0;\\n\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x3442c4e6074a82f1797f72ac0000000; // add x^02 * (33! / 02!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x116b96f757c380fb287fd0e40000000; // add x^03 * (33! / 03!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x045ae5bdd5f0e03eca1ff4390000000; // add x^04 * (33! / 04!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00defabf91302cd95b9ffda50000000; // add x^05 * (33! / 05!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x002529ca9832b22439efff9b8000000; // add x^06 * (33! / 06!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00054f1cf12bd04e516b6da88000000; // add x^07 * (33! / 07!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000a9e39e257a09ca2d6db51000000; // add x^08 * (33! / 08!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000012e066e7b839fa050c309000000; // add x^09 * (33! / 09!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000001e33d7d926c329a1ad1a800000; // add x^10 * (33! / 10!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000002bee513bdb4a6b19b5f800000; // add x^11 * (33! / 11!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000003a9316fa79b88eccf2a00000; // add x^12 * (33! / 12!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000048177ebe1fa812375200000; // add x^13 * (33! / 13!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000005263fe90242dcbacf00000; // add x^14 * (33! / 14!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000000000057e22099c030d94100000; // add x^15 * (33! / 15!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000057e22099c030d9410000; // add x^16 * (33! / 16!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000052b6b54569976310000; // add x^17 * (33! / 17!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000004985f67696bf748000; // add x^18 * (33! / 18!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000000000000003dea12ea99e498000; // add x^19 * (33! / 19!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000000031880f2214b6e000; // add x^20 * (33! / 20!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000000000000000025bcff56eb36000; // add x^21 * (33! / 21!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000000000000000001b722e10ab1000; // add x^22 * (33! / 22!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000001317c70077000; // add x^23 * (33! / 23!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000000000000cba84aafa00; // add x^24 * (33! / 24!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000000000000082573a0a00; // add x^25 * (33! / 25!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000000000000005035ad900; // add x^26 * (33! / 26!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x000000000000000000000002f881b00; // add x^27 * (33! / 27!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000000000001b29340; // add x^28 * (33! / 28!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x00000000000000000000000000efc40; // add x^29 * (33! / 29!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000000000000007fe0; // add x^30 * (33! / 30!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000000000000000420; // add x^31 * (33! / 31!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000000000000000021; // add x^32 * (33! / 32!)\\n        xi = (xi * _x) >> _precision;\\n        res += xi * 0x0000000000000000000000000000001; // add x^33 * (33! / 33!)\\n\\n        return res / 0x688589cc0e9505e2f2fee5580000000 + _x + (ONE << _precision); // divide by 33! and then add x^1 / 1! + x^0 / 0!\\n    }\\n\\n    /**\\n     * @dev computes log(x / FIXED_1) * FIXED_1\\n     * Input range: FIXED_1 <= x <= LOG_EXP_MAX_VAL - 1\\n     * Auto-generated via 'PrintFunctionOptimalLog.py'\\n     * Detailed description:\\n     * - Rewrite the input as a product of natural exponents and a single residual r, such that 1 < r < 2\\n     * - The natural logarithm of each (pre-calculated) exponent is the degree of the exponent\\n     * - The natural logarithm of r is calculated via Taylor series for log(1 + x), where x = r - 1\\n     * - The natural logarithm of the input is calculated by summing up the intermediate results above\\n     * - For example: log(250) = log(e^4 * e^1 * e^0.5 * 1.021692859) = 4 + 1 + 0.5 + log(1 + 0.021692859)\\n     */\\n    function optimalLog(uint256 x) internal pure returns (uint256) {\\n        uint256 res = 0;\\n\\n        uint256 y;\\n        uint256 z;\\n        uint256 w;\\n\\n        if (x >= 0xd3094c70f034de4b96ff7d5b6f99fcd8) {\\n            res += 0x40000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0xd3094c70f034de4b96ff7d5b6f99fcd8;\\n        } // add 1 / 2^1\\n        if (x >= 0xa45af1e1f40c333b3de1db4dd55f29a7) {\\n            res += 0x20000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0xa45af1e1f40c333b3de1db4dd55f29a7;\\n        } // add 1 / 2^2\\n        if (x >= 0x910b022db7ae67ce76b441c27035c6a1) {\\n            res += 0x10000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x910b022db7ae67ce76b441c27035c6a1;\\n        } // add 1 / 2^3\\n        if (x >= 0x88415abbe9a76bead8d00cf112e4d4a8) {\\n            res += 0x08000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x88415abbe9a76bead8d00cf112e4d4a8;\\n        } // add 1 / 2^4\\n        if (x >= 0x84102b00893f64c705e841d5d4064bd3) {\\n            res += 0x04000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x84102b00893f64c705e841d5d4064bd3;\\n        } // add 1 / 2^5\\n        if (x >= 0x8204055aaef1c8bd5c3259f4822735a2) {\\n            res += 0x02000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x8204055aaef1c8bd5c3259f4822735a2;\\n        } // add 1 / 2^6\\n        if (x >= 0x810100ab00222d861931c15e39b44e99) {\\n            res += 0x01000000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x810100ab00222d861931c15e39b44e99;\\n        } // add 1 / 2^7\\n        if (x >= 0x808040155aabbbe9451521693554f733) {\\n            res += 0x00800000000000000000000000000000;\\n            x = (x * FIXED_1) / 0x808040155aabbbe9451521693554f733;\\n        } // add 1 / 2^8\\n\\n        z = y = x - FIXED_1;\\n        w = (y * y) / FIXED_1;\\n        res +=\\n            (z * (0x100000000000000000000000000000000 - y)) /\\n            0x100000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^01 / 01 - y^02 / 02\\n        res +=\\n            (z * (0x0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa - y)) /\\n            0x200000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^03 / 03 - y^04 / 04\\n        res +=\\n            (z * (0x099999999999999999999999999999999 - y)) /\\n            0x300000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^05 / 05 - y^06 / 06\\n        res +=\\n            (z * (0x092492492492492492492492492492492 - y)) /\\n            0x400000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^07 / 07 - y^08 / 08\\n        res +=\\n            (z * (0x08e38e38e38e38e38e38e38e38e38e38e - y)) /\\n            0x500000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^09 / 09 - y^10 / 10\\n        res +=\\n            (z * (0x08ba2e8ba2e8ba2e8ba2e8ba2e8ba2e8b - y)) /\\n            0x600000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^11 / 11 - y^12 / 12\\n        res +=\\n            (z * (0x089d89d89d89d89d89d89d89d89d89d89 - y)) /\\n            0x700000000000000000000000000000000;\\n        z = (z * w) / FIXED_1; // add y^13 / 13 - y^14 / 14\\n        res +=\\n            (z * (0x088888888888888888888888888888888 - y)) /\\n            0x800000000000000000000000000000000; // add y^15 / 15 - y^16 / 16\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @dev computes e ^ (x / FIXED_1) * FIXED_1\\n     * input range: 0 <= x <= OPT_EXP_MAX_VAL - 1\\n     * auto-generated via 'PrintFunctionOptimalExp.py'\\n     * Detailed description:\\n     * - Rewrite the input as a sum of binary exponents and a single residual r, as small as possible\\n     * - The exponentiation of each binary exponent is given (pre-calculated)\\n     * - The exponentiation of r is calculated via Taylor series for e^x, where x = r\\n     * - The exponentiation of the input is calculated by multiplying the intermediate results above\\n     * - For example: e^5.521692859 = e^(4 + 1 + 0.5 + 0.021692859) = e^4 * e^1 * e^0.5 * e^0.021692859\\n     */\\n    function optimalExp(uint256 x) internal pure returns (uint256) {\\n        uint256 res = 0;\\n\\n        uint256 y;\\n        uint256 z;\\n\\n        z = y = x % 0x10000000000000000000000000000000; // get the input modulo 2^(-3)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x10e1b3be415a0000; // add y^02 * (20! / 02!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x05a0913f6b1e0000; // add y^03 * (20! / 03!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0168244fdac78000; // add y^04 * (20! / 04!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x004807432bc18000; // add y^05 * (20! / 05!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000c0135dca04000; // add y^06 * (20! / 06!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0001b707b1cdc000; // add y^07 * (20! / 07!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000036e0f639b800; // add y^08 * (20! / 08!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x00000618fee9f800; // add y^09 * (20! / 09!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000009c197dcc00; // add y^10 * (20! / 10!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000e30dce400; // add y^11 * (20! / 11!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000000012ebd1300; // add y^12 * (20! / 12!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000017499f00; // add y^13 * (20! / 13!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000001a9d480; // add y^14 * (20! / 14!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x00000000001c6380; // add y^15 * (20! / 15!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000000000001c638; // add y^16 * (20! / 16!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000000001ab8; // add y^17 * (20! / 17!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x000000000000017c; // add y^18 * (20! / 18!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000000000014; // add y^19 * (20! / 19!)\\n        z = (z * y) / FIXED_1;\\n        res += z * 0x0000000000000001; // add y^20 * (20! / 20!)\\n        res = res / 0x21c3677c82b40000 + y + FIXED_1; // divide by 20! and then add y^1 / 1! + y^0 / 0!\\n\\n        if ((x & 0x010000000000000000000000000000000) != 0)\\n            res = (res * 0x1c3d6a24ed82218787d624d3e5eba95f9) / 0x18ebef9eac820ae8682b9793ac6d1e776; // multiply by e^2^(-3)\\n        if ((x & 0x020000000000000000000000000000000) != 0)\\n            res = (res * 0x18ebef9eac820ae8682b9793ac6d1e778) / 0x1368b2fc6f9609fe7aceb46aa619baed4; // multiply by e^2^(-2)\\n        if ((x & 0x040000000000000000000000000000000) != 0)\\n            res = (res * 0x1368b2fc6f9609fe7aceb46aa619baed5) / 0x0bc5ab1b16779be3575bd8f0520a9f21f; // multiply by e^2^(-1)\\n        if ((x & 0x080000000000000000000000000000000) != 0)\\n            res = (res * 0x0bc5ab1b16779be3575bd8f0520a9f21e) / 0x0454aaa8efe072e7f6ddbab84b40a55c9; // multiply by e^2^(+0)\\n        if ((x & 0x100000000000000000000000000000000) != 0)\\n            res = (res * 0x0454aaa8efe072e7f6ddbab84b40a55c5) / 0x00960aadc109e7a3bf4578099615711ea; // multiply by e^2^(+1)\\n        if ((x & 0x200000000000000000000000000000000) != 0)\\n            res = (res * 0x00960aadc109e7a3bf4578099615711d7) / 0x0002bf84208204f5977f9a8cf01fdce3d; // multiply by e^2^(+2)\\n        if ((x & 0x400000000000000000000000000000000) != 0)\\n            res = (res * 0x0002bf84208204f5977f9a8cf01fdc307) / 0x0000003c6ab775dd0b95b4cbee7e65d11; // multiply by e^2^(+3)\\n\\n        return res;\\n    }\\n\\n    /**\\n     * @dev deprecated, backward compatibility\\n     */\\n    function calculateCrossConnectorReturn(\\n        uint256 _fromConnectorBalance,\\n        uint32 _fromConnectorWeight,\\n        uint256 _toConnectorBalance,\\n        uint32 _toConnectorWeight,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        return\\n            calculateCrossReserveReturn(\\n                _fromConnectorBalance,\\n                _fromConnectorWeight,\\n                _toConnectorBalance,\\n                _toConnectorWeight,\\n                _amount\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/upgrades/GraphUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"./IGraphProxy.sol\\\";\\n\\n/**\\n * @title Graph Upgradeable\\n * @dev This contract is intended to be inherited from upgradeable contracts.\\n */\\ncontract GraphUpgradeable {\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32\\n        internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Check if the caller is the proxy admin.\\n     */\\n    modifier onlyProxyAdmin(IGraphProxy _proxy) {\\n        require(msg.sender == _proxy.admin(), \\\"Caller must be the proxy admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check if the caller is the implementation.\\n     */\\n    modifier onlyImpl {\\n        require(msg.sender == _implementation(), \\\"Caller must be the implementation\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     * @return impl Address of the current implementation\\n     */\\n    function _implementation() internal view returns (address impl) {\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Accept to be an implementation of proxy.\\n     */\\n    function acceptProxy(IGraphProxy _proxy) external onlyProxyAdmin(_proxy) {\\n        _proxy.acceptUpgrade();\\n    }\\n\\n    /**\\n     * @dev Accept to be an implementation of proxy and then call a function from the new\\n     * implementation as specified by `_data`, which should be an encoded function call. This is\\n     * useful to initialize new storage variables in the proxied contract.\\n     */\\n    function acceptProxyAndCall(IGraphProxy _proxy, bytes calldata _data)\\n        external\\n        onlyProxyAdmin(_proxy)\\n    {\\n        _proxy.acceptUpgradeAndCall(_data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/TokenUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"../token/IGraphToken.sol\\\";\\n\\nlibrary TokenUtils {\\n    /**\\n     * @dev Pull tokens from an address to this contract.\\n     * @param _graphToken Token to transfer\\n     * @param _from Address sending the tokens\\n     * @param _amount Amount of tokens to transfer\\n     */\\n    function pullTokens(\\n        IGraphToken _graphToken,\\n        address _from,\\n        uint256 _amount\\n    ) internal {\\n        if (_amount > 0) {\\n            require(_graphToken.transferFrom(_from, address(this), _amount), \\\"!transfer\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Push tokens from this contract to a receiving address.\\n     * @param _graphToken Token to transfer\\n     * @param _to Address receiving the tokens\\n     * @param _amount Amount of tokens to transfer\\n     */\\n    function pushTokens(\\n        IGraphToken _graphToken,\\n        address _to,\\n        uint256 _amount\\n    ) internal {\\n        if (_amount > 0) {\\n            require(_graphToken.transfer(_to, _amount), \\\"!transfer\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Burn tokens held by this contract.\\n     * @param _graphToken Token to burn\\n     * @param _amount Amount of tokens to burn\\n     */\\n    function burnTokens(IGraphToken _graphToken, uint256 _amount) internal {\\n        if (_amount > 0) {\\n            _graphToken.burn(_amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/discovery/IGNS.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.3;\\n\\ninterface IGNS {\\n    // -- Pool --\\n\\n    struct NameCurationPool {\\n        uint256 vSignal; // The token of the subgraph deployment bonding curve\\n        uint256 nSignal; // The token of the name curation bonding curve\\n        mapping(address => uint256) curatorNSignal;\\n        bytes32 subgraphDeploymentID;\\n        uint32 reserveRatio;\\n        bool disabled;\\n        uint256 withdrawableGRT;\\n    }\\n\\n    // -- Configuration --\\n\\n    function approveAll() external;\\n\\n    function setOwnerTaxPercentage(uint32 _ownerTaxPercentage) external;\\n\\n    // -- Publishing --\\n\\n    function setDefaultName(\\n        address _graphAccount,\\n        uint8 _nameSystem,\\n        bytes32 _nameIdentifier,\\n        string calldata _name\\n    ) external;\\n\\n    function updateSubgraphMetadata(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        bytes32 _subgraphMetadata\\n    ) external;\\n\\n    function publishNewSubgraph(\\n        address _graphAccount,\\n        bytes32 _subgraphDeploymentID,\\n        bytes32 _versionMetadata,\\n        bytes32 _subgraphMetadata\\n    ) external;\\n\\n    function publishNewVersion(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        bytes32 _subgraphDeploymentID,\\n        bytes32 _versionMetadata\\n    ) external;\\n\\n    function deprecateSubgraph(address _graphAccount, uint256 _subgraphNumber) external;\\n\\n    // -- Curation --\\n\\n    function mintNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _tokensIn,\\n        uint256 _nSignalOutMin\\n    ) external;\\n\\n    function burnNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _nSignal,\\n        uint256 _tokensOutMin\\n    ) external;\\n\\n    function withdraw(address _graphAccount, uint256 _subgraphNumber) external;\\n\\n    // -- Getters --\\n\\n    function tokensToNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _tokensIn\\n    )\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function nSignalToTokens(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _nSignalIn\\n    ) external view returns (uint256, uint256);\\n\\n    function vSignalToNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _vSignalIn\\n    ) external view returns (uint256);\\n\\n    function nSignalToVSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        uint256 _nSignalIn\\n    ) external view returns (uint256);\\n\\n    function getCuratorNSignal(\\n        address _graphAccount,\\n        uint256 _subgraphNumber,\\n        address _curator\\n    ) external view returns (uint256);\\n\\n    function isPublished(address _graphAccount, uint256 _subgraphNumber)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/discovery/GNSStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../governance/Managed.sol\\\";\\n\\nimport \\\"./erc1056/IEthereumDIDRegistry.sol\\\";\\nimport \\\"./IGNS.sol\\\";\\n\\ncontract GNSV1Storage is Managed {\\n    // -- State --\\n\\n    // In parts per hundred\\n    uint32 public ownerTaxPercentage;\\n\\n    // Bonding curve formula\\n    address public bondingCurve;\\n\\n    // graphAccountID => subgraphNumber => subgraphDeploymentID\\n    // subgraphNumber = A number associated to a graph accounts deployed subgraph. This\\n    //                  is used to point to a subgraphID (graphAccountID + subgraphNumber)\\n    mapping(address => mapping(uint256 => bytes32)) public subgraphs;\\n\\n    // graphAccountID => subgraph deployment counter\\n    mapping(address => uint256) public graphAccountSubgraphNumbers;\\n\\n    // graphAccountID => subgraphNumber => NameCurationPool\\n    mapping(address => mapping(uint256 => IGNS.NameCurationPool)) public nameSignals;\\n\\n    // ERC-1056 contract reference\\n    IEthereumDIDRegistry public erc1056Registry;\\n}\\n\"\r\n    },\r\n    \"contracts/base/IMulticall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.3;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Multicall interface\\n * @notice Enables calling multiple methods in a single call to the contract\\n */\\ninterface IMulticall {\\n    /**\\n     * @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\\n     * @param data The encoded function data for each of the calls to make to this contract\\n     * @return results The results from each of the calls passed in via data\\n     */\\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results);\\n}\\n\"\r\n    },\r\n    \"contracts/upgrades/IGraphProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.3;\\n\\ninterface IGraphProxy {\\n    function admin() external returns (address);\\n\\n    function setAdmin(address _newAdmin) external;\\n\\n    function implementation() external returns (address);\\n\\n    function pendingImplementation() external returns (address);\\n\\n    function upgradeTo(address _newImplementation) external;\\n\\n    function acceptUpgrade() external;\\n\\n    function acceptUpgradeAndCall(bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/token/IGraphToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IGraphToken is IERC20 {\\n    // -- Mint and Burn --\\n\\n    function burn(uint256 amount) external;\\n\\n    function mint(address _to, uint256 _amount) external;\\n\\n    // -- Mint Admin --\\n\\n    function addMinter(address _account) external;\\n\\n    function removeMinter(address _account) external;\\n\\n    function renounceMinter() external;\\n\\n    function isMinter(address _account) external view returns (bool);\\n\\n    // -- Permit --\\n\\n    function permit(\\n        address _owner,\\n        address _spender,\\n        uint256 _value,\\n        uint256 _deadline,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/governance/Managed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"./IController.sol\\\";\\n\\nimport \\\"../curation/ICuration.sol\\\";\\nimport \\\"../epochs/IEpochManager.sol\\\";\\nimport \\\"../rewards/IRewardsManager.sol\\\";\\nimport \\\"../staking/IStaking.sol\\\";\\nimport \\\"../token/IGraphToken.sol\\\";\\n\\n/**\\n * @title Graph Managed contract\\n * @dev The Managed contract provides an interface to interact with the Controller.\\n * It also provides local caching for contract addresses. This mechanism relies on calling the\\n * public `syncAllContracts()` function whenever a contract changes in the controller.\\n *\\n * Inspired by Livepeer:\\n * https://github.com/livepeer/protocol/blob/streamflow/contracts/Controller.sol\\n */\\ncontract Managed {\\n    // -- State --\\n\\n    // Controller that contract is registered with\\n    IController public controller;\\n    mapping(bytes32 => address) private addressCache;\\n    uint256[10] private __gap;\\n\\n    // -- Events --\\n\\n    event ParameterUpdated(string param);\\n    event SetController(address controller);\\n\\n    /**\\n     * @dev Emitted when contract with `nameHash` is synced to `contractAddress`.\\n     */\\n    event ContractSynced(bytes32 indexed nameHash, address contractAddress);\\n\\n    // -- Modifiers --\\n\\n    function _notPartialPaused() internal view {\\n        require(!controller.paused(), \\\"Paused\\\");\\n        require(!controller.partialPaused(), \\\"Partial-paused\\\");\\n    }\\n\\n    function _notPaused() internal view {\\n        require(!controller.paused(), \\\"Paused\\\");\\n    }\\n\\n    function _onlyGovernor() internal view {\\n        require(msg.sender == controller.getGovernor(), \\\"Caller must be Controller governor\\\");\\n    }\\n\\n    function _onlyController() internal view {\\n        require(msg.sender == address(controller), \\\"Caller must be Controller\\\");\\n    }\\n\\n    modifier notPartialPaused {\\n        _notPartialPaused();\\n        _;\\n    }\\n\\n    modifier notPaused {\\n        _notPaused();\\n        _;\\n    }\\n\\n    // Check if sender is controller.\\n    modifier onlyController() {\\n        _onlyController();\\n        _;\\n    }\\n\\n    // Check if sender is the governor.\\n    modifier onlyGovernor() {\\n        _onlyGovernor();\\n        _;\\n    }\\n\\n    // -- Functions --\\n\\n    /**\\n     * @dev Initialize the controller.\\n     */\\n    function _initialize(address _controller) internal {\\n        _setController(_controller);\\n    }\\n\\n    /**\\n     * @notice Set Controller. Only callable by current controller.\\n     * @param _controller Controller contract address\\n     */\\n    function setController(address _controller) external onlyController {\\n        _setController(_controller);\\n    }\\n\\n    /**\\n     * @dev Set controller.\\n     * @param _controller Controller contract address\\n     */\\n    function _setController(address _controller) internal {\\n        require(_controller != address(0), \\\"Controller must be set\\\");\\n        controller = IController(_controller);\\n        emit SetController(_controller);\\n    }\\n\\n    /**\\n     * @dev Return Curation interface.\\n     * @return Curation contract registered with Controller\\n     */\\n    function curation() internal view returns (ICuration) {\\n        return ICuration(_resolveContract(keccak256(\\\"Curation\\\")));\\n    }\\n\\n    /**\\n     * @dev Return EpochManager interface.\\n     * @return Epoch manager contract registered with Controller\\n     */\\n    function epochManager() internal view returns (IEpochManager) {\\n        return IEpochManager(_resolveContract(keccak256(\\\"EpochManager\\\")));\\n    }\\n\\n    /**\\n     * @dev Return RewardsManager interface.\\n     * @return Rewards manager contract registered with Controller\\n     */\\n    function rewardsManager() internal view returns (IRewardsManager) {\\n        return IRewardsManager(_resolveContract(keccak256(\\\"RewardsManager\\\")));\\n    }\\n\\n    /**\\n     * @dev Return Staking interface.\\n     * @return Staking contract registered with Controller\\n     */\\n    function staking() internal view returns (IStaking) {\\n        return IStaking(_resolveContract(keccak256(\\\"Staking\\\")));\\n    }\\n\\n    /**\\n     * @dev Return GraphToken interface.\\n     * @return Graph token contract registered with Controller\\n     */\\n    function graphToken() internal view returns (IGraphToken) {\\n        return IGraphToken(_resolveContract(keccak256(\\\"GraphToken\\\")));\\n    }\\n\\n    /**\\n     * @dev Resolve a contract address from the cache or the Controller if not found.\\n     * @return Address of the contract\\n     */\\n    function _resolveContract(bytes32 _nameHash) internal view returns (address) {\\n        address contractAddress = addressCache[_nameHash];\\n        if (contractAddress == address(0)) {\\n            contractAddress = controller.getContractProxy(_nameHash);\\n        }\\n        return contractAddress;\\n    }\\n\\n    /**\\n     * @dev Cache a contract address from the Controller registry.\\n     * @param _name Name of the contract to sync into the cache\\n     */\\n    function _syncContract(string memory _name) internal {\\n        bytes32 nameHash = keccak256(abi.encodePacked(_name));\\n        address contractAddress = controller.getContractProxy(nameHash);\\n        if (addressCache[nameHash] != contractAddress) {\\n            addressCache[nameHash] = contractAddress;\\n            emit ContractSynced(nameHash, contractAddress);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sync protocol contract addresses from the Controller registry.\\n     * This function will cache all the contracts using the latest addresses\\n     * Anyone can call the function whenever a Proxy contract change in the\\n     * controller to ensure the protocol is using the latest version\\n     */\\n    function syncAllContracts() external {\\n        _syncContract(\\\"Curation\\\");\\n        _syncContract(\\\"EpochManager\\\");\\n        _syncContract(\\\"RewardsManager\\\");\\n        _syncContract(\\\"Staking\\\");\\n        _syncContract(\\\"GraphToken\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/discovery/erc1056/IEthereumDIDRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity ^0.7.3;\\n\\ninterface IEthereumDIDRegistry {\\n    function identityOwner(address identity) external view returns (address);\\n\\n    function setAttribute(\\n        address identity,\\n        bytes32 name,\\n        bytes calldata value,\\n        uint256 validity\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/governance/IController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.6.12 <0.8.0;\\n\\ninterface IController {\\n    function getGovernor() external view returns (address);\\n\\n    // -- Registry --\\n\\n    function setContractProxy(bytes32 _id, address _contractAddress) external;\\n\\n    function unsetContractProxy(bytes32 _id) external;\\n\\n    function updateController(bytes32 _id, address _controller) external;\\n\\n    function getContractProxy(bytes32 _id) external view returns (address);\\n\\n    // -- Pausing --\\n\\n    function setPartialPaused(bool _partialPaused) external;\\n\\n    function setPaused(bool _paused) external;\\n\\n    function setPauseGuardian(address _newPauseGuardian) external;\\n\\n    function paused() external view returns (bool);\\n\\n    function partialPaused() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/curation/ICuration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"./IGraphCurationToken.sol\\\";\\n\\ninterface ICuration {\\n    // -- Pool --\\n\\n    struct CurationPool {\\n        uint256 tokens; // GRT Tokens stored as reserves for the subgraph deployment\\n        uint32 reserveRatio; // Ratio for the bonding curve\\n        IGraphCurationToken gcs; // Curation token contract for this curation pool\\n    }\\n\\n    // -- Configuration --\\n\\n    function setDefaultReserveRatio(uint32 _defaultReserveRatio) external;\\n\\n    function setMinimumCurationDeposit(uint256 _minimumCurationDeposit) external;\\n\\n    function setCurationTaxPercentage(uint32 _percentage) external;\\n\\n    // -- Curation --\\n\\n    function mint(\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokensIn,\\n        uint256 _signalOutMin\\n    ) external returns (uint256, uint256);\\n\\n    function burn(\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _signalIn,\\n        uint256 _tokensOutMin\\n    ) external returns (uint256);\\n\\n    function collect(bytes32 _subgraphDeploymentID, uint256 _tokens) external;\\n\\n    // -- Getters --\\n\\n    function isCurated(bytes32 _subgraphDeploymentID) external view returns (bool);\\n\\n    function getCuratorSignal(address _curator, bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getCurationPoolSignal(bytes32 _subgraphDeploymentID) external view returns (uint256);\\n\\n    function getCurationPoolTokens(bytes32 _subgraphDeploymentID) external view returns (uint256);\\n\\n    function tokensToSignal(bytes32 _subgraphDeploymentID, uint256 _tokensIn)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function signalToTokens(bytes32 _subgraphDeploymentID, uint256 _signalIn)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function curationTaxPercentage() external view returns (uint32);\\n}\\n\"\r\n    },\r\n    \"contracts/epochs/IEpochManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.3;\\n\\ninterface IEpochManager {\\n    // -- Configuration --\\n\\n    function setEpochLength(uint256 _epochLength) external;\\n\\n    // -- Epochs\\n\\n    function runEpoch() external;\\n\\n    // -- Getters --\\n\\n    function isCurrentEpochRun() external view returns (bool);\\n\\n    function blockNum() external view returns (uint256);\\n\\n    function blockHash(uint256 _block) external view returns (bytes32);\\n\\n    function currentEpoch() external view returns (uint256);\\n\\n    function currentEpochBlock() external view returns (uint256);\\n\\n    function currentEpochBlockSinceStart() external view returns (uint256);\\n\\n    function epochsSince(uint256 _epoch) external view returns (uint256);\\n\\n    function epochsSinceUpdate() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/IRewardsManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.3;\\n\\ninterface IRewardsManager {\\n    /**\\n     * @dev Stores accumulated rewards and snapshots related to a particular SubgraphDeployment.\\n     */\\n    struct Subgraph {\\n        uint256 accRewardsForSubgraph;\\n        uint256 accRewardsForSubgraphSnapshot;\\n        uint256 accRewardsPerSignalSnapshot;\\n        uint256 accRewardsPerAllocatedToken;\\n    }\\n\\n    // -- Params --\\n\\n    function setIssuanceRate(uint256 _issuanceRate) external;\\n\\n    // -- Denylist --\\n\\n    function setSubgraphAvailabilityOracle(address _subgraphAvailabilityOracle) external;\\n\\n    function setDenied(bytes32 _subgraphDeploymentID, bool _deny) external;\\n\\n    function setDeniedMany(bytes32[] calldata _subgraphDeploymentID, bool[] calldata _deny)\\n        external;\\n\\n    function isDenied(bytes32 _subgraphDeploymentID) external view returns (bool);\\n\\n    // -- Getters --\\n\\n    function getNewRewardsPerSignal() external view returns (uint256);\\n\\n    function getAccRewardsPerSignal() external view returns (uint256);\\n\\n    function getAccRewardsForSubgraph(bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getAccRewardsPerAllocatedToken(bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function getRewards(address _allocationID) external view returns (uint256);\\n\\n    // -- Updates --\\n\\n    function updateAccRewardsPerSignal() external returns (uint256);\\n\\n    function takeRewards(address _allocationID) external returns (uint256);\\n\\n    // -- Hooks --\\n\\n    function onSubgraphSignalUpdate(bytes32 _subgraphDeploymentID) external returns (uint256);\\n\\n    function onSubgraphAllocationUpdate(bytes32 _subgraphDeploymentID) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.6.12 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IStakingData.sol\\\";\\n\\ninterface IStaking is IStakingData {\\n    // -- Allocation Data --\\n\\n    /**\\n     * @dev Possible states an allocation can be\\n     * States:\\n     * - Null = indexer == address(0)\\n     * - Active = not Null && tokens > 0\\n     * - Closed = Active && closedAtEpoch != 0\\n     * - Finalized = Closed && closedAtEpoch + channelDisputeEpochs > now()\\n     * - Claimed = not Null && tokens == 0\\n     */\\n    enum AllocationState { Null, Active, Closed, Finalized, Claimed }\\n\\n    // -- Configuration --\\n\\n    function setMinimumIndexerStake(uint256 _minimumIndexerStake) external;\\n\\n    function setThawingPeriod(uint32 _thawingPeriod) external;\\n\\n    function setCurationPercentage(uint32 _percentage) external;\\n\\n    function setProtocolPercentage(uint32 _percentage) external;\\n\\n    function setChannelDisputeEpochs(uint32 _channelDisputeEpochs) external;\\n\\n    function setMaxAllocationEpochs(uint32 _maxAllocationEpochs) external;\\n\\n    function setRebateRatio(uint32 _alphaNumerator, uint32 _alphaDenominator) external;\\n\\n    function setDelegationRatio(uint32 _delegationRatio) external;\\n\\n    function setDelegationParameters(\\n        uint32 _indexingRewardCut,\\n        uint32 _queryFeeCut,\\n        uint32 _cooldownBlocks\\n    ) external;\\n\\n    function setDelegationParametersCooldown(uint32 _blocks) external;\\n\\n    function setDelegationUnbondingPeriod(uint32 _delegationUnbondingPeriod) external;\\n\\n    function setDelegationTaxPercentage(uint32 _percentage) external;\\n\\n    function setSlasher(address _slasher, bool _allowed) external;\\n\\n    function setAssetHolder(address _assetHolder, bool _allowed) external;\\n\\n    // -- Operation --\\n\\n    function setOperator(address _operator, bool _allowed) external;\\n\\n    function isOperator(address _operator, address _indexer) external view returns (bool);\\n\\n    // -- Staking --\\n\\n    function stake(uint256 _tokens) external;\\n\\n    function stakeTo(address _indexer, uint256 _tokens) external;\\n\\n    function unstake(uint256 _tokens) external;\\n\\n    function slash(\\n        address _indexer,\\n        uint256 _tokens,\\n        uint256 _reward,\\n        address _beneficiary\\n    ) external;\\n\\n    function withdraw() external;\\n\\n    function setRewardsDestination(address _destination) external;\\n\\n    // -- Delegation --\\n\\n    function delegate(address _indexer, uint256 _tokens) external returns (uint256);\\n\\n    function undelegate(address _indexer, uint256 _shares) external returns (uint256);\\n\\n    function withdrawDelegated(address _indexer, address _newIndexer) external returns (uint256);\\n\\n    // -- Channel management and allocations --\\n\\n    function allocate(\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) external;\\n\\n    function allocateFrom(\\n        address _indexer,\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) external;\\n\\n    function closeAllocation(address _allocationID, bytes32 _poi) external;\\n\\n    function closeAllocationMany(CloseAllocationRequest[] calldata _requests) external;\\n\\n    function closeAndAllocate(\\n        address _oldAllocationID,\\n        bytes32 _poi,\\n        address _indexer,\\n        bytes32 _subgraphDeploymentID,\\n        uint256 _tokens,\\n        address _allocationID,\\n        bytes32 _metadata,\\n        bytes calldata _proof\\n    ) external;\\n\\n    function collect(uint256 _tokens, address _allocationID) external;\\n\\n    function claim(address _allocationID, bool _restake) external;\\n\\n    function claimMany(address[] calldata _allocationID, bool _restake) external;\\n\\n    // -- Getters and calculations --\\n\\n    function hasStake(address _indexer) external view returns (bool);\\n\\n    function getIndexerStakedTokens(address _indexer) external view returns (uint256);\\n\\n    function getIndexerCapacity(address _indexer) external view returns (uint256);\\n\\n    function getAllocation(address _allocationID) external view returns (Allocation memory);\\n\\n    function getAllocationState(address _allocationID) external view returns (AllocationState);\\n\\n    function isAllocation(address _allocationID) external view returns (bool);\\n\\n    function getSubgraphAllocatedTokens(bytes32 _subgraphDeploymentID)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getDelegation(address _indexer, address _delegator)\\n        external\\n        view\\n        returns (Delegation memory);\\n\\n    function isDelegator(address _indexer, address _delegator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/curation/IGraphCurationToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity ^0.7.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IGraphCurationToken is IERC20 {\\n    function burnFrom(address _account, uint256 _amount) external;\\n\\n    function mint(address _to, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/staking/IStakingData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n\\npragma solidity >=0.6.12 <0.8.0;\\n\\ninterface IStakingData {\\n    /**\\n     * @dev Allocate GRT tokens for the purpose of serving queries of a subgraph deployment\\n     * An allocation is created in the allocate() function and consumed in claim()\\n     */\\n    struct Allocation {\\n        address indexer;\\n        bytes32 subgraphDeploymentID;\\n        uint256 tokens; // Tokens allocated to a SubgraphDeployment\\n        uint256 createdAtEpoch; // Epoch when it was created\\n        uint256 closedAtEpoch; // Epoch when it was closed\\n        uint256 collectedFees; // Collected fees for the allocation\\n        uint256 effectiveAllocation; // Effective allocation when closed\\n        uint256 accRewardsPerAllocatedToken; // Snapshot used for reward calc\\n    }\\n\\n    /**\\n     * @dev Represents a request to close an allocation with a specific proof of indexing.\\n     * This is passed when calling closeAllocationMany to define the closing parameters for\\n     * each allocation.\\n     */\\n    struct CloseAllocationRequest {\\n        address allocationID;\\n        bytes32 poi;\\n    }\\n\\n    // -- Delegation Data --\\n\\n    /**\\n     * @dev Delegation pool information. One per indexer.\\n     */\\n    struct DelegationPool {\\n        uint32 cooldownBlocks; // Blocks to wait before updating parameters\\n        uint32 indexingRewardCut; // in PPM\\n        uint32 queryFeeCut; // in PPM\\n        uint256 updatedAtBlock; // Block when the pool was last updated\\n        uint256 tokens; // Total tokens as pool reserves\\n        uint256 shares; // Total shares minted in the pool\\n        mapping(address => Delegation) delegators; // Mapping of delegator => Delegation\\n    }\\n\\n    /**\\n     * @dev Individual delegation data of a delegator in a pool.\\n     */\\n    struct Delegation {\\n        uint256 shares; // Shares owned by a delegator in the pool\\n        uint256 tokensLocked; // Tokens locked for undelegation\\n        uint256 tokensLockedUntil; // Block when locked tokens can be withdrawn\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nameHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"ContractSynced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"graphAccount\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nameCurator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nSignalBurnt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnGRT\",\"type\":\"uint256\"}],\"name\":\"GRTWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"graphAccount\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nameCurator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nSignalBurnt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vSignalBurnt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensReceived\",\"type\":\"uint256\"}],\"name\":\"NSignalBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"graphAccount\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nameCurator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nSignalCreated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vSignalCreated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensDeposited\",\"type\":\"uint256\"}],\"name\":\"NSignalMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"graphAccount\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawableGRT\",\"type\":\"uint256\"}],\"name\":\"NameSignalDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"graphAccount\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"subgraphDeploymentID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"reserveRatio\",\"type\":\"uint32\"}],\"name\":\"NameSignalEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"graphAccount\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVSignalCreated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSignalled\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"subgraphDeploymentID\",\"type\":\"bytes32\"}],\"name\":\"NameSignalUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"param\",\"type\":\"string\"}],\"name\":\"ParameterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"SetController\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"graphAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nameSystem\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nameIdentifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"SetDefaultName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"graphAccount\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphNumber\",\"type\":\"uint256\"}],\"name\":\"SubgraphDeprecated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"graphAccount\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"subgraphMetadata\",\"type\":\"bytes32\"}],\"name\":\"SubgraphMetadataUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"graphAccount\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"subgraphNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"subgraphDeploymentID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"versionMetadata\",\"type\":\"bytes32\"}],\"name\":\"SubgraphPublished\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IGraphProxy\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"acceptProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IGraphProxy\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"acceptProxyAndCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approveAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondingCurve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subgraphNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nSignal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokensOutMin\",\"type\":\"uint256\"}],\"name\":\"burnNSignal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subgraphNumber\",\"type\":\"uint256\"}],\"name\":\"deprecateSubgraph\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc1056Registry\",\"outputs\":[{\"internalType\":\"contract IEthereumDIDRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subgraphNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_curator\",\"type\":\"address\"}],\"name\":\"getCuratorNSignal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"graphAccountSubgraphNumbers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bondingCurve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_didRegistry\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subgraphNumber\",\"type\":\"uint256\"}],\"name\":\"isPublished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subgraphNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokensIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nSignalOutMin\",\"type\":\"uint256\"}],\"name\":\"mintNSignal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subgraphNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nSignalIn\",\"type\":\"uint256\"}],\"name\":\"nSignalToTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subgraphNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nSignalIn\",\"type\":\"uint256\"}],\"name\":\"nSignalToVSignal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nameSignals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"vSignal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nSignal\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"subgraphDeploymentID\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"reserveRatio\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableGRT\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerTaxPercentage\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_subgraphDeploymentID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_versionMetadata\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_subgraphMetadata\",\"type\":\"bytes32\"}],\"name\":\"publishNewSubgraph\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subgraphNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_subgraphDeploymentID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_versionMetadata\",\"type\":\"bytes32\"}],\"name\":\"publishNewVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_nameSystem\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_nameIdentifier\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setDefaultName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_ownerTaxPercentage\",\"type\":\"uint32\"}],\"name\":\"setOwnerTaxPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"subgraphs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"syncAllContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subgraphNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokensIn\",\"type\":\"uint256\"}],\"name\":\"tokensToNSignal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subgraphNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_subgraphMetadata\",\"type\":\"bytes32\"}],\"name\":\"updateSubgraphMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subgraphNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vSignalIn\",\"type\":\"uint256\"}],\"name\":\"vSignalToNSignal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_graphAccount\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subgraphNumber\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GNS","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}