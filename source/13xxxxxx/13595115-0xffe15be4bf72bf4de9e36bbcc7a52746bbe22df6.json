{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/ricardomarques/dev/workspace/thugpugs/subdomain-registrar/contracts/EthRegistrarERC721SubdomainRegistrar.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n\\ninterface ENS {\\n\\n    // Logged when the owner of a node assigns a new owner to a subnode.\\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\\n\\n    // Logged when the owner of a node transfers ownership to a new account.\\n    event Transfer(bytes32 indexed node, address owner);\\n\\n    // Logged when the resolver for a node changes.\\n    event NewResolver(bytes32 indexed node, address resolver);\\n\\n    // Logged when the TTL of a node changes\\n    event NewTTL(bytes32 indexed node, uint64 ttl);\\n\\n    // Logged when an operator is added or removed.\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function setRecord(bytes32 node, address owner, address resolver, uint64 ttl) external;\\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns(bytes32);\\n    function setResolver(bytes32 node, address resolver) external;\\n    function setOwner(bytes32 node, address owner) external;\\n    function setTTL(bytes32 node, uint64 ttl) external;\\n    function setApprovalForAll(address operator, bool approved) external;\\n    function owner(bytes32 node) external view returns (address);\\n    function resolver(bytes32 node) external view returns (address);\\n    function ttl(bytes32 node) external view returns (uint64);\\n    function recordExists(bytes32 node) external view returns (bool);\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\\ninterface IERC165 {\\n    /**\\n     * @notice Query if a contract implements an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @dev Interface identification is specified in ERC-165. This function\\n     * uses less than 30,000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ncontract IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function balanceOf(address owner) public view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) public view returns (address owner);\\n\\n    function approve(address to, uint256 tokenId) public;\\n    function getApproved(uint256 tokenId) public view returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) public;\\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public;\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\\n}\\n\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\ncontract BaseRegistrar is IERC721, Ownable {\\n    uint constant public GRACE_PERIOD = 90 days;\\n\\n    event ControllerAdded(address indexed controller);\\n    event ControllerRemoved(address indexed controller);\\n    event NameMigrated(uint256 indexed id, address indexed owner, uint expires);\\n    event NameRegistered(uint256 indexed id, address indexed owner, uint expires);\\n    event NameRenewed(uint256 indexed id, uint expires);\\n\\n    // The ENS registry\\n    ENS public ens;\\n\\n    // The namehash of the TLD this registrar owns (eg, .eth)\\n    bytes32 public baseNode;\\n\\n    // A map of addresses that are authorised to register and renew names.\\n    mapping(address=>bool) public controllers;\\n\\n    // Authorises a controller, who can register and renew domains.\\n    function addController(address controller) external;\\n\\n    // Revoke controller permission for an address.\\n    function removeController(address controller) external;\\n\\n    // Set the resolver for the TLD this registrar manages.\\n    function setResolver(address resolver) external;\\n\\n    // Returns the expiration timestamp of the specified label hash.\\n    function nameExpires(uint256 id) external view returns(uint);\\n\\n    // Returns true iff the specified name is available for registration.\\n    function available(uint256 id) public view returns(bool);\\n\\n    /**\\n     * @dev Register a name.\\n     */\\n    function register(uint256 id, address owner, uint duration) external returns(uint);\\n\\n    function renew(uint256 id, uint duration) external returns(uint);\\n\\n    /**\\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\\n     */\\n    function reclaim(uint256 id, address owner) external;\\n}\\n\\ncontract Resolver {\\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool);\\n    function addr(bytes32 node) public view returns (address);\\n    function setAddr(bytes32 node, address addr) public;\\n}\\n\\ncontract RegistrarInterface {\\n    event OwnerChanged(bytes32 indexed label, address indexed oldOwner, address indexed newOwner);\\n    event DomainConfigured(bytes32 indexed label);\\n    event DomainUnlisted(bytes32 indexed label);\\n    event NewRegistration(bytes32 indexed label, string subdomain, address indexed owner, address erc721);\\n    event RentPaid(bytes32 indexed label, string subdomain, uint amount, uint expirationDate);\\n\\n    // InterfaceID of these four methods is 0xc1b15f5a\\n    function query(bytes32 label, string calldata subdomain) external view returns (string memory domain, IERC721 erc721, uint rent);\\n    function isTokenClaimed(bytes32 label, uint256 tokenId) external view returns (bool claimed);\\n    function register(bytes32 label, string calldata subdomain, uint256 tokenId, address resolver) external;\\n\\n    function rentDue(bytes32 label, string calldata subdomain) external view returns (uint timestamp);\\n    function payRent(bytes32 label, string calldata subdomain) external payable;\\n}\\n\\ncontract AbstractERC721SubdomainRegistrar is RegistrarInterface {\\n\\n    // namehash('eth')\\n    bytes32 constant public TLD_NODE = 0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\\n\\n    bool public stopped = false;\\n    address public registrarOwner;\\n    address public migration;\\n\\n    address public registrar;\\n\\n    ENS public ens;\\n\\n    modifier owner_only(bytes32 label) {\\n        require(owner(label) == msg.sender);\\n        _;\\n    }\\n\\n    modifier not_stopped() {\\n        require(!stopped);\\n        _;\\n    }\\n\\n    modifier registrar_owner_only() {\\n        require(msg.sender == registrarOwner);\\n        _;\\n    }\\n\\n    event DomainTransferred(bytes32 indexed label, string name);\\n\\n    constructor(ENS _ens) public {\\n        ens = _ens;\\n        registrar = ens.owner(TLD_NODE);\\n        registrarOwner = msg.sender;\\n    }\\n\\n    function doRegistration(bytes32 node, bytes32 label, address subdomainOwner, Resolver resolver) internal {\\n        // Get the subdomain so we can configure it\\n        ens.setSubnodeOwner(node, label, address(this));\\n\\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\\n        // Set the subdomain's resolver\\n        ens.setResolver(subnode, address(resolver));\\n\\n        // Set the address record on the resolver\\n        resolver.setAddr(subnode, subdomainOwner);\\n\\n        // Pass ownership of the new subdomain to the registrant\\n        ens.setOwner(subnode, subdomainOwner);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\\n        return (\\n            (interfaceID == 0x01ffc9a7) // supportsInterface(bytes4)\\n            || (interfaceID == 0xc1b15f5a) // RegistrarInterface\\n        );\\n    }\\n\\n    function rentDue(bytes32 label, string calldata subdomain) external view returns (uint timestamp) {\\n        return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n\\n    /**\\n     * @dev Sets the resolver record for a name in ENS.\\n     * @param name The name to set the resolver for.\\n     * @param resolver The address of the resolver\\n     */\\n    function setResolver(string memory name, address resolver) public owner_only(keccak256(bytes(name))) {\\n        bytes32 label = keccak256(bytes(name));\\n        bytes32 node = keccak256(abi.encodePacked(TLD_NODE, label));\\n        ens.setResolver(node, resolver);\\n    }\\n\\n    /**\\n     * @dev Configures a domain for sale.\\n     * @param name The name to configure.\\n     * @param erc721 The address of the erc721 for domain configuration\\n     */\\n    function configureDomain(string memory name, IERC721 erc721) public {\\n        configureDomainFor(name, erc721, msg.sender, address(0x0));\\n    }\\n\\n    /**\\n     * @dev Stops the registrar, disabling configuring of new domains.\\n     */\\n    function stop() public not_stopped registrar_owner_only {\\n        stopped = true;\\n    }\\n\\n    /**\\n     * @dev Sets the address where domains are migrated to.\\n     * @param _migration Address of the new registrar.\\n     */\\n    function setMigrationAddress(address _migration) public registrar_owner_only {\\n        require(stopped);\\n        migration = _migration;\\n    }\\n\\n    function transferOwnership(address newOwner) public registrar_owner_only {\\n        registrarOwner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Returns information about a subdomain.\\n     * @param label The label hash for the domain.\\n     * @param subdomain The label for the subdomain.\\n     * @return domain The name of the domain, or an empty string if the subdomain\\n     *                is unavailable.\\n     * @return erc721 The address of the erc721 for domain configuration\\n     * @return rent The rent to retain a subdomain, in wei per second.\\n     */\\n    function query(bytes32 label, string calldata subdomain) external view returns (string memory domain, IERC721 erc721, uint rent);\\n    function isTokenClaimed(bytes32 label, uint256 tokenId) external view returns (bool claimed);\\n\\n    function owner(bytes32 label) public view returns (address);\\n    function configureDomainFor(string memory name, IERC721 erc721, address payable _owner, address _transfer) public;\\n}\\n\\ncontract EthRegistrarERC721SubdomainRegistrar is AbstractERC721SubdomainRegistrar {\\n\\n    struct Domain {\\n        string name;\\n        address payable owner;\\n        IERC721 erc721;\\n        mapping (uint256 => bool) claims;\\n    }\\n\\n    mapping (bytes32 => Domain) domains;\\n\\n    constructor(ENS ens) AbstractERC721SubdomainRegistrar(ens) public { }\\n\\n    /**\\n     * @dev owner returns the address of the account that controls a domain.\\n     *      Initially this is a null address. If the name has been\\n     *      transferred to this contract, then the internal mapping is consulted\\n     *      to determine who controls it. If the owner is not set,\\n     *      the owner of the domain in the Registrar is returned.\\n     * @param label The label hash of the deed to check.\\n     * @return The address owning the deed.\\n     */\\n    function owner(bytes32 label) public view returns (address) {\\n        if (domains[label].owner != address(0x0)) {\\n            return domains[label].owner;\\n        }\\n\\n        return BaseRegistrar(registrar).ownerOf(uint256(label));\\n    }\\n\\n    /**\\n     * @dev Transfers internal control of a name to a new account. Does not update\\n     *      ENS.\\n     * @param name The name to transfer.\\n     * @param newOwner The address of the new owner.\\n     */\\n    function transfer(string memory name, address payable newOwner) public owner_only(keccak256(bytes(name))) {\\n        bytes32 label = keccak256(bytes(name));\\n        emit OwnerChanged(label, domains[label].owner, newOwner);\\n        domains[label].owner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Configures a domain, optionally transferring it to a new owner.\\n     * @param name The name to configure.\\n     * @param erc721 The address of the erc721 for domain configuration\\n     * @param _owner The address to assign ownership of this domain to.\\n     * @param _transfer The address to set as the transfer address for the name\\n     *        when the permanent registrar is replaced. Can only be set to a non-zero\\n     *        value once.\\n     */\\n    function configureDomainFor(string memory name, IERC721 erc721, address payable _owner, address _transfer) public owner_only(keccak256(bytes(name))) {\\n        bytes32 label = keccak256(bytes(name));\\n        Domain storage domain = domains[label];\\n\\n        if (BaseRegistrar(registrar).ownerOf(uint256(label)) != address(this)) {\\n            BaseRegistrar(registrar).transferFrom(msg.sender, address(this), uint256(label));\\n            BaseRegistrar(registrar).reclaim(uint256(label), address(this));\\n        }\\n\\n        if (domain.owner != _owner) {\\n            domain.owner = _owner;\\n        }\\n\\n        if (keccak256(bytes(domain.name)) != label) {\\n            // New listing\\n            domain.name = name;\\n        }\\n\\n        domain.erc721 = erc721;\\n\\n        emit DomainConfigured(label);\\n    }\\n\\n    /**\\n     * @dev Unlists a domain\\n     * May only be called by the owner.\\n     * @param name The name of the domain to unlist.\\n     */\\n    function unlistDomain(string memory name) public owner_only(keccak256(bytes(name))) {\\n        bytes32 label = keccak256(bytes(name));\\n        Domain storage domain = domains[label];\\n        emit DomainUnlisted(label);\\n\\n        domain.name = '';\\n        domain.erc721 = IERC721(0x0);\\n    }\\n\\n    /**\\n     * @dev Returns information about a subdomain.\\n     * @param label The label hash for the domain.\\n     * @param subdomain The label for the subdomain.\\n     * @return domain The name of the domain, or an empty string if the subdomain\\n     *                is unavailable.\\n     * @return erc721 The address of the erc721 for domain configuration\\n     * @return rent The rent to retain a subdomain, in wei per second.\\n     */\\n    function query(bytes32 label, string calldata subdomain) external view returns (string memory domain, IERC721 erc721, uint rent) {\\n        bytes32 node = keccak256(abi.encodePacked(TLD_NODE, label));\\n        bytes32 subnode = keccak256(abi.encodePacked(node, keccak256(bytes(subdomain))));\\n\\n        if (ens.owner(subnode) != address(0x0)) {\\n            return ('', IERC721(0x0), 0);\\n        }\\n\\n        Domain storage data = domains[label];\\n        return (data.name, data.erc721, 0);\\n    }\\n\\n    /**\\n     * @dev Returns wether a erc721 token has been claimed.\\n     * @param label The label hash for the domain.\\n     * @param tokenId The erc721 tokenId\\n     * @return claimed The token has been claimed or not\\n     */\\n    function isTokenClaimed(bytes32 label, uint256 tokenId) external view returns (bool claimed) {\\n        bytes32 domainNode = keccak256(abi.encodePacked(TLD_NODE, label));\\n\\n        Domain storage domain = domains[label];\\n\\n        return domain.claims[tokenId];\\n    }\\n\\n    /**\\n     * @dev Registers a subdomain.\\n     * @param label The label hash of the domain to register a subdomain of.\\n     * @param subdomain The desired subdomain label.\\n     */\\n    function register(bytes32 label, string calldata subdomain, uint256 tokenId, address resolver) external not_stopped {\\n        address subdomainOwner = msg.sender;\\n        bytes32 domainNode = keccak256(abi.encodePacked(TLD_NODE, label));\\n        bytes32 subdomainLabel = keccak256(bytes(subdomain));\\n\\n        // Subdomain must not be registered already.\\n        require(ens.owner(keccak256(abi.encodePacked(domainNode, subdomainLabel))) == address(0));\\n\\n        Domain storage domain = domains[label];\\n\\n        // Domain must be available for registration\\n        require(keccak256(bytes(domain.name)) == label);\\n\\n        // Token must not be claimed\\n        require(domain.claims[tokenId] == false, \\\"Token already claimed\\\");\\n\\n        // User must hold erc721 tokenId\\n        require(domain.erc721.ownerOf(tokenId) == msg.sender, \\\"User must hold token\\\");\\n\\n        domain.claims[tokenId] = true;\\n\\n        doRegistration(domainNode, subdomainLabel, subdomainOwner, Resolver(resolver));\\n\\n        emit NewRegistration(label, subdomain, subdomainOwner, address(domain.erc721));\\n    }\\n\\n    function rentDue(bytes32 label, string calldata subdomain) external view returns (uint timestamp) {\\n        return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n\\n    /**\\n     * @dev Migrates the domain to a new registrar.\\n     * @param name The name of the domain to migrate.\\n     */\\n    function migrate(string memory name) public owner_only(keccak256(bytes(name))) {\\n        require(stopped);\\n        require(migration != address(0x0));\\n\\n        bytes32 label = keccak256(bytes(name));\\n        Domain storage domain = domains[label];\\n\\n        BaseRegistrar(registrar).approve(migration, uint256(label));\\n\\n        EthRegistrarERC721SubdomainRegistrar(migration).configureDomainFor(\\n            domain.name,\\n            domain.erc721,\\n            domain.owner,\\n            address(0x0)\\n        );\\n\\n        // Due to gas efficiency reasons, claims can't be migrated to the new registrar\\n\\n        delete domains[label];\\n\\n        emit DomainTransferred(label, name);\\n    }\\n\\n    function payRent(bytes32 label, string calldata subdomain) external payable {\\n        revert();\\n    }\\n}\\n\\ncontract ENSMigrationERC721SubdomainRegistrar is EthRegistrarERC721SubdomainRegistrar {\\n\\n    constructor(ENS ens) EthRegistrarERC721SubdomainRegistrar(ens) public { }\\n\\n    function migrateSubdomain(bytes32 node, bytes32 label) external {\\n        bytes32 subnode = keccak256(abi.encodePacked(node, label));\\n        address previous = ens.owner(subnode);\\n\\n        // only allow a contract to run their own migration\\n        require(!isContract(previous) || msg.sender == previous);\\n\\n        ens.setSubnodeRecord(node, label, previous, ens.resolver(subnode), ens.ttl(subnode));\\n    }\\n\\n    function isContract(address addr) private returns (bool) {\\n        uint size;\\n        assembly { size := extcodesize(addr) }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ENS\",\"name\":\"ens\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"DomainConfigured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"DomainTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"DomainUnlisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc721\",\"type\":\"address\"}],\"name\":\"NewRegistration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationDate\",\"type\":\"uint256\"}],\"name\":\"RentPaid\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"TLD_NODE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"contract IERC721\",\"name\":\"erc721\",\"type\":\"address\"}],\"name\":\"configureDomain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"contract IERC721\",\"name\":\"erc721\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_transfer\",\"type\":\"address\"}],\"name\":\"configureDomainFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ens\",\"outputs\":[{\"internalType\":\"contract ENS\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isTokenClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"migrateSubdomain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migration\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"}],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"}],\"name\":\"payRent\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"}],\"name\":\"query\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"domain\",\"type\":\"string\"},{\"internalType\":\"contract IERC721\",\"name\":\"erc721\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrar\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrarOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"label\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"}],\"name\":\"rentDue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_migration\",\"type\":\"address\"}],\"name\":\"setMigrationAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"setResolver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"unlistDomain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ENSMigrationERC721SubdomainRegistrar","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000c2e074ec69a0dfb2997ba6c7d2e1e","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}