{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Pausable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\ncontract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state. Assigns the Pauser role\r\n     * to the deployer.\r\n     */\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to pause, triggers stopped state.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Called by a pauser to unpause, returns to normal state.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/cryptography/ECDSA.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        if (signature.length != 65) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // ecrecover takes the signature parameters, and the only way to get them\r\n        // currently is to use assembly.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            r := mload(add(signature, 0x20))\r\n            s := mload(add(signature, 0x40))\r\n            v := byte(0, mload(add(signature, 0x60)))\r\n        }\r\n\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        }\r\n\r\n        if (v != 27 && v != 28) {\r\n            revert(\"ECDSA: invalid signature 'v' value\");\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * replicates the behavior of the\r\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\r\n     * JSON-RPC method.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IERC721.sol\r\n\r\npragma solidity ^0.6.1;\r\n\r\n\r\ninterface IERC721 {\r\n  function transferFrom(address from, address to, uint256 tokenId) external;\r\n}\r\n\r\n// File: contracts/interfaces/IERC721PreMinteable.sol\r\n\r\npragma solidity ^0.6.1;\r\n\r\ninterface IERC721PreMinteable {\r\n    function issueToken(address beneficiary, uint256 optionId, uint256 issuedId) external;\r\n}\r\n\r\n// File: contracts/Vault.sol\r\n\r\npragma solidity ^0.6.1;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Vault is Ownable, Pausable {\r\n    using Address for address;\r\n    using ECDSA for bytes32;\r\n\r\n    bytes4 public constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    mapping(address => bool) public contractWhitelist;\r\n    mapping(address => bool) public adminWhitelist;\r\n    mapping(address => bool) public supervisorWhitelist;\r\n    mapping(bytes32 => bool) public messageProcessed;\r\n\r\n    event Deposited(address indexed _owner, address indexed _contract, uint256 indexed _tokenId, bytes _userId);\r\n    event Withdrawn(address _beneficiary, address indexed _contract, uint256 indexed _tokenId, bytes _userId);\r\n    event Issued(\r\n        address _beneficiary,\r\n        address indexed _contract,\r\n        uint256 indexed _optionId,\r\n        uint256 indexed _issuedId,\r\n        bytes _userId\r\n    );\r\n\r\n    event ContractSet(address indexed _contract, bool _allowed, address indexed _caller);\r\n    event AdminSet(address indexed _admin, bool _allowed, address indexed _caller);\r\n    event SupervisorSet(address indexed _supervisor, bool _allowed, address indexed _caller);\r\n\r\n\r\n    /**\r\n    * @dev Modifier to check whether a caller is an admin\r\n    */\r\n    modifier onlyAdmin() {\r\n        require(adminWhitelist[msg.sender], \"Caller is not an admin\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to check whether a caller is a supervisor\r\n    */\r\n    modifier onlySupervisor() {\r\n        require(supervisorWhitelist[msg.sender], \"Caller is not a supervisor\");\r\n        _;\r\n    }\r\n\r\n     /**\r\n     * @dev Called by the owner to pause, triggers stopped state.\r\n     */\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the owner to unpause, returns to normal state.\r\n     */\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    /**\r\n    * @dev Add or remove an address to the supervisor whitelist\r\n    * @param _supervisor - Address to be allowed or not\r\n    * @param _allowed - Whether the contract will be allowed or not\r\n    */\r\n    function setSupervisor(address _supervisor, bool _allowed) external onlyOwner {\r\n        if (_allowed) {\r\n            require(!supervisorWhitelist[_supervisor], \"The supervisor is already whitelisted\");\r\n        } else {\r\n            require(supervisorWhitelist[_supervisor], \"The supervisor is not whitelisted\");\r\n        }\r\n\r\n        supervisorWhitelist[_supervisor] = _allowed;\r\n        emit SupervisorSet(_supervisor, _allowed, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Add or remove a contract to the contract whitelist\r\n    * @param _contract - Contract to be allowed or not\r\n    * @param _allowed - Whether the contract will be allowed or not\r\n    */\r\n    function setContract(address _contract, bool _allowed) external onlyOwner {\r\n        if (_allowed) {\r\n            require(!contractWhitelist[_contract], \"The contract is already whitelisted\");\r\n            require(_contract.isContract(), \"The address provided is not a contract\");\r\n        } else {\r\n            require(contractWhitelist[_contract], \"The contract is not whitelisted\");\r\n            // require(_contract.balanceOf(address(this)) == 0, \"The vault has tokens of this contract\");\r\n        }\r\n\r\n        contractWhitelist[_contract] = _allowed;\r\n        emit ContractSet(_contract, _allowed, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Add or remove an address to the admin whitelist\r\n    * @param _admin - Address to be allowed or not\r\n    * @param _allowed - Whether the contract will be allowed or not\r\n    */\r\n    function setAdmin(address _admin, bool _allowed) external onlyOwner {\r\n        _setAdmin(_admin, _allowed);\r\n    }\r\n\r\n    /**\r\n    * @dev Remove an address to the admin whitelist\r\n    * @param _admin - Address to be removed\r\n    */\r\n    function removeAdmin(address _admin) external onlySupervisor {\r\n        _setAdmin(_admin, false);\r\n    }\r\n\r\n     /**\r\n    * @dev Add or remove an address to the admin whitelist\r\n    * @param _admin - Address to be allowed or not\r\n    * @param _allowed - Whether the contract will be allowed or not\r\n    */\r\n    function _setAdmin(address _admin, bool _allowed) internal {\r\n        if (_allowed) {\r\n            require(!adminWhitelist[_admin], \"The admin is already whitelisted\");\r\n        } else {\r\n            require(adminWhitelist[_admin], \"The admin is not whitelisted\");\r\n        }\r\n\r\n        adminWhitelist[_admin] = _allowed;\r\n\r\n        emit AdminSet(_admin, _allowed, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice Handle the receipt of an NFT\r\n    * @dev The ERC721 smart contract calls this function on the recipient\r\n    * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\r\n    * otherwise the caller will revert the transaction. The selector to be\r\n    * returned can be obtained as `this.onERC721Received.selector`. This\r\n    * function MAY throw to revert and reject the transfer.\r\n    * Note: the ERC721 contract address is always the message sender.\r\n    * @param _from - The address which previously owned the token\r\n    * @param _tokenId - The NFT identifier which is being transferred\r\n    * @param _data - Additional data with no specified format\r\n    * @return bytes4 - `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    */\r\n    function onERC721Received(\r\n        address /*_operator*/,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external whenNotPaused returns(bytes4) {\r\n        require(contractWhitelist[msg.sender], \"The contract is not whitelisted\");\r\n\r\n        emit Deposited(_from, msg.sender, _tokenId, _data);\r\n\r\n        return ERC721_RECEIVED;\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw an NFT\r\n    * @param _beneficiary - Beneficiary's address\r\n    * @param _contract - NFT contract' address\r\n    * @param _tokenId - Token id\r\n    * @param _userId - User id\r\n    */\r\n    function withdraw(\r\n        address _beneficiary,\r\n        address _contract,\r\n        uint256 _tokenId,\r\n        bytes calldata _userId\r\n    ) external onlyAdmin {\r\n        _withdraw(_beneficiary, _contract, _tokenId, _userId);\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw an NFT by committing a valid signature\r\n    * @param _beneficiary - Beneficiary's address\r\n    * @param _contract - NFT contract' address\r\n    * @param _tokenId - Token id\r\n    * @param _expires - Expiration of the signature\r\n    * @param _userId - User id\r\n    * @param _signature - Signature\r\n    */\r\n    function withdraw(\r\n        address _beneficiary,\r\n        address  _contract,\r\n        uint256 _tokenId,\r\n        uint256 _expires,\r\n        bytes calldata _userId,\r\n        bytes calldata _signature\r\n    ) external {\r\n        require(_expires >= block.timestamp, \"Expired signature\");\r\n\r\n        bytes32 messageHash = keccak256(\r\n            abi.encodePacked(\r\n                _beneficiary,\r\n                _contract,\r\n                _tokenId,\r\n                _expires,\r\n                _userId\r\n            )\r\n        ).toEthSignedMessageHash();\r\n\r\n        _validateMessageAndSignature(messageHash, _signature);\r\n\r\n        _withdraw(_beneficiary, _contract, _tokenId, _userId);\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw many NFTs\r\n    * @param _beneficiary - Beneficiary's address\r\n    * @param _contracts - NFT contract' addresses\r\n    * @param _tokenIds - Token ids\r\n    * @param _userId - User id\r\n    */\r\n    function withdrawMany(\r\n        address _beneficiary,\r\n        address[] calldata _contracts,\r\n        uint256[] calldata _tokenIds,\r\n        bytes calldata _userId\r\n    ) external onlyAdmin {\r\n        require(\r\n            _contracts.length == _tokenIds.length,\r\n            \"Contracts and token ids must have the same length\"\r\n        );\r\n\r\n        _withdrawMany(_beneficiary, _contracts, _tokenIds, _userId);\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw many NFTs by committing a valid signature\r\n    * @param _beneficiary - Beneficiary's address\r\n    * @param _contracts - NFT contract' addresses\r\n    * @param _tokenIds - Token ids\r\n    * @param _expires - Expiration of the signature\r\n    * @param _userId - User id\r\n    * @param _signature - Signature\r\n    */\r\n    function withdrawMany(\r\n        address _beneficiary,\r\n        address[] calldata _contracts,\r\n        uint256[] calldata _tokenIds,\r\n        uint256 _expires,\r\n        bytes calldata _userId,\r\n        bytes calldata _signature\r\n    ) external {\r\n        require(_expires >= block.timestamp, \"Expired signature\");\r\n        require(\r\n            _contracts.length == _tokenIds.length,\r\n            \"Contracts and token ids must have the same length\"\r\n        );\r\n\r\n        bytes memory transferData;\r\n\r\n        for (uint256 i = 0; i < _contracts.length; i++) {\r\n            transferData = abi.encodePacked(\r\n                transferData,\r\n                abi.encode(\r\n                    _contracts[i],\r\n                    _tokenIds[i]\r\n                )\r\n            );\r\n        }\r\n\r\n        bytes32 messageHash = keccak256(\r\n            abi.encodePacked(\r\n                _beneficiary,\r\n                transferData,\r\n                _expires,\r\n                _userId\r\n            )\r\n        )\r\n        .toEthSignedMessageHash();\r\n\r\n        _validateMessageAndSignature(messageHash, _signature);\r\n\r\n        _withdrawMany(_beneficiary, _contracts, _tokenIds, _userId);\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw many NFTs\r\n    * @param _beneficiary - Beneficiary's address\r\n    * @param _contracts - NFT contract' addresses\r\n    * @param _tokenIds - Token ids\r\n    * @param _userId - User id\r\n    */\r\n    function _withdrawMany(\r\n        address _beneficiary,\r\n        address[] memory _contracts,\r\n        uint256[] memory _tokenIds,\r\n        bytes memory _userId\r\n    ) internal whenNotPaused {\r\n        for (uint256 i = 0; i < _contracts.length; i++) {\r\n            _withdraw(_beneficiary, _contracts[i], _tokenIds[i], _userId);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw an NFT\r\n    * @param _beneficiary - Beneficiary's address\r\n    * @param _contract - NFT contract' address\r\n    * @param _tokenId - Token id\r\n    * @param _userId - User id\r\n    */\r\n    function _withdraw(\r\n        address _beneficiary,\r\n        address _contract,\r\n        uint256 _tokenId,\r\n        bytes memory _userId\r\n    ) internal whenNotPaused {\r\n        IERC721(_contract).transferFrom(address(this), _beneficiary, _tokenId);\r\n\r\n        emit Withdrawn(_beneficiary, _contract, _tokenId, _userId);\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw an NFT by minting it\r\n    * @param _beneficiary - Beneficiary's address\r\n    * @param _contract - NFT contract' address\r\n    * @param _optionId - Option id\r\n    * @param _issuedId - Issued id\r\n    * @param _userId - User id\r\n    */\r\n    function issueToken(\r\n        address _beneficiary,\r\n        address _contract,\r\n        uint256 _optionId,\r\n        uint256 _issuedId,\r\n        bytes calldata _userId\r\n    ) external onlyAdmin {\r\n        _issueToken(\r\n            _beneficiary,\r\n            _contract,\r\n            _optionId,\r\n            _issuedId,\r\n            _userId\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw NFTs by minting them\r\n    * @param _beneficiary - Beneficiary's address\r\n    * @param _contracts - NFT contract' addresses\r\n    * @param _optionIds - Option ids\r\n    * @param _issuedIds - Issued ids\r\n    * @param _userId - User id\r\n    */\r\n    function issueManyTokens(\r\n        address _beneficiary,\r\n        address[] calldata _contracts,\r\n        uint256[] calldata _optionIds,\r\n        uint256[] calldata _issuedIds,\r\n        bytes calldata _userId\r\n    ) external onlyAdmin {\r\n        require(\r\n            _contracts.length == _optionIds.length,\r\n            \"Contracts and option ids must have the same length\"\r\n        );\r\n        require(\r\n            _optionIds.length == _issuedIds.length,\r\n            \"Option ids and issued ids must have the same length\"\r\n        );\r\n\r\n        _issueManyTokens(\r\n            _beneficiary,\r\n            _contracts,\r\n            _optionIds,\r\n            _issuedIds,\r\n            _userId\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw an NFT by minting it committing a valid signature\r\n    * @param _beneficiary - Beneficiary's address\r\n    * @param _contract - NFT contract' address\r\n    * @param _optionId - Option id\r\n    * @param _issuedId - Issued id\r\n    * @param _expires - Expiration of the signature\r\n    * @param _userId - User id\r\n    * @param _signature - Signature\r\n    */\r\n    function issueToken(\r\n        address _beneficiary,\r\n        address _contract,\r\n        uint256 _optionId,\r\n        uint256 _issuedId,\r\n        uint256 _expires,\r\n        bytes calldata _userId,\r\n        bytes calldata _signature\r\n    ) external {\r\n        require(_expires >= block.timestamp, \"Expired signature\");\r\n\r\n        bytes32 messageHash = keccak256(\r\n            abi.encodePacked(\r\n                _beneficiary,\r\n                _contract,\r\n                _optionId,\r\n                _issuedId,\r\n                _expires,\r\n                _userId\r\n            )\r\n        ).toEthSignedMessageHash();\r\n\r\n        _validateMessageAndSignature(messageHash, _signature);\r\n\r\n        _issueToken(\r\n            _beneficiary,\r\n            _contract,\r\n            _optionId,\r\n            _issuedId,\r\n            _userId\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw NFTs by minting them\r\n    * @param _beneficiary - Beneficiary's address\r\n    * @param _contracts - NFT contract' addresses\r\n    * @param _optionIds - Option ids\r\n    * @param _issuedIds - Issued ids\r\n    * @param _expires - Expiration of the signature\r\n    * @param _userId - User id\r\n    * @param _signature - Signature\r\n    */\r\n    function issueManyTokens(\r\n        address _beneficiary,\r\n        address[] calldata _contracts,\r\n        uint256[] calldata _optionIds,\r\n        uint256[] calldata _issuedIds,\r\n        uint256 _expires,\r\n        bytes calldata _userId,\r\n        bytes calldata _signature\r\n    ) external {\r\n        require(_expires >= block.timestamp, \"Expired signature\");\r\n        require(\r\n            _contracts.length == _optionIds.length,\r\n            \"Contracts and option ids must have the same length\"\r\n        );\r\n        require(\r\n            _optionIds.length == _issuedIds.length,\r\n            \"Option ids and issued ids must have the same length\"\r\n        );\r\n\r\n\r\n        bytes memory mintData;\r\n\r\n        for (uint256 i = 0; i < _contracts.length; i++) {\r\n            mintData = abi.encodePacked(\r\n                mintData,\r\n                abi.encode(\r\n                    _contracts[i],\r\n                    _optionIds[i],\r\n                    _issuedIds[i]\r\n                )\r\n            );\r\n        }\r\n\r\n        bytes32 messageHash = keccak256(\r\n            abi.encodePacked(\r\n                _beneficiary,\r\n                mintData,\r\n                _expires,\r\n                _userId\r\n            )\r\n        )\r\n        .toEthSignedMessageHash();\r\n\r\n        _validateMessageAndSignature(messageHash, _signature);\r\n\r\n        _issueManyTokens(\r\n            _beneficiary,\r\n            _contracts,\r\n            _optionIds,\r\n            _issuedIds,\r\n            _userId\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw NFTs by minting them\r\n    * @param _beneficiary - Beneficiary's address\r\n    * @param _contracts - NFT contract' addresses\r\n    * @param _optionIds - Option ids\r\n    * @param _issuedIds - Issued ids\r\n    * @param _userId - User id\r\n    */\r\n    function _issueManyTokens(\r\n        address _beneficiary,\r\n        address[] memory _contracts,\r\n        uint256[] memory _optionIds,\r\n        uint256[] memory _issuedIds,\r\n        bytes memory _userId\r\n    ) internal whenNotPaused {\r\n        for (uint256 i = 0; i < _contracts.length; i++) {\r\n            _issueToken(\r\n                _beneficiary,\r\n                _contracts[i],\r\n                _optionIds[i],\r\n                _issuedIds[i],\r\n                _userId\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Withdraw an NFT by minting it\r\n    * @notice that the mint is based on an option and issued id.\r\n    * The contract should implement the `issueToken` signature\r\n    * @param _beneficiary - Beneficiary's address\r\n    * @param _contract - NFT contract' address\r\n    * @param _optionId - Option id\r\n    * @param _issuedId - Issued id\r\n    * @param _userId - User id\r\n    */\r\n    function _issueToken(\r\n        address _beneficiary,\r\n        address _contract,\r\n        uint256 _optionId,\r\n        uint256 _issuedId,\r\n        bytes memory _userId\r\n    ) internal whenNotPaused {\r\n        IERC721PreMinteable(_contract).issueToken(_beneficiary, _optionId, _issuedId);\r\n\r\n        emit Issued(_beneficiary, _contract, _optionId, _issuedId, _userId);\r\n    }\r\n\r\n    /**\r\n    * @dev Validates that a message has not been processed, and signed by an authorized admin\r\n    * @notice that will revert if any of the condition fails\r\n    * @param _messageHash - Message\r\n    * @param _signature - Signature\r\n    */\r\n    function _validateMessageAndSignature(bytes32 _messageHash, bytes memory _signature) internal {\r\n        require(!messageProcessed[_messageHash], \"The message has been processed\");\r\n        messageProcessed[_messageHash] = true;\r\n\r\n        address signer = _messageHash.recover(_signature);\r\n        require(adminWhitelist[signer], \"Unauthorized admin signature\");\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_allowed\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"AdminSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_allowed\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"ContractSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_userId\",\"type\":\"bytes\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_optionId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_issuedId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_userId\",\"type\":\"bytes\"}],\"name\":\"Issued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_supervisor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_allowed\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"}],\"name\":\"SupervisorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_userId\",\"type\":\"bytes\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ERC721_RECEIVED\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"adminWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"contractWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_contracts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_optionIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_issuedIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_expires\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_userId\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"issueManyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_contracts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_optionIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_issuedIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_userId\",\"type\":\"bytes\"}],\"name\":\"issueManyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_issuedId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_userId\",\"type\":\"bytes\"}],\"name\":\"issueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_optionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_issuedId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expires\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_userId\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"issueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"messageProcessed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"setContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_supervisor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"setSupervisor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supervisorWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expires\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_userId\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_userId\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_contracts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_userId\",\"type\":\"bytes\"}],\"name\":\"withdrawMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_contracts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_expires\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_userId\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"withdrawMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Vault","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9a5e4d895cfe2c38c83c7afab32449f3748fe7d9a3455f55d66a80cddf359e82"}]}