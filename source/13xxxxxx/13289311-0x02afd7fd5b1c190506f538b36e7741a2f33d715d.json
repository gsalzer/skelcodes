{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.7;\n\n\n\n// Part: IERC165\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// Part: IKongNaming\n\ninterface IKongNaming {\n    event SetName(uint256 indexed tokenID, bytes32 name);\n\n    event SetBio(uint256 indexed tokenID, string bio);\n\n    function setName(bytes32 name, uint256 tokenID) external payable;\n\n    function setBio(string memory bio, uint256 tokenID) external payable;\n\n    function setNameAndBio(\n        bytes32 name,\n        string memory bio,\n        uint256 tokenID\n    ) external payable;\n\n    function batchSetName(bytes32[] memory names, uint256[] memory tokenIDs)\n        external\n        payable;\n\n    function batchSetBio(string[] memory bios, uint256[] memory tokenIDs)\n        external\n        payable;\n\n    function batchSetNameAndBio(\n        bytes32[] memory names,\n        string[] memory bios,\n        uint256[] memory tokenIDs\n    ) external payable;\n}\n\n// Part: OpenZeppelin/openzeppelin-contracts@4.3.0/ReentrancyGuard\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n// Part: IERC721\n\ninterface IERC721 is IERC165 {\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId)\n        external\n        view\n        returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    function isApprovedForAll(address owner, address operator)\n        external\n        view\n        returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n// File: KongNaming.sol\n\ncontract KongNaming is IKongNaming, ReentrancyGuard {\n    mapping(uint256 => bytes32) public names;\n    mapping(uint256 => string) public bios;\n\n    mapping(uint256 => bool) private nameWasSet;\n    mapping(uint256 => bool) private bioWasSet;\n\n    address public admin;\n    address payable public beneficiary;\n    IERC721 public immutable rkl;\n    uint256 public changePrice = 0.025 ether;\n\n    constructor(\n        address newAdmin,\n        address payable newBeneficiary,\n        address newRkl\n    ) {\n        ensureAddressNotZero(newAdmin);\n        ensureAddressNotZero(newBeneficiary);\n        ensureAddressNotZero(newRkl);\n        rkl = IERC721(newRkl);\n        admin = newAdmin;\n        beneficiary = newBeneficiary;\n    }\n\n    function setName(bytes32 name, uint256 tokenID)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        // check that the caller is either an owner or admin\n        bool isOwner = isOwnerOfKong(tokenID);\n        require(msg.sender == admin || isOwner, \"KongNaming::unauthorized\");\n\n        // if this is the first time the name is set, mark that the\n        // next time won't be and set the name\n        if (nameWasSet[tokenID] == false) {\n            nameWasSet[tokenID] = true;\n        } else {\n            // if it was the owner that called the function, require\n            // the payment\n            if (isOwner) {\n                require(\n                    msg.value == changePrice,\n                    \"KongNaming::insufficient ether sent\"\n                );\n            }\n        }\n\n        names[tokenID] = name;\n        emit IKongNaming.SetName(tokenID, name);\n    }\n\n    function setBio(string memory bio, uint256 tokenID)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        // check that the caller is either an owner or admin\n        bool isOwner = isOwnerOfKong(tokenID);\n        require(msg.sender == admin || isOwner, \"KongNaming::unauthorized\");\n\n        // if this is the first time the bio is set, mark that the\n        // next time won't be and set the bio\n        if (bioWasSet[tokenID] == false) {\n            bioWasSet[tokenID] = true;\n        } else {\n            // if it was the owner that called the function, require\n            // the payment\n            if (isOwner) {\n                require(\n                    msg.value == changePrice,\n                    \"KongNaming::insufficient ether sent\"\n                );\n            }\n        }\n\n        bios[tokenID] = bio;\n        emit IKongNaming.SetBio(tokenID, bio);\n    }\n\n    function setNameAndBio(\n        bytes32 name,\n        string memory bio,\n        uint256 tokenID\n    ) external payable override nonReentrant {\n        bool isOwner = isOwnerOfKong(tokenID);\n        require(msg.sender == admin || isOwner, \"KongNaming::unauthorized\");\n\n        uint256 payableSets = 0;\n\n        if (bioWasSet[tokenID] == false) {\n            bioWasSet[tokenID] = true;\n        } else {\n            payableSets += 1;\n        }\n\n        if (nameWasSet[tokenID] == false) {\n            nameWasSet[tokenID] = true;\n        } else {\n            payableSets += 1;\n        }\n\n        if (isOwner) {\n            require(\n                msg.value == payableSets * changePrice,\n                \"KongNaming::insufficient ether sent\"\n            );\n        }\n\n        names[tokenID] = name;\n        bios[tokenID] = bio;\n        emit IKongNaming.SetName(tokenID, name);\n        emit IKongNaming.SetBio(tokenID, bio);\n    }\n\n    function batchSetName(bytes32[] memory _names, uint256[] memory tokenIDs)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        // sanity checks\n        require(\n            _names.length == tokenIDs.length,\n            \"KongNaming::different length names and tokenIDs\"\n        );\n        // returns true if the sender is owner of all the passed tokenIDs\n        bool ownerOfAllKongs = isOwnerOfKongs(tokenIDs);\n        // require the caller to be the owner of all of the tokenIDs or be\n        // an admin\n        require(\n            msg.sender == admin || ownerOfAllKongs,\n            \"KongNaming::unauthorized\"\n        );\n\n        // counter to check how much ether should be sent\n        uint256 payableSets = 0;\n\n        for (uint256 i = 0; i < _names.length; i) {\n            if (nameWasSet[tokenIDs[i]] == false) {\n                nameWasSet[tokenIDs[i]] = true;\n            } else {\n                payableSets += 1;\n            }\n\n            names[tokenIDs[i]] = _names[i];\n            emit IKongNaming.SetName(tokenIDs[i], _names[i]);\n        }\n\n        // if it is owner who called, ensure that they have sent adequate\n        // payment\n        if (ownerOfAllKongs) {\n            require(\n                msg.value == payableSets * changePrice,\n                \"KongNaming::insufficient ether sent\"\n            );\n        }\n    }\n\n    function batchSetBio(string[] memory _bios, uint256[] memory tokenIDs)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        require(\n            _bios.length == tokenIDs.length,\n            \"KongNaming::different length bios and tokenIDs\"\n        );\n        bool ownerOfAllKongs = isOwnerOfKongs(tokenIDs);\n        require(\n            msg.sender == admin || ownerOfAllKongs,\n            \"KongNaming::not authorized\"\n        );\n\n        uint256 payableSets = 0;\n\n        for (uint256 i = 0; i < _bios.length; i) {\n            if (bioWasSet[tokenIDs[i]] == false) {\n                bioWasSet[tokenIDs[i]] = true;\n            } else {\n                payableSets += 1;\n            }\n\n            bios[tokenIDs[i]] = _bios[i];\n            emit IKongNaming.SetBio(tokenIDs[i], _bios[i]);\n        }\n\n        if (ownerOfAllKongs) {\n            require(\n                msg.value == payableSets * changePrice,\n                \"KongNaming::insufficient ether sent\"\n            );\n        }\n    }\n\n    function batchSetNameAndBio(\n        bytes32[] memory _names,\n        string[] memory _bios,\n        uint256[] memory tokenIDs\n    ) external payable override nonReentrant {\n        require(\n            _names.length == _bios.length,\n            \"KongNaming::different length names and bios\"\n        );\n        require(\n            _bios.length == tokenIDs.length,\n            \"KongNaming::different length bios and tokenIDs\"\n        );\n        bool ownerOfAllKongs = isOwnerOfKongs(tokenIDs);\n        require(\n            msg.sender == admin || ownerOfAllKongs,\n            \"KongNaming::not authorized\"\n        );\n\n        uint256 payableSets = 0;\n\n        for (uint256 i = 0; i < _names.length; i++) {\n            if (bioWasSet[tokenIDs[i]] == false) {\n                bioWasSet[tokenIDs[i]] = true;\n            } else {\n                payableSets += 1;\n            }\n            if (nameWasSet[tokenIDs[i]] == false) {\n                nameWasSet[tokenIDs[i]] = true;\n            } else {\n                payableSets += 1;\n            }\n\n            names[tokenIDs[i]] = _names[i];\n            bios[tokenIDs[i]] = _bios[i];\n            emit IKongNaming.SetName(tokenIDs[i], _names[i]);\n            emit IKongNaming.SetBio(tokenIDs[i], _bios[i]);\n        }\n\n        if (ownerOfAllKongs) {\n            require(\n                msg.value == payableSets * changePrice,\n                \"KongNaming::insufficient ether sent\"\n            );\n        }\n    }\n\n    function isOwnerOfKong(uint256 tokenID) private view returns (bool) {\n        return msg.sender == rkl.ownerOf(tokenID);\n    }\n\n    function isOwnerOfKongs(uint256[] memory tokenIDs)\n        private\n        view\n        returns (bool)\n    {\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\n            if (!isOwnerOfKong(tokenIDs[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function ensureAddressNotZero(address checkThisAddress) private pure {\n        require(checkThisAddress != address(0), \"KongNaming::address is zero\");\n    }\n\n    function editPrice(uint256 newChangePrice) external {\n        require(msg.sender == admin, \"KongNaming::unauthorized\");\n        changePrice = newChangePrice;\n    }\n\n    function editBeneficiary(address payable newBeneficiary) external {\n        require(msg.sender == admin, \"KongNaming::unauthorized\");\n        beneficiary = newBeneficiary;\n    }\n\n    function editAdmin(address newAdmin) external {\n        require(msg.sender == admin, \"KongNaming::unauthorized\");\n        admin = newAdmin;\n    }\n\n    function withdraw() external {\n        require(msg.sender == admin, \"KongNaming::unauthorized\");\n        beneficiary.transfer(address(this).balance);\n    }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"newBeneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newRkl\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"bio\",\"type\":\"string\"}],\"name\":\"SetBio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"SetName\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_bios\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"batchSetBio\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_names\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"batchSetName\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_names\",\"type\":\"bytes32[]\"},{\"internalType\":\"string[]\",\"name\":\"_bios\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIDs\",\"type\":\"uint256[]\"}],\"name\":\"batchSetNameAndBio\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bios\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"changePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"editAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"editBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newChangePrice\",\"type\":\"uint256\"}],\"name\":\"editPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"names\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rkl\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"bio\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"setBio\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"bio\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"setNameAndBio\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KongNaming","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000444e5a1a667663b0adfd853e8efa04706980000000000000000000000002b5964447005f661d13637cbdfffce600708138f000000000000000000000000ef0182dc0574cd5874494a120750fd222fdb909a","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}