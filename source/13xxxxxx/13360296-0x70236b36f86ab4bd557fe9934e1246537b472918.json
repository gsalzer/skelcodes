{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Delegator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./interfaces/IGovernanceToken.sol\\\";\\nimport \\\"../lib/openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Delegator Contract\\n * @author Cryptex.Finance\\n * @notice Contract in charge of handling delegations.\\n */\\n\\ncontract Delegator is Ownable {\\n   /* ========== STATE VARIABLES ========== */\\n\\n   /// @notice Address of the staking governance token\\n   address public immutable token;\\n\\n   /// @notice Tracks the amount of staked tokens per user\\n   mapping(address => uint256) public stakerBalance;\\n\\n   /* ========== CONSTRUCTOR ========== */\\n\\n   /**\\n    * @notice Constructor\\n    * @param delegatee_ address\\n    * @param token_ address\\n    * @dev when created delegates all it's power to delegatee_ and can't be changed later\\n    * @dev sets delegator factory as owner\\n    */\\n   constructor(address delegatee_, address token_) {\\n      require(\\n         delegatee_ != address(0) && token_ != address(0),\\n         \\\"Address can't be 0\\\"\\n      );\\n      require(IGovernanceToken(token_).decimals() == 18, \\\"Decimals must be 18\\\");\\n      token = token_;\\n      IGovernanceToken(token_).delegate(delegatee_);\\n   }\\n\\n   /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n   /**\\n    * @notice Increases the balance of the staker\\n    * @param staker_ caller of the stake function\\n    * @param amount_ uint to be staked and delegated\\n    * @dev Only delegatorFactory can call it\\n    * @dev after the balance is updated the amount is transferred from the user to this contract\\n    */\\n   function stake(address staker_, uint256 amount_) external onlyOwner {\\n      stakerBalance[staker_] += amount_;\\n   }\\n\\n   /**\\n    * @notice Decreases the balance of the staker\\n    * @param staker_ caller of the stake function\\n    * @param amount_ uint to be withdrawn and undelegated\\n    * @dev Only delegatorFactory can call it\\n    * @dev after the balance is updated the amount is transferred back to the user from this contract\\n    */\\n   function removeStake(address staker_, uint256 amount_) external onlyOwner {\\n      stakerBalance[staker_] -= amount_;\\n      require(\\n         IGovernanceToken(token).transfer(staker_, amount_),\\n         \\\"Transfer failed\\\"\\n      );\\n   }\\n\\n   /* ========== VIEWS ========== */\\n\\n   /// @notice returns the delegatee of this contract\\n   function delegatee() external returns (address) {\\n      return IGovernanceToken(token).delegates(address(this));\\n   }\\n}\\n\"\r\n    },\r\n    \"src/DelegatorFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport \\\"./interfaces/IGovernanceToken.sol\\\";\\nimport \\\"./Delegator.sol\\\";\\nimport \\\"../lib/openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\nimport \\\"../lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\\\";\\n\\n/**\\n * @title Delegator Contract Factory\\n * @author Cryptex.Finance\\n * @notice Contract in charge of generating Delegator contracts, handling delegations and CTX balance map, rewards.\\n */\\n\\ncontract DelegatorFactory is Ownable, ReentrancyGuard {\\n   /* ========== STATE VARIABLES ========== */\\n\\n   /// @notice Address of the staking governance token\\n   address public immutable stakingToken;\\n\\n   /// @notice Address of the reward token\\n   address public immutable rewardsToken;\\n\\n   /// @notice Minimum wait time before removing stake\\n   uint256 public waitTime;\\n\\n   /// @notice Tracks the period where users stop earning rewards\\n   uint256 public periodFinish = 0;\\n   uint256 public rewardRate = 0;\\n\\n   /// @notice How long the rewards lasts, it updates when more rewards are added\\n   uint256 public rewardsDuration = 186 days;\\n\\n   /// @notice Last time rewards were updated\\n   uint256 public lastUpdateTime;\\n\\n   /// @notice Amount of reward calculated per token stored\\n   uint256 public rewardPerTokenStored;\\n\\n   /// @notice Track the rewards paid to users\\n   mapping(address => uint256) public userRewardPerTokenPaid;\\n\\n   /// @notice Tracks the user rewards\\n   mapping(address => uint256) public rewards;\\n\\n   /// @notice Tracks the address of a delegatee with a delegator contract address\\n   mapping(address => address) public delegatorToDelegatee;\\n\\n   /// @notice Tracks the delegator contract address from delegatee address\\n   mapping(address => address) public delegateeToDelegator;\\n\\n   /// @notice Tracks if address is an official delegator\\n   mapping(address => bool) public delegators;\\n\\n   /// @notice Tracks minimum wait time the account has to wait before removing stake\\n   mapping(address => mapping(address => uint256)) public stakerWaitTime;\\n\\n   /// @dev Tracks the total supply of staked tokens\\n   uint256 private _totalSupply;\\n\\n   /// @dev Tracks the amount of staked tokens per user\\n   mapping(address => uint256) private _balances;\\n\\n   /* ========== EVENTS ========== */\\n\\n   /// @notice An event emitted when a Delegator is created\\n   event DelegatorCreated(address indexed delegator, address indexed delegatee);\\n\\n   /// @notice An event emitted when an user has staked and delegated\\n   event Staked(\\n      address indexed delegator,\\n      address indexed delegatee,\\n      uint256 amount\\n   );\\n\\n   /// @notice An event emitted when an user removes stake and undelegated\\n   event Withdrawn(\\n      address indexed delegator,\\n      address indexed delegatee,\\n      uint256 amount\\n   );\\n\\n   /// @notice An event emitted when the minimum wait time is updated\\n   event WaitTimeUpdated(uint256 waitTime);\\n\\n   /// @notice An event emitted when a reward is added\\n   event RewardAdded(uint256 reward);\\n\\n   /// @notice An event emitted when reward is paid to a user\\n   event RewardPaid(address indexed user, uint256 reward);\\n\\n   /// @notice An event emitted when the rewards duration is updated\\n   event RewardsDurationUpdated(uint256 newDuration);\\n\\n   /* ========== CONSTRUCTOR ========== */\\n\\n   /**\\n    * @notice Constructor\\n    * @param stakingToken_ address\\n    * @param rewardsToken_ address\\n    * @param waitTime_ uint256\\n    * @param timelock_ address\\n    * @dev transfers ownership to timelock\\n    */\\n   constructor(\\n      address stakingToken_,\\n      address rewardsToken_,\\n      uint256 waitTime_,\\n      address timelock_\\n   ) {\\n      require(\\n         stakingToken_ != address(0) &&\\n            rewardsToken_ != address(0) &&\\n            timelock_ != address(0),\\n         \\\"Address can't be 0\\\"\\n      );\\n      require(\\n         IGovernanceToken(stakingToken_).decimals() == 18 &&\\n            IGovernanceToken(rewardsToken_).decimals() == 18,\\n         \\\"Decimals must be 18\\\"\\n      );\\n      stakingToken = stakingToken_;\\n      rewardsToken = rewardsToken_;\\n      waitTime = waitTime_;\\n      transferOwnership(timelock_);\\n   }\\n\\n   /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n   /**\\n    * @notice Updates the reward and time on call.\\n    * @param account_ address\\n    */\\n   function updateReward(address account_) private {\\n      rewardPerTokenStored = rewardPerToken();\\n      lastUpdateTime = lastTimeRewardApplicable();\\n\\n      if (account_ != address(0)) {\\n         rewards[account_] = currentEarned(account_);\\n         userRewardPerTokenPaid[account_] = rewardPerTokenStored;\\n      }\\n   }\\n\\n   /**\\n    * @notice Notifies the contract that reward has been added to be given.\\n    * @param reward_ uint\\n    * @dev Only owner  can call it\\n    * @dev Increases duration of rewards\\n    */\\n   function notifyRewardAmount(uint256 reward_) external onlyOwner {\\n      updateReward(address(0));\\n      if (block.timestamp >= periodFinish) {\\n         rewardRate = reward_ / rewardsDuration;\\n      } else {\\n         uint256 remaining = periodFinish - block.timestamp;\\n         uint256 leftover = remaining * rewardRate;\\n         rewardRate = (reward_ + leftover) / rewardsDuration;\\n      }\\n\\n      lastUpdateTime = block.timestamp;\\n      periodFinish = block.timestamp + rewardsDuration;\\n\\n      // Ensure the provided reward amount is not more than the balance in the contract.\\n      // This keeps the reward rate in the right range, preventing overflows due to\\n      // very high values of rewardRate in the earned and rewardsPerToken functions;\\n      // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\\n      uint256 balance = IGovernanceToken(rewardsToken).balanceOf(address(this));\\n      require(\\n         rewardRate <= balance / rewardsDuration,\\n         \\\"Provided reward too high\\\"\\n      );\\n      emit RewardAdded(reward_);\\n   }\\n\\n   /**\\n    * @notice  Updates the reward duration\\n    * @param rewardsDuration_ uint\\n    * @dev Only owner can call it\\n    * @dev Previous rewards must be complete\\n    */\\n   function setRewardsDuration(uint256 rewardsDuration_) external onlyOwner {\\n      require(\\n         block.timestamp > periodFinish,\\n         \\\"Previous rewards period must be complete before changing the duration for the new period\\\"\\n      );\\n      rewardsDuration = rewardsDuration_;\\n      emit RewardsDurationUpdated(rewardsDuration);\\n   }\\n\\n   /**\\n    * @notice Transfers to the caller the current amount of rewards tokens earned.\\n    * @dev updates rewards on call\\n    */\\n   function getReward() external nonReentrant {\\n      updateReward(msg.sender);\\n      uint256 reward = rewards[msg.sender];\\n      if (reward > 0) {\\n         rewards[msg.sender] = 0;\\n         require(\\n            IGovernanceToken(rewardsToken).transfer(msg.sender, reward),\\n            \\\"Transfer Failed\\\"\\n         );\\n         emit RewardPaid(msg.sender, reward);\\n      }\\n   }\\n\\n   /**\\n    * @notice Creates a new delegator contract that delegates all votes to delegatee_\\n    * @param delegatee_ address that will be receiving all votes\\n    * @dev only one delegator contract pointing to the same delegatee can exist\\n    */\\n   function createDelegator(address delegatee_) external {\\n      require(delegatee_ != address(0), \\\"Delegatee can't be 0\\\");\\n      require(\\n         delegateeToDelegator[delegatee_] == address(0),\\n         \\\"Delegator already created\\\"\\n      );\\n      Delegator delegator = new Delegator(delegatee_, stakingToken);\\n      delegateeToDelegator[delegatee_] = address(delegator);\\n      delegatorToDelegatee[address(delegator)] = delegatee_;\\n      delegators[address(delegator)] = true;\\n      emit DelegatorCreated(address(delegator), delegatee_);\\n   }\\n\\n   /**\\n    * @notice Stakes to delegator_ the amount_ specified\\n    * @param delegator_ contract address where to send the amount_\\n    * @param amount_ uint to be staked and delegated\\n    * @dev Delegator must be valid and amount has to be greater than 0\\n    * @dev amount_ is transferred to the delegator contract and staker starts earning rewards if active\\n    * @dev updates rewards on call\\n    */\\n   function stake(address delegator_, uint256 amount_) external nonReentrant {\\n      require(delegators[delegator_], \\\"Not a valid delegator\\\");\\n      require(amount_ > 0, \\\"Amount must be greater than 0\\\");\\n      updateReward(msg.sender);\\n      _totalSupply = _totalSupply + amount_;\\n      _balances[msg.sender] = _balances[msg.sender] + amount_;\\n      Delegator d = Delegator(delegator_);\\n      d.stake(msg.sender, amount_);\\n      stakerWaitTime[msg.sender][delegator_] = block.timestamp + waitTime;\\n      require(\\n         IGovernanceToken(stakingToken).transferFrom(\\n            msg.sender,\\n            delegator_,\\n            amount_\\n         ),\\n         \\\"Transfer Failed\\\"\\n      );\\n      emit Staked(delegator_, msg.sender, amount_);\\n   }\\n\\n   /**\\n    * @notice Removes amount_ from delegator_\\n    * @param delegator_ contract address where to remove the stake from\\n    * @param amount_ uint to be removed from stake and undelegated\\n    * @dev Delegator must be valid and amount has to be greater than 0\\n    * @dev amount_ must be <= that current user stake\\n    * @dev amount_ is transferred from the  delegator contract to the staker\\n    * @dev updates rewards on call\\n    * @dev requires that at least waitTime has passed since delegation to unDelegate\\n    */\\n   function withdraw(address delegator_, uint256 amount_)\\n      external\\n      nonReentrant\\n   {\\n      require(delegators[delegator_], \\\"Not a valid delegator\\\");\\n      require(amount_ > 0, \\\"Amount must be greater than 0\\\");\\n      require(\\n         block.timestamp >= stakerWaitTime[msg.sender][delegator_],\\n         \\\"Need to wait the minimum staking period\\\"\\n      );\\n      updateReward(msg.sender);\\n      _totalSupply = _totalSupply - amount_;\\n      _balances[msg.sender] = _balances[msg.sender] - amount_;\\n      Delegator d = Delegator(delegator_);\\n      d.removeStake(msg.sender, amount_);\\n      emit Withdrawn(delegator_, msg.sender, amount_);\\n   }\\n\\n   /**\\n    * @notice updates the min wait time between delegation and unDelegation\\n    * @param waitTime_ uint new wait time\\n    * @dev only the owner can call it\\n    */\\n   function updateWaitTime(uint256 waitTime_) external onlyOwner {\\n      waitTime = waitTime_;\\n      emit WaitTimeUpdated(waitTime_);\\n   }\\n\\n   /* ========== VIEWS ========== */\\n\\n   /**\\n    * @notice Returns the amount of reward tokens a user has earned.\\n    * @param account_ address\\n    */\\n   function currentEarned(address account_) private view returns (uint256) {\\n      return\\n         (_balances[account_] *\\n            (rewardPerTokenStored - userRewardPerTokenPaid[account_])) /\\n         1e18 +\\n         rewards[account_];\\n   }\\n\\n   /// @notice Returns the total amount of staked tokens.\\n   function totalSupply() external view returns (uint256) {\\n      return _totalSupply;\\n   }\\n\\n   /**\\n    * @notice Returns the amount of staked tokens from specific user\\n    * @param account_ address\\n    */\\n   function balanceOf(address account_) external view returns (uint256) {\\n      return _balances[account_];\\n   }\\n\\n   /// @notice Returns reward rate for a duration\\n   function getRewardForDuration() external view returns (uint256) {\\n      return rewardRate * rewardsDuration;\\n   }\\n\\n   /// @notice Returns the minimum between current block timestamp or the finish period of rewards.\\n   function lastTimeRewardApplicable() public view returns (uint256) {\\n      return min(block.timestamp, periodFinish);\\n   }\\n\\n   /// @notice Returns the calculated reward per token deposited.\\n   function rewardPerToken() public view returns (uint256) {\\n      if (_totalSupply == 0) {\\n         return rewardPerTokenStored;\\n      }\\n\\n      return\\n         rewardPerTokenStored +\\n         ((lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18) /\\n         _totalSupply;\\n   }\\n\\n   /**\\n    * @notice Returns the amount of reward tokens a user has earned.\\n    * @param account_ address\\n    */\\n   function earned(address account_) public view returns (uint256) {\\n      return\\n         (_balances[account_] *\\n            (rewardPerToken() - userRewardPerTokenPaid[account_])) /\\n         1e18 +\\n         rewards[account_];\\n   }\\n\\n   /**\\n    * @notice Returns the minimum between two variables\\n    * @param a_ uint\\n    * @param b_ uint\\n    */\\n   function min(uint256 a_, uint256 b_) public pure returns (uint256) {\\n      return a_ < b_ ? a_ : b_;\\n   }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IGovernanceToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\ninterface IGovernanceToken {\\n   function delegate(address delegatee) external;\\n\\n   function delegates(address delegator) external returns (address);\\n\\n   function transfer(address dst, uint256 rawAmount) external returns (bool);\\n\\n   function transferFrom(\\n      address src,\\n      address dst,\\n      uint256 rawAmount\\n   ) external returns (bool);\\n\\n   function balanceOf(address src) external returns (uint256);\\n\\n   function decimals() external returns (uint8);\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakingToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardsToken_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"waitTime_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"timelock_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"DelegatorCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"RewardsDurationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"waitTime\",\"type\":\"uint256\"}],\"name\":\"WaitTimeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee_\",\"type\":\"address\"}],\"name\":\"createDelegator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegateeToDelegator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegatorToDelegatee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account_\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardForDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b_\",\"type\":\"uint256\"}],\"name\":\"min\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward_\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardsDuration_\",\"type\":\"uint256\"}],\"name\":\"setRewardsDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakerWaitTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"waitTime_\",\"type\":\"uint256\"}],\"name\":\"updateWaitTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"waitTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DelegatorFactory","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000321c2fe4446c7c963dc41dd58879af648838f98d000000000000000000000000321c2fe4446c7c963dc41dd58879af648838f98d0000000000000000000000000000000000000000000000000000000000093a80000000000000000000000000a70b638b70154edfcbb8dbbbd04900f328f32c35","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}