{"status":"1","message":"OK","result":[{"SourceCode":"// File: node_modules\\@openzeppelin\\contracts\\utils\\introspection\\IERC165.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC1155\\IERC1155.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: contracts\\model\\IERC1155Views.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\n\r\n/**\r\n * @title IERC1155Views - An optional utility interface to improve the ERC-1155 Standard.\r\n * @dev This interface introduces some additional capabilities for ERC-1155 Tokens.\r\n */\r\ninterface IERC1155Views {\r\n\r\n    /**\r\n     * @dev Returns the total supply of the given token id\r\n     * @param itemId the id of the token whose availability you want to know \r\n     */\r\n    function totalSupply(uint256 itemId) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the name of the given token id\r\n     * @param itemId the id of the token whose name you want to know \r\n     */\r\n    function name(uint256 itemId) external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the given token id\r\n     * @param itemId the id of the token whose symbol you want to know \r\n     */\r\n    function symbol(uint256 itemId) external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals of the given token id\r\n     * @param itemId the id of the token whose decimals you want to know \r\n     */\r\n    function decimals(uint256 itemId) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the uri of the given token id\r\n     * @param itemId the id of the token whose uri you want to know \r\n     */\r\n    function uri(uint256 itemId) external view returns (string memory);\r\n}\r\n\r\n// File: contracts\\model\\Item.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\npragma abicoder v2;\r\n\r\n\r\n\r\nstruct Header {\r\n    address host;\r\n    string name;\r\n    string symbol;\r\n    string uri;\r\n}\r\n\r\nstruct CreateItem {\r\n    Header header;\r\n    bytes32 collectionId;\r\n    uint256 id;\r\n    address[] accounts;\r\n    uint256[] amounts;\r\n}\r\n\r\ninterface Item is IERC1155, IERC1155Views {\r\n\r\n    event CollectionItem(bytes32 indexed fromCollectionId, bytes32 indexed toCollectionId, uint256 indexed itemId);\r\n\r\n    function name() external view returns(string memory);\r\n    function symbol() external view returns(string memory);\r\n\r\n    function burn(address account, uint256 itemId, uint256 amount) external;\r\n    function burnBatch(address account, uint256[] calldata itemIds, uint256[] calldata amounts) external;\r\n\r\n    function burn(address account, uint256 itemId, uint256 amount, bytes calldata data) external;\r\n    function burnBatch(address account, uint256[] calldata itemIds, uint256[] calldata amounts, bytes calldata data) external;\r\n\r\n    function mintItems(CreateItem[] calldata items) external returns(uint256[] memory itemIds);\r\n    function setItemsCollection(uint256[] calldata itemIds, bytes32[] calldata collectionIds) external returns(bytes32[] memory oldCollectionIds);\r\n    function setItemsMetadata(uint256[] calldata itemIds, Header[] calldata amounts) external returns(Header[] memory oldValues);\r\n\r\n    function interoperableOf(uint256 itemId) external view returns(address);\r\n}\r\n\r\n// File: node_modules\\@ethereansos\\swissknife\\contracts\\generic\\model\\ILazyInitCapableElement.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\n\r\ninterface ILazyInitCapableElement is IERC165 {\r\n\r\n    function lazyInit(bytes calldata lazyInitData) external returns(bytes memory initResponse);\r\n    function initializer() external view returns(address);\r\n\r\n    event Host(address indexed from, address indexed to);\r\n\r\n    function host() external view returns(address);\r\n    function setHost(address newValue) external returns(address oldValue);\r\n\r\n    function subjectIsAuthorizedFor(address subject, address location, bytes4 selector, bytes calldata payload, uint256 value) external view returns(bool);\r\n}\r\n\r\n// File: @ethereansos\\swissknife\\contracts\\dynamicMetadata\\model\\IDynamicMetadataCapableElement.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\n\r\ninterface IDynamicMetadataCapableElement is ILazyInitCapableElement {\r\n\r\n    function uri() external view returns(string memory);\r\n    function plainUri() external view returns(string memory);\r\n\r\n    function setUri(string calldata newValue) external returns (string memory oldValue);\r\n\r\n    function dynamicUriResolver() external view returns(address);\r\n    function setDynamicUriResolver(address newValue) external returns(address oldValue);\r\n}\r\n\r\n// File: contracts\\model\\IItemMainInterface.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\n\r\n\r\nstruct ItemData {\r\n    bytes32 collectionId;\r\n    Header header;\r\n    bytes32 domainSeparator;\r\n    uint256 totalSupply;\r\n    mapping(address => uint256) balanceOf;\r\n    mapping(address => mapping(address => uint256)) allowance;\r\n    mapping(address => uint256) nonces;\r\n}\r\n\r\ninterface IItemMainInterface is Item, IDynamicMetadataCapableElement {\r\n\r\n    event Collection(address indexed from, address indexed to, bytes32 indexed collectionId);\r\n\r\n    function interoperableInterfaceModel() external view returns(address);\r\n\r\n    function collection(bytes32 collectionId) external view returns(address host, string memory name, string memory symbol, string memory uri);\r\n    function collectionUri(bytes32 collectionId) external view returns(string memory);\r\n    function createCollection(Header calldata _collection, CreateItem[] calldata items) external returns(bytes32 collectionId, uint256[] memory itemIds);\r\n    function setCollectionsMetadata(bytes32[] calldata collectionIds, Header[] calldata values) external returns(Header[] memory oldValues);\r\n\r\n    function item(uint256 itemId) external view returns(bytes32 collectionId, Header memory header, bytes32 domainSeparator, uint256 totalSupply);\r\n\r\n    function mintTransferOrBurn(bool isMulti, bytes calldata data) external;\r\n\r\n    function allowance(address account, address spender, uint256 itemId) external view returns(uint256);\r\n    function approve(address account, address spender, uint256 amount, uint256 itemId) external;\r\n    function TYPEHASH_PERMIT() external view returns (bytes32);\r\n    function EIP712_PERMIT_DOMAINSEPARATOR_NAME_AND_VERSION() external view returns(string memory domainSeparatorName, string memory domainSeparatorVersion);\r\n    function permit(uint256 itemId, address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function nonces(address owner, uint256 itemId) external view returns(uint256);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\IERC20.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\extensions\\IERC20Metadata.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\extensions\\draft-IERC20Permit.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n// File: contracts\\model\\IItemInteroperableInterface.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\n\r\n\r\n\r\n\r\ninterface IItemInteroperableInterface is IERC20, IERC20Metadata, IERC20Permit {\r\n\r\n    function init() external;\r\n    function mainInterface() external view returns(address);\r\n    function itemId() external view returns(uint256);\r\n    function emitEvent(bool forApprove, bool isMulti, bytes calldata data) external;\r\n    function burn(uint256 amount) external;\r\n    function EIP712_PERMIT_DOMAINSEPARATOR_NAME_AND_VERSION() external view returns(string memory name, string memory version);\r\n}\r\n\r\n// File: node_modules\\@ethereansos\\swissknife\\contracts\\dynamicMetadata\\model\\IDynamicUriResolver.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\ninterface IDynamicUriResolver {\r\n    function resolve(address subject, string calldata plainUri, bytes calldata inputData, address caller) external view returns(string memory);\r\n}\r\n\r\n// File: node_modules\\@ethereansos\\swissknife\\contracts\\lib\\GeneralUtilities.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\nlibrary BehaviorUtilities {\r\n\r\n    function randomKey(uint256 i) internal view returns (bytes32) {\r\n        return keccak256(abi.encode(i, block.timestamp, block.number, tx.origin, tx.gasprice, block.coinbase, block.difficulty, msg.sender, blockhash(block.number - 5)));\r\n    }\r\n\r\n    function calculateProjectedArraySizeAndLoopUpperBound(uint256 arraySize, uint256 start, uint256 offset) internal pure returns(uint256 projectedArraySize, uint256 projectedArrayLoopUpperBound) {\r\n        if(arraySize != 0 && start < arraySize && offset != 0) {\r\n            uint256 length = start + offset;\r\n            if(start < (length = length > arraySize ? arraySize : length)) {\r\n                projectedArraySize = (projectedArrayLoopUpperBound = length) - start;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary ReflectionUtilities {\r\n\r\n    function read(address subject, bytes memory inputData) internal view returns(bytes memory returnData) {\r\n        bool result;\r\n        (result, returnData) = subject.staticcall(inputData);\r\n        if(!result) {\r\n            assembly {\r\n                revert(add(returnData, 0x20), mload(returnData))\r\n            }\r\n        }\r\n    }\r\n\r\n    function submit(address subject, uint256 value, bytes memory inputData) internal returns(bytes memory returnData) {\r\n        bool result;\r\n        (result, returnData) = subject.call{value : value}(inputData);\r\n        if(!result) {\r\n            assembly {\r\n                revert(add(returnData, 0x20), mload(returnData))\r\n            }\r\n        }\r\n    }\r\n\r\n    function isContract(address subject) internal view returns (bool) {\r\n        if(subject == address(0)) {\r\n            return false;\r\n        }\r\n        uint256 codeLength;\r\n        assembly {\r\n            codeLength := extcodesize(subject)\r\n        }\r\n        return codeLength > 0;\r\n    }\r\n\r\n    function clone(address originalContract) internal returns(address copyContract) {\r\n        assembly {\r\n            mstore(\r\n                0,\r\n                or(\r\n                    0x5880730000000000000000000000000000000000000000803b80938091923cF3,\r\n                    mul(originalContract, 0x1000000000000000000)\r\n                )\r\n            )\r\n            copyContract := create(0, 0, 32)\r\n            switch extcodesize(copyContract)\r\n                case 0 {\r\n                    invalid()\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary BytesUtilities {\r\n\r\n    bytes private constant ALPHABET = \"0123456789abcdef\";\r\n\r\n    function asAddress(bytes memory b) internal pure returns(address) {\r\n        if(b.length == 0) {\r\n            return address(0);\r\n        }\r\n        if(b.length == 20) {\r\n            address addr;\r\n            assembly {\r\n                addr := mload(add(b, 20))\r\n            }\r\n            return addr;\r\n        }\r\n        return abi.decode(b, (address));\r\n    }\r\n\r\n    function asAddressArray(bytes memory b) internal pure returns(address[] memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (address[]));\r\n        }\r\n    }\r\n\r\n    function asBool(bytes memory bs) internal pure returns(bool) {\r\n        return asUint256(bs) != 0;\r\n    }\r\n\r\n    function asBoolArray(bytes memory b) internal pure returns(bool[] memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (bool[]));\r\n        }\r\n    }\r\n\r\n    function asBytesArray(bytes memory b) internal pure returns(bytes[] memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (bytes[]));\r\n        }\r\n    }\r\n\r\n    function asString(bytes memory b) internal pure returns(string memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (string));\r\n        }\r\n    }\r\n\r\n    function asStringArray(bytes memory b) internal pure returns(string[] memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (string[]));\r\n        }\r\n    }\r\n\r\n    function asUint256(bytes memory bs) internal pure returns(uint256 x) {\r\n        if (bs.length >= 32) {\r\n            assembly {\r\n                x := mload(add(bs, add(0x20, 0)))\r\n            }\r\n        }\r\n    }\r\n\r\n    function asUint256Array(bytes memory b) internal pure returns(uint256[] memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (uint256[]));\r\n        }\r\n    }\r\n\r\n    function toString(bytes memory data) internal pure returns(string memory) {\r\n        bytes memory str = new bytes(2 + data.length * 2);\r\n        str[0] = \"0\";\r\n        str[1] = \"x\";\r\n        for (uint i = 0; i < data.length; i++) {\r\n            str[2+i*2] = ALPHABET[uint(uint8(data[i] >> 4))];\r\n            str[3+i*2] = ALPHABET[uint(uint8(data[i] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n}\r\n\r\nlibrary StringUtilities {\r\n\r\n    bytes1 private constant CHAR_0 = bytes1('0');\r\n    bytes1 private constant CHAR_A = bytes1('A');\r\n    bytes1 private constant CHAR_a = bytes1('a');\r\n    bytes1 private constant CHAR_f = bytes1('f');\r\n\r\n    function isEmpty(string memory test) internal pure returns (bool) {\r\n        return equals(test, \"\");\r\n    }\r\n\r\n    function equals(string memory a, string memory b) internal pure returns(bool) {\r\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\r\n    }\r\n\r\n    function toLowerCase(string memory str) internal pure returns(string memory) {\r\n        bytes memory bStr = bytes(str);\r\n        for (uint i = 0; i < bStr.length; i++) {\r\n            bStr[i] = bStr[i] >= 0x41 && bStr[i] <= 0x5A ? bytes1(uint8(bStr[i]) + 0x20) : bStr[i];\r\n        }\r\n        return string(bStr);\r\n    }\r\n\r\n    function asBytes(string calldata str) internal pure returns(bytes memory toDecode) {\r\n        bytes memory data = abi.encodePacked(str);\r\n        if(data.length == 0 || data[0] != \"0\" || (data[1] != \"x\" && data[1] != \"X\")) {\r\n            return \"\";\r\n        }\r\n        uint256 start = 2;\r\n        toDecode = new bytes((data.length - 2) / 2);\r\n\r\n        for(uint256 i = 0; i < toDecode.length; i++) {\r\n            toDecode[i] = bytes1(_fromHexChar(uint8(data[start++])) + _fromHexChar(uint8(data[start++])) * 16);\r\n        }\r\n    }\r\n\r\n    function _fromHexChar(uint8 c) private pure returns (uint8) {\r\n        bytes1 charc = bytes1(c);\r\n        return charc < CHAR_0 || charc > CHAR_f ? 0 : (charc < CHAR_A ? 0 : 10) + c - uint8(charc < CHAR_A ? CHAR_0 : charc < CHAR_a ? CHAR_A : CHAR_a);\r\n    }\r\n}\r\n\r\nlibrary Uint256Utilities {\r\n    function asSingletonArray(uint256 n) internal pure returns(uint256[] memory array) {\r\n        array = new uint256[](1);\r\n        array[0] = n;\r\n    }\r\n\r\n    function toString(uint256 _i) internal pure returns (string memory) {\r\n        return BytesUtilities.toString(abi.encodePacked(_i));\r\n    }\r\n}\r\n\r\nlibrary AddressUtilities {\r\n    function asSingletonArray(address a) internal pure returns(address[] memory array) {\r\n        array = new address[](1);\r\n        array[0] = a;\r\n    }\r\n\r\n    function toString(address _addr) internal pure returns (string memory) {\r\n        return _addr == address(0) ? \"0x0000000000000000000000000000000000000000\" : BytesUtilities.toString(abi.encodePacked(_addr));\r\n    }\r\n}\r\n\r\nlibrary Bytes32Utilities {\r\n\r\n    function asSingletonArray(bytes32 a) internal pure returns(bytes32[] memory array) {\r\n        array = new bytes32[](1);\r\n        array[0] = a;\r\n    }\r\n\r\n    function toString(bytes32 bt) internal pure returns (string memory) {\r\n        return bt == bytes32(0) ?  \"0x0000000000000000000000000000000000000000000000000000000000000000\" : BytesUtilities.toString(abi.encodePacked(bt));\r\n    }\r\n}\r\n\r\n// File: node_modules\\@ethereansos\\swissknife\\contracts\\generic\\impl\\LazyInitCapableElement.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\n\r\n\r\nabstract contract LazyInitCapableElement is ILazyInitCapableElement {\r\n    using ReflectionUtilities for address;\r\n\r\n    address public override initializer;\r\n    address public override host;\r\n\r\n    constructor(bytes memory lazyInitData) {\r\n        if(lazyInitData.length > 0) {\r\n            _privateLazyInit(lazyInitData);\r\n        }\r\n    }\r\n\r\n    function lazyInit(bytes calldata lazyInitData) override external returns (bytes memory lazyInitResponse) {\r\n        return _privateLazyInit(lazyInitData);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) override external view returns(bool) {\r\n        return\r\n            interfaceId == type(IERC165).interfaceId ||\r\n            interfaceId == this.supportsInterface.selector ||\r\n            interfaceId == type(ILazyInitCapableElement).interfaceId ||\r\n            interfaceId == this.lazyInit.selector ||\r\n            interfaceId == this.initializer.selector ||\r\n            interfaceId == this.subjectIsAuthorizedFor.selector ||\r\n            interfaceId == this.host.selector ||\r\n            interfaceId == this.setHost.selector ||\r\n            _supportsInterface(interfaceId);\r\n    }\r\n\r\n    function setHost(address newValue) external override authorizedOnly returns(address oldValue) {\r\n        emit Host(oldValue = host, host = newValue);\r\n    }\r\n\r\n    function subjectIsAuthorizedFor(address subject, address location, bytes4 selector, bytes calldata payload, uint256 value) public override virtual view returns(bool) {\r\n        (bool chidlElementValidationIsConsistent, bool chidlElementValidationResult) = _subjectIsAuthorizedFor(subject, location, selector, payload, value);\r\n        if(chidlElementValidationIsConsistent) {\r\n            return chidlElementValidationResult;\r\n        }\r\n        if(subject == host) {\r\n            return true;\r\n        }\r\n        if(!host.isContract()) {\r\n            return false;\r\n        }\r\n        (bool result, bytes memory resultData) = host.staticcall(abi.encodeWithSelector(ILazyInitCapableElement(host).subjectIsAuthorizedFor.selector, subject, location, selector, payload, value));\r\n        return result && abi.decode(resultData, (bool));\r\n    }\r\n\r\n    function _privateLazyInit(bytes memory lazyInitData) private returns (bytes memory lazyInitResponse) {\r\n        require(initializer == address(0), \"init\");\r\n        initializer = msg.sender;\r\n        (host, lazyInitResponse) = abi.decode(lazyInitData, (address, bytes));\r\n        emit Host(address(0), host);\r\n        lazyInitResponse = _lazyInit(lazyInitResponse);\r\n    }\r\n\r\n    function _lazyInit(bytes memory) internal virtual returns (bytes memory) {\r\n        return \"\";\r\n    }\r\n\r\n    function _supportsInterface(bytes4 selector) internal virtual view returns (bool);\r\n\r\n    function _subjectIsAuthorizedFor(address, address, bytes4, bytes calldata, uint256) internal virtual view returns(bool, bool) {\r\n    }\r\n\r\n    modifier authorizedOnly {\r\n        require(_authorizedOnly(), \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function _authorizedOnly() internal returns(bool) {\r\n        return subjectIsAuthorizedFor(msg.sender, address(this), msg.sig, msg.data, msg.value);\r\n    }\r\n}\r\n\r\n// File: @ethereansos\\swissknife\\contracts\\dynamicMetadata\\impl\\DynamicMetadataCapableElement.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\n\r\n\r\n\r\nabstract contract DynamicMetadataCapableElement is IDynamicMetadataCapableElement, LazyInitCapableElement {\r\n\r\n    string public override plainUri;\r\n    address public override dynamicUriResolver;\r\n\r\n    constructor(bytes memory lazyInitData) LazyInitCapableElement(lazyInitData) {\r\n    }\r\n\r\n    function _lazyInit(bytes memory lazyInitData) internal override returns (bytes memory lazyInitResponse) {\r\n        (plainUri, dynamicUriResolver, lazyInitResponse) = abi.decode(lazyInitData, (string, address, bytes));\r\n        lazyInitResponse = _dynamicMetadataElementLazyInit(lazyInitResponse);\r\n    }\r\n\r\n    function _supportsInterface(bytes4 interfaceId) internal override view returns(bool) {\r\n        return\r\n            interfaceId == type(IDynamicMetadataCapableElement).interfaceId ||\r\n            interfaceId == this.plainUri.selector ||\r\n            interfaceId == this.uri.selector ||\r\n            interfaceId == this.dynamicUriResolver.selector ||\r\n            interfaceId == this.setUri.selector ||\r\n            interfaceId == this.setDynamicUriResolver.selector ||\r\n            _dynamicMetadataElementSupportsInterface(interfaceId);\r\n    }\r\n\r\n    function uri() external override view returns(string memory) {\r\n        return _uri(plainUri, \"\");\r\n    }\r\n\r\n    function setUri(string calldata newValue) external override authorizedOnly returns (string memory oldValue) {\r\n        oldValue = plainUri;\r\n        plainUri = newValue;\r\n    }\r\n\r\n    function setDynamicUriResolver(address newValue) external override authorizedOnly returns(address oldValue) {\r\n        oldValue = dynamicUriResolver;\r\n        dynamicUriResolver = newValue;\r\n    }\r\n\r\n    function _uri(string memory _plainUri, bytes memory additionalData) internal view returns(string memory) {\r\n        if(dynamicUriResolver == address(0)) {\r\n            return _plainUri;\r\n        }\r\n        return IDynamicUriResolver(dynamicUriResolver).resolve(address(this), _plainUri, additionalData, msg.sender);\r\n    }\r\n\r\n    function _dynamicMetadataElementLazyInit(bytes memory lazyInitData) internal virtual returns(bytes memory);\r\n\r\n    function _dynamicMetadataElementSupportsInterface(bytes4 interfaceId) internal virtual view returns(bool);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC1155\\IERC1155Receiver.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n        @dev Handles the receipt of a single ERC1155 token type. This function is\r\n        called at the end of a `safeTransferFrom` after the balance has been updated.\r\n        To accept the transfer, this must return\r\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n        (i.e. 0xf23a6e61, or its own function selector).\r\n        @param operator The address which initiated the transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param id The ID of the token being transferred\r\n        @param value The amount of tokens being transferred\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n        is called at the end of a `safeBatchTransferFrom` after the balances have\r\n        been updated. To accept the transfer(s), this must return\r\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n        (i.e. 0xbc197c81, or its own function selector).\r\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: contracts\\util\\ERC1155CommonLibrary.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\n\r\n\r\nlibrary ERC1155CommonLibrary {\r\n    using ReflectionUtilities for address;\r\n\r\n    function doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) internal {\r\n        if (to.isContract()) {\r\n            try\r\n                IERC1155Receiver(to).onERC1155Received(\r\n                    operator,\r\n                    from,\r\n                    id,\r\n                    amount,\r\n                    data\r\n                )\r\n            returns (bytes4 response) {\r\n                if (\r\n                    response != IERC1155Receiver(to).onERC1155Received.selector\r\n                ) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) internal {\r\n        if (to.isContract()) {\r\n            try\r\n                IERC1155Receiver(to).onERC1155BatchReceived(\r\n                    operator,\r\n                    from,\r\n                    ids,\r\n                    amounts,\r\n                    data\r\n                )\r\n            returns (bytes4 response) {\r\n                if (\r\n                    response !=\r\n                    IERC1155Receiver(to).onERC1155BatchReceived.selector\r\n                ) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\impl\\ItemMainInterface.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\n//pragma abicoder v2;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ItemMainInterface is IItemMainInterface, DynamicMetadataCapableElement {\r\n    using ReflectionUtilities for address;\r\n\r\n    bytes32 override public constant TYPEHASH_PERMIT = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\r\n    address override public interoperableInterfaceModel;\r\n    address private _itemMainInterfaceSupportsInterfaceImplementer;\r\n\r\n    mapping(bytes32 => Header) override public collection;\r\n    mapping(uint256 => ItemData) override public item;\r\n    mapping(address => mapping(address => bool)) public override isApprovedForAll;\r\n\r\n    uint256 private _keyIndex;\r\n\r\n    mapping(uint256 => uint256[]) private _items;\r\n    uint256 private _itemsLength;\r\n    mapping(uint256 => uint256) private _itemsIndexes;\r\n\r\n    mapping(bytes32 => uint256[]) private _batchItems;\r\n    mapping(bytes32 => mapping(uint256 => uint256)) private _batchAmounts;\r\n    bytes32[] private _batchKeys;\r\n\r\n    constructor(bytes memory lazyInitData) DynamicMetadataCapableElement(lazyInitData) {\r\n    }\r\n\r\n    function _dynamicMetadataElementLazyInit(bytes memory lazyInitData) internal override returns(bytes memory) {\r\n        (interoperableInterfaceModel, _itemMainInterfaceSupportsInterfaceImplementer) = abi.decode(lazyInitData, (address, address));\r\n        return \"\";\r\n    }\r\n\r\n    function _dynamicMetadataElementSupportsInterface(bytes4 interfaceId) internal override view returns (bool) {\r\n        return IERC165(_itemMainInterfaceSupportsInterfaceImplementer).supportsInterface(interfaceId);\r\n        /*return \r\n            interfaceId == type(IERC1155).interfaceId ||\r\n            interfaceId == IItemMainInterface(address(0)).balanceOf.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).balanceOfBatch.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).setApprovalForAll.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).isApprovedForAll.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).safeTransferFrom.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).safeBatchTransferFrom.selector ||\r\n            interfaceId == 0xd9b67a26 ||//OpenSea Standard\r\n            interfaceId == type(IERC1155Views).interfaceId ||\r\n            interfaceId == IItemMainInterface(address(0)).totalSupply.selector ||\r\n            interfaceId == 0x00ad800c ||//name(uint256)\r\n            interfaceId == 0x4e41a1fb ||//symbol(uint256)\r\n            interfaceId == IItemMainInterface(address(0)).decimals.selector ||\r\n            interfaceId == 0x0e89341c ||//uri(uint256)\r\n            interfaceId == type(Item).interfaceId ||\r\n            interfaceId == 0x06fdde03 ||//name()\r\n            interfaceId == 0x95d89b41 ||//symbol()\r\n            interfaceId == 0xf5298aca ||//burn(address,uint256,uint256)\r\n            interfaceId == 0x6b20c454 ||//burnBatch(address,uint256[],uint256[])\r\n            interfaceId == 0x8a94b05f ||//burn(address,uint256,uint256,bytes)\r\n            interfaceId == 0x5473422e ||//burnBatch(address,uint256[],uint256[],bytes)\r\n            interfaceId == IItemMainInterface(address(0)).mintItems.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).setItemsCollection.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).setItemsMetadata.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).interoperableOf.selector ||\r\n            interfaceId == type(IItemMainInterface).interfaceId ||\r\n            interfaceId == IItemMainInterface(address(0)).interoperableInterfaceModel.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).setInteroperableInterfaceModel.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).collection.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).collectionUri.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).createCollection.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).setCollectionsMetadata.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).item.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).mintTransferOrBurn.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).allowance.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).approve.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).TYPEHASH_PERMIT.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).EIP712_PERMIT_DOMAINSEPARATOR_NAME_AND_VERSION.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).permit.selector ||\r\n            interfaceId == IItemMainInterface(address(0)).nonces.selector;*/\r\n    }\r\n\r\n    function name() override external pure returns(string memory) {\r\n        return \"Items\";\r\n    }\r\n\r\n    function name(uint256 itemId) override external view returns(string memory) {\r\n        return item[itemId].header.name;\r\n    }\r\n\r\n    function symbol() override external pure returns(string memory) {\r\n        return \"I\";\r\n    }\r\n\r\n    function symbol(uint256 itemId) override external view returns(string memory) {\r\n        return item[itemId].header.symbol;\r\n    }\r\n\r\n    function decimals(uint256) override external pure returns(uint256) {\r\n        return 18;\r\n    }\r\n\r\n    function collectionUri(bytes32 collectionId) override external view returns(string memory) {\r\n        return _uri(collection[collectionId].uri, abi.encode(collectionId, 0));\r\n    }\r\n\r\n    function uri(uint256 itemId) override external view returns(string memory) {\r\n        ItemData storage itemData = item[itemId];\r\n        return _uri(itemData.header.uri, abi.encode(itemData.collectionId, itemId));\r\n    }\r\n\r\n    function setCollectionsMetadata(bytes32[] calldata collectionIds, Header[] calldata values) override external returns(Header[] memory oldValues) {\r\n        oldValues = new Header[](values.length);\r\n        for(uint256 i = 0; i < values.length; i++) {\r\n            Header storage oldValue = collection[collectionIds[i]];\r\n            require((oldValues[i] = oldValue).host == msg.sender, \"Unauthorized\");\r\n            address newHost = (collection[collectionIds[i]] = _validateHeader(values[i], bytes32(0))).host;\r\n            if(newHost != oldValues[i].host) {\r\n                emit Collection(oldValues[i].host, newHost, collectionIds[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function setItemsCollection(uint256[] calldata itemIds, bytes32[] calldata collectionIds) override external returns(bytes32[] memory oldCollectionIds) {\r\n        oldCollectionIds = new bytes32[](itemIds.length);\r\n        for(uint256 i = 0; i < itemIds.length; i++) {\r\n            ItemData storage itemData = item[itemIds[i]];\r\n            require(collection[oldCollectionIds[i] = itemData.collectionId].host == msg.sender, \"Unauthorized\");\r\n            require(!_stringIsEmpty(collection[itemData.collectionId = collectionIds[i]].name), \"collection\");\r\n            emit CollectionItem(oldCollectionIds[i], collectionIds[i], itemIds[i]);\r\n        }\r\n    }\r\n\r\n    function setItemsMetadata(uint256[] calldata itemIds, Header[] calldata values) override external returns(Header[] memory oldValues) {\r\n        oldValues = new Header[](values.length);\r\n        for(uint256 i = 0; i < values.length; i++) {\r\n            ItemData storage itemData = item[itemIds[i]];\r\n            oldValues[i] = itemData.header;\r\n            require(collection[itemData.collectionId].host == msg.sender, \"Unauthorized\");\r\n            itemData.header = _validateHeader(values[i], itemData.collectionId);\r\n            if(keccak256(bytes(itemData.header.uri)) != keccak256(bytes(oldValues[i].uri))) {\r\n                emit URI(itemData.header.uri, itemIds[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function totalSupply(uint256 itemId) override external view returns(uint256) {\r\n        return item[itemId].totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account, uint256 id) override external view returns (uint256) {\r\n        return item[id].balanceOf[account];\r\n    }\r\n\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) override external view returns (uint256[] memory balances) {\r\n        balances = new uint256[](ids.length);\r\n        for(uint256 i = 0; i < balances.length; i++) {\r\n            balances[i] = item[ids[i]].balanceOf[accounts[i]];\r\n        }\r\n    }\r\n\r\n    function allowance(address owner, address spender, uint256 itemId) override external view returns (uint256) {\r\n        return isApprovedForAll[owner][spender] ? 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff : item[itemId].allowance[owner][spender];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) override external {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function interoperableOf(uint256 itemId) override external view returns(address) {\r\n        return item[itemId].collectionId == bytes32(0) ? address(0) : address(uint160(itemId));\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 itemId, uint256 amount, bytes calldata data) override external {\r\n        _mintTransferOrBurn(item[itemId], msg.sender, from, to, itemId, amount, true);\r\n        ERC1155CommonLibrary.doSafeTransferAcceptanceCheck(msg.sender, from, to, itemId, amount, data);\r\n    }\r\n\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata itemIds, uint256[] calldata amounts, bytes calldata data) override external {\r\n        _mintTransferOrBurn(msg.sender, from, to, itemIds, amounts, false, true);\r\n        ERC1155CommonLibrary.doSafeBatchTransferAcceptanceCheck(msg.sender, from, to, itemIds, amounts, data);\r\n    }\r\n\r\n    function burn(address account, uint256 itemId, uint256 amount) override external {\r\n        burn(account, itemId, amount, \"\");\r\n    }\r\n\r\n    function burnBatch(address account, uint256[] calldata itemIds, uint256[] calldata amounts) override external {\r\n        burnBatch(account, itemIds, amounts, \"\");\r\n    }\r\n\r\n    function burn(address account, uint256 itemId, uint256 amount, bytes memory) override public {\r\n        _mintTransferOrBurn(item[itemId], msg.sender, account, address(0), itemId, amount, true);\r\n    }\r\n\r\n    function burnBatch(address account, uint256[] calldata itemIds, uint256[] calldata amounts, bytes memory) override public {\r\n        _mintTransferOrBurn(msg.sender, account, address(0), itemIds, amounts, false, true);\r\n    }\r\n\r\n    function createCollection(Header calldata _collection, CreateItem[] calldata items) override external returns(bytes32 collectionId, uint256[] memory itemIds) {\r\n        Header storage storageCollection = (collection[collectionId = BehaviorUtilities.randomKey(_keyIndex++)] = _validateHeader(_collection, bytes32(0)));\r\n        require(storageCollection.host != address(0) || items.length > 0, \"Empty\");\r\n        emit Collection(address(0), storageCollection.host, collectionId);\r\n        itemIds = _createOrMintItems(collectionId, items);\r\n    }\r\n\r\n    function mintItems(CreateItem[] calldata items) override external returns(uint256[] memory) {\r\n        return _createOrMintItems(bytes32(0), items);\r\n    }\r\n\r\n    function approve(address account, address spender, uint256 amount, uint256 itemId) override external {\r\n        ItemData storage itemData = msg.sender == account ? item[itemId] : _checkItemPermissionAndRetrieveData(itemId);\r\n        require(spender != address(0), \"approve to the zero address\");\r\n        itemData.allowance[account][spender] = amount;\r\n        if(msg.sender != address(uint160(itemId))) {\r\n            IItemInteroperableInterface(address(uint160(itemId))).emitEvent(true, false, abi.encode(account, spender, amount));\r\n        }\r\n    }\r\n\r\n    function mintTransferOrBurn(bool isMulti, bytes calldata data) override external {\r\n        if(isMulti) {\r\n            _mintTransferOrBurn(data);\r\n            return;\r\n        }\r\n        (address operator, address sender, address recipient, uint256 itemId, uint256 amount) = abi.decode(data, (address, address, address, uint256, uint256));\r\n        _mintTransferOrBurn(_checkItemPermissionAndRetrieveData(itemId), operator, sender, recipient, itemId, amount, true);\r\n    }\r\n\r\n    function permit(uint256 itemId, address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) override external {\r\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\r\n        ItemData storage itemData = item[itemId];\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                itemData.domainSeparator,\r\n                keccak256(abi.encode(TYPEHASH_PERMIT, owner, spender, value, itemData.nonces[owner]++, deadline))\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNATURE');\r\n        itemData.allowance[owner][spender] = value;\r\n        if(msg.sender != address(uint160(itemId))) {\r\n            IItemInteroperableInterface(address(uint160(itemId))).emitEvent(true, false, abi.encode(owner, spender, value));\r\n        }\r\n    }\r\n\r\n    function nonces(address owner, uint256 itemId) external override view returns(uint256) {\r\n        return item[itemId].nonces[owner];\r\n    }\r\n\r\n    function EIP712_PERMIT_DOMAINSEPARATOR_NAME_AND_VERSION() public override pure returns(string memory, string memory) {\r\n        return (\"Item\", \"1\");\r\n    }\r\n\r\n    function _validateHeader(Header memory header, bytes32 collectionId) private view returns(Header memory) {\r\n        require(!_stringIsEmpty(header.name = _stringIsEmpty(header.name) && collectionId != bytes32(0) ? collection[collectionId].name : header.name), \"name\");\r\n        require(!_stringIsEmpty(header.symbol = _stringIsEmpty(header.symbol) && collectionId != bytes32(0) ? collection[collectionId].symbol : header.symbol), \"symbol\");\r\n        require(!_stringIsEmpty(header.uri = _stringIsEmpty(header.uri) && collectionId != bytes32(0) ? collection[collectionId].uri : header.uri), \"uri\");\r\n        header.host = collectionId != bytes32(0) ? address(0) : header.host;\r\n        return header;\r\n    }\r\n\r\n    function _createOrMintItems(bytes32 createdCollectionId, CreateItem[] calldata items) private returns(uint256[] memory itemIds) {\r\n        itemIds = new uint256[](items.length);\r\n        for(uint256 i = 0; i < items.length; i++) {\r\n            CreateItem memory itemToCreate = items[i];\r\n            itemIds[i] = createdCollectionId != bytes32(0) ? 0 : itemToCreate.id;\r\n            itemToCreate.collectionId = createdCollectionId != bytes32(0) ? createdCollectionId : itemToCreate.id != 0 ? item[itemToCreate.id].collectionId : itemToCreate.collectionId;\r\n            require(createdCollectionId != bytes32(0) || (itemToCreate.collectionId != bytes32(0) && msg.sender == collection[itemToCreate.collectionId].host), \"Unauthorized\");\r\n            if(itemIds[i] == 0) {\r\n                address interoperableInterfaceAddress = interoperableInterfaceModel.clone();\r\n                IItemInteroperableInterface(interoperableInterfaceAddress).init();\r\n                ItemData storage newItem = item[itemIds[i] = uint160(interoperableInterfaceAddress)];\r\n                newItem.collectionId = itemToCreate.collectionId;\r\n                newItem.header = _validateHeader(itemToCreate.header, itemToCreate.collectionId);\r\n                (string memory domainSeparatorName, string memory domainSeparatorVersion) = EIP712_PERMIT_DOMAINSEPARATOR_NAME_AND_VERSION();\r\n                newItem.domainSeparator = keccak256(\r\n                    abi.encode(\r\n                        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                        keccak256(bytes(domainSeparatorName)),\r\n                        keccak256(bytes(domainSeparatorVersion)),\r\n                        block.chainid,\r\n                        address(uint160(itemIds[i]))\r\n                    )\r\n                );\r\n                emit CollectionItem(bytes32(0), newItem.collectionId, itemIds[i]);\r\n                emit URI(newItem.header.uri, itemIds[i]);\r\n            }\r\n            _mint(itemIds[i], itemToCreate.accounts, itemToCreate.amounts);\r\n        }\r\n    }\r\n\r\n    function _mint(uint256 itemId, address[] memory accounts, uint256[] memory amounts) private {\r\n        for(uint256 i = 0; i < accounts.length; i++) {\r\n            require(accounts[i] != address(0), \"mint to the zero address\");\r\n            _mintTransferOrBurn(address(0), address(0), accounts[i], itemId, amounts[i], false);\r\n        }\r\n        _emitMultiEventsAndClear();\r\n    }\r\n\r\n    function _mintTransferOrBurn(bytes memory data) private {\r\n        bool batch;\r\n        (batch, data) = abi.decode(data, (bool, bytes));\r\n        if(batch) {\r\n            _mintTransferOrBurnBatch(data);\r\n        } else {\r\n            (address[] memory origins, address[] memory senders, address[] memory recipients, uint256[] memory itemIds, uint256[] memory amounts) = abi.decode(data, (address[], address[], address[], uint256[], uint256[]));\r\n            for(uint256 i = 0; i < itemIds.length; i++) {\r\n                _mintTransferOrBurn(origins[i], senders[i], recipients[i], itemIds[i], amounts[i], true);\r\n            }\r\n        }\r\n        _emitMultiEventsAndClear();\r\n    }\r\n\r\n    function _mintTransferOrBurnBatch(bytes memory data) private {\r\n        bytes[] memory batches = abi.decode(data, (bytes[]));\r\n        for(uint256 i = 0; i < batches.length; i++) {\r\n            (address operator, address sender, address recipient, uint256[] memory itemIds, uint256[] memory amounts) = abi.decode(batches[i], (address, address, address, uint256[], uint256[]));\r\n            _mintTransferOrBurn(operator, sender, recipient, itemIds, amounts, true, false);\r\n        }\r\n    }\r\n\r\n    function _mintTransferOrBurn(address operator, address sender, address recipient, uint256[] memory itemIds, uint256[] memory amounts, bool check, bool launchEvents) private {\r\n        for(uint256 i = 0; i < itemIds.length; i++) {\r\n            _mintTransferOrBurn(operator, sender, recipient, itemIds[i], amounts[i], check);\r\n        }\r\n        if(launchEvents) {\r\n            _emitMultiEventsAndClear();\r\n        }\r\n    }\r\n\r\n    function _mintTransferOrBurn(address operator, address sender, address recipient, uint256 itemId, uint256 amount, bool check) private {\r\n        if(amount == 0) {\r\n            return;\r\n        }\r\n        uint256 tokenIndex = _itemsIndexes[itemId];\r\n        uint256[] storage items = _items[tokenIndex];\r\n        if(items.length == 0 || items[0] != itemId) {\r\n            items = _items[tokenIndex = _itemsIndexes[itemId] = _itemsLength++];\r\n            items.push(itemId);\r\n        }\r\n        items.push(uint160(sender));\r\n        items.push(uint160(recipient));\r\n        items.push(amount);\r\n\r\n        bytes32 key = keccak256(abi.encodePacked(operator, sender, recipient));\r\n        items = _batchItems[key];\r\n        if(items.length == 0) {\r\n            _batchKeys.push(key);\r\n            items.push(uint160(operator));\r\n            items.push(uint160(sender));\r\n            items.push(uint160(recipient));\r\n        }\r\n        if(_batchAmounts[key][itemId] == 0) {\r\n            items.push(itemId);\r\n        }\r\n        _batchAmounts[key][itemId] += amount;\r\n        _mintTransferOrBurn(check ? _checkItemPermissionAndRetrieveData(itemId) : item[itemId], operator, sender, recipient, itemId, amount, false);\r\n    }\r\n\r\n    function _mintTransferOrBurn(ItemData storage itemData, address operator, address sender, address recipient, uint256 itemId, uint256 amount, bool launchEvent) private {\r\n        if(sender != address(0)) {\r\n            if(operator != sender) {\r\n                require(itemData.allowance[sender][operator] >= amount || isApprovedForAll[sender][operator], \"amount exceeds allowance\");\r\n                if(itemData.allowance[sender][operator] >= amount) {\r\n                    itemData.allowance[sender][operator] -= amount;\r\n                } else {\r\n                    delete itemData.allowance[sender][operator];\r\n                }\r\n            }\r\n            require(itemData.balanceOf[sender] >= amount, \"amount exceeds balance\");\r\n            itemData.balanceOf[sender] -= amount;\r\n        } else {\r\n            itemData.totalSupply += amount;\r\n        }\r\n        if(recipient != address(0)) {\r\n            itemData.balanceOf[recipient] += amount;\r\n        } else {\r\n            itemData.totalSupply -= amount;\r\n        }\r\n        if(launchEvent) {\r\n            emit TransferSingle(operator, sender, recipient, itemId, amount);\r\n            if(itemId != uint160(msg.sender)) {\r\n                IItemInteroperableInterface(address(uint160(itemId))).emitEvent(false, false, abi.encode(sender, recipient, amount));\r\n            }\r\n        }\r\n    }\r\n\r\n    function _checkItemPermissionAndRetrieveData(uint256 itemId) private view returns (ItemData storage itemData) {\r\n        require(collection[(itemData = item[itemId]).collectionId].host == msg.sender || uint160(msg.sender) == itemId, \"Unauthorized\");\r\n    }\r\n\r\n    function _stringIsEmpty(string memory test) private pure returns(bool) {\r\n        return keccak256(bytes(test)) == keccak256(\"\");\r\n    }\r\n\r\n    function _emitMultiEventsAndClear() private {\r\n        for(uint256 i = 0; i < _itemsLength; i++) {\r\n            uint256[] storage items = _items[i];\r\n            uint256 itemId = items[0];\r\n            delete items[0];\r\n            uint256 length = (items.length - 1) / 3;\r\n            address[] memory senders = new address[](length);\r\n            address[] memory receivers = new address[](length);\r\n            uint256[] memory amounts = new uint256[](length);\r\n            uint256 inc = 0;\r\n            for(uint256 z = 1; z < items.length; z += 3) {\r\n                senders[inc] = address(uint160(items[z]));\r\n                delete items[z];\r\n                receivers[inc] = address(uint160(items[z + 1]));\r\n                delete items[z + 1];\r\n                amounts[inc++] = items[z + 2];\r\n                delete items[z + 2];\r\n            }\r\n            IItemInteroperableInterface(address(uint160(itemId))).emitEvent(false, true, abi.encode(senders, receivers, amounts));\r\n            delete _itemsIndexes[itemId];\r\n            delete _items[i];\r\n        }\r\n        delete _itemsLength;\r\n        _emitMultiEventsAndClearBatch();\r\n    }\r\n\r\n    function _emitMultiEventsAndClearBatch() private {\r\n        for(uint256 i = 0; i < _batchKeys.length; i++) {\r\n            bytes32 key = _batchKeys[i];\r\n            uint256[] storage items = _batchItems[key];\r\n            uint256 length = items.length - 3;\r\n            address operator = address(uint160(items[0]));\r\n            delete items[0];\r\n            address sender = address(uint160(items[1]));\r\n            delete items[1];\r\n            address receiver = address(uint160(items[2]));\r\n            delete items[2];\r\n            uint256 inc = 0;\r\n            uint256[] memory itemIds = new uint256[](length);\r\n            uint256[] memory amounts = new uint256[](length);\r\n            for(uint256 z = 3; z < items.length; z++) {\r\n                amounts[inc] = _batchAmounts[key][itemIds[inc] = items[z]];\r\n                delete items[z];\r\n                delete _batchAmounts[key][inc++];\r\n            }\r\n            emit TransferBatch(operator, sender, receiver, itemIds, amounts);\r\n            delete _batchItems[key];\r\n        }\r\n        delete _batchKeys;\r\n    }\r\n\r\n    function _subjectIsAuthorizedFor(address, address location, bytes4 selector, bytes calldata, uint256) internal virtual override view returns(bool, bool) {\r\n        if(location == address(this) && selector == this.setDynamicUriResolver.selector) {\r\n            return (true, false);\r\n        }\r\n        return (false, false);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"lazyInitData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"collectionId\",\"type\":\"bytes32\"}],\"name\":\"Collection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"fromCollectionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"toCollectionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"CollectionItem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Host\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EIP712_PERMIT_DOMAINSEPARATOR_NAME_AND_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TYPEHASH_PERMIT\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"burnBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"burnBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"collection\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"collectionId\",\"type\":\"bytes32\"}],\"name\":\"collectionUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"internalType\":\"struct Header\",\"name\":\"_collection\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"internalType\":\"struct Header\",\"name\":\"header\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"collectionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct CreateItem[]\",\"name\":\"items\",\"type\":\"tuple[]\"}],\"name\":\"createCollection\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"collectionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dynamicUriResolver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"host\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interoperableInterfaceModel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"interoperableOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"item\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"collectionId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"internalType\":\"struct Header\",\"name\":\"header\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"lazyInitData\",\"type\":\"bytes\"}],\"name\":\"lazyInit\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"lazyInitResponse\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"internalType\":\"struct Header\",\"name\":\"header\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"collectionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct CreateItem[]\",\"name\":\"items\",\"type\":\"tuple[]\"}],\"name\":\"mintItems\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isMulti\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"mintTransferOrBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plainUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"collectionIds\",\"type\":\"bytes32[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"internalType\":\"struct Header[]\",\"name\":\"values\",\"type\":\"tuple[]\"}],\"name\":\"setCollectionsMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"internalType\":\"struct Header[]\",\"name\":\"oldValues\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setDynamicUriResolver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setHost\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"collectionIds\",\"type\":\"bytes32[]\"}],\"name\":\"setItemsCollection\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"oldCollectionIds\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"internalType\":\"struct Header[]\",\"name\":\"values\",\"type\":\"tuple[]\"}],\"name\":\"setItemsMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"internalType\":\"struct Header[]\",\"name\":\"oldValues\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"setUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"oldValue\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"location\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"subjectIsAuthorizedFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ItemMainInterface","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000180000000000000000000000000c5c85480ac2e36a680bd0d53084dbad0cee9c29a0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000600000000000000000000000003ff777884412c7ce8a1da679b4b0cd54f720ab2e00000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000003a697066733a2f2f697066732f516d64375736396d417779794d755634584333595167534a366b5156436e537846714b4b46655258335341736a4a000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000055bbab8bbefc49996507b84cccb92c74a0c2be3f000000000000000000000000e4cd064c93fe94c21884670b3708a7a57dd2afe3","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fad2fb7153eda02e6c43744615766b767dc0efc5caebd9d4d300000cb28e3aeb"}]}