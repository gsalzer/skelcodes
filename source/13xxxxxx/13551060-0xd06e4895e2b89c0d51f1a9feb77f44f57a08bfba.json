{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.8.6;\r\n\r\ninterface IERC721 {\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IERC721Burnable is IERC721 {\r\n    function burn(uint256 tokenId) external;\r\n}\r\n\r\ncontract Reentrancy {\r\n    // ============ Constants ============\r\n\r\n    uint256 internal constant REENTRANCY_NOT_ENTERED = 1;\r\n    uint256 internal constant REENTRANCY_ENTERED = 2;\r\n\r\n    // ============ Mutable Storage ============\r\n\r\n    uint256 internal reentrancyStatus;\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(reentrancyStatus != REENTRANCY_ENTERED, \"Reentrant call\");\r\n        // Any calls to nonReentrant after this point will fail\r\n        reentrancyStatus = REENTRANCY_ENTERED;\r\n        _;\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip2200)\r\n        reentrancyStatus = REENTRANCY_NOT_ENTERED;\r\n    }\r\n}\r\n\r\ninterface ITreasuryConfig {\r\n    function treasury() external returns (address payable);\r\n\r\n    function distributionModel() external returns (address);\r\n}\r\n\r\ninterface IMirrorTreasury {\r\n    function transferFunds(address payable to, uint256 value) external;\r\n\r\n    function transferERC20(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) external;\r\n\r\n    function contributeWithTributary(address tributary) external payable;\r\n\r\n    function contribute(uint256 amount) external payable;\r\n}\r\n\r\n/**\r\n * @title BurnERC721ToRedeemERC721\r\n * @author MirrorXYZ\r\n * Allows burning an \"option\" token in exchange for redeeming another transferrable\r\n * token.\r\n */\r\ncontract BurnERC721ToRedeemERC721 is Reentrancy {\r\n    // ============ Immutable Storage ============\r\n\r\n    // The recipient of the sales in ETH.\r\n    address public immutable fundingRecipient;\r\n    // The ERC721 token that is being burned by the redeemer.\r\n    address public immutable burnToken;\r\n    // The owner of the ERC721 token that is being redeemed.\r\n    address public immutable nftSender;\r\n    // The price of the token being redeemed.\r\n    uint256 public immutable price;\r\n    // The address of the Mirror treasury config, for getting the treasury address.\r\n    address public immutable treasuryConfig;\r\n    // The address of the redeemable token.\r\n    address public immutable nft;\r\n    // The token ID of the first token that's being redeemed.\r\n    uint256 public immutable startingId;\r\n    // The total number of tokens that are being redeemed.\r\n    uint256 public immutable totalTokens;\r\n    // The timestamp past which tokens cannot be redeemed.\r\n    uint256 public immutable endTime;\r\n\r\n    // ============ Mutable Storage ============\r\n\r\n    uint256 public tokenCounter;\r\n\r\n    // ============ Events ============\r\n\r\n    event Redeem(address indexed redeemer, uint256 tokenCounter);\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor(\r\n        address burnToken_,\r\n        address nftSender_,\r\n        address nft_,\r\n        uint256 price_,\r\n        address fundingRecipient_,\r\n        address treasuryConfig_,\r\n        uint256 startingId_,\r\n        uint256 totalTokens_,\r\n        uint256 redemptionDurationSeconds\r\n    ) {\r\n        burnToken = burnToken_;\r\n        price = price_;\r\n        treasuryConfig = treasuryConfig_;\r\n        fundingRecipient = fundingRecipient_;\r\n        nftSender = nftSender_;\r\n        nft = nft_;\r\n        startingId = startingId_;\r\n        totalTokens = totalTokens_ + startingId_;\r\n\r\n        endTime = block.timestamp + redemptionDurationSeconds;\r\n    }\r\n\r\n    // ============ Redeem Method ============\r\n\r\n    /**\r\n     * Allows the sender to burn some quantity of options in order\r\n     * to redeem the same quantity of tokens, provided enough funds have\r\n     * been transferred.\r\n     */\r\n    function redeem(uint256 burnableId) public payable nonReentrant {\r\n        require(block.timestamp <= endTime, \"Redemption period over\");\r\n        // Require that ETH has been sent.\r\n        require(msg.value >= price, \"Insufficient funds sent\");\r\n        // Burn the sender's ERC721 token.\r\n        IERC721Burnable(burnToken).burn(burnableId);\r\n        // Set the counter\r\n        uint256 counter_ = startingId + tokenCounter;\r\n        // Transfer the tokens to the user after burn.\r\n        IERC721(nft).transferFrom(nftSender, msg.sender, counter_);\r\n        // Increment the token counter.\r\n        tokenCounter += 1;\r\n        // Check that we haven't gone over the number of total tokens.\r\n        require(tokenCounter <= totalTokens, \"Token counter is out of range\");\r\n\r\n        emit Redeem(msg.sender, tokenCounter);\r\n    }\r\n\r\n    // ============ Withdraw Methods ============\r\n\r\n    /**\r\n     * @notice Withdraws funds on the current proxy to the operator,\r\n     * and transfer fee to treasury.\r\n     */\r\n    function withdraw() external nonReentrant {\r\n        uint256 feePercentage = 250;\r\n\r\n        uint256 fee = feeAmount(address(this).balance, feePercentage);\r\n\r\n        IMirrorTreasury(ITreasuryConfig(treasuryConfig).treasury()).contribute{\r\n            value: fee\r\n        }(fee);\r\n\r\n        // transfer the remaining available balance to the operator.\r\n        _send(payable(fundingRecipient), address(this).balance);\r\n    }\r\n\r\n    function feeAmount(uint256 amount, uint256 fee)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (amount * fee) / 10000;\r\n    }\r\n\r\n    // ============ Internal Methods ============\r\n\r\n    function _send(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"recipient reverted\");\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"burnToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftSender_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nft_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"fundingRecipient_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasuryConfig_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startingId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redemptionDurationSeconds\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenCounter\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"burnToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"feeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundingRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"burnableId\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BurnERC721ToRedeemERC721","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"000000000000000000000000379b1585592d513f7435060a0a5290cfc7ff62b7000000000000000000000000c11e96adf387f16a5254e4eeeab1894abac4f6ed000000000000000000000000802c30ebd6806fce10176727a9a1874d0dc08cf700000000000000000000000000000000000000000000000006f05b59d3b20000000000000000000000000000c11e96adf387f16a5254e4eeeab1894abac4f6ed00000000000000000000000021a93be569666527dae0fdbfbe7715299dec12020000000000000000000000000000000000000000000000000000000000000032000000000000000000000000000000000000000000000000000000000000001e00000000000000000000000000000000000000000000000000000000000a8c00","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8e152042487999981fe20d38ef52fc262254fa5084ee87153a55493a292ccf4b"}]}