{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.15\r\n\"\"\"\r\n@title Voting Escrow\r\n@author Curve Finance\r\n@license MIT\r\n@notice Votes have a weight depending on time, so that users are\r\n        committed to the future of (whatever they are voting for)\r\n@dev Vote weight decays linearly over time. Lock time cannot be\r\n     more than `MAXTIME` (4 years).\r\n\"\"\"\r\n\r\n# Voting escrow to have time-weighted votes\r\n# Votes have a weight depending on time, so that users are committed\r\n# to the future of (whatever they are voting for).\r\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\r\n# w ^\r\n# 1 +        /\r\n#   |      /\r\n#   |    /\r\n#   |  /\r\n#   |/\r\n# 0 +--------+------> time\r\n#       maxtime (4 years?)\r\n\r\nstruct Point:\r\n    bias: int128\r\n    slope: int128  # - dweight / dt\r\n    ts: uint256\r\n    blk: uint256  # block\r\n# We cannot really do block numbers per se b/c slope is per time, not per block\r\n# and per block could be fairly bad b/c Ethereum changes blocktimes.\r\n# What we can do is to extrapolate ***At functions\r\n\r\nstruct LockedBalance:\r\n    amount: int128\r\n    end: uint256\r\n\r\n\r\ninterface ERC20:\r\n    def decimals() -> uint256: view\r\n    def name() -> String[64]: view\r\n    def symbol() -> String[32]: view\r\n    def transfer(to: address, amount: uint256) -> bool: nonpayable\r\n    def transferFrom(spender: address, to: address, amount: uint256) -> bool: nonpayable\r\n\r\n\r\n# Interface for checking whether address belongs to a whitelisted\r\n# type of a smart wallet.\r\n# When new types are added - the whole contract is changed\r\n# The check() method is modifying to be able to use caching\r\n# for individual wallet addresses\r\ninterface SmartWalletChecker:\r\n    def check(addr: address) -> bool: nonpayable\r\n\r\nDEPOSIT_FOR_TYPE: constant(int128) = 0\r\nCREATE_LOCK_TYPE: constant(int128) = 1\r\nINCREASE_LOCK_AMOUNT: constant(int128) = 2\r\nINCREASE_UNLOCK_TIME: constant(int128) = 3\r\n\r\n\r\nevent CommitOwnership:\r\n    admin: address\r\n\r\nevent ApplyOwnership:\r\n    admin: address\r\n\r\nevent Deposit:\r\n    provider: indexed(address)\r\n    value: uint256\r\n    locktime: indexed(uint256)\r\n    type: int128\r\n    ts: uint256\r\n\r\nevent Withdraw:\r\n    provider: indexed(address)\r\n    value: uint256\r\n    ts: uint256\r\n\r\nevent Supply:\r\n    prevSupply: uint256\r\n    supply: uint256\r\n\r\nevent NewDelegation:\r\n    delegator: indexed(address)\r\n    gauge: indexed(address)\r\n    receiver: indexed(address)\r\n    pct: uint256\r\n    cancel_time: uint256\r\n    expire_time: uint256\r\n\r\nevent CancelledDelegation:\r\n    delegator: indexed(address)\r\n    gauge: indexed(address)\r\n    receiver: indexed(address)\r\n    cancelled_by: address\r\n\r\nstruct ReceivedBoost:\r\n    length: uint256\r\n    data: uint256[10]\r\n\r\n\r\nWEEK: constant(uint256) = 7 * 86400  # all future times are rounded by week\r\nMAXTIME: constant(uint256) = 4 * 365 * 86400  # 4 years\r\nMULTIPLIER: constant(uint256) = 10 ** 18\r\n\r\ntoken: public(address)\r\nsupply: public(uint256)\r\n\r\nlocked: public(HashMap[address, LockedBalance])\r\n\r\nepoch: public(uint256)\r\npoint_history: public(Point[100000000000000000000000000000])  # epoch -> unsigned point\r\nuser_point_history: public(HashMap[address, Point[1000000000]])  # user -> Point[user_epoch]\r\nuser_point_epoch: public(HashMap[address, uint256])\r\nslope_changes: public(HashMap[uint256, int128])  # time -> signed slope change\r\n\r\n# Aragon's view methods for compatibility\r\ncontroller: public(address)\r\ntransfersEnabled: public(bool)\r\n\r\nname: public(String[64])\r\nsymbol: public(String[32])\r\nversion: public(String[32])\r\ndecimals: public(uint256)\r\n\r\n# Checker for whitelisted (smart contract) wallets which are allowed to deposit\r\n# The goal is to prevent tokenizing the escrow\r\nfuture_smart_wallet_checker: public(address)\r\nsmart_wallet_checker: public(address)\r\n\r\nadmin: public(address)  # Can and will be a smart contract\r\nfuture_admin: public(address)\r\n\r\n# user -> number of active boost delegations\r\ndelegation_count: public(HashMap[address, uint256])\r\n\r\n# user -> gauge -> data on boosts delegated to user\r\n# tightly packed as [address][uint16 pct][uint40 cancel time][uint40 expire time]\r\ndelegation_data: HashMap[address, HashMap[address, ReceivedBoost]]\r\n\r\n# user -> gauge -> data about delegation user has made for this gauge\r\ndelegated_to: HashMap[address, HashMap[address, uint256]]\r\n\r\noperator_of: public(HashMap[address, address])\r\n\r\nMIN_VE: constant(uint256) = 2500 * 10**18\r\n\r\n\r\n@external\r\ndef __init__(token_addr: address, _name: String[64], _symbol: String[32], _version: String[32]):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param token_addr `ERC20CRV` token address\r\n    @param _name Token name\r\n    @param _symbol Token symbol\r\n    @param _version Contract version - required for Aragon compatibility\r\n    \"\"\"\r\n    self.admin = msg.sender\r\n    self.token = token_addr\r\n    self.point_history[0].blk = block.number\r\n    self.point_history[0].ts = block.timestamp\r\n    self.controller = msg.sender\r\n    self.transfersEnabled = True\r\n\r\n    _decimals: uint256 = ERC20(token_addr).decimals()\r\n    assert _decimals <= 255\r\n    self.decimals = _decimals\r\n\r\n    self.name = _name\r\n    self.symbol = _symbol\r\n    self.version = _version\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(addr: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of VotingEscrow contract to `addr`\r\n    @param addr Address to have ownership transferred to\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    self.future_admin = addr\r\n    log CommitOwnership(addr)\r\n\r\n\r\n@external\r\ndef apply_transfer_ownership():\r\n    \"\"\"\r\n    @notice Apply ownership transfer\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    _admin: address = self.future_admin\r\n    assert _admin != ZERO_ADDRESS  # dev: admin not set\r\n    self.admin = _admin\r\n    log ApplyOwnership(_admin)\r\n\r\n\r\n@external\r\ndef commit_smart_wallet_checker(addr: address):\r\n    \"\"\"\r\n    @notice Set an external contract to check for approved smart contract wallets\r\n    @param addr Address of Smart contract checker\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n    self.future_smart_wallet_checker = addr\r\n\r\n\r\n@external\r\ndef apply_smart_wallet_checker():\r\n    \"\"\"\r\n    @notice Apply setting external contract to check approved smart contract wallets\r\n    \"\"\"\r\n    assert msg.sender == self.admin\r\n    self.smart_wallet_checker = self.future_smart_wallet_checker\r\n\r\n\r\n@internal\r\ndef assert_not_contract(addr: address):\r\n    \"\"\"\r\n    @notice Check if the call is from a whitelisted smart contract, revert if not\r\n    @param addr Address to be checked\r\n    \"\"\"\r\n    if addr != tx.origin:\r\n        checker: address = self.smart_wallet_checker\r\n        if checker != ZERO_ADDRESS:\r\n            if SmartWalletChecker(checker).check(addr):\r\n                return\r\n        raise \"Smart contract depositors not allowed\"\r\n\r\n\r\n@external\r\n@view\r\ndef get_last_user_slope(addr: address) -> int128:\r\n    \"\"\"\r\n    @notice Get the most recently recorded rate of voting power decrease for `addr`\r\n    @param addr Address of the user wallet\r\n    @return Value of the slope\r\n    \"\"\"\r\n    uepoch: uint256 = self.user_point_epoch[addr]\r\n    return self.user_point_history[addr][uepoch].slope\r\n\r\n\r\n@external\r\n@view\r\ndef user_point_history__ts(_addr: address, _idx: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Get the timestamp for checkpoint `_idx` for `_addr`\r\n    @param _addr User wallet address\r\n    @param _idx User epoch number\r\n    @return Epoch time of the checkpoint\r\n    \"\"\"\r\n    return self.user_point_history[_addr][_idx].ts\r\n\r\n\r\n@external\r\n@view\r\ndef locked__end(_addr: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp when `_addr`'s lock finishes\r\n    @param _addr User wallet\r\n    @return Epoch time of the lock end\r\n    \"\"\"\r\n    return self.locked[_addr].end\r\n\r\n\r\n@internal\r\ndef _checkpoint(addr: address, old_locked: LockedBalance, new_locked: LockedBalance):\r\n    \"\"\"\r\n    @notice Record global and per-user data to checkpoint\r\n    @param addr User's wallet address. No user checkpoint if 0x0\r\n    @param old_locked Pevious locked amount / end lock time for the user\r\n    @param new_locked New locked amount / end lock time for the user\r\n    \"\"\"\r\n    u_old: Point = empty(Point)\r\n    u_new: Point = empty(Point)\r\n    old_dslope: int128 = 0\r\n    new_dslope: int128 = 0\r\n    _epoch: uint256 = self.epoch\r\n\r\n    if addr != ZERO_ADDRESS:\r\n        # Calculate slopes and biases\r\n        # Kept at zero when they have to\r\n        if old_locked.end > block.timestamp and old_locked.amount > 0:\r\n            u_old.slope = old_locked.amount / MAXTIME\r\n            u_old.bias = u_old.slope * convert(old_locked.end - block.timestamp, int128)\r\n        if new_locked.end > block.timestamp and new_locked.amount > 0:\r\n            u_new.slope = new_locked.amount / MAXTIME\r\n            u_new.bias = u_new.slope * convert(new_locked.end - block.timestamp, int128)\r\n\r\n        # Read values of scheduled changes in the slope\r\n        # old_locked.end can be in the past and in the future\r\n        # new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\r\n        old_dslope = self.slope_changes[old_locked.end]\r\n        if new_locked.end != 0:\r\n            if new_locked.end == old_locked.end:\r\n                new_dslope = old_dslope\r\n            else:\r\n                new_dslope = self.slope_changes[new_locked.end]\r\n\r\n    last_point: Point = Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number})\r\n    if _epoch > 0:\r\n        last_point = self.point_history[_epoch]\r\n    last_checkpoint: uint256 = last_point.ts\r\n    # initial_last_point is used for extrapolation to calculate block number\r\n    # (approximately, for *At methods) and save them\r\n    # as we cannot figure that out exactly from inside the contract\r\n    initial_last_point: Point = last_point\r\n    block_slope: uint256 = 0  # dblock/dt\r\n    if block.timestamp > last_point.ts:\r\n        block_slope = MULTIPLIER * (block.number - last_point.blk) / (block.timestamp - last_point.ts)\r\n    # If last point is already recorded in this block, slope=0\r\n    # But that's ok b/c we know the block in such case\r\n\r\n    # Go over weeks to fill history and calculate what the current point is\r\n    t_i: uint256 = (last_checkpoint / WEEK) * WEEK\r\n    for i in range(255):\r\n        # Hopefully it won't happen that this won't get used in 5 years!\r\n        # If it does, users will be able to withdraw but vote weight will be broken\r\n        t_i += WEEK\r\n        d_slope: int128 = 0\r\n        if t_i > block.timestamp:\r\n            t_i = block.timestamp\r\n        else:\r\n            d_slope = self.slope_changes[t_i]\r\n        last_point.bias -= last_point.slope * convert(t_i - last_checkpoint, int128)\r\n        last_point.slope += d_slope\r\n        if last_point.bias < 0:  # This can happen\r\n            last_point.bias = 0\r\n        if last_point.slope < 0:  # This cannot happen - just in case\r\n            last_point.slope = 0\r\n        last_checkpoint = t_i\r\n        last_point.ts = t_i\r\n        last_point.blk = initial_last_point.blk + block_slope * (t_i - initial_last_point.ts) / MULTIPLIER\r\n        _epoch += 1\r\n        if t_i == block.timestamp:\r\n            last_point.blk = block.number\r\n            break\r\n        else:\r\n            self.point_history[_epoch] = last_point\r\n\r\n    self.epoch = _epoch\r\n    # Now point_history is filled until t=now\r\n\r\n    if addr != ZERO_ADDRESS:\r\n        # If last point was in this block, the slope change has been applied already\r\n        # But in such case we have 0 slope(s)\r\n        last_point.slope += (u_new.slope - u_old.slope)\r\n        last_point.bias += (u_new.bias - u_old.bias)\r\n        if last_point.slope < 0:\r\n            last_point.slope = 0\r\n        if last_point.bias < 0:\r\n            last_point.bias = 0\r\n\r\n    # Record the changed point into history\r\n    self.point_history[_epoch] = last_point\r\n\r\n    if addr != ZERO_ADDRESS:\r\n        # Schedule the slope changes (slope is going down)\r\n        # We subtract new_user_slope from [new_locked.end]\r\n        # and add old_user_slope to [old_locked.end]\r\n        if old_locked.end > block.timestamp:\r\n            # old_dslope was <something> - u_old.slope, so we cancel that\r\n            old_dslope += u_old.slope\r\n            if new_locked.end == old_locked.end:\r\n                old_dslope -= u_new.slope  # It was a new deposit, not extension\r\n            self.slope_changes[old_locked.end] = old_dslope\r\n\r\n        if new_locked.end > block.timestamp:\r\n            if new_locked.end > old_locked.end:\r\n                new_dslope -= u_new.slope  # old slope disappeared at this point\r\n                self.slope_changes[new_locked.end] = new_dslope\r\n            # else: we recorded it already in old_dslope\r\n\r\n        # Now handle user history\r\n        user_epoch: uint256 = self.user_point_epoch[addr] + 1\r\n\r\n        self.user_point_epoch[addr] = user_epoch\r\n        u_new.ts = block.timestamp\r\n        u_new.blk = block.number\r\n        self.user_point_history[addr][user_epoch] = u_new\r\n\r\n\r\n@internal\r\ndef _deposit_for(_from: address, _addr: address, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128):\r\n    \"\"\"\r\n    @notice Deposit and lock tokens for a user\r\n    @param _addr User's wallet address\r\n    @param _value Amount to deposit\r\n    @param unlock_time New time when to unlock the tokens, or 0 if unchanged\r\n    @param locked_balance Previous locked amount / timestamp\r\n    \"\"\"\r\n    _locked: LockedBalance = locked_balance\r\n    supply_before: uint256 = self.supply\r\n\r\n    self.supply = supply_before + _value\r\n    old_locked: LockedBalance = _locked\r\n    # Adding to existing lock, or if a lock is expired - creating a new one\r\n    _locked.amount += convert(_value, int128)\r\n    if unlock_time != 0:\r\n        _locked.end = unlock_time\r\n    self.locked[_addr] = _locked\r\n\r\n    # Possibilities:\r\n    # Both old_locked.end could be current or expired (>/< block.timestamp)\r\n    # value == 0 (extend lock) or value > 0 (add to lock or extend lock)\r\n    # _locked.end > block.timestamp (always)\r\n    self._checkpoint(_addr, old_locked, _locked)\r\n\r\n    if _value != 0:\r\n        assert ERC20(self.token).transferFrom(_from, self, _value)\r\n\r\n    log Deposit(_addr, _value, _locked.end, type, block.timestamp)\r\n    log Supply(supply_before, supply_before + _value)\r\n\r\n\r\n@external\r\ndef checkpoint():\r\n    \"\"\"\r\n    @notice Record global data to checkpoint\r\n    \"\"\"\r\n    self._checkpoint(ZERO_ADDRESS, empty(LockedBalance), empty(LockedBalance))\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef deposit_for(_addr: address, _value: uint256):\r\n    \"\"\"\r\n    @notice Deposit `_value` tokens for `_addr` and add to the lock\r\n    @dev Anyone (even a smart contract) can deposit for someone else, but\r\n         cannot extend their locktime and deposit for a brand new user\r\n    @param _addr User's wallet address\r\n    @param _value Amount to add to user's lock\r\n    \"\"\"\r\n    _locked: LockedBalance = self.locked[_addr]\r\n\r\n    assert _value > 0  # dev: need non-zero value\r\n    assert _locked.amount > 0, \"No existing lock found\"\r\n    assert _locked.end > block.timestamp, \"Cannot add to expired lock. Withdraw\"\r\n\r\n    self._deposit_for(msg.sender, _addr, _value, 0, self.locked[_addr], DEPOSIT_FOR_TYPE)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef create_lock(_value: uint256, _unlock_time: uint256):\r\n    \"\"\"\r\n    @notice Deposit `_value` tokens for `msg.sender` and lock until `_unlock_time`\r\n    @param _value Amount to deposit\r\n    @param _unlock_time Epoch time when tokens unlock, rounded down to whole weeks\r\n    \"\"\"\r\n    self.assert_not_contract(msg.sender)\r\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\r\n    _locked: LockedBalance = self.locked[msg.sender]\r\n\r\n    assert _value > 0  # dev: need non-zero value\r\n    assert _locked.amount == 0, \"Withdraw old tokens first\"\r\n    assert unlock_time > block.timestamp, \"Can only lock until time in the future\"\r\n    assert unlock_time <= block.timestamp + MAXTIME, \"Voting lock can be 4 years max\"\r\n\r\n    self._deposit_for(msg.sender, msg.sender, _value, unlock_time, _locked, CREATE_LOCK_TYPE)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef increase_amount(_value: uint256):\r\n    \"\"\"\r\n    @notice Deposit `_value` additional tokens for `msg.sender`\r\n            without modifying the unlock time\r\n    @param _value Amount of tokens to deposit and add to the lock\r\n    \"\"\"\r\n    self.assert_not_contract(msg.sender)\r\n    _locked: LockedBalance = self.locked[msg.sender]\r\n\r\n    assert _value > 0  # dev: need non-zero value\r\n    assert _locked.amount > 0, \"No existing lock found\"\r\n    assert _locked.end > block.timestamp, \"Cannot add to expired lock. Withdraw\"\r\n\r\n    self._deposit_for(msg.sender, msg.sender, _value, 0, _locked, INCREASE_LOCK_AMOUNT)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef increase_unlock_time(_unlock_time: uint256):\r\n    \"\"\"\r\n    @notice Extend the unlock time for `msg.sender` to `_unlock_time`\r\n    @param _unlock_time New epoch time for unlocking\r\n    \"\"\"\r\n    self.assert_not_contract(msg.sender)\r\n    _locked: LockedBalance = self.locked[msg.sender]\r\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\r\n\r\n    assert _locked.end > block.timestamp, \"Lock expired\"\r\n    assert _locked.amount > 0, \"Nothing is locked\"\r\n    assert unlock_time > _locked.end, \"Can only increase lock duration\"\r\n    assert unlock_time <= block.timestamp + MAXTIME, \"Voting lock can be 4 years max\"\r\n\r\n    self._deposit_for(msg.sender, msg.sender, 0, unlock_time, _locked, INCREASE_UNLOCK_TIME)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef withdraw():\r\n    \"\"\"\r\n    @notice Withdraw all tokens for `msg.sender`\r\n    @dev Only possible if the lock has expired\r\n    \"\"\"\r\n    _locked: LockedBalance = self.locked[msg.sender]\r\n    assert block.timestamp >= _locked.end, \"The lock didn't expire\"\r\n    value: uint256 = convert(_locked.amount, uint256)\r\n\r\n    old_locked: LockedBalance = _locked\r\n    _locked.end = 0\r\n    _locked.amount = 0\r\n    self.locked[msg.sender] = _locked\r\n    supply_before: uint256 = self.supply\r\n    self.supply = supply_before - value\r\n\r\n    # old_locked can have either expired <= timestamp or zero end\r\n    # _locked has only 0 end\r\n    # Both can have >= 0 amount\r\n    self._checkpoint(msg.sender, old_locked, _locked)\r\n\r\n    assert ERC20(self.token).transfer(msg.sender, value)\r\n\r\n    log Withdraw(msg.sender, value, block.timestamp)\r\n    log Supply(supply_before, supply_before - value)\r\n\r\n\r\n# The following ERC20/minime-compatible methods are not real balanceOf and supply!\r\n# They measure the weights for the purpose of voting, so they don't represent\r\n# real coins.\r\n\r\n@internal\r\n@view\r\ndef find_block_epoch(_block: uint256, max_epoch: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Binary search to estimate timestamp for block number\r\n    @param _block Block to find\r\n    @param max_epoch Don't go beyond this epoch\r\n    @return Approximate timestamp for block\r\n    \"\"\"\r\n    # Binary search\r\n    _min: uint256 = 0\r\n    _max: uint256 = max_epoch\r\n    for i in range(128):  # Will be always enough for 128-bit numbers\r\n        if _min >= _max:\r\n            break\r\n        _mid: uint256 = (_min + _max + 1) / 2\r\n        if self.point_history[_mid].blk <= _block:\r\n            _min = _mid\r\n        else:\r\n            _max = _mid - 1\r\n    return _min\r\n\r\n@internal\r\n@view\r\ndef _balanceOf(addr: address, _t: uint256 = block.timestamp) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current voting power for `msg.sender`\r\n    @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\r\n    @param addr User wallet address\r\n    @param _t Epoch time to return voting power at\r\n    @return User voting power\r\n    \"\"\"\r\n    _epoch: uint256 = self.user_point_epoch[addr]\r\n    if _epoch == 0:\r\n        return 0\r\n    else:\r\n        last_point: Point = self.user_point_history[addr][_epoch]\r\n        last_point.bias -= last_point.slope * convert(_t - last_point.ts, int128)\r\n        if last_point.bias < 0:\r\n            last_point.bias = 0\r\n        return convert(last_point.bias, uint256)\r\n\r\n@external\r\n@view\r\ndef balanceOf(addr: address, _t: uint256 = block.timestamp) -> uint256:\r\n    \"\"\"\r\n    @notice Get the current voting power for `msg.sender`\r\n    @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\r\n    @param addr User wallet address\r\n    @param _t Epoch time to return voting power at\r\n    @return User voting power\r\n    \"\"\"\r\n    return self._balanceOf(addr, _t)\r\n\r\n@external\r\n@view\r\ndef balanceOfAt(addr: address, _block: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Measure voting power of `addr` at block height `_block`\r\n    @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\r\n    @param addr User's wallet address\r\n    @param _block Block to calculate the voting power at\r\n    @return Voting power\r\n    \"\"\"\r\n    # Copying and pasting totalSupply code because Vyper cannot pass by\r\n    # reference yet\r\n    assert _block <= block.number\r\n\r\n    # Binary search\r\n    _min: uint256 = 0\r\n    _max: uint256 = self.user_point_epoch[addr]\r\n    for i in range(128):  # Will be always enough for 128-bit numbers\r\n        if _min >= _max:\r\n            break\r\n        _mid: uint256 = (_min + _max + 1) / 2\r\n        if self.user_point_history[addr][_mid].blk <= _block:\r\n            _min = _mid\r\n        else:\r\n            _max = _mid - 1\r\n\r\n    upoint: Point = self.user_point_history[addr][_min]\r\n\r\n    max_epoch: uint256 = self.epoch\r\n    _epoch: uint256 = self.find_block_epoch(_block, max_epoch)\r\n    point_0: Point = self.point_history[_epoch]\r\n    d_block: uint256 = 0\r\n    d_t: uint256 = 0\r\n    if _epoch < max_epoch:\r\n        point_1: Point = self.point_history[_epoch + 1]\r\n        d_block = point_1.blk - point_0.blk\r\n        d_t = point_1.ts - point_0.ts\r\n    else:\r\n        d_block = block.number - point_0.blk\r\n        d_t = block.timestamp - point_0.ts\r\n    block_time: uint256 = point_0.ts\r\n    if d_block != 0:\r\n        block_time += d_t * (_block - point_0.blk) / d_block\r\n\r\n    upoint.bias -= upoint.slope * convert(block_time - upoint.ts, int128)\r\n    if upoint.bias >= 0:\r\n        return convert(upoint.bias, uint256)\r\n    else:\r\n        return 0\r\n\r\n\r\n@internal\r\n@view\r\ndef supply_at(point: Point, t: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate total voting power at some point in the past\r\n    @param point The point (bias/slope) to start search from\r\n    @param t Time to calculate the total voting power at\r\n    @return Total voting power at that time\r\n    \"\"\"\r\n    last_point: Point = point\r\n    t_i: uint256 = (last_point.ts / WEEK) * WEEK\r\n    for i in range(255):\r\n        t_i += WEEK\r\n        d_slope: int128 = 0\r\n        if t_i > t:\r\n            t_i = t\r\n        else:\r\n            d_slope = self.slope_changes[t_i]\r\n        last_point.bias -= last_point.slope * convert(t_i - last_point.ts, int128)\r\n        if t_i == t:\r\n            break\r\n        last_point.slope += d_slope\r\n        last_point.ts = t_i\r\n\r\n    if last_point.bias < 0:\r\n        last_point.bias = 0\r\n    return convert(last_point.bias, uint256)\r\n\r\n\r\n@external\r\n@view\r\ndef totalSupply(t: uint256 = block.timestamp) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate total voting power\r\n    @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\r\n    @return Total voting power\r\n    \"\"\"\r\n    _epoch: uint256 = self.epoch\r\n    last_point: Point = self.point_history[_epoch]\r\n    return self.supply_at(last_point, t)\r\n\r\n\r\n@external\r\n@view\r\ndef totalSupplyAt(_block: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate total voting power at some point in the past\r\n    @param _block Block to calculate the total voting power at\r\n    @return Total voting power at `_block`\r\n    \"\"\"\r\n    assert _block <= block.number\r\n    _epoch: uint256 = self.epoch\r\n    target_epoch: uint256 = self.find_block_epoch(_block, _epoch)\r\n\r\n    point: Point = self.point_history[target_epoch]\r\n    dt: uint256 = 0\r\n    if target_epoch < _epoch:\r\n        point_next: Point = self.point_history[target_epoch + 1]\r\n        if point.blk != point_next.blk:\r\n            dt = (_block - point.blk) * (point_next.ts - point.ts) / (point_next.blk - point.blk)\r\n    else:\r\n        if point.blk != block.number:\r\n            dt = (_block - point.blk) * (block.timestamp - point.ts) / (block.number - point.blk)\r\n    # Now dt contains info on how far are we beyond point\r\n\r\n    return self.supply_at(point, point.ts + dt)\r\n\r\n\r\n# Dummy methods for compatibility with Aragon\r\n\r\n@external\r\ndef changeController(_newController: address):\r\n    \"\"\"\r\n    @dev Dummy method required for Aragon compatibility\r\n    \"\"\"\r\n    assert msg.sender == self.controller\r\n    self.controller = _newController\r\n\r\n@view\r\n@external\r\ndef get_delegated_to(_delegator: address, _gauge: address) -> (address, uint256, uint256, uint256):\r\n    \"\"\"\r\n    @notice Get data about an accounts's boost delegation\r\n    @param _delegator Address to query delegation data for\r\n    @param _gauge Gauge address to query. Use ZERO_ADDRESS for global delegation.\r\n    @return address receiving the delegated boost\r\n            delegated boost pct (out of 10000)\r\n            cancellable timestamp\r\n            expiry timestamp\r\n    \"\"\"\r\n    data: uint256 = self.delegated_to[_delegator][_gauge]\r\n    return (\r\n        convert(shift(data, 96), address),\r\n        shift(data, 80) % 2**16,\r\n        shift(data, 40) % 2**40,\r\n        data % 2**40\r\n    )\r\n\r\n\r\n@view\r\n@external\r\ndef get_delegation_data(\r\n    _receiver: address,\r\n    _gauge: address,\r\n    _idx: uint256\r\n) -> (address, uint256, uint256, uint256):\r\n    \"\"\"\r\n    @notice Get data delegation toward an account\r\n    @param _receiver Address to query delegation data for\r\n    @param _gauge Gauge address to query. Use ZERO_ADDRESS for global delegation.\r\n    @param _idx Data index. Each account can receive a max of 10 delegations per pool.\r\n    @return address of the delegator\r\n            delegated boost pct (out of 10000)\r\n            cancellable timestamp\r\n            expiry timestamp\r\n    \"\"\"\r\n    data: uint256 = self.delegation_data[_receiver][_gauge].data[_idx]\r\n    return (\r\n        convert(shift(data, 96), address),\r\n        shift(data, 80) % 2**16,\r\n        shift(data, 40) % 2**40,\r\n        data % 2**40\r\n    )\r\n\r\n\r\n@external\r\ndef set_operator(_operator: address) -> bool:\r\n    \"\"\"\r\n    @notice Set the authorized operator for an address\r\n    @dev An operator can delegate boost, including creating delegations that\r\n         cannot be cancelled. This permission should only be given to trusted\r\n         3rd parties and smart contracts where the contract behavior is known\r\n         to be not malicious.\r\n    @param _operator Approved operator address. Set to `ZERO_ADDRESS` to revoke\r\n                     the currently active approval.\r\n    @return bool success\r\n    \"\"\"\r\n    self.operator_of[msg.sender] = _operator\r\n    return True\r\n\r\n\r\n@internal\r\ndef _delete_delegation_data(_delegator: address, _gauge: address, _delegation_data: uint256):\r\n    # delete record for the delegator\r\n    self.delegated_to[_delegator][_gauge] = 0\r\n    self.delegation_count[_delegator] -= 1\r\n\r\n    receiver: address = convert(shift(_delegation_data, 96), address)\r\n    length: uint256 = self.delegation_data[receiver][_gauge].length\r\n\r\n    # delete record for the receiver\r\n    for i in range(10):\r\n        if i == length - 1:\r\n            self.delegation_data[receiver][_gauge].data[i] = 0\r\n            break\r\n        if self.delegation_data[receiver][_gauge].data[i] == _delegation_data:\r\n            self.delegation_data[receiver][_gauge].data[i] = self.delegation_data[receiver][_gauge].data[length-1]\r\n            self.delegation_data[receiver][_gauge].data[length-1] = 0\r\n\r\n\r\n@external\r\ndef delegate_boost(\r\n    _delegator: address,\r\n    _gauge: address,\r\n    _receiver: address,\r\n    _pct: uint256,\r\n    _cancel_time: uint256,\r\n    _expire_time: uint256\r\n) -> bool:\r\n    \"\"\"\r\n    @notice Delegate per-gauge or global boost to another account\r\n    @param _delegator Address of the user delegating boost. The caller must be the\r\n                      delegator or the approved operator of the delegator.\r\n    @param _gauge Address of the gauge to delegate for. Set as ZERO_ADDRESS for\r\n                  global delegation. Global delegation is not possible if there is\r\n                  also one or more active per-gauge delegations.\r\n    @param _receiver Address to delegate boost to.\r\n    @param _pct Percentage of boost to delegate. 100% is expressed as 10000.\r\n    @param _cancel_time Delegation cannot be cancelled before this time.\r\n    @param _expire_time Delegation automatically expires at this time.\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender in [_delegator, self.operator_of[_delegator]], \"Only owner or operator\"\r\n\r\n    assert _delegator != _receiver, \"Cannot delegate to self\"\r\n    assert _pct >= 100, \"Percent too low\"\r\n    assert _pct <= 10000, \"Percent too high\"\r\n    assert _expire_time < 2**40, \"Expiry time too high\"\r\n    assert _expire_time > block.timestamp, \"Already expired\"\r\n    assert _cancel_time <= _expire_time, \"Cancel time after expiry time\"\r\n\r\n    # check for minimum ve- balance, used to prevent 0 ve- delegation spam\r\n    assert self._balanceOf(_delegator) >= MIN_VE, \"Insufficient ve- to delegate\"\r\n\r\n    # check for an existing, expired delegation\r\n    data: uint256 = self.delegated_to[_delegator][_gauge]\r\n    if data != 0:\r\n        assert data % 2**40 <= block.timestamp, \"Existing delegation has not expired\"\r\n        self._delete_delegation_data(_delegator, _gauge, data)\r\n\r\n    if _gauge == ZERO_ADDRESS:\r\n        assert self.delegation_count[_delegator] == 0, \"Cannot delegate globally while per-gauge is active\"\r\n    else:\r\n        assert self.delegated_to[_delegator][ZERO_ADDRESS] == 0, \"Cannot delegate per-gauge while global is active\"\r\n\r\n    # tightly pack the delegation data\r\n    # [address][uint16 pct][uint40 cancel time][uint40 expire time]\r\n    data = shift(_pct, -80) + shift(_cancel_time, -40) + _expire_time\r\n    idx: uint256 = self.delegation_data[_receiver][_gauge].length\r\n\r\n    self.delegation_data[_receiver][_gauge].data[idx] = data + shift(convert(_delegator, uint256), -96)\r\n    self.delegated_to[_delegator][_gauge] = data + shift(convert(_receiver, uint256), -96)\r\n    self.delegation_data[_receiver][_gauge].length = idx + 1\r\n\r\n    log NewDelegation(_delegator, _gauge, _receiver, _pct, _cancel_time, _expire_time)\r\n    return True\r\n\r\n\r\n@external\r\ndef cancel_delegation(_delegator: address, _gauge: address) -> bool:\r\n    \"\"\"\r\n    @notice Cancel an existing boost delegation\r\n    @param _delegator Address of the user delegating boost. The caller can be the\r\n                      delegator, the receiver, the approved operator of the delegator\r\n                      or receiver. The delegator can cancel after the cancel time\r\n                      has passed, the receiver can cancel at any time.\r\n    @param _gauge Address of the gauge to cancel delegattion for. Set as ZERO_ADDRESS\r\n                  for global delegation.\r\n    @return bool success\r\n    \"\"\"\r\n    data: uint256 = self.delegated_to[_delegator][_gauge]\r\n    assert data != 0, \"No delegation for this pool\"\r\n\r\n    receiver: address = convert(shift(data, 96), address)\r\n    if msg.sender not in [receiver, self.operator_of[receiver]]:\r\n        assert msg.sender in [receiver, self.operator_of[receiver]], \"Only owner or operator\"\r\n        assert shift(data, 40) % 2**40 <= block.timestamp, \"Not yet cancellable\"\r\n\r\n    self._delete_delegation_data(_delegator, _gauge, data)\r\n\r\n    log CancelledDelegation(_delegator, _gauge, receiver, msg.sender)\r\n    return True\r\n\r\n\r\n@view\r\n@external\r\ndef get_adjusted_ve_balance(_user: address, _gauge: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the adjusted ve- balance of an account after delegation\r\n    @param _user Address to query a ve- balance for\r\n    @param _gauge Gauge address\r\n    @return Adjusted ve- balance after delegation\r\n    \"\"\"\r\n    # query the initial ve balance for `_user`\r\n    voting_balance: uint256 = self._balanceOf(_user)\r\n\r\n    # check if the user has delegated any ve and reduce the voting balance\r\n    delegation_count: uint256 = self.delegation_count[_user]\r\n    if delegation_count != 0:\r\n        is_global: bool = False\r\n        # apply global delegation\r\n        if delegation_count == 1:\r\n            data: uint256 = self.delegated_to[_user][ZERO_ADDRESS]\r\n            if data % 2**40 > block.timestamp:\r\n                voting_balance = voting_balance * (10000 - shift(data, 80) % 2**16) / 10000\r\n                is_global = True\r\n        # apply pool-specific delegation\r\n        if not is_global:\r\n            data: uint256 = self.delegated_to[_user][_gauge]\r\n            if data % 2**40 > block.timestamp:\r\n                voting_balance = voting_balance * (10000 - shift(data, 80) % 2**16) / 10000\r\n\r\n    # check for other ve delegated to `_user` and increase the voting balance\r\n    for target in [_gauge, ZERO_ADDRESS]:\r\n        length: uint256 = self.delegation_data[_user][target].length\r\n        if length > 0:\r\n            for i in range(10):\r\n                if i == length:\r\n                    break\r\n                data: uint256 = self.delegation_data[_user][target].data[i]\r\n                if data % 2**40 > block.timestamp:\r\n                    delegator: address = convert(shift(data, 96), address)\r\n                    delegator_balance: uint256 = self._balanceOf(delegator)\r\n                    voting_balance += delegator_balance * (shift(data, 80) % 2**16) / 10000\r\n\r\n    return voting_balance\r\n\r\n\r\n@external\r\ndef update_delegation_records(_user: address, _gauge: address) -> bool:\r\n    \"\"\"\r\n    @notice Remove data about any expired delegations for a user.\r\n    @dev Reduces gas costs when calling `get_adjusted_ve_balance` on\r\n         an address with expired delegations.\r\n    @param _user Address to update records for.\r\n    @param _gauge Gauge address. Use `ZERO_ADDRESS` for global delegations.\r\n    \"\"\"\r\n    length: uint256 = self.delegation_data[_user][_gauge].length - 1\r\n    adjusted_length: uint256 = length\r\n\r\n    # iterate in reverse over `delegation_data` and remove expired records\r\n    for i in range(10):\r\n        if i > length:\r\n            break\r\n        idx: uint256 = length - i\r\n        data: uint256 = self.delegation_data[_user][_gauge].data[idx]\r\n        if data % 2**40 <= block.timestamp:\r\n            # delete record for the delegator\r\n            delegator: address = convert(shift(data, 96), address)\r\n            self.delegated_to[delegator][_gauge] = 0\r\n            self.delegation_count[delegator] -= 1\r\n\r\n            # delete record for the receiver\r\n            if idx == adjusted_length:\r\n                self.delegation_data[_user][_gauge].data[idx] = 0\r\n            else:\r\n                self.delegation_data[_user][_gauge].data[idx] = self.delegation_data[_user][_gauge].data[adjusted_length]\r\n            adjusted_length -= 1\r\n\r\n    return True","ABI":"[{\"name\":\"CommitOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApplyOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"locktime\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"type\",\"type\":\"int128\",\"indexed\":false},{\"name\":\"ts\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ts\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Supply\",\"inputs\":[{\"name\":\"prevSupply\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewDelegation\",\"inputs\":[{\"name\":\"delegator\",\"type\":\"address\",\"indexed\":true},{\"name\":\"gauge\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"pct\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"cancel_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"expire_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CancelledDelegation\",\"inputs\":[{\"name\":\"delegator\",\"type\":\"address\",\"indexed\":true},{\"name\":\"gauge\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"cancelled_by\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"token_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_version\",\"type\":\"string\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":38895},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_transfer_ownership\",\"inputs\":[],\"outputs\":[],\"gas\":41034},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_smart_wallet_checker\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":37605},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_smart_wallet_checker\",\"inputs\":[],\"outputs\":[],\"gas\":39632},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_last_user_slope\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"gas\":5001},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"user_point_history__ts\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2804},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"locked__end\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2789},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"checkpoint\",\"inputs\":[],\"outputs\":[],\"gas\":37424696},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit_for\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":75034171},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"create_lock\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_unlock_time\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":75035740},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increase_amount\",\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":75035161},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increase_unlock_time\",\"inputs\":[{\"name\":\"_unlock_time\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":75035808},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[],\"outputs\":[],\"gas\":37603171},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_t\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOfAt\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_block\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":824489},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[{\"name\":\"t\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupplyAt\",\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":1370618},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"changeController\",\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"outputs\":[],\"gas\":38055},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_delegated_to\",\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\"},{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":4208},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_delegation_data\",\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_gauge\",\"type\":\"address\"},{\"name\":\"_idx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":4289},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_operator\",\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":36108},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"delegate_boost\",\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\"},{\"name\":\"_gauge\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_pct\",\"type\":\"uint256\"},{\"name\":\"_cancel_time\",\"type\":\"uint256\"},{\"name\":\"_expire_time\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":1011246},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"cancel_delegation\",\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\"},{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":887564},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_adjusted_ve_balance\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":359808},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_delegation_records\",\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":989594},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3138},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"supply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3168},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"locked\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"amount\",\"type\":\"int128\"},{\"name\":\"end\",\"type\":\"uint256\"}],\"gas\":5803},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"epoch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3228},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"point_history\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"bias\",\"type\":\"int128\"},{\"name\":\"slope\",\"type\":\"int128\"},{\"name\":\"ts\",\"type\":\"uint256\"},{\"name\":\"blk\",\"type\":\"uint256\"}],\"gas\":10113},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"user_point_history\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"bias\",\"type\":\"int128\"},{\"name\":\"slope\",\"type\":\"int128\"},{\"name\":\"ts\",\"type\":\"uint256\"},{\"name\":\"blk\",\"type\":\"uint256\"}],\"gas\":10358},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"user_point_epoch\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3533},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"slope_changes\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"}],\"gas\":3463},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"controller\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3378},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"transfersEnabled\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3408},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":13668},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":11421},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"gas\":11451},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3528},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_smart_wallet_checker\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3558},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"smart_wallet_checker\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3588},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3618},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3648},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"delegation_count\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3893},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"operator_of\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3923}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.15","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000001ceb5cb57c4d4e2b2433641b95dd330a33185a44000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000005764b5033520000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005764b5033520000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005312e302e30000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}