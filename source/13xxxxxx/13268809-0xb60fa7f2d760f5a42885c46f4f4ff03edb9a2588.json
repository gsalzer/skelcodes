{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/******************************************/\r\n/* KeeperCompatibleInterface starts here  */\r\n/******************************************/\r\n\r\ninterface KeeperCompatibleInterface {\r\n\r\n  /**\r\n   * @notice checks if the contract requires work to be done.\r\n   * @param checkData data passed to the contract when checking for upkeep.\r\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\r\n   * performUpkeep or not.\r\n   * @return performData bytes that the keeper should call performUpkeep with,\r\n   * if upkeep is needed.\r\n   */\r\n  function checkUpkeep(\r\n    bytes calldata checkData\r\n  )\r\n    external\r\n    returns (\r\n      bool upkeepNeeded,\r\n      bytes memory performData\r\n    );\r\n\r\n  /**\r\n   * @notice Performs work on the contract. Executed by the keepers, via the registry.\r\n   * @param performData is the data which was passed back from the checkData\r\n   * simulation.\r\n   */\r\n  function performUpkeep(\r\n    bytes calldata performData\r\n  ) external;\r\n}\r\n\r\n/******************************************/\r\n/* ChainlinkRequestInterface starts here  */\r\n/******************************************/\r\n\r\ninterface ChainlinkRequestInterface {\r\n  function oracleRequest(\r\n    address sender,\r\n    uint256 requestPrice,\r\n    bytes32 serviceAgreementID,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 nonce,\r\n    uint256 dataVersion,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  function cancelOracleRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration\r\n  ) external;\r\n}\r\n\r\n/******************************************/\r\n/*       OracleInterface starts here      */\r\n/******************************************/\r\n\r\ninterface OracleInterface {\r\n  function fulfillOracleRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration,\r\n    bytes32 data\r\n  )\r\n    external\r\n    returns (\r\n      bool\r\n    );\r\n\r\n  function isAuthorizedSender(\r\n    address node\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      bool\r\n    );\r\n\r\n  function withdraw(\r\n    address recipient,\r\n    uint256 amount\r\n  ) external;\r\n\r\n  function withdrawable()\r\n    external\r\n    view\r\n    returns (\r\n      uint256\r\n    );\r\n}\r\n\r\n/******************************************/\r\n/*      OperatorInterface starts here     */\r\n/******************************************/\r\n\r\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\r\n\r\n  function requestOracleData(\r\n    address sender,\r\n    uint256 payment,\r\n    bytes32 specId,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 nonce,\r\n    uint256 dataVersion,\r\n    bytes calldata data\r\n  )\r\n    external;\r\n\r\n  function fulfillOracleRequest2(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration,\r\n    bytes calldata data\r\n  )\r\n    external\r\n    returns (\r\n      bool\r\n    );\r\n\r\n  function ownerTransferAndCall(\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  )\r\n    external\r\n    returns (\r\n      bool success\r\n    );\r\n\r\n  function distributeFunds(\r\n    address payable[] calldata receivers,\r\n    uint[] calldata amounts\r\n  )\r\n    external\r\n    payable;\r\n\r\n  function getAuthorizedSenders()\r\n    external\r\n    returns (\r\n      address[] memory\r\n    );\r\n\r\n  function setAuthorizedSenders(\r\n    address[] calldata senders\r\n  ) external;\r\n\r\n  function getForwarder()\r\n    external\r\n    returns (\r\n      address\r\n    );\r\n}\r\n\r\n/******************************************/\r\n/*      PointerInterface starts here      */\r\n/******************************************/\r\n\r\ninterface PointerInterface {\r\n  \r\n  function getAddress()\r\n    external\r\n    view\r\n    returns (\r\n      address\r\n    );\r\n}\r\n\r\n/******************************************/\r\n/*     LinkTokenInterface starts here     */\r\n/******************************************/\r\n\r\ninterface LinkTokenInterface {\r\n\r\n  function allowance(\r\n    address owner,\r\n    address spender\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256 remaining\r\n    );\r\n\r\n  function approve(\r\n    address spender,\r\n    uint256 value\r\n  )\r\n    external\r\n    returns (\r\n      bool success\r\n    );\r\n\r\n  function balanceOf(\r\n    address owner\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint256 balance\r\n    );\r\n\r\n  function decimals()\r\n    external\r\n    view\r\n    returns (\r\n      uint8 decimalPlaces\r\n    );\r\n\r\n  function decreaseApproval(\r\n    address spender,\r\n    uint256 addedValue\r\n  )\r\n    external\r\n    returns (\r\n      bool success\r\n    );\r\n\r\n  function increaseApproval(\r\n    address spender,\r\n    uint256 subtractedValue\r\n  ) external;\r\n\r\n  function name()\r\n    external\r\n    view\r\n    returns (\r\n      string memory tokenName\r\n    );\r\n\r\n  function symbol()\r\n    external\r\n    view\r\n    returns (\r\n      string memory tokenSymbol\r\n    );\r\n\r\n  function totalSupply()\r\n    external\r\n    view\r\n    returns (\r\n      uint256 totalTokensIssued\r\n    );\r\n\r\n  function transfer(\r\n    address to,\r\n    uint256 value\r\n  )\r\n    external\r\n    returns (\r\n      bool success\r\n    );\r\n\r\n  function transferAndCall(\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  )\r\n    external\r\n    returns (\r\n      bool success\r\n    );\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    external\r\n    returns (\r\n      bool success\r\n    );\r\n\r\n}\r\n\r\n/******************************************/\r\n/*         ENSResolver starts here        */\r\n/******************************************/\r\n\r\nabstract contract ENSResolver_Chainlink {\r\n  function addr(\r\n    bytes32 node\r\n  )\r\n    public\r\n    view\r\n    virtual\r\n    returns (\r\n      address\r\n    );\r\n}\r\n\r\n/******************************************/\r\n/*         ENSInterface starts here       */\r\n/******************************************/\r\n\r\ninterface ENSInterface {\r\n\r\n  // Logged when the owner of a node assigns a new owner to a subnode.\r\n  event NewOwner(\r\n    bytes32 indexed node,\r\n    bytes32 indexed label,\r\n    address owner\r\n  );\r\n\r\n  // Logged when the owner of a node transfers ownership to a new account.\r\n  event Transfer(\r\n    bytes32 indexed node,\r\n    address owner\r\n  );\r\n\r\n  // Logged when the resolver for a node changes.\r\n  event NewResolver(\r\n    bytes32 indexed node,\r\n    address resolver\r\n  );\r\n\r\n  // Logged when the TTL of a node changes\r\n  event NewTTL(\r\n    bytes32 indexed node,\r\n    uint64 ttl\r\n  );\r\n\r\n\r\n  function setSubnodeOwner(\r\n    bytes32 node,\r\n    bytes32 label,\r\n    address owner\r\n  ) external;\r\n\r\n  function setResolver(\r\n    bytes32 node,\r\n    address resolver\r\n  ) external;\r\n\r\n  function setOwner(\r\n    bytes32 node,\r\n    address owner\r\n  ) external;\r\n\r\n  function setTTL(\r\n    bytes32 node,\r\n    uint64 ttl\r\n  ) external;\r\n\r\n  function owner(\r\n    bytes32 node\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      address\r\n    );\r\n\r\n  function resolver(\r\n    bytes32 node\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      address\r\n    );\r\n\r\n  function ttl(\r\n    bytes32 node\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint64\r\n    );\r\n\r\n}\r\n\r\n/******************************************/\r\n/*       BufferChainlink starts here      */\r\n/******************************************/\r\n\r\n/**\r\n* @dev A library for working with mutable byte buffers in Solidity.\r\n*\r\n* Byte buffers are mutable and expandable, and provide a variety of primitives\r\n* for writing to them. At any time you can fetch a bytes object containing the\r\n* current contents of the buffer. The bytes object should not be stored between\r\n* operations, as it may change due to resizing of the buffer.\r\n*/\r\nlibrary BufferChainlink {\r\n  /**\r\n  * @dev Represents a mutable buffer. Buffers have a current value (buf) and\r\n  *      a capacity. The capacity may be longer than the current value, in\r\n  *      which case it can be extended without the need to allocate more memory.\r\n  */\r\n  struct buffer {\r\n    bytes buf;\r\n    uint capacity;\r\n  }\r\n\r\n  /**\r\n  * @dev Initializes a buffer with an initial capacity.\r\n  * @param buf The buffer to initialize.\r\n  * @param capacity The number of bytes of space to allocate the buffer.\r\n  * @return The buffer, for chaining.\r\n  */\r\n  function init(\r\n    buffer memory buf,\r\n    uint capacity\r\n  )\r\n    internal\r\n    pure\r\n    returns(\r\n      buffer memory\r\n    )\r\n  {\r\n    if (capacity % 32 != 0) {\r\n      capacity += 32 - (capacity % 32);\r\n    }\r\n    // Allocate space for the buffer data\r\n    buf.capacity = capacity;\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      mstore(buf, ptr)\r\n      mstore(ptr, 0)\r\n      mstore(0x40, add(32, add(ptr, capacity)))\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n  * @dev Initializes a new buffer from an existing bytes object.\r\n  *      Changes to the buffer may mutate the original value.\r\n  * @param b The bytes object to initialize the buffer with.\r\n  * @return A new buffer.\r\n  */\r\n  function fromBytes(\r\n    bytes memory b\r\n  )\r\n    internal\r\n    pure\r\n    returns(\r\n      buffer memory\r\n    )\r\n  {\r\n    buffer memory buf;\r\n    buf.buf = b;\r\n    buf.capacity = b.length;\r\n    return buf;\r\n  }\r\n\r\n  function resize(\r\n    buffer memory buf,\r\n    uint capacity\r\n  )\r\n    private\r\n    pure\r\n  {\r\n    bytes memory oldbuf = buf.buf;\r\n    init(buf, capacity);\r\n    append(buf, oldbuf);\r\n  }\r\n\r\n  function max(\r\n    uint a,\r\n    uint b\r\n  )\r\n    private\r\n    pure\r\n    returns(\r\n      uint\r\n    )\r\n  {\r\n    if (a > b) {\r\n      return a;\r\n    }\r\n    return b;\r\n  }\r\n\r\n  /**\r\n  * @dev Sets buffer length to 0.\r\n  * @param buf The buffer to truncate.\r\n  * @return The original buffer, for chaining..\r\n  */\r\n  function truncate(\r\n    buffer memory buf\r\n  )\r\n    internal\r\n    pure\r\n    returns (\r\n      buffer memory\r\n    )\r\n  {\r\n    assembly {\r\n      let bufptr := mload(buf)\r\n      mstore(bufptr, 0)\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n  * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param off The start offset to write to.\r\n  * @param data The data to append.\r\n  * @param len The number of bytes to copy.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function write(\r\n    buffer memory buf,\r\n    uint off,\r\n    bytes memory data,\r\n    uint len\r\n  )\r\n    internal\r\n    pure\r\n    returns(\r\n      buffer memory\r\n    )\r\n  {\r\n    require(len <= data.length);\r\n\r\n    if (off + len > buf.capacity) {\r\n      resize(buf, max(buf.capacity, len + off) * 2);\r\n    }\r\n\r\n    uint dest;\r\n    uint src;\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Length of existing buffer data\r\n      let buflen := mload(bufptr)\r\n      // Start address = buffer address + offset + sizeof(buffer length)\r\n      dest := add(add(bufptr, 32), off)\r\n      // Update buffer length if we're extending it\r\n      if gt(add(len, off), buflen) {\r\n        mstore(bufptr, add(len, off))\r\n      }\r\n      src := add(data, 32)\r\n    }\r\n\r\n    // Copy word-length chunks while possible\r\n    for (; len >= 32; len -= 32) {\r\n      assembly {\r\n        mstore(dest, mload(src))\r\n      }\r\n      dest += 32;\r\n      src += 32;\r\n    }\r\n\r\n    // Copy remaining bytes\r\n    uint mask = 256 ** (32 - len) - 1;\r\n    assembly {\r\n      let srcpart := and(mload(src), not(mask))\r\n      let destpart := and(mload(dest), mask)\r\n      mstore(dest, or(destpart, srcpart))\r\n    }\r\n\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n  * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param data The data to append.\r\n  * @param len The number of bytes to copy.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function append(\r\n    buffer memory buf,\r\n    bytes memory data,\r\n    uint len\r\n  )\r\n    internal\r\n    pure\r\n    returns (\r\n      buffer memory\r\n    )\r\n  {\r\n    return write(buf, buf.buf.length, data, len);\r\n  }\r\n\r\n  /**\r\n  * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function append(\r\n    buffer memory buf,\r\n    bytes memory data\r\n  )\r\n    internal\r\n    pure\r\n    returns (\r\n      buffer memory\r\n    )\r\n  {\r\n    return write(buf, buf.buf.length, data, data.length);\r\n  }\r\n\r\n  /**\r\n  * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\r\n  *      capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param off The offset to write the byte at.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function writeUint8(\r\n    buffer memory buf,\r\n    uint off,\r\n    uint8 data\r\n  )\r\n    internal\r\n    pure\r\n    returns(\r\n      buffer memory\r\n    )\r\n  {\r\n    if (off >= buf.capacity) {\r\n      resize(buf, buf.capacity * 2);\r\n    }\r\n\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Length of existing buffer data\r\n      let buflen := mload(bufptr)\r\n      // Address = buffer address + sizeof(buffer length) + off\r\n      let dest := add(add(bufptr, off), 32)\r\n      mstore8(dest, data)\r\n      // Update buffer length if we extended it\r\n      if eq(off, buflen) {\r\n        mstore(bufptr, add(buflen, 1))\r\n      }\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n  * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\r\n  *      capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function appendUint8(\r\n    buffer memory buf,\r\n    uint8 data\r\n  )\r\n    internal\r\n    pure\r\n    returns(\r\n      buffer memory\r\n    )\r\n  {\r\n    return writeUint8(buf, buf.buf.length, data);\r\n  }\r\n\r\n  /**\r\n  * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\r\n  *      exceed the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param off The offset to write at.\r\n  * @param data The data to append.\r\n  * @param len The number of bytes to write (left-aligned).\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function write(\r\n    buffer memory buf,\r\n    uint off,\r\n    bytes32 data,\r\n    uint len\r\n  )\r\n    private\r\n    pure\r\n    returns(\r\n      buffer memory\r\n    )\r\n  {\r\n    if (len + off > buf.capacity) {\r\n      resize(buf, (len + off) * 2);\r\n    }\r\n\r\n    uint mask = 256 ** len - 1;\r\n    // Right-align data\r\n    data = data >> (8 * (32 - len));\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Address = buffer address + sizeof(buffer length) + off + len\r\n      let dest := add(add(bufptr, off), len)\r\n      mstore(dest, or(and(mload(dest), not(mask)), data))\r\n      // Update buffer length if we extended it\r\n      if gt(add(off, len), mload(bufptr)) {\r\n        mstore(bufptr, add(off, len))\r\n      }\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n  * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\r\n  *      capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param off The offset to write at.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function writeBytes20(\r\n    buffer memory buf,\r\n    uint off,\r\n    bytes20 data\r\n  )\r\n    internal\r\n    pure\r\n    returns (\r\n      buffer memory\r\n    )\r\n  {\r\n    return write(buf, off, bytes32(data), 20);\r\n  }\r\n\r\n  /**\r\n  * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chhaining.\r\n  */\r\n  function appendBytes20(\r\n    buffer memory buf,\r\n    bytes20 data\r\n  )\r\n    internal\r\n    pure\r\n    returns (\r\n      buffer memory\r\n    )\r\n  {\r\n    return write(buf, buf.buf.length, bytes32(data), 20);\r\n  }\r\n\r\n  /**\r\n  * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param data The data to append.\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function appendBytes32(\r\n    buffer memory buf,\r\n    bytes32 data\r\n  )\r\n    internal\r\n    pure\r\n    returns (\r\n      buffer memory\r\n    )\r\n  {\r\n    return write(buf, buf.buf.length, data, 32);\r\n  }\r\n\r\n  /**\r\n  * @dev Writes an integer to the buffer. Resizes if doing so would exceed\r\n  *      the capacity of the buffer.\r\n  * @param buf The buffer to append to.\r\n  * @param off The offset to write at.\r\n  * @param data The data to append.\r\n  * @param len The number of bytes to write (right-aligned).\r\n  * @return The original buffer, for chaining.\r\n  */\r\n  function writeInt(\r\n    buffer memory buf,\r\n    uint off,\r\n    uint data,\r\n    uint len\r\n  )\r\n    private\r\n    pure\r\n    returns(\r\n      buffer memory\r\n    )\r\n  {\r\n    if (len + off > buf.capacity) {\r\n      resize(buf, (len + off) * 2);\r\n    }\r\n\r\n    uint mask = 256 ** len - 1;\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Address = buffer address + off + sizeof(buffer length) + len\r\n      let dest := add(add(bufptr, off), len)\r\n      mstore(dest, or(and(mload(dest), not(mask)), data))\r\n      // Update buffer length if we extended it\r\n      if gt(add(off, len), mload(bufptr)) {\r\n        mstore(bufptr, add(off, len))\r\n      }\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n    * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n    * exceed the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer.\r\n    */\r\n  function appendInt(\r\n    buffer memory buf,\r\n    uint data,\r\n    uint len\r\n  )\r\n    internal\r\n    pure\r\n    returns(\r\n      buffer memory\r\n    )\r\n  {\r\n    return writeInt(buf, buf.buf.length, data, len);\r\n  }\r\n}\r\n\r\n/******************************************/\r\n/*        CBORChainlink starts here       */\r\n/******************************************/\r\n\r\nlibrary CBORChainlink {\r\n  using BufferChainlink for BufferChainlink.buffer;\r\n\r\n  uint8 private constant MAJOR_TYPE_INT = 0;\r\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\r\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\r\n  uint8 private constant MAJOR_TYPE_STRING = 3;\r\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\r\n  uint8 private constant MAJOR_TYPE_MAP = 5;\r\n  uint8 private constant MAJOR_TYPE_TAG = 6;\r\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\r\n\r\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\r\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\r\n\r\n  function encodeType(\r\n    BufferChainlink.buffer memory buf,\r\n    uint8 major,\r\n    uint value\r\n  )\r\n    private\r\n    pure\r\n  {\r\n    if(value <= 23) {\r\n      buf.appendUint8(uint8((major << 5) | value));\r\n    } else if(value <= 0xFF) {\r\n      buf.appendUint8(uint8((major << 5) | 24));\r\n      buf.appendInt(value, 1);\r\n    } else if(value <= 0xFFFF) {\r\n      buf.appendUint8(uint8((major << 5) | 25));\r\n      buf.appendInt(value, 2);\r\n    } else if(value <= 0xFFFFFFFF) {\r\n      buf.appendUint8(uint8((major << 5) | 26));\r\n      buf.appendInt(value, 4);\r\n    } else if(value <= 0xFFFFFFFFFFFFFFFF) {\r\n      buf.appendUint8(uint8((major << 5) | 27));\r\n      buf.appendInt(value, 8);\r\n    }\r\n  }\r\n\r\n  function encodeIndefiniteLengthType(\r\n    BufferChainlink.buffer memory buf,\r\n    uint8 major\r\n  )\r\n    private\r\n    pure\r\n  {\r\n    buf.appendUint8(uint8((major << 5) | 31));\r\n  }\r\n\r\n  function encodeUInt(\r\n    BufferChainlink.buffer memory buf,\r\n    uint value\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    encodeType(buf, MAJOR_TYPE_INT, value);\r\n  }\r\n\r\n  function encodeInt(\r\n    BufferChainlink.buffer memory buf,\r\n    int value\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    if(value < -0x10000000000000000) {\r\n      encodeSignedBigNum(buf, value);\r\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\r\n      encodeBigNum(buf, value);\r\n    } else if(value >= 0) {\r\n      encodeType(buf, MAJOR_TYPE_INT, uint(value));\r\n    } else {\r\n      encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\r\n    }\r\n  }\r\n\r\n  function encodeBytes(\r\n    BufferChainlink.buffer memory buf,\r\n    bytes memory value\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    encodeType(buf, MAJOR_TYPE_BYTES, value.length);\r\n    buf.append(value);\r\n  }\r\n\r\n  function encodeBigNum(\r\n    BufferChainlink.buffer memory buf,\r\n    int value\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\r\n    encodeBytes(buf, abi.encode(uint(value)));\r\n  }\r\n\r\n  function encodeSignedBigNum(\r\n    BufferChainlink.buffer memory buf,\r\n    int input\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\r\n    encodeBytes(buf, abi.encode(uint(-1 - input)));\r\n  }\r\n\r\n  function encodeString(\r\n    BufferChainlink.buffer memory buf,\r\n    string memory value\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\r\n    buf.append(bytes(value));\r\n  }\r\n\r\n  function startArray(\r\n    BufferChainlink.buffer memory buf\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\r\n  }\r\n\r\n  function startMap(\r\n    BufferChainlink.buffer memory buf\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\r\n  }\r\n\r\n  function endSequence(\r\n    BufferChainlink.buffer memory buf\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\r\n  }\r\n}\r\n\r\n/******************************************/\r\n/*          Chainlink starts here         */\r\n/******************************************/\r\n\r\n/**\r\n * @title Library for common Chainlink functions\r\n * @dev Uses imported CBOR library for encoding to buffer\r\n */\r\nlibrary Chainlink {\r\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\r\n\r\n  using CBORChainlink for BufferChainlink.buffer;\r\n\r\n  struct Request {\r\n    bytes32 id;\r\n    address callbackAddress;\r\n    bytes4 callbackFunctionId;\r\n    uint256 nonce;\r\n    BufferChainlink.buffer buf;\r\n  }\r\n\r\n  /**\r\n   * @notice Initializes a Chainlink request\r\n   * @dev Sets the ID, callback address, and callback function signature on the request\r\n   * @param self The uninitialized request\r\n   * @param jobId The Job Specification ID\r\n   * @param callbackAddr The callback address\r\n   * @param callbackFunc The callback function signature\r\n   * @return The initialized request\r\n   */\r\n  function initialize(\r\n    Request memory self,\r\n    bytes32 jobId,\r\n    address callbackAddr,\r\n    bytes4 callbackFunc\r\n  )\r\n    internal\r\n    pure\r\n    returns (\r\n      Chainlink.Request memory\r\n    )\r\n  {\r\n    BufferChainlink.init(self.buf, defaultBufferSize);\r\n    self.id = jobId;\r\n    self.callbackAddress = callbackAddr;\r\n    self.callbackFunctionId = callbackFunc;\r\n    return self;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\r\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\r\n   * @param self The initialized request\r\n   * @param data The CBOR data\r\n   */\r\n  function setBuffer(\r\n    Request memory self,\r\n    bytes memory data\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    BufferChainlink.init(self.buf, data.length);\r\n    BufferChainlink.append(self.buf, data);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a string value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param key The name of the key\r\n   * @param value The string value to add\r\n   */\r\n  function add(\r\n    Request memory self,\r\n    string memory key,\r\n    string memory value\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    self.buf.encodeString(key);\r\n    self.buf.encodeString(value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a bytes value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param key The name of the key\r\n   * @param value The bytes value to add\r\n   */\r\n  function addBytes(\r\n    Request memory self,\r\n    string memory key,\r\n    bytes memory value\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    self.buf.encodeString(key);\r\n    self.buf.encodeBytes(value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a int256 value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param key The name of the key\r\n   * @param value The int256 value to add\r\n   */\r\n  function addInt(\r\n    Request memory self,\r\n    string memory key,\r\n    int256 value\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    self.buf.encodeString(key);\r\n    self.buf.encodeInt(value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a uint256 value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param key The name of the key\r\n   * @param value The uint256 value to add\r\n   */\r\n  function addUint(\r\n    Request memory self,\r\n    string memory key,\r\n    uint256 value\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    self.buf.encodeString(key);\r\n    self.buf.encodeUInt(value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds an array of strings to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param key The name of the key\r\n   * @param values The array of string values to add\r\n   */\r\n  function addStringArray(\r\n    Request memory self,\r\n    string memory key,\r\n    string[] memory values\r\n  )\r\n    internal\r\n    pure\r\n  {\r\n    self.buf.encodeString(key);\r\n    self.buf.startArray();\r\n    for (uint256 i = 0; i < values.length; i++) {\r\n      self.buf.encodeString(values[i]);\r\n    }\r\n    self.buf.endSequence();\r\n  }\r\n}\r\n\r\n/******************************************/\r\n/*       ChainlinkClient starts here      */\r\n/******************************************/\r\n\r\n/**\r\n * @title The ChainlinkClient contract\r\n * @notice Contract writers can inherit this contract in order to create requests for the\r\n * Chainlink network\r\n */\r\nabstract contract ChainlinkClient {\r\n  using Chainlink for Chainlink.Request;\r\n\r\n  uint256 constant internal LINK_DIVISIBILITY = 10**18;\r\n  uint256 constant private AMOUNT_OVERRIDE = 0;\r\n  address constant private SENDER_OVERRIDE = address(0);\r\n  uint256 constant private ORACLE_ARGS_VERSION = 1;\r\n  uint256 constant private OPERATOR_ARGS_VERSION = 2;\r\n  bytes32 constant private ENS_TOKEN_SUBNAME = keccak256(\"link\");\r\n  bytes32 constant private ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\r\n  address constant private LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\r\n\r\n  ENSInterface private ens;\r\n  bytes32 private ensNode;\r\n  LinkTokenInterface private link;\r\n  OperatorInterface private oracle;\r\n  uint256 private requestCount = 1;\r\n  mapping(bytes32 => address) private pendingRequests;\r\n\r\n  event ChainlinkRequested(\r\n    bytes32 indexed id\r\n  );\r\n  event ChainlinkFulfilled(\r\n    bytes32 indexed id\r\n  );\r\n  event ChainlinkCancelled(\r\n    bytes32 indexed id\r\n  );\r\n\r\n  /**\r\n   * @notice Creates a request that can hold additional parameters\r\n   * @param specId The Job Specification ID that the request will be created for\r\n   * @param callbackAddress The callback address that the response will be sent to\r\n   * @param callbackFunctionSignature The callback function signature to use for the callback address\r\n   * @return A Chainlink Request struct in memory\r\n   */\r\n  function buildChainlinkRequest(\r\n    bytes32 specId,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionSignature\r\n  )\r\n    internal\r\n    pure\r\n    returns (\r\n      Chainlink.Request memory\r\n    )\r\n  {\r\n    Chainlink.Request memory req;\r\n    return req.initialize(specId, callbackAddress, callbackFunctionSignature);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the stored oracle address\r\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\r\n   * @param req The initialized Chainlink Request\r\n   * @param payment The amount of LINK to send for the request\r\n   * @return requestId The request ID\r\n   */\r\n  function sendChainlinkRequest(\r\n    Chainlink.Request memory req,\r\n    uint256 payment\r\n  )\r\n    internal\r\n    returns (\r\n      bytes32\r\n    )\r\n  {\r\n    return sendChainlinkRequestTo(address(oracle), req, payment);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the specified oracle address\r\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\r\n   * send LINK which creates a request on the target oracle contract.\r\n   * Emits ChainlinkRequested event.\r\n   * @param oracleAddress The address of the oracle for the request\r\n   * @param req The initialized Chainlink Request\r\n   * @param payment The amount of LINK to send for the request\r\n   * @return requestId The request ID\r\n   */\r\n  function sendChainlinkRequestTo(\r\n    address oracleAddress,\r\n    Chainlink.Request memory req,\r\n    uint256 payment\r\n  )\r\n    internal\r\n    returns (\r\n      bytes32 requestId\r\n    )\r\n  {\r\n    return rawRequest(oracleAddress, req, payment, ORACLE_ARGS_VERSION, oracle.oracleRequest.selector);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the stored oracle address\r\n   * @dev This function supports multi-word response\r\n   * @dev Calls `requestOracleDataFrom` with the stored oracle address\r\n   * @param req The initialized Chainlink Request\r\n   * @param payment The amount of LINK to send for the request\r\n   * @return requestId The request ID\r\n   */\r\n  function requestOracleData(\r\n    Chainlink.Request memory req,\r\n    uint256 payment\r\n  )\r\n    internal\r\n    returns (\r\n      bytes32\r\n    )\r\n  {\r\n    return requestOracleDataFrom(address(oracle), req, payment);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the specified oracle address\r\n   * @dev This function supports multi-word response\r\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\r\n   * send LINK which creates a request on the target oracle contract.\r\n   * Emits ChainlinkRequested event.\r\n   * @param oracleAddress The address of the oracle for the request\r\n   * @param req The initialized Chainlink Request\r\n   * @param payment The amount of LINK to send for the request\r\n   * @return requestId The request ID\r\n   */\r\n  function requestOracleDataFrom(\r\n    address oracleAddress,\r\n    Chainlink.Request memory req,\r\n    uint256 payment\r\n  )\r\n    internal\r\n    returns (\r\n      bytes32 requestId\r\n    )\r\n  {\r\n    return rawRequest(oracleAddress, req, payment, OPERATOR_ARGS_VERSION, oracle.requestOracleData.selector);\r\n  }\r\n\r\n  /**\r\n   * @notice Make a request to an oracle\r\n   * @param oracleAddress The address of the oracle for the request\r\n   * @param req The initialized Chainlink Request\r\n   * @param payment The amount of LINK to send for the request\r\n   * @param argsVersion The version of data support (single word, multi word)\r\n   * @return requestId The request ID\r\n   */\r\n  function rawRequest(\r\n    address oracleAddress,\r\n    Chainlink.Request memory req,\r\n    uint256 payment,\r\n    uint256 argsVersion,\r\n    bytes4 funcSelector\r\n  )\r\n    private\r\n    returns (\r\n      bytes32 requestId\r\n    )\r\n  {\r\n    requestId = keccak256(abi.encodePacked(this, requestCount));\r\n    req.nonce = requestCount;\r\n    pendingRequests[requestId] = oracleAddress;\r\n    emit ChainlinkRequested(requestId);\r\n    bytes memory encodedData = abi.encodeWithSelector(\r\n      funcSelector,\r\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\r\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\r\n      req.id,\r\n      req.callbackAddress,\r\n      req.callbackFunctionId,\r\n      req.nonce,\r\n      argsVersion,\r\n      req.buf.buf);\r\n    require(link.transferAndCall(oracleAddress, payment, encodedData), \"unable to transferAndCall to oracle\");\r\n    requestCount += 1;\r\n  }\r\n\r\n  /**\r\n   * @notice Allows a request to be cancelled if it has not been fulfilled\r\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\r\n   * Deletes the request from the `pendingRequests` mapping.\r\n   * Emits ChainlinkCancelled event.\r\n   * @param requestId The request ID\r\n   * @param payment The amount of LINK sent for the request\r\n   * @param callbackFunc The callback function specified for the request\r\n   * @param expiration The time of the expiration for the request\r\n   */\r\n  function cancelChainlinkRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    bytes4 callbackFunc,\r\n    uint256 expiration\r\n  )\r\n    internal\r\n  {\r\n    OperatorInterface requested = OperatorInterface(pendingRequests[requestId]);\r\n    delete pendingRequests[requestId];\r\n    emit ChainlinkCancelled(requestId);\r\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle address\r\n   * @param oracleAddress The address of the oracle contract\r\n   */\r\n  function setChainlinkOracle(\r\n    address oracleAddress\r\n  )\r\n    internal\r\n  {\r\n    oracle = OperatorInterface(oracleAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the LINK token address\r\n   * @param linkAddress The address of the LINK token contract\r\n   */\r\n  function setChainlinkToken(\r\n    address linkAddress\r\n  )\r\n    internal\r\n  {\r\n    link = LinkTokenInterface(linkAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the Chainlink token address for the public\r\n   * network as given by the Pointer contract\r\n   */\r\n  function setPublicChainlinkToken() \r\n    internal\r\n  {\r\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves the stored address of the LINK token\r\n   * @return The address of the LINK token\r\n   */\r\n  function chainlinkTokenAddress()\r\n    internal\r\n    view\r\n    returns (\r\n      address\r\n    )\r\n  {\r\n    return address(link);\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves the stored address of the oracle contract\r\n   * @return The address of the oracle contract\r\n   */\r\n  function chainlinkOracleAddress()\r\n    internal\r\n    view\r\n    returns (\r\n      address\r\n    )\r\n  {\r\n    return address(oracle);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows for a request which was created on another contract to be fulfilled\r\n   * on this contract\r\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\r\n   * @param requestId The request ID used for the response\r\n   */\r\n  function addChainlinkExternalRequest(\r\n    address oracleAddress,\r\n    bytes32 requestId\r\n  )\r\n    internal\r\n    notPendingRequest(requestId)\r\n  {\r\n    pendingRequests[requestId] = oracleAddress;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\r\n   * @dev Accounts for subnodes having different resolvers\r\n   * @param ensAddress The address of the ENS contract\r\n   * @param node The ENS node hash\r\n   */\r\n  function useChainlinkWithENS(\r\n    address ensAddress,\r\n    bytes32 node\r\n  )\r\n    internal\r\n  {\r\n    ens = ENSInterface(ensAddress);\r\n    ensNode = node;\r\n    bytes32 linkSubnode = keccak256(abi.encodePacked(ensNode, ENS_TOKEN_SUBNAME));\r\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(ens.resolver(linkSubnode));\r\n    setChainlinkToken(resolver.addr(linkSubnode));\r\n    updateChainlinkOracleWithENS();\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle contract with the address resolved by ENS\r\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\r\n   */\r\n  function updateChainlinkOracleWithENS()\r\n    internal\r\n  {\r\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(ensNode, ENS_ORACLE_SUBNAME));\r\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(ens.resolver(oracleSubnode));\r\n    setChainlinkOracle(resolver.addr(oracleSubnode));\r\n  }\r\n\r\n  /**\r\n   * @notice Ensures that the fulfillment is valid for this contract\r\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\r\n   * @param requestId The request ID for fulfillment\r\n   */\r\n  function validateChainlinkCallback(\r\n    bytes32 requestId\r\n  )\r\n    internal\r\n    recordChainlinkFulfillment(requestId)\r\n    // solhint-disable-next-line no-empty-blocks\r\n  {}\r\n\r\n  /**\r\n   * @dev Reverts if the sender is not the oracle of the request.\r\n   * Emits ChainlinkFulfilled event.\r\n   * @param requestId The request ID for fulfillment\r\n   */\r\n  modifier recordChainlinkFulfillment(\r\n    bytes32 requestId\r\n  )\r\n  {\r\n    require(msg.sender == pendingRequests[requestId],\r\n            \"Source must be the oracle of the request\");\r\n    delete pendingRequests[requestId];\r\n    emit ChainlinkFulfilled(requestId);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if the request is already pending\r\n   * @param requestId The request ID for fulfillment\r\n   */\r\n  modifier notPendingRequest(\r\n    bytes32 requestId\r\n  )\r\n  {\r\n    require(pendingRequests[requestId] == address(0), \"Request is already pending\");\r\n    _;\r\n  }\r\n}\r\n\r\n/******************************************/\r\n/*       IERC20 starts here               */\r\n/******************************************/\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/******************************************/\r\n/*          Context starts here           */\r\n/******************************************/\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/******************************************/\r\n/*           Ownable starts here          */\r\n/******************************************/\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/******************************************/\r\n/*       Benchmark starts here            */\r\n/******************************************/\r\n\r\nabstract contract Benchmark \r\n{\r\n    function rebase(uint256 supplyDelta, bool increaseSupply) external virtual returns (uint256);\r\n    \r\n    function totalSupply() external virtual view returns (uint256);\r\n}\r\n\r\n/******************************************/\r\n/*       BenchmarkSync starts here        */\r\n/******************************************/\r\n\r\nabstract contract Sync \r\n{\r\n    function syncPools() external virtual;\r\n}\r\n\r\n/******************************************/\r\n/*       KeeperRebase starts here         */\r\n/******************************************/\r\n\r\ncontract KeeperRebase is KeeperCompatibleInterface, ChainlinkClient, Ownable {\r\n\r\n    using Chainlink for Chainlink.Request;\r\n\r\n    uint256 public FEE = 1 * 10 ** 18;\r\n    bytes32 public JOBID = bytes32(\"2bde90044c644ac192cc015c9274d870\");\r\n    address public constant LINK = 0x514910771AF9Ca656af840dff83E8264EcF986CA;\r\n    address public constant ORACLE = 0x049Bd8C3adC3fE7d3Fc2a44541d955A537c2A484;\r\n    Benchmark public constant BENCHMARK = Benchmark(0x67c597624B17b16fb77959217360B7cD18284253);\r\n    Sync public SYNC = Sync(0x4C3aA5160aE34210CC5B783Cd642e4bAACF34b40);\r\n\r\n    uint256 public keeperInterval;\r\n    uint256 public lastRebase;\r\n    int256 public latestPrice;\r\n    int256 public targetPrice;\r\n    bool public rebaseActive;\r\n\r\n    event UpkeepPerformed();\r\n    event RebasePerformed(uint256 supplyDelta, bool increaseSupply);\r\n\r\n    constructor() {\r\n        setChainlinkToken(LINK);\r\n        setChainlinkOracle(ORACLE);\r\n        lastRebase = block.timestamp;\r\n    }\r\n    \r\n/******************************************/\r\n/*       Administration starts here       */\r\n/******************************************/\r\n\r\n    function setJobId(bytes32 _jobId) external onlyOwner {\r\n        JOBID = _jobId;\r\n    } \r\n    \r\n    function setFee(uint256 _fee) external onlyOwner {\r\n        FEE = _fee;\r\n    } \r\n\r\n    function setKeeperInterval(uint256 _interval) external onlyOwner {\r\n        keeperInterval = _interval;\r\n    } \r\n\r\n    function setTargetPrice(int256 _targetPrice) external onlyOwner {\r\n        targetPrice = _targetPrice;\r\n    } \r\n\r\n    function setSyncContract(address _sync) external onlyOwner {\r\n        SYNC = Sync(_sync);\r\n    }\r\n\r\n    function setRebaseActive(bool _active) external onlyOwner {\r\n        rebaseActive = _active;\r\n    }\r\n    \r\n/******************************************/\r\n/*       KeeperNetwork starts here        */\r\n/******************************************/\r\n\r\n    function checkUpkeep(bytes calldata checkData) external override returns (bool upkeepNeeded, bytes memory performData) {\r\n        upkeepNeeded = (block.timestamp - lastRebase) > keeperInterval;\r\n    }\r\n\r\n    function performUpkeep(bytes calldata performData) external override {\r\n        require((block.timestamp - lastRebase) > keeperInterval, \"Too soon.\");\r\n        lastRebase = block.timestamp;\r\n        initiateRebase();\r\n\r\n        emit UpkeepPerformed();\r\n    }\r\n\r\n/******************************************/\r\n/*        MARK Oracle starts here         */\r\n/******************************************/\r\n\r\n    function abs(int x) private pure returns (int) {\r\n        return x >= 0 ? x : -x;\r\n    }\r\n\r\n    function initiatePublicRebase() external {\r\n        IERC20(LINK).transferFrom(msg.sender, address(this), FEE);\r\n        initiateRebase();\r\n    }\r\n    \r\n    function initiateRebase() internal {\r\n        sendChainlinkRequest(buildChainlinkRequest(JOBID, address(this), this.rebaseCallback.selector), FEE);\r\n    }\r\n\r\n    function rebaseCallback(bytes32 _requestId, uint256 _price) external {\r\n        validateChainlinkCallback(_requestId);\r\n\r\n        latestPrice = int(_price);\r\n        int256 rebasePercentage = (latestPrice - targetPrice) * 1e18 / targetPrice;\r\n        uint256 absolutePercentage = uint256(abs(rebasePercentage));\r\n        uint256 supplyDelta = BENCHMARK.totalSupply() * absolutePercentage / 1e18;\r\n        bool increaseSupply = rebasePercentage >= 0 ? true : false;\r\n       \r\n        if (rebaseActive == true) {\r\n        BENCHMARK.rebase(supplyDelta, increaseSupply);\r\n        SYNC.syncPools();\r\n        }\r\n\r\n        emit RebasePerformed(supplyDelta, increaseSupply);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supplyDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"increaseSupply\",\"type\":\"bool\"}],\"name\":\"RebasePerformed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"UpkeepPerformed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BENCHMARK\",\"outputs\":[{\"internalType\":\"contract Benchmark\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"JOBID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LINK\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ORACLE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SYNC\",\"outputs\":[{\"internalType\":\"contract Sync\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiatePublicRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keeperInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRebase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"rebaseCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_jobId\",\"type\":\"bytes32\"}],\"name\":\"setJobId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_interval\",\"type\":\"uint256\"}],\"name\":\"setKeeperInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setRebaseActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sync\",\"type\":\"address\"}],\"name\":\"setSyncContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_targetPrice\",\"type\":\"int256\"}],\"name\":\"setTargetPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"KeeperRebase","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://30a4a5ca08165131bff915c011911863e0b1e9ee890c8d09153d259b96d8b4b8"}]}