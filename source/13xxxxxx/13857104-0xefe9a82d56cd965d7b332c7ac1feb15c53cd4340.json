{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/BatchDeposits.sol\": {\r\n      \"content\": \"\\n//                                                                           ,,---.\\n//                                                                         .-^^,_  `.\\n//                                                                    ;`, / 3 ( o\\\\   }\\n//         __             __                     ___              __  \\\\  ;   \\\\`, /  ,'\\n//        /\\\\ \\\\__         /\\\\ \\\\                  /'___\\\\ __         /\\\\ \\\\ ;_/^`.__.-\\\"  ,'\\n//    ____\\\\ \\\\ ,_\\\\    __  \\\\ \\\\ \\\\/'\\\\      __     /\\\\ \\\\__//\\\\_\\\\    ____\\\\ \\\\ \\\\___     `---'\\n//   /',__\\\\\\\\ \\\\ \\\\/  /'__`\\\\ \\\\ \\\\ , <    /'__`\\\\   \\\\ \\\\ ,__\\\\/\\\\ \\\\  /',__\\\\\\\\ \\\\  _ `\\\\\\n//  /\\\\__, `\\\\\\\\ \\\\ \\\\_/\\\\ \\\\L\\\\.\\\\_\\\\ \\\\ \\\\\\\\`\\\\ /\\\\  __/  __\\\\ \\\\ \\\\_/\\\\ \\\\ \\\\/\\\\__, `\\\\\\\\ \\\\ \\\\ \\\\ \\\\\\n//  \\\\/\\\\____/ \\\\ \\\\__\\\\ \\\\__/.\\\\_\\\\\\\\ \\\\_\\\\ \\\\_\\\\ \\\\____\\\\/\\\\_\\\\\\\\ \\\\_\\\\  \\\\ \\\\_\\\\/\\\\____/ \\\\ \\\\_\\\\ \\\\_\\\\\\n//   \\\\/___/   \\\\/__/\\\\/__/\\\\/_/ \\\\/_/\\\\/_/\\\\/____/\\\\/_/ \\\\/_/   \\\\/_/\\\\/___/   \\\\/_/\\\\/_/\\n//\\n// stakefish Eth2 Batch Deposit contract\\n//\\n// This contract allows deposit of multiple validators in one transaction\\n// SPDX-License-Identifier: Apache-2.0\\n\\n// Coinbase updates: remove fee collection, pausing and ownership\\n\\npragma solidity 0.6.11;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/introspection/IERC165.sol\\\";\\n\\n// Deposit contract interface\\ninterface IDepositContract {\\n    /// @notice A processed deposit event.\\n    event DepositEvent(\\n        bytes pubkey,\\n        bytes withdrawal_credentials,\\n        bytes amount,\\n        bytes signature,\\n        bytes index\\n    );\\n\\n    /// @notice Submit a Phase 0 DepositData object.\\n    /// @param pubkey A BLS12-381 public key.\\n    /// @param withdrawal_credentials Commitment to a public key for withdrawals.\\n    /// @param signature A BLS12-381 signature.\\n    /// @param deposit_data_root The SHA-256 hash of the SSZ-encoded DepositData object.\\n    /// Used as a protection against malformed input.\\n    function deposit(\\n        bytes calldata pubkey,\\n        bytes calldata withdrawal_credentials,\\n        bytes calldata signature,\\n        bytes32 deposit_data_root\\n    ) external payable;\\n\\n    /// @notice Query the current deposit root hash.\\n    /// @return The deposit root hash.\\n    function get_deposit_root() external view returns (bytes32);\\n\\n    /// @notice Query the current deposit count.\\n    /// @return The deposit count encoded as a little endian 64-bit number.\\n    function get_deposit_count() external view returns (bytes memory);\\n}\\n\\n/// @notice BatchDeposit is a contract to support creating multiple ETH2 deposits in a single transaction\\ncontract BatchDeposit {\\n    using SafeMath for uint256;\\n\\n    address immutable depositContract;\\n\\n    uint256 constant PUBKEY_LENGTH = 48;\\n    uint256 constant SIGNATURE_LENGTH = 96;\\n    uint256 constant CREDENTIALS_LENGTH = 32;\\n    uint256 constant MAX_VALIDATORS = 100;\\n    uint256 constant DEPOSIT_AMOUNT = 32 ether;\\n\\n    /**\\n     * @notice Creates a BatchDeposit contract\\n     * @param depositContractAddr Address of the underlying deposit contract\\n    */\\n    constructor(address depositContractAddr) public {\\n        require(IERC165(depositContractAddr).supportsInterface(type(IDepositContract).interfaceId), \\\"BatchDeposit: Invalid Deposit Contract\\\");\\n        depositContract = depositContractAddr;\\n    }\\n\\n    /**\\n     * @notice Performs a batch deposit\\n     * @param pubkeys Concatenation of multiple BLS12-381 public keys.\\n     * @param withdrawal_credentials Commitment to a public key for withdrawals.\\n     * @param signatures Concatenation of multiple BLS12-381 signature.\\n     * @param deposit_data_roots List of SHA-256 hashes of the SSZ-encoded DepositData object.\\n     */\\n    function batchDeposit(\\n        bytes calldata pubkeys,\\n        bytes calldata withdrawal_credentials,\\n        bytes calldata signatures,\\n        bytes32[] calldata deposit_data_roots\\n    )\\n        external payable\\n    {\\n        // sanity checks\\n        require(msg.value % 1 gwei == 0, \\\"BatchDeposit: Deposit value not multiple of GWEI\\\");\\n        require(msg.value >= DEPOSIT_AMOUNT, \\\"BatchDeposit: Amount is too low\\\");\\n\\n        uint256 count = deposit_data_roots.length;\\n        require(count > 0, \\\"BatchDeposit: You should deposit at least one validator\\\");\\n        require(count <= MAX_VALIDATORS, \\\"BatchDeposit: You can deposit max 100 validators at a time\\\");\\n\\n        require(pubkeys.length == count * PUBKEY_LENGTH, \\\"BatchDeposit: Pubkey count doesn't match\\\");\\n        require(signatures.length == count * SIGNATURE_LENGTH, \\\"BatchDeposit: Signatures count doesn't match\\\");\\n        require(withdrawal_credentials.length == 1 * CREDENTIALS_LENGTH, \\\"BatchDeposit: Withdrawal Credentials count doesn't match\\\");\\n\\n        uint256 expectedAmount = DEPOSIT_AMOUNT.mul(count);\\n        require(msg.value == expectedAmount, \\\"BatchDeposit: Amount is not aligned with number of pubkeys\\\");\\n\\n        for (uint256 i = 0; i < count; ++i) {\\n            bytes memory pubkey = bytes(pubkeys[i*PUBKEY_LENGTH:(i+1)*PUBKEY_LENGTH]);\\n            bytes memory signature = bytes(signatures[i*SIGNATURE_LENGTH:(i+1)*SIGNATURE_LENGTH]);\\n\\n            IDepositContract(depositContract).deposit{value: DEPOSIT_AMOUNT}(\\n                pubkey,\\n                withdrawal_credentials,\\n                signature,\\n                deposit_data_roots[i]\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"evmVersion\": \"byzantium\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositContractAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"pubkeys\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"withdrawal_credentials\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"deposit_data_roots\",\"type\":\"bytes32[]\"}],\"name\":\"batchDeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"BatchDeposit","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"00000000000000000000000000000000219ab540356cbb839cbe05303d7705fa","EVMVersion":"byzantium","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}