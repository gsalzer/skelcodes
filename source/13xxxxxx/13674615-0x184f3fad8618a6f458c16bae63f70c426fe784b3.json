{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n// File: libraries/SafeMath.sol\r\n\r\n\r\npragma solidity ^0.7.5;\r\n\r\n\r\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    // Only used in the  BondingCalculator.sol\r\n    function sqrrt(uint256 a) internal pure returns (uint c) {\r\n        if (a > 3) {\r\n            c = a;\r\n            uint b = add( div( a, 2), 1 );\r\n            while (b < c) {\r\n                c = b;\r\n                b = div( add( div( a, b ), b), 2 );\r\n            }\r\n        } else if (a != 0) {\r\n            c = 1;\r\n        }\r\n    }\r\n\r\n}\r\n// File: interfaces/IOlympusAuthority.sol\r\n\r\n\r\npragma solidity =0.7.5;\r\n\r\ninterface IOlympusAuthority {\r\n    /* ========== EVENTS ========== */\r\n    \r\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\r\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \r\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \r\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);    \r\n\r\n    event GovernorPulled(address indexed from, address indexed to);\r\n    event GuardianPulled(address indexed from, address indexed to);\r\n    event PolicyPulled(address indexed from, address indexed to);\r\n    event VaultPulled(address indexed from, address indexed to);\r\n\r\n    /* ========== VIEW ========== */\r\n    \r\n    function governor() external view returns (address);\r\n    function guardian() external view returns (address);\r\n    function policy() external view returns (address);\r\n    function vault() external view returns (address);\r\n}\r\n// File: types/OlympusAccessControlled.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\nabstract contract OlympusAccessControlled {\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event AuthorityUpdated(IOlympusAuthority indexed authority);\r\n\r\n    string UNAUTHORIZED = \"UNAUTHORIZED\"; // save gas\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    IOlympusAuthority public authority;\r\n\r\n\r\n    /* ========== Constructor ========== */\r\n\r\n    constructor(IOlympusAuthority _authority) {\r\n        authority = _authority;\r\n        emit AuthorityUpdated(_authority);\r\n    }\r\n    \r\n\r\n    /* ========== MODIFIERS ========== */\r\n    \r\n    modifier onlyGovernor() {\r\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyGuardian() {\r\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyPolicy() {\r\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n\r\n    modifier onlyVault() {\r\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\r\n        _;\r\n    }\r\n    \r\n    /* ========== GOV ONLY ========== */\r\n    \r\n    function setAuthority(IOlympusAuthority _newAuthority) external onlyGovernor {\r\n        authority = _newAuthority;\r\n        emit AuthorityUpdated(_newAuthority);\r\n    }\r\n}\r\n\r\n// File: interfaces/ITreasuryV1.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface ITreasuryV1 {\r\n    function withdraw(uint256 amount, address token) external;\r\n    function manage(address token, uint256 amount) external;\r\n    function valueOf(address token, uint256 amount) external view returns (uint256);\r\n    function excessReserves() external view returns (uint256);\r\n}\r\n// File: interfaces/IStakingV1.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface IStakingV1 {\r\n    function unstake(uint256 _amount, bool _trigger) external;\r\n\r\n    function index() external view returns (uint256);\r\n}\r\n// File: interfaces/IUniswapV2Router.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface IUniswapV2Router {\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function addLiquidity(\r\n        address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline\r\n        ) external returns (uint amountA, uint amountB, uint liquidity);\r\n        \r\n    function removeLiquidity(\r\n        address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline\r\n        ) external returns (uint amountA, uint amountB);\r\n}\r\n// File: interfaces/IOwnable.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\ninterface IOwnable {\r\n  function owner() external view returns (address);\r\n\r\n  function renounceManagement() external;\r\n  \r\n  function pushManagement( address newOwner_ ) external;\r\n  \r\n  function pullManagement() external;\r\n}\r\n// File: interfaces/IStaking.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface IStaking {\r\n    function stake(\r\n        address _to,\r\n        uint256 _amount,\r\n        bool _rebasing,\r\n        bool _claim\r\n    ) external returns (uint256);\r\n\r\n    function claim(address _recipient, bool _rebasing) external returns (uint256);\r\n\r\n    function forfeit() external returns (uint256);\r\n\r\n    function toggleLock() external;\r\n\r\n    function unstake(\r\n        address _to,\r\n        uint256 _amount,\r\n        bool _trigger,\r\n        bool _rebasing\r\n    ) external returns (uint256);\r\n\r\n    function wrap(address _to, uint256 _amount) external returns (uint256 gBalance_);\r\n\r\n    function unwrap(address _to, uint256 _amount) external returns (uint256 sBalance_);\r\n\r\n    function rebase() external;\r\n\r\n    function index() external view returns (uint256);\r\n\r\n    function contractBalance() external view returns (uint256);\r\n\r\n    function totalStaked() external view returns (uint256);\r\n\r\n    function supplyInWarmup() external view returns (uint256);\r\n}\r\n\r\n// File: interfaces/ITreasury.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface ITreasury {\r\n    function deposit(\r\n        uint256 _amount,\r\n        address _token,\r\n        uint256 _profit\r\n    ) external returns (uint256);\r\n\r\n    function withdraw(uint256 _amount, address _token) external;\r\n\r\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\r\n\r\n    function mint(address _recipient, uint256 _amount) external;\r\n\r\n    function manage(address _token, uint256 _amount) external;\r\n\r\n    function incurDebt(uint256 amount_, address token_) external;\r\n\r\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\r\n\r\n    function excessReserves() external view returns (uint256);\r\n}\r\n\r\n// File: interfaces/IERC20.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: libraries/SafeERC20.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\r\n/// Taken from Solmate\r\nlibrary SafeERC20 {\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(\r\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\r\n        );\r\n\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(\r\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\r\n        );\r\n\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        (bool success, bytes memory data) = address(token).call(\r\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\r\n        );\r\n\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"APPROVE_FAILED\");\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        (bool success, ) = to.call{value: amount}(new bytes(0));\r\n\r\n        require(success, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n}\r\n// File: interfaces/IgOHM.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\ninterface IgOHM is IERC20 {\r\n  function mint(address _to, uint256 _amount) external;\r\n\r\n  function burn(address _from, uint256 _amount) external;\r\n\r\n  function index() external view returns (uint256);\r\n\r\n  function balanceFrom(uint256 _amount) external view returns (uint256);\r\n\r\n  function balanceTo(uint256 _amount) external view returns (uint256);\r\n\r\n  function migrate( address _staking, address _sOHM ) external;\r\n}\r\n\r\n// File: interfaces/IwsOHM.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\n// Old wsOHM interface\r\ninterface IwsOHM is IERC20 {\r\n  function wrap(uint256 _amount) external returns (uint256);\r\n\r\n  function unwrap(uint256 _amount) external returns (uint256);\r\n\r\n  function wOHMTosOHM(uint256 _amount) external view returns (uint256);\r\n\r\n  function sOHMTowOHM(uint256 _amount) external view returns (uint256);\r\n}\r\n\r\n// File: interfaces/IsOHM.sol\r\n\r\n\r\npragma solidity >=0.7.5;\r\n\r\n\r\ninterface IsOHM is IERC20 {\r\n    function rebase( uint256 ohmProfit_, uint epoch_) external returns (uint256);\r\n\r\n    function circulatingSupply() external view returns (uint256);\r\n\r\n    function gonsForBalance( uint amount ) external view returns ( uint );\r\n\r\n    function balanceForGons( uint gons ) external view returns ( uint );\r\n\r\n    function index() external view returns ( uint );\r\n\r\n    function toG(uint amount) external view returns (uint);\r\n\r\n    function fromG(uint amount) external view returns (uint);\r\n\r\n     function changeDebt(\r\n        uint256 amount,\r\n        address debtor,\r\n        bool add\r\n    ) external;\r\n\r\n    function debtBalances(address _address) external view returns (uint256);\r\n}\r\n\r\n// File: gOHM.sol\r\n\r\n\r\npragma solidity 0.7.5;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract OlympusTokenMigrator is OlympusAccessControlled {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using SafeERC20 for IgOHM;\r\n    using SafeERC20 for IsOHM;\r\n    using SafeERC20 for IwsOHM;\r\n\r\n    /* ========== MIGRATION ========== */\r\n\r\n    event TimelockStarted(uint256 block, uint256 end);\r\n    event Migrated(address staking, address treasury);\r\n    event Funded(uint256 amount);\r\n    event Defunded(uint256 amount);\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    IERC20 public immutable oldOHM;\r\n    IsOHM public immutable oldsOHM;\r\n    IwsOHM public immutable oldwsOHM;\r\n    ITreasuryV1 public immutable oldTreasury;\r\n    IStakingV1 public immutable oldStaking;\r\n\r\n    IUniswapV2Router public immutable sushiRouter;\r\n    IUniswapV2Router public immutable uniRouter;\r\n\r\n    IgOHM public gOHM;\r\n    ITreasury public newTreasury;\r\n    IStaking public newStaking;\r\n    IERC20 public newOHM;\r\n\r\n    bool public ohmMigrated;\r\n    bool public shutdown;\r\n\r\n    uint256 public immutable timelockLength;\r\n    uint256 public timelockEnd;\r\n\r\n    uint256 public oldSupply;\r\n\r\n    constructor(\r\n        address _oldOHM,\r\n        address _oldsOHM,\r\n        address _oldTreasury,\r\n        address _oldStaking,\r\n        address _oldwsOHM,\r\n        address _sushi,\r\n        address _uni,\r\n        uint256 _timelock,\r\n        address _authority\r\n    ) OlympusAccessControlled(IOlympusAuthority(_authority)) {\r\n        require(_oldOHM != address(0), \"Zero address: OHM\");\r\n        oldOHM = IERC20(_oldOHM);\r\n        require(_oldsOHM != address(0), \"Zero address: sOHM\");\r\n        oldsOHM = IsOHM(_oldsOHM);\r\n        require(_oldTreasury != address(0), \"Zero address: Treasury\");\r\n        oldTreasury = ITreasuryV1(_oldTreasury);\r\n        require(_oldStaking != address(0), \"Zero address: Staking\");\r\n        oldStaking = IStakingV1(_oldStaking);\r\n        require(_oldwsOHM != address(0), \"Zero address: wsOHM\");\r\n        oldwsOHM = IwsOHM(_oldwsOHM);\r\n        require(_sushi != address(0), \"Zero address: Sushi\");\r\n        sushiRouter = IUniswapV2Router(_sushi);\r\n        require(_uni != address(0), \"Zero address: Uni\");\r\n        uniRouter = IUniswapV2Router(_uni);\r\n        timelockLength = _timelock;\r\n    }\r\n\r\n    /* ========== MIGRATION ========== */\r\n\r\n    enum TYPE {\r\n        UNSTAKED,\r\n        STAKED,\r\n        WRAPPED\r\n    }\r\n\r\n    // migrate OHMv1, sOHMv1, or wsOHM for OHMv2, sOHMv2, or gOHM\r\n    function migrate(\r\n        uint256 _amount,\r\n        TYPE _from,\r\n        TYPE _to\r\n    ) external {\r\n        require(!shutdown, \"Shut down\");\r\n\r\n        uint256 wAmount = oldwsOHM.sOHMTowOHM(_amount);\r\n\r\n        if (_from == TYPE.UNSTAKED) {\r\n            require(ohmMigrated, \"Only staked until migration\");\r\n            oldOHM.safeTransferFrom(msg.sender, address(this), _amount);\r\n        } else if (_from == TYPE.STAKED) {\r\n            oldsOHM.safeTransferFrom(msg.sender, address(this), _amount);\r\n        } else {\r\n            oldwsOHM.safeTransferFrom(msg.sender, address(this), _amount);\r\n            wAmount = _amount;\r\n        }\r\n\r\n        if (ohmMigrated) {\r\n            require(oldSupply >= oldOHM.totalSupply(), \"OHMv1 minted\");\r\n            _send(wAmount, _to);\r\n        } else {\r\n            gOHM.mint(msg.sender, wAmount);\r\n        }\r\n    }\r\n\r\n    // migrate all olympus tokens held\r\n    function migrateAll(TYPE _to) external {\r\n        require(!shutdown, \"Shut down\");\r\n\r\n        uint256 ohmBal = 0;\r\n        uint256 sOHMBal = oldsOHM.balanceOf(msg.sender);\r\n        uint256 wsOHMBal = oldwsOHM.balanceOf(msg.sender);\r\n\r\n        if (oldOHM.balanceOf(msg.sender) > 0 && ohmMigrated) {\r\n            ohmBal = oldOHM.balanceOf(msg.sender);\r\n            oldOHM.safeTransferFrom(msg.sender, address(this), ohmBal);\r\n        }\r\n        if (sOHMBal > 0) {\r\n            oldsOHM.safeTransferFrom(msg.sender, address(this), sOHMBal);\r\n        }\r\n        if (wsOHMBal > 0) {\r\n            oldwsOHM.safeTransferFrom(msg.sender, address(this), wsOHMBal);\r\n        }\r\n\r\n        uint256 wAmount = wsOHMBal.add(oldwsOHM.sOHMTowOHM(ohmBal.add(sOHMBal)));\r\n        if (ohmMigrated) {\r\n            require(oldSupply >= oldOHM.totalSupply(), \"OHMv1 minted\");\r\n            _send(wAmount, _to);\r\n        } else {\r\n            gOHM.mint(msg.sender, wAmount);\r\n        }\r\n    }\r\n\r\n    // send preferred token\r\n    function _send(uint256 wAmount, TYPE _to) internal {\r\n        if (_to == TYPE.WRAPPED) {\r\n            gOHM.safeTransfer(msg.sender, wAmount);\r\n        } else if (_to == TYPE.STAKED) {\r\n            newStaking.unwrap(msg.sender, wAmount);\r\n        } else if (_to == TYPE.UNSTAKED) {\r\n            newStaking.unstake(msg.sender, wAmount, false, false);\r\n        }\r\n    }\r\n\r\n    // bridge back to OHM, sOHM, or wsOHM\r\n    function bridgeBack(uint256 _amount, TYPE _to) external {\r\n        if (!ohmMigrated) {\r\n            gOHM.burn(msg.sender, _amount);\r\n        } else {\r\n            gOHM.safeTransferFrom(msg.sender, address(this), _amount);\r\n        }\r\n\r\n        uint256 amount = oldwsOHM.wOHMTosOHM(_amount);\r\n        // error throws if contract does not have enough of type to send\r\n        if (_to == TYPE.UNSTAKED) {\r\n            oldOHM.safeTransfer(msg.sender, amount);\r\n        } else if (_to == TYPE.STAKED) {\r\n            oldsOHM.safeTransfer(msg.sender, amount);\r\n        } else if (_to == TYPE.WRAPPED) {\r\n            oldwsOHM.safeTransfer(msg.sender, _amount);\r\n        }\r\n    }\r\n\r\n    /* ========== OWNABLE ========== */\r\n\r\n    // halt migrations (but not bridging back)\r\n    function halt() external onlyPolicy {\r\n        require(!ohmMigrated, \"Migration has occurred\");\r\n        shutdown = !shutdown;\r\n    }\r\n\r\n    // withdraw backing of migrated OHM\r\n    function defund(address reserve) external onlyGovernor {\r\n        require(ohmMigrated, \"Migration has not begun\");\r\n        require(timelockEnd < block.number && timelockEnd != 0, \"Timelock not complete\");\r\n\r\n        oldwsOHM.unwrap(oldwsOHM.balanceOf(address(this)));\r\n\r\n        uint256 amountToUnstake = oldsOHM.balanceOf(address(this));\r\n        oldsOHM.approve(address(oldStaking), amountToUnstake);\r\n        oldStaking.unstake(amountToUnstake, false);\r\n\r\n        uint256 balance = oldOHM.balanceOf(address(this));\r\n\r\n        if(balance > oldSupply) {\r\n            oldSupply = 0;\r\n        } else {\r\n            oldSupply -= balance;\r\n        }\r\n\r\n        uint256 amountToWithdraw = balance.mul(1e9);\r\n        oldOHM.approve(address(oldTreasury), amountToWithdraw);\r\n        oldTreasury.withdraw(amountToWithdraw, reserve);\r\n        IERC20(reserve).safeTransfer(address(newTreasury), IERC20(reserve).balanceOf(address(this)));\r\n\r\n        emit Defunded(balance);\r\n    }\r\n\r\n    // start timelock to send backing to new treasury\r\n    function startTimelock() external onlyGovernor {\r\n        require(timelockEnd == 0, \"Timelock set\");\r\n        timelockEnd = block.number.add(timelockLength);\r\n\r\n        emit TimelockStarted(block.number, timelockEnd);\r\n    }\r\n\r\n    // set gOHM address\r\n    function setgOHM(address _gOHM) external onlyGovernor {\r\n        require(address(gOHM) == address(0), \"Already set\");\r\n        require(_gOHM != address(0), \"Zero address: gOHM\");\r\n\r\n        gOHM = IgOHM(_gOHM);\r\n    }\r\n\r\n    // call internal migrate token function\r\n    function migrateToken(address token) external onlyGovernor {\r\n        _migrateToken(token, false);\r\n    }\r\n\r\n    /**\r\n     *   @notice Migrate LP and pair with new OHM\r\n     */\r\n    function migrateLP(\r\n        address pair,\r\n        bool sushi,\r\n        address token,\r\n        uint256 _minA,\r\n        uint256 _minB\r\n    ) external onlyGovernor {\r\n        uint256 oldLPAmount = IERC20(pair).balanceOf(address(oldTreasury));\r\n        oldTreasury.manage(pair, oldLPAmount);\r\n\r\n        IUniswapV2Router router = sushiRouter;\r\n        if (!sushi) {\r\n            router = uniRouter;\r\n        }\r\n\r\n        IERC20(pair).approve(address(router), oldLPAmount);\r\n        (uint256 amountA, uint256 amountB) = router.removeLiquidity(\r\n            token, \r\n            address(oldOHM), \r\n            oldLPAmount,\r\n            _minA, \r\n            _minB, \r\n            address(this), \r\n            block.timestamp\r\n        );\r\n\r\n        newTreasury.mint(address(this), amountB);\r\n\r\n        IERC20(token).approve(address(router), amountA);\r\n        newOHM.approve(address(router), amountB);\r\n\r\n        router.addLiquidity(\r\n            token, \r\n            address(newOHM), \r\n            amountA, \r\n            amountB, \r\n            amountA, \r\n            amountB, \r\n            address(newTreasury), \r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    // Failsafe function to allow owner to withdraw funds sent directly to contract in case someone sends non-ohm tokens to the contract\r\n    function withdrawToken(\r\n        address tokenAddress,\r\n        uint256 amount,\r\n        address recipient\r\n    ) external onlyGovernor {\r\n        require(tokenAddress != address(0), \"Token address cannot be 0x0\");\r\n        require(tokenAddress != address(gOHM), \"Cannot withdraw: gOHM\");\r\n        require(tokenAddress != address(oldOHM), \"Cannot withdraw: old-OHM\");\r\n        require(tokenAddress != address(oldsOHM), \"Cannot withdraw: old-sOHM\");\r\n        require(tokenAddress != address(oldwsOHM), \"Cannot withdraw: old-wsOHM\");\r\n        require(amount > 0, \"Withdraw value must be greater than 0\");\r\n        if (recipient == address(0)) {\r\n            recipient = msg.sender; // if no address is specified the value will will be withdrawn to Owner\r\n        }\r\n\r\n        IERC20 tokenContract = IERC20(tokenAddress);\r\n        uint256 contractBalance = tokenContract.balanceOf(address(this));\r\n        if (amount > contractBalance) {\r\n            amount = contractBalance; // set the withdrawal amount equal to balance within the account.\r\n        }\r\n        // transfer the token from address of this contract\r\n        tokenContract.safeTransfer(recipient, amount);\r\n    }\r\n\r\n    // migrate contracts\r\n    function migrateContracts(\r\n        address _newTreasury,\r\n        address _newStaking,\r\n        address _newOHM,\r\n        address _newsOHM,\r\n        address _reserve\r\n    ) external onlyGovernor {\r\n        require(!ohmMigrated, \"Already migrated\");\r\n        ohmMigrated = true;\r\n        shutdown = false;\r\n\r\n        require(_newTreasury != address(0), \"Zero address: Treasury\");\r\n        newTreasury = ITreasury(_newTreasury);\r\n        require(_newStaking != address(0), \"Zero address: Staking\");\r\n        newStaking = IStaking(_newStaking);\r\n        require(_newOHM != address(0), \"Zero address: OHM\");\r\n        newOHM = IERC20(_newOHM);\r\n\r\n        oldSupply = oldOHM.totalSupply(); // log total supply at time of migration\r\n\r\n        gOHM.migrate(_newStaking, _newsOHM); // change gOHM minter\r\n\r\n        _migrateToken(_reserve, true); // will deposit tokens into new treasury so reserves can be accounted for\r\n\r\n        _fund(oldsOHM.circulatingSupply()); // fund with current staked supply for token migration\r\n\r\n        emit Migrated(_newStaking, _newTreasury);\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    // fund contract with gOHM\r\n    function _fund(uint256 _amount) internal {\r\n        newTreasury.mint(address(this), _amount);\r\n        newOHM.approve(address(newStaking), _amount);\r\n        newStaking.stake(address(this), _amount, false, true); // stake and claim gOHM\r\n\r\n        emit Funded(_amount);\r\n    }\r\n\r\n    /**\r\n     *   @notice Migrate token from old treasury to new treasury\r\n     */\r\n    function _migrateToken(address token, bool deposit) internal {\r\n        uint256 balance = IERC20(token).balanceOf(address(oldTreasury));\r\n\r\n        uint256 excessReserves = oldTreasury.excessReserves();\r\n        uint256 tokenValue = oldTreasury.valueOf(token, balance);\r\n\r\n        if (tokenValue > excessReserves) {\r\n            tokenValue = excessReserves;\r\n            balance = excessReserves * 10**9;\r\n        }\r\n\r\n        oldTreasury.manage(token, balance);\r\n\r\n        if (deposit) {\r\n            IERC20(token).safeApprove(address(newTreasury), balance);\r\n            newTreasury.deposit(balance, token, tokenValue);\r\n        } else {\r\n            IERC20(token).safeTransfer(address(newTreasury), balance);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldOHM\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oldsOHM\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oldTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oldStaking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oldwsOHM\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sushi\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uni\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timelock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_authority\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IOlympusAuthority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Defunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Funded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staking\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"Migrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"TimelockStarted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"enum OlympusTokenMigrator.TYPE\",\"name\":\"_to\",\"type\":\"uint8\"}],\"name\":\"bridgeBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"}],\"name\":\"defund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gOHM\",\"outputs\":[{\"internalType\":\"contract IgOHM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"halt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"enum OlympusTokenMigrator.TYPE\",\"name\":\"_from\",\"type\":\"uint8\"},{\"internalType\":\"enum OlympusTokenMigrator.TYPE\",\"name\":\"_to\",\"type\":\"uint8\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum OlympusTokenMigrator.TYPE\",\"name\":\"_to\",\"type\":\"uint8\"}],\"name\":\"migrateAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTreasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newStaking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newOHM\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newsOHM\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"}],\"name\":\"migrateContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"sushi\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minB\",\"type\":\"uint256\"}],\"name\":\"migrateLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"migrateToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOHM\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newStaking\",\"outputs\":[{\"internalType\":\"contract IStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newTreasury\",\"outputs\":[{\"internalType\":\"contract ITreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ohmMigrated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldOHM\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldStaking\",\"outputs\":[{\"internalType\":\"contract IStakingV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldTreasury\",\"outputs\":[{\"internalType\":\"contract ITreasuryV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldsOHM\",\"outputs\":[{\"internalType\":\"contract IsOHM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldwsOHM\",\"outputs\":[{\"internalType\":\"contract IwsOHM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"_newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gOHM\",\"type\":\"address\"}],\"name\":\"setgOHM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shutdown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelockEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelockLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OlympusTokenMigrator","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000383518188c0c6d7730d91b2c03a03c837814a89900000000000000000000000004f2694c8fcee23e8fd0dfea1d4f5bb8c352111f00000000000000000000000031f8cc382c9898b273eff4e0b7626a6987c846e8000000000000000000000000fd31c7d00ca47653c6ce64af53c1571f9c36566a000000000000000000000000ca76543cf381ebbb277be79574059e32108e3e65000000000000000000000000d9e1ce17f2641f24ae83637ab66a2cca9c378b9f0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d0000000000000000000000000000000000000000000000000000000000001b580000000000000000000000001c21f8ea7e39e2ba00bc12d2968d63f4acb38b7a","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://b09b2af2a491d817278550a9f835a52946dfb113bad0ba1275e3732207f35e6d"}]}