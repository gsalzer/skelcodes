{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/DeusBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n// =================================================================================================================\\n//  _|_|_|    _|_|_|_|  _|    _|    _|_|_|      _|_|_|_|  _|                                                       |\\n//  _|    _|  _|        _|    _|  _|            _|            _|_|_|      _|_|_|  _|_|_|      _|_|_|    _|_|       |\\n//  _|    _|  _|_|_|    _|    _|    _|_|        _|_|_|    _|  _|    _|  _|    _|  _|    _|  _|        _|_|_|_|     |\\n//  _|    _|  _|        _|    _|        _|      _|        _|  _|    _|  _|    _|  _|    _|  _|        _|           |\\n//  _|_|_|    _|_|_|_|    _|_|    _|_|_|        _|        _|  _|    _|    _|_|_|  _|    _|    _|_|_|    _|_|_|     |\\n// =================================================================================================================\\n// ======================= DEUS Bridge ======================\\n// ==========================================================\\n// DEUS Finance: https://github.com/DeusFinance\\n\\n// Primary Author(s)\\n// Sadegh: https://github.com/sadeghte\\n// Reza: https://github.com/bakhshandeh\\n// Vahid: https://github.com/vahid-dev\\n// Mahdi: https://github.com/Mahdi-HF\\n\\nimport \\\"./IMuonV02.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\ninterface IERC20 {\\n\\tfunction transfer(address recipient, uint256 amount) external;\\n\\tfunction transferFrom(address sender, address recipient, uint256 amount) external;\\n\\tfunction pool_burn_from(address b_address, uint256 b_amount) external;\\n\\tfunction pool_mint(address m_address, uint256 m_amount) external;\\n}\\n\\ninterface IDEIStablecoin {\\n\\tfunction global_collateral_ratio() external view returns (uint256);\\n}\\n\\ncontract DeusBridge is Ownable, Pausable {\\n\\tusing ECDSA for bytes32;\\n\\n\\t/* ========== STATE VARIABLES ========== */\\n\\tstruct TX {\\n\\t\\tuint256 txId;\\n\\t\\tuint256 tokenId;\\n\\t\\tuint256 amount;\\n\\t\\tuint256 fromChain;\\n\\t\\tuint256 toChain;\\n\\t\\taddress user;\\n\\t\\tuint256 txBlockNo;\\n\\t}\\n\\n\\tuint256 public lastTxId = 0;  // unique id for deposit tx\\n\\tuint256 public network;  // current chain id\\n\\tuint256 public minReqSigs;  // minimum required tss\\n\\tuint256 public scale = 1e6;\\n\\tuint256 public bridgeReserve;  // it handles buyback & recollaterlize on dei pools\\n\\taddress public muonContract;  // muon signature verifier contract\\n\\taddress public deiAddress;\\n\\tbool    public mintable;  // use mint functions instead of transfer\\n\\tuint8   public ETH_APP_ID = 2;  // muon's eth app id\\n\\t// we assign a unique ID to each chain (default is CHAIN-ID)\\n\\tmapping (uint256 => address) public sideContracts;\\n\\t// tokenId => tokenContractAddress\\n\\tmapping(uint256 => address)  public tokens;\\n\\tmapping(uint256 => TX)       public txs;\\n\\t// user => (destination chain => user's txs id)\\n\\tmapping(address => mapping(uint256 => uint256[])) public userTxs;\\n\\t// source chain => (tx id => false/true)\\n\\tmapping(uint256 => mapping(uint256 => bool))      public claimedTxs;\\n\\t// chainId => confirmationBlock on sourceChain\\n\\tmapping(uint256 => uint256) \\t\\t\\t\\t\\t  public confirmationBlocks;\\n\\t// tokenId => tokenFee\\n\\tmapping(uint256 => uint256) \\t\\t\\t\\t\\t  public fee;\\n\\t// tokenId => collectedFee\\n\\tmapping(uint256 => uint256) \\t\\t\\t\\t\\t  public collectedFee;\\n\\t// tokenId => claimedFee\\n\\tmapping(uint256 => uint256) \\t\\t\\t\\t\\t  public claimedFee;\\n\\n\\n\\t/* ========== CONSTRUCTOR ========== */\\n\\n\\tconstructor(address _muon, bool _mintable, uint256 _minReqSigs, uint256 _bridgeReserve, address _deiAddress) {\\n\\t\\tnetwork = getExecutingChainID();\\n\\t\\tmintable = _mintable;\\n\\t\\tmuonContract = _muon;\\n\\t\\tminReqSigs = _minReqSigs;\\n\\t\\tbridgeReserve = _bridgeReserve;\\n\\t\\tdeiAddress = _deiAddress;\\n\\t}\\n\\n\\n\\t/* ========== PUBLIC FUNCTIONS ========== */\\n\\n\\tfunction deposit(\\n\\t\\tuint256 amount, \\n\\t\\tuint256 toChain,\\n\\t\\tuint256 tokenId\\n\\t) external returns (uint256 txId) {\\n\\t\\ttxId = _deposit(msg.sender, amount, toChain, tokenId);\\n\\t\\temit Deposit(msg.sender, tokenId, amount, toChain, txId);\\n\\t}\\n\\n\\tfunction depositFor(\\n\\t\\taddress user,\\n\\t\\tuint256 amount, \\n\\t\\tuint256 toChain,\\n\\t\\tuint256 tokenId\\n\\t) external returns (uint256 txId) {\\n\\t\\ttxId = _deposit(user, amount, toChain, tokenId);\\n\\t\\temit Deposit(user, tokenId, amount, toChain, txId);\\n\\t}\\n\\n\\tfunction deposit(\\n\\t\\tuint256 amount, \\n\\t\\tuint256 toChain,\\n\\t\\tuint256 tokenId,\\n\\t\\tuint256 referralCode\\n\\t) external returns (uint256 txId) {\\n\\t\\ttxId = _deposit(msg.sender, amount, toChain, tokenId);\\n\\t\\temit DepositWithReferralCode(msg.sender, tokenId, amount, toChain, txId, referralCode);\\n\\t}\\n\\n\\tfunction depositFor(\\n\\t\\taddress user,\\n\\t\\tuint256 amount, \\n\\t\\tuint256 toChain,\\n\\t\\tuint256 tokenId,\\n\\t\\tuint256 referralCode\\n\\t) external returns (uint256 txId) {\\n\\t\\ttxId = _deposit(user, amount, toChain, tokenId);\\n\\t\\temit DepositWithReferralCode(user, tokenId, amount, toChain, txId, referralCode);\\n\\t}\\n\\n\\tfunction _deposit(\\n\\t\\taddress user,\\n\\t\\tuint256 amount,\\n\\t\\tuint256 toChain,\\n\\t\\tuint256 tokenId\\n\\t) internal whenNotPaused() returns (uint256 txId) {\\n\\t\\trequire(sideContracts[toChain] != address(0), \\\"Bridge: unknown toChain\\\");\\n\\t\\trequire(toChain != network, \\\"Bridge: selfDeposit\\\");\\n\\t\\trequire(tokens[tokenId] != address(0), \\\"Bridge: unknown tokenId\\\");\\n\\n\\t\\tIERC20 token = IERC20(tokens[tokenId]);\\n\\t\\tif (mintable) {\\n\\t\\t\\ttoken.pool_burn_from(msg.sender, amount);\\n\\t\\t\\tif (tokens[tokenId] == deiAddress) {\\n\\t\\t\\t\\tbridgeReserve -= amount;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\ttoken.transferFrom(msg.sender, address(this), amount);\\n\\t\\t}\\n\\n\\t\\tif (fee[tokenId] > 0) {\\n\\t\\t\\tuint256 feeAmount = amount * fee[tokenId] / scale;\\n\\t\\t\\tamount -= feeAmount;\\n\\t\\t\\tcollectedFee[tokenId] += feeAmount;\\n\\t\\t}\\n\\n\\t\\ttxId = ++lastTxId;\\n\\t\\ttxs[txId] = TX({\\n\\t\\t\\ttxId: txId,\\n\\t\\t\\ttokenId: tokenId,\\n\\t\\t\\tfromChain: network,\\n\\t\\t\\ttoChain: toChain,\\n\\t\\t\\tamount: amount,\\n\\t\\t\\tuser: user,\\n\\t\\t\\ttxBlockNo: block.number\\n\\t\\t});\\n\\t\\tuserTxs[user][toChain].push(txId);\\n\\t}\\n\\n\\tfunction claim(\\n\\t\\taddress user,\\n\\t\\tuint256 amount,\\n\\t\\tuint256 fromChain,\\n\\t\\tuint256 toChain,\\n\\t\\tuint256 tokenId,\\n\\t\\tuint256 currentBlockNo,\\n\\t\\tuint256 txBlockNo,\\n\\t\\tuint256 txId,\\n\\t\\tbytes calldata _reqId,\\n\\t\\tSchnorrSign[] calldata sigs\\n\\t) public {\\n\\t\\trequire(sideContracts[fromChain] != address(0), 'Bridge: source contract not exist');\\n\\t\\trequire(toChain == network, \\\"Bridge: toChain should equal network\\\");\\n\\t\\trequire(sigs.length >= minReqSigs, \\\"Bridge: insufficient number of signatures\\\");\\n\\t\\trequire(currentBlockNo -  txBlockNo >= confirmationBlocks[fromChain], \\\"Bridge: confirmationBlock is not finished yet\\\");\\n\\n\\t\\t{\\n\\t\\t\\tbytes32 hash = keccak256(\\n\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\tabi.encodePacked(sideContracts[fromChain], txId, tokenId, amount),\\n\\t\\t\\t\\tabi.encodePacked(fromChain, toChain, user, txBlockNo, currentBlockNo, ETH_APP_ID)\\n\\t\\t\\t\\t)\\n\\t\\t\\t);\\n\\n\\t\\t\\tIMuonV02 muon = IMuonV02(muonContract);\\n\\t\\t\\trequire(muon.verify(_reqId, uint256(hash), sigs), \\\"Bridge: not verified\\\");\\n\\t\\t}\\n\\n\\t\\trequire(!claimedTxs[fromChain][txId], \\\"Bridge: already claimed\\\");\\n\\t\\trequire(tokens[tokenId] != address(0), \\\"Bridge: unknown tokenId\\\");\\n\\n\\t\\tIERC20 token = IERC20(tokens[tokenId]);\\n\\t\\tif (mintable) {\\n\\t\\t\\ttoken.pool_mint(user, amount);\\n\\t\\t\\tif (tokens[tokenId] == deiAddress) {\\n\\t\\t\\t\\tbridgeReserve += amount;\\n\\t\\t\\t}\\n\\t\\t} else { \\n\\t\\t\\ttoken.transfer(user, amount);\\n\\t\\t}\\n\\n\\t\\tclaimedTxs[fromChain][txId] = true;\\n\\t\\temit Claim(user, tokenId, amount, fromChain, txId);\\n\\t}\\n\\n\\n\\t/* ========== VIEWS ========== */\\n\\n\\t// This function use pool feature to handle buyback and recollateralize on DEI minter pool\\n\\tfunction collatDollarBalance(uint256 collat_usd_price) public view returns (uint256) {\\n\\t\\tuint collateralRatio = IDEIStablecoin(deiAddress).global_collateral_ratio();\\n\\t\\treturn bridgeReserve * collateralRatio / 1e6;\\n\\t}\\n\\n\\tfunction pendingTxs(\\n\\t\\tuint256 fromChain, \\n\\t\\tuint256[] calldata ids\\n\\t) public view returns (bool[] memory unclaimedIds) {\\n\\t\\tunclaimedIds = new bool[](ids.length);\\n\\t\\tfor(uint256 i=0; i < ids.length; i++){\\n\\t\\t\\tunclaimedIds[i] = claimedTxs[fromChain][ids[i]];\\n\\t\\t}\\n\\t}\\n\\n\\tfunction getUserTxs(\\n\\t\\taddress user, \\n\\t\\tuint256 toChain\\n\\t) public view returns (uint256[] memory) {\\n\\t\\treturn userTxs[user][toChain];\\n\\t}\\n\\n\\tfunction getTx(uint256 _txId) public view returns(\\n\\t\\tuint256 txId,\\n\\t\\tuint256 tokenId,\\n\\t\\tuint256 amount,\\n\\t\\tuint256 fromChain,\\n\\t\\tuint256 toChain,\\n\\t\\taddress user,\\n\\t\\tuint256 txBlockNo,\\n\\t\\tuint256 currentBlockNo\\n\\t){\\n\\t\\ttxId = txs[_txId].txId;\\n\\t\\ttokenId = txs[_txId].tokenId;\\n\\t\\tamount = txs[_txId].amount;\\n\\t\\tfromChain = txs[_txId].fromChain;\\n\\t\\ttoChain = txs[_txId].toChain;\\n\\t\\tuser = txs[_txId].user;\\n\\t\\ttxBlockNo = txs[_txId].txBlockNo;\\n\\t\\tcurrentBlockNo = block.number;\\n\\t}\\n\\n\\tfunction getExecutingChainID() public view returns (uint256) {\\n\\t\\tuint256 id;\\n\\t\\tassembly {\\n\\t\\t\\tid := chainid()\\n\\t\\t}\\n\\t\\treturn id;\\n\\t}\\n\\n\\n\\t/* ========== RESTRICTED FUNCTIONS ========== */\\n\\n\\tfunction setBridgeReserve(uint _bridgeReserve) external onlyOwner {\\n\\t\\temit BridgeReserveSet(bridgeReserve, _bridgeReserve);\\n\\n\\t\\tbridgeReserve = _bridgeReserve;\\n\\t}\\n\\n\\tfunction setToken(uint256 tokenId, address tokenAddress) external onlyOwner {\\n\\t\\ttokens[tokenId] = tokenAddress;\\n\\t}\\n\\n\\tfunction setConfirmationBlock(uint256 chainId, uint256 confirmationBlock) external onlyOwner {\\n\\t\\tconfirmationBlocks[chainId] = confirmationBlock;\\n\\t}\\n\\n\\tfunction setNetworkID(uint256 _network) external onlyOwner {\\n\\t\\tnetwork = _network;\\n\\t\\tdelete sideContracts[network];\\n\\t}\\n\\n\\tfunction setFee(uint256 tokenId, uint256 _fee) external onlyOwner {\\n\\t\\tfee[tokenId] = _fee;\\n\\t}\\n\\t\\n\\tfunction setDeiAddress(address _deiAddress) external onlyOwner {\\n\\t\\tdeiAddress = _deiAddress;\\n\\t}\\n\\n\\tfunction setMinReqSigs(uint256 _minReqSigs) external onlyOwner {\\n\\t\\tminReqSigs = _minReqSigs;\\n\\t}\\n\\n\\tfunction setSideContract(uint256 _network, address _addr) external onlyOwner {\\n\\t\\trequire (network != _network, 'Bridge: current network');\\n\\t\\tsideContracts[_network] = _addr;\\n\\t}\\n\\n\\tfunction setMintable(bool _mintable) external onlyOwner {\\n\\t\\tmintable = _mintable;\\n\\t}\\n\\n\\tfunction setEthAppId(uint8 _ethAppId) external onlyOwner {\\n\\t\\tETH_APP_ID = _ethAppId;\\n\\t}\\n\\n\\tfunction setMuonContract(address _muonContract) external onlyOwner {\\n\\t\\tmuonContract = _muonContract;\\n\\t}\\n\\n\\tfunction pause() external onlyOwner {\\n\\t\\tsuper._pause();\\n\\t}\\n\\n\\tfunction unpase() external onlyOwner {\\n\\t\\tsuper._unpause();\\n\\t}\\n\\n\\tfunction withdrawFee(uint256 tokenId, address addr) external onlyOwner {\\n\\t\\trequire(collectedFee[tokenId] > 0, \\\"Bridge: No fee to collect\\\");\\n\\t\\tIERC20(tokens[tokenId]).pool_mint(addr, collectedFee[tokenId]);\\n\\t\\tclaimedFee[tokenId] += collectedFee[tokenId];\\n\\t\\tcollectedFee[tokenId] = 0;\\n\\t}\\n\\n\\tfunction emergencyWithdrawETH(uint256 amount, address addr) external onlyOwner {\\n\\t\\trequire(addr != address(0));\\n\\t\\tpayable(addr).transfer(amount);\\n\\t}\\n\\n\\tfunction emergencyWithdrawERC20Tokens(address _tokenAddr, address _to, uint _amount) external onlyOwner {\\n\\t\\tIERC20(_tokenAddr).transfer(_to, _amount);\\n\\t}\\n\\n\\t/* ========== EVENTS ========== */\\n\\tevent Deposit(\\n\\t\\taddress indexed user,\\n\\t\\tuint256 tokenId,\\n\\t\\tuint256 amount,\\n\\t\\tuint256 indexed toChain,\\n\\t\\tuint256 txId\\n\\t);\\n\\n\\tevent DepositWithReferralCode(\\n\\t\\taddress indexed user,\\n\\t\\tuint256 tokenId,\\n\\t\\tuint256 amount,\\n\\t\\tuint256 indexed toChain,\\n\\t\\tuint256 txId,\\n\\t\\tuint256 referralCode\\n\\t);\\n\\n\\tevent Claim(\\n\\t\\taddress indexed user,\\n\\t\\tuint256 tokenId, \\n\\t\\tuint256 amount, \\n\\t\\tuint256 indexed fromChain, \\n\\t\\tuint256 txId\\n\\t);\\n\\n\\tevent BridgeReserveSet(uint256 bridgeReserve, uint256 _bridgeReserve);\\n}\\n\"\r\n    },\r\n    \"/contracts/IMuonV02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\nstruct SchnorrSign {\\n    uint256 signature;\\n    address owner;\\n    address nonce;\\n}\\n\\ninterface IMuonV02{\\n    function verify(bytes calldata reqId, uint256 hash, SchnorrSign[] calldata _sigs) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n        } else if (signature.length == 64) {\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                let vs := mload(add(signature, 0x40))\\n                r := mload(add(signature, 0x20))\\n                s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n                v := add(shr(255, vs), 27)\\n            }\\n        } else {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor () {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_muon\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_mintable\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_minReqSigs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bridgeReserve\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_deiAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bridgeReserve\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_bridgeReserve\",\"type\":\"uint256\"}],\"name\":\"BridgeReserveSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromChain\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"txId\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"toChain\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"txId\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"toChain\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"txId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referralCode\",\"type\":\"uint256\"}],\"name\":\"DepositWithReferralCode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ETH_APP_ID\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromChain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toChain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentBlockNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txBlockNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"txId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_reqId\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"signature\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nonce\",\"type\":\"address\"}],\"internalType\":\"struct SchnorrSign[]\",\"name\":\"sigs\",\"type\":\"tuple[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimedFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimedTxs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collat_usd_price\",\"type\":\"uint256\"}],\"name\":\"collatDollarBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collectedFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"confirmationBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deiAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toChain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"txId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toChain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralCode\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"txId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toChain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"depositFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"txId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toChain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralCode\",\"type\":\"uint256\"}],\"name\":\"depositFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"txId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdrawERC20Tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"emergencyWithdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExecutingChainID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_txId\",\"type\":\"uint256\"}],\"name\":\"getTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"txId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromChain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toChain\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"txBlockNo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentBlockNo\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"toChain\",\"type\":\"uint256\"}],\"name\":\"getUserTxs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTxId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minReqSigs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"muonContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"network\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromChain\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"pendingTxs\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"unclaimedIds\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bridgeReserve\",\"type\":\"uint256\"}],\"name\":\"setBridgeReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"confirmationBlock\",\"type\":\"uint256\"}],\"name\":\"setConfirmationBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_deiAddress\",\"type\":\"address\"}],\"name\":\"setDeiAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_ethAppId\",\"type\":\"uint8\"}],\"name\":\"setEthAppId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minReqSigs\",\"type\":\"uint256\"}],\"name\":\"setMinReqSigs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_mintable\",\"type\":\"bool\"}],\"name\":\"setMintable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_muonContract\",\"type\":\"address\"}],\"name\":\"setMuonContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_network\",\"type\":\"uint256\"}],\"name\":\"setNetworkID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_network\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setSideContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sideContracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"txs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"txId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fromChain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toChain\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"txBlockNo\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userTxs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"withdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DeusBridge","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"000000000000000000000000e4f8d9a30936a6f8b17a73dc6feb51a3bbabd51a000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000422ca8b0a00a425000000000000000000000000000000de12c7959e1a72bbe8a5f7a1dc8f8eef9ab011b3","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}