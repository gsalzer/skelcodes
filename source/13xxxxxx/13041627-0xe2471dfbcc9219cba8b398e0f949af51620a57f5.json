{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/facets/DiamondCutFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"diamond-libraries/contracts/libraries/LibDiamond.sol\\\";\\nimport \\\"diamond-libraries/contracts/libraries/LibOwnership.sol\\\";\\n\\ncontract DiamondCutFacet is IDiamondCut {\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external override {\\n        LibOwnership.enforceIsContractOwner();\\n\\n        uint256 selectorCount =\\n            LibDiamondStorage.diamondStorage().selectors.length;\\n        for (\\n            uint256 facetIndex;\\n            facetIndex < _diamondCut.length;\\n            facetIndex++\\n        ) {\\n            FacetCut memory cut;\\n            cut.action = _diamondCut[facetIndex].action;\\n            cut.facetAddress = _diamondCut[facetIndex].facetAddress;\\n            cut.functionSelectors = _diamondCut[facetIndex].functionSelectors;\\n\\n            selectorCount = LibDiamond.executeDiamondCut(selectorCount, cut);\\n        }\\n\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n\\n        LibDiamond.initializeDiamondCut(_init, _calldata);\\n    }\\n}\\n\"\r\n    },\r\n    \"diamond-libraries/contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/IDiamondCut.sol\\\";\\nimport \\\"./LibDiamondStorage.sol\\\";\\n\\nlibrary LibDiamond {\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    // This code is almost the same as the external diamondCut,\\n    // except it is using 'Facet[] memory _diamondCut' instead of\\n    // 'Facet[] calldata _diamondCut'.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for a two dimensional array.\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        uint256 selectorCount = LibDiamondStorage.diamondStorage().selectors.length;\\n\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            selectorCount = executeDiamondCut(selectorCount, _diamondCut[facetIndex]);\\n        }\\n\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    // executeDiamondCut takes one single FacetCut action and executes it\\n    // if FacetCutAction can't be identified, it reverts\\n    function executeDiamondCut(uint256 selectorCount, IDiamondCut.FacetCut memory cut) internal returns (uint256) {\\n        require(cut.functionSelectors.length > 0, \\\"LibDiamond: No selectors in facet to cut\\\");\\n\\n        if (cut.action == IDiamondCut.FacetCutAction.Add) {\\n            require(cut.facetAddress != address(0), \\\"LibDiamond: add facet address can't be address(0)\\\");\\n            enforceHasContractCode(cut.facetAddress, \\\"LibDiamond: add facet must have code\\\");\\n\\n            return _handleAddCut(selectorCount, cut);\\n        }\\n\\n        if (cut.action == IDiamondCut.FacetCutAction.Replace) {\\n            require(cut.facetAddress != address(0), \\\"LibDiamond: remove facet address can't be address(0)\\\");\\n            enforceHasContractCode(cut.facetAddress, \\\"LibDiamond: remove facet must have code\\\");\\n\\n            return _handleReplaceCut(selectorCount, cut);\\n        }\\n\\n        if (cut.action == IDiamondCut.FacetCutAction.Remove) {\\n            require(cut.facetAddress == address(0), \\\"LibDiamond: remove facet address must be address(0)\\\");\\n\\n            return _handleRemoveCut(selectorCount, cut);\\n        }\\n\\n        revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n    }\\n\\n    // _handleAddCut executes a cut with the type Add\\n    // it reverts if the selector already exists\\n    function _handleAddCut(uint256 selectorCount, IDiamondCut.FacetCut memory cut) internal returns (uint256) {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n\\n        for (uint256 selectorIndex; selectorIndex < cut.functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = cut.functionSelectors[selectorIndex];\\n\\n            address oldFacetAddress = ds.facets[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n\\n            ds.facets[selector] = LibDiamondStorage.Facet(\\n                cut.facetAddress,\\n                uint16(selectorCount)\\n            );\\n            ds.selectors.push(selector);\\n\\n            selectorCount++;\\n        }\\n\\n        return selectorCount;\\n    }\\n\\n    // _handleReplaceCut executes a cut with the type Replace\\n    // it does not allow replacing immutable functions\\n    // it does not allow replacing with the same function\\n    // it does not allow replacing a function that does not exist\\n    function _handleReplaceCut(uint256 selectorCount, IDiamondCut.FacetCut memory cut) internal returns (uint256) {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n\\n        for (uint256 selectorIndex; selectorIndex < cut.functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = cut.functionSelectors[selectorIndex];\\n\\n            address oldFacetAddress = ds.facets[selector].facetAddress;\\n\\n            // only useful if immutable functions exist\\n            require(oldFacetAddress != address(this), \\\"LibDiamondCut: Can't replace immutable function\\\");\\n            require(oldFacetAddress != cut.facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            require(oldFacetAddress != address(0), \\\"LibDiamondCut: Can't replace function that doesn't exist\\\");\\n\\n            // replace old facet address\\n            ds.facets[selector].facetAddress = cut.facetAddress;\\n        }\\n\\n        return selectorCount;\\n    }\\n\\n    // _handleRemoveCut executes a cut with the type Remove\\n    // for efficiency, the selector to be deleted is replaced with the last one and then the last one is popped\\n    // it reverts if the function doesn't exist or it's immutable\\n    function _handleRemoveCut(uint256 selectorCount, IDiamondCut.FacetCut memory cut) internal returns (uint256) {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n\\n        for (uint256 selectorIndex; selectorIndex < cut.functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = cut.functionSelectors[selectorIndex];\\n\\n            LibDiamondStorage.Facet memory oldFacet = ds.facets[selector];\\n\\n            require(oldFacet.facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n            require(oldFacet.facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function.\\\");\\n\\n            // replace selector with last selector\\n            if (oldFacet.selectorPosition != selectorCount - 1) {\\n                bytes4 lastSelector = ds.selectors[selectorCount - 1];\\n                ds.selectors[oldFacet.selectorPosition] = lastSelector;\\n                ds.facets[lastSelector].selectorPosition = oldFacet.selectorPosition;\\n            }\\n\\n            // delete last selector\\n            ds.selectors.pop();\\n            delete ds.facets[selector];\\n\\n            selectorCount--;\\n        }\\n\\n        return selectorCount;\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but _calldata is not empty\\\");\\n            return;\\n        }\\n\\n        require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n        if (_init != address(this)) {\\n            enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n        }\\n\\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n        if (!success) {\\n            if (error.length > 0) {\\n                // bubble up the error\\n                revert(string(error));\\n            } else {\\n                revert(\\\"LibDiamondCut: _init function reverted\\\");\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\r\n    },\r\n    \"diamond-libraries/contracts/libraries/LibOwnership.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./LibDiamondStorage.sol\\\";\\n\\nlibrary LibOwnership {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\\n\\n        address previousOwner = ds.contractOwner;\\n        require(previousOwner != _newOwner, \\\"Previous owner and new owner must be different\\\");\\n\\n        ds.contractOwner = _newOwner;\\n\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = LibDiamondStorage.diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() view internal {\\n        require(msg.sender == LibDiamondStorage.diamondStorage().contractOwner, \\\"Must be contract owner\\\");\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == LibDiamondStorage.diamondStorage().contractOwner, \\\"Must be contract owner\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"diamond-libraries/contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"diamond-libraries/contracts/libraries/LibDiamondStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nlibrary LibDiamondStorage {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct Facet {\\n        address facetAddress;\\n        uint16 selectorPosition;\\n    }\\n\\n    struct DiamondStorage {\\n        // function selector => facet address and selector position in selectors array\\n        mapping(bytes4 => Facet) facets;\\n        bytes4[] selectors;\\n\\n        // ERC165\\n        mapping(bytes4 => bool) supportedInterfaces;\\n\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"diamondCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DiamondCutFacet","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}