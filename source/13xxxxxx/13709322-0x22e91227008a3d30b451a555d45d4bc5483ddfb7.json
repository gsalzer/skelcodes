{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BrincToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Snapshot.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./Curve/interfaces/ICurve.sol\\\";\\n\\ncontract BrincToken is ERC20, ERC20Burnable, ERC20Snapshot, ERC20Pausable, Ownable {\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event BuyTaxRateChanged(uint256 oldRate, uint256 newRate);\\n    event SellTaxRateChanged(uint256 oldRate, uint256 newRate);\\n    event BuyTaxScaleChanged(uint256 oldScale, uint256 newScale);\\n    event SellTaxScaleChanged(uint256 oldScale, uint256 newScale);\\n\\n    IERC20 private _reserveAsset;\\n    uint32 private _fixedReserveRatio;\\n    uint256 private _buyTaxRate;\\n    uint256 private _buyTaxScale;\\n    uint256 private _sellTaxRate;\\n    uint256 private _sellTaxScale;\\n    ICurve private _curveAddress;\\n\\n\\n    /**\\n     * @dev given a token supply, reserve balance, weight and a deposit amount (in the reserve token),\\n     * calculates the target amount for a given conversion (in the main token)\\n     *\\n     * Formula:\\n     * return = _supply * ((1 + _amount / _reserveBalance) ^ (_reserveWeight / 1000000) - 1)\\n     *\\n     * @param name             curve token name\\n     * @param symbol           curve token symbol\\n     * @param reserveAsset     reserve asset address\\n     * @param buyTaxRate       value between 1 & 100 for owner revenue on mint/buy\\n     * @param sellTaxRate      value between 1 & 100 for owner revenue on burn/sell\\n     * @param reserveRatio     reserve ratio, represented in ppm (2-2000000)\\n     * @param curveAddress     address of the curve formula instance\\n     */\\n    constructor (\\n        string memory name,\\n        string memory symbol,\\n        address reserveAsset,\\n        uint256 buyTaxRate,\\n        uint256 buyTaxScale,\\n        uint256 sellTaxRate,\\n        uint256 sellTaxScale,\\n        uint32 reserveRatio,\\n        address curveAddress\\n    ) public ERC20(name, symbol) {\\n        require(reserveAsset != address(0), \\\"BrincToken:constructor:Reserve asset invalid\\\");\\n        require(buyTaxRate > 0, \\\"BrincToken:constructor:Buy tax rate cant be 0%\\\");\\n        require(buyTaxRate <= 100, \\\"BrincToken:constructor:Buy tax rate cant be more than 100%\\\");\\n        require(sellTaxRate > 0, \\\"BrincToken:constructor:Sell tax rate cant be 0%\\\");\\n        require(sellTaxRate <= 100, \\\"BrincToken:constructor:Sell tax rate cant be more than 100%\\\");\\n        require(buyTaxScale >= 100, \\\"Buy tax scale can't be < 100\\\");\\n        require(buyTaxScale <= 100000, \\\"Buy tax scale can't be > 100 000\\\");\\n        require(sellTaxScale >= 100, \\\"Sell tax scale can't be < 100\\\");\\n        require(sellTaxScale <= 100000, \\\"Buy tax scale can't be > 100 000\\\");\\n        _fixedReserveRatio = reserveRatio;\\n        _buyTaxRate = buyTaxRate;\\n        _buyTaxScale = buyTaxScale;\\n        _sellTaxRate = sellTaxRate;\\n        _sellTaxScale = sellTaxScale;\\n        _reserveAsset = IERC20(reserveAsset);\\n        _curveAddress = ICurve(curveAddress);\\n    }\\n\\n    /**\\n     * @dev address of the underlining reserve asset\\n     *\\n     * @return reserveAssetAddress\\n     */\\n    /// #if_succeeds {:msg \\\"Returns reserveAssetAddress\\\"}\\n        /// $result == address(_reserveAsset);\\n    function reserveAsset() public view returns (address) {\\n        return address(_reserveAsset);\\n    }\\n\\n    /**\\n     * @dev curve forumla instance address\\n     *\\n     * @return curveAddress\\n     */\\n    /// #if_succeeds  {:msg \\\"Returns curveAddress\\\"}\\n        /// $result == address(_curveAddress);\\n    function curveAddress() public view returns (address) {\\n        return address(_curveAddress);\\n    }\\n\\n    /**\\n     * @dev reserve ratio set for the curve formula\\n     *\\n     * @return reserveRatio\\n     */\\n    /// #if_succeeds  {:msg \\\"Returns reserveRatio\\\"}\\n        /// $result == _fixedReserveRatio;\\n    function reserveRatio() public view returns (uint32) {\\n        return _fixedReserveRatio;\\n    }\\n\\n    // Tax\\n    /**\\n     * @dev tax rate specified to direct reserve assets to owner on mint/buy\\n     *\\n     * @return buyTaxRate\\n     */\\n    /// #if_succeeds  {:msg \\\"Returns taxRate\\\"}\\n        /// $result == _buyTaxRate;\\n    function buyTaxRate() public view returns (uint256) {\\n        return _buyTaxRate;\\n    }\\n\\n    /**\\n     * @dev Buy Tax Scale.\\n     * If buyTaxScale = 100 and buyTaxRate = 1, buyTax will effectively be 1%\\n     * If buyTaxScale = 1000 and buyTaxRate = 1, buyTax will effectively be 0.1%\\n     *\\n     * @return buyTaxScale\\n     */\\n    /// #if_succeeds {:msg \\\"Returns buyTaxScale\\\"}\\n        /// $result == _buyTaxScale;\\n    function buyTaxScale() public view returns (uint256) {\\n        return _buyTaxScale;\\n    }\\n\\n    /**\\n     * @dev tax rate specified to direct reserve assets to owner on burn/sell\\n     *\\n     * @return sellTaxRate\\n     */\\n    /// #if_succeeds {:msg \\\"Returns sellTaxRate\\\"}\\n        /// $result == _sellTaxRate;\\n    function sellTaxRate() public view returns (uint256) {\\n        return _sellTaxRate;\\n    }\\n\\n    /**\\n     * @dev Sell Tax Scale.\\n     * If sellTaxScale = 100 and sellTaxRate = 1, sellTax will effectively be 1%\\n     * If sellTaxScale = 1000 and sellTaxRate = 1, sellTax will effectively be 0.1%\\n     *\\n     * @return sellTaxScale\\n     */\\n    /// #if_succeeds {:msg \\\"Returns sellTaxScale\\\"}\\n        /// $result == _sellTaxScale;\\n    function sellTaxScale() public view returns (uint256) {\\n        return _sellTaxScale;\\n    }\\n\\n    // Curve\\n    /**\\n     * @dev calculates the cost to mint a specified amount of collateral tokens\\n     *\\n     * @param amount tokens to mint\\n     *\\n     * @return cost\\n     */\\n    /// #if_succeeds {:msg \\\"Returns correct mintCost\\\"}\\n        /// $result == fundCost(totalSupply(), _reserveAsset.balanceOf(address(this)), _fixedReserveRatio, amount);\\n    function mintCost(uint256 amount) public view returns(uint256) {\\n        uint256 reserveBalance = _reserveAsset.balanceOf(address(this));\\n        return fundCost(totalSupply(), reserveBalance, _fixedReserveRatio, amount);\\n    }\\n\\n    /**\\n     * @dev calculates the reward for burning specified amount of curve tokens\\n     *\\n     * @param amount tokens to burn\\n     *\\n     * @return reward\\n     */\\n    /// #if_succeeds  {:msg \\\"Returns burnReward\\\"}\\n        /// $result == liquidateReserveAmount(totalSupply(), _reserveAsset.balanceOf(address(this)), _fixedReserveRatio, amount);\\n    function burnReward(uint256 amount) public view returns(uint256) {\\n        uint256 reserveBalance = _reserveAsset.balanceOf(address(this));\\n        return liquidateReserveAmount(totalSupply(), reserveBalance, _fixedReserveRatio, amount);\\n    }\\n\\n    /**\\n     * @dev initialises the curve, the total supply needs to be more than zero for\\n     * the curve to be calculated\\n     *\\n     * @param _firstReserve          initial reserve token\\n     * @param _firstSupply           initial supply of curve tokens\\n     */\\n    /// #if_succeeds {:msg \\\"The sender must be Owner\\\"}\\n        /// old(msg.sender == this.owner());\\n    /// #if_succeeds {:msg \\\"The owner to hold initial minted token\\\"}\\n        /// this.balanceOf(msg.sender) == _firstSupply;\\n    /// #if_succeeds {:msg \\\"The contract should have the correct intial reserve amount\\\"}\\n        /// _reserveAsset.balanceOf(address(this)) == _firstReserve;\\n    function init(uint256 _firstReserve, uint256 _firstSupply) external onlyOwner {\\n        require(totalSupply() == 0, \\\"BrincToken:init:already minted\\\");\\n        require(_reserveAsset.balanceOf(address(this)) == 0, \\\"BrincToken:init:non-zero reserve asset balance\\\");\\n        require(_reserveAsset.transferFrom(_msgSender(), address(this), _firstReserve), \\\"BrincToken:init:Reserve asset transfer failed\\\");\\n        _mint(_msgSender(), _firstSupply);\\n\\t}\\n\\n    /**\\n     * @dev sets the tax rate stored in the buyTaxRate variable\\n     *\\n     * @param _rate                    new tax rate in percentage (integer between 1 and 100)\\n     */\\n    /// #if_succeeds {:msg \\\"The sender must be Owner\\\"}\\n        /// old(msg.sender == this.owner());\\n    /// #if_succeeds {:msg \\\"The buyTaxRate was set properly\\\"}\\n        /// _buyTaxRate == _rate;\\n    function setBuyTaxRate(uint256 _rate) external onlyOwner {\\n        require(_rate <= 100 && _rate >= 0, \\\"BrincToken:setTax:invalid tax rate (1:100)\\\");\\n        uint256 oldRate = _buyTaxRate;\\n        _buyTaxRate = _rate;\\n        emit BuyTaxRateChanged(oldRate, _buyTaxRate);\\n    }\\n\\n    /**\\n     * @dev sets the buy tax scale stored in the buyTaxScale variable\\n     *\\n     * @param _scale new tax scale (integer between 100 and 100000)\\n     */\\n    /// #if_succeeds {:msg \\\"The sender must be Owner\\\"}\\n        /// old(msg.sender == this.owner());\\n    /// #if_succeeds {:msg \\\"The buyTaxScale was set properly\\\"}\\n        /// _buyTaxScale == _scale;\\n    function setBuyTaxScale(uint256 _scale) external onlyOwner {\\n        require(_scale <= 100000 && _scale >= 100, \\\"invalid buy tax scale (100:100000)\\\");\\n        uint256 oldScale = _buyTaxScale;\\n        _buyTaxScale = _scale;\\n        emit BuyTaxScaleChanged(oldScale, _buyTaxScale);\\n    }\\n\\n    /**\\n     * @dev sets the tax rate stored in the sellTaxRate variable\\n     *\\n     * @param _rate                    new tax rate in percentage (integer between 1 and 100)\\n     */\\n    /// #if_succeeds {:msg \\\"The sender must be Owner\\\"}\\n        /// old(msg.sender == this.owner());\\n    /// #if_succeeds {:msg \\\"The correct _sellTaxRate has been set\\\"}\\n        /// _sellTaxRate == _rate;\\n    function setSellTaxRate(uint256 _rate) external onlyOwner {\\n        require(_rate <= 100 && _rate >= 0, \\\"BrincToken:setTax:invalid tax rate (1:100)\\\");\\n        uint256 oldRate = _sellTaxRate;\\n        _sellTaxRate = _rate;\\n        emit SellTaxRateChanged(oldRate, _sellTaxRate);\\n    }\\n\\n    /**\\n     * @dev sets the sell tax scale stored in the sellTaxScale variable\\n     *\\n     * @param _scale new sell tax scale (integer between 100 and 100000)\\n     */\\n    /// #if_succeeds {:msg \\\"The sender must be Owner\\\"}\\n        /// old(msg.sender == this.owner());\\n    /// #if_succeeds {:msg \\\"The sellTaxScale was set properly\\\"}\\n        /// _sellTaxScale == _scale;\\n    function setSellTaxScale(uint256 _scale) external onlyOwner {\\n        require(_scale <= 100000 && _scale >= 100, \\\"invalid sell tax scale (100:100000)\\\");\\n        uint256 oldScale = _sellTaxScale;\\n        _sellTaxScale = _scale;\\n        emit SellTaxScaleChanged(oldScale, _sellTaxScale);\\n    }\\n\\n    // CURVE\\n    /**\\n     * @dev given a token supply, reserve balance, weight and a deposit amount (in the reserve token),\\n     * calculates the target amount for a given conversion (in the main token)\\n     *\\n     * Formula:\\n     * return = _supply * ((1 + _amount / _reserveBalance) ^ (_reserveWeight / 1000000) - 1)\\n     *\\n     * @param _supply          liquid token supply\\n     * @param _reserveBalance  reserve balance\\n     * @param _reserveWeight   reserve weight, represented in ppm (1-1000000)\\n     * @param _amount          amount of reserve tokens to get the target amount for\\n     *\\n     * @return target\\n     */\\n    /// #if_succeeds {:msg \\\"The purchase amount should be correct - case _amount = 0\\\"}\\n        /// _amount == 0 ==> $result == 0;\\n    /// #if_succeeds {:msg \\\"The purchase amount should be correct - case _reserveWeight = MAX_WEIGHT\\\"}\\n        /// let postTax := _removeBuyTaxFromSpecificAmount(_amount) in\\n        /// _reserveWeight == 1000000 ==>  $result == _supply.mul(postTax) / _reserveBalance;\\n\\n    function purchaseTargetAmount(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _reserveWeight,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        uint256 postTax = _removeBuyTaxFromSpecificAmount(_amount);\\n        return _curveAddress.purchaseTargetAmount(\\n            _supply,\\n            _reserveBalance,\\n            _reserveWeight,\\n            postTax\\n        );\\n    }\\n\\n     /**\\n     * @dev given a token supply, reserve balance, weight and a sell amount (in the main token),\\n     * calculates the target amount for a given conversion (in the reserve token)\\n     *\\n     * Formula:\\n     * return = _reserveBalance * (1 - (1 - _amount / _supply) ^ (1000000 / _reserveWeight))\\n     *\\n     * @param _supply          liquid token supply\\n     * @param _reserveBalance  reserve balance\\n     * @param _reserveWeight   reserve weight, represented in ppm (1-1000000)\\n     * @param _amount          amount of liquid tokens to get the target amount for\\n     *\\n     * @return reserve token amount\\n     */\\n    /// #if_succeeds {:msg \\\"The sell amount should be correct - case _amount = 0\\\"} \\n        /// _amount == 0 ==> $result == 0;\\n    /// #if_succeeds {:msg \\\"The sell amount should be correct - case _reserveWeight = MAX_WEIGHT\\\"}\\n        /// _reserveWeight == 1000000 ==> $result == _removeSellTax(_reserveBalance.mul(_amount) / _supply);\\n    function saleTargetAmount(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _reserveWeight,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        uint256 reserveValue = _curveAddress.saleTargetAmount(\\n            _supply,\\n            _reserveBalance,\\n            _reserveWeight,\\n            _amount\\n        );\\n        uint256 gross = _removeSellTax(reserveValue);\\n        return gross;\\n    }\\n\\n     /**\\n     * @dev given a pool token supply, reserve balance, reserve ratio and an amount of requested pool tokens,\\n     * calculates the amount of reserve tokens required for purchasing the given amount of pool tokens\\n     *\\n     * Formula:\\n     * return = _reserveBalance * (((_supply + _amount) / _supply) ^ (MAX_WEIGHT / _reserveRatio) - 1)\\n     *\\n     * @param _supply          pool token supply\\n     * @param _reserveBalance  reserve balance\\n     * @param _reserveRatio    reserve ratio, represented in ppm (2-2000000)\\n     * @param _amount          requested amount of pool tokens\\n     *\\n     * @return reserve token amount\\n     */\\n    /// #if_succeeds {:msg \\\"The fundCost amount should be correct - case _amount = 0\\\"}\\n        /// _amount == 0 ==> $result == 0;\\n    /// #if_succeeds {:msg \\\"The fundCost amount should be correct - case _reserveRatio = MAX_WEIGHT\\\"}\\n        /// _reserveRatio == 1000000 ==> $result == _addBuyTax(_curveAddress.fundCost(_supply, _reserveBalance, _reserveRatio, _amount));\\n    function fundCost(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _reserveRatio,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        uint256 reserveTokenCost = _curveAddress.fundCost(\\n            _supply,\\n            _reserveBalance,\\n            _reserveRatio,\\n            _amount\\n        );\\n        uint256 net = _addBuyTax(reserveTokenCost);\\n        return net;\\n    }\\n\\n    /**\\n     * @dev given a pool token supply, reserve balance, reserve ratio and an amount of pool tokens to liquidate,\\n     * calculates the amount of reserve tokens received for selling the given amount of pool tokens\\n     *\\n     * Formula:\\n     * return = _reserveBalance * (1 - ((_supply - _amount) / _supply) ^ (MAX_WEIGHT / _reserveRatio))\\n     *\\n     * @param _supply          pool token supply\\n     * @param _reserveBalance  reserve balance\\n     * @param _reserveRatio    reserve ratio, represented in ppm (2-2000000)\\n     * @param _amount          amount of pool tokens to liquidate\\n     *\\n     * @return reserve token amount\\n     */\\n    /// #if_succeeds {:msg \\\"The liquidateReserveAmount should be correct - case _amount = 0\\\"}\\n        /// _amount == 0 ==> $result == 0;\\n    /// #if_succeeds {:msg \\\"The liquidateReserveAmount should be correct - case _amount = _supply\\\"}\\n        /// _amount == _supply ==> $result == _removeSellTax(_reserveBalance);\\n    /// #if_succeeds {:msg \\\"The liquidateReserveAmount should be correct - case _reserveRatio = MAX_WEIGHT\\\"}\\n        /// _reserveRatio == 1000000 ==> $result == _removeSellTax(_amount.mul(_reserveBalance) / _supply);\\n    function liquidateReserveAmount(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _reserveRatio,\\n        uint256 _amount\\n    ) public view returns (uint256) {\\n        uint256 liquidateValue = _curveAddress.liquidateReserveAmount(\\n            _supply,\\n            _reserveBalance,\\n            _reserveRatio,\\n            _amount\\n        );\\n        uint256 gross = _removeSellTax(liquidateValue);\\n        return gross;\\n    }\\n\\n\\n    /**\\n     * @dev allows for the minting of tokens\\n     * @param account the account to mint the tokens to\\n     * @param amount the uint256 amount of tokens to mint\\n     *\\n     * @notice see note on mintForSpecificReserveAmount - this function should be used when there is\\n     * a target amount of main tokens (the tokens native to this contract) to be minted\\n     */\\n    /// #if_succeeds {:msg \\\"The caller's BrincToken balance should be increase correct\\\"}\\n        /// this.balanceOf(account) == old(this.balanceOf(account) + amount);\\n    /// #if_succeeds {:msg \\\"The reserve balance should increase correct\\\"} \\n        /// _reserveAsset.balanceOf(address(this)) >= old(_reserveAsset.balanceOf(address(this)));\\n        // this will check if greater or equal to the old balance\\n        // will be equal in the case there is a 0 balance transfer\\n    /// #if_succeeds {:msg \\\"The tax should go to the owner\\\"}\\n        /// let reserveBalance := old(_reserveAsset.balanceOf(address(this))) in\\n        /// let reserveTokenCost := old(fundCost(totalSupply(), reserveBalance, _fixedReserveRatio, amount)) in\\n        /// let taxDeducted := old(_removeBuyTax(reserveTokenCost)) in\\n        /// (msg.sender != owner() && address(this) != owner()) ==> _reserveAsset.balanceOf(owner()) == old(_reserveAsset.balanceOf(owner()) + reserveTokenCost.sub(taxDeducted));\\n    function mint(address account, uint256 amount) public returns (bool) {\\n        uint256 reserveBalance = _reserveAsset.balanceOf(address(this));\\n        uint256 reserveTokenCost = fundCost(totalSupply(), reserveBalance, _fixedReserveRatio, amount);\\n\\n        uint256 taxDeducted = _removeBuyTax(reserveTokenCost);\\n        require(\\n            _reserveAsset.transferFrom(\\n                _msgSender(),\\n                address(this),\\n                reserveTokenCost\\n            ),\\n            \\\"BrincToken:mint:Reserve asset transfer for mint failed\\\"\\n        );\\n        require(\\n            _reserveAsset.transfer(\\n                owner(),\\n                reserveTokenCost.sub(taxDeducted)\\n            ),\\n            \\\"BrincToken:mint:Tax transfer failed\\\"\\n        );\\n        _mint(account, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev allows for the minting of tokens based on a target amount of reserve asset\\n     * @param account the account to mint the tokens to\\n     * @param amount the uint256 amount of reserve tokens to spend minting\\n     *\\n     * @notice the difference between this function and the default mint function is if the\\n     * amount of main token desired is specified (this is the case in the default mint function)\\n     * or if a specific amount of reserve token is being spent - this function would be used if the\\n     * the user has a specific amount of reserve asset (eg Dai) that they wish to spend\\n     */\\n    /// #if_succeeds {:msg \\\"The caller's BrincToken balance should be increase correct\\\"}\\n        /// let reserveBalance := old(_reserveAsset.balanceOf(address(this))) in\\n        /// let tokensToMint := old(purchaseTargetAmount(totalSupply(), reserveBalance, _fixedReserveRatio, amount)) in\\n        /// msg.sender != owner() ==> this.balanceOf(account) == old(this.balanceOf(account) + tokensToMint);\\n    /// #if_succeeds {:msg \\\"The reserve balance should increase by exact amount\\\"}\\n        /// let taxDeducted := old(_removeBuyTaxFromSpecificAmount(amount)) in   \\n        /// (msg.sender != owner() && address(this) != owner()) ==> _reserveAsset.balanceOf(address(this)) == old(_reserveAsset.balanceOf(address(this)) + amount - amount.sub(taxDeducted));\\n    /// #if_succeeds {:msg \\\"The tax should go to the owner\\\"}\\n        /// let taxDeducted := old(_removeBuyTaxFromSpecificAmount(amount)) in\\n        /// (msg.sender != owner() && address(this) != owner()) ==> _reserveAsset.balanceOf(owner()) == old(_reserveAsset.balanceOf(owner())) + amount.sub(taxDeducted);\\n    /// #if_succeeds {:msg \\\"The result should be true\\\"} $result == true;\\n    function mintForSpecificReserveAmount(address account, uint256 amount) public returns (bool) {\\n        uint256 reserveBalance = _reserveAsset.balanceOf(address(this));\\n\\n        uint256 taxDeducted = _removeBuyTaxFromSpecificAmount(amount);\\n        uint256 tokensToMint = purchaseTargetAmount(\\n            totalSupply(), \\n            reserveBalance, \\n            _fixedReserveRatio, \\n            amount\\n        );\\n\\n        require(\\n            _reserveAsset.transferFrom(\\n                _msgSender(),\\n                address(this),\\n                amount\\n            ),\\n            \\\"BrincToken:mint:Reserve asset transfer for mint failed\\\"\\n        );\\n        require(\\n            _reserveAsset.transfer(\\n                owner(),\\n                amount.sub(taxDeducted)\\n            ),\\n            \\\"BrincToken:mint:Tax transfer failed\\\"\\n        );\\n        _mint(account, tokensToMint);\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     * @param amount the uint256 amount of tokens to burn\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n\\n    /// #if_succeeds {:msg \\\"The overridden burn should decrease caller's BrincToken balance\\\"}\\n        /// this.balanceOf(_msgSender()) == old(this.balanceOf(_msgSender()) - amount);\\n    /// #if_succeeds {:msg \\\"burn should add burn tax to the owner's balance\\\"}\\n        /// let reserveBalance := old(_reserveAsset.balanceOf(address(this))) in\\n        /// let reserveTokenNet := old(liquidateReserveAmount(totalSupply(), reserveBalance, _fixedReserveRatio, amount)) in\\n        /// let taxAdded := old(_addSellTax(reserveTokenNet)) in\\n        /// (msg.sender != owner() && address(this) != owner()) ==> _reserveAsset.balanceOf(owner()) == old(_reserveAsset.balanceOf(owner()) + taxAdded.sub(reserveTokenNet));\\n    /// #if_succeeds {:msg \\\"burn should decrease BrincToken reserve balance by exact amount\\\"}\\n        /// let reserveBalance := old(_reserveAsset.balanceOf(address(this))) in\\n        /// let reserveTokenNet := old(liquidateReserveAmount(totalSupply(), reserveBalance, _fixedReserveRatio, amount)) in\\n        /// let taxAdded := old(_addSellTax(reserveTokenNet)) in\\n        /// (msg.sender != owner() && address(this) != owner()) ==> _reserveAsset.balanceOf(address(this)) == old(_reserveAsset.balanceOf(address(this)) - reserveTokenNet - taxAdded.sub(reserveTokenNet));\\n    /// #if_succeeds {:msg \\\"burn should increase user's reserve balance by exact amount\\\"}\\n        /// let reserveBalance := old(_reserveAsset.balanceOf(address(this))) in\\n        /// let reserveTokenNet := old(liquidateReserveAmount(totalSupply(), reserveBalance, _fixedReserveRatio, amount)) in\\n        /// msg.sender != owner() ==> _reserveAsset.balanceOf(_msgSender()) == old(_reserveAsset.balanceOf(_msgSender()) + reserveTokenNet);\\n    function burn(uint256 amount) public override {\\n        uint256 reserveBalance = _reserveAsset.balanceOf(address(this));\\n        uint256 reserveTokenNet = liquidateReserveAmount(totalSupply(), reserveBalance, _fixedReserveRatio, amount);\\n        _burn(_msgSender(), amount);\\n\\n        uint256 taxAdded = _addSellTax(reserveTokenNet);\\n        require(_reserveAsset.transfer(owner(), taxAdded.sub(reserveTokenNet)), \\\"BrincToken:burn:Tax transfer failed\\\");\\n        require(_reserveAsset.transfer(_msgSender(), reserveTokenNet), \\\"BrincToken:burn:Reserve asset transfer failed\\\");\\n    }\\n\\n    /**\\n     * @dev Allows an approved delgate to destroy tokens from another address\\n     * @param account the address to burn tokens from\\n     * @param amount the uint256 amount of tokens to approve\\n     */\\n    /// #if_succeeds {:msg \\\"The overridden burnFrom should decrease caller's BrincToken balance\\\"} \\n        /// this.balanceOf(account) == old(this.balanceOf(account) - amount);\\n    /// #if_succeeds {:msg \\\"burnFrom should add burn tax to the owner's balance\\\"} \\n        /// let reserveBalance := old(_reserveAsset.balanceOf(address(this))) in\\n        /// let reserveTokenNet := old(liquidateReserveAmount(totalSupply(), reserveBalance, _fixedReserveRatio, amount)) in\\n        /// let taxAdded := old(_addSellTax(reserveTokenNet)) in\\n        /// (msg.sender != owner() && address(this) != owner()) ==> _reserveAsset.balanceOf(owner()) == old(_reserveAsset.balanceOf(owner()) + taxAdded.sub(reserveTokenNet));\\n    /// #if_succeeds {:msg \\\"burnFrom should decrease BrincToken reserve balance by exact amount\\\"}\\n        /// let reserveBalance := old(_reserveAsset.balanceOf(address(this))) in\\n        /// let reserveTokenNet := old(liquidateReserveAmount(totalSupply(), reserveBalance, _fixedReserveRatio, amount)) in\\n        /// let taxAdded := old(_addSellTax(reserveTokenNet)) in\\n        /// (msg.sender != owner() && address(this) != owner()) ==> _reserveAsset.balanceOf(address(this)) == old(_reserveAsset.balanceOf(address(this)) - reserveTokenNet - taxAdded.sub(reserveTokenNet));\\n    /// #if_succeeds {:msg \\\"burnFrom should increase user's reserve balance by exact amount\\\"}\\n        /// let reserveBalance := old(_reserveAsset.balanceOf(address(this))) in\\n        /// let reserveTokenNet := old(liquidateReserveAmount(totalSupply(), reserveBalance, _fixedReserveRatio, amount)) in\\n        /// (msg.sender != owner() && address(this) != owner()) ==> _reserveAsset.balanceOf(_msgSender()) == old(_reserveAsset.balanceOf(_msgSender()) + reserveTokenNet);\\n    function burnFrom(address account, uint256 amount) public override {\\n        uint256 reserveBalance = _reserveAsset.balanceOf(address(this));\\n        uint256 reserveTokenNet = liquidateReserveAmount(totalSupply(), reserveBalance, _fixedReserveRatio, amount);\\n        super.burnFrom(account, amount);\\n\\n        uint256 taxAdded = _addSellTax(reserveTokenNet);\\n        require(_reserveAsset.transfer(owner(), taxAdded.sub(reserveTokenNet)), \\\"BrincToken:burnFrom:Tax transfer failed\\\");\\n        require(_reserveAsset.transfer(account, reserveTokenNet), \\\"BrincToken:burnFrom:Reserve asset transfer failed\\\");\\n    }\\n\\n    // ERC20Pausable\\n    /**\\n     * @dev Pauses the contract's transfer, mint & burn functions\\n     *\\n     */\\n    /// #if_succeeds {:msg \\\"The caller must be Owner\\\"}\\n        /// old(msg.sender == this.owner());\\n    function pause() public onlyOwner() {\\n        _pause();\\n    }\\n    /**\\n     * @dev Unpauses the contract's transfer, mint & burn functions\\n     *\\n     */\\n    /// #if_succeeds {:msg \\\"The caller must be Owner\\\"}\\n        /// old(msg.sender == this.owner());\\n    function unpause() public onlyOwner() {\\n        _unpause();\\n    }\\n\\n    // ERC20Snapshot\\n    /**\\n     * @dev Creates a new snapshot and returns its snapshot id.\\n     *\\n     * Emits a {Snapshot} event that contains the same id.\\n     *\\n     */\\n    /// #if_succeeds {:msg \\\"The caller must be Owner\\\"}\\n        /// old(msg.sender == this.owner());\\n    function snapshot() public onlyOwner() {\\n        _snapshot();\\n    }\\n\\n    // Tax\\n    /**\\n     * @dev adds the buy tax to the cost of minting/buying tokens\\n     * @notice this function should be used when the user has not speicified a specific amount of\\n     * reserve tokens they are interested in spending, but rather a specific amount of collateralized\\n     * tokens they are interested in purchasing\\n     * @param reserveTokenAmount the initial amount that needs the taxed amount applied to it\\n     *\\n     * @return the post-tax cost to the user for minting\\n     */\\n    /// #if_succeeds {:msg \\\"The correct tax is added to buy\\\"}\\n        /// $result == reserveTokenAmount.mul(_buyTaxRate.add(_buyTaxScale)).div(_buyTaxScale);\\n    function _addBuyTax(uint256 reserveTokenAmount) internal view returns(uint256) {\\n        return reserveTokenAmount.mul(_buyTaxRate.add(_buyTaxScale)).div(_buyTaxScale);\\n    }\\n\\n    /**\\n     * @dev reapplies the sell tax to the amount of reserves returned on burn/sell\\n     * @param reserveTokenAmount the initial amount that needs the taxed amount reapplied to it\\n     *\\n     * @return the pretax returns from selling\\n     */\\n    /// #if_succeeds {:msg \\\"The correct tax is added to sell\\\"}\\n        /// $result == reserveTokenAmount.mul(_sellTaxRate.add(_sellTaxScale)).div(_sellTaxScale);\\n    function _addSellTax(uint256 reserveTokenAmount) internal view returns(uint256) {\\n        return reserveTokenAmount.mul(_sellTaxRate.add(_sellTaxScale)).div(_sellTaxScale);\\n        // return (reserveTokenAmount.mul(_sellTaxScale)).div(_sellTaxScale.sub(_sellTaxRate));\\n    }\\n\\n    /**\\n     * @dev removes the buy tax from the user-determined reserve token amount\\n     * @notice this function should be used when the user has speicified a specific amount of\\n     * reserve tokens they are interested in purchasing collateral tokens with, as opposed to \\n     * a specific amount of collateralized\\n     * @param reserveTokenAmount the initial amount that needs the taxed amount removed from it\\n     *\\n     * @return the pretax cost of the collateral tokens\\n     */\\n    /// #if_succeeds {:msg \\\"The correct tax removed from specific amount\\\"}\\n        /// $result == reserveTokenAmount.mul(_buyTaxScale.sub(_buyTaxRate)).div(_buyTaxScale);\\n    function _removeBuyTaxFromSpecificAmount(uint256 reserveTokenAmount) internal view returns(uint256) {\\n        // uint256 upscaledTax = 1e18 - (_buyTaxRate.mul(1e16));\\n        // uint256 upscaledPreTax = reserveTokenAmount.mul(upscaledTax);\\n        // return upscaledPreTax / 1e18;\\n        return reserveTokenAmount.mul(_buyTaxScale.sub(_buyTaxRate)).div(_buyTaxScale);\\n    }\\n\\n    /**\\n     * @dev removes the buy tax from the price of minting/buying (yielding the pretax amount)\\n     * @param reserveTokenAmount the initial amount that needs the tax rate removed from\\n     *\\n     * @return the pretax cost of the collateral tokens\\n     */\\n    /// #if_succeeds {:msg \\\"The correct tax amount should be added\\\"}\\n        /// $result == reserveTokenAmount.mul(_buyTaxScale).div(_buyTaxRate.add(_buyTaxScale));\\n    function _removeBuyTax(uint256 reserveTokenAmount) internal view returns(uint256) {\\n        return reserveTokenAmount.mul(_buyTaxScale).div(_buyTaxRate.add(_buyTaxScale));\\n    }\\n\\n    /**\\n     * @dev removes the sell tax from the pretax returns of burning/selling\\n     * @param reserveTokenAmount the initial amount that needs the tax rate removed from\\n     *\\n     * @return the post-tax returns to the user from burning\\n     */\\n    /// #if_succeeds {:msg \\\"The correct tax amount should be subtracted\\\"}\\n        /// $result == reserveTokenAmount.mul(_sellTaxScale).div(_sellTaxRate.add(_sellTaxScale));\\n    function _removeSellTax(uint256 reserveTokenAmount) internal view returns(uint256) {\\n        return reserveTokenAmount.mul(_sellTaxScale).div(_sellTaxRate.add(_sellTaxScale));\\n        // return reserveTokenAmount.mul(_sellTaxScale.sub(_sellTaxRate)).div(_sellTaxScale);\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 amount)\\n        internal virtual override(ERC20,ERC20Snapshot,ERC20Pausable)\\n    {\\n        super._beforeTokenTransfer(from, to, amount);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Snapshot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Arrays.sol\\\";\\nimport \\\"../../utils/Counters.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\\n * total supply at the time are recorded for later access.\\n *\\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\\n * In naive implementations it's possible to perform a \\\"double spend\\\" attack by reusing the same balance from different\\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\\n * used to create an efficient ERC20 forking mechanism.\\n *\\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\\n * and the account address.\\n *\\n * ==== Gas Costs\\n *\\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\\n *\\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\\n * transfers will have normal cost until the next snapshot, and so on.\\n */\\nabstract contract ERC20Snapshot is ERC20 {\\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\\n    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\\n\\n    using SafeMath for uint256;\\n    using Arrays for uint256[];\\n    using Counters for Counters.Counter;\\n\\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\\n    // Snapshot struct, but that would impede usage of functions that work on an array.\\n    struct Snapshots {\\n        uint256[] ids;\\n        uint256[] values;\\n    }\\n\\n    mapping (address => Snapshots) private _accountBalanceSnapshots;\\n    Snapshots private _totalSupplySnapshots;\\n\\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\\n    Counters.Counter private _currentSnapshotId;\\n\\n    /**\\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\\n     */\\n    event Snapshot(uint256 id);\\n\\n    /**\\n     * @dev Creates a new snapshot and returns its snapshot id.\\n     *\\n     * Emits a {Snapshot} event that contains the same id.\\n     *\\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\\n     *\\n     * [WARNING]\\n     * ====\\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\\n     * you must consider that it can potentially be used by attackers in two ways.\\n     *\\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\\n     * section above.\\n     *\\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\\n     * ====\\n     */\\n    function _snapshot() internal virtual returns (uint256) {\\n        _currentSnapshotId.increment();\\n\\n        uint256 currentId = _currentSnapshotId.current();\\n        emit Snapshot(currentId);\\n        return currentId;\\n    }\\n\\n    /**\\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\\n     */\\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\\n\\n        return snapshotted ? value : balanceOf(account);\\n    }\\n\\n    /**\\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\\n     */\\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns(uint256) {\\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\\n\\n        return snapshotted ? value : totalSupply();\\n    }\\n\\n\\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n      super._beforeTokenTransfer(from, to, amount);\\n\\n      if (from == address(0)) {\\n        // mint\\n        _updateAccountSnapshot(to);\\n        _updateTotalSupplySnapshot();\\n      } else if (to == address(0)) {\\n        // burn\\n        _updateAccountSnapshot(from);\\n        _updateTotalSupplySnapshot();\\n      } else {\\n        // transfer\\n        _updateAccountSnapshot(from);\\n        _updateAccountSnapshot(to);\\n      }\\n    }\\n\\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots)\\n        private view returns (bool, uint256)\\n    {\\n        require(snapshotId > 0, \\\"ERC20Snapshot: id is 0\\\");\\n        // solhint-disable-next-line max-line-length\\n        require(snapshotId <= _currentSnapshotId.current(), \\\"ERC20Snapshot: nonexistent id\\\");\\n\\n        // When a valid snapshot is queried, there are three possibilities:\\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\\n        //  to this id is the current one.\\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\\n        //  requested id, and its value is the one to return.\\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\\n        //  larger than the requested one.\\n        //\\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\\n        // exactly this.\\n\\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\\n\\n        if (index == snapshots.ids.length) {\\n            return (false, 0);\\n        } else {\\n            return (true, snapshots.values[index]);\\n        }\\n    }\\n\\n    function _updateAccountSnapshot(address account) private {\\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\\n    }\\n\\n    function _updateTotalSupplySnapshot() private {\\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\\n    }\\n\\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\\n        uint256 currentId = _currentSnapshotId.current();\\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\\n            snapshots.ids.push(currentId);\\n            snapshots.values.push(currentValue);\\n        }\\n    }\\n\\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\\n        if (ids.length == 0) {\\n            return 0;\\n        } else {\\n            return ids[ids.length - 1];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"../../utils/Pausable.sol\\\";\\n\\n/**\\n * @dev ERC20 token with pausable token transfers, minting and burning.\\n *\\n * Useful for scenarios such as preventing trades until the end of an evaluation\\n * period, or having an emergency switch for freezing all token transfers in the\\n * event of a large bug.\\n */\\nabstract contract ERC20Pausable is ERC20, Pausable {\\n    /**\\n     * @dev See {ERC20-_beforeTokenTransfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - the contract must not be paused.\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\n        super._beforeTokenTransfer(from, to, amount);\\n\\n        require(!paused(), \\\"ERC20Pausable: token transfer while paused\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Curve/interfaces/ICurve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n/*\\n    Bonding Curve interface\\n*/\\ninterface ICurve {\\n    function purchaseTargetAmount(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _reserveWeight,\\n        uint256 _amount\\n    ) external view returns (uint256);\\n\\n    function saleTargetAmount(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _reserveWeight,\\n        uint256 _amount\\n    ) external view returns (uint256);\\n\\n    function crossReserveTargetAmount(\\n        uint256 _sourceReserveBalance,\\n        uint32 _sourceReserveWeight,\\n        uint256 _targetReserveBalance,\\n        uint32 _targetReserveWeight,\\n        uint256 _amount\\n    ) external view returns (uint256);\\n\\n    function fundCost(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _reserveRatio,\\n        uint256 _amount\\n    ) external view returns (uint256);\\n\\n    function fundSupplyAmount(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _reserveRatio,\\n        uint256 _amount\\n    ) external view returns (uint256);\\n\\n    function liquidateReserveAmount(\\n        uint256 _supply,\\n        uint256 _reserveBalance,\\n        uint32 _reserveRatio,\\n        uint256 _amount\\n    ) external view returns (uint256);\\n\\n    function balancedWeights(\\n        uint256 _primaryReserveStakedBalance,\\n        uint256 _primaryReserveBalance,\\n        uint256 _secondaryReserveBalance,\\n        uint256 _reserveRateNumerator,\\n        uint256 _reserveRateDenominator\\n    ) external view returns (uint32, uint32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Arrays.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../math/Math.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary Arrays {\\n   /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * `array` is expected to be sorted in ascending order, and to contain no\\n     * repeated elements.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        if (array.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds down (it does integer division with truncation).\\n            if (array[mid] > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low > 0 && array[low - 1] == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../math/SafeMath.sol\\\";\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\\n * directly accessed.\\n */\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor () internal {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"reserveAsset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buyTaxRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyTaxScale\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellTaxRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellTaxScale\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"reserveRatio\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"curveAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"BuyTaxRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldScale\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newScale\",\"type\":\"uint256\"}],\"name\":\"BuyTaxScaleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"SellTaxRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldScale\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newScale\",\"type\":\"uint256\"}],\"name\":\"SellTaxScaleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Snapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"snapshotId\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTaxRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTaxScale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_reserveRatio\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"fundCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_firstReserve\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_firstSupply\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_reserveRatio\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"liquidateReserveAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintForSpecificReserveAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_reserveWeight\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"purchaseTargetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveRatio\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserveBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_reserveWeight\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"saleTargetAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTaxRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTaxScale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setBuyTaxRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_scale\",\"type\":\"uint256\"}],\"name\":\"setBuyTaxScale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setSellTaxRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_scale\",\"type\":\"uint256\"}],\"name\":\"setSellTaxScale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"snapshotId\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BrincToken","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001600000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000000000006300000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000000007a120000000000000000000000000208996ebc57dc4103eb1922cf4e168d79fb97664000000000000000000000000000000000000000000000000000000000000000a4272696e63546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034252430000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}