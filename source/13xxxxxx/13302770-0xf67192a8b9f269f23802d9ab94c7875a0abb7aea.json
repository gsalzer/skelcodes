{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) internal _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n    uint256 internal _totalSupply;\\n    string private _name = \\\"BioBit\\\";\\n    string private _symbol = \\\"BBIT\\\";\\n    uint8 private _decimals = 9;\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n\\n    function _setupDecimals(uint8 decimals_) internal {\\n        _decimals = decimals_;\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"},\"ERC20Burnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller\\u0027s\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance \\u003e= amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n        _approve(account, _msgSender(), currentAllowance - amount);\\n        _burn(account, amount);\\n    }\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n\\nlibrary SafeMath {\\n    \\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n   \\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n}\"},\"ZarelaSmartContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma experimental ABIEncoderV2;\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./ERC20Burnable.sol\\\";\\n\\n/// @author Zarela Team \\n/// @title Decentralized marketplace platform for peer-to-peer transferring of Biosignals\\ncontract ZarelaSmartContract is ERC20 , ERC20Burnable {\\n    \\n    // token distribution 17m reward pool and 3m other(2m team , 1m fundraising)\\n    constructor() {\\n        _mint(msg.sender , 3000000000000000);\\n        _mint(address(this) , 17000000000000000);\\n    }\\n\\n    event orderRegistered(\\n        address owner,\\n        uint orderId\\n        );\\n    event contributed(\\n        address contributor,\\n        address labrotory,\\n        uint orderId,\\n        address mage,\\n        uint difficulty\\n        );\\n    event orderFinished(\\n        uint orderId\\n        );\\n    event signalsApproved(\\n        uint orderId,\\n        uint confirmCount\\n        );\\n   \\n    uint public maxUserDailyReward = 50000000000 ; // Max User Daily Reward As BIOBIT + 50 + _decimals \\n    uint public totalTokenReleaseDaily = 14400000000000 ; // Total Tokens That Release From Zarela Reward Pool Per Day \\n    \\n    address payable[] public paymentQueue; // All addresses pending reward (angels or laboratory)\\n    uint public halvingCounter; // Halving Counter\\n    uint public countDown24Hours = block.timestamp; // Starting 24 hours Timer By Block Timestamp (From Deploy Zarela)\\n    uint public dayCounterOf20Months; // Day Counter Of 20 Months (590 days  =  20 months )\\n    uint public indexCounter; // Index Of Entered Contributors Array \\n    uint public lastRewardableIndex; // Index Of Last Person Who Should Get Reward Until Yesterday\\n    uint public indexOfAddressPendingReward; // Index Of allAngelsAddresses Array Pending For Reward\\n    address addressOfPendingReward; // Address Of allAngelsAddresses Array Pending For Reward\\n    uint public paymentDay; // Payment Day\\n    uint public todayContributionsCount; // Count Of Today Contributions\\n    uint[] public dailyContributionsCount; //  Count Of Daily Contributions\\n    uint public bankBalance; // The Amount of Tokens Remained and Can Add to Rewarding for Next Day\\n    uint[] public remainedDailyTokens; // Daily Token Remained\\n    uint public indexOfZeroDailyTokens; // Index Of remainedDailyTokens Array That Before Day There is No Token\\n    uint public dayOfTokenBurning; // The Day That Token Will be Burned\\n    uint public zarelaDayCounter; // The Day Count Of Zarela Age\\n    uint[] public burnedTokensPerDay; // Array Of Burned Tokens Per Day\\n    uint[] public dailyRewardPerContributor; // Array Of Daily Reward Per Countributor\\n    uint[] public dailyBalance; // Array Of Daily Balance \\n    uint public zarelaDifficultyOfDay; // The Difficulty Of Zarela Network Per Day\\n    bool public isZarelaEnd; // is Zarela End?\\n    \\n    struct Order {\\n        uint orderId; // Order ID\\n        string orderTitle; // Order Title\\n        address orderOwner; // Order Owner\\n        uint tokenPerContributor; // Allcoated Biobit Per Contributor\\n        uint tokenPerLaboratory;  // Allcoated Biobit Per Laboratory\\n        uint totalContributors; // Total Contributors\\n        string zPaper; // zPaper\\n        string description; // Description Of Order\\n        uint totalContributorsRemain; // Total Contributors Remain\\n        uint countOfRegisteredContributions; // Count of Registered Contributions\\n        uint registrationTime; // Order Registration Time\\n        string accessPublicKey; // Encryption Owner Public Key \\n    }\\n    \\n    struct Category {\\n        string zarelaCategory; // Zarela Category (Hashtags)\\n        uint businessCategory; // Business Category\\n    } \\n    \\n    struct OrderData {\\n        uint orderId; // Order ID\\n        uint[] dataRegistrationTime;  // Data Registration Time\\n        string[] ipfsHash; //  IPFS Hash Of Data (Stored In IPFS)\\n        string[] encryptionKey; // IPFS Hash of  Encrypted AES Secret Key (Stored In IPFS)\\n        address[] contributorAddresses; // Array Of Contributors addresses\\n        address[] laboratoryAddresses; // Array Of laboratory addresses\\n        bool[] whoGainedReward; // Array Of addresses that Gained the Reward  (true means angel and false means laboratory)\\n        bool[] isConfirmedByMage; // is Confirmed By Mage?\\n        uint[] zarelaDay; // in Which Zarela Day This Data is Imported\\n    }\\n    \\n    struct User {\\n        uint tokenGainedFromSC; // Total Tokens That User Gained From Smart Contract (Reward Pool)\\n        uint tokenGainedFromMages; // Total Tokens That User Gained From Mages\\n        uint[] angelContributedOrders; // Array Of Orderids That User is Contributed as Angel\\n        uint[] laboratoryContributedOrders;  // Array Of Orderids That User is Contributed as Hub\\n        uint[] ownedOrders; // Array Of Order ids That User is Owned\\n    }\\n    \\n    mapping(uint =\\u003e OrderData) public orderDataMap;\\n    mapping(address =\\u003e User) public userMap;\\n    Order[] public orders;\\n    Category[]public Categories;\\n\\n    modifier onlyRequester(uint _Order_Number) {\\n        Order storage myorder = orders[_Order_Number];\\n        require(myorder.orderOwner == msg.sender, \\\"You Are Not Owner\\\");\\n        _;\\n    }\\n    \\n    modifier checkOrderId(uint _Order_Number) {\\n        Order storage myorder = orders[_Order_Number];\\n        require(_Order_Number == myorder.orderId , \\\"This Order Number Is Not Correct\\\");\\n        _;\\n    }\\n    \\n    modifier notNull(address _address) {\\n        require(address(0) != _address, \\\"Send To The Zero Address\\\");\\n        _;\\n    }\\n    \\n    /// @dev make any kind of request that may be answered with a file.This function is only called by Mage \\n    function submitNewRequest(\\n        string memory _orderTitle,\\n        string memory _description,\\n        string memory _zPaper,\\n        uint _tokenPerContributor,\\n        uint _tokenPerLaboratory,\\n        uint _totalContributors,\\n        string memory _zarelaCategory,\\n        uint _businessCategory,\\n        string memory _accessPublicKey\\n    )\\n        public\\n    {\\n        require(_balances[msg.sender] \\u003e= ((_tokenPerContributor + _tokenPerLaboratory) * _totalContributors), \\\"Your Token Is Not Enough\\\");\\n        ERC20.transfer(address(this),((_tokenPerContributor + _tokenPerLaboratory) * _totalContributors));\\n        uint orderId = orders.length;\\n        orders.push(\\n            Order(\\n                orderId,\\n                _orderTitle,\\n                msg.sender,\\n                _tokenPerContributor,\\n                _tokenPerLaboratory,\\n                _totalContributors,\\n                _zPaper,\\n                _description,\\n                _totalContributors,\\n                0,\\n                block.timestamp,\\n                _accessPublicKey\\n                )\\n            );\\n        userMap[msg.sender].ownedOrders.push(orderId);\\n        Categories.push(\\n            Category(\\n                    _zarelaCategory,\\n                    _businessCategory\\n                )\\n            );\\n        emit orderRegistered(msg.sender, orderId);\\n    }\\n    \\n    \\n    /// @dev Send the angel signal to mage and save then signal IPFS Hash in the block.Also, due to the difficulty of the Zarela network,\\n    /// each user pays the Reward to a number of people in the non-Reward queue\\n    function contribute(\\n        uint _orderId,\\n        address payable _contributorAddress,\\n        address payable _laboratoryAddress,\\n        bool _isContributorGainReward, \\n        address _orderOwner,\\n        string memory _ipfsHash,\\n        string memory _encryptionKey\\n    )\\n        public \\n        checkOrderId (_orderId)\\n        notNull(_orderOwner)\\n        notNull(_contributorAddress)\\n        notNull(_laboratoryAddress)\\n        \\n    {\\n        require(orders[_orderId].totalContributorsRemain != 0 ,\\\"Order Was Finished\\\");\\n        require(_orderOwner ==  orders[_orderId].orderOwner , \\\"Requester Address Was Not Entered Correctly\\\");\\n        require(msg.sender == _laboratoryAddress || msg.sender == _contributorAddress , \\\"You Are Not Angel Or Laboratory\\\");\\n        if (isZarelaEnd != true) {\\n            address payable rewardRecipientAddress;\\n            if (_isContributorGainReward == true) {\\n                rewardRecipientAddress = _contributorAddress;\\n                orderDataMap[_orderId].whoGainedReward.push(true);\\n            } else {\\n                rewardRecipientAddress = _laboratoryAddress;\\n                orderDataMap[_orderId].whoGainedReward.push(false);\\n            }\\n            if (block.timestamp \\u003c countDown24Hours + 24 hours) {\\n                paymentQueue.push(rewardRecipientAddress);\\n                todayContributionsCount++;\\n            } else {\\n                paymentQueue.push(address(0));\\n                paymentQueue.push(rewardRecipientAddress);\\n                dailyContributionsCount.push(todayContributionsCount);\\n                if (dayCounterOf20Months \\u003e= 589) { //20 month\\n                    maxUserDailyReward = maxUserDailyReward / 2 ;\\n                    totalTokenReleaseDaily = totalTokenReleaseDaily / 2 ;\\n                    halvingCounter++;\\n                    dayCounterOf20Months = 0 ;\\n                }\\n                if (_balances[address(this)] \\u003e= totalTokenReleaseDaily) {\\n                    _balances[address(this)] = _balances[address(this)] - totalTokenReleaseDaily;\\n                    bankBalance+=(totalTokenReleaseDaily);\\n                } else if (bankBalance \\u003e 0 \\u0026\\u0026 _balances[address(this)] \\u003c totalTokenReleaseDaily) {\\n                    bankBalance+= totalTokenReleaseDaily;\\n                    totalTokenReleaseDaily = 0; \\n                } else {\\n                    totalTokenReleaseDaily = 0;\\n                    isZarelaEnd = true;\\n                }\\n                \\n                remainedDailyTokens.push(totalTokenReleaseDaily);\\n                \\n                if (zarelaDayCounter \\u003e= 44) { // 45 days\\n                    bankBalance = bankBalance - (remainedDailyTokens[dayOfTokenBurning]);\\n                    burnedTokensPerDay.push(remainedDailyTokens[dayOfTokenBurning]);\\n                    remainedDailyTokens[dayOfTokenBurning] = 0;\\n                    dayOfTokenBurning++;\\n                }\\n                \\n                dailyBalance.push(bankBalance);\\n                \\n                if (maxUserDailyReward * dailyContributionsCount[zarelaDayCounter] \\u003e= bankBalance) {\\n                    dailyBalance[zarelaDayCounter] = bankBalance;\\n                    dailyRewardPerContributor.push(bankBalance/dailyContributionsCount[zarelaDayCounter]);\\n                    bankBalance = 0;\\n                } else {\\n                    dailyBalance[zarelaDayCounter] = maxUserDailyReward * dailyContributionsCount[zarelaDayCounter];\\n                    dailyRewardPerContributor.push(maxUserDailyReward);\\n                    bankBalance = bankBalance - (maxUserDailyReward * dailyContributionsCount[zarelaDayCounter]);\\n                }\\n               \\n                uint tempPrice = dailyBalance[zarelaDayCounter];\\n                \\n                if (tempPrice \\u003e= remainedDailyTokens[zarelaDayCounter]) {\\n                    tempPrice = tempPrice - (remainedDailyTokens[zarelaDayCounter]);\\n                    remainedDailyTokens[zarelaDayCounter] = 0;\\n                    while (tempPrice \\u003e 0) {\\n                        if (tempPrice \\u003e remainedDailyTokens[indexOfZeroDailyTokens]) {\\n                            tempPrice = tempPrice - (remainedDailyTokens[indexOfZeroDailyTokens]);\\n                            remainedDailyTokens[indexOfZeroDailyTokens] = 0;\\n                            indexOfZeroDailyTokens++;\\n                        } else {\\n                            remainedDailyTokens[indexOfZeroDailyTokens] =  remainedDailyTokens[indexOfZeroDailyTokens] - (tempPrice);\\n                            tempPrice = 0;\\n                        }\\n                    }\\n                } else {\\n                    remainedDailyTokens[zarelaDayCounter] = remainedDailyTokens[zarelaDayCounter] - tempPrice;\\n                }\\n                \\n                zarelaDifficultyOfDay = (lastRewardableIndex - indexOfAddressPendingReward) / dailyContributionsCount[zarelaDayCounter];\\n                \\n                if ((zarelaDayCounter - paymentDay) \\u003e= 7 \\u0026\\u0026 (lastRewardableIndex - indexOfAddressPendingReward) \\u003e= 384 ) {\\n                    zarelaDifficultyOfDay = 128;\\n                } else if (zarelaDifficultyOfDay \\u003c 5) {\\n                    zarelaDifficultyOfDay = 2**zarelaDifficultyOfDay;\\n                } else {\\n                    zarelaDifficultyOfDay = 32;\\n                }\\n                \\n                todayContributionsCount = 0;\\n                zarelaDayCounter++;\\n                dayCounterOf20Months++;\\n                countDown24Hours = block.timestamp;\\n    \\n            }\\n            if (paymentQueue[indexCounter] == address(0)) {\\n                lastRewardableIndex = indexCounter;\\n                _reward();\\n                indexCounter+=2;\\n                todayContributionsCount++;\\n            } else if (lastRewardableIndex != indexOfAddressPendingReward) {\\n                _reward();\\n                indexCounter++;\\n            } else {\\n                indexCounter++;\\n            }\\n        }\\n        \\n        orderDataMap[_orderId].orderId = _orderId;\\n        orders[_orderId].countOfRegisteredContributions++;\\n        orderDataMap[_orderId].ipfsHash.push(_ipfsHash);\\n        orderDataMap[_orderId].encryptionKey.push(_encryptionKey);\\n        orderDataMap[_orderId].contributorAddresses.push(_contributorAddress);\\n        orderDataMap[_orderId].laboratoryAddresses.push(_laboratoryAddress);\\n        orderDataMap[_orderId].isConfirmedByMage.push(false);\\n        orderDataMap[_orderId].dataRegistrationTime.push(block.timestamp);\\n        userMap[_contributorAddress].angelContributedOrders.push(_orderId);\\n        userMap[_laboratoryAddress].laboratoryContributedOrders.push(_orderId);\\n        orderDataMap[_orderId].zarelaDay.push(zarelaDayCounter);\\n\\n        emit contributed(_contributorAddress , _laboratoryAddress ,_orderId ,_orderOwner ,zarelaDifficultyOfDay);\\n    }\\n    \\n    /// @dev Calculate and pay the Reward\\n    function _reward() private {\\n        uint temporary = indexOfAddressPendingReward;\\n        if (zarelaDifficultyOfDay == 128) {\\n            for (uint i= temporary; i \\u003c temporary + zarelaDifficultyOfDay; i++) {\\n                if (i \\u003e= lastRewardableIndex) {\\n                    break;\\n                }\\n                \\n                addressOfPendingReward = paymentQueue[i];\\n                \\n                if (addressOfPendingReward == address(0)) {\\n                    paymentDay++;\\n                    i++;\\n                    indexOfAddressPendingReward++;\\n                    addressOfPendingReward = paymentQueue[i];\\n                }\\n                \\n                _balances[addressOfPendingReward] = _balances[addressOfPendingReward] + ((dailyRewardPerContributor[paymentDay]));\\n                userMap[addressOfPendingReward].tokenGainedFromSC += (dailyRewardPerContributor[paymentDay]);\\n                indexOfAddressPendingReward++;\\n            }\\n        }\\n        if ((lastRewardableIndex - temporary) \\u003e= 16) {\\n            for (uint i = temporary  ; i \\u003c zarelaDifficultyOfDay + temporary ; i++) {\\n                if (i \\u003e= lastRewardableIndex) {\\n                    break;\\n                }\\n                \\n                addressOfPendingReward = paymentQueue[i];\\n                \\n                if (addressOfPendingReward == address(0)) {\\n                    paymentDay++;\\n                    i++;\\n                    indexOfAddressPendingReward++;\\n                    addressOfPendingReward = paymentQueue[i];\\n                }\\n                \\n                _balances[addressOfPendingReward] = _balances[addressOfPendingReward] + ((dailyRewardPerContributor[paymentDay]));\\n                userMap[addressOfPendingReward].tokenGainedFromSC += (dailyRewardPerContributor[paymentDay]);\\n                indexOfAddressPendingReward++;\\n            }\\n        } else if ((lastRewardableIndex - temporary) \\u003c 16) {\\n            for (uint i = temporary ; i \\u003c lastRewardableIndex ; i++) {\\n                addressOfPendingReward = paymentQueue[i];\\n                if (addressOfPendingReward == address(0)) {\\n                    paymentDay++;\\n                    i++;\\n                    indexOfAddressPendingReward++;\\n                    addressOfPendingReward = paymentQueue[i];\\n                }\\n                \\n                _balances[addressOfPendingReward] = _balances[addressOfPendingReward] + ((dailyRewardPerContributor[paymentDay]));\\n                userMap[addressOfPendingReward].tokenGainedFromSC += (dailyRewardPerContributor[paymentDay]);\\n                indexOfAddressPendingReward++;\\n            }\\n        }\\n    }\\n    \\n    /// @dev Confirm the signals sent by angels only by Requester (Mage) of that signal.\\n    /// The selection of files is based on their index.\\n    function confirmContributor(\\n        uint _orderId,\\n        uint[]memory _index\\n    )\\n        public \\n        onlyRequester(_orderId)\\n        checkOrderId(_orderId)\\n    {\\n        Order storage myorder = orders[_orderId];\\n        require(_index.length \\u003e= 1,\\\"You Should Select One At Least\\\");\\n        require(_index.length \\u003c= myorder.totalContributorsRemain,\\\"The number of entries is more than allowed\\\");\\n        require(myorder.totalContributorsRemain != 0,\\\"Your Order Is Done, And You Sent All of Rewards to Users\\\");\\n        myorder.totalContributorsRemain = myorder.totalContributorsRemain - (_index.length);\\n        _balances[address(this)] = _balances[address(this)] - ( (myorder.tokenPerContributor + myorder.tokenPerLaboratory) *  _index.length);\\n        for (uint i;i \\u003c _index.length ; i++) {\\n            _balances[orderDataMap[_orderId].contributorAddresses[_index[i]]] = _balances[orderDataMap[_orderId].contributorAddresses[_index[i]]] + (myorder.tokenPerContributor);\\n            _balances[orderDataMap[_orderId].laboratoryAddresses[_index[i]]] = _balances[orderDataMap[_orderId].laboratoryAddresses[_index[i]]] + (myorder.tokenPerLaboratory);\\n            userMap[orderDataMap[_orderId].contributorAddresses[_index[i]]].tokenGainedFromMages+=(myorder.tokenPerContributor);\\n            userMap[orderDataMap[_orderId].laboratoryAddresses[_index[i]]].tokenGainedFromMages+=(myorder.tokenPerLaboratory);\\n            orderDataMap[_orderId].isConfirmedByMage[_index[i]] = true;\\n        }\\n        \\n        if (myorder.totalContributorsRemain == 0) {\\n            emit orderFinished(_orderId);\\n        }\\n        emit signalsApproved(_orderId,_index.length);\\n    }\\n    \\n    /// @dev retrieves the value of each the specefic order by `_orderId`\\n    /// @return the contributors addresses , the Laboratory addresses , Time to send that signal by the angel , Laboratory or angel gained reward? , Status (true , false) of confirmation , Zarela day sent that signal\\n    function getOrderData(\\n        uint _orderId\\n    )\\n        public\\n        checkOrderId (_orderId)\\n        view returns (\\n            address[] memory,\\n            address[] memory,\\n            uint[]memory,\\n            bool[]memory,\\n            bool[] memory,\\n            uint[] memory)\\n    {\\n        return (\\n            orderDataMap[_orderId].contributorAddresses,\\n            orderDataMap[_orderId].laboratoryAddresses,\\n            orderDataMap[_orderId].dataRegistrationTime,\\n            orderDataMap[_orderId].whoGainedReward,\\n            orderDataMap[_orderId].isConfirmedByMage,\\n            orderDataMap[_orderId].zarelaDay\\n            );\\n    }\\n    \\n    /// @dev Receive angels\\u0027 signals by entering the orderId and just order\\u0027s owner can access.\\n    /// @return ipfsHash,encryptionKey\\n    function ownerSpecificData(\\n        uint _orderId\\n        )\\n        public \\n        onlyRequester(_orderId)\\n        checkOrderId(_orderId) \\n        view returns\\n        (\\n            string[] memory,\\n            string[] memory\\n        )\\n    {\\n        return (orderDataMap[_orderId].ipfsHash,orderDataMap[_orderId].encryptionKey);\\n    }\\n    \\n    /// @dev Check the orders registered and contributed by the user (angel or mage) who calls the function\\n    /// @return _ownedOrders and _contributedOrders\\n    function orderResult()\\n        public view returns\\n    (uint[]memory _ownedOrders,\\n    uint[]memory _angelContributedOrders,\\n    uint[]memory _laboratoryContributedOrders)\\n    {\\n        return (\\n            userMap[msg.sender].ownedOrders,\\n            userMap[msg.sender].angelContributedOrders,\\n            userMap[msg.sender].laboratoryContributedOrders\\n        );\\n    }\\n    \\n    /// @dev Total number of orders registered in Zarela\\n    /// @return length of all orders that registered in zarela\\n    function orderSize()\\n        public view returns (uint){\\n        return orders.length;\\n    }\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"labrotory\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mage\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"difficulty\",\"type\":\"uint256\"}],\"name\":\"contributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"orderFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"orderRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"confirmCount\",\"type\":\"uint256\"}],\"name\":\"signalsApproved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Categories\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"zarelaCategory\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"businessCategory\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bankBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"burnedTokensPerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_index\",\"type\":\"uint256[]\"}],\"name\":\"confirmContributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_contributorAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_laboratoryAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isContributorGainReward\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_orderOwner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_ipfsHash\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_encryptionKey\",\"type\":\"string\"}],\"name\":\"contribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countDown24Hours\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyContributionsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyRewardPerContributor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dayCounterOf20Months\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dayOfTokenBurning\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"}],\"name\":\"getOrderData\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"halvingCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"indexCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"indexOfAddressPendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"indexOfZeroDailyTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isZarelaEnd\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardableIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxUserDailyReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderDataMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderResult\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ownedOrders\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_angelContributedOrders\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_laboratoryContributedOrders\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"orderTitle\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"orderOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenPerContributor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenPerLaboratory\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalContributors\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"zPaper\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalContributorsRemain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"countOfRegisteredContributions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registrationTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"accessPublicKey\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"}],\"name\":\"ownerSpecificData\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paymentQueue\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"remainedDailyTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_orderTitle\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_zPaper\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPerContributor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPerLaboratory\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalContributors\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_zarelaCategory\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_businessCategory\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_accessPublicKey\",\"type\":\"string\"}],\"name\":\"submitNewRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"todayContributionsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenReleaseDaily\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenGainedFromSC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenGainedFromMages\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zarelaDayCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zarelaDifficultyOfDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ZarelaSmartContract","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6234e2fe8326eb8b5f53d69adbd0fcb3cf67498ecf99544129e361e0d44ff83a"}]}