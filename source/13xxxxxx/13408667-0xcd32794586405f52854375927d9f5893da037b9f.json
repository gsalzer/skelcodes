{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TokenVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n\\ncontract HasAdmin {\\n  event AdminChanged(address indexed _oldAdmin, address indexed _newAdmin);\\n  event AdminRemoved(address indexed _oldAdmin);\\n\\n  address public admin;\\n\\n  modifier onlyAdmin {\\n    require(msg.sender == admin, \\\"HasAdmin: not admin\\\");\\n    _;\\n  }\\n\\n  constructor() {\\n    admin = msg.sender;\\n    emit AdminChanged(address(0), admin);\\n  }\\n\\n  function changeAdmin(address _newAdmin) external onlyAdmin {\\n    require(_newAdmin != address(0), \\\"HasAdmin: new admin is the zero address\\\");\\n    emit AdminChanged(admin, _newAdmin);\\n    admin = _newAdmin;\\n  }\\n\\n  function removeAdmin() external onlyAdmin {\\n    emit AdminRemoved(admin);\\n    admin = address(0);\\n  }\\n}\\n\\n\\nlibrary SafeMath {\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    require(c >= a, \\\"SafeMath: addition overflow\\\");\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n    return a - b;\\n  }\\n\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    c = a * b;\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    // Since Solidity automatically asserts when dividing by 0,\\n    // but we only need it to revert.\\n    require(b > 0, \\\"SafeMath: division by zero\\\");\\n    return a / b;\\n  }\\n\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    // Same reason as `div`.\\n    require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n    return a % b;\\n  }\\n}\\n\\ninterface IERC20 {\\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n\\n  function totalSupply() external view returns (uint256 _supply);\\n  function balanceOf(address _owner) external view returns (uint256 _balance);\\n\\n  function approve(address _spender, uint256 _value) external returns (bool _success);\\n  function allowance(address _owner, address _spender) external view returns (uint256 _value);\\n\\n  function transfer(address _to, uint256 _value) external returns (bool _success);\\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool _success);\\n}\\n\\ncontract TokenVesting is HasAdmin {\\n  using SafeMath for uint256;\\n\\n  /**\\n    * @dev a Chunk is a period of time in which the beneficiary can receive the same amount of token each time a followUpDuration passes,\\n    * starting from effectiveDate (in relative to startTime).\\n   */\\n  struct Chunk {\\n    uint32 effectiveDate; // Duration from startTime that the chunk becomes effective\\n    uint256 amountPerUnlock;\\n    uint32 followUps;\\n    uint32 followUpDuration;\\n  }\\n\\n  struct BeneficiaryInfo {\\n    uint32 index; // Location of beneficiary in beneficiaryAddresses.\\n    Chunk[] chunks;\\n    uint256 claimedAmount;\\n  }\\n\\n  event StartTimeSet(uint256 _startTime);\\n  event BeneficiaryAdded(address indexed _beneficiary, uint32 _index);\\n  event BeneficiaryRemoved(address indexed _beneficiary);\\n  event TokenClaimed(address indexed _beneficiary, uint256 _amount);\\n\\n  IERC20 public token;\\n  uint256 public startTime;\\n  mapping(address => BeneficiaryInfo) public beneficiaries;\\n\\n  address[] public beneficiaryAddresses;\\n\\n  constructor(IERC20 _token, uint256 _startTime) {\\n    token = _token;\\n    editStartTime(_startTime);\\n    // Add a dummy address so all beneficiary index will be positive.\\n    beneficiaryAddresses.push(address(0));\\n  }\\n\\n  function editStartTime(uint256 _newTime) public onlyAdmin {\\n    startTime = _newTime;\\n    emit StartTimeSet(startTime);\\n  }\\n\\n  /**\\n   * @dev Function for admin to add another beneficiary, initiate with chunks.\\n  */\\n  function addBeneficiary(address _beneficiary, Chunk[] calldata _chunks) external onlyAdmin {\\n    require(beneficiaries[_beneficiary].index == 0, \\\"TokenVesting: Beneficiary already existed\\\");\\n\\n    uint32 _index = uint32(beneficiaryAddresses.length);\\n    beneficiaries[_beneficiary].index = _index;\\n    addChunks(_beneficiary, _chunks);\\n    beneficiaryAddresses.push(_beneficiary);\\n\\n    emit BeneficiaryAdded(_beneficiary, _index);\\n  }\\n\\n  /**\\n   * @dev Function for admin to add more chunks for a specific beneficiary.\\n  */\\n  function addChunks(address _beneficiary, Chunk[] memory _chunks) public onlyAdmin {\\n    require(beneficiaries[_beneficiary].index > 0, \\\"TokenVesting: Beneficiary not existed\\\");\\n\\n    Chunk[] storage _beneficiaryChunks = beneficiaries[_beneficiary].chunks;\\n\\n    for (uint256 _i = 0; _i < _chunks.length; _i++) {\\n        _beneficiaryChunks.push(_chunks[_i]);\\n    }\\n  }\\n\\n  /**\\n   * @dev Remove beneficiary, only used in rare cases that need some modifications.\\n  */\\n  function removeBeneficiary(address _beneficiary) external onlyAdmin {\\n    require(beneficiaries[_beneficiary].index > 0, \\\"TokenVesting: Beneficiary not existed\\\");\\n\\n    uint32 _currentIndex = beneficiaries[_beneficiary].index;\\n    uint256 _lastIndex = beneficiaryAddresses.length.sub(1);\\n\\n    // Replace by last item in array\\n    beneficiaryAddresses[_currentIndex] = beneficiaryAddresses[_lastIndex];\\n    beneficiaries[beneficiaryAddresses[_currentIndex]].index = _currentIndex;\\n\\n    beneficiaryAddresses.pop();\\n    delete beneficiaries[_beneficiary];\\n\\n    emit BeneficiaryRemoved(_beneficiary);\\n  }\\n\\n  /**\\n   * @dev Remove beneficiary, only used in rare cases that need some modifications.\\n  */\\n  function getBeneficiaryList() external view returns (address[] memory) {\\n    return beneficiaryAddresses;\\n  }\\n\\n  /**\\n   * @dev Query chunks of a beneficiary.\\n  */\\n  function beneficiaryChunks(address _beneficiary) external view returns (Chunk[] memory _chunks) {\\n    _chunks = beneficiaries[_beneficiary].chunks;\\n  }\\n\\n  /**\\n   * @dev Query total allocated token, both unlocked and locked.\\n  */\\n  function totalAllocatedAmount(address _beneficiary) external view returns (uint256 _amount) {\\n    Chunk[] storage _chunks = beneficiaries[_beneficiary].chunks;\\n\\n    for (uint256 _i = 0; _i < _chunks.length; _i++) {\\n      Chunk storage _chunk = _chunks[_i];\\n      _amount = _amount.add(_chunk.amountPerUnlock.mul(uint256(1).add(_chunk.followUps)));\\n    }\\n  }\\n\\n  /**\\n   * @dev Query unlocked amount at the current time.\\n  */\\n  function unlockedAmount(address _beneficiary) public view returns (uint256 _totalUnlocked, uint256 _claimable) {\\n    _totalUnlocked = unlockedAt(_beneficiary, block.timestamp);\\n\\n    uint256 _claimedAmount = beneficiaries[_beneficiary].claimedAmount;\\n    _claimable = _totalUnlocked.sub(_claimedAmount);\\n  }\\n\\n  /**\\n   * @dev Query unlocked amount at the specific timestamp.\\n  */\\n  function unlockedAt(address _beneficiary, uint256 _timestamp) public view returns (uint256 _totalUnlocked) {\\n    Chunk[] storage _chunks = beneficiaries[_beneficiary].chunks;\\n\\n    for (uint256 _i = 0; _i < _chunks.length; _i++) {\\n      Chunk storage _chunk = _chunks[_i];\\n\\n      if (startTime.add(_chunk.effectiveDate) <= _timestamp) {\\n        // Calculate how many follow-ups have occured\\n        uint256 followUps = 0;\\n\\n        if (_chunk.followUpDuration > 0) {\\n          followUps = _timestamp.sub(startTime.add(_chunks[_i].effectiveDate)).div(_chunk.followUpDuration);\\n        }\\n\\n        if (followUps > _chunk.followUps) {\\n          followUps = _chunk.followUps;\\n        }\\n\\n        // There are (followUps + 1) unlocks have happened\\n        _totalUnlocked = _totalUnlocked.add(_chunk.amountPerUnlock.mul(followUps.add(1)));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @dev Allows beneficiary to claim claimable tokens, can be called by anyone.\\n  */\\n  function claimToken(address _beneficiary) external {\\n    (uint256 _totalUnlocked, uint256 _claimable) = unlockedAmount(_beneficiary);\\n    require(_claimable > 0, \\\"TokenVesting: No claimable amount\\\");\\n\\n    beneficiaries[_beneficiary].claimedAmount = _totalUnlocked;\\n    token.transfer(_beneficiary, _claimable);\\n\\n    emit TokenClaimed(_beneficiary, _claimable);\\n  }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldAdmin\",\"type\":\"address\"}],\"name\":\"AdminRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"_index\",\"type\":\"uint32\"}],\"name\":\"BeneficiaryAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"BeneficiaryRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"StartTimeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenClaimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"effectiveDate\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amountPerUnlock\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"followUps\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"followUpDuration\",\"type\":\"uint32\"}],\"internalType\":\"struct TokenVesting.Chunk[]\",\"name\":\"_chunks\",\"type\":\"tuple[]\"}],\"name\":\"addBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"effectiveDate\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amountPerUnlock\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"followUps\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"followUpDuration\",\"type\":\"uint32\"}],\"internalType\":\"struct TokenVesting.Chunk[]\",\"name\":\"_chunks\",\"type\":\"tuple[]\"}],\"name\":\"addChunks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"beneficiaries\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"index\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"beneficiaryAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"beneficiaryChunks\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"effectiveDate\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amountPerUnlock\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"followUps\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"followUpDuration\",\"type\":\"uint32\"}],\"internalType\":\"struct TokenVesting.Chunk[]\",\"name\":\"_chunks\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTime\",\"type\":\"uint256\"}],\"name\":\"editStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBeneficiaryList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"removeBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"totalAllocatedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"unlockedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalUnlocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"unlockedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalUnlocked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokenVesting","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006076aedbe9af4e70550c341842bab5624b12395e00000000000000000000000000000000000000000000000000000000618a9b00","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}