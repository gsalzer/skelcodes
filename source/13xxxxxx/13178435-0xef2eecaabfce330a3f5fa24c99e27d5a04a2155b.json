{"status":"1","message":"OK","result":[{"SourceCode":"{\"ClaimBigSB.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n// Rzucam worki w tłum w tłum .. kto łapie ten jara ... XD\\n\\n/**\\nApes Together Strong!\\n\\nAbout BigShortBets DeFi project:\\n\\nWe are creating a social\\u0026trading p2p platform that guarantees encrypted interaction between investors.\\nLogging in is possible via a cryptocurrency wallet (e.g. Metamask).\\nThe security level is one comparable to the Tor network.\\n\\nhttps://bigsb.io/ - Our Tool\\nhttps://bigshortbets.com - Project\\u0026Team info\\n\\nVideo explainer:\\nhttps://youtu.be/wbhUo5IvKdk\\n\\nZaorski, You Son of a bitch I’m in …\\n*/\\n\\npragma solidity 0.8.7;\\nimport \\\"./interfaces.sol\\\";\\nimport \\\"./owned.sol\\\";\\n\\n/**\\nBigShortBets.com BigSB token claiming contract\\nContract need tokens on its address to send them to owners\\n\\n*/\\ncontract ClaimBigSB is Owned {\\n    // presale contracts\\n    address public immutable presale1;\\n    address public immutable presale2;\\n    address public immutable sale;\\n\\n    // BigSB token contract\\n    address public immutable token;\\n\\n    // 1-year claiming window after which Owner can sweep remaining tokens\\n    uint256 public immutable claimDateLimit;\\n\\n    // claiming process need to be enabled\\n    bool public claimStarted;\\n\\n    // Presale2 is bugged in handling multiple ETH deposits\\n    // we need handle that\\n    mapping(address =\\u003e uint256) internal buggedTokens;\\n\\n    // mark users that already claim tokens\\n    mapping(address =\\u003e bool) public isClaimed;\\n\\n    // handle ETH/tokens send from exchanges\\n    mapping(address =\\u003e address) internal _morty;\\n\\n    // AML-ed users address-\\u003etokens\\n    mapping(address =\\u003e uint256) internal _aml;\\n\\n    // events\\n    event TokensClaimed(\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount\\n    );\\n\\n    // useful constant\\n    address internal constant ZERO = address(0x0);\\n\\n    uint256 internal immutable startRate;\\n\\n    /**\\n    @dev contract constructor\\n    @param _presale1 address of presale1 contract\\n    @param _presale2 address of presale2 contract\\n    @param _sale address of final sale contract\\n    @param _token address of BigSB token contract\\n     */\\n    constructor(\\n        address _presale1,\\n        address _presale2,\\n        address _sale,\\n        address _token\\n    ) {\\n        presale1 = _presale1;\\n        presale2 = _presale2;\\n        sale = _sale;\\n        token = _token;\\n        claimDateLimit = block.timestamp + 365 days; //max 1 year to take tokens\\n        startRate = IReflect(_token).getRate();\\n    }\\n\\n    // count tokens from all pre/sale contracts\\n    function _allTokens(address user) internal view returns (uint256) {\\n        // presale2 need manual handle because of \\\"multiple ETH send\\\" error\\n        // \\\"tokensBoughtOf\\\" is also flawed, so we do all math there\\n        uint256 amt = buggedTokens[user];\\n        if (amt == 0) {\\n            // calculate tokens at sale price $2630/ETH, $0.95/token\\n            // function is returning ETH value in wei\\n            amt = (IPresale2(presale2).ethDepositOf(user) * 2630 * 100) / 95;\\n            // calculate tokens for USD at $0.95/token\\n            // contract is returning USD with 0 decimals\\n            amt += (IPresale2(presale2).usdDepositOf(user) * 100 ether) / 95;\\n        }\\n\\n        // presale1 reader is returning ETH amount in wei, $0.65 / token, $1530/ETH\\n        // yes, there is a typo in function name\\n        amt += (IPresale1(presale1).blanceOf(user) * 1530 * 100) / 65;\\n\\n        // sale returning tokens, $1/token, ETH price from oracle at buy time\\n        amt += ISale(sale).tokensBoughtOf(user);\\n\\n        return amt;\\n    }\\n\\n    /**\\n    Reader that can check how many tokens can be claimed by given address\\n    @param user address to check\\n    @return number of tokens (18 decimals)\\n    */\\n    function canClaim(address user) external view returns (uint256) {\\n        return _recalculate(_allTokens(user));\\n    }\\n\\n    // recalculate amount of tokens via start rate\\n    function _recalculate(uint256 tokens) internal view returns (uint256) {\\n        uint256 rate = IReflect(token).getRate();\\n        return (tokens * rate) / startRate;\\n    }\\n\\n    /**\\n    @dev claim BigSB tokens bought on any pre/sale\\n     */\\n    function claim() external {\\n        require(_morty[msg.sender] == ZERO, \\\"Use claimFrom\\\");\\n        _claim(msg.sender, msg.sender);\\n    }\\n\\n    /// Claim tokens from AMLed list\\n    function claimAML() external {\\n        uint256 amt = _aml[msg.sender];\\n        require(amt \\u003e 0, \\\"Not on AML list\\\");\\n        _aml[msg.sender] = 0;\\n        amt = _recalculate(amt);\\n        IERC20(token).transfer(msg.sender, amt);\\n        emit TokensClaimed(msg.sender, msg.sender, amt);\\n    }\\n\\n    /**\\n    @dev Claim BigSB tokens bought on any pre/sale to different address\\n    @param to address to which tokens will be claimed\\n     */\\n    function claimTo(address to) external {\\n        require(_morty[msg.sender] == ZERO, \\\"Use claimFromTo\\\");\\n        _claim(msg.sender, to);\\n    }\\n\\n    /**\\n    @dev Claim BigSB tokens bought on any pre/sale from exchange\\n    @param from sender address that ETH was send to pre/sale contract\\n     */\\n    function claimFrom(address from) external {\\n        address to = _morty[from];\\n        require(msg.sender == to, \\\"Wrong Morty\\\");\\n        _claim(from, to);\\n    }\\n\\n    /**\\n    @dev Claim BigSB tokens by ETH send from exchange to another address\\n    @param from sender address that ETH was send\\n    @param to address to which send claimed tokens\\n     */\\n    function claimFromTo(address from, address to) external {\\n        require(msg.sender == _morty[from], \\\"Wrong Morty\\\");\\n        _claim(from, to);\\n    }\\n\\n    // internal claim function, validate claim and send tokens to given address\\n    function _claim(address from, address to)\\n        internal\\n        claimStart\\n        notZeroAddress(to)\\n    {\\n        require(!isClaimed[from], \\\"Already claimed!\\\");\\n        isClaimed[from] = true;\\n        uint256 amt = _recalculate(_allTokens(from));\\n        require(IERC20(token).transfer(to, amt), \\\"Token transfer failed\\\");\\n        emit TokensClaimed(from, to, amt);\\n    }\\n\\n    //\\n    // viewers\\n    //\\n    function isReplacedBy(address user) external view returns (address) {\\n        return _morty[user];\\n    }\\n\\n    //\\n    // useful modifiers\\n    //\\n    modifier notZeroAddress(address user) {\\n        require(user != ZERO, \\\"Can not use address 0x0\\\");\\n        _;\\n    }\\n    modifier claimStart() {\\n        require(claimStarted, \\\"Claiming process not started!\\\");\\n        _;\\n    }\\n    modifier claimNotStarted() {\\n        require(!claimStarted, \\\"Claiming process already started!\\\");\\n        _;\\n    }\\n\\n    //\\n    // Rick mode\\n    //\\n\\n    /**\\n    @dev add single address that need to be changed in claim process\\n    @param bad address to replace\\n    @param good new address that can claim tokens bought by \\\"bad\\\" address\\n     */\\n    function addMorty(address bad, address good)\\n        external\\n        onlyOwner\\n        claimNotStarted\\n    {\\n        _addMorty(bad, good);\\n    }\\n\\n    /// internal add replacement address function used in singe and multi add function\\n    function _addMorty(address bad, address good)\\n        internal\\n        notZeroAddress(good)\\n    {\\n        require(_morty[bad] == ZERO, \\\"Morty already on list\\\");\\n        _morty[bad] = good;\\n    }\\n\\n    /**\\n    @dev add addresses that need to be replaced in claiming precess, ie send ETH from exchange\\n    @param bad list of wrong send addresses\\n    @param good list of address replacements\\n     */\\n    function addMortys(address[] calldata bad, address[] calldata good)\\n        external\\n        onlyOwner\\n        claimNotStarted\\n    {\\n        uint256 dl = bad.length;\\n        require(dl == good.length, \\\"Data size mismatch\\\");\\n        uint256 i;\\n        for (i; i \\u003c dl; i++) {\\n            _addMorty(bad[i], good[i]);\\n        }\\n    }\\n\\n    /**\\n    @dev add single \\\"bugged\\\" user\\n    @param user affected user address\\n    @param tokens counted tokens for user from presale2\\n     */\\n    function addBugged(address user, uint256 tokens)\\n        external\\n        onlyOwner\\n        claimNotStarted\\n    {\\n        buggedTokens[user] = tokens;\\n    }\\n\\n    /**\\n    @dev add list of users affected by \\\"many ETH send\\\" bug via list\\n    @param user list of users\\n    @param amt list of corresponding tokens amount\\n     */\\n    function addBuggedList(address[] calldata user, uint256[] calldata amt)\\n        external\\n        onlyOwner\\n        claimNotStarted\\n    {\\n        uint256 dl = user.length;\\n        require(dl == amt.length, \\\"Data size mismatch\\\");\\n        uint256 i;\\n        for (i; i \\u003c dl; i++) {\\n            buggedTokens[user[i]] = amt[i];\\n        }\\n    }\\n\\n    // add data to ALMed user list\\n    function addAML(address[] calldata user, uint256[] calldata tokens)\\n        external\\n        onlyOwner\\n        claimNotStarted\\n    {\\n        uint256 dl = user.length;\\n        require(dl == tokens.length, \\\"Data size mismatch\\\");\\n        uint256 i;\\n        for (i; i \\u003c dl; i++) {\\n            _aml[user[i]] = tokens[i];\\n        }\\n    }\\n\\n    /// Enable claiming process\\n    function enableClaim() external onlyOwner claimNotStarted {\\n        claimStarted = true;\\n    }\\n\\n    /**\\n    @dev Function to recover accidentally send ERC20 tokens\\n    @param erc20 ERC20 token address\\n    */\\n    function rescueERC20(address erc20) external onlyOwner {\\n        if (erc20 == token) {\\n            require(block.timestamp \\u003e claimDateLimit, \\\"Too soon\\\");\\n        }\\n        uint256 amt = IERC20(erc20).balanceOf(address(this));\\n        require(amt \\u003e 0, \\\"Nothing to rescue\\\");\\n        IUsdt(erc20).transfer(owner, amt);\\n    }\\n\\n    /**\\n    @dev Function to recover any ETH send to contract\\n    */\\n    function rescueETH() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n}\\n\\n//This is fine!\\n\"},\"interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\npragma solidity ^0.8.7;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\n// Reflection\\ninterface IReflect {\\n    function tokenFromReflection(uint256 rAmount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getRate() external view returns (uint256);\\n}\\n\\n/// ChainLink ETH/USD oracle\\ninterface IChainLink {\\n    // chainlink ETH/USD oracle\\n    // answer|int256 :  216182781556 - 8 decimals\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\\n/// USDT is not ERC-20 compliant, not returning true on transfers\\ninterface IUsdt {\\n    function transfer(address, uint256) external;\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\\n// Check ETH send to first presale\\n// Yes, there is a typo\\ninterface IPresale1 {\\n    function blanceOf(address user) external view returns (uint256 amt);\\n}\\n\\n// Check tokens bought in second presale\\n// There is bug in ETH deposits, we need handle it\\n// Also \\\"tokensBoughtOf\\\" calculation is broken, so we do all math\\ninterface IPresale2 {\\n    function ethDepositOf(address user) external view returns (uint256 amt);\\n\\n    function usdDepositOf(address user) external view returns (uint256 amt);\\n}\\n\\n// Check final sale tokens bought\\ninterface ISale {\\n    function tokensBoughtOf(address user) external view returns (uint256 amt);\\n}\\n\\ninterface IClaimSale {\\n    function addLock(\\n        address user,\\n        uint256 reflection,\\n        uint256 locktime\\n    ) external;\\n}\\n\"},\"owned.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\npragma solidity ^0.8.7;\\n\\ncontract Owned {\\n    address public owner;\\n    address public newOwner;\\n\\n    event OwnershipChanged(address from, address to);\\n\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnershipChanged(address(0), msg.sender);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        _;\\n    }\\n\\n    // owner can give super-rights to someone\\n    function giveOwnership(address user) external onlyOwner {\\n        require(user != address(0), \\\"User renounceOwnership\\\");\\n        newOwner = user;\\n    }\\n\\n    // new owner need to accept\\n    function acceptOwnership() external {\\n        require(msg.sender == newOwner, \\\"Only NewOwner\\\");\\n        emit OwnershipChanged(owner, newOwner);\\n        owner = msg.sender;\\n        delete newOwner;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_presale1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_presale2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sale\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"addAML\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"addBugged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amt\",\"type\":\"uint256[]\"}],\"name\":\"addBuggedList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bad\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"good\",\"type\":\"address\"}],\"name\":\"addMorty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"bad\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"good\",\"type\":\"address[]\"}],\"name\":\"addMortys\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"canClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAML\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDateLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"claimFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimFromTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"giveOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isReplacedBy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presale1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presale2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"}],\"name\":\"rescueERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sale\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ClaimBigSB","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001223730bae7fd3d2fe1e7948b0a90c8a9f3b84460000000000000000000000001863b0c9f63e686a3e7928a21b527c7b3ced5895000000000000000000000000152be47fbf953afa3953a997b81a0bd30ba6dc58000000000000000000000000131157c6760f78f7ddf877c0019eba175ba4b6f6","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://db9fcd60eb17f39ee92519edcca90797b5899a6eda01706a94f18a550b612269"}]}