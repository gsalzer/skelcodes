{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"solidity/contracts/Keep3r.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n/*\\n\\nCoded for The Keep3r Network with ♥ by\\n\\n██████╗░███████╗███████╗██╗  ░██╗░░░░░░░██╗░█████╗░███╗░░██╗██████╗░███████╗██████╗░██╗░░░░░░█████╗░███╗░░██╗██████╗░\\n██╔══██╗██╔════╝██╔════╝██║  ░██║░░██╗░░██║██╔══██╗████╗░██║██╔══██╗██╔════╝██╔══██╗██║░░░░░██╔══██╗████╗░██║██╔══██╗\\n██║░░██║█████╗░░█████╗░░██║  ░╚██╗████╗██╔╝██║░░██║██╔██╗██║██║░░██║█████╗░░██████╔╝██║░░░░░███████║██╔██╗██║██║░░██║\\n██║░░██║██╔══╝░░██╔══╝░░██║  ░░████╔═████║░██║░░██║██║╚████║██║░░██║██╔══╝░░██╔══██╗██║░░░░░██╔══██║██║╚████║██║░░██║\\n██████╔╝███████╗██║░░░░░██║  ░░╚██╔╝░╚██╔╝░╚█████╔╝██║░╚███║██████╔╝███████╗██║░░██║███████╗██║░░██║██║░╚███║██████╔╝\\n╚═════╝░╚══════╝╚═╝░░░░░╚═╝  ░░░╚═╝░░░╚═╝░░░╚════╝░╚═╝░░╚══╝╚═════╝░╚══════╝╚═╝░░╚═╝╚══════╝╚═╝░░╚═╝╚═╝░░╚══╝╚═════╝░\\n\\nhttps://defi.sucks\\n\\n*/\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport './peripherals/jobs/Keep3rJobs.sol';\\nimport './peripherals/keepers/Keep3rKeepers.sol';\\nimport './peripherals/Keep3rAccountance.sol';\\nimport './peripherals/Keep3rRoles.sol';\\nimport './peripherals/Keep3rParameters.sol';\\nimport './peripherals/DustCollector.sol';\\n\\ncontract Keep3r is DustCollector, Keep3rJobs, Keep3rKeepers {\\n  constructor(\\n    address _governance,\\n    address _keep3rHelper,\\n    address _keep3rV1,\\n    address _keep3rV1Proxy,\\n    address _kp3rWethPool\\n  ) Keep3rParameters(_keep3rHelper, _keep3rV1, _keep3rV1Proxy, _kp3rWethPool) Keep3rRoles(_governance) DustCollector() {}\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/jobs/Keep3rJobs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport './Keep3rJobDisputable.sol';\\nimport './Keep3rJobWorkable.sol';\\nimport './Keep3rJobManager.sol';\\n\\nabstract contract Keep3rJobs is Keep3rJobDisputable, Keep3rJobManager, Keep3rJobWorkable {}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/keepers/Keep3rKeepers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport './Keep3rKeeperDisputable.sol';\\n\\nabstract contract Keep3rKeepers is Keep3rKeeperDisputable {}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/Keep3rAccountance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\nimport '../../interfaces/peripherals/IKeep3rAccountance.sol';\\n\\nabstract contract Keep3rAccountance is IKeep3rAccountance {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  /// @notice List of all enabled keepers\\n  EnumerableSet.AddressSet internal _keepers;\\n\\n  /// @inheritdoc IKeep3rAccountance\\n  mapping(address => uint256) public override workCompleted;\\n\\n  /// @inheritdoc IKeep3rAccountance\\n  mapping(address => uint256) public override firstSeen;\\n\\n  /// @inheritdoc IKeep3rAccountance\\n  mapping(address => bool) public override disputes;\\n\\n  /// @inheritdoc IKeep3rAccountance\\n  /// @notice Mapping (job => bonding => amount)\\n  mapping(address => mapping(address => uint256)) public override bonds;\\n\\n  /// @inheritdoc IKeep3rAccountance\\n  mapping(address => mapping(address => uint256)) public override jobTokenCredits;\\n\\n  /// @notice The current liquidity credits available for a job\\n  mapping(address => uint256) internal _jobLiquidityCredits;\\n\\n  /// @notice Map the address of a job to its correspondent periodCredits\\n  mapping(address => uint256) internal _jobPeriodCredits;\\n\\n  /// @notice Enumerable array of Job Tokens for Credits\\n  mapping(address => EnumerableSet.AddressSet) internal _jobTokens;\\n\\n  /// @notice List of liquidities that a job has (job => liquidities)\\n  mapping(address => EnumerableSet.AddressSet) internal _jobLiquidities;\\n\\n  /// @notice Liquidity pool to observe\\n  mapping(address => address) internal _liquidityPool;\\n\\n  /// @notice Tracks if a pool has KP3R as token0\\n  mapping(address => bool) internal _isKP3RToken0;\\n\\n  /// @inheritdoc IKeep3rAccountance\\n  mapping(address => mapping(address => uint256)) public override pendingBonds;\\n\\n  /// @inheritdoc IKeep3rAccountance\\n  mapping(address => mapping(address => uint256)) public override canActivateAfter;\\n\\n  /// @inheritdoc IKeep3rAccountance\\n  mapping(address => mapping(address => uint256)) public override canWithdrawAfter;\\n\\n  /// @inheritdoc IKeep3rAccountance\\n  mapping(address => mapping(address => uint256)) public override pendingUnbonds;\\n\\n  /// @inheritdoc IKeep3rAccountance\\n  mapping(address => bool) public override hasBonded;\\n\\n  /// @notice List of all enabled jobs\\n  EnumerableSet.AddressSet internal _jobs;\\n\\n  /// @inheritdoc IKeep3rAccountance\\n  function jobs() external view override returns (address[] memory _list) {\\n    _list = _jobs.values();\\n  }\\n\\n  /// @inheritdoc IKeep3rAccountance\\n  function keepers() external view override returns (address[] memory _list) {\\n    _list = _keepers.values();\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/Keep3rRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport '../../interfaces/peripherals/IKeep3rRoles.sol';\\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\nimport './Governable.sol';\\n\\ncontract Keep3rRoles is IKeep3rRoles, Governable {\\n  /// @inheritdoc IKeep3rRoles\\n  mapping(address => bool) public override slashers;\\n\\n  /// @inheritdoc IKeep3rRoles\\n  mapping(address => bool) public override disputers;\\n\\n  constructor(address _governance) Governable(_governance) {}\\n\\n  /// @inheritdoc IKeep3rRoles\\n  function addSlasher(address _slasher) external override onlyGovernance {\\n    if (slashers[_slasher]) revert SlasherExistent();\\n    slashers[_slasher] = true;\\n    emit SlasherAdded(_slasher);\\n  }\\n\\n  /// @inheritdoc IKeep3rRoles\\n  function removeSlasher(address _slasher) external override onlyGovernance {\\n    if (!slashers[_slasher]) revert SlasherUnexistent();\\n    delete slashers[_slasher];\\n    emit SlasherRemoved(_slasher);\\n  }\\n\\n  /// @inheritdoc IKeep3rRoles\\n  function addDisputer(address _disputer) external override onlyGovernance {\\n    if (disputers[_disputer]) revert DisputerExistent();\\n    disputers[_disputer] = true;\\n    emit DisputerAdded(_disputer);\\n  }\\n\\n  /// @inheritdoc IKeep3rRoles\\n  function removeDisputer(address _disputer) external override onlyGovernance {\\n    if (!disputers[_disputer]) revert DisputerUnexistent();\\n    delete disputers[_disputer];\\n    emit DisputerRemoved(_disputer);\\n  }\\n\\n  /// @notice Functions with this modifier can only be called by either a slasher or governance\\n  modifier onlySlasher {\\n    if (!slashers[msg.sender]) revert OnlySlasher();\\n    _;\\n  }\\n\\n  /// @notice Functions with this modifier can only be called by either a disputer or governance\\n  modifier onlyDisputer {\\n    if (!disputers[msg.sender]) revert OnlyDisputer();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/Keep3rParameters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport '../../interfaces/IKeep3rHelper.sol';\\nimport '../../interfaces/peripherals/IKeep3rParameters.sol';\\nimport './Keep3rAccountance.sol';\\nimport './Keep3rRoles.sol';\\n\\nabstract contract Keep3rParameters is IKeep3rParameters, Keep3rAccountance, Keep3rRoles {\\n  /// @inheritdoc IKeep3rParameters\\n  address public override keep3rV1;\\n\\n  /// @inheritdoc IKeep3rParameters\\n  address public override keep3rV1Proxy;\\n\\n  /// @inheritdoc IKeep3rParameters\\n  address public override keep3rHelper;\\n\\n  /// @inheritdoc IKeep3rParameters\\n  address public override kp3rWethPool;\\n\\n  /// @inheritdoc IKeep3rParameters\\n  uint256 public override bondTime = 3 days;\\n\\n  /// @inheritdoc IKeep3rParameters\\n  uint256 public override unbondTime = 14 days;\\n\\n  /// @inheritdoc IKeep3rParameters\\n  uint256 public override liquidityMinimum = 3 ether;\\n\\n  /// @inheritdoc IKeep3rParameters\\n  uint256 public override rewardPeriodTime = 5 days;\\n\\n  /// @inheritdoc IKeep3rParameters\\n  uint256 public override inflationPeriod = 34 days;\\n\\n  /// @inheritdoc IKeep3rParameters\\n  uint256 public override fee = 30;\\n\\n  /// @inheritdoc IKeep3rParameters\\n  uint256 public constant override BASE = 10000;\\n\\n  /// @inheritdoc IKeep3rParameters\\n  uint256 public constant override MIN_REWARD_PERIOD_TIME = 1 days;\\n\\n  constructor(\\n    address _keep3rHelper,\\n    address _keep3rV1,\\n    address _keep3rV1Proxy,\\n    address _kp3rWethPool\\n  ) {\\n    keep3rHelper = _keep3rHelper;\\n    keep3rV1 = _keep3rV1;\\n    keep3rV1Proxy = _keep3rV1Proxy;\\n    kp3rWethPool = _kp3rWethPool;\\n    _liquidityPool[kp3rWethPool] = kp3rWethPool;\\n    _isKP3RToken0[_kp3rWethPool] = IKeep3rHelper(keep3rHelper).isKP3RToken0(kp3rWethPool);\\n  }\\n\\n  /// @inheritdoc IKeep3rParameters\\n  function setKeep3rHelper(address _keep3rHelper) external override onlyGovernance {\\n    if (_keep3rHelper == address(0)) revert ZeroAddress();\\n    keep3rHelper = _keep3rHelper;\\n    emit Keep3rHelperChange(_keep3rHelper);\\n  }\\n\\n  /// @inheritdoc IKeep3rParameters\\n  function setKeep3rV1(address _keep3rV1) external override onlyGovernance {\\n    if (_keep3rV1 == address(0)) revert ZeroAddress();\\n    keep3rV1 = _keep3rV1;\\n    emit Keep3rV1Change(_keep3rV1);\\n  }\\n\\n  /// @inheritdoc IKeep3rParameters\\n  function setKeep3rV1Proxy(address _keep3rV1Proxy) external override onlyGovernance {\\n    if (_keep3rV1Proxy == address(0)) revert ZeroAddress();\\n    keep3rV1Proxy = _keep3rV1Proxy;\\n    emit Keep3rV1ProxyChange(_keep3rV1Proxy);\\n  }\\n\\n  /// @inheritdoc IKeep3rParameters\\n  function setKp3rWethPool(address _kp3rWethPool) external override onlyGovernance {\\n    if (_kp3rWethPool == address(0)) revert ZeroAddress();\\n    kp3rWethPool = _kp3rWethPool;\\n    _liquidityPool[kp3rWethPool] = kp3rWethPool;\\n    _isKP3RToken0[_kp3rWethPool] = IKeep3rHelper(keep3rHelper).isKP3RToken0(_kp3rWethPool);\\n    emit Kp3rWethPoolChange(_kp3rWethPool);\\n  }\\n\\n  /// @inheritdoc IKeep3rParameters\\n  function setBondTime(uint256 _bondTime) external override onlyGovernance {\\n    bondTime = _bondTime;\\n    emit BondTimeChange(_bondTime);\\n  }\\n\\n  /// @inheritdoc IKeep3rParameters\\n  function setUnbondTime(uint256 _unbondTime) external override onlyGovernance {\\n    unbondTime = _unbondTime;\\n    emit UnbondTimeChange(_unbondTime);\\n  }\\n\\n  /// @inheritdoc IKeep3rParameters\\n  function setLiquidityMinimum(uint256 _liquidityMinimum) external override onlyGovernance {\\n    liquidityMinimum = _liquidityMinimum;\\n    emit LiquidityMinimumChange(_liquidityMinimum);\\n  }\\n\\n  /// @inheritdoc IKeep3rParameters\\n  function setRewardPeriodTime(uint256 _rewardPeriodTime) external override onlyGovernance {\\n    if (_rewardPeriodTime < MIN_REWARD_PERIOD_TIME) revert MinRewardPeriod();\\n    rewardPeriodTime = _rewardPeriodTime;\\n    emit RewardPeriodTimeChange(_rewardPeriodTime);\\n  }\\n\\n  /// @inheritdoc IKeep3rParameters\\n  function setInflationPeriod(uint256 _inflationPeriod) external override onlyGovernance {\\n    inflationPeriod = _inflationPeriod;\\n    emit InflationPeriodChange(_inflationPeriod);\\n  }\\n\\n  /// @inheritdoc IKeep3rParameters\\n  function setFee(uint256 _fee) external override onlyGovernance {\\n    fee = _fee;\\n    emit FeeChange(_fee);\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/DustCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '../../contracts/peripherals/Governable.sol';\\nimport '../../interfaces/peripherals/IDustCollector.sol';\\n\\nabstract contract DustCollector is IDustCollector, Governable {\\n  using SafeERC20 for IERC20;\\n\\n  address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n  function sendDust(\\n    address _token,\\n    uint256 _amount,\\n    address _to\\n  ) external override onlyGovernance {\\n    if (_to == address(0)) revert ZeroAddress();\\n    if (_token == ETH_ADDRESS) {\\n      payable(_to).transfer(_amount);\\n    } else {\\n      IERC20(_token).safeTransfer(_to, _amount);\\n    }\\n    emit DustSent(_token, _amount, _to);\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/jobs/Keep3rJobDisputable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport './Keep3rJobFundableCredits.sol';\\nimport './Keep3rJobFundableLiquidity.sol';\\nimport '../Keep3rDisputable.sol';\\n\\nabstract contract Keep3rJobDisputable is IKeep3rJobDisputable, Keep3rDisputable, Keep3rJobFundableCredits, Keep3rJobFundableLiquidity {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using SafeERC20 for IERC20;\\n\\n  /// @inheritdoc IKeep3rJobDisputable\\n  function slashTokenFromJob(\\n    address _job,\\n    address _token,\\n    uint256 _amount\\n  ) external override onlySlasher {\\n    if (!disputes[_job]) revert NotDisputed();\\n    if (!_jobTokens[_job].contains(_token)) revert JobTokenUnexistent();\\n    if (jobTokenCredits[_job][_token] < _amount) revert JobTokenInsufficient();\\n\\n    try IERC20(_token).transfer(governance, _amount) {} catch {}\\n    jobTokenCredits[_job][_token] -= _amount;\\n    if (jobTokenCredits[_job][_token] == 0) {\\n      _jobTokens[_job].remove(_token);\\n    }\\n\\n    // emit event\\n    emit JobSlashToken(_job, _token, msg.sender, _amount);\\n  }\\n\\n  /// @inheritdoc IKeep3rJobDisputable\\n  function slashLiquidityFromJob(\\n    address _job,\\n    address _liquidity,\\n    uint256 _amount\\n  ) external override onlySlasher {\\n    if (!disputes[_job]) revert NotDisputed();\\n\\n    _unbondLiquidityFromJob(_job, _liquidity, _amount);\\n    try IERC20(_liquidity).transfer(governance, _amount) {} catch {}\\n    emit JobSlashLiquidity(_job, _liquidity, msg.sender, _amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/jobs/Keep3rJobWorkable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport './Keep3rJobMigration.sol';\\nimport '../../../interfaces/IKeep3rHelper.sol';\\nimport '../../../interfaces/peripherals/IKeep3rJobs.sol';\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\n\\nabstract contract Keep3rJobWorkable is IKeep3rJobWorkable, Keep3rJobMigration {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using SafeERC20 for IERC20;\\n\\n  uint256 internal _initialGas;\\n\\n  /// @inheritdoc IKeep3rJobWorkable\\n  function isKeeper(address _keeper) external override returns (bool _isKeeper) {\\n    _initialGas = gasleft();\\n    if (_keepers.contains(_keeper)) {\\n      emit KeeperValidation(gasleft());\\n      return true;\\n    }\\n  }\\n\\n  /// @inheritdoc IKeep3rJobWorkable\\n  function isBondedKeeper(\\n    address _keeper,\\n    address _bond,\\n    uint256 _minBond,\\n    uint256 _earned,\\n    uint256 _age\\n  ) public override returns (bool _isBondedKeeper) {\\n    _initialGas = gasleft();\\n    if (\\n      _keepers.contains(_keeper) &&\\n      bonds[_keeper][_bond] >= _minBond &&\\n      workCompleted[_keeper] >= _earned &&\\n      block.timestamp - firstSeen[_keeper] >= _age\\n    ) {\\n      emit KeeperValidation(gasleft());\\n      return true;\\n    }\\n  }\\n\\n  /// @inheritdoc IKeep3rJobWorkable\\n  function worked(address _keeper) external override {\\n    address _job = msg.sender;\\n    if (disputes[_job]) revert JobDisputed();\\n    if (!_jobs.contains(_job)) revert JobUnapproved();\\n\\n    if (_updateJobCreditsIfNeeded(_job)) {\\n      emit LiquidityCreditsReward(_job, rewardedAt[_job], _jobLiquidityCredits[_job], _jobPeriodCredits[_job]);\\n    }\\n\\n    uint256 _gasRecord = gasleft();\\n    uint256 _boost = IKeep3rHelper(keep3rHelper).getRewardBoostFor(bonds[_keeper][keep3rV1]);\\n\\n    uint256 _payment = (_quoteLiquidity(_initialGas - _gasRecord, kp3rWethPool) * _boost) / BASE;\\n\\n    if (_payment > _jobLiquidityCredits[_job]) {\\n      _rewardJobCredits(_job);\\n      emit LiquidityCreditsReward(_job, rewardedAt[_job], _jobLiquidityCredits[_job], _jobPeriodCredits[_job]);\\n    }\\n\\n    uint256 _gasUsed = _initialGas - gasleft();\\n    _payment = (_gasUsed * _payment) / (_initialGas - _gasRecord);\\n\\n    _bondedPayment(_job, _keeper, _payment);\\n    emit KeeperWork(keep3rV1, _job, _keeper, _payment, gasleft());\\n  }\\n\\n  /// @inheritdoc IKeep3rJobWorkable\\n  function bondedPayment(address _keeper, uint256 _payment) public override {\\n    address _job = msg.sender;\\n\\n    if (disputes[_job]) revert JobDisputed();\\n    if (!_jobs.contains(_job)) revert JobUnapproved();\\n\\n    if (_updateJobCreditsIfNeeded(_job)) {\\n      emit LiquidityCreditsReward(_job, rewardedAt[_job], _jobLiquidityCredits[_job], _jobPeriodCredits[_job]);\\n    }\\n\\n    if (_payment > _jobLiquidityCredits[_job]) {\\n      _rewardJobCredits(_job);\\n      emit LiquidityCreditsReward(_job, rewardedAt[_job], _jobLiquidityCredits[_job], _jobPeriodCredits[_job]);\\n    }\\n\\n    _bondedPayment(_job, _keeper, _payment);\\n    emit KeeperWork(keep3rV1, _job, _keeper, _payment, gasleft());\\n  }\\n\\n  function _bondedPayment(\\n    address _job,\\n    address _keeper,\\n    uint256 _payment\\n  ) internal {\\n    if (_payment > _jobLiquidityCredits[_job]) revert InsufficientFunds();\\n\\n    workedAt[_job] = block.timestamp;\\n    _jobLiquidityCredits[_job] -= _payment;\\n    bonds[_keeper][keep3rV1] += _payment;\\n    workCompleted[_keeper] += _payment;\\n  }\\n\\n  /// @inheritdoc IKeep3rJobWorkable\\n  function directTokenPayment(\\n    address _token,\\n    address _keeper,\\n    uint256 _amount\\n  ) external override {\\n    address _job = msg.sender;\\n\\n    if (disputes[_job]) revert JobDisputed();\\n    if (disputes[_keeper]) revert Disputed();\\n    if (!_jobs.contains(_job)) revert JobUnapproved();\\n    if (jobTokenCredits[_job][_token] < _amount) revert InsufficientFunds();\\n    jobTokenCredits[_job][_token] -= _amount;\\n    IERC20(_token).safeTransfer(_keeper, _amount);\\n    emit KeeperWork(_token, _job, _keeper, _amount, gasleft());\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/jobs/Keep3rJobManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport './Keep3rJobOwnership.sol';\\nimport '../Keep3rRoles.sol';\\nimport '../Keep3rParameters.sol';\\nimport '../../../interfaces/peripherals/IKeep3rJobs.sol';\\n\\nabstract contract Keep3rJobManager is IKeep3rJobManager, Keep3rJobOwnership, Keep3rRoles, Keep3rParameters {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  /// @inheritdoc IKeep3rJobManager\\n  function addJob(address _job) external override {\\n    if (_jobs.contains(_job)) revert JobAlreadyAdded();\\n    if (hasBonded[_job]) revert AlreadyAKeeper();\\n    _jobs.add(_job);\\n    jobOwner[_job] = msg.sender;\\n    emit JobAddition(msg.sender, _job);\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/jobs/Keep3rJobFundableCredits.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport './Keep3rJobOwnership.sol';\\nimport '../Keep3rAccountance.sol';\\nimport '../Keep3rParameters.sol';\\nimport '../../../interfaces/peripherals/IKeep3rJobs.sol';\\n\\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '@openzeppelin/contracts/utils/math/Math.sol';\\n\\nabstract contract Keep3rJobFundableCredits is IKeep3rJobFundableCredits, ReentrancyGuard, Keep3rJobOwnership, Keep3rParameters {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using SafeERC20 for IERC20;\\n\\n  /// @notice Cooldown between withdrawals\\n  uint256 internal constant _WITHDRAW_TOKENS_COOLDOWN = 1 minutes;\\n\\n  /// @inheritdoc IKeep3rJobFundableCredits\\n  mapping(address => mapping(address => uint256)) public override jobTokenCreditsAddedAt;\\n\\n  /// @inheritdoc IKeep3rJobFundableCredits\\n  function addTokenCreditsToJob(\\n    address _job,\\n    address _token,\\n    uint256 _amount\\n  ) external override nonReentrant {\\n    if (!_jobs.contains(_job)) revert JobUnavailable();\\n    // KP3R shouldn't be used for direct token payments\\n    if (_token == keep3rV1) revert TokenUnallowed();\\n    uint256 _before = IERC20(_token).balanceOf(address(this));\\n    IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\\n    uint256 _received = IERC20(_token).balanceOf(address(this)) - _before;\\n    uint256 _tokenFee = (_received * fee) / BASE;\\n    jobTokenCredits[_job][_token] += _received - _tokenFee;\\n    jobTokenCreditsAddedAt[_job][_token] = block.timestamp;\\n    IERC20(_token).safeTransfer(governance, _tokenFee);\\n    _jobTokens[_job].add(_token);\\n\\n    emit TokenCreditAddition(_job, _token, msg.sender, _received);\\n  }\\n\\n  /// @inheritdoc IKeep3rJobFundableCredits\\n  function withdrawTokenCreditsFromJob(\\n    address _job,\\n    address _token,\\n    uint256 _amount,\\n    address _receiver\\n  ) external override nonReentrant onlyJobOwner(_job) {\\n    if (block.timestamp <= jobTokenCreditsAddedAt[_job][_token] + _WITHDRAW_TOKENS_COOLDOWN) revert JobTokenCreditsLocked();\\n    if (jobTokenCredits[_job][_token] < _amount) revert InsufficientJobTokenCredits();\\n    if (disputes[_job]) revert JobDisputed();\\n\\n    jobTokenCredits[_job][_token] -= _amount;\\n    IERC20(_token).safeTransfer(_receiver, _amount);\\n\\n    if (jobTokenCredits[_job][_token] == 0) {\\n      _jobTokens[_job].remove(_token);\\n    }\\n\\n    emit TokenCreditWithdrawal(_job, _token, _receiver, _amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/jobs/Keep3rJobFundableLiquidity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport './Keep3rJobOwnership.sol';\\nimport '../Keep3rAccountance.sol';\\nimport '../Keep3rParameters.sol';\\nimport '../../../interfaces/IPairManager.sol';\\nimport '../../../interfaces/peripherals/IKeep3rJobs.sol';\\n\\nimport '../../libraries/FullMath.sol';\\n\\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '@openzeppelin/contracts/utils/math/Math.sol';\\n\\nabstract contract Keep3rJobFundableLiquidity is IKeep3rJobFundableLiquidity, ReentrancyGuard, Keep3rJobOwnership, Keep3rParameters {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using SafeERC20 for IERC20;\\n\\n  /// @notice List of liquidities that are accepted in the system\\n  EnumerableSet.AddressSet internal _approvedLiquidities;\\n\\n  /// @inheritdoc IKeep3rJobFundableLiquidity\\n  mapping(address => mapping(address => uint256)) public override liquidityAmount;\\n\\n  /// @inheritdoc IKeep3rJobFundableLiquidity\\n  mapping(address => uint256) public override rewardedAt;\\n\\n  /// @inheritdoc IKeep3rJobFundableLiquidity\\n  mapping(address => uint256) public override workedAt;\\n\\n  /// @notice Tracks an address and returns its TickCache\\n  mapping(address => TickCache) internal _tick;\\n\\n  // Views\\n\\n  /// @inheritdoc IKeep3rJobFundableLiquidity\\n  function approvedLiquidities() external view override returns (address[] memory _list) {\\n    _list = _approvedLiquidities.values();\\n  }\\n\\n  /// @inheritdoc IKeep3rJobFundableLiquidity\\n  function jobPeriodCredits(address _job) public view override returns (uint256 _periodCredits) {\\n    for (uint256 i; i < _jobLiquidities[_job].length(); i++) {\\n      address _liquidity = _jobLiquidities[_job].at(i);\\n      if (_approvedLiquidities.contains(_liquidity)) {\\n        TickCache memory _tickCache = observeLiquidity(_liquidity);\\n        if (_tickCache.period != 0) {\\n          int56 _tickDifference = _isKP3RToken0[_liquidity] ? _tickCache.difference : -_tickCache.difference;\\n          _periodCredits += _getReward(\\n            IKeep3rHelper(keep3rHelper).getKP3RsAtTick(liquidityAmount[_job][_liquidity], _tickDifference, rewardPeriodTime)\\n          );\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @inheritdoc IKeep3rJobFundableLiquidity\\n  function jobLiquidityCredits(address _job) public view override returns (uint256 _liquidityCredits) {\\n    uint256 _periodCredits = jobPeriodCredits(_job);\\n\\n    // A job can have liquidityCredits without periodCredits (forced by Governance)\\n    if (rewardedAt[_job] > _period(block.timestamp - rewardPeriodTime)) {\\n      // Will calculate job credits only if it was rewarded later than last period\\n      if ((block.timestamp - rewardedAt[_job]) >= rewardPeriodTime) {\\n        // Will return a full period if job was rewarded more than a period ago\\n        _liquidityCredits = _periodCredits;\\n      } else {\\n        // Will update minted job credits (not forced) to new twaps if credits are outdated\\n        _liquidityCredits = _periodCredits > 0\\n          ? (_jobLiquidityCredits[_job] * _periodCredits) / _jobPeriodCredits[_job]\\n          : _jobLiquidityCredits[_job];\\n      }\\n    } else {\\n      // Will return a full period if job credits are expired\\n      _liquidityCredits = _periodCredits;\\n    }\\n  }\\n\\n  /// @inheritdoc IKeep3rJobFundableLiquidity\\n  function totalJobCredits(address _job) external view override returns (uint256 _credits) {\\n    uint256 _periodCredits = jobPeriodCredits(_job);\\n    uint256 _cooldown;\\n\\n    if ((rewardedAt[_job] > _period(block.timestamp - rewardPeriodTime))) {\\n      // Will calculate cooldown if it outdated\\n      if ((block.timestamp - rewardedAt[_job]) >= rewardPeriodTime) {\\n        // Will calculate cooldown from last reward reference in this period\\n        _cooldown = block.timestamp - (rewardedAt[_job] + rewardPeriodTime);\\n      } else {\\n        // Will calculate cooldown from last reward timestamp\\n        _cooldown = block.timestamp - rewardedAt[_job];\\n      }\\n    } else {\\n      // Will calculate cooldown from period start if expired\\n      _cooldown = block.timestamp - _period(block.timestamp);\\n    }\\n    _credits = jobLiquidityCredits(_job) + _phase(_cooldown, _periodCredits);\\n  }\\n\\n  /// @inheritdoc IKeep3rJobFundableLiquidity\\n  function quoteLiquidity(address _liquidity, uint256 _amount) external view override returns (uint256 _periodCredits) {\\n    if (_approvedLiquidities.contains(_liquidity)) {\\n      TickCache memory _tickCache = observeLiquidity(_liquidity);\\n      if (_tickCache.period != 0) {\\n        int56 _tickDifference = _isKP3RToken0[_liquidity] ? _tickCache.difference : -_tickCache.difference;\\n        return _getReward(IKeep3rHelper(keep3rHelper).getKP3RsAtTick(_amount, _tickDifference, rewardPeriodTime));\\n      }\\n    }\\n  }\\n\\n  /// @inheritdoc IKeep3rJobFundableLiquidity\\n  function observeLiquidity(address _liquidity) public view override returns (TickCache memory _tickCache) {\\n    if (_tick[_liquidity].period == _period(block.timestamp)) {\\n      // Will return cached twaps if liquidity is updated\\n      _tickCache = _tick[_liquidity];\\n    } else {\\n      bool success;\\n      uint256 lastPeriod = _period(block.timestamp - rewardPeriodTime);\\n\\n      if (_tick[_liquidity].period == lastPeriod) {\\n        // Will only ask for current period accumulator if liquidity is outdated\\n        uint32[] memory _secondsAgo = new uint32[](1);\\n        int56 previousTick = _tick[_liquidity].current;\\n\\n        _secondsAgo[0] = uint32(block.timestamp - _period(block.timestamp));\\n\\n        (_tickCache.current, , success) = IKeep3rHelper(keep3rHelper).observe(_liquidityPool[_liquidity], _secondsAgo);\\n\\n        _tickCache.difference = _tickCache.current - previousTick;\\n      } else if (_tick[_liquidity].period < lastPeriod) {\\n        // Will ask for 2 accumulators if liquidity is expired\\n        uint32[] memory _secondsAgo = new uint32[](2);\\n\\n        _secondsAgo[0] = uint32(block.timestamp - _period(block.timestamp));\\n        _secondsAgo[1] = uint32(block.timestamp - _period(block.timestamp) + rewardPeriodTime);\\n\\n        int56 _tickCumulative2;\\n        (_tickCache.current, _tickCumulative2, success) = IKeep3rHelper(keep3rHelper).observe(_liquidityPool[_liquidity], _secondsAgo);\\n\\n        _tickCache.difference = _tickCache.current - _tickCumulative2;\\n      }\\n      if (success) {\\n        _tickCache.period = _period(block.timestamp);\\n      } else {\\n        _tickCache.period = 0;\\n      }\\n    }\\n  }\\n\\n  // Methods\\n\\n  /// @inheritdoc IKeep3rJobFundableLiquidity\\n  function forceLiquidityCreditsToJob(address _job, uint256 _amount) external override onlyGovernance {\\n    if (!_jobs.contains(_job)) revert JobUnavailable();\\n    _settleJobAccountance(_job);\\n    _jobLiquidityCredits[_job] += _amount;\\n    emit LiquidityCreditsForced(_job, rewardedAt[_job], _jobLiquidityCredits[_job]);\\n  }\\n\\n  /// @inheritdoc IKeep3rJobFundableLiquidity\\n  function approveLiquidity(address _liquidity) external override onlyGovernance {\\n    if (!_approvedLiquidities.add(_liquidity)) revert LiquidityPairApproved();\\n    _liquidityPool[_liquidity] = IPairManager(_liquidity).pool();\\n    _isKP3RToken0[_liquidity] = IKeep3rHelper(keep3rHelper).isKP3RToken0(_liquidityPool[_liquidity]);\\n    _tick[_liquidity] = observeLiquidity(_liquidity);\\n    emit LiquidityApproval(_liquidity);\\n  }\\n\\n  /// @inheritdoc IKeep3rJobFundableLiquidity\\n  function revokeLiquidity(address _liquidity) external override onlyGovernance {\\n    if (!_approvedLiquidities.remove(_liquidity)) revert LiquidityPairUnexistent();\\n    emit LiquidityRevocation(_liquidity);\\n  }\\n\\n  /// @inheritdoc IKeep3rJobFundableLiquidity\\n  function addLiquidityToJob(\\n    address _job,\\n    address _liquidity,\\n    uint256 _amount\\n  ) external override nonReentrant {\\n    if (!_approvedLiquidities.contains(_liquidity)) revert LiquidityPairUnapproved();\\n    if (!_jobs.contains(_job)) revert JobUnavailable();\\n\\n    _jobLiquidities[_job].add(_liquidity);\\n\\n    _settleJobAccountance(_job);\\n\\n    if (_quoteLiquidity(liquidityAmount[_job][_liquidity] + _amount, _liquidity) < liquidityMinimum) revert JobLiquidityLessThanMin();\\n\\n    emit LiquidityCreditsReward(_job, rewardedAt[_job], _jobLiquidityCredits[_job], _jobPeriodCredits[_job]);\\n\\n    IERC20(_liquidity).safeTransferFrom(msg.sender, address(this), _amount);\\n    liquidityAmount[_job][_liquidity] += _amount;\\n    _jobPeriodCredits[_job] += _getReward(_quoteLiquidity(_amount, _liquidity));\\n    emit LiquidityAddition(_job, _liquidity, msg.sender, _amount);\\n  }\\n\\n  /// @inheritdoc IKeep3rJobFundableLiquidity\\n  function unbondLiquidityFromJob(\\n    address _job,\\n    address _liquidity,\\n    uint256 _amount\\n  ) external override onlyJobOwner(_job) {\\n    canWithdrawAfter[_job][_liquidity] = block.timestamp + unbondTime;\\n    pendingUnbonds[_job][_liquidity] += _amount;\\n    _unbondLiquidityFromJob(_job, _liquidity, _amount);\\n\\n    uint256 _remainingLiquidity = liquidityAmount[_job][_liquidity];\\n    if (_remainingLiquidity > 0 && _quoteLiquidity(_remainingLiquidity, _liquidity) < liquidityMinimum) revert JobLiquidityLessThanMin();\\n\\n    emit Unbonding(_job, _liquidity, _amount);\\n  }\\n\\n  /// @inheritdoc IKeep3rJobFundableLiquidity\\n  function withdrawLiquidityFromJob(\\n    address _job,\\n    address _liquidity,\\n    address _receiver\\n  ) external override onlyJobOwner(_job) {\\n    if (_receiver == address(0)) revert ZeroAddress();\\n    if (canWithdrawAfter[_job][_liquidity] == 0) revert UnbondsUnexistent();\\n    if (canWithdrawAfter[_job][_liquidity] >= block.timestamp) revert UnbondsLocked();\\n    if (disputes[_job]) revert Disputed();\\n\\n    uint256 _amount = pendingUnbonds[_job][_liquidity];\\n    IERC20(_liquidity).safeTransfer(_receiver, _amount);\\n    emit LiquidityWithdrawal(_job, _liquidity, _receiver, _amount);\\n\\n    pendingUnbonds[_job][_liquidity] = 0;\\n  }\\n\\n  // Internal functions\\n\\n  /// @notice Updates or rewards job liquidity credits depending on time since last job reward\\n  function _updateJobCreditsIfNeeded(address _job) internal returns (bool _rewarded) {\\n    if (rewardedAt[_job] < _period(block.timestamp)) {\\n      // Will exit function if job has been rewarded in current period\\n      if (rewardedAt[_job] <= _period(block.timestamp - rewardPeriodTime)) {\\n        // Will reset job to period syncronicity if a full period passed without rewards\\n        _updateJobPeriod(_job);\\n        _jobLiquidityCredits[_job] = _jobPeriodCredits[_job];\\n        rewardedAt[_job] = _period(block.timestamp);\\n        _rewarded = true;\\n      } else if ((block.timestamp - rewardedAt[_job]) >= rewardPeriodTime) {\\n        // Will reset job's syncronicity if last reward was more than epoch ago\\n        _updateJobPeriod(_job);\\n        _jobLiquidityCredits[_job] = _jobPeriodCredits[_job];\\n        rewardedAt[_job] += rewardPeriodTime;\\n        _rewarded = true;\\n      } else if (workedAt[_job] < _period(block.timestamp)) {\\n        // First keeper on period has to update job accountance to current twaps\\n        uint256 previousPeriodCredits = _jobPeriodCredits[_job];\\n        _updateJobPeriod(_job);\\n        _jobLiquidityCredits[_job] = (_jobLiquidityCredits[_job] * _jobPeriodCredits[_job]) / previousPeriodCredits;\\n        // Updating job accountance does not reward job\\n      }\\n    }\\n  }\\n\\n  /// @notice Only called if _jobLiquidityCredits < payment\\n  function _rewardJobCredits(address _job) internal {\\n    /// @notice Only way to += jobLiquidityCredits is when keeper rewarding (cannot pay work)\\n    /* WARNING: this allows to top up _jobLiquidityCredits to a max of 1.99 but have to spend at least 1 */\\n    _jobLiquidityCredits[_job] += _phase(block.timestamp - rewardedAt[_job], _jobPeriodCredits[_job]);\\n    rewardedAt[_job] = block.timestamp;\\n  }\\n\\n  /// @notice Updates accountance for _jobPeriodCredits\\n  function _updateJobPeriod(address _job) internal {\\n    _jobPeriodCredits[_job] = _calculateJobPeriodCredits(_job);\\n  }\\n\\n  /// @notice Quotes the outdated job liquidities and calculates _periodCredits\\n  /// @dev This function is also responsible for keeping the KP3R/WETH quote updated\\n  function _calculateJobPeriodCredits(address _job) internal returns (uint256 _periodCredits) {\\n    if (_tick[kp3rWethPool].period != _period(block.timestamp)) {\\n      // Updates KP3R/WETH quote if needed\\n      _tick[kp3rWethPool] = observeLiquidity(kp3rWethPool);\\n    }\\n\\n    for (uint256 i; i < _jobLiquidities[_job].length(); i++) {\\n      address _liquidity = _jobLiquidities[_job].at(i);\\n      if (_approvedLiquidities.contains(_liquidity)) {\\n        if (_tick[_liquidity].period != _period(block.timestamp)) {\\n          // Updates liquidity cache only if needed\\n          _tick[_liquidity] = observeLiquidity(_liquidity);\\n        }\\n        _periodCredits += _getReward(_quoteLiquidity(liquidityAmount[_job][_liquidity], _liquidity));\\n      }\\n    }\\n  }\\n\\n  /// @notice Updates job accountance calculating the impact of the unbonded liquidity amount\\n  function _unbondLiquidityFromJob(\\n    address _job,\\n    address _liquidity,\\n    uint256 _amount\\n  ) internal nonReentrant {\\n    if (!_jobLiquidities[_job].contains(_liquidity)) revert JobLiquidityUnexistent();\\n    if (liquidityAmount[_job][_liquidity] < _amount) revert JobLiquidityInsufficient();\\n\\n    // Ensures current twaps in job liquidities\\n    _updateJobPeriod(_job);\\n    uint256 _periodCreditsToRemove = _getReward(_quoteLiquidity(_amount, _liquidity));\\n\\n    // A liquidity can be revoked causing a job to have 0 periodCredits\\n    if (_jobPeriodCredits[_job] > 0) {\\n      // Removes a % correspondant to a full rewardPeriodTime for the liquidity withdrawn vs all of the liquidities\\n      _jobLiquidityCredits[_job] -= (_jobLiquidityCredits[_job] * _periodCreditsToRemove) / _jobPeriodCredits[_job];\\n      _jobPeriodCredits[_job] -= _periodCreditsToRemove;\\n    }\\n\\n    liquidityAmount[_job][_liquidity] -= _amount;\\n    if (liquidityAmount[_job][_liquidity] == 0) {\\n      _jobLiquidities[_job].remove(_liquidity);\\n    }\\n  }\\n\\n  /// @notice Returns a fraction of the multiplier or the whole multiplier if equal or more than a rewardPeriodTime has passed\\n  function _phase(uint256 _timePassed, uint256 _multiplier) internal view returns (uint256 _result) {\\n    if (_timePassed < rewardPeriodTime) {\\n      _result = (_timePassed * _multiplier) / rewardPeriodTime;\\n    } else _result = _multiplier;\\n  }\\n\\n  /// @notice Returns the start of the period of the provided timestamp\\n  function _period(uint256 _timestamp) internal view returns (uint256 _periodTimestamp) {\\n    return _timestamp - (_timestamp % rewardPeriodTime);\\n  }\\n\\n  /// @notice Calculates relation between rewardPeriod and inflationPeriod\\n  function _getReward(uint256 _baseAmount) internal view returns (uint256 _credits) {\\n    return FullMath.mulDiv(_baseAmount, rewardPeriodTime, inflationPeriod);\\n  }\\n\\n  /// @notice Returns underlying KP3R amount for a given liquidity amount\\n  function _quoteLiquidity(uint256 _amount, address _liquidity) internal view returns (uint256 _quote) {\\n    if (_tick[_liquidity].period != 0) {\\n      int56 _tickDifference = _isKP3RToken0[_liquidity] ? _tick[_liquidity].difference : -_tick[_liquidity].difference;\\n      _quote = IKeep3rHelper(keep3rHelper).getKP3RsAtTick(_amount, _tickDifference, rewardPeriodTime);\\n    }\\n  }\\n\\n  /// @notice Updates job credits to current quotes and rewards job's pending minted credits\\n  /// @dev Ensures a maximum of 1 period of credits\\n  function _settleJobAccountance(address _job) internal virtual {\\n    _updateJobCreditsIfNeeded(_job);\\n    _rewardJobCredits(_job);\\n    _jobLiquidityCredits[_job] = Math.min(_jobLiquidityCredits[_job], _jobPeriodCredits[_job]);\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/Keep3rDisputable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport './Keep3rParameters.sol';\\nimport './Keep3rRoles.sol';\\nimport '../../interfaces/peripherals/IKeep3rDisputable.sol';\\n\\nabstract contract Keep3rDisputable is IKeep3rDisputable, Keep3rAccountance, Keep3rRoles {\\n  /// @inheritdoc IKeep3rDisputable\\n  function dispute(address _jobOrKeeper) external override onlyDisputer {\\n    if (disputes[_jobOrKeeper]) revert AlreadyDisputed();\\n    disputes[_jobOrKeeper] = true;\\n    emit Dispute(_jobOrKeeper, msg.sender);\\n  }\\n\\n  /// @inheritdoc IKeep3rDisputable\\n  function resolve(address _jobOrKeeper) external override onlyDisputer {\\n    if (!disputes[_jobOrKeeper]) revert NotDisputed();\\n    disputes[_jobOrKeeper] = false;\\n    emit Resolve(_jobOrKeeper, msg.sender);\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/jobs/Keep3rJobOwnership.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport '../../../interfaces/peripherals/IKeep3rJobs.sol';\\n\\nabstract contract Keep3rJobOwnership is IKeep3rJobOwnership {\\n  /// @inheritdoc IKeep3rJobOwnership\\n  mapping(address => address) public override jobOwner;\\n\\n  /// @inheritdoc IKeep3rJobOwnership\\n  mapping(address => address) public override jobPendingOwner;\\n\\n  /// @inheritdoc IKeep3rJobOwnership\\n  function changeJobOwnership(address _job, address _newOwner) external override onlyJobOwner(_job) {\\n    jobPendingOwner[_job] = _newOwner;\\n    emit JobOwnershipChange(_job, jobOwner[_job], _newOwner);\\n  }\\n\\n  /// @inheritdoc IKeep3rJobOwnership\\n  function acceptJobOwnership(address _job) external override onlyPendingJobOwner(_job) {\\n    address _previousOwner = jobOwner[_job];\\n\\n    jobOwner[_job] = jobPendingOwner[_job];\\n    delete jobPendingOwner[_job];\\n\\n    emit JobOwnershipAssent(msg.sender, _job, _previousOwner);\\n  }\\n\\n  modifier onlyJobOwner(address _job) {\\n    if (msg.sender != jobOwner[_job]) revert OnlyJobOwner();\\n    _;\\n  }\\n\\n  modifier onlyPendingJobOwner(address _job) {\\n    if (msg.sender != jobPendingOwner[_job]) revert OnlyPendingJobOwner();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/peripherals/IKeep3rJobs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\n/// @title Keep3rJobFundableCredits contract\\n/// @notice Handles the addition and withdrawal of credits from a job\\ninterface IKeep3rJobFundableCredits {\\n  // Events\\n\\n  /// @notice Emitted when Keep3rJobFundableCredits#addTokenCreditsToJob is called\\n  /// @param _job The address of the job being credited\\n  /// @param _token The address of the token being provided\\n  /// @param _provider The user that calls the function\\n  /// @param _amount The amount of credit being added to the job\\n  event TokenCreditAddition(address indexed _job, address indexed _token, address indexed _provider, uint256 _amount);\\n\\n  /// @notice Emitted when Keep3rJobFundableCredits#withdrawTokenCreditsFromJob is called\\n  /// @param _job The address of the job from which the credits are withdrawn\\n  /// @param _token The credit being withdrawn from the job\\n  /// @param _receiver The user that receives the tokens\\n  /// @param _amount The amount of credit withdrawn\\n  event TokenCreditWithdrawal(address indexed _job, address indexed _token, address indexed _receiver, uint256 _amount);\\n\\n  // Errors\\n\\n  /// @notice Throws when the token is KP3R, as it should not be used for direct token payments\\n  error TokenUnallowed();\\n\\n  /// @notice Throws when the token withdraw cooldown has not yet passed\\n  error JobTokenCreditsLocked();\\n\\n  /// @notice Throws when the user tries to withdraw more tokens than it has\\n  error InsufficientJobTokenCredits();\\n\\n  // Variables\\n\\n  /// @notice Last block where tokens were added to the job [job => token => timestamp]\\n  /// @return _timestamp The last block where tokens were added to the job\\n  function jobTokenCreditsAddedAt(address _job, address _token) external view returns (uint256 _timestamp);\\n\\n  // Methods\\n\\n  /// @notice Add credit to a job to be paid out for work\\n  /// @param _job The address of the job being credited\\n  /// @param _token The address of the token being credited\\n  /// @param _amount The amount of credit being added\\n  function addTokenCreditsToJob(\\n    address _job,\\n    address _token,\\n    uint256 _amount\\n  ) external;\\n\\n  /// @notice Withdraw credit from a job\\n  /// @param _job The address of the job from which the credits are withdrawn\\n  /// @param _token The address of the token being withdrawn\\n  /// @param _amount The amount of token to be withdrawn\\n  /// @param _receiver The user that will receive tokens\\n  function withdrawTokenCreditsFromJob(\\n    address _job,\\n    address _token,\\n    uint256 _amount,\\n    address _receiver\\n  ) external;\\n}\\n\\n/// @title  Keep3rJobFundableLiquidity contract\\n/// @notice Handles the funding of jobs through specific liquidity pairs\\ninterface IKeep3rJobFundableLiquidity {\\n  // Events\\n\\n  /// @notice Emitted when Keep3rJobFundableLiquidity#approveLiquidity function is called\\n  /// @param _liquidity The address of the liquidity pair being approved\\n  event LiquidityApproval(address _liquidity);\\n\\n  /// @notice Emitted when Keep3rJobFundableLiquidity#revokeLiquidity function is called\\n  /// @param _liquidity The address of the liquidity pair being revoked\\n  event LiquidityRevocation(address _liquidity);\\n\\n  /// @notice Emitted when IKeep3rJobFundableLiquidity#addLiquidityToJob function is called\\n  /// @param _job The address of the job to which liquidity will be added\\n  /// @param _liquidity The address of the liquidity being added\\n  /// @param _provider The user that calls the function\\n  /// @param _amount The amount of liquidity being added\\n  event LiquidityAddition(address indexed _job, address indexed _liquidity, address indexed _provider, uint256 _amount);\\n\\n  /// @notice Emitted when IKeep3rJobFundableLiquidity#withdrawLiquidityFromJob function is called\\n  /// @param _job The address of the job of which liquidity will be withdrawn from\\n  /// @param _liquidity The address of the liquidity being withdrawn\\n  /// @param _receiver The receiver of the liquidity tokens\\n  /// @param _amount The amount of liquidity being withdrawn from the job\\n  event LiquidityWithdrawal(address indexed _job, address indexed _liquidity, address indexed _receiver, uint256 _amount);\\n\\n  /// @notice Emitted when Keep3rJobFundableLiquidity#addLiquidityToJob function is called\\n  /// @param _job The address of the job whose credits will be updated\\n  /// @param _rewardedAt The time at which the job was last rewarded\\n  /// @param _currentCredits The current credits of the job\\n  /// @param _periodCredits The credits of the job for the current period\\n  event LiquidityCreditsReward(address indexed _job, uint256 _rewardedAt, uint256 _currentCredits, uint256 _periodCredits);\\n\\n  /// @notice Emitted when Keep3rJobFundableLiquidity#forceLiquidityCreditsToJob function is called\\n  /// @param _job The address of the job whose credits will be updated\\n  /// @param _rewardedAt The time at which the job was last rewarded\\n  /// @param _currentCredits The current credits of the job\\n  event LiquidityCreditsForced(address indexed _job, uint256 _rewardedAt, uint256 _currentCredits);\\n\\n  // Errors\\n\\n  /// @notice Throws when the liquidity being approved has already been approved\\n  error LiquidityPairApproved();\\n\\n  /// @notice Throws when the liquidity being removed has not been approved\\n  error LiquidityPairUnexistent();\\n\\n  /// @notice Throws when trying to add liquidity to an unapproved pool\\n  error LiquidityPairUnapproved();\\n\\n  /// @notice Throws when the job doesn't have the requested liquidity\\n  error JobLiquidityUnexistent();\\n\\n  /// @notice Throws when trying to remove more liquidity than the job has\\n  error JobLiquidityInsufficient();\\n\\n  /// @notice Throws when trying to add less liquidity than the minimum liquidity required\\n  error JobLiquidityLessThanMin();\\n\\n  // Structs\\n\\n  /// @notice Stores the tick information of the different liquidity pairs\\n  struct TickCache {\\n    int56 current; // Tracks the current tick\\n    int56 difference; // Stores the difference between the current tick and the last tick\\n    uint256 period; // Stores the period at which the last observation was made\\n  }\\n\\n  // Variables\\n\\n  /// @notice Lists liquidity pairs\\n  /// @return _list An array of addresses with all the approved liquidity pairs\\n  function approvedLiquidities() external view returns (address[] memory _list);\\n\\n  /// @notice Amount of liquidity in a specified job\\n  /// @param _job The address of the job being checked\\n  /// @param _liquidity The address of the liquidity we are checking\\n  /// @return _amount Amount of liquidity in the specified job\\n  function liquidityAmount(address _job, address _liquidity) external view returns (uint256 _amount);\\n\\n  /// @notice Last time the job was rewarded liquidity credits\\n  /// @param _job The address of the job being checked\\n  /// @return _timestamp Timestamp of the last time the job was rewarded liquidity credits\\n  function rewardedAt(address _job) external view returns (uint256 _timestamp);\\n\\n  /// @notice Last time the job was worked\\n  /// @param _job The address of the job being checked\\n  /// @return _timestamp Timestamp of the last time the job was worked\\n  function workedAt(address _job) external view returns (uint256 _timestamp);\\n\\n  // Methods\\n\\n  /// @notice Returns the liquidity credits of a given job\\n  /// @param _job The address of the job of which we want to know the liquidity credits\\n  /// @return _amount The liquidity credits of a given job\\n  function jobLiquidityCredits(address _job) external view returns (uint256 _amount);\\n\\n  /// @notice Returns the credits of a given job for the current period\\n  /// @param _job The address of the job of which we want to know the period credits\\n  /// @return _amount The credits the given job has at the current period\\n  function jobPeriodCredits(address _job) external view returns (uint256 _amount);\\n\\n  /// @notice Calculates the total credits of a given job\\n  /// @param _job The address of the job of which we want to know the total credits\\n  /// @return _amount The total credits of the given job\\n  function totalJobCredits(address _job) external view returns (uint256 _amount);\\n\\n  /// @notice Calculates how many credits should be rewarded periodically for a given liquidity amount\\n  /// @dev _periodCredits = underlying KP3Rs for given liquidity amount * rewardPeriod / inflationPeriod\\n  /// @param _liquidity The liquidity to provide\\n  /// @param _amount The amount of liquidity to provide\\n  /// @return _periodCredits The amount of KP3R periodically minted for the given liquidity\\n  function quoteLiquidity(address _liquidity, uint256 _amount) external view returns (uint256 _periodCredits);\\n\\n  /// @notice Observes the current state of the liquidity pair being observed and updates TickCache with the information\\n  /// @param _liquidity The liquidity pair being observed\\n  /// @return _tickCache The updated TickCache\\n  function observeLiquidity(address _liquidity) external view returns (TickCache memory _tickCache);\\n\\n  /// @notice Gifts liquidity credits to the specified job\\n  /// @param _job The address of the job being credited\\n  /// @param _amount The amount of liquidity credits to gift\\n  function forceLiquidityCreditsToJob(address _job, uint256 _amount) external;\\n\\n  /// @notice Approve a liquidity pair for being accepted in future\\n  /// @param _liquidity The address of the liquidity accepted\\n  function approveLiquidity(address _liquidity) external;\\n\\n  /// @notice Revoke a liquidity pair from being accepted in future\\n  /// @param _liquidity The liquidity no longer accepted\\n  function revokeLiquidity(address _liquidity) external;\\n\\n  /// @notice Allows anyone to fund a job with liquidity\\n  /// @param _job The address of the job to assign liquidity to\\n  /// @param _liquidity The liquidity being added\\n  /// @param _amount The amount of liquidity tokens to add\\n  function addLiquidityToJob(\\n    address _job,\\n    address _liquidity,\\n    uint256 _amount\\n  ) external;\\n\\n  /// @notice Unbond liquidity for a job\\n  /// @dev Can only be called by the job's owner\\n  /// @param _job The address of the job being unbound from\\n  /// @param _liquidity The liquidity being unbound\\n  /// @param _amount The amount of liquidity being removed\\n  function unbondLiquidityFromJob(\\n    address _job,\\n    address _liquidity,\\n    uint256 _amount\\n  ) external;\\n\\n  /// @notice Withdraw liquidity from a job\\n  /// @param _job The address of the job being withdrawn from\\n  /// @param _liquidity The liquidity being withdrawn\\n  /// @param _receiver The address that will receive the withdrawn liquidity\\n  function withdrawLiquidityFromJob(\\n    address _job,\\n    address _liquidity,\\n    address _receiver\\n  ) external;\\n}\\n\\n/// @title Keep3rJobManager contract\\n/// @notice Handles the addition and withdrawal of credits from a job\\ninterface IKeep3rJobManager {\\n  // Events\\n\\n  /// @notice Emitted when Keep3rJobManager#addJob is called\\n  /// @param _job The address of the job to add\\n  /// @param _jobOwner The job's owner\\n  event JobAddition(address indexed _job, address indexed _jobOwner);\\n\\n  // Errors\\n\\n  /// @notice Throws when trying to add a job that has already been added\\n  error JobAlreadyAdded();\\n\\n  /// @notice Throws when the address that is trying to register as a keeper is already a keeper\\n  error AlreadyAKeeper();\\n\\n  // Methods\\n\\n  /// @notice Allows any caller to add a new job\\n  /// @param _job Address of the contract for which work should be performed\\n  function addJob(address _job) external;\\n}\\n\\n/// @title Keep3rJobWorkable contract\\n/// @notice Handles the mechanisms jobs can pay keepers with along with the restrictions jobs can put on keepers before they can work on jobs\\ninterface IKeep3rJobWorkable {\\n  // Events\\n\\n  /// @notice Emitted when a keeper is validated before a job\\n  /// @param _gasLeft The amount of gas that the transaction has left at the moment of keeper validation\\n  event KeeperValidation(uint256 _gasLeft);\\n\\n  /// @notice Emitted when a keeper works a job\\n  /// @param _credit The address of the asset in which the keeper is paid\\n  /// @param _job The address of the job the keeper has worked\\n  /// @param _keeper The address of the keeper that has worked the job\\n  /// @param _amount The amount that has been paid out to the keeper in exchange for working the job\\n  /// @param _gasLeft The amount of gas that the transaction has left at the moment of payment\\n  event KeeperWork(address indexed _credit, address indexed _job, address indexed _keeper, uint256 _amount, uint256 _gasLeft);\\n\\n  // Errors\\n\\n  /// @notice Throws if the address claiming to be a job is not in the list of approved jobs\\n  error JobUnapproved();\\n\\n  /// @notice Throws if the amount of funds in the job is less than the payment that must be paid to the keeper that works that job\\n  error InsufficientFunds();\\n\\n  // Methods\\n\\n  /// @notice Confirms if the current keeper is registered, can be used for general (non critical) functions\\n  /// @param _keeper The keeper being investigated\\n  /// @return _isKeeper Whether the address passed as a parameter is a keeper or not\\n  function isKeeper(address _keeper) external returns (bool _isKeeper);\\n\\n  /// @notice Confirms if the current keeper is registered and has a minimum bond of any asset. Should be used for protected functions\\n  /// @param _keeper The keeper to check\\n  /// @param _bond The bond token being evaluated\\n  /// @param _minBond The minimum amount of bonded tokens\\n  /// @param _earned The minimum funds earned in the keepers lifetime\\n  /// @param _age The minimum keeper age required\\n  /// @return _isBondedKeeper Whether the `_keeper` meets the given requirements\\n  function isBondedKeeper(\\n    address _keeper,\\n    address _bond,\\n    uint256 _minBond,\\n    uint256 _earned,\\n    uint256 _age\\n  ) external returns (bool _isBondedKeeper);\\n\\n  /// @notice Implemented by jobs to show that a keeper performed work\\n  /// @dev Automatically calculates the payment for the keeper\\n  /// @param _keeper Address of the keeper that performed the work\\n  function worked(address _keeper) external;\\n\\n  /// @notice Implemented by jobs to show that a keeper performed work\\n  /// @dev Pays the keeper that performs the work with KP3R\\n  /// @param _keeper Address of the keeper that performed the work\\n  /// @param _payment The reward that should be allocated for the job\\n  function bondedPayment(address _keeper, uint256 _payment) external;\\n\\n  /// @notice Implemented by jobs to show that a keeper performed work\\n  /// @dev Pays the keeper that performs the work with a specific token\\n  /// @param _token The asset being awarded to the keeper\\n  /// @param _keeper Address of the keeper that performed the work\\n  /// @param _amount The reward that should be allocated\\n  function directTokenPayment(\\n    address _token,\\n    address _keeper,\\n    uint256 _amount\\n  ) external;\\n}\\n\\n/// @title Keep3rJobOwnership contract\\n/// @notice Handles the ownership of the jobs\\ninterface IKeep3rJobOwnership {\\n  // Events\\n\\n  /// @notice Emitted when Keep3rJobOwnership#changeJobOwnership is called\\n  /// @param _job The address of the job proposed to have a change of owner\\n  /// @param _owner The current owner of the job\\n  /// @param _pendingOwner The new address proposed to be the owner of the job\\n  event JobOwnershipChange(address indexed _job, address indexed _owner, address indexed _pendingOwner);\\n\\n  /// @notice Emitted when Keep3rJobOwnership#JobOwnershipAssent is called\\n  /// @param _job The address of the job which the proposed owner will now own\\n  /// @param _previousOwner The previous owner of the job\\n  /// @param _newOwner The newowner of the job\\n  event JobOwnershipAssent(address indexed _job, address indexed _previousOwner, address indexed _newOwner);\\n\\n  // Errors\\n\\n  /// @notice Throws when the caller of the function is not the job owner\\n  error OnlyJobOwner();\\n\\n  /// @notice Throws when the caller of the function is not the pending job owner\\n  error OnlyPendingJobOwner();\\n\\n  // Variables\\n\\n  /// @notice Maps the job to the owner of the job (job => user)\\n  /// @return _owner The addres of the owner of the job\\n  function jobOwner(address _job) external view returns (address _owner);\\n\\n  /// @notice Maps the owner of the job to its pending owner (job => user)\\n  /// @return _pendingOwner The address of the pending owner of the job\\n  function jobPendingOwner(address _job) external view returns (address _pendingOwner);\\n\\n  // Methods\\n\\n  /// @notice Proposes a new address to be the owner of the job\\n  function changeJobOwnership(address _job, address _newOwner) external;\\n\\n  /// @notice The proposed address accepts to be the owner of the job\\n  function acceptJobOwnership(address _job) external;\\n}\\n\\n/// @title Keep3rJobMigration contract\\n/// @notice Handles the migration process of jobs to different addresses\\ninterface IKeep3rJobMigration {\\n  // Events\\n\\n  /// @notice Emitted when Keep3rJobMigration#migrateJob function is called\\n  /// @param _fromJob The address of the job that requests to migrate\\n  /// @param _toJob The address at which the job requests to migrate\\n  event JobMigrationRequested(address indexed _fromJob, address _toJob);\\n\\n  /// @notice Emitted when Keep3rJobMigration#acceptJobMigration function is called\\n  /// @param _fromJob The address of the job that requested to migrate\\n  /// @param _toJob The address at which the job had requested to migrate\\n  event JobMigrationSuccessful(address _fromJob, address indexed _toJob);\\n\\n  // Errors\\n\\n  /// @notice Throws when the address of the job that requests to migrate wants to migrate to its same address\\n  error JobMigrationImpossible();\\n\\n  /// @notice Throws when the _toJob address differs from the address being tracked in the pendingJobMigrations mapping\\n  error JobMigrationUnavailable();\\n\\n  /// @notice Throws when cooldown between migrations has not yet passed\\n  error JobMigrationLocked();\\n\\n  // Variables\\n\\n  /// @notice Maps the jobs that have requested a migration to the address they have requested to migrate to\\n  /// @return _toJob The address to which the job has requested to migrate to\\n  function pendingJobMigrations(address _fromJob) external view returns (address _toJob);\\n\\n  // Methods\\n\\n  /// @notice Initializes the migration process for a job by adding the request to the pendingJobMigrations mapping\\n  /// @param _fromJob The address of the job that is requesting to migrate\\n  /// @param _toJob The address at which the job is requesting to migrate\\n  function migrateJob(address _fromJob, address _toJob) external;\\n\\n  /// @notice Completes the migration process for a job\\n  /// @dev Unbond/withdraw process doesn't get migrated\\n  /// @param _fromJob The address of the job that requested to migrate\\n  /// @param _toJob The address to which the job wants to migrate to\\n  function acceptJobMigration(address _fromJob, address _toJob) external;\\n}\\n\\n/// @title Keep3rJobDisputable contract\\n/// @notice Handles the actions that can be taken on a disputed job\\ninterface IKeep3rJobDisputable is IKeep3rJobFundableCredits, IKeep3rJobFundableLiquidity {\\n  // Events\\n\\n  /// @notice Emitted when Keep3rJobDisputable#slashTokenFromJob is called\\n  /// @param _job The address of the job from which the token will be slashed\\n  /// @param _token The address of the token being slashed\\n  /// @param _slasher The user that slashes the token\\n  /// @param _amount The amount of the token being slashed\\n  event JobSlashToken(address indexed _job, address _token, address indexed _slasher, uint256 _amount);\\n\\n  /// @notice Emitted when Keep3rJobDisputable#slashLiquidityFromJob is called\\n  /// @param _job The address of the job from which the liquidity will be slashed\\n  /// @param _liquidity The address of the liquidity being slashed\\n  /// @param _slasher The user that slashes the liquidity\\n  /// @param _amount The amount of the liquidity being slashed\\n  event JobSlashLiquidity(address indexed _job, address _liquidity, address indexed _slasher, uint256 _amount);\\n\\n  // Errors\\n\\n  /// @notice Throws when the token trying to be slashed doesn't exist\\n  error JobTokenUnexistent();\\n\\n  /// @notice Throws when someone tries to slash more tokens than the job has\\n  error JobTokenInsufficient();\\n\\n  // Methods\\n\\n  /// @notice Allows governance or slasher to slash a job specific token\\n  /// @param _job The address of the job from which the token will be slashed\\n  /// @param _token The address of the token that will be slashed\\n  /// @param _amount The amount of the token that will be slashed\\n  function slashTokenFromJob(\\n    address _job,\\n    address _token,\\n    uint256 _amount\\n  ) external;\\n\\n  /// @notice Allows governance or a slasher to slash liquidity from a job\\n  /// @param _job The address being slashed\\n  /// @param _liquidity The address of the liquidity that will be slashed\\n  /// @param _amount The amount of liquidity that will be slashed\\n  function slashLiquidityFromJob(\\n    address _job,\\n    address _liquidity,\\n    uint256 _amount\\n  ) external;\\n}\\n\\n// solhint-disable-next-line no-empty-blocks\\ninterface IKeep3rJobs is IKeep3rJobOwnership, IKeep3rJobDisputable, IKeep3rJobMigration, IKeep3rJobManager, IKeep3rJobWorkable {\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/peripherals/IKeep3rAccountance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\n/// @title Keep3rDisputable contract\\n/// @notice Disputes keepers, or if they're already disputed, it can resolve the case\\n/// @dev Argument `bonding` can be the address of either a token or a liquidity\\ninterface IKeep3rAccountance {\\n  // Events\\n\\n  /// @notice Emitted when the bonding process of a new keeper begins\\n  /// @param _keeper The caller of Keep3rKeeperFundable#bond function\\n  /// @param _bonding The asset the keeper has bonded\\n  /// @param _amount The amount the keeper has bonded\\n  event Bonding(address indexed _keeper, address indexed _bonding, uint256 _amount);\\n\\n  /// @notice Emitted when a keeper or job begins the unbonding process to withdraw the funds\\n  /// @param _keeperOrJob The keeper or job that began the unbonding process\\n  /// @param _unbonding The liquidity pair or asset being unbonded\\n  /// @param _amount The amount being unbonded\\n  event Unbonding(address indexed _keeperOrJob, address indexed _unbonding, uint256 _amount);\\n\\n  // Variables\\n\\n  /// @notice Tracks the total KP3R earnings of a keeper since it started working\\n  /// @return _workCompleted Total KP3R earnings of a keeper since it started working\\n  function workCompleted(address _keeper) external view returns (uint256 _workCompleted);\\n\\n  /// @notice Tracks when a keeper was first registered\\n  /// @return timestamp The time at which the keeper was first registered\\n  function firstSeen(address _keeper) external view returns (uint256 timestamp);\\n\\n  /// @notice Tracks if a keeper or job has a pending dispute\\n  /// @return _disputed Whether a keeper or job has a pending dispute\\n  function disputes(address _keeperOrJob) external view returns (bool _disputed);\\n\\n  /// @notice Tracks how much a keeper has bonded of a certain token\\n  /// @return _bonds Amount of a certain token that a keeper has bonded\\n  function bonds(address _keeper, address _bond) external view returns (uint256 _bonds);\\n\\n  /// @notice The current token credits available for a job\\n  /// @return _amount The amount of token credits available for a job\\n  function jobTokenCredits(address _job, address _token) external view returns (uint256 _amount);\\n\\n  /// @notice Tracks the amount of assets deposited in pending bonds\\n  /// @return _pendingBonds Amount of a certain asset a keeper has unbonding\\n  function pendingBonds(address _keeper, address _bonding) external view returns (uint256 _pendingBonds);\\n\\n  /// @notice Tracks when a bonding for a keeper can be activated\\n  /// @return _timestamp Time at which the bonding for a keeper can be activated\\n  function canActivateAfter(address _keeper, address _bonding) external view returns (uint256 _timestamp);\\n\\n  /// @notice Tracks when keeper bonds are ready to be withdrawn\\n  /// @return _timestamp Time at which the keeper bonds are ready to be withdrawn\\n  function canWithdrawAfter(address _keeper, address _bonding) external view returns (uint256 _timestamp);\\n\\n  /// @notice Tracks how much keeper bonds are to be withdrawn\\n  /// @return _pendingUnbonds The amount of keeper bonds that are to be withdrawn\\n  function pendingUnbonds(address _keeper, address _bonding) external view returns (uint256 _pendingUnbonds);\\n\\n  /// @notice Checks whether the address has ever bonded an asset\\n  /// @return _hasBonded Whether the address has ever bonded an asset\\n  function hasBonded(address _keeper) external view returns (bool _hasBonded);\\n\\n  // Methods\\n  /// @notice Lists all jobs\\n  /// @return _jobList Array with all the jobs in _jobs\\n  function jobs() external view returns (address[] memory _jobList);\\n\\n  /// @notice Lists all keepers\\n  /// @return _keeperList Array with all the jobs in keepers\\n  function keepers() external view returns (address[] memory _keeperList);\\n\\n  // Errors\\n\\n  /// @notice Throws when an address is passed as a job, but that address is not a job\\n  error JobUnavailable();\\n\\n  /// @notice Throws when an action that requires an undisputed job is applied on a disputed job\\n  error JobDisputed();\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/IKeep3rHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/// @title Keep3rHelper contract\\n/// @notice Contains all the helper functions used throughout the different files.\\ninterface IKeep3rHelper {\\n  // Errors\\n\\n  /// @notice Throws when none of the tokens in the liquidity pair is KP3R\\n  error LiquidityPairInvalid();\\n\\n  // Variables\\n\\n  /// @notice Address of KP3R token\\n  /// @return _kp3r Address of KP3R token\\n  // solhint-disable func-name-mixedcase\\n  function KP3R() external view returns (address _kp3r);\\n\\n  /// @notice Address of KP3R-WETH pool to use as oracle\\n  /// @return _kp3rWeth Address of KP3R-WETH pool to use as oracle\\n  function KP3R_WETH_POOL() external view returns (address _kp3rWeth);\\n\\n  /// @notice The minimum multiplier used to calculate the amount of gas paid to the Keeper for the gas used to perform a job\\n  ///         For example: if the quoted gas used is 1000, then the minimum amount to be paid will be 1000 * MIN / BOOST_BASE\\n  /// @return _multiplier The MIN multiplier\\n  function MIN() external view returns (uint256 _multiplier);\\n\\n  /// @notice The maximum multiplier used to calculate the amount of gas paid to the Keeper for the gas used to perform a job\\n  ///         For example: if the quoted gas used is 1000, then the maximum amount to be paid will be 1000 * MAX / BOOST_BASE\\n  /// @return _multiplier The MAX multiplier\\n  function MAX() external view returns (uint256 _multiplier);\\n\\n  /// @notice The boost base used to calculate the boost rewards for the keeper\\n  /// @return _base The boost base number\\n  function BOOST_BASE() external view returns (uint256 _base);\\n\\n  /// @notice The targeted amount of bonded KP3Rs to max-up reward multiplier\\n  ///         For example: if the amount of KP3R the keeper has bonded is TARGETBOND or more, then the keeper will get\\n  ///                      the maximum boost possible in his rewards, if it's less, the reward boost will be proportional\\n  /// @return _target The amount of KP3R that comforms the TARGETBOND\\n  function TARGETBOND() external view returns (uint256 _target);\\n\\n  // Methods\\n  // solhint-enable func-name-mixedcase\\n\\n  /// @notice Calculates the amount of KP3R that corresponds to the ETH passed into the function\\n  /// @dev This function allows us to calculate how much KP3R we should pay to a keeper for things expressed in ETH, like gas\\n  /// @param _eth The amount of ETH\\n  /// @return _amountOut The amount of KP3R\\n  function quote(uint256 _eth) external view returns (uint256 _amountOut);\\n\\n  /// @notice Returns the amount of KP3R the keeper has bonded\\n  /// @param _keeper The address of the keeper to check\\n  /// @return _amountBonded The amount of KP3R the keeper has bonded\\n  function bonds(address _keeper) external view returns (uint256 _amountBonded);\\n\\n  /// @notice Calculates the reward (in KP3R) that corresponds to a keeper for using gas\\n  /// @param _keeper The address of the keeper to check\\n  /// @param _gasUsed The amount of gas used that will be rewarded\\n  /// @return _kp3r The amount of KP3R that should be awarded to the keeper\\n  function getRewardAmountFor(address _keeper, uint256 _gasUsed) external view returns (uint256 _kp3r);\\n\\n  /// @notice Calculates the boost in the reward given to a keeper based on the amount of KP3R that keeper has bonded\\n  /// @param _bonds The amount of KP3R tokens bonded by the keeper\\n  /// @return _rewardBoost The reward boost that corresponds to the keeper\\n  function getRewardBoostFor(uint256 _bonds) external view returns (uint256 _rewardBoost);\\n\\n  /// @notice Calculates the reward (in KP3R) that corresponds to tx.origin for using gas\\n  /// @param _gasUsed The amount of gas used that will be rewarded\\n  /// @return _amount The amount of KP3R that should be awarded to tx.origin\\n  function getRewardAmount(uint256 _gasUsed) external view returns (uint256 _amount);\\n\\n  /// @notice Given a pool address, returns the underlying tokens of the pair\\n  /// @param _pool Address of the correspondant pool\\n  /// @return _token0 Address of the first token of the pair\\n  /// @return _token1 Address of the second token of the pair\\n  function getPoolTokens(address _pool) external view returns (address _token0, address _token1);\\n\\n  /// @notice Defines the order of the tokens in the pair for twap calculations\\n  /// @param _pool Address of the correspondant pool\\n  /// @return _isKP3RToken0 Boolean indicating the order of the tokens in the pair\\n  function isKP3RToken0(address _pool) external view returns (bool _isKP3RToken0);\\n\\n  /// @notice Given an array of secondsAgo, returns UniswapV3 pool cumulatives at that moment\\n  /// @param _pool Address of the pool to observe\\n  /// @param _secondsAgo Array with time references to observe\\n  /// @return _tickCumulative1 Cummulative sum of ticks until first time reference\\n  /// @return _tickCumulative2 Cummulative sum of ticks until second time reference\\n  /// @return _success Boolean indicating if the observe call was succesfull\\n  function observe(address _pool, uint32[] memory _secondsAgo)\\n    external\\n    view\\n    returns (\\n      int56 _tickCumulative1,\\n      int56 _tickCumulative2,\\n      bool _success\\n    );\\n\\n  /// @notice Given a tick and a liquidity amount, calculates the underlying KP3R tokens\\n  /// @param _liquidityAmount Amount of liquidity to be converted\\n  /// @param _tickDifference Tick value used to calculate the quote\\n  /// @param _timeInterval Time value used to calculate the quote\\n  /// @return _kp3rAmount Amount of KP3R tokens underlying on the given liquidity\\n  function getKP3RsAtTick(\\n    uint256 _liquidityAmount,\\n    int56 _tickDifference,\\n    uint256 _timeInterval\\n  ) external pure returns (uint256 _kp3rAmount);\\n\\n  /// @notice Given a tick and a token amount, calculates the output in correspondant token\\n  /// @param _baseAmount Amount of token to be converted\\n  /// @param _tickDifference Tick value used to calculate the quote\\n  /// @param _timeInterval Time value used to calculate the quote\\n  /// @return _quoteAmount Amount of credits deserved for the baseAmount at the tick value\\n  function getQuoteAtTick(\\n    uint128 _baseAmount,\\n    int56 _tickDifference,\\n    uint256 _timeInterval\\n  ) external pure returns (uint256 _quoteAmount);\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/peripherals/IKeep3rParameters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport './IBaseErrors.sol';\\n\\n/// @title Keep3rParameters contract\\n/// @notice Handles and sets all the required parameters for Keep3r\\n\\ninterface IKeep3rParameters is IBaseErrors {\\n  // Events\\n\\n  /// @notice Emitted when the Keep3rHelper address is changed\\n  /// @param _keep3rHelper The address of Keep3rHelper's contract\\n  event Keep3rHelperChange(address _keep3rHelper);\\n\\n  /// @notice Emitted when the Keep3rV1 address is changed\\n  /// @param _keep3rV1 The address of Keep3rV1's contract\\n  event Keep3rV1Change(address _keep3rV1);\\n\\n  /// @notice Emitted when the Keep3rV1Proxy address is changed\\n  /// @param _keep3rV1Proxy The address of Keep3rV1Proxy's contract\\n  event Keep3rV1ProxyChange(address _keep3rV1Proxy);\\n\\n  /// @notice Emitted when the KP3R-WETH pool address is changed\\n  /// @param _kp3rWethPool The address of the KP3R-WETH pool\\n  event Kp3rWethPoolChange(address _kp3rWethPool);\\n\\n  /// @notice Emitted when bondTime is changed\\n  /// @param _bondTime The new bondTime\\n  event BondTimeChange(uint256 _bondTime);\\n\\n  /// @notice Emitted when _liquidityMinimum is changed\\n  /// @param _liquidityMinimum The new _liquidityMinimum\\n  event LiquidityMinimumChange(uint256 _liquidityMinimum);\\n\\n  /// @notice Emitted when _unbondTime is changed\\n  /// @param _unbondTime The new _unbondTime\\n  event UnbondTimeChange(uint256 _unbondTime);\\n\\n  /// @notice Emitted when _rewardPeriodTime is changed\\n  /// @param _rewardPeriodTime The new _rewardPeriodTime\\n  event RewardPeriodTimeChange(uint256 _rewardPeriodTime);\\n\\n  /// @notice Emitted when the inflationPeriod is changed\\n  /// @param _inflationPeriod The new inflationPeriod\\n  event InflationPeriodChange(uint256 _inflationPeriod);\\n\\n  /// @notice Emitted when the fee is changed\\n  /// @param _fee The new token credits fee\\n  event FeeChange(uint256 _fee);\\n\\n  // Variables\\n\\n  /// @notice Address of Keep3rHelper's contract\\n  /// @return _keep3rHelper The address of Keep3rHelper's contract\\n  function keep3rHelper() external view returns (address _keep3rHelper);\\n\\n  /// @notice Address of Keep3rV1's contract\\n  /// @return _keep3rV1 The address of Keep3rV1's contract\\n  function keep3rV1() external view returns (address _keep3rV1);\\n\\n  /// @notice Address of Keep3rV1Proxy's contract\\n  /// @return _keep3rV1Proxy The address of Keep3rV1Proxy's contract\\n  function keep3rV1Proxy() external view returns (address _keep3rV1Proxy);\\n\\n  /// @notice Address of the KP3R-WETH pool\\n  /// @return _kp3rWethPool The address of KP3R-WETH pool\\n  function kp3rWethPool() external view returns (address _kp3rWethPool);\\n\\n  /// @notice The amount of time required to pass after a keeper has bonded assets for it to be able to activate\\n  /// @return _days The required bondTime in days\\n  function bondTime() external view returns (uint256 _days);\\n\\n  /// @notice The amount of time required to pass before a keeper can unbond what he has bonded\\n  /// @return _days The required unbondTime in days\\n  function unbondTime() external view returns (uint256 _days);\\n\\n  /// @notice The minimum amount of liquidity required to fund a job per liquidity\\n  /// @return _amount The minimum amount of liquidity in KP3R\\n  function liquidityMinimum() external view returns (uint256 _amount);\\n\\n  /// @notice The amount of time between each scheduled credits reward given to a job\\n  /// @return _days The reward period in days\\n  function rewardPeriodTime() external view returns (uint256 _days);\\n\\n  /// @notice The inflation period is the denominator used to regulate the emission of KP3R\\n  /// @return _period The denominator used to regulate the emission of KP3R\\n  function inflationPeriod() external view returns (uint256 _period);\\n\\n  /// @notice The fee to be sent to governance when a user adds liquidity to a job\\n  /// @return _amount The fee amount to be sent to governance when a user adds liquidity to a job\\n  function fee() external view returns (uint256 _amount);\\n\\n  // solhint-disable func-name-mixedcase\\n  /// @notice The base that will be used to calculate the fee\\n  /// @return _base The base that will be used to calculate the fee\\n  function BASE() external view returns (uint256 _base);\\n\\n  /// @notice The minimum rewardPeriodTime value to be set\\n  /// @return _minPeriod The minimum reward period in seconds\\n  function MIN_REWARD_PERIOD_TIME() external view returns (uint256 _minPeriod);\\n\\n  // solhint-enable func-name-mixedcase\\n\\n  // Errors\\n\\n  /// @notice Throws if the reward period is less than the minimum reward period time\\n  error MinRewardPeriod();\\n\\n  /// @notice Throws if either a job or a keeper is disputed\\n  error Disputed();\\n\\n  /// @notice Throws if there are no bonded assets\\n  error BondsUnexistent();\\n\\n  /// @notice Throws if the time required to bond an asset has not passed yet\\n  error BondsLocked();\\n\\n  /// @notice Throws if there are no bonds to withdraw\\n  error UnbondsUnexistent();\\n\\n  /// @notice Throws if the time required to withdraw the bonds has not passed yet\\n  error UnbondsLocked();\\n\\n  // Methods\\n\\n  /// @notice Sets the Keep3rHelper address\\n  /// @param _keep3rHelper The Keep3rHelper address\\n  function setKeep3rHelper(address _keep3rHelper) external;\\n\\n  /// @notice Sets the Keep3rV1 address\\n  /// @param _keep3rV1 The Keep3rV1 address\\n  function setKeep3rV1(address _keep3rV1) external;\\n\\n  /// @notice Sets the Keep3rV1Proxy address\\n  /// @param _keep3rV1Proxy The Keep3rV1Proxy address\\n  function setKeep3rV1Proxy(address _keep3rV1Proxy) external;\\n\\n  /// @notice Sets the KP3R-WETH pool address\\n  /// @param _kp3rWethPool The KP3R-WETH pool address\\n  function setKp3rWethPool(address _kp3rWethPool) external;\\n\\n  /// @notice Sets the bond time required to activate as a keeper\\n  /// @param _bond The new bond time\\n  function setBondTime(uint256 _bond) external;\\n\\n  /// @notice Sets the unbond time required unbond what has been bonded\\n  /// @param _unbond The new unbond time\\n  function setUnbondTime(uint256 _unbond) external;\\n\\n  /// @notice Sets the minimum amount of liquidity required to fund a job\\n  /// @param _liquidityMinimum The new minimum amount of liquidity\\n  function setLiquidityMinimum(uint256 _liquidityMinimum) external;\\n\\n  /// @notice Sets the time required to pass between rewards for jobs\\n  /// @param _rewardPeriodTime The new amount of time required to pass between rewards\\n  function setRewardPeriodTime(uint256 _rewardPeriodTime) external;\\n\\n  /// @notice Sets the new inflation period\\n  /// @param _inflationPeriod The new inflation period\\n  function setInflationPeriod(uint256 _inflationPeriod) external;\\n\\n  /// @notice Sets the new fee\\n  /// @param _fee The new fee\\n  function setFee(uint256 _fee) external;\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/peripherals/IBaseErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\ninterface IBaseErrors {\\n  /// @notice Throws if a variable is assigned to the zero address\\n  error ZeroAddress();\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/peripherals/IKeep3rRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\n/// @title Keep3rRoles contract\\n/// @notice Manages the Keep3r specific roles\\ninterface IKeep3rRoles {\\n  // Events\\n\\n  /// @notice Emitted when a slasher is added\\n  /// @param _slasher Address of the added slasher\\n  event SlasherAdded(address _slasher);\\n\\n  /// @notice Emitted when a slasher is removed\\n  /// @param _slasher Address of the removed slasher\\n  event SlasherRemoved(address _slasher);\\n\\n  /// @notice Emitted when a disputer is added\\n  /// @param _disputer Address of the added disputer\\n  event DisputerAdded(address _disputer);\\n\\n  /// @notice Emitted when a disputer is removed\\n  /// @param _disputer Address of the removed disputer\\n  event DisputerRemoved(address _disputer);\\n\\n  // Variables\\n\\n  /// @notice Maps an address to a boolean to determine whether the address is a slasher or not.\\n  /// @return _isSlasher Whether the address is a slasher or not\\n  function slashers(address _slasher) external view returns (bool _isSlasher);\\n\\n  /// @notice Maps an address to a boolean to determine whether the address is a disputer or not.\\n  /// @return _isDisputer Whether the address is a disputer or not\\n  function disputers(address _disputer) external view returns (bool _isDisputer);\\n\\n  // Errors\\n\\n  /// @notice Throws if the address is already a registered slasher\\n  error SlasherExistent();\\n\\n  /// @notice Throws if caller is not a registered slasher\\n  error SlasherUnexistent();\\n\\n  /// @notice Throws if the address is already a registered disputer\\n  error DisputerExistent();\\n\\n  /// @notice Throws if caller is not a registered disputer\\n  error DisputerUnexistent();\\n\\n  /// @notice Throws if the msg.sender is not a slasher or is not a part of governance\\n  error OnlySlasher();\\n\\n  /// @notice Throws if the msg.sender is not a disputer or is not a part of governance\\n  error OnlyDisputer();\\n\\n  // Methods\\n\\n  /// @notice Registers a slasher by updating the slashers mapping\\n  function addSlasher(address _slasher) external;\\n\\n  /// @notice Removes a slasher by updating the slashers mapping\\n  function removeSlasher(address _slasher) external;\\n\\n  /// @notice Registers a disputer by updating the disputers mapping\\n  function addDisputer(address _disputer) external;\\n\\n  /// @notice Removes a disputer by updating the disputers mapping\\n  function removeDisputer(address _disputer) external;\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport '../../interfaces/peripherals/IGovernable.sol';\\n\\nabstract contract Governable is IGovernable {\\n  /// @inheritdoc IGovernable\\n  address public override governance;\\n\\n  /// @inheritdoc IGovernable\\n  address public override pendingGovernance;\\n\\n  constructor(address _governance) {\\n    if (_governance == address(0)) revert NoGovernanceZeroAddress();\\n    governance = _governance;\\n  }\\n\\n  /// @inheritdoc IGovernable\\n  function setGovernance(address _governance) external override onlyGovernance {\\n    pendingGovernance = _governance;\\n    emit GovernanceProposal(_governance);\\n  }\\n\\n  /// @inheritdoc IGovernable\\n  function acceptGovernance() external override onlyPendingGovernance {\\n    governance = pendingGovernance;\\n    delete pendingGovernance;\\n    emit GovernanceSet(governance);\\n  }\\n\\n  /// @notice Functions with this modifier can only be called by governance\\n  modifier onlyGovernance {\\n    if (msg.sender != governance) revert OnlyGovernance();\\n    _;\\n  }\\n\\n  /// @notice Functions with this modifier can only be called by pendingGovernance\\n  modifier onlyPendingGovernance {\\n    if (msg.sender != pendingGovernance) revert OnlyPendingGovernance();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/peripherals/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\n/// @title Governable contract\\n/// @notice Manages the governance role\\ninterface IGovernable {\\n  // Events\\n\\n  /// @notice Emitted when pendingGovernance accepts to be governance\\n  /// @param _governance Address of the new governance\\n  event GovernanceSet(address _governance);\\n\\n  /// @notice Emitted when a new governance is proposed\\n  /// @param _pendingGovernance Address that is proposed to be the new governance\\n  event GovernanceProposal(address _pendingGovernance);\\n\\n  // Errors\\n\\n  /// @notice Throws if the caller of the function is not governance\\n  error OnlyGovernance();\\n\\n  /// @notice Throws if the caller of the function is not pendingGovernance\\n  error OnlyPendingGovernance();\\n\\n  /// @notice Throws if trying to set governance to zero address\\n  error NoGovernanceZeroAddress();\\n\\n  // Variables\\n\\n  /// @notice Stores the governance address\\n  /// @return _governance The governance addresss\\n  function governance() external view returns (address _governance);\\n\\n  /// @notice Stores the pendingGovernance address\\n  /// @return _pendingGovernance The pendingGovernance addresss\\n  function pendingGovernance() external view returns (address _pendingGovernance);\\n\\n  // Methods\\n\\n  /// @notice Proposes a new address to be governance\\n  /// @param _governance The address of the user proposed to be the new governance\\n  function setGovernance(address _governance) external;\\n\\n  /// @notice Changes the governance from the current governance to the previously proposed address\\n  function acceptGovernance() external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/IPairManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\\n\\n/// @title  Pair Manager interface\\n/// @notice Generic interface for Keep3r liquidity pools (kLP)\\ninterface IPairManager is IERC20Metadata {\\n  /// @notice Address of the pool from which the Keep3r pair manager will interact with\\n  /// @return _pool The pool's address\\n  function pool() external view returns (address _pool);\\n\\n  /// @notice Token0 of the pool\\n  /// @return _token0 The address of token0\\n  function token0() external view returns (address _token0);\\n\\n  /// @notice Token1 of the pool\\n  /// @return _token1 The address of token1\\n  function token1() external view returns (address _token1);\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n  /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n  /// @param a The multiplicand\\n  /// @param b The multiplier\\n  /// @param denominator The divisor\\n  /// @return result The 256-bit result\\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n  function mulDiv(\\n    uint256 a,\\n    uint256 b,\\n    uint256 denominator\\n  ) internal pure returns (uint256 result) {\\n    unchecked {\\n      // 512-bit multiply [prod1 prod0] = a * b\\n      // Compute the product mod 2**256 and mod 2**256 - 1\\n      // then use the Chinese Remainder Theorem to reconstruct\\n      // the 512 bit result. The result is stored in two 256\\n      // variables such that product = prod1 * 2**256 + prod0\\n      uint256 prod0; // Least significant 256 bits of the product\\n      uint256 prod1; // Most significant 256 bits of the product\\n      assembly {\\n        let mm := mulmod(a, b, not(0))\\n        prod0 := mul(a, b)\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n      }\\n\\n      // Handle non-overflow cases, 256 by 256 division\\n      if (prod1 == 0) {\\n        require(denominator > 0);\\n        assembly {\\n          result := div(prod0, denominator)\\n        }\\n        return result;\\n      }\\n\\n      // Make sure the result is less than 2**256.\\n      // Also prevents denominator == 0\\n      require(denominator > prod1);\\n\\n      ///////////////////////////////////////////////\\n      // 512 by 256 division.\\n      ///////////////////////////////////////////////\\n\\n      // Make division exact by subtracting the remainder from [prod1 prod0]\\n      // Compute remainder using mulmod\\n      uint256 remainder;\\n      assembly {\\n        remainder := mulmod(a, b, denominator)\\n      }\\n      // Subtract 256 bit number from 512 bit number\\n      assembly {\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n      }\\n\\n      // Factor powers of two out of denominator\\n      // Compute largest power of two divisor of denominator.\\n      // Always >= 1.\\n      uint256 twos = (~denominator + 1) & denominator;\\n      // Divide denominator by power of two\\n      assembly {\\n        denominator := div(denominator, twos)\\n      }\\n\\n      // Divide [prod1 prod0] by the factors of two\\n      assembly {\\n        prod0 := div(prod0, twos)\\n      }\\n      // Shift in bits from prod1 into prod0. For this we need\\n      // to flip `twos` such that it is 2**256 / twos.\\n      // If twos is zero, then it becomes one\\n      assembly {\\n        twos := add(div(sub(0, twos), twos), 1)\\n      }\\n      prod0 |= prod1 * twos;\\n\\n      // Invert denominator mod 2**256\\n      // Now that denominator is an odd number, it has an inverse\\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n      // Compute the inverse by starting with a seed that is correct\\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n      uint256 inv = (3 * denominator) ^ 2;\\n      // Now use Newton-Raphson iteration to improve the precision.\\n      // Thanks to Hensel's lifting lemma, this also works in modular\\n      // arithmetic, doubling the correct bits in each step.\\n      inv *= 2 - denominator * inv; // inverse mod 2**8\\n      inv *= 2 - denominator * inv; // inverse mod 2**16\\n      inv *= 2 - denominator * inv; // inverse mod 2**32\\n      inv *= 2 - denominator * inv; // inverse mod 2**64\\n      inv *= 2 - denominator * inv; // inverse mod 2**128\\n      inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n      // Because the division is now exact we can divide by multiplying\\n      // with the modular inverse of denominator. This will give us the\\n      // correct result modulo 2**256. Since the precoditions guarantee\\n      // that the outcome is less than 2**256, this is the final result.\\n      // We don't need to compute the high bits of the result and prod1\\n      // is no longer required.\\n      result = prod0 * inv;\\n      return result;\\n    }\\n  }\\n\\n  /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n  /// @param a The multiplicand\\n  /// @param b The multiplier\\n  /// @param denominator The divisor\\n  /// @return result The 256-bit result\\n  function mulDivRoundingUp(\\n    uint256 a,\\n    uint256 b,\\n    uint256 denominator\\n  ) internal pure returns (uint256 result) {\\n    unchecked {\\n      result = mulDiv(a, b, denominator);\\n      if (mulmod(a, b, denominator) > 0) {\\n        require(result < type(uint256).max);\\n        result++;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/peripherals/IKeep3rDisputable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\n/// @title Keep3rDisputable contract\\n/// @notice Creates/resolves disputes for jobs or keepers\\n///         A disputed keeper is slashable and is not able to bond, activate, withdraw or receive direct payments\\n///         A disputed job is slashable and is not able to pay the keepers, withdraw tokens or to migrate\\ninterface IKeep3rDisputable {\\n  /// @notice Emitted when a keeper or a job is disputed\\n  /// @param _jobOrKeeper The address of the disputed keeper/job\\n  /// @param _disputer The user that called the function and disputed the keeper\\n  event Dispute(address indexed _jobOrKeeper, address indexed _disputer);\\n\\n  /// @notice Emitted when a dispute is resolved\\n  /// @param _jobOrKeeper The address of the disputed keeper/job\\n  /// @param _resolver The user that called the function and resolved the dispute\\n  event Resolve(address indexed _jobOrKeeper, address indexed _resolver);\\n\\n  /// @notice Throws when a job or keeper is already disputed\\n  error AlreadyDisputed();\\n\\n  /// @notice Throws when a job or keeper is not disputed and someone tries to resolve the dispute\\n  error NotDisputed();\\n\\n  /// @notice Allows governance to create a dispute for a given keeper/job\\n  /// @param _jobOrKeeper The address in dispute\\n  function dispute(address _jobOrKeeper) external;\\n\\n  /// @notice Allows governance to resolve a dispute on a keeper/job\\n  /// @param _jobOrKeeper The address cleared\\n  function resolve(address _jobOrKeeper) external;\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/jobs/Keep3rJobMigration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport '../../../interfaces/peripherals/IKeep3rJobs.sol';\\nimport './Keep3rJobFundableCredits.sol';\\nimport './Keep3rJobFundableLiquidity.sol';\\n\\nabstract contract Keep3rJobMigration is IKeep3rJobMigration, Keep3rJobFundableCredits, Keep3rJobFundableLiquidity {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  uint256 internal constant _MIGRATION_COOLDOWN = 1 minutes;\\n\\n  /// @inheritdoc IKeep3rJobMigration\\n  mapping(address => address) public override pendingJobMigrations;\\n  mapping(address => mapping(address => uint256)) internal _migrationCreatedAt;\\n\\n  /// @inheritdoc IKeep3rJobMigration\\n  function migrateJob(address _fromJob, address _toJob) external override onlyJobOwner(_fromJob) {\\n    if (_fromJob == _toJob) revert JobMigrationImpossible();\\n\\n    pendingJobMigrations[_fromJob] = _toJob;\\n    _migrationCreatedAt[_fromJob][_toJob] = block.timestamp;\\n\\n    emit JobMigrationRequested(_fromJob, _toJob);\\n  }\\n\\n  /// @inheritdoc IKeep3rJobMigration\\n  function acceptJobMigration(address _fromJob, address _toJob) external override onlyJobOwner(_toJob) {\\n    if (disputes[_fromJob] || disputes[_toJob]) revert JobDisputed();\\n    if (pendingJobMigrations[_fromJob] != _toJob) revert JobMigrationUnavailable();\\n    if (block.timestamp < _migrationCreatedAt[_fromJob][_toJob] + _MIGRATION_COOLDOWN) revert JobMigrationLocked();\\n\\n    // force job credits update for both jobs\\n    _settleJobAccountance(_fromJob);\\n    _settleJobAccountance(_toJob);\\n\\n    // migrate tokens\\n    while (_jobTokens[_fromJob].length() > 0) {\\n      address _tokenToMigrate = _jobTokens[_fromJob].at(0);\\n      jobTokenCredits[_toJob][_tokenToMigrate] += jobTokenCredits[_fromJob][_tokenToMigrate];\\n      jobTokenCredits[_fromJob][_tokenToMigrate] = 0;\\n      _jobTokens[_fromJob].remove(_tokenToMigrate);\\n      _jobTokens[_toJob].add(_tokenToMigrate);\\n    }\\n\\n    // migrate liquidities\\n    while (_jobLiquidities[_fromJob].length() > 0) {\\n      address _liquidity = _jobLiquidities[_fromJob].at(0);\\n\\n      liquidityAmount[_toJob][_liquidity] += liquidityAmount[_fromJob][_liquidity];\\n      delete liquidityAmount[_fromJob][_liquidity];\\n\\n      _jobLiquidities[_toJob].add(_liquidity);\\n      _jobLiquidities[_fromJob].remove(_liquidity);\\n    }\\n\\n    // migrate job balances\\n    _jobPeriodCredits[_toJob] += _jobPeriodCredits[_fromJob];\\n    delete _jobPeriodCredits[_fromJob];\\n\\n    _jobLiquidityCredits[_toJob] += _jobLiquidityCredits[_fromJob];\\n    delete _jobLiquidityCredits[_fromJob];\\n\\n    // stop _fromJob from being a job\\n    delete rewardedAt[_fromJob];\\n    _jobs.remove(_fromJob);\\n\\n    // delete unused data slots\\n    delete jobOwner[_fromJob];\\n    delete jobPendingOwner[_fromJob];\\n    delete _migrationCreatedAt[_fromJob][_toJob];\\n    delete pendingJobMigrations[_fromJob];\\n\\n    emit JobMigrationSuccessful(_fromJob, _toJob);\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/keepers/Keep3rKeeperDisputable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport './Keep3rKeeperFundable.sol';\\nimport '../Keep3rDisputable.sol';\\nimport '../../../interfaces/external/IKeep3rV1.sol';\\nimport '../../../interfaces/peripherals/IKeep3rKeepers.sol';\\n\\nabstract contract Keep3rKeeperDisputable is IKeep3rKeeperDisputable, Keep3rDisputable, Keep3rKeeperFundable {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using SafeERC20 for IERC20;\\n\\n  /// @inheritdoc IKeep3rKeeperDisputable\\n  function slash(\\n    address _keeper,\\n    address _bonded,\\n    uint256 _amount\\n  ) public override onlySlasher {\\n    if (!disputes[_keeper]) revert NotDisputed();\\n    _slash(_keeper, _bonded, _amount);\\n    emit KeeperSlash(_keeper, msg.sender, _amount);\\n  }\\n\\n  /// @inheritdoc IKeep3rKeeperDisputable\\n  function revoke(address _keeper) external override onlySlasher {\\n    if (!disputes[_keeper]) revert NotDisputed();\\n    _keepers.remove(_keeper);\\n    _slash(_keeper, keep3rV1, bonds[_keeper][keep3rV1]);\\n    emit KeeperRevoke(_keeper, msg.sender);\\n  }\\n\\n  function _slash(\\n    address _keeper,\\n    address _bonded,\\n    uint256 _amount\\n  ) internal {\\n    if (_bonded != keep3rV1) {\\n      try IERC20(_bonded).transfer(governance, _amount) returns (bool) {} catch (bytes memory) {}\\n    }\\n    bonds[_keeper][_bonded] -= _amount;\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/contracts/peripherals/keepers/Keep3rKeeperFundable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport '../Keep3rAccountance.sol';\\nimport '../Keep3rParameters.sol';\\nimport '../../../interfaces/peripherals/IKeep3rKeepers.sol';\\n\\nimport '../../../interfaces/external/IKeep3rV1.sol';\\nimport '../../../interfaces/external/IKeep3rV1Proxy.sol';\\n\\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\n\\nabstract contract Keep3rKeeperFundable is IKeep3rKeeperFundable, ReentrancyGuard, Keep3rParameters {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using SafeERC20 for IERC20;\\n\\n  /// @inheritdoc IKeep3rKeeperFundable\\n  function bond(address _bonding, uint256 _amount) external override nonReentrant {\\n    if (disputes[msg.sender]) revert Disputed();\\n    if (_jobs.contains(msg.sender)) revert AlreadyAJob();\\n    canActivateAfter[msg.sender][_bonding] = block.timestamp + bondTime;\\n\\n    uint256 _before = IERC20(_bonding).balanceOf(address(this));\\n    IERC20(_bonding).safeTransferFrom(msg.sender, address(this), _amount);\\n    _amount = IERC20(_bonding).balanceOf(address(this)) - _before;\\n\\n    hasBonded[msg.sender] = true;\\n    pendingBonds[msg.sender][_bonding] += _amount;\\n\\n    emit Bonding(msg.sender, _bonding, _amount);\\n  }\\n\\n  /// @inheritdoc IKeep3rKeeperFundable\\n  function activate(address _bonding) external override {\\n    if (disputes[msg.sender]) revert Disputed();\\n    if (canActivateAfter[msg.sender][_bonding] == 0) revert BondsUnexistent();\\n    if (canActivateAfter[msg.sender][_bonding] >= block.timestamp) revert BondsLocked();\\n\\n    _activate(msg.sender, _bonding);\\n  }\\n\\n  /// @inheritdoc IKeep3rKeeperFundable\\n  function unbond(address _bonding, uint256 _amount) external override {\\n    canWithdrawAfter[msg.sender][_bonding] = block.timestamp + unbondTime;\\n    bonds[msg.sender][_bonding] -= _amount;\\n    pendingUnbonds[msg.sender][_bonding] += _amount;\\n\\n    emit Unbonding(msg.sender, _bonding, _amount);\\n  }\\n\\n  /// @inheritdoc IKeep3rKeeperFundable\\n  function withdraw(address _bonding) external override nonReentrant {\\n    if (canWithdrawAfter[msg.sender][_bonding] == 0) revert UnbondsUnexistent();\\n    if (canWithdrawAfter[msg.sender][_bonding] >= block.timestamp) revert UnbondsLocked();\\n    if (disputes[msg.sender]) revert Disputed();\\n\\n    uint256 _amount = pendingUnbonds[msg.sender][_bonding];\\n\\n    if (_bonding == keep3rV1) {\\n      IKeep3rV1Proxy(keep3rV1Proxy).mint(_amount);\\n    }\\n\\n    pendingUnbonds[msg.sender][_bonding] = 0;\\n    IERC20(_bonding).safeTransfer(msg.sender, _amount);\\n\\n    emit Withdrawal(msg.sender, _bonding, _amount);\\n  }\\n\\n  function _bond(\\n    address _bonding,\\n    address _from,\\n    uint256 _amount\\n  ) internal {\\n    bonds[_from][_bonding] += _amount;\\n    if (_bonding == keep3rV1) {\\n      IKeep3rV1(keep3rV1).burn(_amount);\\n    }\\n  }\\n\\n  function _activate(address _keeper, address _bonding) internal {\\n    if (firstSeen[_keeper] == 0) {\\n      firstSeen[_keeper] = block.timestamp;\\n    }\\n    _keepers.add(_keeper);\\n    uint256 _amount = pendingBonds[_keeper][_bonding];\\n    pendingBonds[_keeper][_bonding] = 0;\\n    _bond(_bonding, _keeper, _amount);\\n\\n    emit Activation(_keeper, _bonding, _amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/external/IKeep3rV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\\n\\n// solhint-disable func-name-mixedcase\\ninterface IKeep3rV1 is IERC20, IERC20Metadata {\\n  // Structs\\n  struct Checkpoint {\\n    uint32 fromBlock;\\n    uint256 votes;\\n  }\\n\\n  // Events\\n  event DelegateChanged(address indexed _delegator, address indexed _fromDelegate, address indexed _toDelegate);\\n  event DelegateVotesChanged(address indexed _delegate, uint256 _previousBalance, uint256 _newBalance);\\n  event SubmitJob(address indexed _job, address indexed _liquidity, address indexed _provider, uint256 _block, uint256 _credit);\\n  event ApplyCredit(address indexed _job, address indexed _liquidity, address indexed _provider, uint256 _block, uint256 _credit);\\n  event RemoveJob(address indexed _job, address indexed _liquidity, address indexed _provider, uint256 _block, uint256 _credit);\\n  event UnbondJob(address indexed _job, address indexed _liquidity, address indexed _provider, uint256 _block, uint256 _credit);\\n  event JobAdded(address indexed _job, uint256 _block, address _governance);\\n  event JobRemoved(address indexed _job, uint256 _block, address _governance);\\n  event KeeperWorked(address indexed _credit, address indexed _job, address indexed _keeper, uint256 _block, uint256 _amount);\\n  event KeeperBonding(address indexed _keeper, uint256 _block, uint256 _active, uint256 _bond);\\n  event KeeperBonded(address indexed _keeper, uint256 _block, uint256 _activated, uint256 _bond);\\n  event KeeperUnbonding(address indexed _keeper, uint256 _block, uint256 _deactive, uint256 _bond);\\n  event KeeperUnbound(address indexed _keeper, uint256 _block, uint256 _deactivated, uint256 _bond);\\n  event KeeperSlashed(address indexed _keeper, address indexed _slasher, uint256 _block, uint256 _slash);\\n  event KeeperDispute(address indexed _keeper, uint256 _block);\\n  event KeeperResolved(address indexed _keeper, uint256 _block);\\n  event TokenCreditAddition(address indexed _credit, address indexed _job, address indexed _creditor, uint256 _block, uint256 _amount);\\n\\n  // Variables\\n  function KPRH() external returns (address);\\n\\n  function delegates(address _delegator) external view returns (address);\\n\\n  function checkpoints(address _account, uint32 _checkpoint) external view returns (Checkpoint memory);\\n\\n  function numCheckpoints(address _account) external view returns (uint32);\\n\\n  function DOMAIN_TYPEHASH() external returns (bytes32);\\n\\n  function DOMAINSEPARATOR() external returns (bytes32);\\n\\n  function DELEGATION_TYPEHASH() external returns (bytes32);\\n\\n  function PERMIT_TYPEHASH() external returns (bytes32);\\n\\n  function nonces(address _user) external view returns (uint256);\\n\\n  function BOND() external returns (uint256);\\n\\n  function UNBOND() external returns (uint256);\\n\\n  function LIQUIDITYBOND() external returns (uint256);\\n\\n  function FEE() external returns (uint256);\\n\\n  function BASE() external returns (uint256);\\n\\n  function ETH() external returns (address);\\n\\n  function bondings(address _user, address _bonding) external view returns (uint256);\\n\\n  function canWithdrawAfter(address _user, address _bonding) external view returns (uint256);\\n\\n  function pendingUnbonds(address _keeper, address _bonding) external view returns (uint256);\\n\\n  function pendingbonds(address _keeper, address _bonding) external view returns (uint256);\\n\\n  function bonds(address _keeper, address _bonding) external view returns (uint256);\\n\\n  function votes(address _delegator) external view returns (uint256);\\n\\n  function firstSeen(address _keeper) external view returns (uint256);\\n\\n  function disputes(address _keeper) external view returns (bool);\\n\\n  function lastJob(address _keeper) external view returns (uint256);\\n\\n  function workCompleted(address _keeper) external view returns (uint256);\\n\\n  function jobs(address _job) external view returns (bool);\\n\\n  function credits(address _job, address _credit) external view returns (uint256);\\n\\n  function liquidityProvided(\\n    address _provider,\\n    address _liquidity,\\n    address _job\\n  ) external view returns (uint256);\\n\\n  function liquidityUnbonding(\\n    address _provider,\\n    address _liquidity,\\n    address _job\\n  ) external view returns (uint256);\\n\\n  function liquidityAmountsUnbonding(\\n    address _provider,\\n    address _liquidity,\\n    address _job\\n  ) external view returns (uint256);\\n\\n  function jobProposalDelay(address _job) external view returns (uint256);\\n\\n  function liquidityApplied(\\n    address _provider,\\n    address _liquidity,\\n    address _job\\n  ) external view returns (uint256);\\n\\n  function liquidityAmount(\\n    address _provider,\\n    address _liquidity,\\n    address _job\\n  ) external view returns (uint256);\\n\\n  function keepers(address _keeper) external view returns (bool);\\n\\n  function blacklist(address _keeper) external view returns (bool);\\n\\n  function keeperList(uint256 _index) external view returns (address);\\n\\n  function jobList(uint256 _index) external view returns (address);\\n\\n  function governance() external returns (address);\\n\\n  function pendingGovernance() external returns (address);\\n\\n  function liquidityAccepted(address _liquidity) external view returns (bool);\\n\\n  function liquidityPairs(uint256 _index) external view returns (address);\\n\\n  // Methods\\n  function getCurrentVotes(address _account) external view returns (uint256);\\n\\n  function addCreditETH(address _job) external payable;\\n\\n  function addCredit(\\n    address _credit,\\n    address _job,\\n    uint256 _amount\\n  ) external;\\n\\n  function addVotes(address _voter, uint256 _amount) external;\\n\\n  function removeVotes(address _voter, uint256 _amount) external;\\n\\n  function addKPRCredit(address _job, uint256 _amount) external;\\n\\n  function approveLiquidity(address _liquidity) external;\\n\\n  function revokeLiquidity(address _liquidity) external;\\n\\n  function pairs() external view returns (address[] memory);\\n\\n  function addLiquidityToJob(\\n    address _liquidity,\\n    address _job,\\n    uint256 _amount\\n  ) external;\\n\\n  function applyCreditToJob(\\n    address _provider,\\n    address _liquidity,\\n    address _job\\n  ) external;\\n\\n  function unbondLiquidityFromJob(\\n    address _liquidity,\\n    address _job,\\n    uint256 _amount\\n  ) external;\\n\\n  function removeLiquidityFromJob(address _liquidity, address _job) external;\\n\\n  function mint(uint256 _amount) external;\\n\\n  function burn(uint256 _amount) external;\\n\\n  function worked(address _keeper) external;\\n\\n  function receipt(\\n    address _credit,\\n    address _keeper,\\n    uint256 _amount\\n  ) external;\\n\\n  function receiptETH(address _keeper, uint256 _amount) external;\\n\\n  function addJob(address _job) external;\\n\\n  function getJobs() external view returns (address[] memory);\\n\\n  function removeJob(address _job) external;\\n\\n  function setKeep3rHelper(address _keep3rHelper) external;\\n\\n  function setGovernance(address _governance) external;\\n\\n  function acceptGovernance() external;\\n\\n  function isKeeper(address _keeper) external returns (bool);\\n\\n  function isMinKeeper(\\n    address _keeper,\\n    uint256 _minBond,\\n    uint256 _earned,\\n    uint256 _age\\n  ) external returns (bool);\\n\\n  function isBondedKeeper(\\n    address _keeper,\\n    address _bond,\\n    uint256 _minBond,\\n    uint256 _earned,\\n    uint256 _age\\n  ) external returns (bool);\\n\\n  function bond(address _bonding, uint256 _amount) external;\\n\\n  function getKeepers() external view returns (address[] memory);\\n\\n  function activate(address _bonding) external;\\n\\n  function unbond(address _bonding, uint256 _amount) external;\\n\\n  function slash(\\n    address _bonded,\\n    address _keeper,\\n    uint256 _amount\\n  ) external;\\n\\n  function withdraw(address _bonding) external;\\n\\n  function dispute(address _keeper) external;\\n\\n  function revoke(address _keeper) external;\\n\\n  function resolve(address _keeper) external;\\n\\n  function permit(\\n    address _owner,\\n    address _spender,\\n    uint256 _amount,\\n    uint256 _deadline,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/peripherals/IKeep3rKeepers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\n/// @title Keep3rKeeperFundable contract\\n/// @notice Handles the actions required to become a keeper\\ninterface IKeep3rKeeperFundable {\\n  // Events\\n\\n  /// @notice Emitted when Keep3rKeeperFundable#activate is called\\n  /// @param _keeper The keeper that has been activated\\n  /// @param _bond The asset the keeper has bonded\\n  /// @param _amount The amount of the asset the keeper has bonded\\n  event Activation(address indexed _keeper, address indexed _bond, uint256 _amount);\\n\\n  /// @notice Emitted when Keep3rKeeperFundable#withdraw is called\\n  /// @param _keeper The caller of Keep3rKeeperFundable#withdraw function\\n  /// @param _bond The asset to withdraw from the bonding pool\\n  /// @param _amount The amount of funds withdrawn\\n  event Withdrawal(address indexed _keeper, address indexed _bond, uint256 _amount);\\n\\n  // Errors\\n\\n  /// @notice Throws when the address that is trying to register as a job is already a job\\n  error AlreadyAJob();\\n\\n  // Methods\\n\\n  /// @notice Beginning of the bonding process\\n  /// @param _bonding The asset being bound\\n  /// @param _amount The amount of bonding asset being bound\\n  function bond(address _bonding, uint256 _amount) external;\\n\\n  /// @notice Beginning of the unbonding process\\n  /// @param _bonding The asset being unbound\\n  /// @param _amount Allows for partial unbonding\\n  function unbond(address _bonding, uint256 _amount) external;\\n\\n  /// @notice End of the bonding process after bonding time has passed\\n  /// @param _bonding The asset being activated as bond collateral\\n  function activate(address _bonding) external;\\n\\n  /// @notice Withdraw funds after unbonding has finished\\n  /// @param _bonding The asset to withdraw from the bonding pool\\n  function withdraw(address _bonding) external;\\n}\\n\\n/// @title Keep3rKeeperDisputable contract\\n/// @notice Handles the actions that can be taken on a disputed keeper\\ninterface IKeep3rKeeperDisputable {\\n  // Events\\n\\n  /// @notice Emitted when Keep3rKeeperDisputable#slash is called\\n  /// @param _keeper The slashed keeper\\n  /// @param _slasher The user that called Keep3rKeeperDisputable#slash\\n  /// @param _amount The amount of credits slashed from the keeper\\n  event KeeperSlash(address indexed _keeper, address indexed _slasher, uint256 _amount);\\n\\n  /// @notice Emitted when Keep3rKeeperDisputable#revoke is called\\n  /// @param _keeper The revoked keeper\\n  /// @param _slasher The user that called Keep3rKeeperDisputable#revoke\\n  event KeeperRevoke(address indexed _keeper, address indexed _slasher);\\n\\n  /// @notice Keeper revoked\\n\\n  // Methods\\n\\n  /// @notice Allows governance to slash a keeper based on a dispute\\n  /// @param _keeper The address being slashed\\n  /// @param _bonded The asset being slashed\\n  /// @param _amount The amount being slashed\\n  function slash(\\n    address _keeper,\\n    address _bonded,\\n    uint256 _amount\\n  ) external;\\n\\n  /// @notice Blacklists a keeper from participating in the network\\n  /// @param _keeper The address being slashed\\n  function revoke(address _keeper) external;\\n}\\n\\n// solhint-disable-next-line no-empty-blocks\\n\\n/// @title Keep3rKeepers contract\\ninterface IKeep3rKeepers is IKeep3rKeeperDisputable {\\n\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/external/IKeep3rV1Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport '../peripherals/IGovernable.sol';\\n\\ninterface IKeep3rV1Proxy is IGovernable {\\n  // Structs\\n  struct Recipient {\\n    address recipient;\\n    uint256 caps;\\n  }\\n\\n  // Variables\\n  function keep3rV1() external view returns (address);\\n\\n  function minter() external view returns (address);\\n\\n  function next(address) external view returns (uint256);\\n\\n  function caps(address) external view returns (uint256);\\n\\n  function recipients() external view returns (address[] memory);\\n\\n  function recipientsCaps() external view returns (Recipient[] memory);\\n\\n  // Errors\\n  error Cooldown();\\n  error NoDrawableAmount();\\n  error ZeroAddress();\\n  error OnlyMinter();\\n\\n  // Methods\\n  function addRecipient(address recipient, uint256 amount) external;\\n\\n  function removeRecipient(address recipient) external;\\n\\n  function draw() external returns (uint256 _amount);\\n\\n  function setKeep3rV1(address _keep3rV1) external;\\n\\n  function setMinter(address _minter) external;\\n\\n  function mint(uint256 _amount) external;\\n\\n  function mint(address _account, uint256 _amount) external;\\n\\n  function setKeep3rV1Governance(address _governance) external;\\n\\n  function acceptKeep3rV1Governance() external;\\n\\n  function dispute(address _keeper) external;\\n\\n  function slash(\\n    address _bonded,\\n    address _keeper,\\n    uint256 _amount\\n  ) external;\\n\\n  function revoke(address _keeper) external;\\n\\n  function resolve(address _keeper) external;\\n\\n  function addJob(address _job) external;\\n\\n  function removeJob(address _job) external;\\n\\n  function addKPRCredit(address _job, uint256 _amount) external;\\n\\n  function approveLiquidity(address _liquidity) external;\\n\\n  function revokeLiquidity(address _liquidity) external;\\n\\n  function setKeep3rHelper(address _keep3rHelper) external;\\n\\n  function addVotes(address _voter, uint256 _amount) external;\\n\\n  function removeVotes(address _voter, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"solidity/interfaces/peripherals/IDustCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport './IBaseErrors.sol';\\n\\ninterface IDustCollector is IBaseErrors {\\n  /// @notice Emitted when dust is sent\\n  /// @param _to The address which wil received the funds\\n  /// @param _token The token that will be transferred\\n  /// @param _amount The amount of the token that will be transferred\\n  event DustSent(address _token, uint256 _amount, address _to);\\n\\n  /// @notice Allows an authorized user to transfer the tokens or eth that may have been left in a contract\\n  /// @param _token The token that will be transferred\\n  /// @param _amount The amont of the token that will be transferred\\n  /// @param _to The address that will receive the idle funds\\n  function sendDust(\\n    address _token,\\n    uint256 _amount,\\n    address _to\\n  ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_keep3rHelper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_keep3rV1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_keep3rV1Proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_kp3rWethPool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyAJob\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyAKeeper\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyDisputed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BondsLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BondsUnexistent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Disputed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DisputerExistent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DisputerUnexistent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientFunds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientJobTokenCredits\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobDisputed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobLiquidityInsufficient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobLiquidityLessThanMin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobLiquidityUnexistent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobMigrationImpossible\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobMigrationLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobMigrationUnavailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobTokenCreditsLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobTokenInsufficient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobTokenUnexistent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobUnapproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"JobUnavailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidityPairApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidityPairUnapproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidityPairUnexistent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinRewardPeriod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoGovernanceZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotDisputed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyDisputer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyGovernance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyJobOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyPendingGovernance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyPendingJobOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlySlasher\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SlasherExistent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SlasherUnexistent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenUnallowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnbondsLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnbondsUnexistent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_bond\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Activation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_bondTime\",\"type\":\"uint256\"}],\"name\":\"BondTimeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_bonding\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Bonding\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_jobOrKeeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_disputer\",\"type\":\"address\"}],\"name\":\"Dispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_disputer\",\"type\":\"address\"}],\"name\":\"DisputerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_disputer\",\"type\":\"address\"}],\"name\":\"DisputerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"DustSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"FeeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_pendingGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"GovernanceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_inflationPeriod\",\"type\":\"uint256\"}],\"name\":\"InflationPeriodChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_jobOwner\",\"type\":\"address\"}],\"name\":\"JobAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_fromJob\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_toJob\",\"type\":\"address\"}],\"name\":\"JobMigrationRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_fromJob\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_toJob\",\"type\":\"address\"}],\"name\":\"JobMigrationSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"JobOwnershipAssent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pendingOwner\",\"type\":\"address\"}],\"name\":\"JobOwnershipChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_slasher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"JobSlashLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_slasher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"JobSlashToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_keep3rHelper\",\"type\":\"address\"}],\"name\":\"Keep3rHelperChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_keep3rV1\",\"type\":\"address\"}],\"name\":\"Keep3rV1Change\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_keep3rV1Proxy\",\"type\":\"address\"}],\"name\":\"Keep3rV1ProxyChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_slasher\",\"type\":\"address\"}],\"name\":\"KeeperRevoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_slasher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"KeeperSlash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gasLeft\",\"type\":\"uint256\"}],\"name\":\"KeeperValidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_credit\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gasLeft\",\"type\":\"uint256\"}],\"name\":\"KeeperWork\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_kp3rWethPool\",\"type\":\"address\"}],\"name\":\"Kp3rWethPoolChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"LiquidityAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"}],\"name\":\"LiquidityApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_rewardedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_currentCredits\",\"type\":\"uint256\"}],\"name\":\"LiquidityCreditsForced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_rewardedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_currentCredits\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_periodCredits\",\"type\":\"uint256\"}],\"name\":\"LiquidityCreditsReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_liquidityMinimum\",\"type\":\"uint256\"}],\"name\":\"LiquidityMinimumChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"}],\"name\":\"LiquidityRevocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"LiquidityWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_jobOrKeeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"Resolve\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_rewardPeriodTime\",\"type\":\"uint256\"}],\"name\":\"RewardPeriodTimeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_slasher\",\"type\":\"address\"}],\"name\":\"SlasherAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_slasher\",\"type\":\"address\"}],\"name\":\"SlasherRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenCreditAddition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenCreditWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_unbondTime\",\"type\":\"uint256\"}],\"name\":\"UnbondTimeChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_keeperOrJob\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_unbonding\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Unbonding\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_bond\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ETH_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_REWARD_PERIOD_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fromJob\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toJob\",\"type\":\"address\"}],\"name\":\"acceptJobMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"}],\"name\":\"acceptJobOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bonding\",\"type\":\"address\"}],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_disputer\",\"type\":\"address\"}],\"name\":\"addDisputer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"}],\"name\":\"addJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addLiquidityToJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_slasher\",\"type\":\"address\"}],\"name\":\"addSlasher\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addTokenCreditsToJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"}],\"name\":\"approveLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approvedLiquidities\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_list\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bonding\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"bond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_payment\",\"type\":\"uint256\"}],\"name\":\"bondedPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canActivateAfter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canWithdrawAfter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeJobOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"directTokenPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_jobOrKeeper\",\"type\":\"address\"}],\"name\":\"dispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"disputers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"disputes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"firstSeen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"forceLiquidityCreditsToJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasBonded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inflationPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bond\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_earned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_age\",\"type\":\"uint256\"}],\"name\":\"isBondedKeeper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isBondedKeeper\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"}],\"name\":\"isKeeper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isKeeper\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"}],\"name\":\"jobLiquidityCredits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityCredits\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"jobOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"jobPendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"}],\"name\":\"jobPeriodCredits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_periodCredits\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"jobTokenCredits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"jobTokenCreditsAddedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jobs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_list\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keep3rHelper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keep3rV1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keep3rV1Proxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keepers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"_list\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kp3rWethPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityMinimum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fromJob\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_toJob\",\"type\":\"address\"}],\"name\":\"migrateJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"}],\"name\":\"observeLiquidity\",\"outputs\":[{\"components\":[{\"internalType\":\"int56\",\"name\":\"current\",\"type\":\"int56\"},{\"internalType\":\"int56\",\"name\":\"difference\",\"type\":\"int56\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"internalType\":\"struct IKeep3rJobFundableLiquidity.TickCache\",\"name\":\"_tickCache\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingBonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingJobMigrations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingUnbonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"quoteLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_periodCredits\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_disputer\",\"type\":\"address\"}],\"name\":\"removeDisputer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_slasher\",\"type\":\"address\"}],\"name\":\"removeSlasher\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_jobOrKeeper\",\"type\":\"address\"}],\"name\":\"resolve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"}],\"name\":\"revokeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPeriodTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"sendDust\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bondTime\",\"type\":\"uint256\"}],\"name\":\"setBondTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_inflationPeriod\",\"type\":\"uint256\"}],\"name\":\"setInflationPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keep3rHelper\",\"type\":\"address\"}],\"name\":\"setKeep3rHelper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keep3rV1\",\"type\":\"address\"}],\"name\":\"setKeep3rV1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keep3rV1Proxy\",\"type\":\"address\"}],\"name\":\"setKeep3rV1Proxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_kp3rWethPool\",\"type\":\"address\"}],\"name\":\"setKp3rWethPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityMinimum\",\"type\":\"uint256\"}],\"name\":\"setLiquidityMinimum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardPeriodTime\",\"type\":\"uint256\"}],\"name\":\"setRewardPeriodTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_unbondTime\",\"type\":\"uint256\"}],\"name\":\"setUnbondTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bonded\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"slash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"slashLiquidityFromJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"slashTokenFromJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"slashers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"}],\"name\":\"totalJobCredits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_credits\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bonding\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unbond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unbondLiquidityFromJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unbondTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bonding\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"withdrawLiquidityFromJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_job\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"withdrawTokenCreditsFromJob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"workCompleted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keeper\",\"type\":\"address\"}],\"name\":\"worked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"workedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Keep3r","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000054054ea2db6edc336cb87966815fd66cc337f224000000000000000000000000c07c37a0a1e557e0d1704c90d966b37a67a45dd40000000000000000000000001ceb5cb57c4d4e2b2433641b95dd330a33185a44000000000000000000000000fc48ac750959d5d5ae9a4bb38f548a7ca8763f8d00000000000000000000000011b7a6bc0259ed6cf9db8f499988f9ecc7167bf5","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}