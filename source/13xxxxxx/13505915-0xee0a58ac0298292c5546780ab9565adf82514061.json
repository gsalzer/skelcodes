{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin\\contracts\\token\\ERC20\\IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @ethereansos\\swissknife\\contracts\\lib\\GeneralUtilities.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\n\r\nlibrary BehaviorUtilities {\r\n\r\n    function randomKey(uint256 i) internal view returns (bytes32) {\r\n        return keccak256(abi.encode(i, block.timestamp, block.number, tx.origin, tx.gasprice, block.coinbase, block.difficulty, msg.sender, blockhash(block.number - 5)));\r\n    }\r\n\r\n    function calculateProjectedArraySizeAndLoopUpperBound(uint256 arraySize, uint256 start, uint256 offset) internal pure returns(uint256 projectedArraySize, uint256 projectedArrayLoopUpperBound) {\r\n        if(arraySize != 0 && start < arraySize && offset != 0) {\r\n            uint256 length = start + offset;\r\n            if(start < (length = length > arraySize ? arraySize : length)) {\r\n                projectedArraySize = (projectedArrayLoopUpperBound = length) - start;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary ReflectionUtilities {\r\n\r\n    function read(address subject, bytes memory inputData) internal view returns(bytes memory returnData) {\r\n        bool result;\r\n        (result, returnData) = subject.staticcall(inputData);\r\n        if(!result) {\r\n            assembly {\r\n                revert(add(returnData, 0x20), mload(returnData))\r\n            }\r\n        }\r\n    }\r\n\r\n    function submit(address subject, uint256 value, bytes memory inputData) internal returns(bytes memory returnData) {\r\n        bool result;\r\n        (result, returnData) = subject.call{value : value}(inputData);\r\n        if(!result) {\r\n            assembly {\r\n                revert(add(returnData, 0x20), mload(returnData))\r\n            }\r\n        }\r\n    }\r\n\r\n    function isContract(address subject) internal view returns (bool) {\r\n        if(subject == address(0)) {\r\n            return false;\r\n        }\r\n        uint256 codeLength;\r\n        assembly {\r\n            codeLength := extcodesize(subject)\r\n        }\r\n        return codeLength > 0;\r\n    }\r\n\r\n    function clone(address originalContract) internal returns(address copyContract) {\r\n        assembly {\r\n            mstore(\r\n                0,\r\n                or(\r\n                    0x5880730000000000000000000000000000000000000000803b80938091923cF3,\r\n                    mul(originalContract, 0x1000000000000000000)\r\n                )\r\n            )\r\n            copyContract := create(0, 0, 32)\r\n            switch extcodesize(copyContract)\r\n                case 0 {\r\n                    invalid()\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary BytesUtilities {\r\n\r\n    bytes private constant ALPHABET = \"0123456789abcdef\";\r\n\r\n    function asAddress(bytes memory b) internal pure returns(address) {\r\n        if(b.length == 0) {\r\n            return address(0);\r\n        }\r\n        if(b.length == 20) {\r\n            address addr;\r\n            assembly {\r\n                addr := mload(add(b, 20))\r\n            }\r\n            return addr;\r\n        }\r\n        return abi.decode(b, (address));\r\n    }\r\n\r\n    function asAddressArray(bytes memory b) internal pure returns(address[] memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (address[]));\r\n        }\r\n    }\r\n\r\n    function asBool(bytes memory bs) internal pure returns(bool) {\r\n        return asUint256(bs) != 0;\r\n    }\r\n\r\n    function asBoolArray(bytes memory b) internal pure returns(bool[] memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (bool[]));\r\n        }\r\n    }\r\n\r\n    function asBytesArray(bytes memory b) internal pure returns(bytes[] memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (bytes[]));\r\n        }\r\n    }\r\n\r\n    function asString(bytes memory b) internal pure returns(string memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (string));\r\n        }\r\n    }\r\n\r\n    function asStringArray(bytes memory b) internal pure returns(string[] memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (string[]));\r\n        }\r\n    }\r\n\r\n    function asUint256(bytes memory bs) internal pure returns(uint256 x) {\r\n        if (bs.length >= 32) {\r\n            assembly {\r\n                x := mload(add(bs, add(0x20, 0)))\r\n            }\r\n        }\r\n    }\r\n\r\n    function asUint256Array(bytes memory b) internal pure returns(uint256[] memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (uint256[]));\r\n        }\r\n    }\r\n\r\n    function toString(bytes memory data) internal pure returns(string memory) {\r\n        bytes memory str = new bytes(2 + data.length * 2);\r\n        str[0] = \"0\";\r\n        str[1] = \"x\";\r\n        for (uint i = 0; i < data.length; i++) {\r\n            str[2+i*2] = ALPHABET[uint(uint8(data[i] >> 4))];\r\n            str[3+i*2] = ALPHABET[uint(uint8(data[i] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    function asSingletonArray(bytes memory a) internal pure returns(bytes[] memory array) {\r\n        array = new bytes[](1);\r\n        array[0] = a;\r\n    }\r\n}\r\n\r\nlibrary StringUtilities {\r\n\r\n    bytes1 private constant CHAR_0 = bytes1('0');\r\n    bytes1 private constant CHAR_A = bytes1('A');\r\n    bytes1 private constant CHAR_a = bytes1('a');\r\n    bytes1 private constant CHAR_f = bytes1('f');\r\n\r\n    function isEmpty(string memory test) internal pure returns (bool) {\r\n        return equals(test, \"\");\r\n    }\r\n\r\n    function equals(string memory a, string memory b) internal pure returns(bool) {\r\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\r\n    }\r\n\r\n    function toLowerCase(string memory str) internal pure returns(string memory) {\r\n        bytes memory bStr = bytes(str);\r\n        for (uint i = 0; i < bStr.length; i++) {\r\n            bStr[i] = bStr[i] >= 0x41 && bStr[i] <= 0x5A ? bytes1(uint8(bStr[i]) + 0x20) : bStr[i];\r\n        }\r\n        return string(bStr);\r\n    }\r\n\r\n    function asBytes(string calldata str) internal pure returns(bytes memory toDecode) {\r\n        bytes memory data = abi.encodePacked(str);\r\n        if(data.length == 0 || data[0] != \"0\" || (data[1] != \"x\" && data[1] != \"X\")) {\r\n            return \"\";\r\n        }\r\n        uint256 start = 2;\r\n        toDecode = new bytes((data.length - 2) / 2);\r\n\r\n        for(uint256 i = 0; i < toDecode.length; i++) {\r\n            toDecode[i] = bytes1(_fromHexChar(uint8(data[start++])) + _fromHexChar(uint8(data[start++])) * 16);\r\n        }\r\n    }\r\n\r\n    function _fromHexChar(uint8 c) private pure returns (uint8) {\r\n        bytes1 charc = bytes1(c);\r\n        return charc < CHAR_0 || charc > CHAR_f ? 0 : (charc < CHAR_A ? 0 : 10) + c - uint8(charc < CHAR_A ? CHAR_0 : charc < CHAR_a ? CHAR_A : CHAR_a);\r\n    }\r\n}\r\n\r\nlibrary Uint256Utilities {\r\n    function asSingletonArray(uint256 n) internal pure returns(uint256[] memory array) {\r\n        array = new uint256[](1);\r\n        array[0] = n;\r\n    }\r\n\r\n    function toString(uint256 _i) internal pure returns (string memory) {\r\n        return BytesUtilities.toString(abi.encodePacked(_i));\r\n    }\r\n\r\n    function sum(uint256[] memory arr) internal pure returns (uint256 result) {\r\n        for(uint256 i = 0; i < arr.length; i++) {\r\n            result += arr[i];\r\n        }\r\n    }\r\n}\r\n\r\nlibrary AddressUtilities {\r\n    function asSingletonArray(address a) internal pure returns(address[] memory array) {\r\n        array = new address[](1);\r\n        array[0] = a;\r\n    }\r\n\r\n    function toString(address _addr) internal pure returns (string memory) {\r\n        return _addr == address(0) ? \"0x0000000000000000000000000000000000000000\" : BytesUtilities.toString(abi.encodePacked(_addr));\r\n    }\r\n}\r\n\r\nlibrary Bytes32Utilities {\r\n\r\n    function asSingletonArray(bytes32 a) internal pure returns(bytes32[] memory array) {\r\n        array = new bytes32[](1);\r\n        array[0] = a;\r\n    }\r\n\r\n    function toString(bytes32 bt) internal pure returns (string memory) {\r\n        return bt == bytes32(0) ?  \"0x0000000000000000000000000000000000000000000000000000000000000000\" : BytesUtilities.toString(abi.encodePacked(bt));\r\n    }\r\n}\r\n\r\nlibrary TransferUtilities {\r\n    using ReflectionUtilities for address;\r\n\r\n    function balanceOf(address erc20TokenAddress, address account) internal view returns(uint256) {\r\n        if(erc20TokenAddress == address(0)) {\r\n            return account.balance;\r\n        }\r\n        return abi.decode(erc20TokenAddress.read(abi.encodeWithSelector(IERC20(erc20TokenAddress).balanceOf.selector, account)), (uint256));\r\n    }\r\n\r\n    function allowance(address erc20TokenAddress, address account, address spender) internal view returns(uint256) {\r\n        if(erc20TokenAddress == address(0)) {\r\n            return 0;\r\n        }\r\n        return abi.decode(erc20TokenAddress.read(abi.encodeWithSelector(IERC20(erc20TokenAddress).allowance.selector, account, spender)), (uint256));\r\n    }\r\n\r\n    function safeApprove(address erc20TokenAddress, address spender, uint256 value) internal {\r\n        bytes memory returnData = erc20TokenAddress.submit(0, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, spender, value));\r\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address erc20TokenAddress, address to, uint256 value) internal {\r\n        if(value == 0) {\r\n            return;\r\n        }\r\n        if(erc20TokenAddress == address(0)) {\r\n            to.submit(value, \"\");\r\n            return;\r\n        }\r\n        bytes memory returnData = erc20TokenAddress.submit(0, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\r\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) internal {\r\n        if(value == 0) {\r\n            return;\r\n        }\r\n        if(erc20TokenAddress == address(0)) {\r\n            to.submit(value, \"\");\r\n            return;\r\n        }\r\n        bytes memory returnData = erc20TokenAddress.submit(0, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\r\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\r\n    }\r\n}\r\n\r\n// File: contracts\\claimer\\OldOSClaimer.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\n\r\n\r\ncontract OldOSClaimer {\r\n    using TransferUtilities for address;\r\n\r\n    event Claimed(address indexed subject, address indexed token, address indexed receiver, uint256 amount);\r\n\r\n    address public host;\r\n\r\n    bool public claimable;\r\n\r\n    mapping(address => mapping(address => uint256)) public amount;\r\n\r\n    mapping(address => bool) public claimed;\r\n\r\n    address[] private _tokens;\r\n\r\n    mapping(address => bool) public testAddress;\r\n\r\n    constructor(address _host, address[] memory tokensArray, address[] memory testAddresses) {\r\n        host = _host;\r\n        _tokens = tokensArray;\r\n        for(uint256 i = 0; i < testAddresses.length; i++) {\r\n            require(testAddresses[i] != address(0), \"zero address\");\r\n            testAddress[testAddresses[i]] = true;\r\n        }\r\n    }\r\n\r\n    function tokens() external view returns(address[] memory) {\r\n        return _tokens;\r\n    }\r\n\r\n    modifier hostOnly {\r\n        require(msg.sender == host, \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    receive() external payable {\r\n    }\r\n\r\n    function makeClaimable() external hostOnly {\r\n        claimable = true;\r\n        host = address(0);\r\n    }\r\n\r\n    function flushToWallet(address receiver) external hostOnly {\r\n        require(receiver != address(0), \"zero address\");\r\n        uint256[] memory amounts = getBalances();\r\n        for(uint256 i = 0; i < amounts.length; i++) {\r\n            _tokens[i].safeTransfer(receiver, amounts[i]);\r\n        }\r\n    }\r\n\r\n    function getBalances() public view returns(uint256[] memory amounts) {\r\n        amounts = new uint256[](_tokens.length);\r\n        for(uint256 i = 0; i < amounts.length; i++) {\r\n            amounts[i] = _tokens[i].balanceOf(address(this));\r\n        }\r\n    }\r\n\r\n    function setup(address[] calldata owners, uint256[][] calldata amounts) external hostOnly {\r\n        require(!claimable, \"claimable\");\r\n        require(owners.length == amounts.length, \"input\");\r\n        address[] memory tks = _tokens;\r\n        for(uint256 z = 0; z < owners.length; z++) {\r\n            address owner = owners[z];\r\n            uint256[] memory ownerAmounts = amounts[z];\r\n            require(ownerAmounts.length == tks.length, \"length\");\r\n            for(uint256 i = 0; i < tks.length; i++) {\r\n                address tokenAddress = tks[i];\r\n                amount[owner][tokenAddress] = ownerAmounts[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    function claim(address receiver) external {\r\n        require(claimable || testAddress[msg.sender], \"not claimable\");\r\n        require(!claimed[msg.sender], \"claimed\");\r\n        claimed[msg.sender] = true;\r\n        address realReceiver = receiver == address(0) ? msg.sender : receiver;\r\n        address[] memory tks = _tokens;\r\n        for(uint256 i = 0; i < tks.length; i++) {\r\n            address tokenAddress = tks[i];\r\n            uint256 tokenAmount = amount[msg.sender][tokenAddress];\r\n            if(tokenAmount != 0) {\r\n                tokenAddress.safeTransfer(realReceiver, tokenAmount);\r\n            }\r\n            emit Claimed(msg.sender, tokenAddress, realReceiver, tokenAmount);\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_host\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokensArray\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"testAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"flushToWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalances\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"host\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makeClaimable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"amounts\",\"type\":\"uint256[][]\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"testAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"OldOSClaimer","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000e03fb6b2252f96282ebf0a867e5afe58e4b03fa000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000006100dd79fcaa88420750dcee3f735d168abcb77100000000000000000000000000000000000000000000000000000000000000020000000000000000000000007efb51578f3c4cc6d0ee287f7e43ec29f49e73020000000000000000000000008837b6d20791666eea44bed9636022aad87d7d49","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://07633fd055013e623d89ff8f483ca96bac58fee1c877a53bdb73b6c451aca2ae"}]}