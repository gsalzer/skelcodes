// SPDX-License-Identifier: MIT

/* 

   _|_|    _|_|_|        _|_|    _|      _|    _|_|_|  _|_|_|_|  _|          _|_|_|
 _|    _|    _|        _|    _|  _|_|    _|  _|        _|        _|        _|    
 _|_|_|_|    _|        _|_|_|_|  _|  _|  _|  _|  _|_|  _|_|_|    _|          _|_|  
 _|    _|    _|        _|    _|  _|    _|_|  _|    _|  _|        _|              _|
 _|    _|  _|_|_|      _|    _|  _|      _|    _|_|_|  _|_|_|_|  _|_|_|_|  _|_|_|

200 angels generated by artificial intelligence stored on the blockchain.

This is a collaboration between Computer & Gatlas to raise money for their friend that is battling cancer.

All money generated from this collection will go directly to help their friend and his family.

Website: https://aiangels.art/
GoFundMe: https://www.gofundme.com/f/matt039s-savior

*/


pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract AIAngels is ERC721Enumerable, Ownable {
    
    using SafeMath for uint256;

    uint public price = 0.04 ether;
    uint public maxAngels = 200;
    uint public txnLimit = 5;
    bool public saleIsActive = false;
    string private baseURI;

    event NewAngelsMinted(address sender, uint[] tokenId);

    constructor() ERC721("AI Angels", "AIAngels") {
        
    }

    function _baseURI() internal view override returns (string memory) {
        return baseURI;
    }

    function setBaseURI(string memory uri) public onlyOwner {
        baseURI = uri;
    }

    function flipSaleState() public onlyOwner {
        saleIsActive = !saleIsActive;
    }

    function mintAngel() public payable {
        require(saleIsActive, "The sale must be active to mint an Angel");
        require(price <= msg.value, "Ether value sent is not correct");
        uint tokenId = totalSupply().add(1);
        require(tokenId <= maxAngels, "The purchase would exceed the max supply of Angels");
        
        _safeMint(msg.sender, tokenId);

        uint[] memory tokenIds = new uint[](1);
        tokenIds[0] = tokenId;
        emit NewAngelsMinted(msg.sender, tokenIds);
    }

    function mintNAngels(uint numAngels) public payable {
        require(saleIsActive, "The sale must be active to mint an Angel");
        require(numAngels > 0, "Must mint at least one Angel");
        require(numAngels <= txnLimit, "Cannot purchase more than 10 in one transaction");
        require(price * numAngels <= msg.value, "Ether value sent is not correct");
        require(totalSupply().add(numAngels) <= maxAngels, "Purchase would exceed max supply of Angels");
        uint[] memory tokenIds = new uint[](numAngels);
        
        for(uint i = 0; i < numAngels; i++) {
            uint tokenId = totalSupply() + 1;
            if (totalSupply() < maxAngels) {
                _safeMint(msg.sender, tokenId);
                tokenIds[i] = tokenId;
            }
        }

        emit NewAngelsMinted(msg.sender, tokenIds);
    }

    function withdrawAll() public payable onlyOwner {
        require(payable(msg.sender).send(address(this).balance));
    }

    function withdrawAllToAddress(address addr) public payable onlyOwner {
        require(payable(addr).send(address(this).balance));
    }
}
