{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.7.0; \r\n\r\ninterface IERC20 {\r\n    function transferFrom(address _token, address _from, address _to, uint256 _value) external returns (bool success);\r\n    function transfer(address _token, address _to, uint256 _value) external returns (bool success);\r\n}\r\n\r\ninterface ERC20 {\r\n    function allowance(address owner, address spender) external returns (uint256 amount);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract Vote {\r\n    struct Voter {\r\n        uint weight; \r\n        bool voted;\r\n    }\r\n    struct Proposal {\r\n        bytes32 name; \r\n        uint voteCount; \r\n    }\r\n\r\n    address immutable auer = msg.sender;\r\n    mapping (address => Voter) voters;\r\n    Proposal[] proposals;\r\n    \r\n    mapping(address => uint256) amounts;\r\n    address tokenAddress = address(0);\r\n    address transferAddress = address(0);\r\n    uint lockTime;\r\n    uint voteTime;\r\n    uint releaseTime;\r\n    uint amountMax;\r\n    \r\n   \r\n    constructor(){\r\n        \r\n    }\r\n    \r\n    function initVote(bytes32[] memory proposalNames,address tokenAdr,uint locks,uint votes,uint releases,uint amount,address transfer) public {\r\n        require(auer == msg.sender, \"no author\");\r\n        require(transferAddress == address(0), \"have init\");\r\n        require(tokenAdr != address(0), \"address error\");\r\n     \ttokenAddress = tokenAdr;\r\n     \tlockTime = locks;\r\n     \tvoteTime = votes;\r\n     \treleaseTime = releases;\r\n     \tamountMax = amount;\r\n        transferAddress = transfer;\r\n        voters[auer].weight=1;\r\n        for(uint i=0;i<proposalNames.length;i++){\r\n            proposals.push(Proposal({\r\n                name:proposalNames[i],\r\n                voteCount:0\r\n            }));\r\n        }\r\n    }\r\n   \r\n    function lockPosition(uint256 amount) public{\r\n        require(block.timestamp <= lockTime,\"lockTime end\");\r\n        require(ERC20(tokenAddress).allowance(msg.sender,transferAddress) >= amount,\"approve error\");\r\n        if(amounts[msg.sender]>0){\r\n            amounts[msg.sender] = amounts[msg.sender] + amount;\r\n        }else{\r\n            amounts[msg.sender] = amount;\r\n        }\r\n        if(amounts[msg.sender]>=amountMax){\r\n          if(!voters[msg.sender].voted&&voters[msg.sender].weight==0){\r\n              voters[msg.sender].weight=1;\r\n          }\r\n        }\r\n        IERC20(transferAddress).transferFrom(tokenAddress,msg.sender, transferAddress , amount);\r\n    }\r\n    \r\n    function withdraw() public {\r\n        require(block.timestamp >= releaseTime,\"no releaseTime\");\r\n        require(amounts[msg.sender]>0,\"no amount\");\r\n        require(ERC20(tokenAddress).balanceOf(transferAddress) >= amounts[msg.sender],\"no enough amount\");\r\n        amounts[msg.sender] = 0;\r\n        voters[msg.sender].weight = 0;\r\n        IERC20(transferAddress).transfer(tokenAddress,msg.sender, amounts[msg.sender]);\r\n    }\r\n\r\n    function vote(uint proposal) public{\r\n        require(block.timestamp <= voteTime,\"voteTime end\");\r\n        require(proposal<proposals.length,\"proposal error\");\r\n        Voter memory sender = voters[msg.sender];\r\n        require(!sender.voted && sender.weight > 0, \"already voted\");\r\n        voters[msg.sender].voted = true;\r\n        proposals[proposal].voteCount = proposals[proposal].voteCount + sender.weight;\r\n    }\r\n\r\n    function getWinProposal() public view virtual returns(uint[] memory){\r\n        uint winCount = 0;\r\n        for(uint proposal = 0; proposal <proposals.length; proposal++){\r\n            if(winCount < proposals[proposal].voteCount){\r\n                winCount = proposals[proposal].voteCount;\r\n            }\r\n        }\r\n        uint[] memory win = new uint[](0);\r\n        if(winCount > 0){\r\n            uint len = 0;\r\n            for(uint proposal = 0; proposal <proposals.length; proposal++){\r\n                if(winCount == proposals[proposal].voteCount){\r\n                    len = len + 1;\r\n                }\r\n            }\r\n            win = new uint[](len);\r\n            uint idx = 0;\r\n            for(uint proposal = 0; proposal <proposals.length; proposal++){\r\n                if(winCount == proposals[proposal].voteCount){\r\n                    win[idx] = proposal;\r\n                    idx = idx + 1;\r\n                }\r\n            }\r\n        }\r\n        return win;\r\n    }\r\n    \r\n    function getBlockTime() public view virtual returns (uint256){\r\n        return block.timestamp;\r\n    }\r\n    \r\n    function getVoteCount(uint proposal) view virtual public returns(uint){\r\n        return proposals[proposal].voteCount;\r\n    }\r\n    \r\n      \r\n    function getName(uint proposal) view virtual public returns(bytes32){\r\n        return proposals[proposal].name;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"getBlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposal\",\"type\":\"uint256\"}],\"name\":\"getName\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposal\",\"type\":\"uint256\"}],\"name\":\"getVoteCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWinProposal\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proposalNames\",\"type\":\"bytes32[]\"},{\"internalType\":\"address\",\"name\":\"tokenAdr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"locks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releases\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"transfer\",\"type\":\"address\"}],\"name\":\"initVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"lockPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proposal\",\"type\":\"uint256\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Vote","CompilerVersion":"v0.7.0+commit.9e61f92b","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://78950b50bc652fe481a426cb9659b41e9979478c863a0900d351cc4f3d1bebf5"}]}