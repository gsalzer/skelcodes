{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"},\"ICollectorPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\ninterface ICollectorPool {\\n  function maximumSupply() external view returns (uint256);\\n  function balanceOf(address owner) external view returns (uint256);\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n}\\n\"},\"ILandCollection.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\ninterface ILandCollection {\\n  function totalMinted(uint256 groupId) external view returns (uint256);\\n  function maximumSupply(uint256 groupId) external view returns (uint256);\\n  function mintToken(address account, uint256 groupId, uint256 count, uint256 seed) external;\\n  function balanceOf(address owner) external view returns (uint256);\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n  function ownerOf(uint256 tokenId) external view returns (address);\\n}\\n\"},\"ILandYield.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\ninterface ILandYield {\\n  function distributePrimaryYield() external;\\n}\\n\"},\"IMintPass.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\ninterface IMintPass {\\n  function passExists(uint256 _passId) external view returns (bool);\\n  function passDetail(uint256 _tokenId) external view returns (address, uint256, uint256);\\n  function mintToken(\\n    address _account,\\n    uint256 _passId,\\n    uint256 _count\\n  ) external;\\n  function burnToken(uint256 _tokenId) external;\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"},\"ZokuMinter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\n\\nimport \\\"./ILandCollection.sol\\\";\\nimport \\\"./ILandYield.sol\\\";\\nimport \\\"./IMintPass.sol\\\";\\nimport \\\"./ICollectorPool.sol\\\";\\n\\n\\ncontract ZokuMinter is Ownable, ReentrancyGuard {\\n  // Collection token contract interface\\n  ILandCollection public landCollection;\\n  // LandYield contract interface\\n  ILandYield public landYield;\\n  // MintPass token contract interface\\n  IMintPass public mintPass;\\n  // CollectorPool contract interface\\n  ICollectorPool public collectorPool;\\n\\n  // Used to determine whether minting is open to public\\n  bool public openForPublic;\\n  // Used to determine whether minting is open to MintPass holders\\n  bool public openForPass;\\n  // Stores the currently set token price\\n  uint256 public tokenPrice;\\n  // Stores the number of maximum tokens mintable in a single tx\\n  uint256 public mintLimit;\\n\\n  // Stores the universal groupId tracked by the main Collection\\n  uint256 public groupId;\\n\\n  constructor(\\n    uint256 _groupId,\\n    uint256 _price,\\n    address _landCollection,\\n    address _landYield,\\n    address _mintPass,\\n    address _collectorPool\\n  ) {\\n    mintLimit = 15;\\n    groupId = _groupId;\\n    tokenPrice = _price;\\n    landCollection = ILandCollection(_landCollection);\\n    landYield = ILandYield(_landYield);\\n    mintPass = IMintPass(_mintPass);\\n    collectorPool = ICollectorPool(_collectorPool);\\n  }\\n\\n  // Only to be used in case there\\u0027s a need to upgrade the yield contract mid-sales\\n  function setLandYield(address _address) external onlyOwner {\\n    require(_address != address(0), \\\"Invalid Address\\\");\\n    landYield = ILandYield(_address);\\n  }\\n\\n  // Only to be used in case there\\u0027s a need to upgrade the collector pool contract mid-sales\\n  function setCollectorPool(address _address) external onlyOwner {\\n    require(_address != address(0), \\\"Invalid Address\\\");\\n    collectorPool = ICollectorPool(_address);\\n  }\\n\\n  // Update the state of the public minting\\n  function setOpenForPublic(bool _state) external onlyOwner {\\n    require(openForPublic != _state, \\\"Identical State Has Been Set\\\");\\n    openForPublic = _state;\\n  }\\n\\n  // Update the state of the priority minting\\n  function setOpenForPass(bool _state) external onlyOwner {\\n    require(openForPass != _state, \\\"Identical State Has Been Set\\\");\\n    openForPass = _state;\\n  }\\n\\n  // Update the token price only if there\\u0027s a valid reason to do so\\n  function setTokenPrice(uint256 _price) external onlyOwner {\\n    require(_price \\u003e 0, \\\"Invalid Price\\\");\\n    tokenPrice = _price;\\n  }\\n\\n  // Set maximum mint limit per tx\\n  function setMintLimit(uint256 _limit) external onlyOwner {\\n    require(_limit \\u003e 0 \\u0026\\u0026 _limit \\u003c= 20, \\\"Invalid Value For Limit\\\");\\n    mintLimit = _limit;\\n  }\\n\\n  // Accepts optional passTokenIds for priority minting using MintPass tokens (only before public sales)\\n  function mint(uint256[] calldata _passTokenIds) external payable nonReentrant {\\n    // Check if tokens are still available for sale\\n    uint256 maxSupply = landCollection.maximumSupply(groupId);\\n    uint256 totalMinted = landCollection.totalMinted(groupId);\\n    uint256 available = maxSupply - totalMinted;\\n    available = (available \\u003e mintLimit ? mintLimit : available);\\n    require(available \\u003e 0, \\\"Sold Out\\\");\\n\\n    uint256 mintCount;\\n    uint256 totalSpent = 0;\\n\\n    if (_passTokenIds.length \\u003e 0) {\\n      // If passTokenIds are specified, check if priority minting is open and calculate actual total prices after discounts\\n      require(openForPass, \\\"Priority Minting Is Closed\\\");\\n      mintCount = _passTokenIds.length;\\n      mintCount = (mintCount \\u003e available ? available : mintCount);\\n\\n      for (uint256 i = 0; i \\u003c mintCount; i++) {\\n        address passOwner;\\n        uint256 passDiscount;\\n        (passOwner, , passDiscount) = mintPass.passDetail(_passTokenIds[i]);\\n        require(passOwner == msg.sender, \\\"Invalid Pass Specified\\\");\\n\\n        totalSpent += tokenPrice * (100 - passDiscount) / 100;\\n      }\\n\\n      require(msg.value \\u003e= totalSpent, \\\"Insufficient Funds\\\");\\n\\n      for (uint256 i = 0; i \\u003c mintCount; i++) {\\n        mintPass.burnToken(_passTokenIds[i]);\\n      }\\n    } else {\\n      require(openForPublic, \\\"Publis Sale Is Closed\\\");\\n      require(msg.value \\u003e= tokenPrice, \\\"Insufficient Funds\\\");\\n      mintCount = msg.value / tokenPrice;\\n      mintCount = (mintCount \\u003e available ? available : mintCount);\\n      totalSpent = mintCount * tokenPrice;\\n    }\\n\\n    landCollection.mintToken(msg.sender, groupId, mintCount, available);\\n\\n    if (totalSpent \\u003e 0) {\\n      // Transfer the funds to the yield contract for land owners and treasury, and leave the rest for collectors\\n      uint256 yield = totalSpent * 85 / 100;\\n      uint256 treasury = totalSpent * 5 / 100;\\n      (bool success, ) = address(landYield).call{value: yield + treasury}(\\n        abi.encodeWithSignature(\\\"distributeSalesYield(uint256)\\\", yield)\\n      );\\n      require(success, \\\"Failed To Distribute To Yield\\\");\\n\\n      // Send back any excess funds\\n      uint256 refund = msg.value - totalSpent;\\n      if (refund \\u003e 0) {\\n        payable(msg.sender).transfer(refund);\\n      }\\n    }\\n  }\\n\\n  // Transfers the remaining funds to the collector pool\\n  function withdraw() external onlyOwner {\\n    uint256 totalFunds = address(this).balance;\\n    require(totalFunds \\u003e 0, \\\"Insufficient Funds\\\");\\n    // Send funds via call function for the collector pool funds\\n    (bool success, ) = address(collectorPool).call{value: totalFunds}(\\\"\\\");\\n    require(success, \\\"Failed To Distribute To Pool\\\");\\n  }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_groupId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_landCollection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_landYield\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mintPass\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collectorPool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"collectorPool\",\"outputs\":[{\"internalType\":\"contract ICollectorPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"groupId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"landCollection\",\"outputs\":[{\"internalType\":\"contract ILandCollection\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"landYield\",\"outputs\":[{\"internalType\":\"contract ILandYield\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_passTokenIds\",\"type\":\"uint256[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPass\",\"outputs\":[{\"internalType\":\"contract IMintPass\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openForPass\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openForPublic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setCollectorPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setLandYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setMintLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setOpenForPass\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setOpenForPublic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ZokuMinter","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000003eb00000000000000000000000000000000000000000000000003782dace9d900000000000000000000000000007f0ab6a57cfd191a202ab3f813ef9b851c77e61800000000000000000000000039dfba33b4388aa786232a4fd39f8f86fcd74067000000000000000000000000f8854f6011278dcb3b1abbf41bdf80a8c427c656000000000000000000000000060435dd1d60dce1a7d8335ab90251c7114bcc7e","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://039b66f4e3b452a6aaf9e8bf175e3b24330f413a6788e2a9ce66ec7b4761d1ab"}]}