{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.8 <0.9.0;\r\nlibrary Counters { struct Counter { uint256 _value; }\r\nfunction current(Counter storage counter) internal view returns (uint256) { return counter._value; }\r\nfunction increment(Counter storage counter) internal { unchecked { counter._value += 1; } }\r\nfunction decrement(Counter storage counter) internal { uint256 value = counter._value; require(value > 0, \"Counter: decrement overflow\"); unchecked { counter._value = value - 1; } }\r\nfunction reset(Counter storage counter) internal { counter._value = 0; } }\r\ninterface IERC165 { function supportsInterface(bytes4 interfaceId) external view returns (bool); }\r\ninterface IERC721 is IERC165 { event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\nfunction balanceOf(address owner) external view returns (uint256 balance);\r\nfunction ownerOf(uint256 tokenId) external view returns (address owner);\r\nfunction safeTransferFrom( address from, address to, uint256 tokenId ) external;\r\nfunction transferFrom( address from, address to, uint256 tokenId ) external;\r\nfunction approve(address to, uint256 tokenId) external;\r\nfunction getApproved(uint256 tokenId) external view returns (address operator);\r\nfunction setApprovalForAll(address operator, bool _approved) external;\r\nfunction isApprovedForAll(address owner, address operator) external view returns (bool);\r\nfunction safeTransferFrom( address from, address to, uint256 tokenId, bytes calldata data ) external; }\r\ninterface IERC721Receiver { function onERC721Received( address operator, address from, uint256 tokenId, bytes calldata data ) external returns (bytes4); }\r\ninterface IERC721Metadata is IERC721 { function name() external view returns (string memory); function symbol() external view returns (string memory); function tokenURI(uint256 tokenId) external view returns (string memory); }\r\nlibrary Address {function isContract(address account) internal view returns (bool) { uint256 size; assembly { size := extcodesize(account) } return size > 0; }\r\nfunction sendValue(address payable recipient, uint256 amount) internal { require(address(this).balance >= amount, \"Address: insufficient balance\");  (bool success, ) = recipient.call{value: amount}(\"\"); require(success, \"Address: unable to send value, recipient may have reverted\"); }\r\nfunction functionCall(address target, bytes memory data) internal returns (bytes memory) { return functionCall(target, data, \"Address: low-level call failed\"); }\r\nfunction functionCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) { return functionCallWithValue(target, data, 0, errorMessage); }\r\nfunction functionCallWithValue( address target, bytes memory data, uint256 value ) internal returns (bytes memory) { return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"); }\r\nfunction functionCallWithValue( address target, bytes memory data, uint256 value, string memory errorMessage ) internal returns (bytes memory) { require(address(this).balance >= value, \"Address: insufficient balance for call\"); require(isContract(target), \"Address: call to non-contract\");  (bool success, bytes memory returndata) = target.call{value: value}(data); return verifyCallResult(success, returndata, errorMessage); }\r\nfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) { return functionStaticCall(target, data, \"Address: low-level static call failed\"); }\r\nfunction functionStaticCall( address target, bytes memory data, string memory errorMessage ) internal view returns (bytes memory) { require(isContract(target), \"Address: static call to non-contract\");  (bool success, bytes memory returndata) = target.staticcall(data); return verifyCallResult(success, returndata, errorMessage); }\r\nfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) { return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); }\r\nfunction functionDelegateCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory) { require(isContract(target), \"Address: delegate call to non-contract\");  (bool success, bytes memory returndata) = target.delegatecall(data); return verifyCallResult(success, returndata, errorMessage); }\r\nfunction verifyCallResult( bool success, bytes memory returndata, string memory errorMessage ) internal pure returns (bytes memory) { if (success) { return returndata; } else { if (returndata.length > 0) { assembly { let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) } } else { revert(errorMessage); } } } }\r\nabstract contract Context { function _msgSender() internal view virtual returns (address) { return msg.sender; } function _msgData() internal view virtual returns (bytes calldata) { return msg.data; } }\r\nlibrary Strings { bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\"; function toString(uint256 value) internal pure returns (string memory) { if (value == 0) { return \"0\"; } uint256 temp = value; uint256 digits; while (temp != 0) { digits++; temp /= 10; } bytes memory buffer = new bytes(digits); while (value != 0) { digits -= 1; buffer[digits] = bytes1(uint8(48 + uint256(value % 10))); value /= 10; } return string(buffer); }\r\nfunction toHexString(uint256 value) internal pure returns (string memory) { if (value == 0) { return \"0x00\"; } uint256 temp = value; uint256 length = 0; while (temp != 0) { length++; temp >>= 8; } return toHexString(value, length); }\r\nfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory) { bytes memory buffer = new bytes(2 * length + 2); buffer[0] = \"0\"; buffer[1] = \"x\"; for (uint256 i = 2 * length + 1; i > 1; --i) { buffer[i] = _HEX_SYMBOLS[value & 0xf]; value >>= 4; } require(value == 0, \"Strings: hex length insufficient\"); return string(buffer); } }\r\nabstract contract ERC165 is IERC165 { function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) { return interfaceId == type(IERC165).interfaceId; } }\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata { using Address for address; using Strings for uint256; string private _name; string private _symbol; mapping(uint256 => address) private _owners; mapping(address => uint256) private _balances; mapping(uint256 => address) private _tokenApprovals; mapping(address => mapping(address => bool)) private _operatorApprovals;\r\nconstructor(string memory name_, string memory symbol_) { _name = name_; _symbol = symbol_; }\r\nfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) { return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId); }\r\nfunction balanceOf(address owner) public view virtual override returns (uint256) { require(owner != address(0), \"ERC721: balance query for the zero address\"); return _balances[owner]; }\r\nfunction ownerOf(uint256 tokenId) public view virtual override returns (address) { address owner = _owners[tokenId]; require(owner != address(0), \"ERC721: owner query for nonexistent token\"); return owner; }\r\nfunction name() public view virtual override returns (string memory) { return _name; }\r\nfunction symbol() public view virtual override returns (string memory) { return _symbol; }\r\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) { require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\"); string memory baseURI = _baseURI(); return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\"; }\r\nfunction _baseURI() internal view virtual returns (string memory) { return \"\"; }\r\nfunction approve(address to, uint256 tokenId) public virtual override { address owner = ERC721.ownerOf(tokenId); require(to != owner, \"ERC721: approval to current owner\"); require( _msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not owner nor approved for all\" ); _approve(to, tokenId); }\r\nfunction getApproved(uint256 tokenId) public view virtual override returns (address) { require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");  return _tokenApprovals[tokenId]; }\r\nfunction setApprovalForAll(address operator, bool approved) public virtual override { require(operator != _msgSender(), \"ERC721: approve to caller\");  _operatorApprovals[_msgSender()][operator] = approved; emit ApprovalForAll(_msgSender(), operator, approved); }\r\nfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) { return _operatorApprovals[owner][operator]; }\r\nfunction transferFrom( address from, address to, uint256 tokenId ) public virtual override { require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\"); _transfer(from, to, tokenId); }\r\nfunction safeTransferFrom( address from, address to, uint256 tokenId ) public virtual override { safeTransferFrom(from, to, tokenId, \"\"); }\r\nfunction safeTransferFrom( address from, address to, uint256 tokenId, bytes memory _data ) public virtual override { require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\"); _safeTransfer(from, to, tokenId, _data); }\r\nfunction _safeTransfer( address from, address to, uint256 tokenId, bytes memory _data ) internal virtual { _transfer(from, to, tokenId); require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\"); }\r\nfunction _exists(uint256 tokenId) internal view virtual returns (bool) { return _owners[tokenId] != address(0); }\r\nfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) { require(_exists(tokenId), \"ERC721: operator query for nonexistent token\"); address owner = ERC721.ownerOf(tokenId); return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender)); }\r\nfunction _safeMint(address to, uint256 tokenId) internal virtual { _safeMint(to, tokenId, \"\"); }\r\nfunction _safeMint( address to, uint256 tokenId, bytes memory _data ) internal virtual { _mint(to, tokenId); require( _checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\" ); }\r\nfunction _mint(address to, uint256 tokenId) internal virtual { require(to != address(0), \"ERC721: mint to the zero address\"); require(!_exists(tokenId), \"ERC721: token already minted\"); _beforeTokenTransfer(address(0), to, tokenId); _balances[to] += 1; _owners[tokenId] = to; emit Transfer(address(0), to, tokenId); }\r\nfunction _burn(uint256 tokenId) internal virtual { address owner = ERC721.ownerOf(tokenId); _beforeTokenTransfer(owner, address(0), tokenId); _approve(address(0), tokenId); _balances[owner] -= 1; delete _owners[tokenId];  emit Transfer(owner, address(0), tokenId); }\r\nfunction _transfer( address from, address to, uint256 tokenId ) internal virtual { require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\"); require(to != address(0), \"ERC721: transfer to the zero address\");  _beforeTokenTransfer(from, to, tokenId);  _approve(address(0), tokenId);  _balances[from] -= 1; _balances[to] += 1; _owners[tokenId] = to;  emit Transfer(from, to, tokenId); }\r\nfunction _approve(address to, uint256 tokenId) internal virtual { _tokenApprovals[tokenId] = to; emit Approval(ERC721.ownerOf(tokenId), to, tokenId); }\r\nfunction _checkOnERC721Received( address from, address to, uint256 tokenId, bytes memory _data ) private returns (bool) { if (to.isContract()) { try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) { return retval == IERC721Receiver.onERC721Received.selector; } catch (bytes memory reason) { if (reason.length == 0) { revert(\"ERC721: transfer to non ERC721Receiver implementer\"); } else { assembly { revert(add(32, reason), mload(reason)) } } } } else { return true; } }\r\nfunction _beforeTokenTransfer( address from, address to, uint256 tokenId ) internal virtual {} }\r\ninterface IERC721Enumerable is IERC721 { function totalSupply() external view returns (uint256); function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId); function tokenByIndex(uint256 index) external view returns (uint256);}\r\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable { mapping(address => mapping(uint256 => uint256)) private _ownedTokens; mapping(uint256 => uint256) private _ownedTokensIndex; uint256[] private _allTokens; mapping(uint256 => uint256) private _allTokensIndex;\r\nfunction supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) { return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId); }\r\nfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) { require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\"); return _ownedTokens[owner][index]; }\r\nfunction totalSupply() public view virtual override returns (uint256) { return _allTokens.length; }\r\nfunction tokenByIndex(uint256 index) public view virtual override returns (uint256) { require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\"); return _allTokens[index]; }\r\nfunction _beforeTokenTransfer( address from, address to, uint256 tokenId ) internal virtual override { super._beforeTokenTransfer(from, to, tokenId); if (from == address(0)) { _addTokenToAllTokensEnumeration(tokenId); } else if (from != to) { _removeTokenFromOwnerEnumeration(from, tokenId); } if (to == address(0)) { _removeTokenFromAllTokensEnumeration(tokenId); } else if (to != from) { _addTokenToOwnerEnumeration(to, tokenId); } }\r\nfunction _addTokenToOwnerEnumeration(address to, uint256 tokenId) private { uint256 length = ERC721.balanceOf(to); _ownedTokens[to][length] = tokenId; _ownedTokensIndex[tokenId] = length; }\r\nfunction _addTokenToAllTokensEnumeration(uint256 tokenId) private { _allTokensIndex[tokenId] = _allTokens.length; _allTokens.push(tokenId); }\r\nfunction _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {  uint256 lastTokenIndex = ERC721.balanceOf(from) - 1; uint256 tokenIndex = _ownedTokensIndex[tokenId];  if (tokenIndex != lastTokenIndex) { uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];  _ownedTokens[from][tokenIndex] = lastTokenId; _ownedTokensIndex[lastTokenId] = tokenIndex;  } delete _ownedTokensIndex[tokenId]; delete _ownedTokens[from][lastTokenIndex]; }\r\nfunction _removeTokenFromAllTokensEnumeration(uint256 tokenId) private { uint256 lastTokenIndex = _allTokens.length - 1; uint256 tokenIndex = _allTokensIndex[tokenId]; uint256 lastTokenId = _allTokens[lastTokenIndex]; _allTokens[tokenIndex] = lastTokenId; _allTokensIndex[lastTokenId] = tokenIndex;  _allTokensIndex[tokenId]; _allTokens.pop(); } }\r\nabstract contract ERC721URIStorage is ERC721 { using Strings for uint256; mapping(uint256 => string) private _tokenURIs;\r\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) { require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\"); string memory _tokenURI = _tokenURIs[tokenId]; string memory base = _baseURI(); if (bytes(base).length == 0) { return _tokenURI; } if (bytes(_tokenURI).length > 0) { return string(abi.encodePacked(base, _tokenURI)); }  return super.tokenURI(tokenId); }\r\nfunction _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual { require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\"); _tokenURIs[tokenId] = _tokenURI; }\r\nfunction _burn(uint256 tokenId) internal virtual override { super._burn(tokenId);  if (bytes(_tokenURIs[tokenId]).length != 0) { delete _tokenURIs[tokenId]; } } }\r\nabstract contract ERC721Burnable is Context, ERC721 { function burn(uint256 tokenId) public virtual { require(_isApprovedOrOwner(_msgSender(), tokenId), \"Burnable: you are neither the owner nor the proxy\"); _burn(tokenId); } }\r\nabstract contract Ownable is Context { address private _owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() { _setOwner(_msgSender()); }\r\nfunction owner() public view virtual returns (address) { return _owner; } modifier onlyOwner() { require(owner() == _msgSender(), \"Ownable: caller is not the owner\"); _; }\r\nfunction transferOwnership(address newOwner) public virtual onlyOwner { require(newOwner != address(0), \"Ownable: new owner is the zero address\"); _setOwner(newOwner); }\r\nfunction _setOwner(address newOwner) private { address oldOwner = _owner; _owner = newOwner; emit OwnershipTransferred(oldOwner, newOwner); } }\r\nabstract contract ContextMixin { function msgSender() internal view returns (address payable sender) { if (msg.sender == address(this)) { bytes memory array = msg.data; uint256 index = msg.data.length; assembly { sender := and( mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff ) } } else { sender = payable(msg.sender); } return sender; } }\r\ncontract Initializable { bool inited = false; modifier initializer() { require(!inited, \"already inited\"); _; inited = true; } }\r\ncontract EIP712Base is Initializable { struct EIP712Domain { string name; string version; address verifyingContract; bytes32 salt; } string constant public ERC712_VERSION = \"1\"; bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256( bytes( \"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\" ) ); bytes32 internal domainSeperator;\r\nfunction _initializeEIP712( string memory name ) internal initializer { _setDomainSeperator(name); }\r\nfunction _setDomainSeperator(string memory name) internal { domainSeperator = keccak256( abi.encode( EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes(ERC712_VERSION)), address(this), bytes32(getChainId()) ) ); }\r\nfunction getDomainSeperator() public view returns (bytes32) { return domainSeperator; } function getChainId() public view returns (uint256) { uint256 id; assembly { id := chainid() } return id; }\r\nfunction toTypedMessageHash(bytes32 messageHash) internal view returns (bytes32) { return keccak256( abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(), messageHash) ); } }\r\nlibrary SafeMath {function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { unchecked { uint256 c = a + b; if (c < a) return (false, 0); return (true, c); } }\r\nfunction trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { unchecked { if (b > a) return (false, 0); return (true, a - b); } }\r\nfunction tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { unchecked { if (a == 0) return (true, 0); uint256 c = a * b; if (c / a != b) return (false, 0); return (true, c); } }\r\nfunction tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { unchecked { if (b == 0) return (false, 0); return (true, a / b); } }\r\nfunction tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { unchecked { if (b == 0) return (false, 0); return (true, a % b); } }\r\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) { return a + b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { return a - b; } function mul(uint256 a, uint256 b) internal pure returns (uint256) { return a * b; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function mod(uint256 a, uint256 b) internal pure returns (uint256) { return a % b; }\r\nfunction sub( uint256 a, uint256 b, string memory errorMessage ) internal pure returns (uint256) { unchecked { require(b <= a, errorMessage); return a - b; } }\r\nfunction div( uint256 a, uint256 b, string memory errorMessage ) internal pure returns (uint256) { unchecked { require(b > 0, errorMessage); return a / b; } }\r\nfunction mod( uint256 a, uint256 b, string memory errorMessage ) internal pure returns (uint256) { unchecked { require(b > 0, errorMessage); return a % b; } } }\r\ncontract NativeMetaTransaction is EIP712Base { using SafeMath for uint256; bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256( bytes( \"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\" ) ); event MetaTransactionExecuted( address userAddress, address payable relayerAddress, bytes functionSignature ); mapping(address => uint256) nonces; struct MetaTransaction { uint256 nonce; address from; bytes functionSignature; }\r\nfunction executeMetaTransaction( address userAddress, bytes memory functionSignature, bytes32 sigR, bytes32 sigS, uint8 sigV ) public payable returns (bytes memory) { MetaTransaction memory metaTx = MetaTransaction({ nonce: nonces[userAddress], from: userAddress, functionSignature: functionSignature }); require( verify(userAddress, metaTx, sigR, sigS, sigV), \"Signer and signature do not match\" ); nonces[userAddress] = nonces[userAddress].add(1); emit MetaTransactionExecuted( userAddress, payable(msg.sender), functionSignature ); (bool success, bytes memory returnData) = address(this).call( abi.encodePacked(functionSignature, userAddress) ); require(success, \"Function call not successful\"); return returnData; }\r\nfunction hashMetaTransaction(MetaTransaction memory metaTx) internal pure returns (bytes32) { return keccak256( abi.encode( META_TRANSACTION_TYPEHASH, metaTx.nonce, metaTx.from, keccak256(metaTx.functionSignature) ) ); }\r\nfunction getNonce(address user) public view returns (uint256 nonce) { nonce = nonces[user]; }\r\nfunction verify( address signer, MetaTransaction memory metaTx, bytes32 sigR, bytes32 sigS, uint8 sigV ) internal view returns (bool) { require(signer != address(0), \"NativeMetaTransaction: INVALID_SIGNER\");  return signer == ecrecover( toTypedMessageHash(hashMetaTransaction(metaTx)), sigV, sigR, sigS ); } }\r\ncontract OwnableDelegateProxy {}\r\ncontract ProxyRegistry { mapping(address => OwnableDelegateProxy) public proxies; }\r\nabstract contract ERC721Tradable is ERC721, ContextMixin, ERC721Enumerable, NativeMetaTransaction, ERC721URIStorage, ERC721Burnable, Ownable { using Counters for Counters.Counter; address proxyRegistryAddress; event PermanentURI(string value, uint256 indexed id); constructor( string memory _name, string memory _symbol, address _proxyRegistryAddress ) ERC721(_name, _symbol) { proxyRegistryAddress = _proxyRegistryAddress; _initializeEIP712(_name); }\r\nfunction _setPermanentURI(uint256 id, string memory uri) internal { _setTokenURI(id, uri); emit PermanentURI(uri, id); }\r\nfunction _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Enumerable) { super._beforeTokenTransfer(from, to, tokenId); }\r\nfunction _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) { super._burn(tokenId); }\r\nfunction tokenURI(uint256 tokenId) public virtual view override(ERC721, ERC721URIStorage) returns (string memory) { return super.tokenURI(tokenId); }\r\nfunction supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) { return super.supportsInterface(interfaceId); }\r\nfunction isApprovedForAll(address owner, address operator) public view override returns (bool) { ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress); if (address(proxyRegistry.proxies(owner)) == operator) { return true; } return super.isApprovedForAll(owner, operator); }\r\nfunction _msgSender() internal view override returns (address sender) { return ContextMixin.msgSender(); }}\r\nabstract contract ReentrancyGuard { uint256 private constant _NOT_ENTERED = 1; uint256 private constant _ENTERED = 2; uint256 private _status; constructor() { _status = _NOT_ENTERED; } modifier nonReentrant() { require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\"); _status = _ENTERED; _; _status = _NOT_ENTERED; } }\r\ncontract ESEstore is ERC721 ,  Ownable , ReentrancyGuard{ using Counters for Counters.Counter; using SafeMath for uint256; using Address for address; using Strings for uint256; mapping (uint256 => string) private _tokenURIs; string private _baseURIextended; uint public MaxSupply = 5555; uint256 private  _mintCost; event PriceChanged(uint256 New_mintCost); event SetESEstore(address eseStore); uint256 public totalSupply; address public eseStore; address private _proxyRegistryAddress; bool private _isPublicMintEnabled;\r\nconstructor( string memory baseURI) ERC721(\"ESE Stories\", \"ESE_s\") { _baseURIextended = baseURI;  _isPublicMintEnabled = true; _mintCost = 2*10**16;}\r\nfunction ResetEseStore(address _eseStore) external onlyOwner { eseStore = _eseStore; emit SetESEstore(_eseStore); }function Mint_Allow() public onlyOwner{ _isPublicMintEnabled = true; }function Mint_Deny() public onlyOwner{ _isPublicMintEnabled = false; }function RMS(uint256 max) public onlyOwner{MaxSupply = max;}\r\nfunction Store_Gift(address to) public  nonReentrant { require(_isPublicMintEnabled, \"ESE:>>> Mint disabled\"); require(totalSupply < MaxSupply, \"ESE:>>> Exceeds max supply\"); require( eseStore == msg.sender || owner() == msg.sender, \"ESE:>>> caller is neither eseStore nor owner\" ); { totalSupply += 1; _safeMint(to, totalSupply);} }\r\nfunction Get_Dev() public onlyOwner { uint256 balance = address(this).balance; payable(msg.sender).transfer(balance); } function New_BaseURI(string memory baseURI_) external onlyOwner() {  _baseURIextended = baseURI_; }\r\nfunction _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual { require(_exists(tokenId), \"ESE:>>>  URI set of nonexistent token\"); _tokenURIs[tokenId] = _tokenURI; } function _baseURI() internal view virtual override returns (string memory) { return _baseURIextended; }\r\nfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) { require(_exists(tokenId), \"ESE: Query for nonexistent token\"); require(_isApprovedOrOwner(_msgSender(), tokenId) || owner() == msg.sender, \"ESE:>>>  caller is not owner nor approved\"); string memory _tokenURI = _tokenURIs[tokenId]; string memory base = _baseURI(); if (bytes(_tokenURI).length == 0) { return string(abi.encodePacked(base, tokenId.toString(), \".json\")); } if (bytes(_tokenURI).length > 0) { return _tokenURI; } return string(abi.encodePacked(base, tokenId.toString())); }\r\nfunction Reset_Nft_URI( uint256 _tokenId, string memory tokenURI_ ) external { require(_exists(_tokenId), \"ESE:>>>  Operation query for nonexistent token\"); require(_isApprovedOrOwner(_msgSender(), _tokenId) || owner() == msg.sender, \"ESE:>>>  caller is not owner nor approved\"); _setTokenURI(_tokenId, tokenURI_);}\r\nfunction GetPrice() public view returns (uint256){return _mintCost;}function getMintStatus() public view returns (bool) {return _isPublicMintEnabled;} function setTokenPrice(uint256 _ether) external onlyOwner {emit PriceChanged(_ether);  _mintCost = _ether; }\r\nfunction Bay_With_ESE_URI (address To_, uint256 Quantity_) public payable nonReentrant{require(_isPublicMintEnabled, \"ESE:>>>  Mint disabled\"); require(Quantity_ > 0, \"ESE:>>>  You can drop minimum 1 NFTs\"); require(owner() == msg.sender || msg.value >= _mintCost * Quantity_, \"ESE:>>>  ETH value sent is not correct, check >>> GetPrice <<<\"); require(totalSupply < MaxSupply, \"ESE:>>> Exceeds max supply\"); for(uint256 i; i<Quantity_; i++){ totalSupply += 1; _safeMint(To_, totalSupply); } } \r\nfunction Bay_With_Self_URI(address To_, uint256 Quantity_, string memory tokenURI_ ) public payable nonReentrant { require(_isPublicMintEnabled, \"ESE:>>>  Mint disabled\"); require(Quantity_ > 0, \"ESE:>>>  You can drop minimum 1 NFTs\"); require(owner() == msg.sender || msg.value >= _mintCost * Quantity_, \"ESE:>>>  ETH value sent is not correct, check >>> GetPrice <<<\"); require(totalSupply < MaxSupply, \"ESE:>>> Exceeds max supply\"); for(uint256 i; i<Quantity_; i++){ totalSupply += 1; _safeMint(To_, totalSupply); _setTokenURI(totalSupply, tokenURI_); } } }","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"New_mintCost\",\"type\":\"uint256\"}],\"name\":\"PriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"eseStore\",\"type\":\"address\"}],\"name\":\"SetESEstore\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"To_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Quantity_\",\"type\":\"uint256\"}],\"name\":\"Bay_With_ESE_URI\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"To_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Quantity_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tokenURI_\",\"type\":\"string\"}],\"name\":\"Bay_With_Self_URI\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Get_Dev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MaxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Mint_Allow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Mint_Deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"}],\"name\":\"New_BaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"RMS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_eseStore\",\"type\":\"address\"}],\"name\":\"ResetEseStore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tokenURI_\",\"type\":\"string\"}],\"name\":\"Reset_Nft_URI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Store_Gift\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eseStore\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ether\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ESEstore","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003668747470733a2f2f6573652d732d6e66742e73332e65752d776573742d322e616d617a6f6e6177732e636f6d2f6d657461646174612f00000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://604db16f84d32267d0ec8a44a741a0964b329a5a8a50bc68cb06b6e2956f74f2"}]}