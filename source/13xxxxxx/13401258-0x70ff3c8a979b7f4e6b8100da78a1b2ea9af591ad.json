{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.6.5 https://hardhat.org\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.2/contracts/utils/types/AddressIsContract.sol@v1.1.2\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// Partially derived from OpenZeppelin:\r\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/406c83649bd6169fc1b578e08506d78f0873b276/contracts/utils/Address.sol\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @dev Upgrades the address type to check if it is a contract.\r\n */\r\nlibrary AddressIsContract {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.2/contracts/utils/ERC20Wrapper.sol@v1.1.2\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC20Wrapper\r\n * Wraps ERC20 functions to support non-standard implementations which do not return a bool value.\r\n * Calls to the wrapped functions revert only if they throw or if they return false.\r\n */\r\nlibrary ERC20Wrapper {\r\n    using AddressIsContract for address;\r\n\r\n    function wrappedTransfer(\r\n        IWrappedERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function wrappedTransferFrom(\r\n        IWrappedERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function wrappedApprove(\r\n        IWrappedERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function _callWithOptionalReturnData(IWrappedERC20 token, bytes memory callData) internal {\r\n        address target = address(token);\r\n        require(target.isContract(), \"ERC20Wrapper: non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = target.call(callData);\r\n        if (success) {\r\n            if (data.length != 0) {\r\n                require(abi.decode(data, (bool)), \"ERC20Wrapper: operation failed\");\r\n            }\r\n        } else {\r\n            // revert using a standard revert message\r\n            if (data.length == 0) {\r\n                revert(\"ERC20Wrapper: operation failed\");\r\n            }\r\n\r\n            // revert using the revert message coming from the call\r\n            assembly {\r\n                let size := mload(data)\r\n                revert(add(32, data), size)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IWrappedERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.2/contracts/algo/EnumMap.sol@v1.1.2\r\n\r\n// Derived from OpenZeppelin:\r\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/406c83649bd6169fc1b578e08506d78f0873b276/contracts/utils/structs/EnumerableMap.sol\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @dev Library for managing an enumerable variant of Solidity's\r\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\r\n * type.\r\n *\r\n * Maps have the following properties:\r\n *\r\n * - Entries are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumMap for EnumMap.Map;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumMap.Map private myMap;\r\n * }\r\n * ```\r\n */\r\nlibrary EnumMap {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Map type with\r\n    // bytes32 keys and values.\r\n    // This means that we can only create new EnumMaps for types that fit\r\n    // in bytes32.\r\n\r\n    struct MapEntry {\r\n        bytes32 key;\r\n        bytes32 value;\r\n    }\r\n\r\n    struct Map {\r\n        // Storage of map keys and values\r\n        MapEntry[] entries;\r\n        // Position of the entry defined by a key in the `entries` array, plus 1\r\n        // because index 0 means a key is not in the map.\r\n        mapping(bytes32 => uint256) indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n    function set(\r\n        Map storage map,\r\n        bytes32 key,\r\n        bytes32 value\r\n    ) internal returns (bool) {\r\n        // We read and store the key's index to prevent multiple reads from the same storage slot\r\n        uint256 keyIndex = map.indexes[key];\r\n\r\n        if (keyIndex == 0) {\r\n            // Equivalent to !contains(map, key)\r\n            map.entries.push(MapEntry({key: key, value: value}));\r\n            // The entry is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            map.indexes[key] = map.entries.length;\r\n            return true;\r\n        } else {\r\n            map.entries[keyIndex - 1].value = value;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a key-value pair from a map. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n    function remove(Map storage map, bytes32 key) internal returns (bool) {\r\n        // We read and store the key's index to prevent multiple reads from the same storage slot\r\n        uint256 keyIndex = map.indexes[key];\r\n\r\n        if (keyIndex != 0) {\r\n            // Equivalent to contains(map, key)\r\n            // To delete a key-value pair from the entries array in O(1), we swap the entry to delete with the last one\r\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = keyIndex - 1;\r\n            uint256 lastIndex = map.entries.length - 1;\r\n\r\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            MapEntry storage lastEntry = map.entries[lastIndex];\r\n\r\n            // Move the last entry to the index where the entry to delete is\r\n            map.entries[toDeleteIndex] = lastEntry;\r\n            // Update the index for the moved entry\r\n            map.indexes[lastEntry.key] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved entry was stored\r\n            map.entries.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete map.indexes[key];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n    function contains(Map storage map, bytes32 key) internal view returns (bool) {\r\n        return map.indexes[key] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of key-value pairs in the map. O(1).\r\n     */\r\n    function length(Map storage map) internal view returns (uint256) {\r\n        return map.entries.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of entries inside the\r\n     * array, and it may change when more entries are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\r\n        require(map.entries.length > index, \"EnumMap: index out of bounds\");\r\n\r\n        MapEntry storage entry = map.entries[index];\r\n        return (entry.key, entry.value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value associated with `key`.  O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n    function get(Map storage map, bytes32 key) internal view returns (bytes32) {\r\n        uint256 keyIndex = map.indexes[key];\r\n        require(keyIndex != 0, \"EnumMap: nonexistent key\"); // Equivalent to contains(map, key)\r\n        return map.entries[keyIndex - 1].value; // All indexes are 1-based\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.2/contracts/algo/EnumSet.sol@v1.1.2\r\n\r\n// Derived from OpenZeppelin:\r\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/406c83649bd6169fc1b578e08506d78f0873b276/contracts/utils/structs/EnumerableSet.sol\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumSet for EnumSet.Set;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumSet.Set private mySet;\r\n * }\r\n * ```\r\n */\r\nlibrary EnumSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Set storage set, bytes32 value) internal returns (bool) {\r\n        if (!contains(set, value)) {\r\n            set.values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set.indexes[value] = set.values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Set storage set, bytes32 value) internal returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set.indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set.values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            bytes32 lastvalue = set.values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set.values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set.indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set.values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set.indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Set storage set, bytes32 value) internal view returns (bool) {\r\n        return set.indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(Set storage set) internal view returns (uint256) {\r\n        return set.values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Set storage set, uint256 index) internal view returns (bytes32) {\r\n        require(set.values.length > index, \"EnumSet: index out of bounds\");\r\n        return set.values[index];\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.2/contracts/metatx/ManagedIdentity.sol@v1.1.2\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/*\r\n * Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner.\r\n */\r\nabstract contract ManagedIdentity {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.2/contracts/access/IERC173.sol@v1.1.2\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC-173 Contract Ownership Standard\r\n * Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\n */\r\ninterface IERC173 {\r\n    /**\r\n     * Event emited when ownership of a contract changes.\r\n     * @param previousOwner the previous owner.\r\n     * @param newOwner the new owner.\r\n     */\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * Get the address of the owner\r\n     * @return The address of the owner.\r\n     */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n     * Set the address of the new owner of the contract\r\n     * Set newOwner to address(0) to renounce any ownership.\r\n     * @dev Emits an {OwnershipTransferred} event.\r\n     * @param newOwner The address of the new owner of the contract. Using the zero address means renouncing ownership.\r\n     */\r\n    function transferOwnership(address newOwner) external;\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.2/contracts/access/Ownable.sol@v1.1.2\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is ManagedIdentity, IERC173 {\r\n    address internal _owner;\r\n\r\n    /**\r\n     * Initializes the contract, setting the deployer as the initial owner.\r\n     * @dev Emits an {IERC173-OwnershipTransferred(address,address)} event.\r\n     */\r\n    constructor(address owner_) {\r\n        _owner = owner_;\r\n        emit OwnershipTransferred(address(0), owner_);\r\n    }\r\n\r\n    /**\r\n     * Gets the address of the current contract owner.\r\n     */\r\n    function owner() public view virtual override returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * See {IERC173-transferOwnership(address)}\r\n     * @dev Reverts if the sender is not the current contract owner.\r\n     * @param newOwner the address of the new owner. Use the zero address to renounce the ownership.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual override {\r\n        _requireOwnership(_msgSender());\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if `account` is not the contract owner.\r\n     * @param account the account to test.\r\n     */\r\n    function _requireOwnership(address account) internal virtual {\r\n        require(account == this.owner(), \"Ownable: not the owner\");\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.2/contracts/payment/PayoutWallet.sol@v1.1.2\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n/**\r\n    @title PayoutWallet\r\n    @dev adds support for a payout wallet\r\n    Note: .\r\n */\r\nabstract contract PayoutWallet is ManagedIdentity, Ownable {\r\n    event PayoutWalletSet(address payoutWallet_);\r\n\r\n    address payable public payoutWallet;\r\n\r\n    constructor(address owner, address payable payoutWallet_) Ownable(owner) {\r\n        require(payoutWallet_ != address(0), \"Payout: zero address\");\r\n        payoutWallet = payoutWallet_;\r\n        emit PayoutWalletSet(payoutWallet_);\r\n    }\r\n\r\n    function setPayoutWallet(address payable payoutWallet_) public {\r\n        _requireOwnership(_msgSender());\r\n        require(payoutWallet_ != address(0), \"Payout: zero address\");\r\n        payoutWallet = payoutWallet_;\r\n        emit PayoutWalletSet(payoutWallet);\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.2/contracts/lifecycle/Startable.sol@v1.1.2\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * Contract module which allows derived contracts to implement a mechanism for\r\n * activating, or 'starting', a contract.\r\n *\r\n * This module is used through inheritance. It will make available the modifiers\r\n * `whenNotStarted` and `whenStarted`, which can be applied to the functions of\r\n * your contract. Those functions will only be 'startable' once the modifiers\r\n * are put in place.\r\n */\r\nabstract contract Startable is ManagedIdentity {\r\n    event Started(address account);\r\n\r\n    uint256 private _startedAt;\r\n\r\n    /**\r\n     * Modifier to make a function callable only when the contract has not started.\r\n     */\r\n    modifier whenNotStarted() {\r\n        require(_startedAt == 0, \"Startable: started\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Modifier to make a function callable only when the contract has started.\r\n     */\r\n    modifier whenStarted() {\r\n        require(_startedAt != 0, \"Startable: not started\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * Returns the timestamp when the contract entered the started state.\r\n     * @return The timestamp when the contract entered the started state.\r\n     */\r\n    function startedAt() public view returns (uint256) {\r\n        return _startedAt;\r\n    }\r\n\r\n    /**\r\n     * Triggers the started state.\r\n     * @dev Emits the Started event when the function is successfully called.\r\n     */\r\n    function _start() internal virtual whenNotStarted {\r\n        _startedAt = block.timestamp;\r\n        emit Started(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.2/contracts/lifecycle/Pausable.sol@v1.1.2\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @dev Contract which allows children to implement pausability.\r\n */\r\nabstract contract Pausable is ManagedIdentity {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool public paused;\r\n\r\n    constructor(bool paused_) {\r\n        paused = paused_;\r\n    }\r\n\r\n    function _requireNotPaused() internal view {\r\n        require(!paused, \"Pausable: paused\");\r\n    }\r\n\r\n    function _requirePaused() internal view {\r\n        require(paused, \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual {\r\n        _requireNotPaused();\r\n        paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual {\r\n        _requirePaused();\r\n        paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/math/SafeMath.sol@v3.4.0\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-sale-2.0.0/contracts/sale/interfaces/ISale.sol@v2.0.0\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ISale\r\n *\r\n * An interface for a contract which allows merchants to display products and customers to purchase them.\r\n *\r\n *  Products, designated as SKUs, are represented by bytes32 identifiers so that an identifier can carry an\r\n *  explicit name under the form of a fixed-length string. Each SKU can be priced via up to several payment\r\n *  tokens which can be ETH and/or ERC20(s). ETH token is represented by the magic value TOKEN_ETH, which means\r\n *  this value can be used as the 'token' argument of the purchase-related functions to indicate ETH payment.\r\n *\r\n *  The total available supply for a SKU is fixed at its creation. The magic value SUPPLY_UNLIMITED is used\r\n *  to represent a SKU with an infinite, never-decreasing supply. An optional purchase notifications receiver\r\n *  contract address can be set for a SKU at its creation: if the value is different from the zero address,\r\n *  the function `onPurchaseNotificationReceived` will be called on this address upon every purchase of the SKU.\r\n *\r\n *  This interface is designed to be consistent while managing a variety of implementation scenarios. It is\r\n *  also intended to be developer-friendly: all vital information is consistently deductible from the events\r\n *  (backend-oriented), as well as retrievable through calls to public functions (frontend-oriented).\r\n */\r\ninterface ISale {\r\n    /**\r\n     * Event emitted to notify about the magic values necessary for interfacing with this contract.\r\n     * @param names An array of names for the magic values used by the contract.\r\n     * @param values An array of values for the magic values used by the contract.\r\n     */\r\n    event MagicValues(bytes32[] names, bytes32[] values);\r\n\r\n    /**\r\n     * Event emitted to notify about the creation of a SKU.\r\n     * @param sku The identifier of the created SKU.\r\n     * @param totalSupply The initial total supply for sale.\r\n     * @param maxQuantityPerPurchase The maximum allowed quantity for a single purchase.\r\n     * @param notificationsReceiver If not the zero address, the address of a contract on which `onPurchaseNotificationReceived` will be called after\r\n     *  each purchase. If this is the zero address, the call is not enabled.\r\n     */\r\n    event SkuCreation(bytes32 sku, uint256 totalSupply, uint256 maxQuantityPerPurchase, address notificationsReceiver);\r\n\r\n    /**\r\n     * Event emitted to notify about a change in the pricing of a SKU.\r\n     * @dev `tokens` and `prices` arrays MUST have the same length.\r\n     * @param sku The identifier of the updated SKU.\r\n     * @param tokens An array of updated payment tokens. If empty, interpret as all payment tokens being disabled.\r\n     * @param prices An array of updated prices for each of the payment tokens.\r\n     *  Zero price values are used for payment tokens being disabled.\r\n     */\r\n    event SkuPricingUpdate(bytes32 indexed sku, address[] tokens, uint256[] prices);\r\n\r\n    /**\r\n     * Event emitted to notify about a purchase.\r\n     * @param purchaser The initiater and buyer of the purchase.\r\n     * @param recipient The recipient of the purchase.\r\n     * @param token The token used as the currency for the payment.\r\n     * @param sku The identifier of the purchased SKU.\r\n     * @param quantity The purchased quantity.\r\n     * @param userData Optional extra user input data.\r\n     * @param totalPrice The amount of `token` paid.\r\n     * @param extData Implementation-specific extra purchase data, such as\r\n     *  details about discounts applied, conversion rates, purchase receipts, etc.\r\n     */\r\n    event Purchase(\r\n        address indexed purchaser,\r\n        address recipient,\r\n        address indexed token,\r\n        bytes32 indexed sku,\r\n        uint256 quantity,\r\n        bytes userData,\r\n        uint256 totalPrice,\r\n        bytes extData\r\n    );\r\n\r\n    /**\r\n     * Returns the magic value used to represent the ETH payment token.\r\n     * @dev MUST NOT be the zero address.\r\n     * @return the magic value used to represent the ETH payment token.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function TOKEN_ETH() external pure returns (address);\r\n\r\n    /**\r\n     * Returns the magic value used to represent an infinite, never-decreasing SKU's supply.\r\n     * @dev MUST NOT be zero.\r\n     * @return the magic value used to represent an infinite, never-decreasing SKU's supply.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function SUPPLY_UNLIMITED() external pure returns (uint256);\r\n\r\n    /**\r\n     * Performs a purchase.\r\n     * @dev Reverts if `recipient` is the zero address.\r\n     * @dev Reverts if `token` is the address zero.\r\n     * @dev Reverts if `quantity` is zero.\r\n     * @dev Reverts if `quantity` is greater than the maximum purchase quantity.\r\n     * @dev Reverts if `quantity` is greater than the remaining supply.\r\n     * @dev Reverts if `sku` does not exist.\r\n     * @dev Reverts if `sku` exists but does not have a price set for `token`.\r\n     * @dev Emits the Purchase event.\r\n     * @param recipient The recipient of the purchase.\r\n     * @param token The token to use as the payment currency.\r\n     * @param sku The identifier of the SKU to purchase.\r\n     * @param quantity The quantity to purchase.\r\n     * @param userData Optional extra user input data.\r\n     */\r\n    function purchaseFor(\r\n        address payable recipient,\r\n        address token,\r\n        bytes32 sku,\r\n        uint256 quantity,\r\n        bytes calldata userData\r\n    ) external payable;\r\n\r\n    /**\r\n     * Estimates the computed final total amount to pay for a purchase, including any potential discount.\r\n     * @dev This function MUST compute the same price as `purchaseFor` would in identical conditions (same arguments, same point in time).\r\n     * @dev If an implementer contract uses the `pricingData` field, it SHOULD document how to interpret the values.\r\n     * @dev Reverts if `recipient` is the zero address.\r\n     * @dev Reverts if `token` is the zero address.\r\n     * @dev Reverts if `quantity` is zero.\r\n     * @dev Reverts if `quantity` is greater than the maximum purchase quantity.\r\n     * @dev Reverts if `quantity` is greater than the remaining supply.\r\n     * @dev Reverts if `sku` does not exist.\r\n     * @dev Reverts if `sku` exists but does not have a price set for `token`.\r\n     * @param recipient The recipient of the purchase used to calculate the total price amount.\r\n     * @param token The payment token used to calculate the total price amount.\r\n     * @param sku The identifier of the SKU used to calculate the total price amount.\r\n     * @param quantity The quantity used to calculate the total price amount.\r\n     * @param userData Optional extra user input data.\r\n     * @return totalPrice The computed total price to pay.\r\n     * @return pricingData Implementation-specific extra pricing data, such as details about discounts applied.\r\n     *  If not empty, the implementer MUST document how to interepret the values.\r\n     */\r\n    function estimatePurchase(\r\n        address payable recipient,\r\n        address token,\r\n        bytes32 sku,\r\n        uint256 quantity,\r\n        bytes calldata userData\r\n    ) external view returns (uint256 totalPrice, bytes32[] memory pricingData);\r\n\r\n    /**\r\n     * Returns the information relative to a SKU.\r\n     * @dev WARNING: it is the responsibility of the implementer to ensure that the\r\n     *  number of payment tokens is bounded, so that this function does not run out of gas.\r\n     * @dev Reverts if `sku` does not exist.\r\n     * @param sku The SKU identifier.\r\n     * @return totalSupply The initial total supply for sale.\r\n     * @return remainingSupply The remaining supply for sale.\r\n     * @return maxQuantityPerPurchase The maximum allowed quantity for a single purchase.\r\n     * @return notificationsReceiver The address of a contract on which to call the `onPurchaseNotificationReceived` function.\r\n     * @return tokens The list of supported payment tokens.\r\n     * @return prices The list of associated prices for each of the `tokens`.\r\n     */\r\n    function getSkuInfo(bytes32 sku)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalSupply,\r\n            uint256 remainingSupply,\r\n            uint256 maxQuantityPerPurchase,\r\n            address notificationsReceiver,\r\n            address[] memory tokens,\r\n            uint256[] memory prices\r\n        );\r\n\r\n    /**\r\n     * Returns the list of created SKU identifiers.\r\n     * @dev WARNING: it is the responsibility of the implementer to ensure that the\r\n     *  number of SKUs is bounded, so that this function does not run out of gas.\r\n     * @return skus the list of created SKU identifiers.\r\n     */\r\n    function getSkus() external view returns (bytes32[] memory skus);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-sale-2.0.0/contracts/sale/interfaces/IPurchaseNotificationsReceiver.sol@v2.0.0\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title IPurchaseNotificationsReceiver\r\n * Interface for any contract that wants to support purchase notifications from a Sale contract.\r\n */\r\ninterface IPurchaseNotificationsReceiver {\r\n    /**\r\n     * Handles the receipt of a purchase notification.\r\n     * @dev This function MUST return the function selector, otherwise the caller will revert the transaction.\r\n     *  The selector to be returned can be obtained as `this.onPurchaseNotificationReceived.selector`\r\n     * @dev This function MAY throw.\r\n     * @param purchaser The purchaser of the purchase.\r\n     * @param recipient The recipient of the purchase.\r\n     * @param token The token to use as the payment currency.\r\n     * @param sku The identifier of the SKU to purchase.\r\n     * @param quantity The quantity to purchase.\r\n     * @param userData Optional extra user input data.\r\n     * @param totalPrice The total price paid.\r\n     * @param pricingData Implementation-specific extra pricing data, such as details about discounts applied.\r\n     * @param paymentData Implementation-specific extra payment data, such as conversion rates.\r\n     * @param deliveryData Implementation-specific extra delivery data, such as purchase receipts.\r\n     * @return `bytes4(keccak256(\r\n     *  \"onPurchaseNotificationReceived(address,address,address,bytes32,uint256,bytes,uint256,bytes32[],bytes32[],bytes32[])\"))`\r\n     */\r\n    function onPurchaseNotificationReceived(\r\n        address purchaser,\r\n        address recipient,\r\n        address token,\r\n        bytes32 sku,\r\n        uint256 quantity,\r\n        bytes calldata userData,\r\n        uint256 totalPrice,\r\n        bytes32[] calldata pricingData,\r\n        bytes32[] calldata paymentData,\r\n        bytes32[] calldata deliveryData\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-sale-2.0.0/contracts/sale/abstract/PurchaseLifeCycles.sol@v2.0.0\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title PurchaseLifeCycles\r\n * An abstract contract which define the life cycles for a purchase implementer.\r\n */\r\nabstract contract PurchaseLifeCycles {\r\n    /**\r\n     * Wrapper for the purchase data passed as argument to the life cycle functions and down to their step functions.\r\n     */\r\n    struct PurchaseData {\r\n        address payable purchaser;\r\n        address payable recipient;\r\n        address token;\r\n        bytes32 sku;\r\n        uint256 quantity;\r\n        bytes userData;\r\n        uint256 totalPrice;\r\n        bytes32[] pricingData;\r\n        bytes32[] paymentData;\r\n        bytes32[] deliveryData;\r\n    }\r\n\r\n    /*                               Internal Life Cycle Functions                               */\r\n\r\n    /**\r\n     * `estimatePurchase` lifecycle.\r\n     * @param purchase The purchase conditions.\r\n     */\r\n    function _estimatePurchase(PurchaseData memory purchase) internal view virtual returns (uint256 totalPrice, bytes32[] memory pricingData) {\r\n        _validation(purchase);\r\n        _pricing(purchase);\r\n\r\n        totalPrice = purchase.totalPrice;\r\n        pricingData = purchase.pricingData;\r\n    }\r\n\r\n    /**\r\n     * `purchaseFor` lifecycle.\r\n     * @param purchase The purchase conditions.\r\n     */\r\n    function _purchaseFor(PurchaseData memory purchase) internal virtual {\r\n        _validation(purchase);\r\n        _pricing(purchase);\r\n        _payment(purchase);\r\n        _delivery(purchase);\r\n        _notification(purchase);\r\n    }\r\n\r\n    /*                            Internal Life Cycle Step Functions                             */\r\n\r\n    /**\r\n     * Lifecycle step which validates the purchase pre-conditions.\r\n     * @dev Responsibilities:\r\n     *  - Ensure that the purchase pre-conditions are met and revert if not.\r\n     * @param purchase The purchase conditions.\r\n     */\r\n    function _validation(PurchaseData memory purchase) internal view virtual;\r\n\r\n    /**\r\n     * Lifecycle step which computes the purchase price.\r\n     * @dev Responsibilities:\r\n     *  - Computes the pricing formula, including any discount logic and price conversion;\r\n     *  - Set the value of `purchase.totalPrice`;\r\n     *  - Add any relevant extra data related to pricing in `purchase.pricingData` and document how to interpret it.\r\n     * @param purchase The purchase conditions.\r\n     */\r\n    function _pricing(PurchaseData memory purchase) internal view virtual;\r\n\r\n    /**\r\n     * Lifecycle step which manages the transfer of funds from the purchaser.\r\n     * @dev Responsibilities:\r\n     *  - Ensure the payment reaches destination in the expected output token;\r\n     *  - Handle any token swap logic;\r\n     *  - Add any relevant extra data related to payment in `purchase.paymentData` and document how to interpret it.\r\n     * @param purchase The purchase conditions.\r\n     */\r\n    function _payment(PurchaseData memory purchase) internal virtual;\r\n\r\n    /**\r\n     * Lifecycle step which delivers the purchased SKUs to the recipient.\r\n     * @dev Responsibilities:\r\n     *  - Ensure the product is delivered to the recipient, if that is the contract's responsibility.\r\n     *  - Handle any internal logic related to the delivery, including the remaining supply update;\r\n     *  - Add any relevant extra data related to delivery in `purchase.deliveryData` and document how to interpret it.\r\n     * @param purchase The purchase conditions.\r\n     */\r\n    function _delivery(PurchaseData memory purchase) internal virtual;\r\n\r\n    /**\r\n     * Lifecycle step which notifies of the purchase.\r\n     * @dev Responsibilities:\r\n     *  - Manage after-purchase event(s) emission.\r\n     *  - Handle calls to the notifications receiver contract's `onPurchaseNotificationReceived` function, if applicable.\r\n     * @param purchase The purchase conditions.\r\n     */\r\n    function _notification(PurchaseData memory purchase) internal virtual;\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-sale-2.0.0/contracts/sale/abstract/Sale.sol@v2.0.0\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Sale\r\n * An abstract base sale contract with a minimal implementation of ISale and administration functions.\r\n *  A minimal implementation of the `_validation`, `_delivery` and `notification` life cycle step functions\r\n *  are provided, but the inheriting contract must implement `_pricing` and `_payment`.\r\n */\r\nabstract contract Sale is PurchaseLifeCycles, ISale, PayoutWallet, Startable, Pausable {\r\n    using AddressIsContract for address;\r\n    using SafeMath for uint256;\r\n    using EnumSet for EnumSet.Set;\r\n    using EnumMap for EnumMap.Map;\r\n\r\n    struct SkuInfo {\r\n        uint256 totalSupply;\r\n        uint256 remainingSupply;\r\n        uint256 maxQuantityPerPurchase;\r\n        address notificationsReceiver;\r\n        EnumMap.Map prices;\r\n    }\r\n\r\n    address public constant override TOKEN_ETH = address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint256 public constant override SUPPLY_UNLIMITED = type(uint256).max;\r\n\r\n    EnumSet.Set internal _skus;\r\n    mapping(bytes32 => SkuInfo) internal _skuInfos;\r\n\r\n    uint256 internal immutable _skusCapacity;\r\n    uint256 internal immutable _tokensPerSkuCapacity;\r\n\r\n    /**\r\n     * Constructor.\r\n     * @dev Emits the `MagicValues` event.\r\n     * @dev Emits the `Paused` event.\r\n     * @param payoutWallet_ the payout wallet.\r\n     * @param skusCapacity the cap for the number of managed SKUs.\r\n     * @param tokensPerSkuCapacity the cap for the number of tokens managed per SKU.\r\n     */\r\n    constructor(\r\n        address payable payoutWallet_,\r\n        uint256 skusCapacity,\r\n        uint256 tokensPerSkuCapacity\r\n    ) PayoutWallet(msg.sender, payoutWallet_) Pausable(true) {\r\n        _skusCapacity = skusCapacity;\r\n        _tokensPerSkuCapacity = tokensPerSkuCapacity;\r\n        bytes32[] memory names = new bytes32[](2);\r\n        bytes32[] memory values = new bytes32[](2);\r\n        (names[0], values[0]) = (\"TOKEN_ETH\", bytes32(uint256(TOKEN_ETH)));\r\n        (names[1], values[1]) = (\"SUPPLY_UNLIMITED\", bytes32(uint256(SUPPLY_UNLIMITED)));\r\n        emit MagicValues(names, values);\r\n    }\r\n\r\n    /*                                   Public Admin Functions                                  */\r\n\r\n    /**\r\n     * Actvates, or 'starts', the contract.\r\n     * @dev Emits the `Started` event.\r\n     * @dev Emits the `Unpaused` event.\r\n     * @dev Reverts if called by any other than the contract owner.\r\n     * @dev Reverts if the contract has already been started.\r\n     * @dev Reverts if the contract is not paused.\r\n     */\r\n    function start() public virtual {\r\n        _requireOwnership(_msgSender());\r\n        _start();\r\n        _unpause();\r\n    }\r\n\r\n    /**\r\n     * Pauses the contract.\r\n     * @dev Emits the `Paused` event.\r\n     * @dev Reverts if called by any other than the contract owner.\r\n     * @dev Reverts if the contract has not been started yet.\r\n     * @dev Reverts if the contract is already paused.\r\n     */\r\n    function pause() public virtual whenStarted {\r\n        _requireOwnership(_msgSender());\r\n        _pause();\r\n    }\r\n\r\n    /**\r\n     * Resumes the contract.\r\n     * @dev Emits the `Unpaused` event.\r\n     * @dev Reverts if called by any other than the contract owner.\r\n     * @dev Reverts if the contract has not been started yet.\r\n     * @dev Reverts if the contract is not paused.\r\n     */\r\n    function unpause() public virtual whenStarted {\r\n        _requireOwnership(_msgSender());\r\n        _unpause();\r\n    }\r\n\r\n    /**\r\n     * Sets the token prices for the specified product SKU.\r\n     * @dev Reverts if called by any other than the contract owner.\r\n     * @dev Reverts if `tokens` and `prices` have different lengths.\r\n     * @dev Reverts if `sku` does not exist.\r\n     * @dev Reverts if one of the `tokens` is the zero address.\r\n     * @dev Reverts if the update results in too many tokens for the SKU.\r\n     * @dev Emits the `SkuPricingUpdate` event.\r\n     * @param sku The identifier of the SKU.\r\n     * @param tokens The list of payment tokens to update.\r\n     *  If empty, disable all the existing payment tokens.\r\n     * @param prices The list of prices to apply for each payment token.\r\n     *  Zero price values are used to disable a payment token.\r\n     */\r\n    function updateSkuPricing(\r\n        bytes32 sku,\r\n        address[] memory tokens,\r\n        uint256[] memory prices\r\n    ) public virtual {\r\n        _requireOwnership(_msgSender());\r\n        uint256 length = tokens.length;\r\n        require(length == prices.length, \"Sale: inconsistent arrays\");\r\n        SkuInfo storage skuInfo = _skuInfos[sku];\r\n        require(skuInfo.totalSupply != 0, \"Sale: non-existent sku\");\r\n\r\n        EnumMap.Map storage tokenPrices = skuInfo.prices;\r\n        if (length == 0) {\r\n            uint256 currentLength = tokenPrices.length();\r\n            for (uint256 i = 0; i < currentLength; ++i) {\r\n                // TODO add a clear function in EnumMap and EnumSet and use it\r\n                (bytes32 token, ) = tokenPrices.at(0);\r\n                tokenPrices.remove(token);\r\n            }\r\n        } else {\r\n            _setTokenPrices(tokenPrices, tokens, prices);\r\n        }\r\n\r\n        emit SkuPricingUpdate(sku, tokens, prices);\r\n    }\r\n\r\n    /*                                   ISale Public Functions                                  */\r\n\r\n    /**\r\n     * Performs a purchase.\r\n     * @dev Reverts if the sale has not started.\r\n     * @dev Reverts if the sale is paused.\r\n     * @dev Reverts if `recipient` is the zero address.\r\n     * @dev Reverts if `token` is the zero address.\r\n     * @dev Reverts if `quantity` is zero.\r\n     * @dev Reverts if `quantity` is greater than the maximum purchase quantity.\r\n     * @dev Reverts if `quantity` is greater than the remaining supply.\r\n     * @dev Reverts if `sku` does not exist.\r\n     * @dev Reverts if `sku` exists but does not have a price set for `token`.\r\n     * @dev Emits the Purchase event.\r\n     * @param recipient The recipient of the purchase.\r\n     * @param token The token to use as the payment currency.\r\n     * @param sku The identifier of the SKU to purchase.\r\n     * @param quantity The quantity to purchase.\r\n     * @param userData Optional extra user input data.\r\n     */\r\n    function purchaseFor(\r\n        address payable recipient,\r\n        address token,\r\n        bytes32 sku,\r\n        uint256 quantity,\r\n        bytes calldata userData\r\n    ) external payable virtual override whenStarted {\r\n        _requireNotPaused();\r\n        PurchaseData memory purchase;\r\n        purchase.purchaser = _msgSender();\r\n        purchase.recipient = recipient;\r\n        purchase.token = token;\r\n        purchase.sku = sku;\r\n        purchase.quantity = quantity;\r\n        purchase.userData = userData;\r\n\r\n        _purchaseFor(purchase);\r\n    }\r\n\r\n    /**\r\n     * Estimates the computed final total amount to pay for a purchase, including any potential discount.\r\n     * @dev This function MUST compute the same price as `purchaseFor` would in identical conditions (same arguments, same point in time).\r\n     * @dev If an implementer contract uses the `pricingData` field, it SHOULD document how to interpret the values.\r\n     * @dev Reverts if the sale has not started.\r\n     * @dev Reverts if the sale is paused.\r\n     * @dev Reverts if `recipient` is the zero address.\r\n     * @dev Reverts if `token` is the zero address.\r\n     * @dev Reverts if `quantity` is zero.\r\n     * @dev Reverts if `quantity` is greater than the maximum purchase quantity.\r\n     * @dev Reverts if `quantity` is greater than the remaining supply.\r\n     * @dev Reverts if `sku` does not exist.\r\n     * @dev Reverts if `sku` exists but does not have a price set for `token`.\r\n     * @param recipient The recipient of the purchase used to calculate the total price amount.\r\n     * @param token The payment token used to calculate the total price amount.\r\n     * @param sku The identifier of the SKU used to calculate the total price amount.\r\n     * @param quantity The quantity used to calculate the total price amount.\r\n     * @param userData Optional extra user input data.\r\n     * @return totalPrice The computed total price.\r\n     * @return pricingData Implementation-specific extra pricing data, such as details about discounts applied.\r\n     *  If not empty, the implementer MUST document how to interepret the values.\r\n     */\r\n    function estimatePurchase(\r\n        address payable recipient,\r\n        address token,\r\n        bytes32 sku,\r\n        uint256 quantity,\r\n        bytes calldata userData\r\n    ) external view virtual override whenStarted returns (uint256 totalPrice, bytes32[] memory pricingData) {\r\n        _requireNotPaused();\r\n        PurchaseData memory purchase;\r\n        purchase.purchaser = _msgSender();\r\n        purchase.recipient = recipient;\r\n        purchase.token = token;\r\n        purchase.sku = sku;\r\n        purchase.quantity = quantity;\r\n        purchase.userData = userData;\r\n\r\n        return _estimatePurchase(purchase);\r\n    }\r\n\r\n    /**\r\n     * Returns the information relative to a SKU.\r\n     * @dev WARNING: it is the responsibility of the implementer to ensure that the\r\n     * number of payment tokens is bounded, so that this function does not run out of gas.\r\n     * @dev Reverts if `sku` does not exist.\r\n     * @param sku The SKU identifier.\r\n     * @return totalSupply The initial total supply for sale.\r\n     * @return remainingSupply The remaining supply for sale.\r\n     * @return maxQuantityPerPurchase The maximum allowed quantity for a single purchase.\r\n     * @return notificationsReceiver The address of a contract on which to call the `onPurchaseNotificationReceived` function.\r\n     * @return tokens The list of supported payment tokens.\r\n     * @return prices The list of associated prices for each of the `tokens`.\r\n     */\r\n    function getSkuInfo(bytes32 sku)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            uint256 totalSupply,\r\n            uint256 remainingSupply,\r\n            uint256 maxQuantityPerPurchase,\r\n            address notificationsReceiver,\r\n            address[] memory tokens,\r\n            uint256[] memory prices\r\n        )\r\n    {\r\n        SkuInfo storage skuInfo = _skuInfos[sku];\r\n        uint256 length = skuInfo.prices.length();\r\n\r\n        totalSupply = skuInfo.totalSupply;\r\n        require(totalSupply != 0, \"Sale: non-existent sku\");\r\n        remainingSupply = skuInfo.remainingSupply;\r\n        maxQuantityPerPurchase = skuInfo.maxQuantityPerPurchase;\r\n        notificationsReceiver = skuInfo.notificationsReceiver;\r\n\r\n        tokens = new address[](length);\r\n        prices = new uint256[](length);\r\n        for (uint256 i = 0; i < length; ++i) {\r\n            (bytes32 token, bytes32 price) = skuInfo.prices.at(i);\r\n            tokens[i] = address(uint256(token));\r\n            prices[i] = uint256(price);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the list of created SKU identifiers.\r\n     * @return skus the list of created SKU identifiers.\r\n     */\r\n    function getSkus() external view override returns (bytes32[] memory skus) {\r\n        skus = _skus.values;\r\n    }\r\n\r\n    /*                               Internal Utility Functions                                  */\r\n\r\n    /**\r\n     * Creates an SKU.\r\n     * @dev Reverts if `totalSupply` is zero.\r\n     * @dev Reverts if `sku` already exists.\r\n     * @dev Reverts if `notificationsReceiver` is not the zero address and is not a contract address.\r\n     * @dev Reverts if the update results in too many SKUs.\r\n     * @dev Emits the `SkuCreation` event.\r\n     * @param sku the SKU identifier.\r\n     * @param totalSupply the initial total supply.\r\n     * @param maxQuantityPerPurchase The maximum allowed quantity for a single purchase.\r\n     * @param notificationsReceiver The purchase notifications receiver contract address.\r\n     *  If set to the zero address, the notification is not enabled.\r\n     */\r\n    function _createSku(\r\n        bytes32 sku,\r\n        uint256 totalSupply,\r\n        uint256 maxQuantityPerPurchase,\r\n        address notificationsReceiver\r\n    ) internal virtual {\r\n        require(totalSupply != 0, \"Sale: zero supply\");\r\n        require(_skus.length() < _skusCapacity, \"Sale: too many skus\");\r\n        require(_skus.add(sku), \"Sale: sku already created\");\r\n        if (notificationsReceiver != address(0)) {\r\n            require(notificationsReceiver.isContract(), \"Sale: non-contract receiver\");\r\n        }\r\n        SkuInfo storage skuInfo = _skuInfos[sku];\r\n        skuInfo.totalSupply = totalSupply;\r\n        skuInfo.remainingSupply = totalSupply;\r\n        skuInfo.maxQuantityPerPurchase = maxQuantityPerPurchase;\r\n        skuInfo.notificationsReceiver = notificationsReceiver;\r\n        emit SkuCreation(sku, totalSupply, maxQuantityPerPurchase, notificationsReceiver);\r\n    }\r\n\r\n    /**\r\n     * Updates SKU token prices.\r\n     * @dev Reverts if one of the `tokens` is the zero address.\r\n     * @dev Reverts if the update results in too many tokens for the SKU.\r\n     * @param tokenPrices Storage pointer to a mapping of SKU token prices to update.\r\n     * @param tokens The list of payment tokens to update.\r\n     * @param prices The list of prices to apply for each payment token.\r\n     *  Zero price values are used to disable a payment token.\r\n     */\r\n    function _setTokenPrices(\r\n        EnumMap.Map storage tokenPrices,\r\n        address[] memory tokens,\r\n        uint256[] memory prices\r\n    ) internal virtual {\r\n        for (uint256 i = 0; i < tokens.length; ++i) {\r\n            address token = tokens[i];\r\n            require(token != address(0), \"Sale: zero address token\");\r\n            uint256 price = prices[i];\r\n            if (price == 0) {\r\n                tokenPrices.remove(bytes32(uint256(token)));\r\n            } else {\r\n                tokenPrices.set(bytes32(uint256(token)), bytes32(price));\r\n            }\r\n        }\r\n        require(tokenPrices.length() <= _tokensPerSkuCapacity, \"Sale: too many tokens\");\r\n    }\r\n\r\n    /*                            Internal Life Cycle Step Functions                             */\r\n\r\n    /**\r\n     * Lifecycle step which validates the purchase pre-conditions.\r\n     * @dev Responsibilities:\r\n     *  - Ensure that the purchase pre-conditions are met and revert if not.\r\n     * @dev Reverts if `purchase.recipient` is the zero address.\r\n     * @dev Reverts if `purchase.token` is the zero address.\r\n     * @dev Reverts if `purchase.quantity` is zero.\r\n     * @dev Reverts if `purchase.quantity` is greater than the SKU's `maxQuantityPerPurchase`.\r\n     * @dev Reverts if `purchase.quantity` is greater than the available supply.\r\n     * @dev Reverts if `purchase.sku` does not exist.\r\n     * @dev Reverts if `purchase.sku` exists but does not have a price set for `purchase.token`.\r\n     * @dev If this function is overriden, the implementer SHOULD super call this before.\r\n     * @param purchase The purchase conditions.\r\n     */\r\n    function _validation(PurchaseData memory purchase) internal view virtual override {\r\n        require(purchase.recipient != address(0), \"Sale: zero address recipient\");\r\n        require(purchase.token != address(0), \"Sale: zero address token\");\r\n        require(purchase.quantity != 0, \"Sale: zero quantity purchase\");\r\n        SkuInfo storage skuInfo = _skuInfos[purchase.sku];\r\n        require(skuInfo.totalSupply != 0, \"Sale: non-existent sku\");\r\n        require(skuInfo.maxQuantityPerPurchase >= purchase.quantity, \"Sale: above max quantity\");\r\n        if (skuInfo.totalSupply != SUPPLY_UNLIMITED) {\r\n            require(skuInfo.remainingSupply >= purchase.quantity, \"Sale: insufficient supply\");\r\n        }\r\n        bytes32 priceKey = bytes32(uint256(purchase.token));\r\n        require(skuInfo.prices.contains(priceKey), \"Sale: non-existent sku token\");\r\n    }\r\n\r\n    /**\r\n     * Lifecycle step which delivers the purchased SKUs to the recipient.\r\n     * @dev Responsibilities:\r\n     *  - Ensure the product is delivered to the recipient, if that is the contract's responsibility.\r\n     *  - Handle any internal logic related to the delivery, including the remaining supply update;\r\n     *  - Add any relevant extra data related to delivery in `purchase.deliveryData` and document how to interpret it.\r\n     * @dev Reverts if there is not enough available supply.\r\n     * @dev If this function is overriden, the implementer SHOULD super call it.\r\n     * @param purchase The purchase conditions.\r\n     */\r\n    function _delivery(PurchaseData memory purchase) internal virtual override {\r\n        SkuInfo storage skuInfo = _skuInfos[purchase.sku];\r\n        if (skuInfo.totalSupply != SUPPLY_UNLIMITED) {\r\n            _skuInfos[purchase.sku].remainingSupply = skuInfo.remainingSupply.sub(purchase.quantity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Lifecycle step which notifies of the purchase.\r\n     * @dev Responsibilities:\r\n     *  - Manage after-purchase event(s) emission.\r\n     *  - Handle calls to the notifications receiver contract's `onPurchaseNotificationReceived` function, if applicable.\r\n     * @dev Reverts if `onPurchaseNotificationReceived` throws or returns an incorrect value.\r\n     * @dev Emits the `Purchase` event. The values of `purchaseData` are the concatenated values of `priceData`, `paymentData`\r\n     * and `deliveryData`. If not empty, the implementer MUST document how to interpret these values.\r\n     * @dev If this function is overriden, the implementer SHOULD super call it.\r\n     * @param purchase The purchase conditions.\r\n     */\r\n    function _notification(PurchaseData memory purchase) internal virtual override {\r\n        emit Purchase(\r\n            purchase.purchaser,\r\n            purchase.recipient,\r\n            purchase.token,\r\n            purchase.sku,\r\n            purchase.quantity,\r\n            purchase.userData,\r\n            purchase.totalPrice,\r\n            abi.encodePacked(purchase.pricingData, purchase.paymentData, purchase.deliveryData)\r\n        );\r\n\r\n        address notificationsReceiver = _skuInfos[purchase.sku].notificationsReceiver;\r\n        if (notificationsReceiver != address(0)) {\r\n            require(\r\n                IPurchaseNotificationsReceiver(notificationsReceiver).onPurchaseNotificationReceived(\r\n                    purchase.purchaser,\r\n                    purchase.recipient,\r\n                    purchase.token,\r\n                    purchase.sku,\r\n                    purchase.quantity,\r\n                    purchase.userData,\r\n                    purchase.totalPrice,\r\n                    purchase.pricingData,\r\n                    purchase.paymentData,\r\n                    purchase.deliveryData\r\n                ) == IPurchaseNotificationsReceiver(address(0)).onPurchaseNotificationReceived.selector, // TODO precompute return value\r\n                \"Sale: notification refused\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-sale-2.0.0/contracts/sale/FixedPricesSale.sol@v2.0.0\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n/**\r\n * @title FixedPricesSale\r\n * An Sale which implements a fixed prices strategy.\r\n *  The final implementer is responsible for implementing any additional pricing and/or delivery logic.\r\n */\r\nabstract contract FixedPricesSale is Sale {\r\n    using ERC20Wrapper for IWrappedERC20;\r\n    using SafeMath for uint256;\r\n    using EnumMap for EnumMap.Map;\r\n\r\n    /**\r\n     * Constructor.\r\n     * @dev Emits the `MagicValues` event.\r\n     * @dev Emits the `Paused` event.\r\n     * @param payoutWallet_ the payout wallet.\r\n     * @param skusCapacity the cap for the number of managed SKUs.\r\n     * @param tokensPerSkuCapacity the cap for the number of tokens managed per SKU.\r\n     */\r\n    constructor(\r\n        address payable payoutWallet_,\r\n        uint256 skusCapacity,\r\n        uint256 tokensPerSkuCapacity\r\n    ) Sale(payoutWallet_, skusCapacity, tokensPerSkuCapacity) {}\r\n\r\n    /*                               Internal Life Cycle Functions                               */\r\n\r\n    /**\r\n     * Lifecycle step which computes the purchase price.\r\n     * @dev Responsibilities:\r\n     *  - Computes the pricing formula, including any discount logic and price conversion;\r\n     *  - Set the value of `purchase.totalPrice`;\r\n     *  - Add any relevant extra data related to pricing in `purchase.pricingData` and document how to interpret it.\r\n     * @dev Reverts if `purchase.sku` does not exist.\r\n     * @dev Reverts if `purchase.token` is not supported by the SKU.\r\n     * @dev Reverts in case of price overflow.\r\n     * @param purchase The purchase conditions.\r\n     */\r\n    function _pricing(PurchaseData memory purchase) internal view virtual override {\r\n        SkuInfo storage skuInfo = _skuInfos[purchase.sku];\r\n        require(skuInfo.totalSupply != 0, \"Sale: unsupported SKU\");\r\n        EnumMap.Map storage prices = skuInfo.prices;\r\n        uint256 unitPrice = _unitPrice(purchase, prices);\r\n        purchase.totalPrice = unitPrice.mul(purchase.quantity);\r\n    }\r\n\r\n    /**\r\n     * Lifecycle step which manages the transfer of funds from the purchaser.\r\n     * @dev Responsibilities:\r\n     *  - Ensure the payment reaches destination in the expected output token;\r\n     *  - Handle any token swap logic;\r\n     *  - Add any relevant extra data related to payment in `purchase.paymentData` and document how to interpret it.\r\n     * @dev Reverts in case of payment failure.\r\n     * @param purchase The purchase conditions.\r\n     */\r\n    function _payment(PurchaseData memory purchase) internal virtual override {\r\n        if (purchase.token == TOKEN_ETH) {\r\n            require(msg.value >= purchase.totalPrice, \"Sale: insufficient ETH\");\r\n\r\n            payoutWallet.transfer(purchase.totalPrice);\r\n\r\n            uint256 change = msg.value.sub(purchase.totalPrice);\r\n\r\n            if (change != 0) {\r\n                purchase.purchaser.transfer(change);\r\n            }\r\n        } else {\r\n            IWrappedERC20(purchase.token).wrappedTransferFrom(_msgSender(), payoutWallet, purchase.totalPrice);\r\n        }\r\n    }\r\n\r\n    /*                               Internal Utility Functions                                  */\r\n\r\n    /**\r\n     * Retrieves the unit price of a SKU for the specified payment token.\r\n     * @dev Reverts if the specified payment token is unsupported.\r\n     * @param purchase The purchase conditions specifying the payment token with which the unit price will be retrieved.\r\n     * @param prices Storage pointer to a mapping of SKU token prices to retrieve the unit price from.\r\n     * @return unitPrice The unit price of a SKU for the specified payment token.\r\n     */\r\n    function _unitPrice(PurchaseData memory purchase, EnumMap.Map storage prices) internal view virtual returns (uint256 unitPrice) {\r\n        unitPrice = uint256(prices.get(bytes32(uint256(purchase.token))));\r\n        require(unitPrice != 0, \"Sale: unsupported payment token\");\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.2/contracts/utils/Recoverable.sol@v1.1.2\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n\r\nabstract contract Recoverable is ManagedIdentity, Ownable {\r\n    using ERC20Wrapper for IWrappedERC20;\r\n\r\n    /**\r\n     * Extract ERC20 tokens which were accidentally sent to the contract to a list of accounts.\r\n     * Warning: this function should be overriden for contracts which are supposed to hold ERC20 tokens\r\n     * so that the extraction is limited to only amounts sent accidentally.\r\n     * @dev Reverts if the sender is not the contract owner.\r\n     * @dev Reverts if `accounts`, `tokens` and `amounts` do not have the same length.\r\n     * @dev Reverts if one of `tokens` is does not implement the ERC20 transfer function.\r\n     * @dev Reverts if one of the ERC20 transfers fail for any reason.\r\n     * @param accounts the list of accounts to transfer the tokens to.\r\n     * @param tokens the list of ERC20 token addresses.\r\n     * @param amounts the list of token amounts to transfer.\r\n     */\r\n    function recoverERC20s(\r\n        address[] calldata accounts,\r\n        address[] calldata tokens,\r\n        uint256[] calldata amounts\r\n    ) external virtual {\r\n        _requireOwnership(_msgSender());\r\n        uint256 length = accounts.length;\r\n        require(length == tokens.length && length == amounts.length, \"Recov: inconsistent arrays\");\r\n        for (uint256 i = 0; i != length; ++i) {\r\n            IWrappedERC20(tokens[i]).wrappedTransfer(accounts[i], amounts[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract ERC721 tokens which were accidentally sent to the contract to a list of accounts.\r\n     * Warning: this function should be overriden for contracts which are supposed to hold ERC721 tokens\r\n     * so that the extraction is limited to only tokens sent accidentally.\r\n     * @dev Reverts if the sender is not the contract owner.\r\n     * @dev Reverts if `accounts`, `contracts` and `amounts` do not have the same length.\r\n     * @dev Reverts if one of `contracts` is does not implement the ERC721 transferFrom function.\r\n     * @dev Reverts if one of the ERC721 transfers fail for any reason.\r\n     * @param accounts the list of accounts to transfer the tokens to.\r\n     * @param contracts the list of ERC721 contract addresses.\r\n     * @param tokenIds the list of token ids to transfer.\r\n     */\r\n    function recoverERC721s(\r\n        address[] calldata accounts,\r\n        address[] calldata contracts,\r\n        uint256[] calldata tokenIds\r\n    ) external virtual {\r\n        _requireOwnership(_msgSender());\r\n        uint256 length = accounts.length;\r\n        require(length == contracts.length && length == tokenIds.length, \"Recov: inconsistent arrays\");\r\n        for (uint256 i = 0; i != length; ++i) {\r\n            IRecoverableERC721(contracts[i]).transferFrom(address(this), accounts[i], tokenIds[i]);\r\n        }\r\n    }\r\n}\r\n\r\ninterface IRecoverableERC721 {\r\n    /// See {IERC721-transferFrom(address,address,uint256)}\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n}\r\n\r\n\r\n// File contracts/sale/TokenLaunchpadVouchersSale.sol\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n/**\r\n * @title TokenLaunchpad Vouchers Sale\r\n * A FixedPricesSale contract that handles the purchase and delivery of TokenLaunchpad vouchers.\r\n */\r\ncontract TokenLaunchpadVouchersSale is FixedPricesSale, Recoverable {\r\n    IVouchersContract public immutable vouchersContract;\r\n\r\n    mapping(bytes32 => uint256) public skuTokenIds;\r\n\r\n    /**\r\n     * Constructor.\r\n     * @dev Emits the `MagicValues` event.\r\n     * @dev Emits the `Paused` event.\r\n     * @param vouchersContract_ The inventory contract from which the sale supply is attributed from.\r\n     * @param payoutWallet the payout wallet.\r\n     * @param skusCapacity the cap for the number of managed SKUs.\r\n     * @param tokensPerSkuCapacity the cap for the number of tokens managed per SKU.\r\n     */\r\n    constructor(\r\n        IVouchersContract vouchersContract_,\r\n        address payable payoutWallet,\r\n        uint256 skusCapacity,\r\n        uint256 tokensPerSkuCapacity\r\n    ) FixedPricesSale(payoutWallet, skusCapacity, tokensPerSkuCapacity) {\r\n        vouchersContract = vouchersContract_;\r\n    }\r\n\r\n    /**\r\n     * Creates an SKU.\r\n     * @dev Reverts if `totalSupply` is zero.\r\n     * @dev Reverts if `sku` already exists.\r\n     * @dev Reverts if `notificationsReceiver` is not the zero address and is not a contract address.\r\n     * @dev Reverts if the update results in too many SKUs.\r\n     * @dev Reverts if `tokenId` is zero.\r\n     * @dev Emits the `SkuCreation` event.\r\n     * @param sku The SKU identifier.\r\n     * @param totalSupply The initial total supply.\r\n     * @param maxQuantityPerPurchase The maximum allowed quantity for a single purchase.\r\n     * param notificationsReceiver The purchase notifications receiver contract address.\r\n     *  If set to the zero address, the notification is not enabled.\r\n     * @param tokenId The inventory contract token ID to associate with the SKU, used for purchase\r\n     *  delivery.\r\n     */\r\n    function createSku(\r\n        bytes32 sku,\r\n        uint256 totalSupply,\r\n        uint256 maxQuantityPerPurchase,\r\n        uint256 tokenId\r\n    ) external {\r\n        _requireOwnership(_msgSender());\r\n        require(vouchersContract.isFungible(tokenId), \"Sale: not a fungible token\");\r\n        skuTokenIds[sku] = tokenId;\r\n        _createSku(sku, totalSupply, maxQuantityPerPurchase, address(0));\r\n    }\r\n\r\n    /// @inheritdoc Sale\r\n    function _delivery(PurchaseData memory purchase) internal override {\r\n        super._delivery(purchase);\r\n        vouchersContract.safeMint(purchase.recipient, skuTokenIds[purchase.sku], purchase.quantity, \"\");\r\n    }\r\n}\r\n\r\ninterface IVouchersContract {\r\n    function isFungible(uint256 id) external pure returns (bool);\r\n\r\n    function safeMint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external;\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IVouchersContract\",\"name\":\"vouchersContract_\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"payoutWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"skusCapacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensPerSkuCapacity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"names\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"values\",\"type\":\"bytes32[]\"}],\"name\":\"MagicValues\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payoutWallet_\",\"type\":\"address\"}],\"name\":\"PayoutWalletSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"sku\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"extData\",\"type\":\"bytes\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sku\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxQuantityPerPurchase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"notificationsReceiver\",\"type\":\"address\"}],\"name\":\"SkuCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"sku\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"name\":\"SkuPricingUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Started\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SUPPLY_UNLIMITED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_ETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sku\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerPurchase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"createSku\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"sku\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"estimatePurchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"pricingData\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sku\",\"type\":\"bytes32\"}],\"name\":\"getSkuInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxQuantityPerPurchase\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"notificationsReceiver\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSkus\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"skus\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payoutWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"sku\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"purchaseFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"recoverERC20s\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"recoverERC721s\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"payoutWallet_\",\"type\":\"address\"}],\"name\":\"setPayoutWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"skuTokenIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sku\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"}],\"name\":\"updateSkuPricing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vouchersContract\",\"outputs\":[{\"internalType\":\"contract IVouchersContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TokenLaunchpadVouchersSale","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"00000000000000000000000087a3747c9942d8351cc85aac2f94807b27a37c0d00000000000000000000000039fa29ede121b06dce3674e97970caa539afc9570000000000000000000000000000000000000000000000000000000000000019000000000000000000000000000000000000000000000000000000000000000a","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4d8cb75b26991c2fd95de34bbfcb733e5c728a2668a653399596a37a352a4c85"}]}