{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/interfaces/IRandomnessProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IRandomnessProvider {\\n    function newRandomnessRequest() external returns (bytes32);\\n\\n    function updateFee(uint256) external;\\n\\n    function rescueLINK(address to, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/VRFLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '../interfaces/IRandomnessProvider.sol';\\n\\nlibrary VRFLibrary {\\n    struct VRFData {\\n        IRandomnessProvider randomnessProvider;\\n        bytes32 lastRequestId;\\n        mapping(uint256 => uint256) highestIdForRandomness;\\n        mapping(uint256 => uint256) randomResults;\\n        uint256 lastRequest;\\n        uint256 minResultIndex;\\n        uint256 resultsReceived;\\n    }\\n\\n    modifier onlyRandomnessProvider(VRFData storage self) {\\n        require(\\n            msg.sender == address(self.randomnessProvider),\\n            'Required to be randomnessProvider'\\n        );\\n        _;\\n    }\\n\\n    function processingStats(\\n        VRFData storage self,\\n        uint256 maxId,\\n        uint256 processedId,\\n        uint256 interval\\n    )\\n        public\\n        view\\n        returns (\\n            bool requestPending,\\n            uint256 maxIdAvailableToProcess,\\n            uint256 readyForProcessing,\\n            uint256 waitingToBeProcessed,\\n            uint256 timeTellNextRandomnessRequest\\n        )\\n    {\\n        timeTellNextRandomnessRequest = self.lastRequest + interval < block.timestamp\\n                ? 0\\n                : (self.lastRequest + interval) - block.timestamp;\\n\\n        return (\\n            self.lastRequestId != '' && timeTellNextRandomnessRequest > interval / 2,\\n            self.highestIdForRandomness[self.resultsReceived],\\n            self.highestIdForRandomness[self.resultsReceived] - processedId,\\n            maxId - self.highestIdForRandomness[self.resultsReceived],\\n            timeTellNextRandomnessRequest\\n        );\\n    }\\n\\n    function checkRandomness(\\n        VRFData storage self,\\n        uint256 maxId,\\n        uint256 processedId,\\n        uint256 interval,\\n        uint256 needed,\\n        uint256 minimum\\n    ) external {\\n        (\\n            bool requested,\\n            ,\\n            ,\\n            uint256 processingNeeded,\\n            uint256 timeTellNext\\n        ) = processingStats(self, maxId, processedId, interval);\\n\\n        if (\\n            !requested &&\\n            (processingNeeded >= needed ||\\n                (timeTellNext == 0 && processingNeeded > minimum))\\n        ) {\\n            newRequest(self);\\n        }\\n    }\\n\\n    function newRequest(VRFData storage self) public {\\n        bytes32 requestId = self.randomnessProvider.newRandomnessRequest();\\n\\n        if (requestId != '') {\\n            self.lastRequest = block.timestamp;\\n            self.lastRequestId = requestId;\\n        }\\n    }\\n\\n    function setRequestResults(\\n        VRFData storage self,\\n        bytes32 requestId,\\n        uint256 randomness,\\n        uint256 maxId\\n    ) public onlyRandomnessProvider(self) {\\n        if (self.lastRequestId == requestId) {\\n            self.resultsReceived++;\\n            self.randomResults[self.resultsReceived] = randomness;\\n            self.highestIdForRandomness[self.resultsReceived] = maxId;\\n            self.lastRequestId = '';\\n        }\\n    }\\n\\n    function randomnessForId(VRFData storage self, uint256 id)\\n        public\\n        returns (bool available, uint256 randomness)\\n    {\\n        while (\\n            self.highestIdForRandomness[self.minResultIndex] < id &&\\n            self.minResultIndex < self.resultsReceived\\n        ) {\\n            delete self.randomResults[self.minResultIndex];\\n            delete self.highestIdForRandomness[self.minResultIndex];\\n            self.minResultIndex++;\\n        }\\n\\n        if (self.highestIdForRandomness[self.minResultIndex] >= id) {\\n            return (true, self.randomResults[self.minResultIndex]);\\n        }\\n\\n        return (false, 0);\\n    }\\n\\n    function setRandomnessProvider(\\n        VRFData storage self,\\n        address randomnessProvider\\n    ) public {\\n        self.randomnessProvider = IRandomnessProvider(randomnessProvider);\\n    }\\n\\n    function updateFee(VRFData storage self, uint256 fee) public {\\n        self.randomnessProvider.updateFee(fee);\\n    }\\n\\n    function rescueLINK(\\n        VRFData storage self,\\n        address to,\\n        uint256 amount\\n    ) public {\\n        self.randomnessProvider.rescueLINK(to, amount);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[]","ContractName":"VRFLibrary","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}