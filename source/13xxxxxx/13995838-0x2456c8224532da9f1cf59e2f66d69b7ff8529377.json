{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.8.2 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\npragma abicoder v2;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20Upgradeable {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\r\n  /**\r\n   * @dev Returns the name of the token.\r\n   */\r\n  function name() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the symbol of the token.\r\n   */\r\n  function symbol() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the decimals places of the token.\r\n   */\r\n  function decimals() external view returns (uint8);\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary AddressUpgradeable {\r\n  /**\r\n   * @dev Returns true if `account` is a contract.\r\n   *\r\n   * [IMPORTANT]\r\n   * ====\r\n   * It is unsafe to assume that an address for which this function returns\r\n   * false is an externally-owned account (EOA) and not a contract.\r\n   *\r\n   * Among others, `isContract` will return false for the following\r\n   * types of addresses:\r\n   *\r\n   *  - an externally-owned account\r\n   *  - a contract in construction\r\n   *  - an address where a contract will be created\r\n   *  - an address where a contract lived, but was destroyed\r\n   * ====\r\n   */\r\n  function isContract(address account) internal view returns (bool) {\r\n    // This method relies on extcodesize, which returns 0 for contracts in\r\n    // construction, since the code is only stored at the end of the\r\n    // constructor execution.\r\n\r\n    uint256 size;\r\n    assembly {\r\n      size := extcodesize(account)\r\n    }\r\n    return size > 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n   * `recipient`, forwarding all available gas and reverting on errors.\r\n   *\r\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n   * imposed by `transfer`, making them unable to receive funds via\r\n   * `transfer`. {sendValue} removes this limitation.\r\n   *\r\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n   *\r\n   * IMPORTANT: because control is transferred to `recipient`, care must be\r\n   * taken to not create reentrancy vulnerabilities. Consider using\r\n   * {ReentrancyGuard} or the\r\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n   */\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, 'Address: insufficient balance');\r\n\r\n    (bool success, ) = recipient.call{ value: amount }('');\r\n    require(\r\n      success,\r\n      'Address: unable to send value, recipient may have reverted'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Performs a Solidity function call using a low level `call`. A\r\n   * plain `call` is an unsafe replacement for a function call: use this\r\n   * function instead.\r\n   *\r\n   * If `target` reverts with a revert reason, it is bubbled up by this\r\n   * function (like regular Solidity function calls).\r\n   *\r\n   * Returns the raw returned data. To convert to the expected return value,\r\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `target` must be a contract.\r\n   * - calling `target` with `data` must not revert.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCall(address target, bytes memory data)\r\n    internal\r\n    returns (bytes memory)\r\n  {\r\n    return functionCall(target, data, 'Address: low-level call failed');\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n   * `errorMessage` as a fallback revert reason when `target` reverts.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but also transferring `value` wei to `target`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - the calling contract must have an ETH balance of at least `value`.\r\n   * - the called Solidity function must be `payable`.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value\r\n  ) internal returns (bytes memory) {\r\n    return\r\n      functionCallWithValue(\r\n        target,\r\n        data,\r\n        value,\r\n        'Address: low-level call with value failed'\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n   *\r\n   * _Available since v3.1._\r\n   */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(\r\n      address(this).balance >= value,\r\n      'Address: insufficient balance for call'\r\n    );\r\n    require(isContract(target), 'Address: call to non-contract');\r\n\r\n    (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n    return verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n   * but performing a static call.\r\n   *\r\n   * _Available since v3.3._\r\n   */\r\n  function functionStaticCall(address target, bytes memory data)\r\n    internal\r\n    view\r\n    returns (bytes memory)\r\n  {\r\n    return\r\n      functionStaticCall(target, data, 'Address: low-level static call failed');\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n   * but performing a static call.\r\n   *\r\n   * _Available since v3.3._\r\n   */\r\n  function functionStaticCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes memory) {\r\n    require(isContract(target), 'Address: static call to non-contract');\r\n\r\n    (bool success, bytes memory returndata) = target.staticcall(data);\r\n    return verifyCallResult(success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n   * revert reason using the provided one.\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) internal pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      // Look for revert reason and bubble it up if present\r\n      if (returndata.length > 0) {\r\n        // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\r\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() initializer {}\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private _initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private _initializing;\r\n\r\n  /**\r\n   * @dev Modifier to protect an initializer function from being invoked twice.\r\n   */\r\n  modifier initializer() {\r\n    // If the contract is initializing we ignore whether _initialized is set in order to support multiple\r\n    // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\r\n    // contract may have been reentered.\r\n    require(\r\n      _initializing ? _isConstructor() : !_initialized,\r\n      'Initializable: contract is already initialized'\r\n    );\r\n\r\n    bool isTopLevelCall = !_initializing;\r\n    if (isTopLevelCall) {\r\n      _initializing = true;\r\n      _initialized = true;\r\n    }\r\n\r\n    _;\r\n\r\n    if (isTopLevelCall) {\r\n      _initializing = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n   * {initializer} modifier, directly or indirectly.\r\n   */\r\n  modifier onlyInitializing() {\r\n    require(_initializing, 'Initializable: contract is not initializing');\r\n    _;\r\n  }\r\n\r\n  function _isConstructor() private view returns (bool) {\r\n    return !AddressUpgradeable.isContract(address(this));\r\n  }\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract ContextUpgradeable is Initializable {\r\n  function __Context_init() internal onlyInitializing {\r\n    __Context_init_unchained();\r\n  }\r\n\r\n  function __Context_init_unchained() internal onlyInitializing {}\r\n\r\n  function _msgSender() internal view virtual returns (address) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view virtual returns (bytes calldata) {\r\n    return msg.data;\r\n  }\r\n\r\n  uint256[50] private __gap;\r\n}\r\n\r\n// File @openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20Upgradeable is\r\n  Initializable,\r\n  ContextUpgradeable,\r\n  IERC20Upgradeable,\r\n  IERC20MetadataUpgradeable\r\n{\r\n  mapping(address => uint256) private _balances;\r\n\r\n  mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n  uint256 private _totalSupply;\r\n\r\n  string private _name;\r\n  string private _symbol;\r\n\r\n  /**\r\n   * @dev Sets the values for {name} and {symbol}.\r\n   *\r\n   * The default value of {decimals} is 18. To select a different value for\r\n   * {decimals} you should overload it.\r\n   *\r\n   * All two of these values are immutable: they can only be set once during\r\n   * construction.\r\n   */\r\n  function __ERC20_init(string memory name_, string memory symbol_)\r\n    internal\r\n    onlyInitializing\r\n  {\r\n    __Context_init_unchained();\r\n    __ERC20_init_unchained(name_, symbol_);\r\n  }\r\n\r\n  function __ERC20_init_unchained(string memory name_, string memory symbol_)\r\n    internal\r\n    onlyInitializing\r\n  {\r\n    _name = name_;\r\n    _symbol = symbol_;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the name of the token.\r\n   */\r\n  function name() public view virtual override returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the symbol of the token, usually a shorter version of the\r\n   * name.\r\n   */\r\n  function symbol() public view virtual override returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of decimals used to get its user representation.\r\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n   *\r\n   * Tokens usually opt for a value of 18, imitating the relationship between\r\n   * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n   * overridden;\r\n   *\r\n   * NOTE: This information is only used for _display_ purposes: it in\r\n   * no way affects any of the arithmetic of the contract, including\r\n   * {IERC20-balanceOf} and {IERC20-transfer}.\r\n   */\r\n  function decimals() public view virtual override returns (uint8) {\r\n    return 18;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-totalSupply}.\r\n   */\r\n  function totalSupply() public view virtual override returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-balanceOf}.\r\n   */\r\n  function balanceOf(address account)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _balances[account];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-transfer}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `recipient` cannot be the zero address.\r\n   * - the caller must have a balance of at least `amount`.\r\n   */\r\n  function transfer(address recipient, uint256 amount)\r\n    public\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    _transfer(_msgSender(), recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-allowance}.\r\n   */\r\n  function allowance(address owner, address spender)\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-approve}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function approve(address spender, uint256 amount)\r\n    public\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    _approve(_msgSender(), spender, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev See {IERC20-transferFrom}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance. This is not\r\n   * required by the EIP. See the note at the beginning of {ERC20}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `sender` and `recipient` cannot be the zero address.\r\n   * - `sender` must have a balance of at least `amount`.\r\n   * - the caller must have allowance for ``sender``'s tokens of at least\r\n   * `amount`.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) public virtual override returns (bool) {\r\n    _transfer(sender, recipient, amount);\r\n\r\n    uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n    require(\r\n      currentAllowance >= amount,\r\n      'ERC20: transfer amount exceeds allowance'\r\n    );\r\n    unchecked {\r\n      _approve(sender, _msgSender(), currentAllowance - amount);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {IERC20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function increaseAllowance(address spender, uint256 addedValue)\r\n    public\r\n    virtual\r\n    returns (bool)\r\n  {\r\n    _approve(\r\n      _msgSender(),\r\n      spender,\r\n      _allowances[_msgSender()][spender] + addedValue\r\n    );\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {IERC20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   * - `spender` must have allowance for the caller of at least\r\n   * `subtractedValue`.\r\n   */\r\n  function decreaseAllowance(address spender, uint256 subtractedValue)\r\n    public\r\n    virtual\r\n    returns (bool)\r\n  {\r\n    uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n    require(\r\n      currentAllowance >= subtractedValue,\r\n      'ERC20: decreased allowance below zero'\r\n    );\r\n    unchecked {\r\n      _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n   *\r\n   * This internal function is equivalent to {transfer}, and can be used to\r\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `sender` cannot be the zero address.\r\n   * - `recipient` cannot be the zero address.\r\n   * - `sender` must have a balance of at least `amount`.\r\n   */\r\n  function _transfer(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(sender != address(0), 'ERC20: transfer from the zero address');\r\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\r\n\r\n    _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n    uint256 senderBalance = _balances[sender];\r\n    require(senderBalance >= amount, 'ERC20: transfer amount exceeds balance');\r\n    unchecked {\r\n      _balances[sender] = senderBalance - amount;\r\n    }\r\n    _balances[recipient] += amount;\r\n\r\n    emit Transfer(sender, recipient, amount);\r\n\r\n    _afterTokenTransfer(sender, recipient, amount);\r\n  }\r\n\r\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n   * the total supply.\r\n   *\r\n   * Emits a {Transfer} event with `from` set to the zero address.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `account` cannot be the zero address.\r\n   */\r\n  function _mint(address account, uint256 amount) internal virtual {\r\n    require(account != address(0), 'ERC20: mint to the zero address');\r\n\r\n    _beforeTokenTransfer(address(0), account, amount);\r\n\r\n    _totalSupply += amount;\r\n    _balances[account] += amount;\r\n    emit Transfer(address(0), account, amount);\r\n\r\n    _afterTokenTransfer(address(0), account, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys `amount` tokens from `account`, reducing the\r\n   * total supply.\r\n   *\r\n   * Emits a {Transfer} event with `to` set to the zero address.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `account` cannot be the zero address.\r\n   * - `account` must have at least `amount` tokens.\r\n   */\r\n  function _burn(address account, uint256 amount) internal virtual {\r\n    require(account != address(0), 'ERC20: burn from the zero address');\r\n\r\n    _beforeTokenTransfer(account, address(0), amount);\r\n\r\n    uint256 accountBalance = _balances[account];\r\n    require(accountBalance >= amount, 'ERC20: burn amount exceeds balance');\r\n    unchecked {\r\n      _balances[account] = accountBalance - amount;\r\n    }\r\n    _totalSupply -= amount;\r\n\r\n    emit Transfer(account, address(0), amount);\r\n\r\n    _afterTokenTransfer(account, address(0), amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n   *\r\n   * This internal function is equivalent to `approve`, and can be used to\r\n   * e.g. set automatic allowances for certain subsystems, etc.\r\n   *\r\n   * Emits an {Approval} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `owner` cannot be the zero address.\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function _approve(\r\n    address owner,\r\n    address spender,\r\n    uint256 amount\r\n  ) internal virtual {\r\n    require(owner != address(0), 'ERC20: approve from the zero address');\r\n    require(spender != address(0), 'ERC20: approve to the zero address');\r\n\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Hook that is called before any transfer of tokens. This includes\r\n   * minting and burning.\r\n   *\r\n   * Calling conditions:\r\n   *\r\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n   * will be transferred to `to`.\r\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n   * - `from` and `to` are never both zero.\r\n   *\r\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n   */\r\n  function _beforeTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual {}\r\n\r\n  /**\r\n   * @dev Hook that is called after any transfer of tokens. This includes\r\n   * minting and burning.\r\n   *\r\n   * Calling conditions:\r\n   *\r\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n   * has been transferred to `to`.\r\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n   * - `from` and `to` are never both zero.\r\n   *\r\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n   */\r\n  function _afterTokenTransfer(\r\n    address from,\r\n    address to,\r\n    uint256 amount\r\n  ) internal virtual {}\r\n\r\n  uint256[45] private __gap;\r\n}\r\n\r\n// File contracts/assets/Types.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/*\r\n * @author Eddy <eddy@alphaworks.xyz>\r\n * @dev ECDSA Signature wrapper struct\r\n */\r\nstruct Signature {\r\n  uint8 v;\r\n  bytes32 r;\r\n  bytes32 s;\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n  bytes16 private constant _HEX_SYMBOLS = '0123456789abcdef';\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n   */\r\n  function toString(uint256 value) internal pure returns (string memory) {\r\n    // Inspired by OraclizeAPI's implementation - MIT licence\r\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n    if (value == 0) {\r\n      return '0';\r\n    }\r\n    uint256 temp = value;\r\n    uint256 digits;\r\n    while (temp != 0) {\r\n      digits++;\r\n      temp /= 10;\r\n    }\r\n    bytes memory buffer = new bytes(digits);\r\n    while (value != 0) {\r\n      digits -= 1;\r\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n      value /= 10;\r\n    }\r\n    return string(buffer);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n   */\r\n  function toHexString(uint256 value) internal pure returns (string memory) {\r\n    if (value == 0) {\r\n      return '0x00';\r\n    }\r\n    uint256 temp = value;\r\n    uint256 length = 0;\r\n    while (temp != 0) {\r\n      length++;\r\n      temp >>= 8;\r\n    }\r\n    return toHexString(value, length);\r\n  }\r\n\r\n  /**\r\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n   */\r\n  function toHexString(uint256 value, uint256 length)\r\n    internal\r\n    pure\r\n    returns (string memory)\r\n  {\r\n    bytes memory buffer = new bytes(2 * length + 2);\r\n    buffer[0] = '0';\r\n    buffer[1] = 'x';\r\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n      buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n      value >>= 4;\r\n    }\r\n    require(value == 0, 'Strings: hex length insufficient');\r\n    return string(buffer);\r\n  }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/cryptography/ECDSA.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n  enum RecoverError {\r\n    NoError,\r\n    InvalidSignature,\r\n    InvalidSignatureLength,\r\n    InvalidSignatureS,\r\n    InvalidSignatureV\r\n  }\r\n\r\n  function _throwError(RecoverError error) private pure {\r\n    if (error == RecoverError.NoError) {\r\n      return; // no error: do nothing\r\n    } else if (error == RecoverError.InvalidSignature) {\r\n      revert('ECDSA: invalid signature');\r\n    } else if (error == RecoverError.InvalidSignatureLength) {\r\n      revert('ECDSA: invalid signature length');\r\n    } else if (error == RecoverError.InvalidSignatureS) {\r\n      revert(\"ECDSA: invalid signature 's' value\");\r\n    } else if (error == RecoverError.InvalidSignatureV) {\r\n      revert(\"ECDSA: invalid signature 'v' value\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address that signed a hashed message (`hash`) with\r\n   * `signature` or error string. This address can then be used for verification purposes.\r\n   *\r\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n   * this function rejects them by requiring the `s` value to be in the lower\r\n   * half order, and the `v` value to be either 27 or 28.\r\n   *\r\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n   * verification to be secure: it is possible to craft signatures that\r\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n   * this is by receiving a hash of the original message (which may otherwise\r\n   * be too long), and then calling {toEthSignedMessageHash} on it.\r\n   *\r\n   * Documentation for signature generation:\r\n   * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\r\n   * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function tryRecover(bytes32 hash, bytes memory signature)\r\n    internal\r\n    pure\r\n    returns (address, RecoverError)\r\n  {\r\n    // Check the signature length\r\n    // - case 65: r,s,v signature (standard)\r\n    // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\r\n    if (signature.length == 65) {\r\n      bytes32 r;\r\n      bytes32 s;\r\n      uint8 v;\r\n      // ecrecover takes the signature parameters, and the only way to get them\r\n      // currently is to use assembly.\r\n      assembly {\r\n        r := mload(add(signature, 0x20))\r\n        s := mload(add(signature, 0x40))\r\n        v := byte(0, mload(add(signature, 0x60)))\r\n      }\r\n      return tryRecover(hash, v, r, s);\r\n    } else if (signature.length == 64) {\r\n      bytes32 r;\r\n      bytes32 vs;\r\n      // ecrecover takes the signature parameters, and the only way to get them\r\n      // currently is to use assembly.\r\n      assembly {\r\n        r := mload(add(signature, 0x20))\r\n        vs := mload(add(signature, 0x40))\r\n      }\r\n      return tryRecover(hash, r, vs);\r\n    } else {\r\n      return (address(0), RecoverError.InvalidSignatureLength);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the address that signed a hashed message (`hash`) with\r\n   * `signature`. This address can then be used for verification purposes.\r\n   *\r\n   * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n   * this function rejects them by requiring the `s` value to be in the lower\r\n   * half order, and the `v` value to be either 27 or 28.\r\n   *\r\n   * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n   * verification to be secure: it is possible to craft signatures that\r\n   * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n   * this is by receiving a hash of the original message (which may otherwise\r\n   * be too long), and then calling {toEthSignedMessageHash} on it.\r\n   */\r\n  function recover(bytes32 hash, bytes memory signature)\r\n    internal\r\n    pure\r\n    returns (address)\r\n  {\r\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\r\n    _throwError(error);\r\n    return recovered;\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\r\n   *\r\n   * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function tryRecover(\r\n    bytes32 hash,\r\n    bytes32 r,\r\n    bytes32 vs\r\n  ) internal pure returns (address, RecoverError) {\r\n    bytes32 s;\r\n    uint8 v;\r\n    assembly {\r\n      s := and(\r\n        vs,\r\n        0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n      )\r\n      v := add(shr(255, vs), 27)\r\n    }\r\n    return tryRecover(hash, v, r, s);\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\r\n   *\r\n   * _Available since v4.2._\r\n   */\r\n  function recover(\r\n    bytes32 hash,\r\n    bytes32 r,\r\n    bytes32 vs\r\n  ) internal pure returns (address) {\r\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\r\n    _throwError(error);\r\n    return recovered;\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\r\n   * `r` and `s` signature fields separately.\r\n   *\r\n   * _Available since v4.3._\r\n   */\r\n  function tryRecover(\r\n    bytes32 hash,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal pure returns (address, RecoverError) {\r\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n    // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\r\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n    //\r\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n    // these malleable signatures as well.\r\n    if (\r\n      uint256(s) >\r\n      0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\r\n    ) {\r\n      return (address(0), RecoverError.InvalidSignatureS);\r\n    }\r\n    if (v != 27 && v != 28) {\r\n      return (address(0), RecoverError.InvalidSignatureV);\r\n    }\r\n\r\n    // If the signature is valid (and not malleable), return the signer address\r\n    address signer = ecrecover(hash, v, r, s);\r\n    if (signer == address(0)) {\r\n      return (address(0), RecoverError.InvalidSignature);\r\n    }\r\n\r\n    return (signer, RecoverError.NoError);\r\n  }\r\n\r\n  /**\r\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\r\n   * `r` and `s` signature fields separately.\r\n   */\r\n  function recover(\r\n    bytes32 hash,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal pure returns (address) {\r\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n    _throwError(error);\r\n    return recovered;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n   * produces hash corresponding to the one signed with the\r\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n   * JSON-RPC method as part of EIP-191.\r\n   *\r\n   * See {recover}.\r\n   */\r\n  function toEthSignedMessageHash(bytes32 hash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    // 32 is the length in bytes of hash,\r\n    // enforced by the type signature above\r\n    return\r\n      keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', hash));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an Ethereum Signed Message, created from `s`. This\r\n   * produces hash corresponding to the one signed with the\r\n   * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n   * JSON-RPC method as part of EIP-191.\r\n   *\r\n   * See {recover}.\r\n   */\r\n  function toEthSignedMessageHash(bytes memory s)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    return\r\n      keccak256(\r\n        abi.encodePacked(\r\n          '\\x19Ethereum Signed Message:\\n',\r\n          Strings.toString(s.length),\r\n          s\r\n        )\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an Ethereum Signed Typed Data, created from a\r\n   * `domainSeparator` and a `structHash`. This produces hash corresponding\r\n   * to the one signed with the\r\n   * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\r\n   * JSON-RPC method as part of EIP-712.\r\n   *\r\n   * See {recover}.\r\n   */\r\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    return keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\r\n  }\r\n}\r\n\r\n// File contracts/lib/EIP712.sol\r\n\r\n/**\r\n *\r\n * Copyright (c) 2020 CENTRE SECZ\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * @title EIP712\r\n * @notice A library that provides EIP712 helper functions\r\n */\r\nlibrary EIP712 {\r\n  // keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\r\n  bytes32 public constant EIP712_DOMAIN_TYPEHASH =\r\n    0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\r\n\r\n  /**\r\n   * @notice Make EIP712 domain separator\r\n   * @param name      Contract name\r\n   * @param version   Contract version\r\n   * @return Domain separator\r\n   */\r\n  function makeDomainSeparator(string memory name, string memory version)\r\n    internal\r\n    view\r\n    returns (bytes32)\r\n  {\r\n    return\r\n      keccak256(\r\n        abi.encode(\r\n          EIP712_DOMAIN_TYPEHASH,\r\n          keccak256(bytes(name)),\r\n          keccak256(bytes(version)),\r\n          bytes32(block.chainid),\r\n          address(this)\r\n        )\r\n      );\r\n  }\r\n\r\n  /**\r\n   * @notice Recover signer's address from a EIP712 signature\r\n   * @param domainSeparator   Domain separator\r\n   * @param v                 v of the signature\r\n   * @param r                 r of the signature\r\n   * @param s                 s of the signature\r\n   * @param typeHashAndData   Type hash concatenated with data\r\n   * @return Signer's address\r\n   */\r\n  function recover(\r\n    bytes32 domainSeparator,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s,\r\n    bytes memory typeHashAndData\r\n  ) internal pure returns (address) {\r\n    bytes32 digest = ECDSA.toTypedDataHash(\r\n      domainSeparator,\r\n      keccak256(typeHashAndData)\r\n    );\r\n    return ECDSA.recover(digest, v, r, s);\r\n  }\r\n}\r\n\r\nabstract contract EIP712Domain {\r\n  /**\r\n   * @dev EIP712 Domain Separator\r\n   */\r\n  bytes32 public DOMAIN_SEPARATOR;\r\n}\r\n\r\n// File contracts/assets/ERC20/ERC20Permit.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * @notice ERC20Permit interface that implementation of ERC2612 scheme on ERC20\r\n * @author Eddy <eddy@alphaworks.xyz>\r\n */\r\nabstract contract ERC20Permit is EIP712Domain {\r\n  // keccak256(\"Permit(address owner,address spender,uint256 amount,uint256 nonce,uint256 deadline)\")\r\n  bytes32 public constant PERMIT_TYPEHASH =\r\n    0xfc77c2b9d30fe91687fd39abb7d16fcdfe1472d065740051ab8b13e4bf4a617f;\r\n\r\n  mapping(address => uint256) internal _nonces;\r\n\r\n  /**\r\n   * @notice Nonces for permit\r\n   * @param _owner Token owner's address\r\n   * @return Next nonce\r\n   */\r\n  function nonces(address _owner) external view returns (uint256) {\r\n    return _nonces[_owner];\r\n  }\r\n\r\n  /**\r\n   * @notice update allowance with a signed permit\r\n   * @param _owner     Token owner's address (Authorizer)\r\n   * @param _spender   Spender's address\r\n   * @param _amount    Amount of allowance\r\n   * @param _deadline  The time at which this expires (unix time)\r\n   * @param _sig       Signature\r\n   */\r\n  function _permit(\r\n    address _owner,\r\n    address _spender,\r\n    uint256 _amount,\r\n    uint256 _deadline,\r\n    Signature memory _sig\r\n  ) internal virtual {\r\n    require(_deadline >= block.timestamp, 'ERC20Permit: expired');\r\n\r\n    bytes memory data = abi.encode(\r\n      PERMIT_TYPEHASH,\r\n      _owner,\r\n      _spender,\r\n      _amount,\r\n      _nonces[_owner]++,\r\n      _deadline\r\n    );\r\n    require(\r\n      EIP712.recover(DOMAIN_SEPARATOR, _sig.v, _sig.r, _sig.s, data) == _owner,\r\n      'EIP2612: invalid signature'\r\n    );\r\n\r\n    // _approve(_owner, _spender, _amount);\r\n  }\r\n}\r\n\r\n// File contracts/lib/EIP3009.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nabstract contract EIP3009 is EIP712Domain {\r\n  // keccak256(\"CancelAuthorization(address authorizer,bytes32 nonce)\")\r\n  bytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH =\r\n    0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\r\n\r\n  mapping(address => mapping(bytes32 => bool)) internal _authorizationStates;\r\n\r\n  event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\r\n  event AuthorizationCanceled(\r\n    address indexed authorizer,\r\n    bytes32 indexed nonce\r\n  );\r\n\r\n  string internal constant _INVALID_SIGNATURE_ERROR =\r\n    'EIP3009: invalid signature';\r\n  string internal constant _AUTHORIZATION_USED_ERROR =\r\n    'EIP3009: authorization is used';\r\n\r\n  /**\r\n   * @notice Returns the state of an authorization\r\n   * @dev Nonces are randomly generated 32-byte data unique to the authorizer's\r\n   * address\r\n   * @param authorizer    Authorizer's address\r\n   * @param nonce         Nonce of the authorization\r\n   * @return True if the nonce is used\r\n   */\r\n  function authorizationState(address authorizer, bytes32 nonce)\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _authorizationStates[authorizer][nonce];\r\n  }\r\n\r\n  /**\r\n   * @notice Attempt to cancel an authorization\r\n   * @param _authorizer    Authorizer's address\r\n   * @param _nonce         Nonce of the authorization\r\n   * @param _v             v of the signature\r\n   * @param _r             r of the signature\r\n   * @param _s             s of the signature\r\n   */\r\n  function _cancelAuthorization(\r\n    address _authorizer,\r\n    bytes32 _nonce,\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s\r\n  ) internal {\r\n    _spendAuthorization(\r\n      _authorizer,\r\n      abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, _authorizer, _nonce),\r\n      _nonce,\r\n      _v,\r\n      _r,\r\n      _s\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Spend authorization at specified nonce\r\n   * @param _from          Authorizer's address\r\n   * @param _payload       Payload to verify\r\n   * @param _nonce         Nonce of the authorization\r\n   * @param _v             v of the signature\r\n   * @param _r             r of the signature\r\n   * @param _s             s of the signature\r\n   */\r\n  function _spendAuthorization(\r\n    address _from,\r\n    bytes memory _payload,\r\n    bytes32 _nonce,\r\n    uint8 _v,\r\n    bytes32 _r,\r\n    bytes32 _s\r\n  ) internal {\r\n    require(!_authorizationStates[_from][_nonce], _AUTHORIZATION_USED_ERROR);\r\n\r\n    require(\r\n      EIP712.recover(DOMAIN_SEPARATOR, _v, _r, _s, _payload) == _from,\r\n      _INVALID_SIGNATURE_ERROR\r\n    );\r\n\r\n    _authorizationStates[_from][_nonce] = true;\r\n    emit AuthorizationUsed(_from, _nonce);\r\n  }\r\n}\r\n\r\n// File contracts/assets/ERC20/ERC20Spendable.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * @notice ERC20Spendable interface that extends ERC20 standard\r\n * @author Eddy <eddy@alphaworks.xyz>\r\n */\r\nabstract contract ERC20Spendable is EIP3009 {\r\n  // keccak256(\"TransferWithAuthorization(address from,address to,uint256 amount,bytes32 nonce,uint256 validAfter,uint256 validBefore)\");\r\n  bytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH =\r\n    0xa7bc2c08eada54d419b87dfce5103bb4d0fab70d36db67226c8a1bb80b69524b;\r\n  // keccak256(\"ReceiveWithAuthorization(address from,address to,uint256 amount,bytes32 nonce,uint256 validAfter,uint256 validBefore)\")\r\n  bytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH =\r\n    0x809662e72f8d3065d367f26b91f7ad18604329f65460d0132508901cece31a00;\r\n\r\n  /**\r\n   * @notice Execute a transfer with a signed authorization\r\n   * @param _from         Payer's address (Authorizer)\r\n   * @param _to           Payee's address\r\n   * @param _amount       Amount to be transferred\r\n   * @param _nonce        Unique nonce\r\n   * @param _validAfter   The time after which this is valid (unix time)\r\n   * @param _validBefore  The time before which this is valid (unix time)\r\n   * @param _sig          Signature\r\n   */\r\n  function _transferWithAuthorization(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    uint256 _validAfter,\r\n    uint256 _validBefore,\r\n    Signature memory _sig\r\n  ) internal virtual {\r\n    require(block.timestamp > _validAfter, 'ERC20Spendable: not yet valid');\r\n    require(block.timestamp < _validBefore, 'ERC20Spendable: expired');\r\n\r\n    _spendAuthorization(\r\n      _from,\r\n      abi.encode(\r\n        TRANSFER_WITH_AUTHORIZATION_TYPEHASH,\r\n        _from,\r\n        _to,\r\n        _amount,\r\n        _nonce,\r\n        _validAfter,\r\n        _validBefore\r\n      ),\r\n      _nonce,\r\n      _sig.v,\r\n      _sig.r,\r\n      _sig.s\r\n    );\r\n\r\n    // _transfer(_from, _to, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Receive a transfer with a signed authorization from the payer\r\n   * @dev This has an additional check to ensure that the payee's address matches\r\n   * the caller of this function to prevent front-running attacks. (See security\r\n   * considerations)\r\n   * @param _from         Payer's address (Authorizer)\r\n   * @param _to           Payee's address\r\n   * @param _amount       Amount to be transferred\r\n   * @param _nonce        Unique nonce\r\n   * @param _validAfter   The time after which this is valid (unix time)\r\n   * @param _validBefore  The time before which this is valid (unix time)\r\n   * @param _sig          Signature\r\n   */\r\n  function _receiveWithAuthorization(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    uint256 _validAfter,\r\n    uint256 _validBefore,\r\n    Signature memory _sig\r\n  ) internal virtual {\r\n    require(_to == msg.sender, 'ERC20Spendable: caller must be the payee');\r\n\r\n    require(block.timestamp > _validAfter, 'ERC20Spendable: not yet valid');\r\n    require(block.timestamp < _validBefore, 'ERC20Spendable: expired');\r\n\r\n    _spendAuthorization(\r\n      _from,\r\n      abi.encode(\r\n        RECEIVE_WITH_AUTHORIZATION_TYPEHASH,\r\n        _from,\r\n        _to,\r\n        _amount,\r\n        _nonce,\r\n        _validAfter,\r\n        _validBefore\r\n      ),\r\n      _nonce,\r\n      _sig.v,\r\n      _sig.r,\r\n      _sig.s\r\n    );\r\n\r\n    // _transfer(_from, _to, _amount);\r\n  }\r\n\r\n  function cancelAuthorization(\r\n    address _authorizer,\r\n    bytes32 _nonce,\r\n    Signature memory _sig\r\n  ) external {\r\n    _cancelAuthorization(_authorizer, _nonce, _sig.v, _sig.r, _sig.s);\r\n  }\r\n}\r\n\r\n// File contracts/assets/ERC20/SportiumERC20.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/**\r\n * @notice Sportium ERC20 contract\r\n * @author Eddy <eddy@alphaworks.xyz>\r\n */\r\ncontract SportiumERC20 is\r\n  Initializable,\r\n  ERC20Upgradeable, // proxy wrapper\r\n  ERC20Spendable, // EIP3009\r\n  ERC20Permit // EIP2612\r\n{\r\n  struct InitialSupplyPayload {\r\n    uint256 amount;\r\n    address to;\r\n  }\r\n\r\n  function initialize(\r\n    string memory _name,\r\n    string memory _symbol,\r\n    InitialSupplyPayload[] memory _payload\r\n  ) public initializer {\r\n    __ERC20_init(_name, _symbol);\r\n    DOMAIN_SEPARATOR = EIP712.makeDomainSeparator(_name, '1');\r\n    for (uint256 i = 0; i < _payload.length; i++) {\r\n      _mint(_payload[i].to, _payload[i].amount);\r\n    }\r\n  }\r\n\r\n  function transferWithAuthorization(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    uint256 _validAfter,\r\n    uint256 _validBefore,\r\n    Signature memory _sig\r\n  ) external virtual {\r\n    _transferWithAuthorization(\r\n      _from,\r\n      _to,\r\n      _amount,\r\n      _nonce,\r\n      _validAfter,\r\n      _validBefore,\r\n      _sig\r\n    );\r\n    _transfer(_from, _to, _amount);\r\n  }\r\n\r\n  function receiveWithAuthorization(\r\n    address _from,\r\n    address _to,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    uint256 _validAfter,\r\n    uint256 _validBefore,\r\n    Signature memory _sig\r\n  ) external virtual {\r\n    _receiveWithAuthorization(\r\n      _from,\r\n      _to,\r\n      _amount,\r\n      _nonce,\r\n      _validAfter,\r\n      _validBefore,\r\n      _sig\r\n    );\r\n    _transfer(_from, _to, _amount);\r\n  }\r\n\r\n  function permit(\r\n    address _owner,\r\n    address _spender,\r\n    uint256 _amount,\r\n    uint256 _deadline,\r\n    Signature memory _sig\r\n  ) external virtual {\r\n    _permit(_owner, _spender, _amount, _deadline, _sig);\r\n    _approve(_owner, _spender, _amount);\r\n  }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"AuthorizationCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"AuthorizationUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CANCEL_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RECEIVE_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"authorizationState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authorizer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_nonce\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Signature\",\"name\":\"_sig\",\"type\":\"tuple\"}],\"name\":\"cancelAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"internalType\":\"struct SportiumERC20.InitialSupplyPayload[]\",\"name\":\"_payload\",\"type\":\"tuple[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Signature\",\"name\":\"_sig\",\"type\":\"tuple\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_validBefore\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Signature\",\"name\":\"_sig\",\"type\":\"tuple\"}],\"name\":\"receiveWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_validBefore\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Signature\",\"name\":\"_sig\",\"type\":\"tuple\"}],\"name\":\"transferWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SportiumERC20","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://abf79a4e222b8457bdf3d11745833095b8c597ff10365a5756ea8565b5763811"}]}