{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"CoboSafeFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.7.6;\\n\\nimport \\\"Pausable.sol\\\";\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"CoboSafeModule.sol\\\";\\n\\ncontract CoboSafeFactory is TransferOwnable, Pausable {\\n    string public constant NAME = \\\"Cobo Safe Factory\\\";\\n    string public constant VERSION = \\\"0.2.2\\\";\\n\\n    address[] public modules;\\n    mapping(address => address) public safeToModule;\\n\\n    event NewModule(\\n        address indexed safe,\\n        address indexed module,\\n        address indexed sender\\n    );\\n\\n    function modulesSize() public view returns (uint256) {\\n        return modules.length;\\n    }\\n\\n    function createModule(address _safe)\\n        external\\n        whenNotPaused\\n        returns (address _module)\\n    {\\n        require(safeToModule[_safe] == address(0), \\\"Module already created\\\");\\n        bytes memory bytecode = type(CoboSafeModule).creationCode;\\n        bytes memory creationCode = abi.encodePacked(\\n            bytecode,\\n            abi.encode(_safe)\\n        );\\n        uint256 moduleIndex = modulesSize();\\n        bytes32 salt = keccak256(abi.encodePacked(address(this), moduleIndex));\\n\\n        assembly {\\n            _module := create2(\\n                0,\\n                add(creationCode, 32),\\n                mload(creationCode),\\n                salt\\n            )\\n        }\\n        require(_module != address(0), \\\"Failed to create module\\\");\\n        modules.push(_module);\\n        safeToModule[_safe] = _module;\\n\\n        emit NewModule(_safe, _module, _msgSender());\\n    }\\n\\n    function setPaused(bool paused) external onlyOwner {\\n        if (paused) _pause();\\n        else _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor () {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\nimport \\\"Context.sol\\\";\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\nabstract contract TransferOwnable is Ownable {\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"CoboSafeModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"EnumerableSet.sol\\\";\\nimport \\\"GnosisSafe.sol\\\";\\nimport \\\"Ownable.sol\\\";\\n\\n/// @title A GnosisSafe module that implements Cobo's role based access control policy\\n/// @author Cobo Safe Dev Team (safe_devs@cobo.com)\\n/// @notice Use this module to access Gnosis Safe with role based access control policy\\n/// @dev This contract implements the core data structure and its related features.\\ncontract CoboSafeModule is Ownable {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    string public constant NAME = \\\"Cobo Safe Module\\\";\\n    string public constant VERSION = \\\"0.2.2\\\";\\n\\n    // Below are predefined roles: ROLE_HARVESTER\\n    //\\n    // Gnosis safe owners need to call to `grantRole(ROLE_XXX, delegate)` to grant permission to a delegate.\\n\\n    // 'harvesters\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00'\\n    bytes32 public constant ROLE_HARVESTER =\\n        0x6861727665737465727300000000000000000000000000000000000000000000;\\n\\n    /// @notice Event fired when a delegate is added\\n    /// @dev Event fired when a delegate is added via `grantRole` method\\n    /// @param delegate the delegate being added\\n    /// @param sender the owner who added the delegate\\n    event DelegateAdded(address indexed delegate, address indexed sender);\\n\\n    /// @notice Event fired when a delegate is removed\\n    /// @dev Event fired when a delegate is remove via `revokeRole` method\\n    /// @param delegate the delegate being removed\\n    /// @param sender the owner who removed the delegate\\n    event DelegateRemoved(address indexed delegate, address indexed sender);\\n\\n    /// @notice Event fired when a role is added\\n    /// @dev Event fired when a role is being added via `addRole` method\\n    /// @param role the role being added\\n    /// @param sender the owner who added the role\\n    event RoleAdded(bytes32 indexed role, address indexed sender);\\n\\n    /// @notice Event fired when a role is grant to a delegate\\n    /// @dev Event fired when a role is grant to a delegate via `grantRole`\\n    /// @param role the role being granted\\n    /// @param delegate the delegate being granted the given role\\n    /// @param sender the owner who granted the role to the given delegate\\n    event RoleGranted(\\n        bytes32 indexed role,\\n        address indexed delegate,\\n        address indexed sender\\n    );\\n\\n    /// @notice Event fired when a role is revoked from a delegate\\n    /// @dev Event fired when a role is revoked from a delegate via `revokeRole`\\n    /// @param role the role being revoked\\n    /// @param delegate the delegate being revoked the given role\\n    /// @param sender the owner who revoked the role from the given delegate\\n    event RoleRevoked(\\n        bytes32 indexed role,\\n        address indexed delegate,\\n        address indexed sender\\n    );\\n\\n    /// @notice Event fired after a transaction is successfully executed by a delegate\\n    /// @dev Event fired after a transaction is successfully executed by a delegate via `execTransaction` method\\n    /// @param to the targate contract to execute the transaction\\n    /// @param value the ether value to be sent to the target contract when executing the transaction\\n    /// @param operation use `call` or `delegatecall` to execute the transaction on the contract\\n    /// @param data input data to execute the transaction on the given contract\\n    /// @param sender the delegate who execute the transaction\\n    event ExecTransaction(\\n        address indexed to,\\n        uint256 value,\\n        Enum.Operation operation,\\n        bytes data,\\n        address indexed sender\\n    );\\n\\n    /// @notice Event fired when a role is associated with a contract and its function list\\n    /// @dev Event fired when a role is associated with a contract and its function list via `assocRoleWithContractFuncs`\\n    /// @param role the role to be associated with the given contract and function list\\n    /// @param _contract the target contract to be associated with the role\\n    /// @param funcList a list of function signatures of the given contract to be associated with the role\\n    /// @param sender the owner who associated the role with the contract and its function list\\n    event AssocContractFuncs(\\n        bytes32 indexed role,\\n        address indexed _contract,\\n        string[] funcList,\\n        address indexed sender\\n    );\\n\\n    /// @notice Event fired when a role is disassociate from a contract and its function list\\n    /// @dev Event fired when a role is disassociate from a contract and its function list via `dissocRoleFromContractFuncs`\\n    /// @param role the role to be disassociated from the given contract and function list\\n    /// @param _contract the target contract to be disassociated from the role\\n    /// @param funcList a list of function signatures of the given contract to be disassociated from the role\\n    /// @param sender the owner who disassociated the role from the contract and its function list\\n    event DissocContractFuncs(\\n        bytes32 indexed role,\\n        address indexed _contract,\\n        string[] funcList,\\n        address indexed sender\\n    );\\n\\n    /// @dev Tracks the set of granted delegates. The set is dynamically added\\n    ///      to or removed from by  `grantRole` and `rokeRole`.  `isDelegate`\\n    ///      also uses it to test if a caller is a valid delegate or not\\n    EnumerableSet.AddressSet delegateSet;\\n\\n    /// @dev Tracks what roles each delegate owns. The mapping is dynamically\\n    ///      added to or removed from by  `grantRole` and `rokeRole`. `hasRole`\\n    ///      also uses it to test if a delegate is granted a given role or not\\n    mapping(address => EnumerableSet.Bytes32Set) delegateToRoles;\\n\\n    /// @dev Tracks the set of roles. The set keeps track of all defined roles.\\n    ///      It is updated by `addRole`, and possibly by `removeRole` if to be\\n    ///      supported. All role based access policy checks against the set for\\n    ///      role validity.\\n    EnumerableSet.Bytes32Set roleSet;\\n\\n    /// @dev Tracks the set of contract address. The set keeps track of contracts\\n    ///      which have been associated with a role. It is updated by\\n    ///      `assocRoleWithContractFuncs` and `dissocRoleFromContractFuncs`\\n    EnumerableSet.AddressSet contractSet;\\n\\n    /// @dev mapping from `contract address` => `function selectors`\\n    mapping(address => EnumerableSet.Bytes32Set) contractToFuncs;\\n\\n    /// @dev mapping from `contract address` => `function selectors` => `list of roles`\\n    mapping(address => mapping(bytes32 => EnumerableSet.Bytes32Set)) funcToRoles;\\n\\n    /// @dev modifier to assert only delegate is allow to proceed\\n    modifier onlyDelegate() {\\n        require(isDelegate(_msgSender()), \\\"must be delegate\\\");\\n        _;\\n    }\\n\\n    /// @dev modifier to assert the given role must be predefined\\n    /// @param role the role to be checked\\n    modifier roleDefined(bytes32 role) {\\n        require(roleSet.contains(role), \\\"unrecognized role\\\");\\n        _;\\n    }\\n\\n    /// @notice Contructor function for CoboSafeModule\\n    /// @dev When this module is deployed, its ownership will be automatically\\n    ///      transferred to the given Gnosis safe instance. The instance is\\n    ///      supposed to call `enableModule` on the constructed module instance\\n    ///      in order for it to function properly.\\n    /// @param _safe the Gnosis Safe (GnosisSafeProxy) instance's address\\n    constructor(address payable _safe) {\\n        require(_safe != address(0), \\\"invalid safe address\\\");\\n\\n        // Add default role. Use `addRole` to make sure `RoleAdded` event is fired\\n        addRole(ROLE_HARVESTER);\\n\\n        // make the given safe the owner of the current module.\\n        _transferOwnership(_safe);\\n    }\\n\\n    /// @notice Checks if an address is a permitted delegate\\n    /// @dev the address must have been granted role via `grantRole` in order to become a delegate\\n    /// @param delegate the address to be checked\\n    /// @return true|false\\n    function isDelegate(address delegate) public view returns (bool) {\\n        return delegateSet.contains(delegate);\\n    }\\n\\n    /// @notice Grant a role to a delegate\\n    /// @dev Granting a role to a delegate will give delegate permission to call\\n    ///      contract functions associated with the role. Only owner can grant\\n    ///      role and the must be predefined and not granted to the delegate\\n    ///      already. on success, `RoleGranted` event would be fired and\\n    ///      possibly `DelegateAdded` as well if this is the first role being\\n    ///      granted to the delegate.\\n    /// @param role the role to be granted\\n    /// @param delegate the delegate to be granted role\\n    function grantRole(bytes32 role, address delegate)\\n        external\\n        onlyOwner\\n        roleDefined(role)\\n    {\\n        require(!_hasRole(role, delegate), \\\"role already granted\\\");\\n\\n        delegateToRoles[delegate].add(role);\\n\\n        // We need to emit `DelegateAdded` before `RoleGranted` to allow\\n        // subgraph event handler to process in sensible order.\\n        if (delegateSet.add(delegate)) {\\n            emit DelegateAdded(delegate, _msgSender());\\n        }\\n\\n        emit RoleGranted(role, delegate, _msgSender());\\n    }\\n\\n    /// @notice Revoke a role from a delegate\\n    /// @dev Revoking a role from a delegate will remove the permission the\\n    ///      delegate has to call contract functions associated with the role.\\n    ///      Only owner can revoke the role.  The role has to be predefined and\\n    ///      granted to the delegate before revoking, otherwise the function\\n    ///      will be reverted. `RoleRevoked` event would be fired and possibly\\n    ///      `DelegateRemoved` as well if this is the last role the delegate\\n    ///      owns.\\n    /// @param role the role to be granted\\n    /// @param delegate the delegate to be granted role\\n    function revokeRole(bytes32 role, address delegate)\\n        external\\n        onlyOwner\\n        roleDefined(role)\\n    {\\n        require(_hasRole(role, delegate), \\\"role has not been granted\\\");\\n\\n        delegateToRoles[delegate].remove(role);\\n\\n        // We need to make sure `RoleRevoked` is fired before `DelegateRemoved`\\n        // to make sure the event handlers in subgraphs are triggered in the\\n        // right order.\\n        emit RoleRevoked(role, delegate, _msgSender());\\n\\n        if (delegateToRoles[delegate].length() == 0) {\\n            delegateSet.remove(delegate);\\n            emit DelegateRemoved(delegate, _msgSender());\\n        }\\n    }\\n\\n    /// @notice Test if a delegate has a role\\n    /// @dev The role has be predefined or the function will be reverted.\\n    /// @param role the role to be checked\\n    /// @param delegate the delegate to be checked\\n    /// @return true|false\\n    function hasRole(bytes32 role, address delegate)\\n        external\\n        view\\n        roleDefined(role)\\n        returns (bool)\\n    {\\n        return _hasRole(role, delegate);\\n    }\\n\\n    /// @notice Test if a delegate has a role (internal version)\\n    /// @dev This does the same check as hasRole, but avoid the checks on if the\\n    ///      role is defined. Internal functions can call this to save gas consumptions\\n    /// @param role the role to be checked\\n    /// @param delegate the delegate to be checked\\n    /// @return true|false\\n    function _hasRole(bytes32 role, address delegate)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return delegateToRoles[delegate].contains(role);\\n    }\\n\\n    /// @notice Add a new role\\n    /// @dev only owner can call this function, the role has to be a new role.\\n    ///      On success, `RoleAdded` event will be fired\\n    /// @param role the role to be added\\n    function addRole(bytes32 role) public onlyOwner {\\n        require(!roleSet.contains(role), \\\"role exists\\\");\\n\\n        roleSet.add(role);\\n\\n        emit RoleAdded(role, _msgSender());\\n    }\\n\\n    /// @notice Call Gnosis Safe to execute a transaction\\n    /// @dev Delegates can call this method to invoke gnosis safe to forward to\\n    ///      transaction to target contract method `to`::`func`, where `func`\\n    ///      is the function selector contained in first 4 bytes of `data`.\\n    ///      The function can only be called by delegates.\\n    /// @param to The target contract to be called by Gnosis Safe\\n    /// @param data The input data to be called by Gnosis Safe\\n    ///\\n    /// TODO: implement EIP712 signature.\\n    function execTransaction(address to, bytes calldata data)\\n        external\\n        onlyDelegate\\n    {\\n        _execTransaction(to, data);\\n    }\\n\\n    /// @notice Batch execute multiple transaction via Gnosis Safe\\n    /// @dev This is batch version of the `execTransaction` function to allow\\n    ///      the delegates to bundle multiple calls into a single transaction and\\n    ///      sign only once. Batch execute the transactions, one failure cause the\\n    ///      batch reverted. Only delegates are allowed to call this.\\n    /// @param toList list of contract addresses to be called\\n    /// @param dataList list of input data associated with each contract call\\n    function batchExecTransactions(\\n        address[] calldata toList,\\n        bytes[] calldata dataList\\n    ) external onlyDelegate {\\n        require(\\n            toList.length > 0 && toList.length == dataList.length,\\n            \\\"invalid inputs\\\"\\n        );\\n\\n        for (uint256 i = 0; i < toList.length; i++) {\\n            _execTransaction(toList[i], dataList[i]);\\n        }\\n    }\\n\\n    /// @dev The internal implementation of `execTransaction` and\\n    ///      `batchExecTransactions`, that invokes gnosis safe to forward to\\n    ///      transaction to target contract method `to`::`func`, where `func` is\\n    ///      the function selector contained in first 4 bytes of `data`.  The\\n    ///      function checks if the calling delegate has the required permission\\n    ///      to call the designated contract function before invoking Gnosis\\n    ///      Safe.\\n    /// @param to The target contract to be called by Gnosis Safe\\n    /// @param data The input data to be called by Gnosis Safe\\n    function _execTransaction(address to, bytes memory data) internal {\\n        bytes4 selector;\\n        assembly {\\n            selector := mload(add(data, 0x20))\\n        }\\n\\n        require(\\n            _hasPermission(_msgSender(), to, selector),\\n            \\\"permission denied\\\"\\n        );\\n\\n        // execute the transaction from Gnosis Safe, note this call will bypass\\n        // safe owners confirmation.\\n        require(\\n            GnosisSafe(payable(owner())).execTransactionFromModule(\\n                to,\\n                0,\\n                data,\\n                Enum.Operation.Call\\n            ),\\n            \\\"failed in execution in safe\\\"\\n        );\\n\\n        emit ExecTransaction(to, 0, Enum.Operation.Call, data, _msgSender());\\n    }\\n\\n    /// @dev Internal function to check if a delegate has the permission to call a given contract function\\n    /// @param delegate the delegate to be checked\\n    /// @param to the target contract\\n    /// @param selector the function selector of the contract function to be called\\n    /// @return true|false\\n    function _hasPermission(\\n        address delegate,\\n        address to,\\n        bytes4 selector\\n    ) internal view returns (bool) {\\n        bytes32[] memory roles = getRolesByDelegate(delegate);\\n        EnumerableSet.Bytes32Set storage funcRoles = funcToRoles[to][selector];\\n        for (uint256 index = 0; index < roles.length; index++) {\\n            if (funcRoles.contains(roles[index])) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /// @dev Public function to check if a delegate has the permission to call a given contract function\\n    /// @param delegate the delegate to be checked\\n    /// @param to the target contract\\n    /// @param selector the function selector of the contract function to be called\\n    /// @return true|false\\n    function hasPermission(\\n        address delegate,\\n        address to,\\n        bytes4 selector\\n    ) external view returns (bool) {\\n        if (!isDelegate(delegate)) {\\n            return false;\\n        }\\n\\n        return _hasPermission(delegate, to, selector);\\n    }\\n\\n    /// @notice Associate a role with given contract funcs\\n    /// @dev only owners are allowed to call this function, the given role has\\n    ///      to be predefined. On success, the role will be associated with the\\n    ///      given contract function, `AssocContractFuncs` event will be fired.\\n    /// @param role the role to be associated\\n    /// @param _contract the contract address to be associated with the role\\n    /// @param funcList the list of contract functions to be associated with the role\\n    function assocRoleWithContractFuncs(\\n        bytes32 role,\\n        address _contract,\\n        string[] calldata funcList\\n    ) external onlyOwner roleDefined(role) {\\n        require(funcList.length > 0, \\\"empty funcList\\\");\\n\\n        for (uint256 index = 0; index < funcList.length; index++) {\\n            bytes4 funcSelector = bytes4(keccak256(bytes(funcList[index])));\\n            bytes32 funcSelector32 = bytes32(funcSelector);\\n            funcToRoles[_contract][funcSelector32].add(role);\\n            contractToFuncs[_contract].add(funcSelector32);\\n        }\\n\\n        contractSet.add(_contract);\\n\\n        emit AssocContractFuncs(role, _contract, funcList, _msgSender());\\n    }\\n\\n    /// @notice Dissociate a role from given contract funcs\\n    /// @dev only owners are allowed to call this function, the given role has\\n    ///      to be predefined. On success, the role will be disassociated from\\n    ///      the given contract function, `DissocContractFuncs` event will be\\n    ///      fired.\\n    /// @param role the role to be disassociated\\n    /// @param _contract the contract address to be disassociated from the role\\n    /// @param funcList the list of contract functions to be disassociated from the role\\n    function dissocRoleFromContractFuncs(\\n        bytes32 role,\\n        address _contract,\\n        string[] calldata funcList\\n    ) external onlyOwner roleDefined(role) {\\n        require(funcList.length > 0, \\\"empty funcList\\\");\\n\\n        for (uint256 index = 0; index < funcList.length; index++) {\\n            bytes4 funcSelector = bytes4(keccak256(bytes(funcList[index])));\\n            bytes32 funcSelector32 = bytes32(funcSelector);\\n            funcToRoles[_contract][funcSelector32].remove(role);\\n\\n            if (funcToRoles[_contract][funcSelector32].length() <= 0) {\\n                contractToFuncs[_contract].remove(funcSelector32);\\n            }\\n        }\\n\\n        if (contractToFuncs[_contract].length() <= 0) {\\n            contractSet.remove(_contract);\\n        }\\n\\n        emit DissocContractFuncs(role, _contract, funcList, _msgSender());\\n    }\\n\\n    /// @notice Get all the delegates who are currently granted any role\\n    /// @return list of delegate addresses\\n    function getAllDelegates() public view returns (address[] memory) {\\n        bytes32[] memory store = delegateSet._inner._values;\\n        address[] memory result;\\n        assembly {\\n            result := store\\n        }\\n        return result;\\n    }\\n\\n    /// @notice Given a delegate, return all the roles granted to the delegate\\n    /// @return list of roles\\n    function getRolesByDelegate(address delegate)\\n        public\\n        view\\n        returns (bytes32[] memory)\\n    {\\n        return delegateToRoles[delegate]._inner._values;\\n    }\\n\\n    /// @notice Get all the roles defined in the module\\n    /// @return list of roles\\n    function getAllRoles() external view returns (bytes32[] memory) {\\n        return roleSet._inner._values;\\n    }\\n\\n    /// @notice Get all the contracts ever associated with any role\\n    /// @return list of contract addresses\\n    function getAllContracts() public view returns (address[] memory) {\\n        bytes32[] memory store = contractSet._inner._values;\\n        address[] memory result;\\n        assembly {\\n            result := store\\n        }\\n        return result;\\n    }\\n\\n    /// @notice Given a contract, list all the function selectors of this contract associated with a role\\n    /// @param _contract the contract\\n    /// @return list of function selectors in the contract ever associated with a role\\n    function getFuncsByContract(address _contract)\\n        public\\n        view\\n        returns (bytes4[] memory)\\n    {\\n        bytes32[] memory store = contractToFuncs[_contract]._inner._values;\\n        bytes4[] memory result;\\n        assembly {\\n            result := store\\n        }\\n        return result;\\n    }\\n\\n    /// @notice Given a function, list all the roles that have permission to access to them\\n    /// @param _contract the contract address\\n    /// @param funcSelector the function selector\\n    /// @return list of roles\\n    function getRolesByContractFunction(address _contract, bytes4 funcSelector)\\n        public\\n        view\\n        returns (bytes32[] memory)\\n    {\\n        return funcToRoles[_contract][funcSelector]._inner._values;\\n    }\\n}\\n\"\r\n    },\r\n    \"EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"GnosisSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity 0.7.6;\\n\\n/// @title Enum - Collection of enums\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract Enum {\\n    enum Operation {\\n        Call,\\n        DelegateCall\\n    }\\n}\\n\\ninterface GnosisSafe {\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModule(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation\\n    ) external returns (bool success);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NewModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_safe\",\"type\":\"address\"}],\"name\":\"createModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"modules\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"modulesSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"safeToModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CoboSafeFactory","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}