{"status":"1","message":"OK","result":[{"SourceCode":"{\"Erc2612.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Adapted from OpenZeppelin ERC2612 (ERC20Permit)\\n\\npragma solidity 0.8.4;\\n\\nimport \\u0027./Hash.sol\\u0027;\\nimport \\u0027./PErc20.sol\\u0027;\\nimport \\u0027./IErc2612.sol\\u0027;\\n\\n/**\\n* @dev Extension of {ERC20} that allows token holders to use their tokens\\n* without sending any transactions by setting {IERC20-allowance} with a\\n* signature using the {permit} method, and then spend them via\\n* {IERC20-transferFrom}.\\n* NOTE: Naming convention is kept OZStyle vs our own OzStyle to prevent clashing\\n*\\n* The {permit} signature mechanism conforms to the {IERC2612} interface.\\n*/\\ncontract Erc2612 is PErc20, IErc2612 {\\n  mapping (address =\\u003e uint256) public override nonces;\\n\\n  bytes32 public immutable domain;\\n\\n  /// @param n name for the token\\n  /// @param s symbol for the token\\n  /// @param d decimals for the token\\n  constructor(string memory n, string memory s, uint8 d) PErc20(n, s, d) {\\n    domain = Hash.domain(n, \\u00271\\u0027, block.chainid, address(this));\\n  }\\n\\n  /**\\n  * @dev See {IERC2612-permit}.\\n  *\\n  * In cases where the free option is not a concern, deadline can simply be\\n  * set to uint(-1), so it should be seen as an optional parameter\\n  *\\n  * @param o Address of the owner\\n  * @param spender Address of the spender\\n  * @param a Amount to be approved\\n  * @param d Deadline at which the permission is no longer valid\\n  * NOTE: Last three args (v, r, s) are the components of a valid ECDSA signature\\n  */\\n  function permit(address o, address spender, uint256 a, uint256 d, uint8 v, bytes32 r, bytes32 s) public virtual override {\\n    require(d \\u003e= block.timestamp, \\u0027erc2612 expired deadline\\u0027);\\n\\n    bytes32 hashStruct = Hash.permit(o, spender, a, nonces[o]++, d);\\n    bytes32 hash = Hash.message(domain, hashStruct); \\n    address signer = ecrecover(hash, v, r, s);\\n\\n    require(signer != address(0) \\u0026\\u0026 signer == o, \\u0027erc2612 invalid signature\\u0027);\\n    _approve(o, spender, a);\\n  }\\n}\\n\"},\"Hash.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.4;\\n\\n/**\\n  @notice Encapsulation of the logic to produce EIP712 hashed domain and messages.\\n  Also to produce / verify hashed and signed Permits.\\n*/\\n\\nlibrary Hash {\\n  // EIP712 Domain Separator typeHash\\n  // keccak256(abi.encodePacked(\\n  //     \\u0027EIP712Domain(\\u0027,\\n  //     \\u0027string name,\\u0027,\\n  //     \\u0027string version,\\u0027,\\n  //     \\u0027uint256 chainId,\\u0027,\\n  //     \\u0027address verifyingContract\\u0027,\\n  //     \\u0027)\\u0027\\n  // ));\\n  bytes32 constant internal DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n  // EIP2612 typeHash of a Permit\\n  // keccak256(abi.encodePacked(\\n  //     \\u0027Permit(\\u0027,\\n  //     \\u0027address owner,\\u0027,\\n  //     \\u0027address spender,\\u0027,\\n  //     \\u0027uint256 value,\\u0027,\\n  //     \\u0027uint256 nonce,\\u0027,\\n  //     \\u0027uint256 deadline,\\u0027,\\n  //     \\u0027)\\u0027\\n  // ));\\n  bytes32 constant internal PERMIT_TYPEHASH = 0x80772249b4aef1688b30651778f4249b05cb73b517d98482439b9d8999b30602;\\n\\n  /// @param n EIP712 domain name\\n  /// @param version EIP712 semantic version string\\n  /// @param i Chain ID\\n  /// @param verifier address of the verifying contract\\n  function domain(string memory n, string memory version, uint256 i, address verifier) internal pure returns (bytes32) {\\n    bytes32 hash;\\n\\n    assembly {\\n      let nameHash := keccak256(add(n, 32), mload(n))\\n      let versionHash := keccak256(add(version, 32), mload(version))\\n      let pointer := mload(64)\\n      mstore(pointer, DOMAIN_TYPEHASH)\\n      mstore(add(pointer, 32), nameHash)\\n      mstore(add(pointer, 64), versionHash)\\n      mstore(add(pointer, 96), i)\\n      mstore(add(pointer, 128), verifier)\\n      hash := keccak256(pointer, 160)\\n    }\\n\\n    return hash;\\n  }\\n\\n  /// @param d Type hash of the domain separator (see Hash.domain)\\n  /// @param h EIP712 hash struct (Permit for example)\\n  function message(bytes32 d, bytes32 h) internal pure returns (bytes32) {\\n    bytes32 hash;\\n\\n    assembly {\\n      let pointer := mload(64)\\n      mstore(pointer, 0x1901000000000000000000000000000000000000000000000000000000000000)\\n      mstore(add(pointer, 2), d)\\n      mstore(add(pointer, 34), h)\\n      hash := keccak256(pointer, 66)\\n    }\\n\\n    return hash;\\n  }\\n\\n  /// @param o Address of the owner\\n  /// @param s Address of the spender\\n  /// @param a Amount to be approved\\n  /// @param n Current nonce\\n  /// @param d Deadline at which the permission is no longer valid\\n  function permit(address o, address s, uint256 a, uint256 n, uint256 d) internal pure returns (bytes32) {\\n    return keccak256(abi.encode(PERMIT_TYPEHASH, o, s, a, n, d));\\n  }\\n}\\n\"},\"IErc2612.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Code adapted from OpenZeppelin IERCPermit\\npragma solidity 0.8.4;\\n\\n/**\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\n *\\n * Adds the {permit} method, which can be used to change one\\u0027s\\n * {IERC20-allowance} without having to send a transaction, by signing a\\n * message. This allows users to spend tokens without having to hold Ether.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\n */\\ninterface IErc2612 {\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`\\u0027s tokens,\\n     * given `owner`\\u0027s signed approval.\\n     * @param o The owner\\n     * @param spender The spender\\n     * @param a The amount\\n     * @param d The deadline\\n     * @param v v portion of the ECDSA\\n     * @param r r portion of the ECDSA\\n     * @param s s portion of the ECDSA\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``\\u0027s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(address o, address spender, uint256 a, uint256 d, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /**\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\n     * @param o The owner\\n     *\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``\\u0027s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address o) external view returns (uint256);\\n}\\n\"},\"Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.4;\\n\\ninterface Erc20 {\\n  function decimals() external returns (uint8);\\n}\\n\\ninterface CErc20 {\\n\\tfunction exchangeRateCurrent() external returns (uint256);\\n  function underlying() external returns (address);\\n}\\n\"},\"IPErc20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IPErc20 {\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     * @param a Adress to fetch balance of\\n     */\\n    function balanceOf(address a) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     * @param r The recipient\\n     * @param a The amount transferred\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address r, uint256 a) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     * @param o The owner\\n     * @param s The spender\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address o, address s) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     * @param s The spender\\n     * @param a The amount to approve\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address s, uint256 a) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     * @param s The sender\\n     * @param r The recipient\\n     * @param a The amount to transfer\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address s, address r, uint256 a) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IZcToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./IPErc20.sol\\\";\\n\\n/**\\n * @dev Mint and burn interface for the ZCToken\\n *\\n */\\ninterface IZcToken is IPErc20 {\\n    /**\\n     * @dev Mints...\\n     */\\n    function mint(address, uint256) external returns(bool);\\n\\n    /**\\n     * @dev Burns...\\n     */\\n    function burn(address, uint256) external returns(bool);\\n}\\n\"},\"MarketPlace.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.4;\\n\\nimport \\u0027./Interfaces.sol\\u0027;\\nimport \\u0027./ZcToken.sol\\u0027;\\nimport \\u0027./VaultTracker.sol\\u0027;\\n\\ncontract MarketPlace {\\n  struct Market {\\n    address cTokenAddr;\\n    address zcTokenAddr;\\n    address vaultAddr;\\n    uint256 maturityRate;\\n  }\\n\\n  mapping (address =\\u003e mapping (uint256 =\\u003e Market)) public markets;\\n\\n  address public admin;\\n  address public swivel;\\n  bool public paused;\\n\\n  event Create(address indexed underlying, uint256 indexed maturity, address cToken, address zcToken, address vaultTracker);\\n  event Mature(address indexed underlying, uint256 indexed maturity, uint256 maturityRate, uint256 matured);\\n  event RedeemZcToken(address indexed underlying, uint256 indexed maturity, address indexed sender, uint256 amount);\\n  event RedeemVaultInterest(address indexed underlying, uint256 indexed maturity, address indexed sender);\\n  event CustodialInitiate(address indexed underlying, uint256 indexed maturity, address zcTarget, address nTarget, uint256 amount);\\n  event CustodialExit(address indexed underlying, uint256 indexed maturity, address zcTarget, address nTarget, uint256 amount);\\n  event P2pZcTokenExchange(address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);\\n  event P2pVaultExchange(address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);\\n  event TransferVaultNotional(address indexed underlying, uint256 indexed maturity, address from, address to, uint256 amount);\\n\\n  constructor() {\\n    admin = msg.sender;\\n  }\\n\\n  /// @param s Address of the deployed swivel contract\\n  /// @notice We only allow this to be set once\\n  function setSwivelAddress(address s) external authorized(admin) returns (bool) {\\n    require(swivel == address(0), \\u0027swivel contract address already set\\u0027);\\n    swivel = s;\\n    return true;\\n  }\\n\\n  /// @param a Address of a new admin\\n  function transferAdmin(address a) external authorized(admin) returns (bool) {\\n    admin = a;\\n    return true;\\n  }\\n\\n  /// @notice Allows the owner to create new markets\\n  /// @param m Maturity timestamp of the new market\\n  /// @param c cToken address associated with underlying for the new market\\n  /// @param n Name of the new zcToken market\\n  /// @param s Symbol of the new zcToken market\\n  function createMarket(\\n    uint256 m,\\n    address c,\\n    string memory n,\\n    string memory s\\n  ) external authorized(admin) unpaused() returns (bool) {\\n    address swivelAddr = swivel;\\n    require(swivelAddr != address(0), \\u0027swivel contract address not set\\u0027);\\n\\n    address underAddr = CErc20(c).underlying();\\n    require(markets[underAddr][m].vaultAddr == address(0), \\u0027market already exists\\u0027);\\n\\n    uint8 decimals = Erc20(underAddr).decimals();\\n    address zcTokenAddr = address(new ZcToken(underAddr, m, n, s, decimals));\\n    address vaultAddr = address(new VaultTracker(m, c, swivelAddr));\\n    markets[underAddr][m] = Market(c, zcTokenAddr, vaultAddr, 0);\\n\\n    emit Create(underAddr, m, c, zcTokenAddr, vaultAddr);\\n\\n    return true;\\n  }\\n\\n  /// @notice Can be called after maturity, allowing all of the zcTokens to earn floating interest on Compound until they release their funds\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  function matureMarket(address u, uint256 m) public unpaused() returns (bool) {\\n    Market memory mkt = markets[u][m];\\n\\n    require(mkt.maturityRate == 0, \\u0027market already matured\\u0027);\\n    require(block.timestamp \\u003e= m, \\\"maturity not reached\\\");\\n\\n    // set the base maturity cToken exchange rate at maturity to the current cToken exchange rate\\n    uint256 currentExchangeRate = CErc20(mkt.cTokenAddr).exchangeRateCurrent();\\n    markets[u][m].maturityRate = currentExchangeRate;\\n\\n    require(VaultTracker(mkt.vaultAddr).matureVault(currentExchangeRate), \\u0027mature vault failed\\u0027);\\n\\n    emit Mature(u, m, currentExchangeRate, block.timestamp);\\n\\n    return true;\\n  }\\n\\n  /// @notice Allows Swivel caller to deposit their underlying, in the process splitting it - minting both zcTokens and vault notional.\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  /// @param t Address of the depositing user\\n  /// @param a Amount of notional being added\\n  function mintZcTokenAddingNotional(address u, uint256 m, address t, uint256 a) external authorized(swivel) unpaused() returns (bool) {\\n    Market memory mkt = markets[u][m];\\n    require(ZcToken(mkt.zcTokenAddr).mint(t, a), \\u0027mint zcToken failed\\u0027);\\n    require(VaultTracker(mkt.vaultAddr).addNotional(t, a), \\u0027add notional failed\\u0027);\\n    \\n    return true;\\n  }\\n\\n  /// @notice Allows Swivel caller to deposit/burn both zcTokens + vault notional. This process is \\\"combining\\\" the two and redeeming underlying.\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  /// @param t Address of the combining/redeeming user\\n  /// @param a Amount of zcTokens being burned\\n  function burnZcTokenRemovingNotional(address u, uint256 m, address t, uint256 a) external authorized(swivel) unpaused() returns(bool) {\\n    Market memory mkt = markets[u][m];\\n    require(ZcToken(mkt.zcTokenAddr).burn(t, a), \\u0027burn failed\\u0027);\\n    require(VaultTracker(mkt.vaultAddr).removeNotional(t, a), \\u0027remove notional failed\\u0027);\\n    \\n    return true;\\n  }\\n\\n  /// @notice Allows (via swivel) zcToken holders to redeem their tokens for underlying tokens after maturity has been reached.\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  /// @param t Address of the redeeming user\\n  /// @param a Amount of zcTokens being redeemed\\n  function redeemZcToken(address u, uint256 m, address t, uint256 a) external authorized(swivel) unpaused() returns (uint256) {\\n    Market memory mkt = markets[u][m];\\n\\n    // if the market has not matured, mature it and redeem exactly the amount\\n    if (mkt.maturityRate == 0) {\\n      require(matureMarket(u, m), \\u0027failed to mature the market\\u0027);\\n    }\\n\\n    // burn user\\u0027s zcTokens\\n    require(ZcToken(mkt.zcTokenAddr).burn(t, a), \\u0027could not burn\\u0027);\\n\\n    emit RedeemZcToken(u, m, t, a);\\n\\n    if (mkt.maturityRate == 0) {\\n      return a;\\n    } else { \\n      // if the market was already mature the return should include the amount + marginal floating interest generated on Compound since maturity\\n      return calculateReturn(u, m, a);\\n    }\\n  }\\n\\n  /// @notice Allows Vault owners (via Swivel) to redeem any currently accrued interest\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  /// @param t Address of the redeeming user\\n  function redeemVaultInterest(address u, uint256 m, address t) external authorized(swivel) unpaused() returns (uint256) {\\n    // call to the floating market contract to release the position and calculate the interest generated\\n    uint256 interest = VaultTracker(markets[u][m].vaultAddr).redeemInterest(t);\\n\\n    emit RedeemVaultInterest(u, m, t);\\n\\n    return interest;\\n  }\\n\\n  /// @notice Calculates the total amount of underlying returned including interest generated since the `matureMarket` function has been called\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  /// @param a Amount of zcTokens being redeemed\\n  function calculateReturn(address u, uint256 m, uint256 a) internal returns (uint256) {\\n    Market memory mkt = markets[u][m];\\n    uint256 rate = CErc20(mkt.cTokenAddr).exchangeRateCurrent();\\n\\n    return (a * rate) / mkt.maturityRate;\\n  }\\n\\n  /// @notice Return the ctoken address for a given market\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  function cTokenAddress(address u, uint256 m) external view returns (address) {\\n    return markets[u][m].cTokenAddr;\\n  }\\n\\n  /// @notice Called by swivel IVFZI \\u0026\\u0026 IZFVI\\n  /// @dev Call with underlying, maturity, mint-target, add-notional-target and an amount\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  /// @param z Recipient of the minted zcToken\\n  /// @param n Recipient of the added notional\\n  /// @param a Amount of zcToken minted and notional added\\n  function custodialInitiate(address u, uint256 m, address z, address n, uint256 a) external authorized(swivel) unpaused() returns (bool) {\\n    Market memory mkt = markets[u][m];\\n    require(ZcToken(mkt.zcTokenAddr).mint(z, a), \\u0027mint failed\\u0027);\\n    require(VaultTracker(mkt.vaultAddr).addNotional(n, a), \\u0027add notional failed\\u0027);\\n    emit CustodialInitiate(u, m, z, n, a);\\n    return true;\\n  }\\n\\n  /// @notice Called by swivel EVFZE FF EZFVE\\n  /// @dev Call with underlying, maturity, burn-target, remove-notional-target and an amount\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  /// @param z Owner of the zcToken to be burned\\n  /// @param n Target to remove notional from\\n  /// @param a Amount of zcToken burned and notional removed\\n  function custodialExit(address u, uint256 m, address z, address n, uint256 a) external authorized(swivel) unpaused() returns (bool) {\\n    Market memory mkt = markets[u][m];\\n    require(ZcToken(mkt.zcTokenAddr).burn(z, a), \\u0027burn failed\\u0027);\\n    require(VaultTracker(mkt.vaultAddr).removeNotional(n, a), \\u0027remove notional failed\\u0027);\\n    emit CustodialExit(u, m, z, n, a);\\n    return true;\\n  }\\n\\n  /// @notice Called by swivel IZFZE, EZFZI\\n  /// @dev Call with underlying, maturity, transfer-from, transfer-to, amount\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  /// @param f Owner of the zcToken to be burned\\n  /// @param t Target to be minted to\\n  /// @param a Amount of zcToken transfer\\n  function p2pZcTokenExchange(address u, uint256 m, address f, address t, uint256 a) external authorized(swivel) unpaused() returns (bool) {\\n    Market memory mkt = markets[u][m];\\n    require(ZcToken(mkt.zcTokenAddr).burn(f, a), \\u0027zcToken burn failed\\u0027);\\n    require(ZcToken(mkt.zcTokenAddr).mint(t, a), \\u0027zcToken mint failed\\u0027);\\n    emit P2pZcTokenExchange(u, m, f, t, a);\\n    return true;\\n  }\\n\\n  /// @notice Called by swivel IVFVE, EVFVI\\n  /// @dev Call with underlying, maturity, remove-from, add-to, amount\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  /// @param f Owner of the notional to be transferred\\n  /// @param t Target to be transferred to\\n  /// @param a Amount of notional transfer\\n  function p2pVaultExchange(address u, uint256 m, address f, address t, uint256 a) external authorized(swivel) unpaused() returns (bool) {\\n    require(VaultTracker(markets[u][m].vaultAddr).transferNotionalFrom(f, t, a), \\u0027transfer notional failed\\u0027);\\n    emit P2pVaultExchange(u, m, f, t, a);\\n    return true;\\n  }\\n\\n  /// @notice External method giving access to this functionality within a given vault\\n  /// @dev Note that this method calculates yield and interest as well\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  /// @param t Target to be transferred to\\n  /// @param a Amount of notional to be transferred\\n  function transferVaultNotional(address u, uint256 m, address t, uint256 a) external unpaused() returns (bool) {\\n    require(VaultTracker(markets[u][m].vaultAddr).transferNotionalFrom(msg.sender, t, a), \\u0027vault transfer failed\\u0027);\\n    emit TransferVaultNotional(u, m, msg.sender, t, a);\\n    return true;\\n  }\\n\\n  /// @notice Transfers notional fee to the Swivel contract without recalculating marginal interest for from\\n  /// @param u Underlying token address associated with the market\\n  /// @param m Maturity timestamp of the market\\n  /// @param f Owner of the amount\\n  /// @param a Amount to transfer\\n  function transferVaultNotionalFee(address u, uint256 m, address f, uint256 a) external authorized(swivel) returns (bool) {\\n    VaultTracker(markets[u][m].vaultAddr).transferNotionalFee(f, a);\\n    return true;\\n  }\\n\\n  /// @notice Called by admin at any point to pause / unpause market transactions\\n  /// @param b Boolean which indicates the markets paused status\\n  function pause(bool b) external authorized(admin) returns (bool) {\\n    paused = b;\\n    return true;\\n  }\\n\\n  modifier authorized(address a) {\\n    require(msg.sender == a, \\u0027sender must be authorized\\u0027);\\n    _;\\n  }\\n\\n  modifier unpaused() {\\n    require(!paused, \\u0027markets are paused\\u0027);\\n    _;\\n  }\\n}\\n\"},\"PErc20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./IPErc20.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * NOTES: This is an adaptation of the Open Zeppelin ERC20, with changes made per audit\\n * requests, and to fit overall Swivel Style. We use it specifically as the base for\\n * the Erc2612 hence the `Perc` (Permissioned erc20) naming.\\n *\\n * Dangling underscores are generally not allowed within swivel style but the \\n * internal, abstracted implementation methods inherted from the O.Z contract are maintained here.\\n * Hence, when you see a dangling underscore prefix, you know it is *only* allowed for\\n * one of these method calls. It is not allowed for any other purpose. These are:\\n     _approve\\n     _transfer\\n     _mint\\n     _burn\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n\\n\\n */\\ncontract PErc20 is IPErc20 {\\n    mapping (address =\\u003e uint256) private balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private allowances;\\n\\n    uint8 public decimals;\\n    uint256 public totalSupply;\\n    string public name; // NOTE: cannot make strings immutable\\n    string public symbol; // NOTE: see above\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     * @param n Name of the token\\n     * @param s Symbol of the token\\n     * @param d Decimals of the token\\n     */\\n    constructor (string memory n, string memory s, uint8 d) {\\n        name = n;\\n        symbol = s;\\n        decimals = d;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     * @param a Adress to fetch balance of\\n     */\\n    function balanceOf(address a) public view virtual override returns (uint256) {\\n        return balances[a];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     * @param r The recipient\\n     * @param a The amount transferred\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address r, uint256 a) public virtual override returns (bool) {\\n        _transfer(msg.sender, r, a);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     * @param o The owner\\n     * @param s The spender\\n     */\\n    function allowance(address o, address s) public view virtual override returns (uint256) {\\n        return allowances[o][s];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     * @param s The spender\\n     * @param a The amount to approve\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address s, uint256 a) public virtual override returns (bool) {\\n        _approve(msg.sender, s, a);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * @param s The sender\\n     * @param r The recipient\\n     * @param a The amount to transfer\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address s, address r, uint256 a) public virtual override returns (bool) {\\n        _transfer(s, r, a);\\n\\n        uint256 currentAllowance = allowances[s][msg.sender];\\n        require(currentAllowance \\u003e= a, \\\"erc20 transfer amount exceeds allowance\\\");\\n        _approve(s, msg.sender, currentAllowance - a);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     * @param s The spender\\n     * @param a The amount increased\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address s, uint256 a) public virtual returns (bool) {\\n        _approve(msg.sender, s, allowances[msg.sender][s] + a);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     * @param s The spender\\n     * @param a The amount subtracted\\n     * \\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address s, uint256 a) public virtual returns (bool) {\\n        uint256 currentAllowance = allowances[msg.sender][s];\\n        require(currentAllowance \\u003e= a, \\\"erc20 decreased allowance below zero\\\");\\n        _approve(msg.sender, s, currentAllowance - a);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     * @param s The sender\\n     * @param r The recipient\\n     * @param a The amount to transfer\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address s, address r, uint256 a) internal virtual {\\n        require(s != address(0), \\\"erc20 transfer from the zero address\\\");\\n        require(r != address(0), \\\"erc20 transfer to the zero address\\\");\\n\\n        uint256 senderBalance = balances[s];\\n        require(senderBalance \\u003e= a, \\\"erc20 transfer amount exceeds balance\\\");\\n        balances[s] = senderBalance - a;\\n        balances[r] += a;\\n\\n        emit Transfer(s, r, a);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     * @param r The recipient\\n     * @param a The amount to mint\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     */\\n    function _mint(address r, uint256 a) internal virtual {\\n        require(r != address(0), \\\"erc20 mint to the zero address\\\");\\n\\n        totalSupply += a;\\n        balances[r] += a;\\n        emit Transfer(address(0), r, a);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `owner`, reducing the\\n     * total supply.\\n     * @param o The owner of the amount being burned\\n     * @param a The amount to burn\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `owner` must have at least `amount` tokens.\\n     */\\n    function _burn(address o, uint256 a) internal virtual {\\n        require(o != address(0), \\\"erc20 burn from the zero address\\\");\\n\\n        uint256 accountBalance = balances[o];\\n        require(accountBalance \\u003e= a, \\\"erc20 burn amount exceeds balance\\\");\\n        balances[o] = accountBalance - a;\\n        totalSupply -= a;\\n\\n        emit Transfer(o, address(0), a);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     * @param o The owner\\n     * @param s The spender\\n     * @param a The amount\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address o, address s, uint256 a) internal virtual {\\n        require(o != address(0), \\\"erc20 approve from the zero address\\\");\\n        require(s != address(0), \\\"erc20 approve to the zero address\\\");\\n\\n        allowances[o][s] = a;\\n        emit Approval(o, s, a);\\n    }\\n}\\n\"},\"VaultTracker.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./Interfaces.sol\\\";\\n\\ncontract VaultTracker {\\n  struct Vault {\\n    uint256 notional;\\n    uint256 redeemable;\\n    uint256 exchangeRate;\\n  }\\n\\n  mapping(address =\\u003e Vault) public vaults;\\n\\n  address public immutable admin;\\n  address public immutable cTokenAddr;\\n  address public immutable swivel;\\n  uint256 public immutable maturity;\\n  uint256 public maturityRate;\\n\\n  /// @param m Maturity timestamp of the new market\\n  /// @param c cToken address associated with underlying for the new market\\n  /// @param s address of the deployed swivel contract\\n  constructor(uint256 m, address c, address s) {\\n    admin = msg.sender;\\n    maturity = m;\\n    cTokenAddr = c;\\n    swivel = s;\\n\\n    // instantiate swivel\\u0027s vault (unblocking transferNotionalFee)\\n    vaults[s] = Vault({\\n      notional: 0,\\n      redeemable: 0,\\n      exchangeRate: CErc20(c).exchangeRateCurrent()\\n    });\\n  }\\n\\n  /// @notice Adds notional to a given address\\n  /// @param o Address that owns a vault\\n  /// @param a Amount of notional added\\n  function addNotional(address o, uint256 a) external authorized(admin) returns (bool) {\\n    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();\\n\\n    Vault memory vlt = vaults[o];\\n\\n    if (vlt.notional \\u003e 0) {\\n      uint256 yield;\\n\\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\\n      if (maturityRate \\u003e 0) { // Calculate marginal interest\\n        yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\\n      } else {\\n        yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\\n      }\\n\\n      uint256 interest = (yield * vlt.notional) / 1e26;\\n      // add interest and amount to position, reset cToken exchange rate\\n      vlt.redeemable += interest;\\n      vlt.notional += a;\\n    } else {\\n      vlt.notional = a;\\n    }\\n\\n    vlt.exchangeRate = exchangeRate;\\n    vaults[o] = vlt;\\n\\n    return true;\\n  }\\n\\n  /// @notice Removes notional from a given address\\n  /// @param o Address that owns a vault\\n  /// @param a Amount of notional to remove\\n  function removeNotional(address o, uint256 a) external authorized(admin) returns (bool) {\\n\\n    Vault memory vlt = vaults[o];\\n\\n    require(vlt.notional \\u003e= a, \\\"amount exceeds vault balance\\\");\\n\\n    uint256 yield;\\n    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();\\n\\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\\n    if (maturityRate \\u003e 0) { // Calculate marginal interest\\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\\n    } else {\\n      // calculate marginal interest\\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\\n    }\\n\\n    uint256 interest = (yield * vlt.notional) / 1e26;\\n    // remove amount from position, Add interest to position, reset cToken exchange rate\\n    vlt.redeemable += interest;\\n    vlt.notional -= a;\\n    vlt.exchangeRate = exchangeRate;\\n\\n    vaults[o] = vlt;\\n\\n    return true;\\n  }\\n\\n  /// @notice Redeem\\u0027s interest accrued by a given address\\n  /// @param o Address that owns a vault\\n  function redeemInterest(address o) external authorized(admin) returns (uint256) {\\n\\n    Vault memory vlt = vaults[o];\\n\\n    uint256 redeemable = vlt.redeemable;\\n    uint256 yield;\\n    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();\\n\\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\\n    if (maturityRate \\u003e 0) { // Calculate marginal interest\\n      yield = ((maturityRate * 1e26) / vlt.exchangeRate) - 1e26;\\n    } else {\\n      // calculate marginal interest\\n      yield = ((exchangeRate * 1e26) / vlt.exchangeRate) - 1e26;\\n    }\\n\\n    uint256 interest = (yield * vlt.notional) / 1e26;\\n\\n    vlt.exchangeRate = exchangeRate;\\n    vlt.redeemable = 0;\\n\\n    vaults[o] = vlt;\\n\\n    // return adds marginal interest to previously accrued redeemable interest\\n    return (redeemable + interest);\\n  }\\n\\n  /// @notice Matures the vault\\n  /// @param c The current cToken exchange rate\\n  function matureVault(uint256 c) external authorized(admin) returns (bool) {\\n    maturityRate = c;\\n    return true;\\n  }\\n\\n  /// @notice Transfers notional from one address to another\\n  /// @param f Owner of the amount\\n  /// @param t Recipient of the amount\\n  /// @param a Amount to transfer\\n  function transferNotionalFrom(address f, address t, uint256 a) external authorized(admin) returns (bool) {\\n    require(f != t, \\u0027cannot transfer notional to self\\u0027);\\n\\n    Vault memory from = vaults[f];\\n    Vault memory to = vaults[t];\\n\\n    require(from.notional \\u003e= a, \\\"amount exceeds available balance\\\");\\n\\n    uint256 yield;\\n    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();\\n\\n    // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\\n    // otherwise, calculate marginal exchange rate between current and previous exchange rate.\\n    if (maturityRate \\u003e 0) { \\n      // calculate marginal interest\\n      yield = ((maturityRate * 1e26) / from.exchangeRate) - 1e26;\\n    } else {\\n      yield = ((exchangeRate * 1e26) / from.exchangeRate) - 1e26;\\n    }\\n\\n    uint256 interest = (yield * from.notional) / 1e26;\\n    // remove amount from position, Add interest to position, reset cToken exchange rate\\n    from.redeemable += interest;\\n    from.notional -= a;\\n    from.exchangeRate = exchangeRate;\\n\\n    vaults[f] = from;\\n\\n    // transfer notional to address \\\"t\\\", calculate interest if necessary\\n    if (to.notional \\u003e 0) {\\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\\n      if (maturityRate \\u003e 0) { \\n        // calculate marginal interest\\n        yield = ((maturityRate * 1e26) / to.exchangeRate) - 1e26;\\n      } else {\\n        yield = ((exchangeRate * 1e26) / to.exchangeRate) - 1e26;\\n      }\\n\\n      uint256 newVaultInterest = (yield * to.notional) / 1e26;\\n      // add interest and amount to position, reset cToken exchange rate\\n      to.redeemable += newVaultInterest;\\n      to.notional += a;\\n    } else {\\n      to.notional = a;\\n    }\\n\\n    to.exchangeRate = exchangeRate;\\n    vaults[t] = to;\\n\\n    return true;\\n  }\\n\\n  /// @notice Transfers, in notional, a fee payment to the Swivel contract without recalculating marginal interest for the owner\\n  /// @param f Owner of the amount\\n  /// @param a Amount to transfer\\n  function transferNotionalFee(address f, uint256 a) external authorized(admin) returns(bool) {\\n    Vault memory oVault = vaults[f];\\n    Vault memory sVault = vaults[swivel];\\n\\n    // remove notional from its owner\\n    oVault.notional -= a;\\n\\n    uint256 exchangeRate = CErc20(cTokenAddr).exchangeRateCurrent();\\n    uint256 yield;\\n\\n    // check if exchangeRate has been stored already this block. If not, calculate marginal interest + store exchangeRate\\n    if (sVault.exchangeRate != exchangeRate) {\\n      // if market has matured, calculate marginal interest between the maturity rate and previous position exchange rate\\n      // otherwise, calculate marginal exchange rate between current and previous exchange rate.\\n      if (maturityRate \\u003e 0) { \\n        // calculate marginal interest\\n          yield = ((maturityRate * 1e26) / sVault.exchangeRate) - 1e26;\\n      } else {\\n          yield = ((exchangeRate * 1e26) / sVault.exchangeRate) - 1e26;\\n      }\\n      uint256 interest = (yield * sVault.notional) / 1e26;\\n      // add interest and amount, reset cToken exchange rate\\n      sVault.redeemable += interest;\\n      sVault.exchangeRate = exchangeRate;\\n    }\\n    // add notional to swivel\\u0027s vault\\n    sVault.notional += a;\\n    // store the adjusted vaults\\n    vaults[swivel] = sVault;\\n    vaults[f] = oVault;\\n    return true;\\n  }\\n\\n  /// @notice Returns both relevant balances for a given user\\u0027s vault\\n  /// @param o Address that owns a vault\\n  function balancesOf(address o) external view returns (uint256, uint256) {\\n    Vault memory vault = vaults[o];\\n    return (vault.notional, vault.redeemable);\\n  }\\n\\n  modifier authorized(address a) {\\n    require(msg.sender == a, \\u0027sender must be authorized\\u0027);\\n    _;\\n  }\\n}\\n\"},\"ZcToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// NOTE: whomever decided methods which are the implementation of a stated interface\\n//       need to be labeled \\u0027override\\u0027 should to be publicly flogged.\\n\\npragma solidity 0.8.4;\\n\\nimport \\u0027./Erc2612.sol\\u0027;\\nimport \\u0027./IZcToken.sol\\u0027;\\n\\n/// NOTE the OZStlye naming conventions are kept for the internal methods\\n/// _burn and _mint as dangling underscores are generally not allowed.\\ncontract ZcToken is Erc2612, IZcToken {\\n  address public immutable admin;\\n  address public immutable underlying;\\n  uint256 public immutable maturity;\\n\\n  /// @param u Underlying\\n  /// @param m Maturity\\n  /// @param n Name\\n  /// @param s Symbol\\n  /// @param d Decimals\\n  constructor(address u, uint256 m, string memory n, string memory s, uint8 d) Erc2612(n, s, d) {\\n    admin = msg.sender;  \\n    underlying = u;\\n    maturity = m;\\n  }\\n  \\n  /// @param f Address to burn from\\n  /// @param a Amount to burn\\n  function burn(address f, uint256 a) external onlyAdmin(admin) override returns(bool) {\\n      _burn(f, a);\\n      return true;\\n  }\\n\\n  /// @param t Address recieving the minted amount\\n  /// @param a The amount to mint\\n  function mint(address t, uint256 a) external onlyAdmin(admin) override returns(bool) {\\n      _mint(t, a);\\n      return true;\\n  }\\n\\n  /// @param a Admin address\\n  modifier onlyAdmin(address a) {\\n    require(msg.sender == a, \\u0027sender must be admin\\u0027);\\n    _;\\n  }\\n}\\n\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"zcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vaultTracker\",\"type\":\"address\"}],\"name\":\"Create\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"zcTarget\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nTarget\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CustodialExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"zcTarget\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nTarget\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CustodialInitiate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maturityRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"matured\",\"type\":\"uint256\"}],\"name\":\"Mature\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"P2pVaultExchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"P2pZcTokenExchange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RedeemVaultInterest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RedeemZcToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferVaultNotional\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"burnZcTokenRemovingNotional\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"cTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"c\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"n\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"s\",\"type\":\"string\"}],\"name\":\"createMarket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"z\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"n\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"custodialExit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"z\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"n\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"custodialInitiate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"markets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"cTokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zcTokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maturityRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"}],\"name\":\"matureMarket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"mintZcTokenAddingNotional\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"p2pVaultExchange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"p2pZcTokenExchange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"redeemVaultInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"redeemZcToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"s\",\"type\":\"address\"}],\"name\":\"setSwivelAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swivel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"transferVaultNotional\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"m\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"f\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"transferVaultNotionalFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MarketPlace","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"7000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://cc5eba73f6a76090420d154c81232914e1c3917a54b40a027c2e8a51d29ba4d9"}]}