{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/vesting/AdvisorsVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract AdvisorsVesting {\\n\\n    uint256 immutable private tokens;\\n    address immutable private icomToken;\\n    address immutable private owner;\\n\\n    uint256 constant private FIRST_STEP = 500000000000000000;\\n    uint256 constant private SECOND_STEP = 750000000000000000;\\n    uint256 constant private THIRD_STEP = 1000000000000000000;\\n\\n    address[8] private advisorsWallet;\\n    uint16[8] private percentages;\\n    uint32 public listingDate;\\n    bool[3] private unlockedTranche;\\n\\n    uint32 constant private MAX_LISTING_DATE = 1672441200;  // 2022/12/31 00:00:00\\n\\n    event advisorTokensSent(uint256 _amount);\\n\\n    constructor(address _icomToken, address[] memory _advisorsWallet, uint16[] memory _percentages, uint256 _tokens) {\\n        icomToken = _icomToken;\\n        tokens = _tokens;\\n        owner = msg.sender;\\n\\n        for (uint256 i=0; i< _advisorsWallet.length; i++) {\\n            advisorsWallet[i] = _advisorsWallet[i];\\n            percentages[i] = _percentages[i];\\n        }\\n    }\\n\\n    function setListingDate(uint32 _listingDate) external {\\n        require(msg.sender == owner, \\\"OnlyOwner\\\");\\n        require(_listingDate < MAX_LISTING_DATE, \\\"CantDelayMoreListing\\\");\\n        require(block.timestamp < _listingDate, \\\"CantListInPast\\\");\\n\\n        listingDate = _listingDate;\\n    }\\n\\n    function withdrawTokens(bytes calldata _params, bytes calldata _messageLength, bytes calldata _signature) external {\\n        uint256 unlockPercentage = _checkPrice(_params, _messageLength, _signature);\\n        require(block.timestamp >= listingDate + 150 days || unlockPercentage > 0, \\\"CantWithdrawYet\\\");\\n\\n        if (block.timestamp >= listingDate + 150 days) {\\n            uint256 balance = IERC20(icomToken).balanceOf(address(this));\\n            _sendTokens(balance);\\n        } else {\\n            uint256 amount = tokens * unlockPercentage / 100;\\n            _sendTokens(amount);\\n        }\\n    }\\n\\n    function _checkPrice(bytes calldata _params, bytes calldata _messageLength, bytes calldata _signature) internal returns(uint256) {\\n        address _signer = _decodeSignature(_params, _messageLength, _signature);\\n        require(_signer == owner, \\\"BadSigner\\\");\\n    \\n        (, uint256 _price) = abi.decode(_params, (uint256, uint256));\\n        return _unlockedPercentage(_price);\\n    }\\n\\n    function _unlockedPercentage(uint256 _price) internal returns(uint256) {\\n        uint256 percentage = 0;\\n        if ((_price >= FIRST_STEP) && (unlockedTranche[0] == false)) {\\n            percentage += 35;\\n            unlockedTranche[0] = true;\\n        } else if ((_price >= SECOND_STEP) && (unlockedTranche[1] == false)) {\\n            percentage += 35;\\n            unlockedTranche[1] = true;\\n        } else if ((_price >= THIRD_STEP) && (unlockedTranche[2] == false)) {\\n            percentage += 30;\\n            unlockedTranche[2] = true;\\n        }\\n\\n        return percentage;\\n    }\\n\\n    function _sendTokens(uint256 _amount) internal {\\n        for (uint256 i = 0; i< advisorsWallet.length; i++) {\\n            IERC20(icomToken).transfer(advisorsWallet[i], _amount * percentages[i] / 1000);\\n        }\\n        \\n        emit advisorTokensSent(_amount);\\n    }\\n\\n    function _decodeSignature(bytes memory _message, bytes memory _messageLength, bytes memory _signature) internal pure returns (address) {\\n        if (_signature.length != 65) return (address(0));\\n\\n        bytes32 messageHash = keccak256(abi.encodePacked(hex\\\"19457468657265756d205369676e6564204d6573736167653a0a\\\", _messageLength, _message));\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        assembly {\\n            r := mload(add(_signature, 0x20))\\n            s := mload(add(_signature, 0x40))\\n            v := byte(0, mload(add(_signature, 0x60)))\\n        }\\n\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) return address(0);\\n\\n        if (v != 27 && v != 28) return address(0);\\n        \\n        return ecrecover(messageHash, v, r, s);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_icomToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_advisorsWallet\",\"type\":\"address[]\"},{\"internalType\":\"uint16[]\",\"name\":\"_percentages\",\"type\":\"uint16[]\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"advisorTokensSent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"listingDate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_listingDate\",\"type\":\"uint32\"}],\"name\":\"setListingDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_messageLength\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AdvisorsVesting","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000010be237ba3d3d8c87731e68ee854fc98e3705f0e00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000069e10de76676d080000000000000000000000000000000000000000000000000000000000000000000007000000000000000000000000bdb9ae7678108c302684d6ef61ad874e023fa8490000000000000000000000003a778b86ce3ac006bb9614ceb55d5e43560178240000000000000000000000006415fcbccbbcf5bbe465ace609a9f9d9c5bf25bb0000000000000000000000005257df5e76abf6d6838b97c5020d5c206317746e000000000000000000000000b01c208e874a183720c41a5e9fa298d68cb629a30000000000000000000000008cd407cf0652f23944eac2b75851e10033d1efba000000000000000000000000014c9fbe4018cd8546d04f1a9ffd9f2b2aaf171f0000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000012c00000000000000000000000000000000000000000000000000000000000000fa000000000000000000000000000000000000000000000000000000000000007d000000000000000000000000000000000000000000000000000000000000007d0000000000000000000000000000000000000000000000000000000000000023000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000000000000000000000000000000000000000007d0000000000000000000000000000000000000000000000000000000000000019","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}