{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FUM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"erc20permit/contracts/ERC20Permit.sol\\\";\\nimport \\\"./IUSM.sol\\\";\\nimport \\\"./OptOutable.sol\\\";\\nimport \\\"./MinOut.sol\\\";\\n\\n\\n/**\\n * @title FUM Token\\n * @author Alberto Cuesta CaÃ±ada, Jacob Eliosoff, Alex Roan\\n *\\n * @notice This should be created and owned by the USM instance.\\n */\\ncontract FUM is ERC20Permit, OptOutable {\\n    IUSM public immutable usm;\\n\\n    constructor(address[] memory optedOut_)\\n        ERC20Permit(\\\"Minimalist Funding v1.0 - Test 5\\\", \\\"FUMTest\\\")\\n        OptOutable(optedOut_)\\n    {\\n        usm = IUSM(msg.sender);     // FUM constructor can only be called by a USM instance\\n    }\\n\\n    /**\\n     * @notice If anyone sends ETH here, assume they intend it as a `fund`.  If decimals 8 to 11 (inclusive) of the amount of\\n     * ETH received are `0000`, then the next 7 will be parsed as the minimum number of FUM accepted per input ETH, with the\\n     * 7-digit number interpreted as \\\"hundredths of a FUM\\\".  See comments in `MinOut`.\\n     */\\n    receive() external payable {\\n        usm.fund{ value: msg.value }(msg.sender, MinOut.parseMinTokenOut(msg.value));\\n    }\\n\\n    /**\\n     * @notice If a user sends FUM tokens directly to this contract (or to the USM contract), assume they intend it as a\\n     * `defund`.  If using `transfer`/`transferFrom` as `defund`, and if decimals 8 to 11 (inclusive) of the amount transferred\\n     * are `0000`, then the next 7 will be parsed as the maximum number of FUM tokens sent per ETH received, with the 7-digit\\n     * number interpreted as \\\"hundredths of a FUM\\\".  See comments in `MinOut`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal override noOptOut(recipient) returns (bool) {\\n        if (recipient == address(this) || recipient == address(usm) || recipient == address(0)) {\\n            usm.defund(sender, payable(sender), amount, MinOut.parseMinEthOut(amount));\\n        } else {\\n            super._transfer(sender, recipient, amount);\\n        }\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Mint new FUM to the _recipient\\n     *\\n     * @param _recipient address to mint to\\n     * @param _amount amount to mint\\n     */\\n    function mint(address _recipient, uint _amount) external {\\n        require(msg.sender == address(usm), \\\"Only USM\\\");\\n        _mint(_recipient, _amount);\\n    }\\n\\n    /**\\n     * @notice Burn FUM from _holder\\n     *\\n     * @param _holder address to burn from\\n     * @param _amount amount to burn\\n     */\\n    function burn(address _holder, uint _amount) external {\\n        require(msg.sender == address(usm), \\\"Only USM\\\");\\n        _burn(_holder, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"erc20permit/contracts/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\\npragma solidity ^0.8.0;\\n\\nimport \\\"acc-erc20/contracts/ERC20.sol\\\";\\nimport \\\"./IERC2612.sol\\\";\\n\\n/**\\n * @author Georgios Konstantopoulos\\n * @dev Extension of {ERC20} that allows token holders to use their tokens\\n * without sending any transactions by setting {IERC20-allowance} with a\\n * signature using the {permit} method, and then spend them via\\n * {IERC20-transferFrom}.\\n *\\n * The {permit} signature mechanism conforms to the {IERC2612} interface.\\n */\\nabstract contract ERC20Permit is ERC20, IERC2612 {\\n    mapping (address => uint256) public override nonces;\\n\\n    bytes32 public immutable PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public immutable DOMAIN_SEPARATOR;\\n\\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name_)),\\n                keccak256(bytes(version())),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /// @dev Setting the version as a function so that it can be overriden\\n    function version() public pure virtual returns(string memory) { return \\\"1\\\"; }\\n\\n    /**\\n     * @dev See {IERC2612-permit}.\\n     *\\n     * In cases where the free option is not a concern, deadline can simply be\\n     * set to uint(-1), so it should be seen as an optional parameter\\n     */\\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public virtual override {\\n        require(deadline >= block.timestamp, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 hashStruct = keccak256(\\n            abi.encode(\\n                PERMIT_TYPEHASH,\\n                owner,\\n                spender,\\n                amount,\\n                nonces[owner]++,\\n                deadline\\n            )\\n        );\\n\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                DOMAIN_SEPARATOR,\\n                hashStruct\\n            )\\n        );\\n\\n        address signer = ecrecover(hash, v, r, s);\\n        require(\\n            signer != address(0) && signer == owner,\\n            \\\"ERC20Permit: invalid signature\\\"\\n        );\\n\\n        _approve(owner, spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IUSM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"acc-erc20/contracts/IERC20.sol\\\";\\nimport \\\"./oracles/Oracle.sol\\\";\\n\\nabstract contract IUSM is IERC20, Oracle {\\n    event UnderwaterStatusChanged(bool underwater);\\n    event BidAskAdjustmentChanged(uint adjustment);\\n    event PriceChanged(uint timestamp, uint price);\\n\\n    enum Side {Buy, Sell}\\n\\n    // ____________________ External transactional functions ____________________\\n\\n    /**\\n     * @notice Mint new USM, sending it to the given address, and only if the amount minted >= `minUsmOut`.  The amount of ETH\\n     * is passed in as `msg.value`.\\n     * @param to address to send the USM to.\\n     * @param minUsmOut Minimum accepted USM for a successful mint.\\n     */\\n    function mint(address to, uint minUsmOut) external virtual payable returns (uint usmOut);\\n\\n    /**\\n     * @dev Burn USM in exchange for ETH.\\n     * @param from address to deduct the USM from.\\n     * @param to address to send the ETH to.\\n     * @param usmToBurn Amount of USM to burn.\\n     * @param minEthOut Minimum accepted ETH for a successful burn.\\n     */\\n    function burn(address from, address payable to, uint usmToBurn, uint minEthOut) external virtual returns (uint ethOut);\\n\\n    /**\\n     * @notice Funds the pool with ETH, minting new FUM and sending it to the given address, but only if the amount minted >=\\n     * `minFumOut`.  The amount of ETH is passed in as `msg.value`.\\n     * @param to address to send the FUM to.\\n     * @param minFumOut Minimum accepted FUM for a successful fund.\\n     */\\n    function fund(address to, uint minFumOut) external virtual payable returns (uint fumOut);\\n\\n    /**\\n     * @notice Defunds the pool by redeeming FUM in exchange for equivalent ETH from the pool.\\n     * @param from address to deduct the FUM from.\\n     * @param to address to send the ETH to.\\n     * @param fumToBurn Amount of FUM to burn.\\n     * @param minEthOut Minimum accepted ETH for a successful defund.\\n     */\\n    function defund(address from, address payable to, uint fumToBurn, uint minEthOut) external virtual returns (uint ethOut);\\n\\n    // ____________________ Public informational view functions ____________________\\n\\n    /**\\n     * @notice Total amount of ETH in the pool (ie, in the contract).\\n     * @return pool ETH pool\\n     */\\n    function ethPool() public virtual view returns (uint pool);\\n\\n    /**\\n     * @notice Total amount of ETH in the pool (ie, in the contract).\\n     * @return supply the total supply of FUM.  Users of this `IUSM` interface, like `USMView`, need to call this rather than\\n     * `usm.fum().totalSupply()` directly, because `IUSM` doesn't (and shouldn't) know about the `FUM` type.\\n     */\\n    function fumTotalSupply() public virtual view returns (uint supply);\\n\\n    /**\\n     * @notice The current bid/ask adjustment, equal to the stored value decayed over time towards its stable value, 1.  This\\n     * adjustment is intended as a measure of \\\"how long-ETH recent user activity has been\\\", so that we can slide price\\n     * accordingly: if recent activity was mostly long-ETH (`fund()` and `burn()`), raise FUM buy price/reduce USM sell price;\\n     * if recent activity was short-ETH (`defund()` and `mint()`), reduce FUM sell price/raise USM buy price.\\n     * @return adjustment The sliding-price bid/ask adjustment\\n     */\\n    function bidAskAdjustment() public virtual view returns (uint adjustment);\\n\\n    function timeSystemWentUnderwater() public virtual view returns (uint timestamp);\\n\\n    function isDuringPrefund() public virtual view returns (bool duringPrefund);\\n\\n    // ____________________ Public helper pure functions (for functions above) ____________________\\n\\n    /**\\n     * @notice Calculate the amount of ETH in the buffer.\\n     * @return buffer ETH buffer\\n     */\\n    function ethBuffer(uint ethUsdPrice, uint ethInPool, uint usmSupply, bool roundUp) public virtual pure returns (int buffer);\\n\\n    /**\\n     * @notice Calculate debt ratio for a given eth to USM price: ratio of the outstanding USM (amount of USM in total supply),\\n     * to the current ETH pool value in USD (ETH qty * ETH/USD price).\\n     * @return ratio Debt ratio (or 0 if there's currently 0 ETH in the pool/price = 0: these should never happen after launch)\\n     */\\n    function debtRatio(uint ethUsdPrice, uint ethInPool, uint usmSupply) public virtual pure returns (uint ratio);\\n\\n    /**\\n     * @notice Convert ETH amount to USM using a ETH/USD price.\\n     * @param ethAmount The amount of ETH to convert\\n     * @return usmOut The amount of USM\\n     */\\n    function ethToUsm(uint ethUsdPrice, uint ethAmount, bool roundUp) public virtual pure returns (uint usmOut);\\n\\n    /**\\n     * @notice Convert USM amount to ETH using a ETH/USD price.\\n     * @param usmAmount The amount of USM to convert\\n     * @return ethOut The amount of ETH\\n     */\\n    function usmToEth(uint ethUsdPrice, uint usmAmount, bool roundUp) public virtual pure returns (uint ethOut);\\n\\n    /**\\n     * @return price The ETH/USD price, adjusted by the `bidAskAdjustment` (if applicable) for the given buy/sell side.\\n     */\\n    function adjustedEthUsdPrice(Side side, uint ethUsdPrice, uint adjustment) public virtual pure returns (uint price);\\n\\n    /**\\n     * @notice Calculate the *marginal* price of USM (in ETH terms): that is, of the next unit, before the price start sliding.\\n     * @return price USM price in ETH terms\\n     */\\n    function usmPrice(Side side, uint ethUsdPrice) public virtual pure returns (uint price);\\n\\n    /**\\n     * @notice Calculate the *marginal* price of FUM (in ETH terms): that is, of the next unit, before the price starts rising.\\n     * @param usmEffectiveSupply should be either the actual current USM supply, or, when calculating the FUM *buy* price, the\\n     * return value of `usmSupplyForFumBuys()`.\\n     * @return price FUM price in ETH terms\\n     */\\n    function fumPrice(Side side, uint ethUsdPrice, uint ethInPool, uint usmEffectiveSupply, uint fumSupply, bool prefund) public virtual pure returns (uint price);\\n\\n    /**\\n     * @return timeSystemWentUnderwater_ The time at which we first detected the system was underwater (debt ratio >\\n     * `MAX_DEBT_RATIO`), based on the current oracle price and pool ETH and USM; or 0 if we're not currently underwater.\\n     * @return usmSupplyForFumBuys The current supply of USM *for purposes of calculating the FUM buy price,* and therefore\\n     * for `fumFromFund()`.  The \\\"supply for FUM buys\\\" is the *lesser* of the actual current USM supply, and the USM amount\\n     * that would make debt ratio = `MAX_DEBT_RATIO`.  Example:\\n     *\\n     * 1. Suppose the system currently contains 50 ETH at price $1,000 (total pool value: $50,000), with an actual USM supply\\n     *    of 30,000 USM.  Then debt ratio = 30,000 / $50,000 = 60%: < MAX 80%, so `usmSupplyForFumBuys` = 30,000.\\n     * 2. Now suppose ETH/USD halves to $500.  Then pool value halves to $25,000, and debt ratio doubles to 120%.  Now\\n     *    `usmSupplyForFumBuys` instead = 20,000: the USM quantity at which debt ratio would equal 80% (20,000 / $25,000).\\n     *    (Call this the \\\"80% supply\\\".)\\n     * 3. ...Except, we also gradually increase the supply over time while we remain underwater.  This has the effect of\\n     *    *reducing* the FUM buy price inferred from that supply (higher JacobUSM supply -> smaller buffer -> lower FUM price).\\n     *    The math we use gradually increases the supply from its initial \\\"80% supply\\\" value, where debt ratio =\\n     *    `MAX_DEBT_RATIO` (20,000 above), to a theoretical maximum \\\"100% supply\\\" value, where debt ratio = 100% (in the $500\\n     *    example above, this would be 25,000).  (Or the actual supply, whichever is lower: we never increase\\n     *    `usmSupplyForFumBuys` above `usmActualSupply`.)  The climb from the initial 80% supply (20,000) to the 100% supply\\n     *    (25,000) is at a rate that brings it \\\"halfway closer per `MIN_FUM_BUY_PRICE_HALF_LIFE` (eg, 1 day)\\\": so three days\\n     *    after going underwater, the supply returned will be 25,000 - 0.5**3 * (25,000 - 20,000) = 24,375.\\n     */\\n    function checkIfUnderwater(uint usmActualSupply, uint ethPool_, uint ethUsdPrice, uint oldTimeUnderwater, uint currentTime) public virtual pure returns (uint timeSystemWentUnderwater_, uint usmSupplyForFumBuys, uint debtRatio_);\\n}\\n\"\r\n    },\r\n    \"contracts/OptOutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\n\\n/**\\n * A general type of contract with a behavior that using contracts can \\\"opt out of\\\".  The practical motivation is, when we have\\n * multiple versions of a token (eg, USMv1 and USMv2), and support \\\"mint/burn via send\\\" - sending ETH/tokens mints/burns tokens\\n * (respectively), there's a UX risk that users might accidentally send (eg) USMv1 tokens to the USMv2 address: resulting in\\n * not a burn (returning ETH), but just the tokens being permanently lost with no ETH sent back in exchange.\\n *\\n * To avoid this, we want the USMv1 contract to be able to \\\"opt out\\\" of receiving USMv2 tokens, and vice versa:\\n *\\n *     1. During creation of USMv2, the address of USMv1 is included in the `optedOut_` argument to the USMv2 constructor.\\n *     2. This puts USMv1 in USMv2's `optedOut` state variable.\\n *     3. Then, if someone accidentally tries to send USMv1 tokens to the USMv2 address, the `_transfer()` call fails, rather\\n *        than the USMv1 tokens being permanently lost.\\n *     4. And to handle the reverse case, USMv2's constructor can call `USMv1.optOut()`, so that sends of USMv2 tokens to the\\n *        USMv1 address also fail cleanly.  (USMv2 couldn't be passed to USMv1's constructor, because USMv2 didn't exist yet!)\\n *\\n * See also https://github.com/usmfum/USM/issues/88 and https://github.com/usmfum/USM/pull/93.\\n *\\n * Note that this would be prone to abuse if users could call `optOut()` on *other* contracts: so we only let a contract opt\\n * *itself* out, ie, `optOut()` takes no argument.  (Or it could be passed to the constructor of the `OptOutable`-implementing\\n * contract.)\\n */\\nabstract contract OptOutable {\\n    event OptOutStatusChanged(address indexed user, bool newStatus);\\n\\n    mapping(address => bool) public optedOut;  // true = address opted out of something\\n\\n    constructor(address[] memory optedOut_) {\\n        for (uint i = 0; i < optedOut_.length; i++) {\\n            optedOut[optedOut_[i]] = true;\\n        }\\n    }\\n\\n    modifier noOptOut(address target) {\\n        require(!optedOut[target], \\\"Target opted out\\\");\\n        _;\\n    }\\n\\n    function optOut() public virtual {\\n        if (!optedOut[msg.sender]) {\\n            optedOut[msg.sender] = true;\\n            emit OptOutStatusChanged(msg.sender, true);\\n        }\\n    }\\n\\n    function optBackIn() public virtual {\\n        if (optedOut[msg.sender]) {\\n            optedOut[msg.sender] = false;\\n            emit OptOutStatusChanged(msg.sender, false);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MinOut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nlibrary MinOut {\\n    uint public constant ZEROES_PLUS_LIMIT_PRICE_DIGITS = 1e11; // 4 digits all 0s, + 7 digits to specify the limit price\\n    uint public constant LIMIT_PRICE_DIGITS = 1e7;              // 7 digits to specify the limit price (unscaled)\\n    uint public constant LIMIT_PRICE_SCALING_FACTOR = 100;      // So, last 7 digits \\\"1234567\\\" / 100 = limit price 12345.67\\n\\n    function parseMinTokenOut(uint ethIn) internal pure returns (uint minTokenOut) {\\n        uint minPrice = ethIn % ZEROES_PLUS_LIMIT_PRICE_DIGITS;\\n        if (minPrice != 0 && minPrice < LIMIT_PRICE_DIGITS) {\\n            minTokenOut = ethIn * minPrice / LIMIT_PRICE_SCALING_FACTOR;\\n        }\\n    }\\n\\n    function parseMinEthOut(uint tokenIn) internal pure returns (uint minEthOut) {\\n        uint maxPrice = tokenIn % ZEROES_PLUS_LIMIT_PRICE_DIGITS;\\n        if (maxPrice != 0 && maxPrice < LIMIT_PRICE_DIGITS) {\\n            minEthOut = tokenIn * LIMIT_PRICE_SCALING_FACTOR / maxPrice;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"acc-erc20/contracts/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Inspired on token.sol from DappHub\\n\\npragma solidity  ^0.8.0;\\nimport \\\"./IERC20.sol\\\";\\n\\ncontract ERC20 is IERC20 {\\n    uint256                                           internal  _totalSupply;\\n    mapping (address => uint256)                      internal  _balanceOf;\\n    mapping (address => mapping (address => uint256)) internal  _allowance;\\n    string                                            public    symbol;\\n    uint256                                           public    decimals = 18; // standard token precision. override to customize\\n    string                                            public    name = \\\"\\\";     // Optional token name\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        name = name_;\\n        symbol = symbol_;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address guy) public view virtual override returns (uint256) {\\n        return _balanceOf[guy];\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowance[owner][spender];\\n    }\\n\\n    function approve(address spender, uint wad) public virtual override returns (bool) {\\n        return _approve(msg.sender, spender, wad);\\n    }\\n\\n    function transfer(address dst, uint wad) public virtual override returns (bool) {\\n        return _transfer(msg.sender, dst, wad);\\n    }\\n\\n    function transferFrom(address src, address dst, uint wad) public virtual override returns (bool) {\\n        uint256 allowed = _allowance[src][msg.sender];\\n        if (src != msg.sender && allowed != type(uint).max) {\\n            require(allowed >= wad, \\\"ERC20: Insufficient approval\\\");\\n            _approve(src, msg.sender, allowed - wad);\\n        }\\n\\n        return _transfer(src, dst, wad);\\n    }\\n\\n    function _transfer(address src, address dst, uint wad) internal virtual returns (bool) {\\n        require(_balanceOf[src] >= wad, \\\"ERC20: Insufficient balance\\\");\\n        _balanceOf[src] = _balanceOf[src] - wad;\\n        _balanceOf[dst] = _balanceOf[dst] + wad;\\n\\n        emit Transfer(src, dst, wad);\\n\\n        return true;\\n    }\\n\\n    function _approve(address owner, address spender, uint wad) internal virtual returns (bool) {\\n        _allowance[owner][spender] = wad;\\n        emit Approval(owner, spender, wad);\\n        return true;\\n    }\\n\\n    function _mint(address dst, uint wad) internal virtual {\\n        _balanceOf[dst] = _balanceOf[dst] + wad;\\n        _totalSupply = _totalSupply + wad;\\n        emit Transfer(address(0), dst, wad);\\n    }\\n\\n    function _burn(address src, uint wad) internal virtual {\\n        require(_balanceOf[src] >= wad, \\\"ERC20: Insufficient balance\\\");\\n        _balanceOf[src] = _balanceOf[src] - wad;\\n        _totalSupply = _totalSupply - wad;\\n        emit Transfer(src, address(0), wad);\\n    }\\n}\"\r\n    },\r\n    \"erc20permit/contracts/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\n *\\n * Adds the {permit} method, which can be used to change one's\\n * {IERC20-allowance} without having to send a transaction, by signing a\\n * message. This allows users to spend tokens without having to hold Ether.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\n */\\ninterface IERC2612 {\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /**\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"acc-erc20/contracts/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    },\r\n    \"contracts/oracles/Oracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nabstract contract Oracle {\\n    /**\\n     * @return price WAD-scaled - 18 dec places\\n     * @return updateTime The last time the price was updated.  This is a bit subtle: `price` can change without `updateTime`\\n     * changing.  Suppose, eg, the current Uniswap v3 TWAP price over the last 10 minutes is $3,000, and then Uniswap records a\\n     * new trade observation at a price of $2,980.  This will nudge the 10-minute TWAP slightly below $3,000, and reset\\n     * `updateTime` to the new trade's time.  However, over the subsequent 10 minutes, the 10-minute TWAP will continue to\\n     * decrease, as more and more of \\\"the last 10 minutes\\\" is at $2,980 rather than $3,000: but because this gradual price\\n     * change is only driven by the passage of time, not by any new price observations, it will *not* change `updateTime`,\\n     * which will remain at the time of the $2,980 trade until another trade occurs.\\n     */\\n    function latestPrice() public virtual view returns (uint price, uint updateTime);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"optedOut_\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"OptOutStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"guy\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optBackIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"optedOut\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usm\",\"outputs\":[{\"internalType\":\"contract IUSM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"FUM","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000200000000000000000000000003eb7ce2907e202bb70bae3d7b0c588573d3cecc000000000000000000000000f04a5d82ff8a801f7d45e9c14cdcf73deff1a394","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}