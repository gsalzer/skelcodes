{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/feeders/NonPeggedFeederPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n// External\\nimport { IMasset } from \\\"../interfaces/IMasset.sol\\\";\\nimport { IFAssetRedemptionPriceGetter } from \\\"../interfaces/IFAssetRedemptionPriceGetter.sol\\\";\\n\\n// Internal\\nimport \\\"../masset/MassetStructs.sol\\\";\\nimport { IFeederPool } from \\\"../interfaces/IFeederPool.sol\\\";\\nimport { Initializable } from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport { InitializableToken } from \\\"../shared/InitializableToken.sol\\\";\\nimport { PausableModule } from \\\"../shared/PausableModule.sol\\\";\\nimport { InitializableReentrancyGuard } from \\\"../shared/InitializableReentrancyGuard.sol\\\";\\nimport { IBasicToken } from \\\"../shared/IBasicToken.sol\\\";\\n\\n// Libs\\nimport { SafeCast } from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { StableMath } from \\\"../shared/StableMath.sol\\\";\\nimport { FeederManager } from \\\"./FeederManager.sol\\\";\\nimport { FeederLogic } from \\\"./FeederLogic.sol\\\";\\n\\n/**\\n * @title   NonPeggedFeederPool\\n * @author  mStable, @stobiewan\\n* @notice  Base contract for Feeder Pools (fPools) handling non-pegged stable assets with a redemption price. Feeder\\n*          Pools are combined of 50/50 fAsset and mAsset. This supports efficient swaps into and out of mAssets and the\\n*          bAssets in the mAsset basket (a.k.a mpAssets). There is 0 fee to trade from fAsset into mAsset, providing\\n*          low cost on-ramps into mAssets.\\n * @dev     VERSION: 1.0\\n *          DATE:    2021-10-01\\n */\\ncontract NonPeggedFeederPool is\\n    IFeederPool,\\n    Initializable,\\n    InitializableToken,\\n    PausableModule,\\n    InitializableReentrancyGuard\\n{\\n    using SafeERC20 for IERC20;\\n    using StableMath for uint256;\\n\\n    // Forging Events\\n    event Minted(\\n        address indexed minter,\\n        address recipient,\\n        uint256 output,\\n        address input,\\n        uint256 inputQuantity\\n    );\\n    event MintedMulti(\\n        address indexed minter,\\n        address recipient,\\n        uint256 output,\\n        address[] inputs,\\n        uint256[] inputQuantities\\n    );\\n    event Swapped(\\n        address indexed swapper,\\n        address input,\\n        address output,\\n        uint256 outputAmount,\\n        uint256 fee,\\n        address recipient\\n    );\\n    event Redeemed(\\n        address indexed redeemer,\\n        address recipient,\\n        uint256 mAssetQuantity,\\n        address output,\\n        uint256 outputQuantity,\\n        uint256 scaledFee\\n    );\\n    event RedeemedMulti(\\n        address indexed redeemer,\\n        address recipient,\\n        uint256 mAssetQuantity,\\n        address[] outputs,\\n        uint256[] outputQuantity,\\n        uint256 scaledFee\\n    );\\n    // State Events\\n    event CacheSizeChanged(uint256 cacheSize);\\n    event FeesChanged(uint256 swapFee, uint256 redemptionFee, uint256 govFee);\\n    event WeightLimitsChanged(uint128 min, uint128 max);\\n\\n    // FeederManager Events\\n    event BassetsMigrated(address[] bAssets, address newIntegrator);\\n    event StartRampA(uint256 currentA, uint256 targetA, uint256 startTime, uint256 rampEndTime);\\n    event StopRampA(uint256 currentA, uint256 time);\\n\\n    // Constants\\n    uint256 private constant MAX_FEE = 1e16;\\n    uint256 private constant A_PRECISION = 100;\\n    uint256 private constant M_INDEX = 0;\\n    uint256 private constant F_INDEX = 1;\\n    uint256 private constant NUM_ASSETS = 2;\\n    uint256 private constant RAY = 10**27;\\n    uint128 private fAssetBaseRatio;\\n    address public immutable override mAsset;\\n    address public immutable fAssetRedemptionPriceGetter;\\n\\n    // Core data storage\\n    FeederData public data;\\n\\n    /**\\n     * @dev Constructor to set immutable bytecode\\n     * @param _nexus   Nexus address\\n     * @param _mAsset  Immutable mAsset address\\n     * @param _mAsset  Immutable address of fAsset redemption price getter\\n     */\\n    constructor(\\n        address _nexus,\\n        address _mAsset,\\n        address _fAssetRedemptionPriceGetter\\n    ) PausableModule(_nexus) {\\n        mAsset = _mAsset;\\n        fAssetRedemptionPriceGetter = _fAssetRedemptionPriceGetter;\\n    }\\n\\n    /**\\n     * @dev Basic initializer. Sets up core state and importantly provides infinite approvals to the mAsset pool\\n     * to support the cross pool swaps. bAssetData and bAssetPersonal are always ordered [mAsset, fAsset].\\n     * @param _nameArg     Name of the fPool token (a.k.a. fpToken)\\n     * @param _symbolArg   Symbol of the fPool token\\n     * @param _mAsset      Details on the base mAsset\\n     * @param _fAsset      Details on the attached fAsset\\n     * @param _mpAssets    Array of bAssets from the mAsset (to approve)\\n     * @param _config      Starting invariant config\\n     */\\n    function initialize(\\n        string calldata _nameArg,\\n        string calldata _symbolArg,\\n        BassetPersonal calldata _mAsset,\\n        BassetPersonal calldata _fAsset,\\n        address[] calldata _mpAssets,\\n        BasicConfig memory _config\\n    ) public initializer {\\n        InitializableToken._initialize(_nameArg, _symbolArg);\\n\\n        _initializeReentrancyGuard();\\n\\n        require(_mAsset.addr == mAsset, \\\"mAsset incorrect\\\");\\n        fAssetBaseRatio = SafeCast.toUint128(10**(26 - IBasicToken(_fAsset.addr).decimals()));\\n        data.bAssetPersonal.push(\\n            BassetPersonal(_mAsset.addr, _mAsset.integrator, false, BassetStatus.Normal)\\n        );\\n        data.bAssetData.push(BassetData(1e8, 0));\\n        data.bAssetPersonal.push(\\n            BassetPersonal(_fAsset.addr, _fAsset.integrator, _fAsset.hasTxFee, BassetStatus.Normal)\\n        );\\n        data.bAssetData.push(BassetData(fAssetBaseRatio, 0));\\n        for (uint256 i = 0; i < _mpAssets.length; i++) {\\n            // Call will fail if bAsset does not exist\\n            IMasset(_mAsset.addr).getBasset(_mpAssets[i]);\\n            IERC20(_mpAssets[i]).safeApprove(_mAsset.addr, 2**255);\\n        }\\n\\n        uint64 startA = SafeCast.toUint64(_config.a * A_PRECISION);\\n        data.ampData = AmpData(startA, startA, 0, 0);\\n        data.weightLimits = _config.limits;\\n\\n        data.swapFee = 4e14;\\n        data.redemptionFee = 4e14;\\n        data.cacheSize = 1e17;\\n        data.govFee = 1e17;\\n    }\\n\\n    /**\\n     * @dev System will be halted during a recollateralisation event\\n     */\\n    modifier whenInOperation() {\\n        _isOperational();\\n        _;\\n    }\\n\\n    // Internal fn for modifier to reduce deployment size\\n    function _isOperational() internal view {\\n        require(!_paused || msg.sender == _recollateraliser(), \\\"Unhealthy\\\");\\n    }\\n\\n    /**\\n     * @dev Verifies that the caller is the Interest Validator contract\\n     */\\n    modifier onlyInterestValidator() {\\n        require(nexus.getModule(KEY_INTEREST_VALIDATOR) == msg.sender, \\\"Only validator\\\");\\n        _;\\n    }\\n\\n    /***************************************\\n                    MINTING\\n    ****************************************/\\n\\n    /**\\n     * @notice Mint fpTokens with a single bAsset. This contract must have approval to spend the senders bAsset.\\n     * Supports either fAsset, mAsset or mpAsset as input - with mpAssets used to mint mAsset before depositing.\\n     * @param _input                Address of the bAsset to deposit.\\n     * @param _inputQuantity        Quantity in input token units.\\n     * @param _minOutputQuantity    Minimum fpToken quantity to be minted. This protects against slippage.\\n     * @param _recipient            Recipient of the newly minted fpTokens\\n     * @return mintOutput           Quantity of fpToken minted from the deposited bAsset.\\n     */\\n    function mint(\\n        address _input,\\n        uint256 _inputQuantity,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) external override nonReentrant whenInOperation returns (uint256 mintOutput) {\\n        require(_recipient != address(0), \\\"Invalid recipient\\\");\\n        require(_inputQuantity > 0, \\\"Qty==0\\\");\\n\\n        Asset memory input = _getAsset(_input);\\n\\n        _updateBassetData();\\n        mintOutput = FeederLogic.mint(\\n            data,\\n            _getConfig(),\\n            input,\\n            _inputQuantity,\\n            _minOutputQuantity\\n        );\\n\\n        // Mint the fpToken\\n        _mint(_recipient, mintOutput);\\n        emit Minted(msg.sender, _recipient, mintOutput, _input, _inputQuantity);\\n    }\\n\\n    /**\\n     * @notice Mint fpTokens with multiple bAssets. This contract must have approval to spend the senders bAssets.\\n     * Supports only fAsset or mAsset as inputs.\\n     * @param _inputs               Address of the bAssets to deposit.\\n     * @param _inputQuantities      Quantity in input token units.\\n     * @param _minOutputQuantity    Minimum fpToken quantity to be minted. This protects against slippage.\\n     * @param _recipient            Recipient of the newly minted fpTokens\\n     * @return mintOutput           Quantity of fpToken minted from the deposited bAssets.\\n     */\\n    function mintMulti(\\n        address[] calldata _inputs,\\n        uint256[] calldata _inputQuantities,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) external override nonReentrant whenInOperation returns (uint256 mintOutput) {\\n        require(_recipient != address(0), \\\"Invalid recipient\\\");\\n        uint256 len = _inputQuantities.length;\\n        require(len > 0 && len == _inputs.length, \\\"Input array mismatch\\\");\\n\\n        uint8[] memory indexes = _getAssets(_inputs);\\n        _updateBassetData();\\n        mintOutput = FeederLogic.mintMulti(\\n            data,\\n            _getConfig(),\\n            indexes,\\n            _inputQuantities,\\n            _minOutputQuantity\\n        );\\n        // Mint the fpToken\\n        _mint(_recipient, mintOutput);\\n        emit MintedMulti(msg.sender, _recipient, mintOutput, _inputs, _inputQuantities);\\n    }\\n\\n    /**\\n     * @notice Get the projected output of a given mint.\\n     * @param _input             Address of the bAsset to deposit\\n     * @param _inputQuantity     Quantity in bAsset units\\n     * @return mintOutput        Estimated mint output in fpToken terms\\n     */\\n    function getMintOutput(address _input, uint256 _inputQuantity)\\n        external\\n        view\\n        override\\n        returns (uint256 mintOutput)\\n    {\\n        require(_inputQuantity > 0, \\\"Qty==0\\\");\\n\\n        Asset memory input = _getAsset(_input);\\n\\n        if (input.exists) {\\n            mintOutput = FeederLogic.computeMint(\\n                _getMemBassetData(),\\n                input.idx,\\n                _inputQuantity,\\n                _getConfig()\\n            );\\n        } else {\\n            uint256 estimatedMasset = IMasset(mAsset).getMintOutput(_input, _inputQuantity);\\n            mintOutput = FeederLogic.computeMint(\\n                _getMemBassetData(),\\n                0,\\n                estimatedMasset,\\n                _getConfig()\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice Get the projected output of a given mint\\n     * @param _inputs            Non-duplicate address array of addresses to bAssets to deposit for the minted mAsset tokens.\\n     * @param _inputQuantities   Quantity of each bAsset to deposit for the minted fpToken.\\n     * @return mintOutput        Estimated mint output in fpToken terms\\n     */\\n    function getMintMultiOutput(address[] calldata _inputs, uint256[] calldata _inputQuantities)\\n        external\\n        view\\n        override\\n        returns (uint256 mintOutput)\\n    {\\n        uint256 len = _inputQuantities.length;\\n        require(len > 0 && len == _inputs.length, \\\"Input array mismatch\\\");\\n        uint8[] memory indexes = _getAssets(_inputs);\\n        return\\n            FeederLogic.computeMintMulti(\\n                _getMemBassetData(),\\n                indexes,\\n                _inputQuantities,\\n                _getConfig()\\n            );\\n    }\\n\\n    /***************************************\\n                    SWAPPING\\n    ****************************************/\\n\\n    /**\\n     * @notice Swaps two assets - either internally between fAsset<>mAsset, or between fAsset<>mpAsset by\\n     * first routing through the mAsset pool.\\n     * @param _input             Address of bAsset to deposit\\n     * @param _output            Address of bAsset to withdraw\\n     * @param _inputQuantity     Units of input bAsset to swap in\\n     * @param _minOutputQuantity Minimum quantity of the swap output asset. This protects against slippage\\n     * @param _recipient         Address to transfer output asset to\\n     * @return swapOutput        Quantity of output asset returned from swap\\n     */\\n    function swap(\\n        address _input,\\n        address _output,\\n        uint256 _inputQuantity,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) external override nonReentrant whenInOperation returns (uint256 swapOutput) {\\n        require(_recipient != address(0), \\\"Invalid recipient\\\");\\n        require(_input != _output, \\\"Invalid pair\\\");\\n        require(_inputQuantity > 0, \\\"Qty==0\\\");\\n\\n        Asset memory input = _getAsset(_input);\\n        Asset memory output = _getAsset(_output);\\n        require(_pathIsValid(input, output), \\\"Invalid pair\\\");\\n\\n        uint256 localFee;\\n        _updateBassetData();\\n        (swapOutput, localFee) = FeederLogic.swap(\\n            data,\\n            _getConfig(),\\n            input,\\n            output,\\n            _inputQuantity,\\n            _minOutputQuantity,\\n            _recipient\\n        );\\n\\n        uint256 govFee = data.govFee;\\n        if (govFee > 0) {\\n            data.pendingFees += ((localFee * govFee) / 1e18);\\n        }\\n\\n        emit Swapped(msg.sender, input.addr, output.addr, swapOutput, localFee, _recipient);\\n    }\\n\\n    /**\\n     * @notice Determines both if a trade is valid, and the expected fee or output.\\n     * Swap is valid if it does not result in the input asset exceeding its maximum weight.\\n     * @param _input             Address of bAsset to deposit\\n     * @param _output            Address of bAsset to receive\\n     * @param _inputQuantity     Units of input bAsset to swap\\n     * @return swapOutput        Quantity of output asset returned from swap\\n     */\\n    function getSwapOutput(\\n        address _input,\\n        address _output,\\n        uint256 _inputQuantity\\n    ) external view override returns (uint256 swapOutput) {\\n        require(_input != _output, \\\"Invalid pair\\\");\\n        require(_inputQuantity > 0, \\\"Qty==0\\\");\\n\\n        Asset memory input = _getAsset(_input);\\n        Asset memory output = _getAsset(_output);\\n        require(_pathIsValid(input, output), \\\"Invalid pair\\\");\\n\\n        // Internal swap between fAsset and mAsset\\n        if (input.exists && output.exists) {\\n            (swapOutput, ) = FeederLogic.computeSwap(\\n                _getMemBassetData(),\\n                input.idx,\\n                output.idx,\\n                _inputQuantity,\\n                output.idx == 0 ? 0 : data.swapFee,\\n                _getConfig()\\n            );\\n            return swapOutput;\\n        }\\n\\n        // Swapping out of fAsset\\n        if (input.exists) {\\n            // Swap into mAsset > Redeem into mpAsset\\n            (swapOutput, ) = FeederLogic.computeSwap(\\n                _getMemBassetData(),\\n                1,\\n                0,\\n                _inputQuantity,\\n                0,\\n                _getConfig()\\n            );\\n            swapOutput = IMasset(mAsset).getRedeemOutput(_output, swapOutput);\\n        }\\n        // Else we are swapping into fAsset\\n        else {\\n            // Mint mAsset from mp > Swap into fAsset here\\n            swapOutput = IMasset(mAsset).getMintOutput(_input, _inputQuantity);\\n            (swapOutput, ) = FeederLogic.computeSwap(\\n                _getMemBassetData(),\\n                0,\\n                1,\\n                swapOutput,\\n                data.swapFee,\\n                _getConfig()\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Checks if a given swap path is valid. Only fAsset<>mAsset & fAsset<>mpAsset swaps are supported.\\n     */\\n    function _pathIsValid(Asset memory _in, Asset memory _out)\\n        internal\\n        pure\\n        returns (bool isValid)\\n    {\\n        // mpAsset -> mpAsset\\n        if (!_in.exists && !_out.exists) return false;\\n        // f/mAsset -> f/mAsset\\n        if (_in.exists && _out.exists) return true;\\n        // fAsset -> mpAsset\\n        if (_in.exists && _in.idx == 1) return true;\\n        // mpAsset -> fAsset\\n        if (_out.exists && _out.idx == 1) return true;\\n        // Path is into or out of mAsset - just use main pool for this\\n        return false;\\n    }\\n\\n    /***************************************\\n                    REDEMPTION\\n    ****************************************/\\n\\n    /**\\n     * @notice Burns a specified quantity of the senders fpToken in return for a bAsset. The output amount is derived\\n     * from the invariant. Supports redemption into either the fAsset, mAsset or assets in the mAsset basket.\\n     * @param _output            Address of the bAsset to withdraw\\n     * @param _fpTokenQuantity   Quantity of LP Token to burn\\n     * @param _minOutputQuantity Minimum bAsset quantity to receive for the burnt fpToken. This protects against slippage.\\n     * @param _recipient         Address to transfer the withdrawn bAssets to.\\n     * @return outputQuantity    Quanity of bAsset units received for the burnt fpToken\\n     */\\n    function redeem(\\n        address _output,\\n        uint256 _fpTokenQuantity,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) external override nonReentrant whenInOperation returns (uint256 outputQuantity) {\\n        require(_recipient != address(0), \\\"Invalid recipient\\\");\\n        require(_fpTokenQuantity > 0, \\\"Qty==0\\\");\\n\\n        Asset memory output = _getAsset(_output);\\n\\n        // Get config before burning. Config > Burn > CacheSize\\n        FeederConfig memory config = _getConfig();\\n        _burn(msg.sender, _fpTokenQuantity);\\n\\n        uint256 localFee;\\n        _updateBassetData();\\n        (outputQuantity, localFee) = FeederLogic.redeem(\\n            data,\\n            config,\\n            output,\\n            _fpTokenQuantity,\\n            _minOutputQuantity,\\n            _recipient\\n        );\\n\\n        uint256 govFee = data.govFee;\\n        if (govFee > 0) {\\n            data.pendingFees += ((localFee * govFee) / 1e18);\\n        }\\n\\n        emit Redeemed(\\n            msg.sender,\\n            _recipient,\\n            _fpTokenQuantity,\\n            output.addr,\\n            outputQuantity,\\n            localFee\\n        );\\n    }\\n\\n    /**\\n     * @dev Credits a recipient with a proportionate amount of bAssets, relative to current vault\\n     * balance levels and desired fpToken quantity. Burns the fpToken as payment. Only fAsset & mAsset are supported in this path.\\n     * @param _inputQuantity        Quantity of fpToken to redeem\\n     * @param _minOutputQuantities  Min units of output to receive\\n     * @param _recipient            Address to credit the withdrawn bAssets\\n     * @return outputQuantities     Array of output asset quantities\\n     */\\n    function redeemProportionately(\\n        uint256 _inputQuantity,\\n        uint256[] calldata _minOutputQuantities,\\n        address _recipient\\n    ) external override nonReentrant whenInOperation returns (uint256[] memory outputQuantities) {\\n        require(_recipient != address(0), \\\"Invalid recipient\\\");\\n        require(_inputQuantity > 0, \\\"Qty==0\\\");\\n\\n        // Get config before burning. Burn > CacheSize\\n        FeederConfig memory config = _getConfig();\\n        _burn(msg.sender, _inputQuantity);\\n\\n        address[] memory outputs;\\n        uint256 scaledFee;\\n        _updateBassetData();\\n        (scaledFee, outputs, outputQuantities) = FeederLogic.redeemProportionately(\\n            data,\\n            config,\\n            _inputQuantity,\\n            _minOutputQuantities,\\n            _recipient\\n        );\\n\\n        uint256 govFee = data.govFee;\\n        if (govFee > 0) {\\n            data.pendingFees += ((scaledFee * govFee) / 1e18);\\n        }\\n\\n        emit RedeemedMulti(\\n            msg.sender,\\n            _recipient,\\n            _inputQuantity,\\n            outputs,\\n            outputQuantities,\\n            scaledFee\\n        );\\n    }\\n\\n    /**\\n     * @dev Credits a recipient with a certain quantity of selected bAssets, in exchange for burning the\\n     *      relative fpToken quantity from the sender. Only fAsset & mAsset (0,1) are supported in this path.\\n     * @param _outputs              Addresses of the bAssets to receive\\n     * @param _outputQuantities     Units of the bAssets to receive\\n     * @param _maxInputQuantity     Maximum fpToken quantity to burn for the received bAssets. This protects against slippage.\\n     * @param _recipient            Address to receive the withdrawn bAssets\\n     * @return fpTokenQuantity      Quantity of fpToken units burned as payment\\n     */\\n    function redeemExactBassets(\\n        address[] calldata _outputs,\\n        uint256[] calldata _outputQuantities,\\n        uint256 _maxInputQuantity,\\n        address _recipient\\n    ) external override nonReentrant whenInOperation returns (uint256 fpTokenQuantity) {\\n        require(_recipient != address(0), \\\"Invalid recipient\\\");\\n        uint256 len = _outputQuantities.length;\\n        require(len > 0 && len == _outputs.length, \\\"Invalid array input\\\");\\n        require(_maxInputQuantity > 0, \\\"Qty==0\\\");\\n\\n        uint8[] memory indexes = _getAssets(_outputs);\\n\\n        uint256 localFee;\\n        _updateBassetData();\\n        (fpTokenQuantity, localFee) = FeederLogic.redeemExactBassets(\\n            data,\\n            _getConfig(),\\n            indexes,\\n            _outputQuantities,\\n            _maxInputQuantity,\\n            _recipient\\n        );\\n\\n        _burn(msg.sender, fpTokenQuantity);\\n        uint256 govFee = data.govFee;\\n        if (govFee > 0) {\\n            data.pendingFees += ((localFee * govFee) / 1e18);\\n        }\\n\\n        emit RedeemedMulti(\\n            msg.sender,\\n            _recipient,\\n            fpTokenQuantity,\\n            _outputs,\\n            _outputQuantities,\\n            localFee\\n        );\\n    }\\n\\n    /**\\n     * @notice Gets the estimated output from a given redeem\\n     * @param _output            Address of the bAsset to receive\\n     * @param _fpTokenQuantity   Quantity of fpToken to redeem\\n     * @return bAssetOutput      Estimated quantity of bAsset units received for the burnt fpTokens\\n     */\\n    function getRedeemOutput(address _output, uint256 _fpTokenQuantity)\\n        external\\n        view\\n        override\\n        returns (uint256 bAssetOutput)\\n    {\\n        require(_fpTokenQuantity > 0, \\\"Qty==0\\\");\\n\\n        Asset memory output = _getAsset(_output);\\n        uint256 scaledFee = _fpTokenQuantity.mulTruncate(data.redemptionFee);\\n\\n        bAssetOutput = FeederLogic.computeRedeem(\\n            _getMemBassetData(),\\n            output.exists ? output.idx : 0,\\n            _fpTokenQuantity - scaledFee,\\n            _getConfig()\\n        );\\n        // Extra step for mpAsset redemption\\n        if (!output.exists) {\\n            bAssetOutput = IMasset(mAsset).getRedeemOutput(output.addr, bAssetOutput);\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets the estimated output from a given redeem\\n     * @param _outputs           Addresses of the bAsset to receive\\n     * @param _outputQuantities  Quantities of bAsset to redeem\\n     * @return fpTokenQuantity   Estimated quantity of fpToken units needed to burn to receive output\\n     */\\n    function getRedeemExactBassetsOutput(\\n        address[] calldata _outputs,\\n        uint256[] calldata _outputQuantities\\n    ) external view override returns (uint256 fpTokenQuantity) {\\n        uint256 len = _outputQuantities.length;\\n        require(len > 0 && len == _outputs.length, \\\"Invalid array input\\\");\\n\\n        uint8[] memory indexes = _getAssets(_outputs);\\n\\n        uint256 mAssetRedeemed = FeederLogic.computeRedeemExact(\\n            _getMemBassetData(),\\n            indexes,\\n            _outputQuantities,\\n            _getConfig()\\n        );\\n        fpTokenQuantity = mAssetRedeemed.divPrecisely(1e18 - data.redemptionFee);\\n        if (fpTokenQuantity > 0) fpTokenQuantity += 1;\\n    }\\n\\n    /***************************************\\n                    GETTERS\\n    ****************************************/\\n\\n    /**\\n     * @notice Gets the price of the fpToken, and invariant value k\\n     * @return price    Price of an fpToken\\n     * @return k        Total value of basket, k\\n     */\\n    function getPrice() public view override returns (uint256 price, uint256 k) {\\n        return FeederLogic.computePrice(_getMemBassetData(), _getConfig());\\n    }\\n\\n    /**\\n     * @notice Gets all config needed for general InvariantValidator calls\\n     */\\n    function getConfig() external view override returns (FeederConfig memory config) {\\n        return _getConfig();\\n    }\\n\\n    /**\\n     * @notice Get data for a specific bAsset, if it exists\\n     * @param _bAsset     Address of bAsset\\n     * @return personal   Struct with personal data\\n     * @return vaultData  Struct with full bAsset data\\n     */\\n    function getBasset(address _bAsset)\\n        external\\n        view\\n        override\\n        returns (BassetPersonal memory personal, BassetData memory vaultData)\\n    {\\n        Asset memory asset = _getAsset(_bAsset);\\n        require(asset.exists, \\\"Invalid asset\\\");\\n        personal = data.bAssetPersonal[asset.idx];\\n        vaultData = _getMemBassetData()[asset.idx];\\n    }\\n\\n    /**\\n     * @notice Get data for a all bAssets in basket\\n     * @return personal    Struct[] with full bAsset data\\n     * @return vaultData   Number of bAssets in the Basket\\n     */\\n    function getBassets()\\n        external\\n        view\\n        override\\n        returns (BassetPersonal[] memory, BassetData[] memory vaultData)\\n    {\\n        return (data.bAssetPersonal, _getMemBassetData());\\n    }\\n\\n    /***************************************\\n                GETTERS - INTERNAL\\n    ****************************************/\\n\\n    /**\\n     * @dev Checks if a given asset exists in basket and return the index.\\n     * @return status    Data containing address, index and whether it exists in basket\\n     */\\n    function _getAsset(address _asset) internal view returns (Asset memory status) {\\n        // if input is mAsset then we know the position\\n        if (_asset == mAsset) return Asset(0, _asset, true);\\n\\n        // else it exists if the position 1 is _asset\\n        return Asset(1, _asset, data.bAssetPersonal[1].addr == _asset);\\n    }\\n\\n    /**\\n     * @dev Validates an array of input assets and returns their indexes. Assets must exist\\n     * in order to be valid, as mintMulti and redeemMulti do not support external bAssets.\\n     */\\n    function _getAssets(address[] memory _assets) internal view returns (uint8[] memory indexes) {\\n        uint256 len = _assets.length;\\n\\n        indexes = new uint8[](len);\\n\\n        Asset memory input_;\\n        for (uint256 i = 0; i < len; i++) {\\n            input_ = _getAsset(_assets[i]);\\n            indexes[i] = input_.idx;\\n            require(input_.exists, \\\"Invalid asset\\\");\\n\\n            for (uint256 j = i + 1; j < len; j++) {\\n                require(_assets[i] != _assets[j], \\\"Duplicate asset\\\");\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Gets all config needed for general InvariantValidator calls\\n     */\\n    function _getConfig() internal view returns (FeederConfig memory) {\\n        return FeederConfig(totalSupply() + data.pendingFees, _getA(), data.weightLimits);\\n    }\\n\\n    /**\\n     * @dev Gets current amplification var A\\n     */\\n    function _getA() internal view returns (uint256) {\\n        AmpData memory ampData_ = data.ampData;\\n\\n        uint64 endA = ampData_.targetA;\\n        uint64 endTime = ampData_.rampEndTime;\\n\\n        // If still changing, work out based on current timestamp\\n        if (block.timestamp < endTime) {\\n            uint64 startA = ampData_.initialA;\\n            uint64 startTime = ampData_.rampStartTime;\\n\\n            (uint256 elapsed, uint256 total) = (block.timestamp - startTime, endTime - startTime);\\n\\n            if (endA > startA) {\\n                return startA + (((endA - startA) * elapsed) / total);\\n            } else {\\n                return startA - (((startA - endA) * elapsed) / total);\\n            }\\n        }\\n        // Else return final value\\n        else {\\n            return endA;\\n        }\\n    }\\n\\n    function _getMemBassetData() internal view returns (BassetData[] memory bAssetData) {\\n        if (fAssetRedemptionPriceGetter == address(0)) return data.bAssetData;\\n        bAssetData = new BassetData[](NUM_ASSETS);\\n        bAssetData[M_INDEX] = data.bAssetData[M_INDEX];\\n        bAssetData[F_INDEX].vaultBalance = data.bAssetData[F_INDEX].vaultBalance;\\n        bAssetData[F_INDEX].ratio = _getRatioFromRedemptionPrice();\\n    }\\n\\n    function _getRatioFromRedemptionPrice() internal view returns (uint128 ratio) {\\n        uint256 rp_ray = IFAssetRedemptionPriceGetter(fAssetRedemptionPriceGetter)\\n        .snappedRedemptionPrice();\\n        return SafeCast.toUint128((uint256(fAssetBaseRatio) * rp_ray + RAY / 2) / RAY);\\n    }\\n\\n    /***************************************\\n                    YIELD\\n    ****************************************/\\n\\n    /**\\n     * @dev Collects the interest generated from the lending markets, performing a theoretical mint, which\\n     * is then validated by the interest validator to protect against accidental hyper inflation.\\n     * @return mintAmount   fpToken units generated from interest collected from lending markets\\n     * @return newSupply    fpToken total supply after mint\\n     */\\n    function collectPlatformInterest()\\n        external\\n        override\\n        onlyInterestValidator\\n        whenInOperation\\n        nonReentrant\\n        returns (uint256 mintAmount, uint256 newSupply)\\n    {\\n        _updateBassetData();\\n        (uint8[] memory idxs, uint256[] memory gains) = FeederManager.calculatePlatformInterest(\\n            data.bAssetPersonal,\\n            data.bAssetData\\n        );\\n        // Calculate potential mint amount. This will be validated by the interest validator\\n        mintAmount = FeederLogic.computeMintMulti(data.bAssetData, idxs, gains, _getConfig());\\n        newSupply = totalSupply() + data.pendingFees + mintAmount;\\n\\n        uint256 govFee = data.govFee;\\n        if (govFee > 0) {\\n            data.pendingFees += ((mintAmount * govFee) / 1e18);\\n        }\\n\\n        // Dummy mint event to catch the collections here\\n        emit MintedMulti(address(this), msg.sender, 0, new address[](0), gains);\\n    }\\n\\n    /**\\n     * @dev Collects the pending gov fees extracted from swap, redeem and platform interest.\\n     */\\n    function collectPendingFees() external override onlyInterestValidator {\\n        uint256 fees = data.pendingFees;\\n        if (fees > 1) {\\n            uint256 mintAmount = fees - 1;\\n            data.pendingFees = 1;\\n\\n            _mint(msg.sender, mintAmount);\\n            emit MintedMulti(\\n                address(this),\\n                msg.sender,\\n                mintAmount,\\n                new address[](0),\\n                new uint256[](0)\\n            );\\n        }\\n    }\\n\\n    /***************************************\\n                    STATE\\n    ****************************************/\\n\\n    /**\\n     * @dev Sets the MAX cache size for each bAsset. The cache will actually revolve around\\n     *      _cacheSize * totalSupply / 2 under normal circumstances.\\n     * @param _cacheSize Maximum percent of total fpToken supply to hold for each bAsset\\n     */\\n    function setCacheSize(uint256 _cacheSize) external onlyGovernor {\\n        require(_cacheSize <= 2e17, \\\"Must be <= 20%\\\");\\n\\n        data.cacheSize = _cacheSize;\\n\\n        emit CacheSizeChanged(_cacheSize);\\n    }\\n\\n    /**\\n     * @dev Set the ecosystem fee for swapping bAssets or redeeming specific bAssets\\n     * @param _swapFee       Fee calculated in (%/100 * 1e18)\\n     * @param _redemptionFee Fee calculated in (%/100 * 1e18)\\n     * @param _govFee        Fee calculated in (%/100 * 1e18)\\n     */\\n    function setFees(\\n        uint256 _swapFee,\\n        uint256 _redemptionFee,\\n        uint256 _govFee\\n    ) external onlyGovernor {\\n        require(_swapFee <= MAX_FEE, \\\"Swap rate oob\\\");\\n        require(_redemptionFee <= MAX_FEE, \\\"Redemption rate oob\\\");\\n        require(_govFee <= 5e17, \\\"Gov fee rate oob\\\");\\n\\n        data.swapFee = _swapFee;\\n        data.redemptionFee = _redemptionFee;\\n        data.govFee = _govFee;\\n\\n        emit FeesChanged(_swapFee, _redemptionFee, _govFee);\\n    }\\n\\n    /**\\n     * @dev Set the maximum weight across all bAssets\\n     * @param _min Weight where 100% = 1e18\\n     * @param _max Weight where 100% = 1e18\\n     */\\n    function setWeightLimits(uint128 _min, uint128 _max) external onlyGovernor {\\n        require(_min <= 3e17 && _max >= 7e17, \\\"Weights oob\\\");\\n\\n        data.weightLimits = WeightLimits(_min, _max);\\n\\n        emit WeightLimitsChanged(_min, _max);\\n    }\\n\\n    /**\\n     * @dev Transfers all collateral from one lending market to another - used initially\\n     *      to handle the migration between Aave V1 and Aave V2. Note - only supports non\\n     *      tx fee enabled assets. Supports going from no integration to integration, but\\n     *      not the other way around.\\n     * @param _bAssets Array of basket assets to migrate\\n     * @param _newIntegration Address of the new platform integration\\n     */\\n    function migrateBassets(address[] calldata _bAssets, address _newIntegration)\\n        external\\n        onlyGovernor\\n    {\\n        FeederManager.migrateBassets(data.bAssetPersonal, _bAssets, _newIntegration);\\n    }\\n\\n    /**\\n     * @dev Starts changing of the amplification var A\\n     * @param _targetA      Target A value\\n     * @param _rampEndTime  Time at which A will arrive at _targetA\\n     */\\n    function startRampA(uint256 _targetA, uint256 _rampEndTime) external onlyGovernor {\\n        FeederManager.startRampA(data.ampData, _targetA, _rampEndTime, _getA(), A_PRECISION);\\n    }\\n\\n    /**\\n     * @dev Stops the changing of the amplification var A, setting\\n     * it to whatever the current value is.\\n     */\\n    function stopRampA() external onlyGovernor {\\n        FeederManager.stopRampA(data.ampData, _getA());\\n    }\\n\\n    /**\\n     * @dev Updates the value ratio of fAsset if rate source had been set.\\n     */\\n    function _updateBassetData() internal {\\n        if (fAssetRedemptionPriceGetter == address(0)) return;\\n        data.bAssetData[F_INDEX].ratio = _getRatioFromRedemptionPrice();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMasset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\npragma abicoder v2;\\n\\nimport { BassetData, BassetPersonal } from \\\"../masset/MassetStructs.sol\\\";\\n\\nabstract contract IMasset {\\n    // Mint\\n    function mint(\\n        address _input,\\n        uint256 _inputQuantity,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) external virtual returns (uint256 mintOutput);\\n\\n    function mintMulti(\\n        address[] calldata _inputs,\\n        uint256[] calldata _inputQuantities,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) external virtual returns (uint256 mintOutput);\\n\\n    function getMintOutput(address _input, uint256 _inputQuantity)\\n        external\\n        view\\n        virtual\\n        returns (uint256 mintOutput);\\n\\n    function getMintMultiOutput(address[] calldata _inputs, uint256[] calldata _inputQuantities)\\n        external\\n        view\\n        virtual\\n        returns (uint256 mintOutput);\\n\\n    // Swaps\\n    function swap(\\n        address _input,\\n        address _output,\\n        uint256 _inputQuantity,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) external virtual returns (uint256 swapOutput);\\n\\n    function getSwapOutput(\\n        address _input,\\n        address _output,\\n        uint256 _inputQuantity\\n    ) external view virtual returns (uint256 swapOutput);\\n\\n    // Redemption\\n    function redeem(\\n        address _output,\\n        uint256 _mAssetQuantity,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) external virtual returns (uint256 outputQuantity);\\n\\n    function redeemMasset(\\n        uint256 _mAssetQuantity,\\n        uint256[] calldata _minOutputQuantities,\\n        address _recipient\\n    ) external virtual returns (uint256[] memory outputQuantities);\\n\\n    function redeemExactBassets(\\n        address[] calldata _outputs,\\n        uint256[] calldata _outputQuantities,\\n        uint256 _maxMassetQuantity,\\n        address _recipient\\n    ) external virtual returns (uint256 mAssetRedeemed);\\n\\n    function getRedeemOutput(address _output, uint256 _mAssetQuantity)\\n        external\\n        view\\n        virtual\\n        returns (uint256 bAssetOutput);\\n\\n    function getRedeemExactBassetsOutput(\\n        address[] calldata _outputs,\\n        uint256[] calldata _outputQuantities\\n    ) external view virtual returns (uint256 mAssetAmount);\\n\\n    // Views\\n    function getBasket() external view virtual returns (bool, bool);\\n\\n    function getBasset(address _token)\\n        external\\n        view\\n        virtual\\n        returns (BassetPersonal memory personal, BassetData memory data);\\n\\n    function getBassets()\\n        external\\n        view\\n        virtual\\n        returns (BassetPersonal[] memory personal, BassetData[] memory data);\\n\\n    function bAssetIndexes(address) external view virtual returns (uint8);\\n\\n    function getPrice() external view virtual returns (uint256 price, uint256 k);\\n\\n    // SavingsManager\\n    function collectInterest() external virtual returns (uint256 swapFeesGained, uint256 newSupply);\\n\\n    function collectPlatformInterest()\\n        external\\n        virtual\\n        returns (uint256 mintAmount, uint256 newSupply);\\n\\n    // Admin\\n    function setCacheSize(uint256 _cacheSize) external virtual;\\n\\n    function setFees(uint256 _swapFee, uint256 _redemptionFee) external virtual;\\n\\n    function setTransferFeesFlag(address _bAsset, bool _flag) external virtual;\\n\\n    function migrateBassets(address[] calldata _bAssets, address _newIntegration) external virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFAssetRedemptionPriceGetter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IFAssetRedemptionPriceGetter {\\n    function snappedRedemptionPrice() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/masset/MassetStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nstruct BassetPersonal {\\n    // Address of the bAsset\\n    address addr;\\n    // Address of the bAsset\\n    address integrator;\\n    // An ERC20 can charge transfer fee, for example USDT, DGX tokens.\\n    bool hasTxFee; // takes a byte in storage\\n    // Status of the bAsset\\n    BassetStatus status;\\n}\\n\\nstruct BassetData {\\n    // 1 Basset * ratio / ratioScale == x Masset (relative value)\\n    // If ratio == 10e8 then 1 bAsset = 10 mAssets\\n    // A ratio is divised as 10^(18-tokenDecimals) * measurementMultiple(relative value of 1 base unit)\\n    uint128 ratio;\\n    // Amount of the Basset that is held in Collateral\\n    uint128 vaultBalance;\\n}\\n\\n// Status of the Basset - has it broken its peg?\\nenum BassetStatus {\\n    Default,\\n    Normal,\\n    BrokenBelowPeg,\\n    BrokenAbovePeg,\\n    Blacklisted,\\n    Liquidating,\\n    Liquidated,\\n    Failed\\n}\\n\\nstruct BasketState {\\n    bool undergoingRecol;\\n    bool failed;\\n}\\n\\nstruct FeederConfig {\\n    uint256 supply;\\n    uint256 a;\\n    WeightLimits limits;\\n}\\n\\nstruct InvariantConfig {\\n    uint256 supply;\\n    uint256 a;\\n    WeightLimits limits;\\n    uint256 recolFee;\\n}\\n\\nstruct BasicConfig {\\n    uint256 a;\\n    WeightLimits limits;\\n}\\n\\nstruct WeightLimits {\\n    uint128 min;\\n    uint128 max;\\n}\\n\\nstruct AmpData {\\n    uint64 initialA;\\n    uint64 targetA;\\n    uint64 rampStartTime;\\n    uint64 rampEndTime;\\n}\\n\\nstruct FeederData {\\n    uint256 swapFee;\\n    uint256 redemptionFee;\\n    uint256 govFee;\\n    uint256 pendingFees;\\n    uint256 cacheSize;\\n    BassetPersonal[] bAssetPersonal;\\n    BassetData[] bAssetData;\\n    AmpData ampData;\\n    WeightLimits weightLimits;\\n}\\n\\nstruct MassetData {\\n    uint256 swapFee;\\n    uint256 redemptionFee;\\n    uint256 cacheSize;\\n    uint256 surplus;\\n    BassetPersonal[] bAssetPersonal;\\n    BassetData[] bAssetData;\\n    BasketState basket;\\n    AmpData ampData;\\n    WeightLimits weightLimits;\\n}\\n\\nstruct AssetData {\\n    uint8 idx;\\n    uint256 amt;\\n    BassetPersonal personal;\\n}\\n\\nstruct Asset {\\n    uint8 idx;\\n    address addr;\\n    bool exists;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeederPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\npragma abicoder v2;\\n\\nimport \\\"../masset/MassetStructs.sol\\\";\\n\\nabstract contract IFeederPool {\\n    // Mint\\n    function mint(\\n        address _input,\\n        uint256 _inputQuantity,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) external virtual returns (uint256 mintOutput);\\n\\n    function mintMulti(\\n        address[] calldata _inputs,\\n        uint256[] calldata _inputQuantities,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) external virtual returns (uint256 mintOutput);\\n\\n    function getMintOutput(address _input, uint256 _inputQuantity)\\n        external\\n        view\\n        virtual\\n        returns (uint256 mintOutput);\\n\\n    function getMintMultiOutput(address[] calldata _inputs, uint256[] calldata _inputQuantities)\\n        external\\n        view\\n        virtual\\n        returns (uint256 mintOutput);\\n\\n    // Swaps\\n    function swap(\\n        address _input,\\n        address _output,\\n        uint256 _inputQuantity,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) external virtual returns (uint256 swapOutput);\\n\\n    function getSwapOutput(\\n        address _input,\\n        address _output,\\n        uint256 _inputQuantity\\n    ) external view virtual returns (uint256 swapOutput);\\n\\n    // Redemption\\n    function redeem(\\n        address _output,\\n        uint256 _fpTokenQuantity,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) external virtual returns (uint256 outputQuantity);\\n\\n    function redeemProportionately(\\n        uint256 _fpTokenQuantity,\\n        uint256[] calldata _minOutputQuantities,\\n        address _recipient\\n    ) external virtual returns (uint256[] memory outputQuantities);\\n\\n    function redeemExactBassets(\\n        address[] calldata _outputs,\\n        uint256[] calldata _outputQuantities,\\n        uint256 _maxMassetQuantity,\\n        address _recipient\\n    ) external virtual returns (uint256 mAssetRedeemed);\\n\\n    function getRedeemOutput(address _output, uint256 _fpTokenQuantity)\\n        external\\n        view\\n        virtual\\n        returns (uint256 bAssetOutput);\\n\\n    function getRedeemExactBassetsOutput(\\n        address[] calldata _outputs,\\n        uint256[] calldata _outputQuantities\\n    ) external view virtual returns (uint256 mAssetAmount);\\n\\n    // Views\\n    function mAsset() external view virtual returns (address);\\n\\n    function getPrice() public view virtual returns (uint256 price, uint256 k);\\n\\n    function getConfig() external view virtual returns (FeederConfig memory config);\\n\\n    function getBasset(address _token)\\n        external\\n        view\\n        virtual\\n        returns (BassetPersonal memory personal, BassetData memory data);\\n\\n    function getBassets()\\n        external\\n        view\\n        virtual\\n        returns (BassetPersonal[] memory personal, BassetData[] memory data);\\n\\n    // SavingsManager\\n    function collectPlatformInterest()\\n        external\\n        virtual\\n        returns (uint256 mintAmount, uint256 newSupply);\\n\\n    function collectPendingFees() external virtual;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/shared/InitializableToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport { ERC205, IERC20 } from \\\"./@openzeppelin-2.5/ERC205.sol\\\";\\nimport { InitializableERC20Detailed } from \\\"./InitializableERC20Detailed.sol\\\";\\n\\n/**\\n * @title  InitializableToken\\n * @author mStable\\n * @dev    Basic ERC20Detailed Token functionality for Masset\\n */\\nabstract contract InitializableToken is ERC205, InitializableERC20Detailed {\\n    /**\\n     * @dev Initialization function for implementing contract\\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\\n     */\\n    function _initialize(string memory _nameArg, string memory _symbolArg) internal virtual {\\n        InitializableERC20Detailed._initialize(_nameArg, _symbolArg, 18);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/shared/PausableModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport { ImmutableModule } from \\\"./ImmutableModule.sol\\\";\\n\\n/**\\n * @title   PausableModule\\n * @author  mStable\\n * @dev     Forked from @openzeppelin/contracts/lifecycle/pausable\\n *          Changes: `onlyGovernor` can pause\\n */\\nabstract contract PausableModule is ImmutableModule {\\n    /**\\n     * @dev Emitted when the pause is triggered by Governor\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by Governor\\n     */\\n    event Unpaused(address account);\\n\\n    bool internal _paused = false;\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!_paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     */\\n    modifier whenPaused() {\\n        require(_paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     * Hooks into the Module to give the Governor ability to pause\\n     * @param _nexus Nexus contract address\\n     */\\n    constructor(address _nexus) ImmutableModule(_nexus) {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     * @return Returns `true` when paused, otherwise `false`\\n     */\\n    function paused() external view returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Called by the Governor to pause, triggers stopped state.\\n     */\\n    function pause() external onlyGovernor whenNotPaused {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Called by Governor to unpause, returns to normal state.\\n     */\\n    function unpause() external onlyGovernor whenPaused {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/shared/InitializableReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n *\\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\\n * metering changes introduced in the Istanbul hardfork.\\n */\\ncontract InitializableReentrancyGuard {\\n    bool private _notEntered;\\n\\n    function _initializeReentrancyGuard() internal {\\n        // Storing an initial non-zero value makes deployment a bit more\\n        // expensive, but in exchange the refund on every call to nonReentrant\\n        // will be lower in amount. Since refunds are capped to a percetange of\\n        // the total transaction's gas, it is best to keep them low in cases\\n        // like this one, to increase the likelihood of the full refund coming\\n        // into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/shared/IBasicToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IBasicToken {\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/shared/StableMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title   StableMath\\n * @author  mStable\\n * @notice  A library providing safe mathematical operations to multiply and\\n *          divide with standardised precision.\\n * @dev     Derives from OpenZeppelin's SafeMath lib and uses generic system\\n *          wide variables for managing precision.\\n */\\nlibrary StableMath {\\n    /**\\n     * @dev Scaling unit for use in specific calculations,\\n     * where 1 * 10**18, or 1e18 represents a unit '1'\\n     */\\n    uint256 private constant FULL_SCALE = 1e18;\\n\\n    /**\\n     * @dev Token Ratios are used when converting between units of bAsset, mAsset and MTA\\n     * Reasoning: Takes into account token decimals, and difference in base unit (i.e. grams to Troy oz for gold)\\n     * bAsset ratio unit for use in exact calculations,\\n     * where (1 bAsset unit * bAsset.ratio) / ratioScale == x mAsset unit\\n     */\\n    uint256 private constant RATIO_SCALE = 1e8;\\n\\n    /**\\n     * @dev Provides an interface to the scaling unit\\n     * @return Scaling unit (1e18 or 1 * 10**18)\\n     */\\n    function getFullScale() internal pure returns (uint256) {\\n        return FULL_SCALE;\\n    }\\n\\n    /**\\n     * @dev Provides an interface to the ratio unit\\n     * @return Ratio scale unit (1e8 or 1 * 10**8)\\n     */\\n    function getRatioScale() internal pure returns (uint256) {\\n        return RATIO_SCALE;\\n    }\\n\\n    /**\\n     * @dev Scales a given integer to the power of the full scale.\\n     * @param x   Simple uint256 to scale\\n     * @return    Scaled value a to an exact number\\n     */\\n    function scaleInteger(uint256 x) internal pure returns (uint256) {\\n        return x * FULL_SCALE;\\n    }\\n\\n    /***************************************\\n              PRECISE ARITHMETIC\\n    ****************************************/\\n\\n    /**\\n     * @dev Multiplies two precise units, and then truncates by the full scale\\n     * @param x     Left hand input to multiplication\\n     * @param y     Right hand input to multiplication\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              scale unit\\n     */\\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulTruncateScale(x, y, FULL_SCALE);\\n    }\\n\\n    /**\\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\\n     * @param x     Left hand input to multiplication\\n     * @param y     Right hand input to multiplication\\n     * @param scale Scale unit\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              scale unit\\n     */\\n    function mulTruncateScale(\\n        uint256 x,\\n        uint256 y,\\n        uint256 scale\\n    ) internal pure returns (uint256) {\\n        // e.g. assume scale = fullScale\\n        // z = 10e18 * 9e17 = 9e36\\n        // return 9e36 / 1e18 = 9e18\\n        return (x * y) / scale;\\n    }\\n\\n    /**\\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\\n     * @param x     Left hand input to multiplication\\n     * @param y     Right hand input to multiplication\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              scale unit, rounded up to the closest base unit.\\n     */\\n    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\\n        // e.g. 8e17 * 17268172638 = 138145381104e17\\n        uint256 scaled = x * y;\\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\\n        uint256 ceil = scaled + FULL_SCALE - 1;\\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\\n        return ceil / FULL_SCALE;\\n    }\\n\\n    /**\\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\\n     * @param x     Left hand input to division\\n     * @param y     Right hand input to division\\n     * @return      Result after multiplying the left operand by the scale, and\\n     *              executing the division on the right hand input.\\n     */\\n    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\\n        // e.g. 8e18 * 1e18 = 8e36\\n        // e.g. 8e36 / 10e18 = 8e17\\n        return (x * FULL_SCALE) / y;\\n    }\\n\\n    /***************************************\\n                  RATIO FUNCS\\n    ****************************************/\\n\\n    /**\\n     * @dev Multiplies and truncates a token ratio, essentially flooring the result\\n     *      i.e. How much mAsset is this bAsset worth?\\n     * @param x     Left hand operand to multiplication (i.e Exact quantity)\\n     * @param ratio bAsset ratio\\n     * @return c    Result after multiplying the two inputs and then dividing by the ratio scale\\n     */\\n    function mulRatioTruncate(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\\n        return mulTruncateScale(x, ratio, RATIO_SCALE);\\n    }\\n\\n    /**\\n     * @dev Multiplies and truncates a token ratio, rounding up the result\\n     *      i.e. How much mAsset is this bAsset worth?\\n     * @param x     Left hand input to multiplication (i.e Exact quantity)\\n     * @param ratio bAsset ratio\\n     * @return      Result after multiplying the two inputs and then dividing by the shared\\n     *              ratio scale, rounded up to the closest base unit.\\n     */\\n    function mulRatioTruncateCeil(uint256 x, uint256 ratio) internal pure returns (uint256) {\\n        // e.g. How much mAsset should I burn for this bAsset (x)?\\n        // 1e18 * 1e8 = 1e26\\n        uint256 scaled = x * ratio;\\n        // 1e26 + 9.99e7 = 100..00.999e8\\n        uint256 ceil = scaled + RATIO_SCALE - 1;\\n        // return 100..00.999e8 / 1e8 = 1e18\\n        return ceil / RATIO_SCALE;\\n    }\\n\\n    /**\\n     * @dev Precisely divides two ratioed units, by first scaling the left hand operand\\n     *      i.e. How much bAsset is this mAsset worth?\\n     * @param x     Left hand operand in division\\n     * @param ratio bAsset ratio\\n     * @return c    Result after multiplying the left operand by the scale, and\\n     *              executing the division on the right hand input.\\n     */\\n    function divRatioPrecisely(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\\n        // e.g. 1e14 * 1e8 = 1e22\\n        // return 1e22 / 1e12 = 1e10\\n        return (x * RATIO_SCALE) / ratio;\\n    }\\n\\n    /***************************************\\n                    HELPERS\\n    ****************************************/\\n\\n    /**\\n     * @dev Calculates minimum of two numbers\\n     * @param x     Left hand input\\n     * @param y     Right hand input\\n     * @return      Minimum of the two inputs\\n     */\\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? y : x;\\n    }\\n\\n    /**\\n     * @dev Calculated maximum of two numbers\\n     * @param x     Left hand input\\n     * @param y     Right hand input\\n     * @return      Maximum of the two inputs\\n     */\\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x > y ? x : y;\\n    }\\n\\n    /**\\n     * @dev Clamps a value to an upper bound\\n     * @param x           Left hand input\\n     * @param upperBound  Maximum possible value to return\\n     * @return            Input x clamped to a maximum value, upperBound\\n     */\\n    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\\n        return x > upperBound ? upperBound : x;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/feeders/FeederManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\npragma abicoder v2;\\n\\n// External\\nimport { IPlatformIntegration } from \\\"../interfaces/IPlatformIntegration.sol\\\";\\n\\n// Internal\\nimport \\\"../masset/MassetStructs.sol\\\";\\n\\n// Libs\\nimport { SafeCast } from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { StableMath } from \\\"../shared/StableMath.sol\\\";\\n\\n/**\\n * @title   FeederManager\\n * @author  mStable\\n * @notice  Manager contract for fPools. Forked from `masset/Manager.sol`, and performs a subset of functionality\\n *          related to basket management.\\n * @dev     VERSION: 1.0\\n *          DATE:    2021-03-01\\n */\\nlibrary FeederManager {\\n    using SafeERC20 for IERC20;\\n    using StableMath for uint256;\\n\\n    event BassetsMigrated(address[] bAssets, address newIntegrator);\\n    event StartRampA(uint256 currentA, uint256 targetA, uint256 startTime, uint256 rampEndTime);\\n    event StopRampA(uint256 currentA, uint256 time);\\n\\n    uint256 private constant MIN_RAMP_TIME = 1 days;\\n    uint256 private constant MAX_A = 1e6;\\n\\n    /**\\n     * @dev Calculates the gains accrued across all lending markets.\\n     * @param _bAssetPersonal   Basset personal storage array\\n     * @param _bAssetData       Basset data storage array\\n     * @return idxs             Array [0,1]\\n     * @return rawGains         Raw increases in vault Balance\\n     */\\n    function calculatePlatformInterest(\\n        BassetPersonal[] memory _bAssetPersonal,\\n        BassetData[] storage _bAssetData\\n    ) external returns (uint8[] memory idxs, uint256[] memory rawGains) {\\n        // Get basket details\\n        BassetData[] memory bAssetData_ = _bAssetData;\\n        uint256 count = bAssetData_.length;\\n        idxs = new uint8[](count);\\n        rawGains = new uint256[](count);\\n        // 1. Calculate rawGains in each bAsset, in comparison to current vault balance\\n        for (uint256 i = 0; i < count; i++) {\\n            idxs[i] = uint8(i);\\n            BassetPersonal memory bPersonal = _bAssetPersonal[i];\\n            BassetData memory bData = bAssetData_[i];\\n            // If there is no integration, then nothing can have accrued\\n            if (bPersonal.integrator == address(0)) continue;\\n            uint256 lending = IPlatformIntegration(bPersonal.integrator).checkBalance(\\n                bPersonal.addr\\n            );\\n            uint256 cache = 0;\\n            if (!bPersonal.hasTxFee) {\\n                cache = IERC20(bPersonal.addr).balanceOf(bPersonal.integrator);\\n            }\\n            uint256 balance = lending + cache;\\n            uint256 oldVaultBalance = bData.vaultBalance;\\n            if (balance > oldVaultBalance && bPersonal.status == BassetStatus.Normal) {\\n                _bAssetData[i].vaultBalance = SafeCast.toUint128(balance);\\n                uint256 interestDelta = balance - oldVaultBalance;\\n                rawGains[i] = interestDelta;\\n            } else {\\n                rawGains[i] = 0;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers all collateral from one lending market to another - used initially\\n     *      to handle the migration between Aave V1 and Aave V2. Note - only supports non\\n     *      tx fee enabled assets. Supports going from no integration to integration, but\\n     *      not the other way around.\\n     * @param _bAssetPersonal   Basset data storage array\\n     * @param _bAssets          Array of basket assets to migrate\\n     * @param _newIntegration   Address of the new platform integration\\n     */\\n    function migrateBassets(\\n        BassetPersonal[] storage _bAssetPersonal,\\n        address[] calldata _bAssets,\\n        address _newIntegration\\n    ) external {\\n        uint256 len = _bAssets.length;\\n        require(len > 0, \\\"Must migrate some bAssets\\\");\\n\\n        for (uint256 i = 0; i < len; i++) {\\n            // 1. Check that the bAsset is in the basket\\n            address bAsset = _bAssets[i];\\n            uint256 index = _getAssetIndex(_bAssetPersonal, bAsset);\\n            require(!_bAssetPersonal[index].hasTxFee, \\\"A bAsset has a transfer fee\\\");\\n\\n            // 2. Withdraw everything from the old platform integration\\n            address oldAddress = _bAssetPersonal[index].integrator;\\n            require(oldAddress != _newIntegration, \\\"Must transfer to new integrator\\\");\\n            (uint256 cache, uint256 lendingBal) = (0, 0);\\n            if (oldAddress == address(0)) {\\n                cache = IERC20(bAsset).balanceOf(address(this));\\n            } else {\\n                IPlatformIntegration oldIntegration = IPlatformIntegration(oldAddress);\\n                cache = IERC20(bAsset).balanceOf(address(oldIntegration));\\n                // 2.1. Withdraw from the lending market\\n                lendingBal = oldIntegration.checkBalance(bAsset);\\n                if (lendingBal > 0) {\\n                    oldIntegration.withdraw(address(this), bAsset, lendingBal, false);\\n                }\\n                // 2.2. Withdraw from the cache, if any\\n                if (cache > 0) {\\n                    oldIntegration.withdrawRaw(address(this), bAsset, cache);\\n                }\\n            }\\n            uint256 sum = lendingBal + cache;\\n\\n            // 3. Update the integration address for this bAsset\\n            _bAssetPersonal[index].integrator = _newIntegration;\\n\\n            // 4. Deposit everything into the new\\n            //    This should fail if we did not receive the full amount from the platform withdrawal\\n            // 4.1. Deposit all bAsset\\n            IERC20(bAsset).safeTransfer(_newIntegration, sum);\\n            IPlatformIntegration newIntegration = IPlatformIntegration(_newIntegration);\\n            if (lendingBal > 0) {\\n                newIntegration.deposit(bAsset, lendingBal, false);\\n            }\\n            // 4.2. Check balances\\n            uint256 newLendingBal = newIntegration.checkBalance(bAsset);\\n            uint256 newCache = IERC20(bAsset).balanceOf(address(newIntegration));\\n            uint256 upperMargin = 10001e14;\\n            uint256 lowerMargin = 9999e14;\\n\\n            require(\\n                newLendingBal >= lendingBal.mulTruncate(lowerMargin) &&\\n                    newLendingBal <= lendingBal.mulTruncate(upperMargin),\\n                \\\"Must transfer full amount\\\"\\n            );\\n            require(\\n                newCache >= cache.mulTruncate(lowerMargin) &&\\n                    newCache <= cache.mulTruncate(upperMargin),\\n                \\\"Must transfer full amount\\\"\\n            );\\n        }\\n\\n        emit BassetsMigrated(_bAssets, _newIntegration);\\n    }\\n\\n    /**\\n     * @dev Simply gets the asset index by looping through bAssets. Given there are only\\n     * ever 2 assets, should not be gas intensive.\\n     */\\n    function _getAssetIndex(BassetPersonal[] storage _bAssetPersonal, address _asset)\\n        internal\\n        view\\n        returns (uint8 idx)\\n    {\\n        uint256 len = _bAssetPersonal.length;\\n        for (uint8 i = 0; i < len; i++) {\\n            if (_bAssetPersonal[i].addr == _asset) return i;\\n        }\\n        revert(\\\"Invalid asset\\\");\\n    }\\n\\n    /**\\n     * @dev Starts changing of the amplification var A\\n     * @param _targetA      Target A value\\n     * @param _rampEndTime  Time at which A will arrive at _targetA\\n     */\\n    function startRampA(\\n        AmpData storage _ampData,\\n        uint256 _targetA,\\n        uint256 _rampEndTime,\\n        uint256 _currentA,\\n        uint256 _precision\\n    ) external {\\n        require(\\n            block.timestamp >= (_ampData.rampStartTime + MIN_RAMP_TIME),\\n            \\\"Sufficient period of previous ramp has not elapsed\\\"\\n        );\\n        require(_rampEndTime >= (block.timestamp + MIN_RAMP_TIME), \\\"Ramp time too short\\\");\\n        require(_targetA > 0 && _targetA < MAX_A, \\\"A target out of bounds\\\");\\n\\n        uint256 preciseTargetA = _targetA * _precision;\\n\\n        if (preciseTargetA > _currentA) {\\n            require(preciseTargetA <= _currentA * 10, \\\"A target increase too big\\\");\\n        } else {\\n            require(preciseTargetA >= _currentA / 10, \\\"A target decrease too big\\\");\\n        }\\n\\n        _ampData.initialA = SafeCast.toUint64(_currentA);\\n        _ampData.targetA = SafeCast.toUint64(preciseTargetA);\\n        _ampData.rampStartTime = SafeCast.toUint64(block.timestamp);\\n        _ampData.rampEndTime = SafeCast.toUint64(_rampEndTime);\\n\\n        emit StartRampA(_currentA, preciseTargetA, block.timestamp, _rampEndTime);\\n    }\\n\\n    /**\\n     * @dev Stops the changing of the amplification var A, setting\\n     * it to whatever the current value is.\\n     */\\n    function stopRampA(AmpData storage _ampData, uint256 _currentA) external {\\n        require(block.timestamp < _ampData.rampEndTime, \\\"Amplification not changing\\\");\\n\\n        _ampData.initialA = SafeCast.toUint64(_currentA);\\n        _ampData.targetA = SafeCast.toUint64(_currentA);\\n        _ampData.rampStartTime = SafeCast.toUint64(block.timestamp);\\n        _ampData.rampEndTime = SafeCast.toUint64(block.timestamp);\\n\\n        emit StopRampA(_currentA, block.timestamp);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/feeders/FeederLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n// External\\nimport { IPlatformIntegration } from \\\"../interfaces/IPlatformIntegration.sol\\\";\\nimport { IMasset } from \\\"../interfaces/IMasset.sol\\\";\\n\\n// Internal\\nimport \\\"../masset/MassetStructs.sol\\\";\\n\\n// Libs\\nimport { Root } from \\\"../shared/Root.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { SafeCast } from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport { MassetHelpers } from \\\"../shared/MassetHelpers.sol\\\";\\nimport { StableMath } from \\\"../shared/StableMath.sol\\\";\\n\\n/**\\n * @title   FeederLogic\\n * @author  mStable\\n * @notice  Logic contract for feeder pools that calculates trade output and updates core state.\\n *          Includes modular invariant application code applying the StableSwap invariant first designed\\n *          by Curve Finance and derived for mStable application in MIP-8 (https://mips.mstable.org/MIPS/mip-8)\\n * @dev     VERSION: 1.0\\n *          DATE:    2021-03-01\\n */\\nlibrary FeederLogic {\\n    using StableMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    uint256 internal constant A_PRECISION = 100;\\n\\n    /***************************************\\n                    MINT\\n    ****************************************/\\n\\n    /**\\n     * @notice Transfers token in, updates internal balances and computes the fpToken output\\n     * @param _data                 Feeder pool storage state\\n     * @param _config               Core config for use in the invariant validator\\n     * @param _input                Data on the bAsset to deposit for the minted fpToken.\\n     * @param _inputQuantity        Quantity in input token units.\\n     * @param _minOutputQuantity    Minimum fpToken quantity to be minted. This protects against slippage.\\n     * @return mintOutput           Quantity of fpToken minted from the deposited bAsset.\\n     */\\n    function mint(\\n        FeederData storage _data,\\n        FeederConfig calldata _config,\\n        Asset calldata _input,\\n        uint256 _inputQuantity,\\n        uint256 _minOutputQuantity\\n    ) external returns (uint256 mintOutput) {\\n        BassetData[] memory cachedBassetData = _data.bAssetData;\\n        AssetData memory inputData = _transferIn(\\n            _data,\\n            _config,\\n            cachedBassetData,\\n            _input,\\n            _inputQuantity\\n        );\\n        // Validation should be after token transfer, as real input amt is unknown before\\n        mintOutput = computeMint(cachedBassetData, inputData.idx, inputData.amt, _config);\\n        require(mintOutput >= _minOutputQuantity, \\\"Mint quantity < min qty\\\");\\n    }\\n\\n    /**\\n     * @notice Transfers tokens in, updates internal balances and computes the fpToken output.\\n     * Only fAsset & mAsset are supported in this path.\\n     * @param _data                 Feeder pool storage state\\n     * @param _config               Core config for use in the invariant validator\\n     * @param _indices              Non-duplicate addresses of the bAssets to deposit for the minted fpToken.\\n     * @param _inputQuantities      Quantity of each input in input token units.\\n     * @param _minOutputQuantity    Minimum fpToken quantity to be minted. This protects against slippage.\\n     * @return mintOutput           Quantity of fpToken minted from the deposited bAsset.\\n     */\\n    function mintMulti(\\n        FeederData storage _data,\\n        FeederConfig calldata _config,\\n        uint8[] calldata _indices,\\n        uint256[] calldata _inputQuantities,\\n        uint256 _minOutputQuantity\\n    ) external returns (uint256 mintOutput) {\\n        uint256 len = _indices.length;\\n        uint256[] memory quantitiesDeposited = new uint256[](len);\\n        // Load bAssets from storage into memory\\n        BassetData[] memory allBassets = _data.bAssetData;\\n        uint256 maxCache = _getCacheDetails(_data, _config.supply);\\n        // Transfer the Bassets to the integrator & update storage\\n        for (uint256 i = 0; i < len; i++) {\\n            if (_inputQuantities[i] > 0) {\\n                uint8 idx = _indices[i];\\n                BassetData memory bData = allBassets[idx];\\n                quantitiesDeposited[i] = _depositTokens(\\n                    _data.bAssetPersonal[idx],\\n                    bData.ratio,\\n                    _inputQuantities[i],\\n                    maxCache\\n                );\\n\\n                _data.bAssetData[idx].vaultBalance =\\n                    bData.vaultBalance +\\n                    SafeCast.toUint128(quantitiesDeposited[i]);\\n            }\\n        }\\n        // Validate the proposed mint, after token transfer\\n        mintOutput = computeMintMulti(allBassets, _indices, quantitiesDeposited, _config);\\n        require(mintOutput >= _minOutputQuantity, \\\"Mint quantity < min qty\\\");\\n        require(mintOutput > 0, \\\"Zero mAsset quantity\\\");\\n    }\\n\\n    /***************************************\\n                    SWAP\\n    ****************************************/\\n\\n    /**\\n     * @notice Swaps two assets - either internally between fAsset<>mAsset, or between fAsset<>mpAsset by\\n     * first routing through the mAsset pool.\\n     * @param _data              Feeder pool storage state\\n     * @param _config            Core config for use in the invariant validator\\n     * @param _input             Data on bAsset to deposit\\n     * @param _output            Data on bAsset to withdraw\\n     * @param _inputQuantity     Units of input bAsset to swap in\\n     * @param _minOutputQuantity Minimum quantity of the swap output asset. This protects against slippage\\n     * @param _recipient         Address to transfer output asset to\\n     * @return swapOutput        Quantity of output asset returned from swap\\n     * @return localFee          Fee paid, in fpToken terms\\n     */\\n    function swap(\\n        FeederData storage _data,\\n        FeederConfig calldata _config,\\n        Asset calldata _input,\\n        Asset calldata _output,\\n        uint256 _inputQuantity,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) external returns (uint256 swapOutput, uint256 localFee) {\\n        BassetData[] memory cachedBassetData = _data.bAssetData;\\n\\n        AssetData memory inputData = _transferIn(\\n            _data,\\n            _config,\\n            cachedBassetData,\\n            _input,\\n            _inputQuantity\\n        );\\n        // 1. [f/mAsset ->][ f/mAsset]               : Y - normal in, SWAP, normal out\\n        // 3. [mpAsset -> mAsset][ -> fAsset]        : Y - mint in  , SWAP, normal out\\n        if (_output.exists) {\\n            (swapOutput, localFee) = _swapLocal(\\n                _data,\\n                _config,\\n                cachedBassetData,\\n                inputData,\\n                _output,\\n                _minOutputQuantity,\\n                _recipient\\n            );\\n        }\\n        // 2. [fAsset ->][ mAsset][ -> mpAsset]      : Y - normal in, SWAP, mpOut\\n        else {\\n            address mAsset = _data.bAssetPersonal[0].addr;\\n            (swapOutput, localFee) = _swapLocal(\\n                _data,\\n                _config,\\n                cachedBassetData,\\n                inputData,\\n                Asset(0, mAsset, true),\\n                0,\\n                address(this)\\n            );\\n            swapOutput = IMasset(mAsset).redeem(\\n                _output.addr,\\n                swapOutput,\\n                _minOutputQuantity,\\n                _recipient\\n            );\\n        }\\n    }\\n\\n    /***************************************\\n                    REDEEM\\n    ****************************************/\\n\\n    /**\\n     * @notice Burns a specified quantity of the senders fpToken in return for a bAsset. The output amount is derived\\n     * from the invariant. Supports redemption into either the fAsset, mAsset or assets in the mAsset basket.\\n     * @param _data              Feeder pool storage state\\n     * @param _config            Core config for use in the invariant validator\\n     * @param _output            Data on bAsset to withdraw\\n     * @param _fpTokenQuantity   Quantity of fpToken to burn\\n     * @param _minOutputQuantity Minimum bAsset quantity to receive for the burnt fpToken. This protects against slippage.\\n     * @param _recipient         Address to transfer the withdrawn bAssets to.\\n     * @return outputQuantity    Quanity of bAsset units received for the burnt fpToken\\n     * @return localFee          Fee paid, in fpToken terms\\n     */\\n    function redeem(\\n        FeederData storage _data,\\n        FeederConfig calldata _config,\\n        Asset calldata _output,\\n        uint256 _fpTokenQuantity,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) external returns (uint256 outputQuantity, uint256 localFee) {\\n        if (_output.exists) {\\n            (outputQuantity, localFee) = _redeemLocal(\\n                _data,\\n                _config,\\n                _output,\\n                _fpTokenQuantity,\\n                _minOutputQuantity,\\n                _recipient\\n            );\\n        } else {\\n            address mAsset = _data.bAssetPersonal[0].addr;\\n            (outputQuantity, localFee) = _redeemLocal(\\n                _data,\\n                _config,\\n                Asset(0, mAsset, true),\\n                _fpTokenQuantity,\\n                0,\\n                address(this)\\n            );\\n            outputQuantity = IMasset(mAsset).redeem(\\n                _output.addr,\\n                outputQuantity,\\n                _minOutputQuantity,\\n                _recipient\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Credits a recipient with a proportionate amount of bAssets, relative to current vault\\n     * balance levels and desired fpToken quantity. Burns the fpToken as payment. Only fAsset & mAsset are supported in this path.\\n     * @param _data                 Feeder pool storage state\\n     * @param _config               Core config for use in the invariant validator\\n     * @param _inputQuantity        Quantity of fpToken to redeem\\n     * @param _minOutputQuantities  Min units of output to receive\\n     * @param _recipient            Address to credit the withdrawn bAssets\\n     * @return scaledFee            Fee collected in fpToken terms\\n     * @return outputs              Array of output asset addresses\\n     * @return outputQuantities     Array of output asset quantities\\n     */\\n    function redeemProportionately(\\n        FeederData storage _data,\\n        FeederConfig calldata _config,\\n        uint256 _inputQuantity,\\n        uint256[] calldata _minOutputQuantities,\\n        address _recipient\\n    )\\n        external\\n        returns (\\n            uint256 scaledFee,\\n            address[] memory outputs,\\n            uint256[] memory outputQuantities\\n        )\\n    {\\n        // Calculate mAsset redemption quantities\\n        scaledFee = _inputQuantity.mulTruncate(_data.redemptionFee);\\n        // cache = (config.supply - inputQuantity) * 0.2\\n        uint256 maxCache = _getCacheDetails(_data, _config.supply - _inputQuantity);\\n\\n        // Load the bAsset data from storage into memory\\n        BassetData[] memory allBassets = _data.bAssetData;\\n        uint256 len = allBassets.length;\\n        outputs = new address[](len);\\n        outputQuantities = new uint256[](len);\\n        for (uint256 i = 0; i < len; i++) {\\n            // Get amount out, proportionate to redemption quantity\\n            uint256 amountOut = (allBassets[i].vaultBalance * (_inputQuantity - scaledFee)) /\\n                _config.supply;\\n            require(amountOut > 1, \\\"Output == 0\\\");\\n            amountOut -= 1;\\n            require(amountOut >= _minOutputQuantities[i], \\\"bAsset qty < min qty\\\");\\n            // Set output in array\\n            (outputQuantities[i], outputs[i]) = (amountOut, _data.bAssetPersonal[i].addr);\\n            // Transfer the bAsset to the recipient\\n            _withdrawTokens(\\n                amountOut,\\n                _data.bAssetPersonal[i],\\n                allBassets[i],\\n                _recipient,\\n                maxCache\\n            );\\n            // Reduce vaultBalance\\n            _data.bAssetData[i].vaultBalance =\\n                allBassets[i].vaultBalance -\\n                SafeCast.toUint128(amountOut);\\n        }\\n    }\\n\\n    /**\\n     * @dev Credits a recipient with a certain quantity of selected bAssets, in exchange for burning the\\n     *      relative fpToken quantity from the sender. Only fAsset & mAsset (0,1) are supported in this path.\\n     * @param _data                 Feeder pool storage state\\n     * @param _config               Core config for use in the invariant validator\\n     * @param _indices              Indices of the bAssets to receive\\n     * @param _outputQuantities     Units of the bAssets to receive\\n     * @param _maxInputQuantity     Maximum fpToken quantity to burn for the received bAssets. This protects against slippage.\\n     * @param _recipient            Address to receive the withdrawn bAssets\\n     * @return fpTokenQuantity      Quantity of fpToken units to burn as payment\\n     * @return localFee             Fee collected, in fpToken terms\\n     */\\n    function redeemExactBassets(\\n        FeederData storage _data,\\n        FeederConfig memory _config,\\n        uint8[] calldata _indices,\\n        uint256[] calldata _outputQuantities,\\n        uint256 _maxInputQuantity,\\n        address _recipient\\n    ) external returns (uint256 fpTokenQuantity, uint256 localFee) {\\n        // Load bAsset data from storage to memory\\n        BassetData[] memory allBassets = _data.bAssetData;\\n\\n        // Validate redemption\\n        uint256 fpTokenRequired = computeRedeemExact(\\n            allBassets,\\n            _indices,\\n            _outputQuantities,\\n            _config\\n        );\\n        fpTokenQuantity = fpTokenRequired.divPrecisely(1e18 - _data.redemptionFee);\\n        localFee = fpTokenQuantity - fpTokenRequired;\\n        require(fpTokenQuantity > 0, \\\"Must redeem some mAssets\\\");\\n        fpTokenQuantity += 1;\\n        require(fpTokenQuantity <= _maxInputQuantity, \\\"Redeem mAsset qty > max quantity\\\");\\n\\n        // Burn the full amount of Masset\\n        uint256 maxCache = _getCacheDetails(_data, _config.supply - fpTokenQuantity);\\n        // Transfer the Bassets to the recipient\\n        for (uint256 i = 0; i < _outputQuantities.length; i++) {\\n            _withdrawTokens(\\n                _outputQuantities[i],\\n                _data.bAssetPersonal[_indices[i]],\\n                allBassets[_indices[i]],\\n                _recipient,\\n                maxCache\\n            );\\n            _data.bAssetData[_indices[i]].vaultBalance =\\n                allBassets[_indices[i]].vaultBalance -\\n                SafeCast.toUint128(_outputQuantities[i]);\\n        }\\n    }\\n\\n    /***************************************\\n                FORGING - INTERNAL\\n    ****************************************/\\n\\n    /**\\n     * @dev Transfers an asset in and updates vault balance. Supports fAsset, mAsset and mpAsset.\\n     * Transferring an mpAsset requires first a mint in the main pool, and consequent depositing of\\n     * the mAsset.\\n     */\\n    function _transferIn(\\n        FeederData storage _data,\\n        FeederConfig memory _config,\\n        BassetData[] memory _cachedBassetData,\\n        Asset memory _input,\\n        uint256 _inputQuantity\\n    ) internal returns (AssetData memory inputData) {\\n        // fAsset / mAsset transfers\\n        if (_input.exists) {\\n            BassetPersonal memory personal = _data.bAssetPersonal[_input.idx];\\n            uint256 amt = _depositTokens(\\n                personal,\\n                _cachedBassetData[_input.idx].ratio,\\n                _inputQuantity,\\n                _getCacheDetails(_data, _config.supply)\\n            );\\n            inputData = AssetData(_input.idx, amt, personal);\\n        }\\n        // mpAsset transfers\\n        else {\\n            inputData = _mpMint(\\n                _data,\\n                _input,\\n                _inputQuantity,\\n                _getCacheDetails(_data, _config.supply)\\n            );\\n            require(inputData.amt > 0, \\\"Must mint something from mp\\\");\\n        }\\n        _data.bAssetData[inputData.idx].vaultBalance =\\n            _cachedBassetData[inputData.idx].vaultBalance +\\n            SafeCast.toUint128(inputData.amt);\\n    }\\n\\n    /**\\n     * @dev Mints an asset in the main mAsset pool. Input asset must be supported by the mAsset\\n     * or else the call will revert. After minting, check if the balance exceeds the cache upper limit\\n     * and consequently deposit if necessary.\\n     */\\n    function _mpMint(\\n        FeederData storage _data,\\n        Asset memory _input,\\n        uint256 _inputQuantity,\\n        uint256 _maxCache\\n    ) internal returns (AssetData memory mAssetData) {\\n        mAssetData = AssetData(0, 0, _data.bAssetPersonal[0]);\\n        IERC20(_input.addr).safeTransferFrom(msg.sender, address(this), _inputQuantity);\\n\\n        address integrator = mAssetData.personal.integrator == address(0)\\n            ? address(this)\\n            : mAssetData.personal.integrator;\\n\\n        uint256 balBefore = IERC20(mAssetData.personal.addr).balanceOf(integrator);\\n        // Mint will revert if the _input.addr is not whitelisted on that mAsset\\n        IMasset(mAssetData.personal.addr).mint(_input.addr, _inputQuantity, 0, integrator);\\n        uint256 balAfter = IERC20(mAssetData.personal.addr).balanceOf(integrator);\\n        mAssetData.amt = balAfter - balBefore;\\n\\n        // Route the mAsset to platform integration\\n        if (integrator != address(this)) {\\n            if (balAfter > _maxCache) {\\n                uint256 delta = balAfter - (_maxCache / 2);\\n                IPlatformIntegration(integrator).deposit(mAssetData.personal.addr, delta, false);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a swap between fAsset and mAsset. If the output is an mAsset, do not\\n     * charge the swap fee.\\n     */\\n    function _swapLocal(\\n        FeederData storage _data,\\n        FeederConfig memory _config,\\n        BassetData[] memory _cachedBassetData,\\n        AssetData memory _inputData,\\n        Asset memory _output,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) internal returns (uint256 swapOutput, uint256 scaledFee) {\\n        // Validate the swap\\n        (swapOutput, scaledFee) = computeSwap(\\n            _cachedBassetData,\\n            _inputData.idx,\\n            _output.idx,\\n            _inputData.amt,\\n            _output.idx == 0 ? 0 : _data.swapFee,\\n            _config\\n        );\\n        require(swapOutput >= _minOutputQuantity, \\\"Output qty < minimum qty\\\");\\n        require(swapOutput > 0, \\\"Zero output quantity\\\");\\n        // Settle the swap\\n        _withdrawTokens(\\n            swapOutput,\\n            _data.bAssetPersonal[_output.idx],\\n            _cachedBassetData[_output.idx],\\n            _recipient,\\n            _getCacheDetails(_data, _config.supply)\\n        );\\n        // Decrease output bal\\n        _data.bAssetData[_output.idx].vaultBalance =\\n            _cachedBassetData[_output.idx].vaultBalance -\\n            SafeCast.toUint128(swapOutput);\\n    }\\n\\n    /**\\n     * @dev Performs a local redemption into either fAsset or mAsset.\\n     */\\n    function _redeemLocal(\\n        FeederData storage _data,\\n        FeederConfig memory _config,\\n        Asset memory _output,\\n        uint256 _fpTokenQuantity,\\n        uint256 _minOutputQuantity,\\n        address _recipient\\n    ) internal returns (uint256 outputQuantity, uint256 scaledFee) {\\n        BassetData[] memory allBassets = _data.bAssetData;\\n        // Subtract the redemption fee\\n        scaledFee = _fpTokenQuantity.mulTruncate(_data.redemptionFee);\\n        // Calculate redemption quantities\\n        outputQuantity = computeRedeem(\\n            allBassets,\\n            _output.idx,\\n            _fpTokenQuantity - scaledFee,\\n            _config\\n        );\\n        require(outputQuantity >= _minOutputQuantity, \\\"bAsset qty < min qty\\\");\\n        require(outputQuantity > 0, \\\"Output == 0\\\");\\n\\n        // Transfer the bAssets to the recipient\\n        _withdrawTokens(\\n            outputQuantity,\\n            _data.bAssetPersonal[_output.idx],\\n            allBassets[_output.idx],\\n            _recipient,\\n            _getCacheDetails(_data, _config.supply - _fpTokenQuantity)\\n        );\\n        // Set vault balance\\n        _data.bAssetData[_output.idx].vaultBalance =\\n            allBassets[_output.idx].vaultBalance -\\n            SafeCast.toUint128(outputQuantity);\\n    }\\n\\n    /**\\n     * @dev Deposits a given asset to the system. If there is sufficient room for the asset\\n     * in the cache, then just transfer, otherwise reset the cache to the desired mid level by\\n     * depositing the delta in the platform\\n     */\\n    function _depositTokens(\\n        BassetPersonal memory _bAsset,\\n        uint256 _bAssetRatio,\\n        uint256 _quantity,\\n        uint256 _maxCache\\n    ) internal returns (uint256 quantityDeposited) {\\n        // 0. If integration is 0, short circuit\\n        if (_bAsset.integrator == address(0)) {\\n            (uint256 received, ) = MassetHelpers.transferReturnBalance(\\n                msg.sender,\\n                address(this),\\n                _bAsset.addr,\\n                _quantity\\n            );\\n            return received;\\n        }\\n\\n        // 1 - Send all to PI, using the opportunity to get the cache balance and net amount transferred\\n        uint256 cacheBal;\\n        (quantityDeposited, cacheBal) = MassetHelpers.transferReturnBalance(\\n            msg.sender,\\n            _bAsset.integrator,\\n            _bAsset.addr,\\n            _quantity\\n        );\\n\\n        // 2 - Deposit X if necessary\\n        // 2.1 - Deposit if xfer fees\\n        if (_bAsset.hasTxFee) {\\n            uint256 deposited = IPlatformIntegration(_bAsset.integrator).deposit(\\n                _bAsset.addr,\\n                quantityDeposited,\\n                true\\n            );\\n\\n            return StableMath.min(deposited, quantityDeposited);\\n        }\\n        // 2.2 - Else Deposit X if Cache > %\\n        // This check is in place to ensure that any token with a txFee is rejected\\n        require(quantityDeposited == _quantity, \\\"Asset not fully transferred\\\");\\n\\n        uint256 relativeMaxCache = _maxCache.divRatioPrecisely(_bAssetRatio);\\n\\n        if (cacheBal > relativeMaxCache) {\\n            uint256 delta = cacheBal - (relativeMaxCache / 2);\\n            IPlatformIntegration(_bAsset.integrator).deposit(_bAsset.addr, delta, false);\\n        }\\n    }\\n\\n    /**\\n     * @dev Withdraws a given asset from its platformIntegration. If there is sufficient liquidity\\n     * in the cache, then withdraw from there, otherwise withdraw from the lending market and reset the\\n     * cache to the mid level.\\n     */\\n    function _withdrawTokens(\\n        uint256 _quantity,\\n        BassetPersonal memory _personal,\\n        BassetData memory _data,\\n        address _recipient,\\n        uint256 _maxCache\\n    ) internal {\\n        if (_quantity == 0) return;\\n\\n        // 1.0 If there is no integrator, send from here\\n        if (_personal.integrator == address(0)) {\\n            // If this is part of a cross-swap or cross-redeem, and there is no\\n            // integrator.. then we don't need to transfer anywhere\\n            if (_recipient == address(this)) return;\\n            IERC20(_personal.addr).safeTransfer(_recipient, _quantity);\\n        }\\n        // 1.1 If txFee then short circuit - there is no cache\\n        else if (_personal.hasTxFee) {\\n            IPlatformIntegration(_personal.integrator).withdraw(\\n                _recipient,\\n                _personal.addr,\\n                _quantity,\\n                _quantity,\\n                true\\n            );\\n        }\\n        // 1.2. Else, withdraw from either cache or main vault\\n        else {\\n            uint256 cacheBal = IERC20(_personal.addr).balanceOf(_personal.integrator);\\n            // 2.1 - If balance b in cache, simply withdraw\\n            if (cacheBal >= _quantity) {\\n                IPlatformIntegration(_personal.integrator).withdrawRaw(\\n                    _recipient,\\n                    _personal.addr,\\n                    _quantity\\n                );\\n            }\\n            // 2.2 - Else reset the cache to X, or as far as possible\\n            //       - Withdraw X+b from platform\\n            //       - Send b to user\\n            else {\\n                uint256 relativeMidCache = _maxCache.divRatioPrecisely(_data.ratio) / 2;\\n                uint256 totalWithdrawal = StableMath.min(\\n                    relativeMidCache + _quantity - cacheBal,\\n                    _data.vaultBalance - SafeCast.toUint128(cacheBal)\\n                );\\n\\n                IPlatformIntegration(_personal.integrator).withdraw(\\n                    _recipient,\\n                    _personal.addr,\\n                    _quantity,\\n                    totalWithdrawal,\\n                    false\\n                );\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Gets the max cache size, given the supply of fpToken\\n     * @return maxCache    Max units of any given bAsset that should be held in the cache\\n     */\\n    function _getCacheDetails(FeederData storage _data, uint256 _supply)\\n        internal\\n        view\\n        returns (uint256 maxCache)\\n    {\\n        maxCache = (_supply * _data.cacheSize) / 1e18;\\n    }\\n\\n    /***************************************\\n                    INVARIANT\\n    ****************************************/\\n\\n    /**\\n     * @notice Compute the amount of fpToken received for minting\\n     * with `quantity` amount of bAsset index `i`.\\n     * @param _bAssets      Array of all bAsset Data\\n     * @param _i            Index of bAsset with which to mint\\n     * @param _rawInput     Raw amount of bAsset to use in mint\\n     * @param _config       Generalised FeederConfig stored externally\\n     * @return mintAmount   Quantity of fpTokens minted\\n     */\\n    function computeMint(\\n        BassetData[] memory _bAssets,\\n        uint8 _i,\\n        uint256 _rawInput,\\n        FeederConfig memory _config\\n    ) public pure returns (uint256 mintAmount) {\\n        // 1. Get raw reserves\\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\\n        // 2. Get value of reserves according to invariant\\n        uint256 k0 = _invariant(x, sum, _config.a);\\n        uint256 scaledInput = (_rawInput * _bAssets[_i].ratio) / 1e8;\\n        require(scaledInput > 1e6, \\\"Must add > 1e6 units\\\");\\n        // 3. Add deposit to x and sum\\n        x[_i] += scaledInput;\\n        sum += scaledInput;\\n        // 4. Finalise mint\\n        require(_inBounds(x, sum, _config.limits), \\\"Exceeds weight limits\\\");\\n        mintAmount = _computeMintOutput(x, sum, k0, _config);\\n    }\\n\\n    /**\\n     * @notice Compute the amount of fpToken received for minting\\n     * with the given array of inputs.\\n     * @param _bAssets      Array of all bAsset Data\\n     * @param _indices      Indexes of bAssets with which to mint\\n     * @param _rawInputs    Raw amounts of bAssets to use in mint\\n     * @param _config       Generalised FeederConfig stored externally\\n     * @return mintAmount   Quantity of fpTokens minted\\n     */\\n    function computeMintMulti(\\n        BassetData[] memory _bAssets,\\n        uint8[] memory _indices,\\n        uint256[] memory _rawInputs,\\n        FeederConfig memory _config\\n    ) public pure returns (uint256 mintAmount) {\\n        // 1. Get raw reserves\\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\\n        // 2. Get value of reserves according to invariant\\n        uint256 k0 = _invariant(x, sum, _config.a);\\n        // 3. Add deposits to x and sum\\n        uint256 len = _indices.length;\\n        uint8 idx;\\n        uint256 scaledInput;\\n        for (uint256 i = 0; i < len; i++) {\\n            idx = _indices[i];\\n            scaledInput = (_rawInputs[i] * _bAssets[idx].ratio) / 1e8;\\n            x[idx] += scaledInput;\\n            sum += scaledInput;\\n        }\\n        // 4. Finalise mint\\n        require(_inBounds(x, sum, _config.limits), \\\"Exceeds weight limits\\\");\\n        mintAmount = _computeMintOutput(x, sum, k0, _config);\\n    }\\n\\n    /**\\n     * @notice Compute the amount of bAsset received for swapping\\n     * `quantity` amount of index `input_idx` to index `output_idx`.\\n     * @param _bAssets      Array of all bAsset Data\\n     * @param _i            Index of bAsset to swap IN\\n     * @param _o            Index of bAsset to swap OUT\\n     * @param _rawInput     Raw amounts of input bAsset to input\\n     * @param _feeRate      Swap fee rate to apply to output\\n     * @param _config       Generalised FeederConfig stored externally\\n     * @return bAssetOutputQuantity   Raw bAsset output quantity\\n     * @return scaledSwapFee          Swap fee collected, in fpToken terms\\n     */\\n    function computeSwap(\\n        BassetData[] memory _bAssets,\\n        uint8 _i,\\n        uint8 _o,\\n        uint256 _rawInput,\\n        uint256 _feeRate,\\n        FeederConfig memory _config\\n    ) public pure returns (uint256 bAssetOutputQuantity, uint256 scaledSwapFee) {\\n        // 1. Get raw reserves\\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\\n        // 2. Get value of reserves according to invariant\\n        uint256 k0 = _invariant(x, sum, _config.a);\\n        // 3. Add deposits to x and sum\\n        uint256 scaledInput = (_rawInput * _bAssets[_i].ratio) / 1e8;\\n        require(scaledInput > 1e6, \\\"Must add > 1e6 units\\\");\\n        x[_i] += scaledInput;\\n        sum += scaledInput;\\n        // 4. Calc total fpToken q\\n        uint256 k1 = _invariant(x, sum, _config.a);\\n        scaledSwapFee = ((k1 - k0) * _feeRate) / 1e18;\\n        // 5. Calc output bAsset\\n        uint256 newOutputReserve = _solveInvariant(x, _config.a, _o, k0 + scaledSwapFee);\\n        // Convert swap fee to fpToken terms\\n        // fpFee = fee * s / k\\n        scaledSwapFee = (scaledSwapFee * _config.supply) / k0;\\n        uint256 output = x[_o] - newOutputReserve - 1;\\n        bAssetOutputQuantity = (output * 1e8) / _bAssets[_o].ratio;\\n        // 6. Check for bounds\\n        x[_o] -= output;\\n        sum -= output;\\n        require(_inBounds(x, sum, _config.limits), \\\"Exceeds weight limits\\\");\\n    }\\n\\n    /**\\n     * @notice Compute the amount of bAsset index `i` received for\\n     * redeeming `quantity` amount of fpToken.\\n     * @param _bAssets              Array of all bAsset Data\\n     * @param _o                    Index of output bAsset\\n     * @param _netRedeemInput       Net amount of fpToken to redeem\\n     * @param _config               Generalised FeederConfig stored externally\\n     * @return rawOutputUnits       Raw bAsset output returned\\n     */\\n    function computeRedeem(\\n        BassetData[] memory _bAssets,\\n        uint8 _o,\\n        uint256 _netRedeemInput,\\n        FeederConfig memory _config\\n    ) public pure returns (uint256 rawOutputUnits) {\\n        require(_netRedeemInput > 1e6, \\\"Must redeem > 1e6 units\\\");\\n        // 1. Get raw reserves\\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\\n        // 2. Get value of reserves according to invariant\\n        uint256 k0 = _invariant(x, sum, _config.a);\\n        uint256 kFinal = (k0 * (_config.supply - _netRedeemInput)) / _config.supply + 1;\\n        // 3. Compute bAsset output\\n        uint256 newOutputReserve = _solveInvariant(x, _config.a, _o, kFinal);\\n        uint256 output = x[_o] - newOutputReserve - 1;\\n        rawOutputUnits = (output * 1e8) / _bAssets[_o].ratio;\\n        // 4. Check for max weight\\n        x[_o] -= output;\\n        sum -= output;\\n        require(_inBounds(x, sum, _config.limits), \\\"Exceeds weight limits\\\");\\n    }\\n\\n    /**\\n     * @notice Compute the amount of fpToken required to redeem\\n     * a given selection of bAssets.\\n     * @param _bAssets          Array of all bAsset Data\\n     * @param _indices          Indexes of output bAssets\\n     * @param _rawOutputs       Desired raw bAsset outputs\\n     * @param _config           Generalised FeederConfig stored externally\\n     * @return redeemInput      Amount of fpToken required to redeem bAssets\\n     */\\n    function computeRedeemExact(\\n        BassetData[] memory _bAssets,\\n        uint8[] memory _indices,\\n        uint256[] memory _rawOutputs,\\n        FeederConfig memory _config\\n    ) public pure returns (uint256 redeemInput) {\\n        // 1. Get raw reserves\\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\\n        // 2. Get value of reserves according to invariant\\n        uint256 k0 = _invariant(x, sum, _config.a);\\n        // 3. Sub deposits from x and sum\\n        uint256 len = _indices.length;\\n        uint256 ratioed;\\n        for (uint256 i = 0; i < len; i++) {\\n            ratioed = (_rawOutputs[i] * _bAssets[_indices[i]].ratio) / 1e8;\\n            x[_indices[i]] -= ratioed;\\n            sum -= ratioed;\\n        }\\n        require(_inBounds(x, sum, _config.limits), \\\"Exceeds weight limits\\\");\\n        // 4. Get new value of reserves according to invariant\\n        uint256 k1 = _invariant(x, sum, _config.a);\\n        // 5. Total fpToken is the difference between values\\n        redeemInput = (_config.supply * (k0 - k1)) / k0;\\n        require(redeemInput > 1e6, \\\"Must redeem > 1e6 units\\\");\\n    }\\n\\n    /**\\n     * @notice Gets the price of the fpToken, and invariant value k\\n     * @param _bAssets  Array of all bAsset Data\\n     * @param _config   Generalised FeederConfig stored externally\\n     * @return price    Price of an fpToken\\n     * @return k        Total value of basket, k\\n     */\\n    function computePrice(BassetData[] memory _bAssets, FeederConfig memory _config)\\n        public\\n        pure\\n        returns (uint256 price, uint256 k)\\n    {\\n        (uint256[] memory x, uint256 sum) = _getReserves(_bAssets);\\n        k = _invariant(x, sum, _config.a);\\n        price = (1e18 * k) / _config.supply;\\n    }\\n\\n    /***************************************\\n                    INTERNAL\\n    ****************************************/\\n\\n    /**\\n     * @dev Computes the actual mint output after adding mint inputs\\n     * to the vault balances\\n     * @param _x            Scaled vaultBalances\\n     * @param _sum          Sum of vaultBalances, to avoid another loop\\n     * @param _k            Previous value of invariant, k, before addition\\n     * @param _config       Generalised FeederConfig stored externally\\n     * @return mintAmount   Amount of value added to invariant, in fpToken terms\\n     */\\n    function _computeMintOutput(\\n        uint256[] memory _x,\\n        uint256 _sum,\\n        uint256 _k,\\n        FeederConfig memory _config\\n    ) internal pure returns (uint256 mintAmount) {\\n        // 1. Get value of reserves according to invariant\\n        uint256 kFinal = _invariant(_x, _sum, _config.a);\\n        // 2. Total minted is the difference between values, with respect to total supply\\n        if (_config.supply == 0) {\\n            mintAmount = kFinal - _k;\\n        } else {\\n            mintAmount = (_config.supply * (kFinal - _k)) / _k;\\n        }\\n    }\\n\\n    /**\\n     * @dev Simply scaled raw reserve values and returns the sum\\n     * @param _bAssets  All bAssets\\n     * @return x        Scaled vault balances\\n     * @return sum      Sum of scaled vault balances\\n     */\\n    function _getReserves(BassetData[] memory _bAssets)\\n        internal\\n        pure\\n        returns (uint256[] memory x, uint256 sum)\\n    {\\n        uint256 len = _bAssets.length;\\n        x = new uint256[](len);\\n        uint256 r;\\n        for (uint256 i = 0; i < len; i++) {\\n            BassetData memory bAsset = _bAssets[i];\\n            r = (bAsset.vaultBalance * bAsset.ratio) / 1e8;\\n            x[i] = r;\\n            sum += r;\\n        }\\n    }\\n\\n    /**\\n     * @dev Checks that no bAsset reserves exceed max weight\\n     * @param _x            Scaled bAsset reserves\\n     * @param _sum          Sum of x, precomputed\\n     * @param _limits       Config object containing max and min weights\\n     * @return inBounds     Bool, true if all assets are within bounds\\n     */\\n    function _inBounds(\\n        uint256[] memory _x,\\n        uint256 _sum,\\n        WeightLimits memory _limits\\n    ) internal pure returns (bool inBounds) {\\n        uint256 len = _x.length;\\n        inBounds = true;\\n        uint256 w;\\n        for (uint256 i = 0; i < len; i++) {\\n            w = (_x[i] * 1e18) / _sum;\\n            if (w > _limits.max || w < _limits.min) return false;\\n        }\\n    }\\n\\n    /***************************************\\n                    INVARIANT\\n    ****************************************/\\n\\n    /**\\n     * @dev Compute the invariant f(x) for a given array of supplies `x`.\\n     * @param _x        Scaled vault balances\\n     * @param _sum      Sum of scaled vault balances\\n     * @param _a        Precise amplification coefficient\\n     * @return k        Cumulative value of all assets according to the invariant\\n     */\\n    function _invariant(\\n        uint256[] memory _x,\\n        uint256 _sum,\\n        uint256 _a\\n    ) internal pure returns (uint256 k) {\\n        if (_sum == 0) return 0;\\n\\n        uint256 var1 = _x[0] * _x[1];\\n        uint256 var2 = (_a * var1) / (_x[0] + _x[1]) / A_PRECISION;\\n        // result = 2 * (isqrt(var2**2 + (A + A_PRECISION) * var1 // A_PRECISION) - var2) + 1\\n        k = 2 * (Root.sqrt((var2**2) + (((_a + A_PRECISION) * var1) / A_PRECISION)) - var2) + 1;\\n    }\\n\\n    /**\\n     * @dev Solves the invariant for _i with respect to target K, given an array of reserves.\\n     * @param _x        Scaled reserve balances\\n     * @param _a        Precise amplification coefficient\\n     * @param _idx      Index of asset for which to solve\\n     * @param _targetK  Target invariant value K\\n     * @return y        New reserve of _i\\n     */\\n    function _solveInvariant(\\n        uint256[] memory _x,\\n        uint256 _a,\\n        uint8 _idx,\\n        uint256 _targetK\\n    ) internal pure returns (uint256 y) {\\n        require(_idx == 0 || _idx == 1, \\\"Invalid index\\\");\\n\\n        uint256 x = _idx == 0 ? _x[1] : _x[0];\\n        uint256 var1 = _a + A_PRECISION;\\n        uint256 var2 = ((_targetK**2) * A_PRECISION) / var1;\\n        // var3 = var2 // (4 * x) + k * _a // var1 - x\\n        uint256 tmp = var2 / (4 * x) + ((_targetK * _a) / var1);\\n        uint256 var3 = tmp >= x ? tmp - x : x - tmp;\\n        //  result = (sqrt(var3**2 + var2) + var3) // 2\\n        y = ((Root.sqrt((var3**2) + var2) + tmp - x) / 2) + 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/shared/@openzeppelin-2.5/ERC205.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport \\\"./Context.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20Mintable}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC205 is Context, IERC20 {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/shared/InitializableERC20Detailed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @dev Optional functions from the ERC20 standard.\\n * Converted from openzeppelin/contracts/token/ERC20/ERC20Detailed.sol\\n */\\nabstract contract InitializableERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\\n     * these values are immutable: they can only be set once during\\n     * construction.\\n     * @notice To avoid variable shadowing appended `Arg` after arguments name.\\n     */\\n    function _initialize(\\n        string memory nameArg,\\n        string memory symbolArg,\\n        uint8 decimalsArg\\n    ) internal {\\n        _name = nameArg;\\n        _symbol = symbolArg;\\n        _decimals = decimalsArg;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/shared/@openzeppelin-2.5/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    // constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/shared/ImmutableModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport { ModuleKeys } from \\\"./ModuleKeys.sol\\\";\\nimport { INexus } from \\\"../interfaces/INexus.sol\\\";\\n\\n/**\\n * @title   ImmutableModule\\n * @author  mStable\\n * @dev     Subscribes to module updates from a given publisher and reads from its registry.\\n *          Contract is used for upgradable proxy contracts.\\n */\\nabstract contract ImmutableModule is ModuleKeys {\\n    INexus public immutable nexus;\\n\\n    /**\\n     * @dev Initialization function for upgradable proxy contracts\\n     * @param _nexus Nexus contract address\\n     */\\n    constructor(address _nexus) {\\n        require(_nexus != address(0), \\\"Nexus address is zero\\\");\\n        nexus = INexus(_nexus);\\n    }\\n\\n    /**\\n     * @dev Modifier to allow function calls only from the Governor.\\n     */\\n    modifier onlyGovernor() {\\n        _onlyGovernor();\\n        _;\\n    }\\n\\n    function _onlyGovernor() internal view {\\n        require(msg.sender == _governor(), \\\"Only governor can execute\\\");\\n    }\\n\\n    /**\\n     * @dev Modifier to allow function calls only from the Governance.\\n     *      Governance is either Governor address or Governance address.\\n     */\\n    modifier onlyGovernance() {\\n        require(\\n            msg.sender == _governor() || msg.sender == _governance(),\\n            \\\"Only governance can execute\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns Governor address from the Nexus\\n     * @return Address of Governor Contract\\n     */\\n    function _governor() internal view returns (address) {\\n        return nexus.governor();\\n    }\\n\\n    /**\\n     * @dev Returns Governance Module address from the Nexus\\n     * @return Address of the Governance (Phase 2)\\n     */\\n    function _governance() internal view returns (address) {\\n        return nexus.getModule(KEY_GOVERNANCE);\\n    }\\n\\n    /**\\n     * @dev Return SavingsManager Module address from the Nexus\\n     * @return Address of the SavingsManager Module contract\\n     */\\n    function _savingsManager() internal view returns (address) {\\n        return nexus.getModule(KEY_SAVINGS_MANAGER);\\n    }\\n\\n    /**\\n     * @dev Return Recollateraliser Module address from the Nexus\\n     * @return  Address of the Recollateraliser Module contract (Phase 2)\\n     */\\n    function _recollateraliser() internal view returns (address) {\\n        return nexus.getModule(KEY_RECOLLATERALISER);\\n    }\\n\\n    /**\\n     * @dev Return Liquidator Module address from the Nexus\\n     * @return  Address of the Liquidator Module contract\\n     */\\n    function _liquidator() internal view returns (address) {\\n        return nexus.getModule(KEY_LIQUIDATOR);\\n    }\\n\\n    /**\\n     * @dev Return ProxyAdmin Module address from the Nexus\\n     * @return Address of the ProxyAdmin Module contract\\n     */\\n    function _proxyAdmin() internal view returns (address) {\\n        return nexus.getModule(KEY_PROXY_ADMIN);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/shared/ModuleKeys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title  ModuleKeys\\n * @author mStable\\n * @notice Provides system wide access to the byte32 represntations of system modules\\n *         This allows each system module to be able to reference and update one another in a\\n *         friendly way\\n * @dev    keccak256() values are hardcoded to avoid re-evaluation of the constants at runtime.\\n */\\ncontract ModuleKeys {\\n    // Governance\\n    // ===========\\n    // keccak256(\\\"Governance\\\");\\n    bytes32 internal constant KEY_GOVERNANCE =\\n        0x9409903de1e6fd852dfc61c9dacb48196c48535b60e25abf92acc92dd689078d;\\n    //keccak256(\\\"Staking\\\");\\n    bytes32 internal constant KEY_STAKING =\\n        0x1df41cd916959d1163dc8f0671a666ea8a3e434c13e40faef527133b5d167034;\\n    //keccak256(\\\"ProxyAdmin\\\");\\n    bytes32 internal constant KEY_PROXY_ADMIN =\\n        0x96ed0203eb7e975a4cbcaa23951943fa35c5d8288117d50c12b3d48b0fab48d1;\\n\\n    // mStable\\n    // =======\\n    // keccak256(\\\"OracleHub\\\");\\n    bytes32 internal constant KEY_ORACLE_HUB =\\n        0x8ae3a082c61a7379e2280f3356a5131507d9829d222d853bfa7c9fe1200dd040;\\n    // keccak256(\\\"Manager\\\");\\n    bytes32 internal constant KEY_MANAGER =\\n        0x6d439300980e333f0256d64be2c9f67e86f4493ce25f82498d6db7f4be3d9e6f;\\n    //keccak256(\\\"Recollateraliser\\\");\\n    bytes32 internal constant KEY_RECOLLATERALISER =\\n        0x39e3ed1fc335ce346a8cbe3e64dd525cf22b37f1e2104a755e761c3c1eb4734f;\\n    //keccak256(\\\"MetaToken\\\");\\n    bytes32 internal constant KEY_META_TOKEN =\\n        0xea7469b14936af748ee93c53b2fe510b9928edbdccac3963321efca7eb1a57a2;\\n    // keccak256(\\\"SavingsManager\\\");\\n    bytes32 internal constant KEY_SAVINGS_MANAGER =\\n        0x12fe936c77a1e196473c4314f3bed8eeac1d757b319abb85bdda70df35511bf1;\\n    // keccak256(\\\"Liquidator\\\");\\n    bytes32 internal constant KEY_LIQUIDATOR =\\n        0x1e9cb14d7560734a61fa5ff9273953e971ff3cd9283c03d8346e3264617933d4;\\n    // keccak256(\\\"InterestValidator\\\");\\n    bytes32 internal constant KEY_INTEREST_VALIDATOR =\\n        0xc10a28f028c7f7282a03c90608e38a4a646e136e614e4b07d119280c5f7f839f;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INexus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title INexus\\n * @dev Basic interface for interacting with the Nexus i.e. SystemKernel\\n */\\ninterface INexus {\\n    function governor() external view returns (address);\\n\\n    function getModule(bytes32 key) external view returns (address);\\n\\n    function proposeModule(bytes32 _key, address _addr) external;\\n\\n    function cancelProposedModule(bytes32 _key) external;\\n\\n    function acceptProposedModule(bytes32 _key) external;\\n\\n    function acceptProposedModules(bytes32[] calldata _keys) external;\\n\\n    function requestLockModule(bytes32 _key) external;\\n\\n    function cancelLockModule(bytes32 _key) external;\\n\\n    function lockModule(bytes32 _key) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPlatformIntegration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title Platform interface to integrate with lending platform like Compound, AAVE etc.\\n */\\ninterface IPlatformIntegration {\\n    /**\\n     * @dev Deposit the given bAsset to Lending platform\\n     * @param _bAsset bAsset address\\n     * @param _amount Amount to deposit\\n     */\\n    function deposit(\\n        address _bAsset,\\n        uint256 _amount,\\n        bool isTokenFeeCharged\\n    ) external returns (uint256 quantityDeposited);\\n\\n    /**\\n     * @dev Withdraw given bAsset from Lending platform\\n     */\\n    function withdraw(\\n        address _receiver,\\n        address _bAsset,\\n        uint256 _amount,\\n        bool _hasTxFee\\n    ) external;\\n\\n    /**\\n     * @dev Withdraw given bAsset from Lending platform\\n     */\\n    function withdraw(\\n        address _receiver,\\n        address _bAsset,\\n        uint256 _amount,\\n        uint256 _totalAmount,\\n        bool _hasTxFee\\n    ) external;\\n\\n    /**\\n     * @dev Withdraw given bAsset from the cache\\n     */\\n    function withdrawRaw(\\n        address _receiver,\\n        address _bAsset,\\n        uint256 _amount\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current balance of the given bAsset\\n     */\\n    function checkBalance(address _bAsset) external returns (uint256 balance);\\n}\\n\"\r\n    },\r\n    \"contracts/shared/Root.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nlibrary Root {\\n    /**\\n     * @dev Returns the square root of a given number\\n     * @param x Input\\n     * @return y Square root of Input\\n     */\\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\\n        if (x == 0) return 0;\\n        else {\\n            uint256 xx = x;\\n            uint256 r = 1;\\n            if (xx >= 0x100000000000000000000000000000000) {\\n                xx >>= 128;\\n                r <<= 64;\\n            }\\n            if (xx >= 0x10000000000000000) {\\n                xx >>= 64;\\n                r <<= 32;\\n            }\\n            if (xx >= 0x100000000) {\\n                xx >>= 32;\\n                r <<= 16;\\n            }\\n            if (xx >= 0x10000) {\\n                xx >>= 16;\\n                r <<= 8;\\n            }\\n            if (xx >= 0x100) {\\n                xx >>= 8;\\n                r <<= 4;\\n            }\\n            if (xx >= 0x10) {\\n                xx >>= 4;\\n                r <<= 2;\\n            }\\n            if (xx >= 0x8) {\\n                r <<= 1;\\n            }\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1; // Seven iterations should be enough\\n            uint256 r1 = x / r;\\n            return uint256(r < r1 ? r : r1);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/shared/MassetHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title   MassetHelpers\\n * @author  mStable\\n * @notice  Helper functions to facilitate minting and redemption from off chain\\n * @dev     VERSION: 1.0\\n *          DATE:    2020-03-28\\n */\\nlibrary MassetHelpers {\\n    using SafeERC20 for IERC20;\\n\\n    function transferReturnBalance(\\n        address _sender,\\n        address _recipient,\\n        address _bAsset,\\n        uint256 _qty\\n    ) internal returns (uint256 receivedQty, uint256 recipientBalance) {\\n        uint256 balBefore = IERC20(_bAsset).balanceOf(_recipient);\\n        IERC20(_bAsset).safeTransferFrom(_sender, _recipient, _qty);\\n        recipientBalance = IERC20(_bAsset).balanceOf(_recipient);\\n        receivedQty = recipientBalance - balBefore;\\n    }\\n\\n    function safeInfiniteApprove(address _asset, address _spender) internal {\\n        IERC20(_asset).safeApprove(_spender, 0);\\n        IERC20(_asset).safeApprove(_spender, 2**256 - 1);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/feeders/FeederManager.sol\": {\r\n        \"FeederManager\": \"0x90ae544e8cc76d2867987ee4f5456c02c50abd8b\"\r\n      },\r\n      \"contracts/feeders/FeederLogic.sol\": {\r\n        \"FeederLogic\": \"0x2837c77527c37d61d9763f53005211dacb4125de\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nexus\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mAsset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_fAssetRedemptionPriceGetter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"bAssets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newIntegrator\",\"type\":\"address\"}],\"name\":\"BassetsMigrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cacheSize\",\"type\":\"uint256\"}],\"name\":\"CacheSizeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redemptionFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"govFee\",\"type\":\"uint256\"}],\"name\":\"FeesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inputQuantity\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"inputs\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"inputQuantities\",\"type\":\"uint256[]\"}],\"name\":\"MintedMulti\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mAssetQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"output\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scaledFee\",\"type\":\"uint256\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mAssetQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"outputs\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"outputQuantity\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scaledFee\",\"type\":\"uint256\"}],\"name\":\"RedeemedMulti\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rampEndTime\",\"type\":\"uint256\"}],\"name\":\"StartRampA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"StopRampA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"input\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"output\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"name\":\"WeightLimitsChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectPendingFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectPlatformInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"data\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redemptionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"govFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingFees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cacheSize\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"initialA\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"targetA\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"rampStartTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"rampEndTime\",\"type\":\"uint64\"}],\"internalType\":\"struct AmpData\",\"name\":\"ampData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct WeightLimits\",\"name\":\"weightLimits\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fAssetRedemptionPriceGetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bAsset\",\"type\":\"address\"}],\"name\":\"getBasset\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasTxFee\",\"type\":\"bool\"},{\"internalType\":\"enum BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct BassetPersonal\",\"name\":\"personal\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct BassetData\",\"name\":\"vaultData\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBassets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasTxFee\",\"type\":\"bool\"},{\"internalType\":\"enum BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct BassetPersonal[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"ratio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"vaultBalance\",\"type\":\"uint128\"}],\"internalType\":\"struct BassetData[]\",\"name\":\"vaultData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct FeederConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_inputs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_inputQuantities\",\"type\":\"uint256[]\"}],\"name\":\"getMintMultiOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputQuantity\",\"type\":\"uint256\"}],\"name\":\"getMintOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"k\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_outputs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_outputQuantities\",\"type\":\"uint256[]\"}],\"name\":\"getRedeemExactBassetsOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fpTokenQuantity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fpTokenQuantity\",\"type\":\"uint256\"}],\"name\":\"getRedeemOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bAssetOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputQuantity\",\"type\":\"uint256\"}],\"name\":\"getSwapOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_nameArg\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbolArg\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasTxFee\",\"type\":\"bool\"},{\"internalType\":\"enum BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct BassetPersonal\",\"name\":\"_mAsset\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"integrator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"hasTxFee\",\"type\":\"bool\"},{\"internalType\":\"enum BassetStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"internalType\":\"struct BassetPersonal\",\"name\":\"_fAsset\",\"type\":\"tuple\"},{\"internalType\":\"address[]\",\"name\":\"_mpAssets\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"max\",\"type\":\"uint128\"}],\"internalType\":\"struct WeightLimits\",\"name\":\"limits\",\"type\":\"tuple\"}],\"internalType\":\"struct BasicConfig\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bAssets\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_newIntegration\",\"type\":\"address\"}],\"name\":\"migrateBassets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOutputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_inputs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_inputQuantities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_minOutputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"mintMulti\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nexus\",\"outputs\":[{\"internalType\":\"contract INexus\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fpTokenQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOutputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"outputQuantity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_outputs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_outputQuantities\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_maxInputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"redeemExactBassets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fpTokenQuantity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_inputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_minOutputQuantities\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"redeemProportionately\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"outputQuantities\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cacheSize\",\"type\":\"uint256\"}],\"name\":\"setCacheSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_redemptionFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_govFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_max\",\"type\":\"uint128\"}],\"name\":\"setWeightLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_targetA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rampEndTime\",\"type\":\"uint256\"}],\"name\":\"startRampA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopRampA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minOutputQuantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NonPeggedFeederPool","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000afce80b19a8ce13dec0739a1aab7a028d6845eb3000000000000000000000000e2f2a5c287993345a840db3b0845fbc70f5935a500000000000000000000000007210b8871073228626ab79c296d9b22238f63ce","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}