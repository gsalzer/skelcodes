{"status":"1","message":"OK","result":[{"SourceCode":"{\"ethBridge.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.7;\\n\\nimport \\\"./multiOwnable.sol\\\";\\nimport \\\"./gfshibToken.sol\\\";\\n\\ncontract ethBridge is Multiownable {\\n    GhostfaceShiba private token;\\n\\n    mapping(address =\\u003e uint256) public tokensSent;\\n    mapping(address =\\u003e uint256) public tokensRecieved;\\n    mapping(address =\\u003e uint256) public tokensRecievedButNotSent;\\n \\n    address public tokenAddress; \\n\\n    constructor (address payable _token) {\\n        tokenAddress = _token;\\n        token = GhostfaceShiba(_token);\\n    }\\n \\n    bool transferStatus;\\n    \\n    bool avoidReentrancy = false;\\n \\n    function sendTokens(uint256 amount) public {\\n        require(msg.sender != address(0), \\\"Zero account\\\");\\n        require(amount \\u003e 0,\\\"Amount of tokens should be more then 0\\\");\\n        require(token.balanceOf(msg.sender) \\u003e= amount,\\\"Not enough balance\\\");\\n        \\n        transferStatus = token.transferFrom(msg.sender, address(this), amount);\\n        if (transferStatus == true) {\\n            tokensRecieved[msg.sender] += amount;\\n        }\\n    }\\n \\n    function writeTransaction(address user, uint256 amount) public onlyAllOwners {\\n        require(user != address(0), \\\"Zero account\\\");\\n        require(amount \\u003e 0,\\\"Amount of tokens should be more then 0\\\");\\n        require(!avoidReentrancy);\\n        \\n        avoidReentrancy = true;\\n        tokensRecievedButNotSent[user] += amount;\\n        avoidReentrancy = false;\\n    }\\n\\n    function recieveTokens(uint256[] memory commissions) public payable {\\n        if (tokensRecievedButNotSent[msg.sender] != 0) {\\n            require(commissions.length == owners.length, \\\"The number of commissions and owners does not match\\\");\\n            uint256 sum;\\n            for(uint i = 0; i \\u003c commissions.length; i++) {\\n                sum += commissions[i];\\n            }\\n            require(msg.value \\u003e= sum, \\\"Not enough ETH (The amount of ETH is less than the amount of commissions.)\\\");\\n            require(msg.value \\u003e= owners.length * 150000 * 10**9, \\\"Not enough ETH (The amount of ETH is less than the internal commission.)\\\");\\n        \\n            for (uint i = 0; i \\u003c owners.length; i++) {\\n                address payable owner = payable(owners[i]);\\n                uint256 commission = commissions[i];\\n                owner.transfer(commission);\\n            }\\n\\n            uint256 amountToSent;\\n\\n            amountToSent = tokensRecievedButNotSent[msg.sender] - tokensSent[msg.sender];\\n            transferStatus = token.transfer(msg.sender, amountToSent);\\n            if (transferStatus == true) {\\n                tokensSent[msg.sender] += amountToSent;\\n            }\\n        }\\n    }\\n \\n    function withdrawTokens(uint256 amount, address reciever) public onlyAllOwners {\\n        require(amount \\u003e 0,\\\"Amount of tokens should be more then 0\\\");\\n        require(reciever != address(0), \\\"Zero account\\\");\\n        require(token.balanceOf(address(this)) \\u003e= amount,\\\"Not enough balance\\\");\\n        \\n        token.transfer(reciever, amount);\\n    }\\n    \\n    function withdrawEther(uint256 amount, address payable reciever) public onlyAllOwners {\\n        require(amount \\u003e 0,\\\"Amount of tokens should be more then 0\\\");\\n        require(reciever != address(0), \\\"Zero account\\\");\\n        require(address(this).balance \\u003e= amount,\\\"Not enough balance\\\");\\n\\n        reciever.transfer(amount);\\n    }\\n}\"},\"gfshibToken.sol\":{\"content\":\"/**\\n *Submitted for verification at Etherscan.io on 2021-10-08\\n*/\\n\\n/*\\nGhostface Shiba $GFSHIB\\nTelegram: https://t.me/ghostfaceshiba\\nWebsite: https://ghostfaceshiba.com/\\nTwitter: https://twitter.com/GhostFaceShiba\\n\\n                              ┌▄▄              ,▄▄\\n                              ╟███▓▄╓∞═^*══w▄█▓██▓\\n                              ╟▓▓▀⌠╓▄▄█████▄╗¿▀▓▓▓\\n                             ╒█╜╓▓████████████▓╗\\\"▀▄\\n                            ▄▌ ╬▓███╜ ╙██▌\\\"\\\"▓██▓▓,╙█,\\n                           ▀▀ ╬▓▓▓▓\\\"   ▓█    ▓▓▓▓╣ ▐▓▄\\n                          ██▌ ╢▒█▀     ██µ    ╙██▒[ ▄▄▄\\n                         ▓▓▓▌ ╢▀█▄▄▄▄██▄▄██▄▄▄▄██▒`▐▓▓▓\\n                  ▄████▄  ███▄ ║▒╢▓▓▓▓▓▀╙▀▓▓▓▓╣╣╣\\\"╓███▀\\n                  ▀██▀██   ▀███▄ ╜╢╢╢▓▓▄ ▓▓╢╣▒╝╙,▄███└\\n               ,  \\\"██▓▓▓▄    ▀███▄▄,`╙╙╜╜╜╙\\\",▄▄███▀▀\\n             ▄██▄  ▓▓▓▓▓▓▄▄▄▄█▄▄▀▀████████████▀▀╓▄█▓▓▓▓█▄\\n           ▄███▀    ▓▓▓▓▓▓▓▓▓▓▓▓▓██████████████▓▓▓▓▓▓▓▓▓▓█\\n         ▄██▀└       \\\"▓▓▓▓▓▓▀╓▓▓████████████████▓▓▄▀▀▓▓▓▓▓▓\\n       ▄█▀▀              ╙╙\\\",▓▓██████████████████▓▓   ▓▓▓▓▓█\\n      └                     █▓▓██████████████████▌▓█  ▐█████\\n                            ▓▓▓██████████████████▌▓▓   █████\\n                           ▐▓▓▓██████████████████╣▓▓\\n                           ▐▓▓▓▓▓███████████████╣▓▓▓          █,\\n                           ]▓▓▓▓▓▓▓▓▓███████▓╣▓▓▓▓▓▌╒,     ,▄▓▓▓\\n                            ▓▓▓▓▓▓▓▀▓▓▓▓▓▓▓▓▀▓▓▓▓▓▓ ▓▓▓███▓▓▓▓▓▓\\u0027\\n                            ╘▓▓▓▓▓▓▓▓r,  ╒▄▓█▓▓▓▓▓▌ ▀▓▓▓▓▓▓▓▓▓▓\\\"\\n                              ▀▓▓▓▓▓\\\\▄█  j▓▓▓▓▓▓▓▓     \\\"╙▀▀╙\\u0027\\n                                  ═▀▀▀    ██████▀\\n                                           \\u0027└└¬\\n \\n*/\\n// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity ^0.8.7;\\n\\nlibrary Address {\\n    /**\\n     * C U ON THE MOON\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\n    }\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        return _functionCallWithValue(target, data, value, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            if (returndata.length \\u003e 0) {\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\nabstract contract Context {\\n    function _msgSender() internal view returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this;\\n        return msg.data;\\n    }\\n}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IDEXFactory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n}\\n\\ninterface IDEXRouter {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\ncontract GhostfaceShiba is IERC20, Ownable {\\n    using Address for address;\\n    \\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\\n    address ZERO = 0x0000000000000000000000000000000000000000;\\n\\n    string constant _name = \\\"Ghostface Shiba\\\";\\n    string constant _symbol = \\\"GFSHIB\\\";\\n    uint8 constant _decimals = 9;\\n\\n    uint256 _totalSupply = 1_000_000_000 * (10 ** _decimals);\\n    uint256 _maxBuyTxAmount = (_totalSupply * 1) / 2000;\\n    uint256 _maxSellTxAmount = (_totalSupply * 1) / 500;\\n    uint256 _maxWalletSize = (_totalSupply * 2) / 100;\\n\\n    mapping (address =\\u003e uint256) _balances;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) _allowances;\\n    mapping (address =\\u003e uint256) public lastSell;\\n    mapping (address =\\u003e uint256) public lastBuy;\\n\\n    mapping (address =\\u003e bool) isFeeExempt;\\n    mapping (address =\\u003e bool) isTxLimitExempt;\\n    mapping (address =\\u003e bool) liquidityCreator;\\n\\n    uint256 marketingFee = 800;\\n    uint256 liquidityFee = 200;\\n    uint256 totalFee = marketingFee + liquidityFee;\\n    uint256 sellBias = 0;\\n    uint256 feeDenominator = 10000;\\n\\n    address payable public liquidityFeeReceiver = payable(0x03A7C3c57B1366DdE691F0F2c8c4F113Bc0eEAE3);\\n    address payable public marketingFeeReceiver = payable(0x03A7C3c57B1366DdE691F0F2c8c4F113Bc0eEAE3);\\n\\n    IDEXRouter public router;\\n    address routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\\n    mapping (address =\\u003e bool) liquidityPools;\\n    mapping (address =\\u003e uint256) public protected;\\n    bool protectionEnabled = true;\\n    bool protectionDisabled = false;\\n    uint256 protectionLimit;\\n    uint256 public protectionCount;\\n    uint256 protectionTimer;\\n\\n    address public pair;\\n\\n    uint256 public launchedAt;\\n    uint256 public launchedTime;\\n    uint256 public deadBlocks;\\n    bool startBullRun = false;\\n    bool pauseDisabled = false;\\n    uint256 public rateLimit = 2;\\n\\n    bool public swapEnabled = false;\\n    bool processEnabled = true;\\n    uint256 public swapThreshold = _totalSupply / 1000;\\n    uint256 public swapMinimum = _totalSupply / 10000;\\n    bool inSwap;\\n    modifier swapping() { inSwap = true; _; inSwap = false; }\\n    \\n    mapping (address =\\u003e bool) teamMember;\\n    \\n    modifier onlyTeam() {\\n        require(teamMember[_msgSender()] || msg.sender == owner(), \\\"Caller is not a team member\\\");\\n        _;\\n    }\\n    \\n    event ProtectedWallet(address, address, uint256, uint8);\\n\\n    constructor () {\\n        router = IDEXRouter(routerAddress);\\n        pair = IDEXFactory(router.factory()).createPair(router.WETH(), address(this));\\n        liquidityPools[pair] = true;\\n        _allowances[owner()][routerAddress] = type(uint256).max;\\n        _allowances[address(this)][routerAddress] = type(uint256).max;\\n\\n        isFeeExempt[owner()] = true;\\n        liquidityCreator[owner()] = true;\\n\\n        isTxLimitExempt[address(this)] = true;\\n        isTxLimitExempt[owner()] = true;\\n        isTxLimitExempt[routerAddress] = true;\\n        isTxLimitExempt[DEAD] = true;\\n\\n        _balances[owner()] = _totalSupply;\\n\\n        emit Transfer(address(0), owner(), _totalSupply);\\n    }\\n\\n    receive() external payable { }\\n\\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\\n    function decimals() external pure returns (uint8) { return _decimals; }\\n    function symbol() external pure returns (string memory) { return _symbol; }\\n    function name() external pure returns (string memory) { return _name; }\\n    function getOwner() external view returns (address) { return owner(); }\\n    function maxBuyTxTokens() external view returns (uint256) { return _maxBuyTxAmount / (10 ** _decimals); }\\n    function maxSellTxTokens() external view returns (uint256) { return _maxSellTxAmount / (10 ** _decimals); }\\n    function maxWalletTokens() external view returns (uint256) { return _maxWalletSize / (10 ** _decimals); }\\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\\n\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _allowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function approveMax(address spender) external returns (bool) {\\n        return approve(spender, type(uint256).max);\\n    }\\n    \\n    function setTeamMember(address _team, bool _enabled) external onlyOwner {\\n        teamMember[_team] = _enabled;\\n    }\\n    \\n    function airdrop(address[] calldata addresses, uint256[] calldata amounts) external onlyOwner {\\n        require(addresses.length \\u003e 0 \\u0026\\u0026 amounts.length == addresses.length);\\n        address from = msg.sender;\\n\\n        for (uint i = 0; i \\u003c addresses.length; i++) {\\n            if(!liquidityPools[addresses[i]] \\u0026\\u0026 !liquidityCreator[addresses[i]]) {\\n                _basicTransfer(from, addresses[i], amounts[i] * (10 ** _decimals));\\n            }\\n        }\\n    }\\n    \\n    function clearStuckBalance(uint256 amountPercentage, address adr) external onlyTeam {\\n        uint256 amountETH = address(this).balance;\\n        payable(adr).transfer((amountETH * amountPercentage) / 100);\\n    }\\n    \\n    function openTrading(uint256 _deadBlocks, uint256 _protection, uint256 _limit) external onlyTeam {\\n        require(!startBullRun \\u0026\\u0026 _deadBlocks \\u003c 10);\\n        deadBlocks = _deadBlocks;\\n        startBullRun = true;\\n        launchedAt = block.number;\\n        protectionTimer = block.timestamp + _protection;\\n        protectionLimit = _limit * (10 ** _decimals);\\n    }\\n    \\n    function pauseTrading() external onlyTeam {\\n        require(!pauseDisabled);\\n        startBullRun = false;\\n    }\\n    \\n    function disablePause() external onlyTeam {\\n        pauseDisabled = true;\\n        startBullRun = true;\\n    }\\n    \\n    function setProtection(bool _protect, uint256 _addTime) external onlyTeam {\\n        require(!protectionDisabled);\\n        protectionEnabled = _protect;\\n        require(_addTime \\u003c 1 days);\\n        protectionTimer += _addTime;\\n    }\\n    \\n    function disableProtection() external onlyTeam {\\n        protectionDisabled = true;\\n        protectionEnabled = false;\\n    }\\n    \\n    function protectWallet(address[] calldata _wallets, bool _protect) external onlyTeam {\\n        if (_protect) {\\n            require(protectionEnabled);\\n        }\\n        \\n        for (uint i = 0; i \\u003c _wallets.length; i++) {\\n            \\n            if (_protect) {\\n                protectionCount++;\\n                emit ProtectedWallet(tx.origin, _wallets[i], block.number, 2);\\n            }\\n            else {\\n                if (protected[_wallets[i]] != 0)\\n                    protectionCount--;      \\n            }\\n            protected[_wallets[i]] = _protect ? block.number : 0;\\n        }\\n    }\\n\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\n        return _transferFrom(msg.sender, recipient, amount);\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\n        if(_allowances[sender][msg.sender] != type(uint256).max){\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\\n        }\\n\\n        return _transferFrom(sender, recipient, amount);\\n    }\\n\\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\\n        require(sender != address(0), \\\"BEP20: transfer from 0x0\\\");\\n        require(recipient != address(0), \\\"BEP20: transfer to 0x0\\\");\\n        require(amount \\u003e 0, \\\"Amount must be \\u003e zero\\\");\\n        require(_balances[sender] \\u003e= amount, \\\"Insufficient balance\\\");\\n        if(!launched() \\u0026\\u0026 liquidityPools[recipient]){ require(liquidityCreator[sender], \\\"Liquidity not added yet.\\\"); launch(); }\\n        if(!startBullRun){ require(liquidityCreator[sender] || liquidityCreator[recipient], \\\"Trading not open yet.\\\"); }\\n\\n        checkTxLimit(sender, recipient, amount);\\n        \\n        if (!liquidityPools[recipient] \\u0026\\u0026 recipient != DEAD) {\\n            if (!isTxLimitExempt[recipient]) {\\n                checkWalletLimit(recipient, amount);\\n            }\\n        }\\n        \\n        if(protectionEnabled \\u0026\\u0026 protectionTimer \\u003e block.timestamp) {\\n            if(liquidityPools[sender] \\u0026\\u0026 tx.origin != recipient \\u0026\\u0026 protected[recipient] == 0) {\\n                protected[recipient] = block.number;\\n                protectionCount++;\\n                emit ProtectedWallet(tx.origin, recipient, block.number, 0);\\n            }\\n        }\\n        \\n        if(inSwap){ return _basicTransfer(sender, recipient, amount); }\\n\\n        _balances[sender] = _balances[sender] - amount;\\n\\n        uint256 amountReceived = shouldTakeFee(sender) ? takeFee(recipient, amount) : amount;\\n        \\n        if(shouldSwapBack(recipient)){ if (amount \\u003e 0) swapBack(amount); }\\n        \\n        _balances[recipient] = _balances[recipient] + amountReceived;\\n\\n        emit Transfer(sender, recipient, amountReceived);\\n        return true;\\n    }\\n    \\n    function launched() internal view returns (bool) {\\n        return launchedAt != 0;\\n    }\\n\\n    function launch() internal {\\n        launchedAt = block.number;\\n        launchedTime = block.timestamp;\\n        swapEnabled = true;\\n    }\\n\\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\\n        _balances[sender] = _balances[sender] - amount;\\n        _balances[recipient] = _balances[recipient] + amount;\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n    \\n    function checkWalletLimit(address recipient, uint256 amount) internal view {\\n        uint256 walletLimit = _maxWalletSize;\\n        require(_balances[recipient] + amount \\u003c= walletLimit, \\\"Transfer amount exceeds the bag size.\\\");\\n    }\\n\\n    function checkTxLimit(address sender, address recipient, uint256 amount) internal {\\n        require(isTxLimitExempt[sender] || amount \\u003c= (liquidityPools[sender] ? _maxBuyTxAmount : _maxSellTxAmount), \\\"TX Limit Exceeded\\\");\\n        require(isTxLimitExempt[sender] || lastBuy[recipient] + rateLimit \\u003c= block.number, \\\"Transfer rate limit exceeded.\\\");\\n        \\n        if (protected[sender] != 0){\\n            require(amount \\u003c= protectionLimit * (10 ** _decimals) \\u0026\\u0026 lastSell[sender] == 0 \\u0026\\u0026 protectionTimer \\u003e block.timestamp, \\\"Wallet protected, please contact support.\\\");\\n            lastSell[sender] = block.number;\\n        }\\n        \\n        if (liquidityPools[recipient]) {\\n            lastSell[sender] = block.number;\\n        } else if (shouldTakeFee(sender)) {\\n            if (protectionEnabled \\u0026\\u0026 protectionTimer \\u003e block.timestamp \\u0026\\u0026 lastBuy[tx.origin] == block.number \\u0026\\u0026 protected[recipient] == 0) {\\n                protected[recipient] = block.number;\\n                emit ProtectedWallet(tx.origin, recipient, block.number, 1);\\n            }\\n            lastBuy[recipient] = block.number;\\n            if (tx.origin != recipient)\\n                lastBuy[tx.origin] = block.number;\\n        }\\n    }\\n\\n    function shouldTakeFee(address sender) internal view returns (bool) {\\n        return !isFeeExempt[sender];\\n    }\\n\\n    function getTotalFee(bool selling) public view returns (uint256) {\\n        if(launchedAt + deadBlocks \\u003e= block.number){ return feeDenominator - 1; }\\n        if (selling) return totalFee + sellBias;\\n        return totalFee - sellBias;\\n    }\\n\\n    function takeFee(address recipient, uint256 amount) internal returns (uint256) {\\n        bool selling = liquidityPools[recipient];\\n        uint256 feeAmount = (amount * getTotalFee(selling)) / feeDenominator;\\n        \\n        _balances[address(this)] += feeAmount;\\n    \\n        return amount - feeAmount;\\n    }\\n\\n    function shouldSwapBack(address recipient) internal view returns (bool) {\\n        return !liquidityPools[msg.sender]\\n        \\u0026\\u0026 !inSwap\\n        \\u0026\\u0026 swapEnabled\\n        \\u0026\\u0026 liquidityPools[recipient]\\n        \\u0026\\u0026 _balances[address(this)] \\u003e= swapMinimum;\\n    }\\n\\n    function swapBack(uint256 amount) internal swapping {\\n        uint256 amountToSwap = amount \\u003c swapThreshold ? amount : swapThreshold;\\n        if (_balances[address(this)] \\u003c amountToSwap) amountToSwap = _balances[address(this)];\\n        \\n        uint256 amountToLiquify = (amountToSwap * liquidityFee / 2) / totalFee;\\n        amountToSwap -= amountToLiquify;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = router.WETH();\\n        \\n        uint256 balanceBefore = address(this).balance;\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            amountToSwap,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        uint256 amountBNB = address(this).balance - balanceBefore;\\n        uint256 totalBNBFee = totalFee - (liquidityFee / 2);\\n\\n        uint256 amountBNBLiquidity = (amountBNB * liquidityFee / 2) / totalBNBFee;\\n        uint256 amountBNBMarketing = amountBNB - amountBNBLiquidity;\\n        \\n        if (amountBNBMarketing \\u003e 0)\\n            marketingFeeReceiver.transfer(amountBNBMarketing);\\n        \\n        if(amountToLiquify \\u003e 0){\\n            router.addLiquidityETH{value: amountBNBLiquidity}(\\n                address(this),\\n                amountToLiquify,\\n                0,\\n                0,\\n                liquidityFeeReceiver,\\n                block.timestamp\\n            );\\n        }\\n\\n        emit FundsDistributed(amountBNBMarketing, amountBNBLiquidity, amountToLiquify);\\n    }\\n    \\n    function addLiquidityPool(address lp, bool isPool) external onlyOwner {\\n        require(lp != pair, \\\"Can\\u0027t alter current liquidity pair\\\");\\n        liquidityPools[lp] = isPool;\\n    }\\n\\n    function setRateLimit(uint256 rate) external onlyOwner {\\n        require(rate \\u003c= 60 seconds);\\n        rateLimit = rate;\\n    }\\n\\n    function setTxLimit(uint256 buyNumerator, uint256 sellNumerator, uint256 divisor) external onlyOwner {\\n        require(buyNumerator \\u003e 0 \\u0026\\u0026 sellNumerator \\u003e 0 \\u0026\\u0026 divisor \\u003e 0 \\u0026\\u0026 divisor \\u003c= 10000);\\n        _maxBuyTxAmount = (_totalSupply * buyNumerator) / divisor;\\n        _maxSellTxAmount = (_totalSupply * sellNumerator) / divisor;\\n    }\\n    \\n    function setMaxWallet(uint256 numerator, uint256 divisor) external onlyOwner() {\\n        require(numerator \\u003e 0 \\u0026\\u0026 divisor \\u003e 0 \\u0026\\u0026 divisor \\u003c= 10000);\\n        _maxWalletSize = (_totalSupply * numerator) / divisor;\\n    }\\n\\n    function setIsFeeExempt(address holder, bool exempt) external onlyOwner {\\n        isFeeExempt[holder] = exempt;\\n    }\\n\\n    function setIsTxLimitExempt(address holder, bool exempt) external onlyOwner {\\n        isTxLimitExempt[holder] = exempt;\\n    }\\n\\n    function setFees(uint256 _liquidityFee, uint256 _marketingFee, uint256 _sellBias, uint256 _feeDenominator) external onlyOwner {\\n        liquidityFee = _liquidityFee;\\n        marketingFee = _marketingFee;\\n        totalFee = _marketingFee + _liquidityFee;\\n        sellBias = _sellBias;\\n        feeDenominator = _feeDenominator;\\n        require(totalFee \\u003c feeDenominator / 2);\\n    }\\n\\n    function setFeeReceivers(address _liquidityFeeReceiver, address _marketingFeeReceiver) external onlyOwner {\\n        liquidityFeeReceiver = payable(_liquidityFeeReceiver);\\n        marketingFeeReceiver = payable(_marketingFeeReceiver);\\n    }\\n\\n    function setSwapBackSettings(bool _enabled, bool _processEnabled, uint256 _denominator, uint256 _swapMinimum) external onlyOwner {\\n        require(_denominator \\u003e 0);\\n        swapEnabled = _enabled;\\n        processEnabled = _processEnabled;\\n        swapThreshold = _totalSupply / _denominator;\\n        swapMinimum = _swapMinimum * (10 ** _decimals);\\n    }\\n\\n    function getCirculatingSupply() public view returns (uint256) {\\n        return _totalSupply - (balanceOf(DEAD) + balanceOf(ZERO));\\n    }\\n\\n    event FundsDistributed(uint256 marketingBNB, uint256 liquidityBNB, uint256 liquidityTokens);\\n    //C U ON THE MOON\\n}\"},\"multiOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ncontract Multiownable {\\n\\n    // VARIABLES\\n\\n    uint256 public ownersGeneration;\\n    uint256 public howManyOwnersDecide;\\n    address[] public owners;\\n    bytes32[] public allOperations;\\n    address internal insideCallSender;\\n    uint256 internal insideCallCount;\\n\\n    // Reverse lookup tables for owners and allOperations\\n    mapping(address =\\u003e uint) public ownersIndices; // Starts from 1\\n    mapping(bytes32 =\\u003e uint) public allOperationsIndicies;\\n\\n    // Owners voting mask per operations\\n    mapping(bytes32 =\\u003e uint256) public votesMaskByOperation;\\n    mapping(bytes32 =\\u003e uint256) public votesCountByOperation;\\n\\n    // EVENTS\\n\\n    event OwnershipTransferred(address[] previousOwners, uint howManyOwnersDecide, address[] newOwners, uint newHowManyOwnersDecide);\\n    event OperationCreated(bytes32 operation, uint howMany, uint ownersCount, address proposer);\\n    event OperationUpvoted(bytes32 operation, uint votes, uint howMany, uint ownersCount, address upvoter);\\n    event OperationPerformed(bytes32 operation, uint howMany, uint ownersCount, address performer);\\n    event OperationDownvoted(bytes32 operation, uint votes, uint ownersCount,  address downvoter);\\n    event OperationCancelled(bytes32 operation, address lastCanceller);\\n    \\n    // ACCESSORS\\n\\n    function isOwner(address wallet) public view returns(bool) {\\n        return ownersIndices[wallet] \\u003e 0;\\n    }\\n\\n    function ownersCount() public view returns(uint) {\\n        return owners.length;\\n    }\\n\\n    function allOperationsCount() public view returns(uint) {\\n        return allOperations.length;\\n    }\\n\\n    // MODIFIERS\\n\\n    /**\\n    * @dev Allows to perform method by any of the owners\\n    */\\n    modifier onlyAnyOwner {\\n        if (checkHowManyOwners(1)) {\\n            bool update = (insideCallSender == address(0));\\n            if (update) {\\n                insideCallSender = msg.sender;\\n                insideCallCount = 1;\\n            }\\n            _;\\n            if (update) {\\n                insideCallSender = address(0);\\n                insideCallCount = 0;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @dev Allows to perform method only after many owners call it with the same arguments\\n    */\\n    modifier onlyManyOwners {\\n        if (checkHowManyOwners(howManyOwnersDecide)) {\\n            bool update = (insideCallSender == address(0));\\n            if (update) {\\n                insideCallSender = msg.sender;\\n                insideCallCount = howManyOwnersDecide;\\n            }\\n            _;\\n            if (update) {\\n                insideCallSender = address(0);\\n                insideCallCount = 0;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @dev Allows to perform method only after all owners call it with the same arguments\\n    */\\n    modifier onlyAllOwners {\\n        if (checkHowManyOwners(owners.length)) {\\n            bool update = (insideCallSender == address(0));\\n            if (update) {\\n                insideCallSender = msg.sender;\\n                insideCallCount = owners.length;\\n            }\\n            _;\\n            if (update) {\\n                insideCallSender = address(0);\\n                insideCallCount = 0;\\n            }\\n        }\\n    }\\n\\n    /**\\n    * @dev Allows to perform method only after some owners call it with the same arguments\\n    */\\n    modifier onlySomeOwners(uint howMany) {\\n        require(howMany \\u003e 0, \\\"onlySomeOwners: howMany argument is zero\\\");\\n        require(howMany \\u003c= owners.length, \\\"onlySomeOwners: howMany argument exceeds the number of owners\\\");\\n        \\n        if (checkHowManyOwners(howMany)) {\\n            bool update = (insideCallSender == address(0));\\n            if (update) {\\n                insideCallSender = msg.sender;\\n                insideCallCount = howMany;\\n            }\\n            _;\\n            if (update) {\\n                insideCallSender = address(0);\\n                insideCallCount = 0;\\n            }\\n        }\\n    }\\n\\n    // CONSTRUCTOR\\n\\n    constructor() {\\n        owners.push(msg.sender);\\n        ownersIndices[msg.sender] = 1;\\n        howManyOwnersDecide = 1;\\n    }\\n\\n    // INTERNAL METHODS\\n\\n    /**\\n     * @dev onlyManyOwners modifier helper\\n     */\\n    function checkHowManyOwners(uint howMany) internal returns(bool) {\\n        if (insideCallSender == msg.sender) {\\n            require(howMany \\u003c= insideCallCount, \\\"checkHowManyOwners: nested owners modifier check require more owners\\\");\\n            return true;\\n        }\\n\\n        uint ownerIndex = ownersIndices[msg.sender] - 1;\\n        require(ownerIndex \\u003c owners.length, \\\"checkHowManyOwners: msg.sender is not an owner\\\");\\n        bytes32 operation = keccak256(abi.encodePacked(msg.data, ownersGeneration));\\n\\n        require((votesMaskByOperation[operation] \\u0026 (2 ** ownerIndex)) == 0, \\\"checkHowManyOwners: owner already voted for the operation\\\");\\n        votesMaskByOperation[operation] |= (2 ** ownerIndex);\\n        uint operationVotesCount = votesCountByOperation[operation] + 1;\\n        votesCountByOperation[operation] = operationVotesCount;\\n        if (operationVotesCount == 1) {\\n            allOperationsIndicies[operation] = allOperations.length;\\n            allOperations.push(operation);\\n            emit OperationCreated(operation, howMany, owners.length, msg.sender);\\n        }\\n        emit OperationUpvoted(operation, operationVotesCount, howMany, owners.length, msg.sender);\\n\\n        // If enough owners confirmed the same operation\\n        if (votesCountByOperation[operation] == howMany) {\\n            deleteOperation(operation);\\n            emit OperationPerformed(operation, howMany, owners.length, msg.sender);\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n    * @dev Used to delete cancelled or performed operation\\n    * @param operation defines which operation to delete\\n    */\\n    function deleteOperation(bytes32 operation) internal {\\n        uint index = allOperationsIndicies[operation];\\n        if (index \\u003c allOperations.length - 1) { // Not last\\n            allOperations[index] = allOperations[allOperations.length - 1];\\n            allOperationsIndicies[allOperations[index]] = index;\\n        }\\n        //allOperations.length-1\\n        allOperations.push(allOperations[allOperations.length-1]);\\n\\n        delete votesMaskByOperation[operation];\\n        delete votesCountByOperation[operation];\\n        delete allOperationsIndicies[operation];\\n    }\\n\\n    // PUBLIC METHODS\\n\\n    /**\\n    * @dev Allows owners to change their mind by cacnelling votesMaskByOperation operations\\n    * @param operation defines which operation to delete\\n    */\\n    function cancelPending(bytes32 operation) public onlyAnyOwner {\\n        uint ownerIndex = ownersIndices[msg.sender] - 1;\\n        require((votesMaskByOperation[operation] \\u0026 (2 ** ownerIndex)) != 0, \\\"cancelPending: operation not found for this user\\\");\\n        votesMaskByOperation[operation] \\u0026= ~(2 ** ownerIndex);\\n        uint operationVotesCount = votesCountByOperation[operation] - 1;\\n        votesCountByOperation[operation] = operationVotesCount;\\n        emit OperationDownvoted(operation, operationVotesCount, owners.length, msg.sender);\\n        if (operationVotesCount == 0) {\\n            deleteOperation(operation);\\n            emit OperationCancelled(operation, msg.sender);\\n        }\\n    }\\n\\n    /**\\n    * @dev Allows owners to change ownership\\n    * @param newOwners defines array of addresses of new owners\\n    */\\n    function transferOwnership(address[] memory newOwners) public {\\n        transferOwnershipWithHowMany(newOwners, newOwners.length);\\n    }\\n\\n    /**\\n    * @dev Allows owners to change ownership\\n    * @param newOwners defines array of addresses of new owners\\n    * @param newHowManyOwnersDecide defines how many owners can decide\\n    */\\n    function transferOwnershipWithHowMany(address[] memory newOwners, uint256 newHowManyOwnersDecide) public onlyManyOwners {\\n        require(newOwners.length \\u003e 0, \\\"transferOwnershipWithHowMany: owners array is empty\\\");\\n        require(newOwners.length \\u003c= 256, \\\"transferOwnershipWithHowMany: owners count is greater then 256\\\");\\n        require(newHowManyOwnersDecide \\u003e 0, \\\"transferOwnershipWithHowMany: newHowManyOwnersDecide equal to 0\\\");\\n        require(newHowManyOwnersDecide \\u003c= newOwners.length, \\\"transferOwnershipWithHowMany: newHowManyOwnersDecide exceeds the number of owners\\\");\\n\\n        // Reset owners reverse lookup table\\n        for (uint j = 0; j \\u003c owners.length; j++) {\\n            delete ownersIndices[owners[j]];\\n        }\\n        for (uint i = 0; i \\u003c newOwners.length; i++) {\\n            require(newOwners[i] != address(0), \\\"transferOwnershipWithHowMany: owners array contains zero\\\");\\n            require(ownersIndices[newOwners[i]] == 0, \\\"transferOwnershipWithHowMany: owners array contains duplicates\\\");\\n            ownersIndices[newOwners[i]] = i + 1;\\n        }\\n        \\n        emit OwnershipTransferred(owners, howManyOwnersDecide, newOwners, newHowManyOwnersDecide);\\n        owners = newOwners;\\n        howManyOwnersDecide = newHowManyOwnersDecide;\\n        // allOperations.length = 0;\\n        allOperations.push(allOperations[0]);\\n        ownersGeneration++;\\n    }\\n\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lastCanceller\",\"type\":\"address\"}],\"name\":\"OperationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"howMany\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownersCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"}],\"name\":\"OperationCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownersCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"downvoter\",\"type\":\"address\"}],\"name\":\"OperationDownvoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"howMany\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownersCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"performer\",\"type\":\"address\"}],\"name\":\"OperationPerformed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"howMany\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ownersCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"upvoter\",\"type\":\"address\"}],\"name\":\"OperationUpvoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"previousOwners\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"howManyOwnersDecide\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"newOwners\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newHowManyOwnersDecide\",\"type\":\"uint256\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allOperations\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allOperationsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"allOperationsIndicies\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"cancelPending\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"howManyOwnersDecide\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownersGeneration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownersIndices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"commissions\",\"type\":\"uint256[]\"}],\"name\":\"recieveTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensRecieved\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensRecievedButNotSent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensSent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"newOwners\",\"type\":\"address[]\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"newOwners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"newHowManyOwnersDecide\",\"type\":\"uint256\"}],\"name\":\"transferOwnershipWithHowMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"votesCountByOperation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"votesMaskByOperation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"reciever\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"reciever\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"writeTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ethBridge","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ca96dcc988ec155a30eb78f45fccb968e2ebf5fd","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://10b9801f06875360a7da28da3995483a6f7a9469cd3689232b0a3b5f18a78a5c"}]}