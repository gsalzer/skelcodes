{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"DanielArshamErosions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*\\r\\n\\r\\n    ██████╗  █████╗ ███╗   ██╗██╗███████╗██╗\\r\\n    ██╔══██╗██╔══██╗████╗  ██║██║██╔════╝██║\\r\\n    ██║  ██║███████║██╔██╗ ██║██║█████╗  ██║\\r\\n    ██║  ██║██╔══██║██║╚██╗██║██║██╔══╝  ██║\\r\\n    ██████╔╝██║  ██║██║ ╚████║██║███████╗███████╗\\r\\n    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝╚══════╝╚══════╝\\r\\n\\r\\n  █████╗ ██████╗ ███████╗██╗  ██╗ █████╗ ███╗   ███╗\\r\\n ██╔══██╗██╔══██╗██╔════╝██║  ██║██╔══██╗████╗ ████║\\r\\n ███████║██████╔╝███████╗███████║███████║██╔████╔██║\\r\\n ██╔══██║██╔══██╗╚════██║██╔══██║██╔══██║██║╚██╔╝██║\\r\\n ██║  ██║██║  ██║███████║██║  ██║██║  ██║██║ ╚═╝ ██║\\r\\n ╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝     ╚═╝\\r\\n\\r\\n                       ______\\r\\n                      /     /\\\\\\r\\n                     /     /##\\\\\\r\\n                    /     /####\\\\\\r\\n                   /     /######\\\\\\r\\n                  /     /########\\\\\\r\\n                 /     /##########\\\\\\r\\n                /     /#####/\\\\#####\\\\\\r\\n               /     /#####/++\\\\#####\\\\\\r\\n              /     /#####/++++\\\\#####\\\\\\r\\n             /     /#####/\\\\+++++\\\\#####\\\\\\r\\n            /     /#####/  \\\\+++++\\\\#####\\\\\\r\\n           /     /#####/    \\\\+++++\\\\#####\\\\\\r\\n          /     /#####/      \\\\+++++\\\\#####\\\\\\r\\n         /     /#####/        \\\\+++++\\\\#####\\\\\\r\\n        /     /#####/__________\\\\+++++\\\\#####\\\\\\r\\n       /                        \\\\+++++\\\\#####\\\\\\r\\n      /__________________________\\\\+++++\\\\####/\\r\\n      \\\\+++++++++++++++++++++++++++++++++\\\\##/\\r\\n       \\\\+++++++++++++++++++++++++++++++++\\\\/\\r\\n        ``````````````````````````````````\\r\\n\\r\\n              ██████╗██╗  ██╗██╗██████╗\\r\\n             ██╔════╝╚██╗██╔╝██║██╔══██╗\\r\\n             ██║      ╚███╔╝ ██║██████╔╝\\r\\n             ██║      ██╔██╗ ██║██╔═══╝\\r\\n             ╚██████╗██╔╝ ██╗██║██║\\r\\n              ╚═════╝╚═╝  ╚═╝╚═╝╚═╝\\r\\n\\r\\n*/\\r\\n\\r\\nimport \\\"OpenSea.sol\\\";\\r\\nimport \\\"ICxipERC721.sol\\\";\\r\\nimport \\\"ICxipIdentity.sol\\\";\\r\\nimport \\\"ICxipProvenance.sol\\\";\\r\\nimport \\\"ICxipRegistry.sol\\\";\\r\\nimport \\\"IPA1D.sol\\\";\\r\\nimport \\\"Address.sol\\\";\\r\\nimport \\\"Bytes.sol\\\";\\r\\nimport \\\"RotatingToken.sol\\\";\\r\\nimport \\\"Strings.sol\\\";\\r\\nimport \\\"CollectionData.sol\\\";\\r\\nimport \\\"TokenData.sol\\\";\\r\\nimport \\\"Verification.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title CXIP ERC721\\r\\n * @author CXIP-Labs\\r\\n * @notice A smart contract for minting and managing ERC721 NFTs.\\r\\n * @dev The entire logic and functionality of the smart contract is self-contained.\\r\\n */\\r\\ncontract DanielArshamErosions {\\r\\n    /**\\r\\n     * @dev Stores default collection data: name, symbol, and royalties.\\r\\n     */\\r\\n    CollectionData private _collectionData;\\r\\n\\r\\n    /**\\r\\n     * @dev Internal last minted token id, to allow for auto-increment.\\r\\n     */\\r\\n    uint256 private _currentTokenId;\\r\\n\\r\\n    /**\\r\\n     * @dev Array of all token ids in collection.\\r\\n     */\\r\\n    uint256[] private _allTokens;\\r\\n\\r\\n    /**\\r\\n     * @dev Map of token id to array index of _ownedTokens.\\r\\n     */\\r\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\r\\n\\r\\n    /**\\r\\n     * @dev Token id to wallet (owner) address map.\\r\\n     */\\r\\n    mapping(uint256 => address) private _tokenOwner;\\r\\n\\r\\n    /**\\r\\n     * @dev 1-to-1 map of token id that was assigned an approved operator address.\\r\\n     */\\r\\n    mapping(uint256 => address) private _tokenApprovals;\\r\\n\\r\\n    /**\\r\\n     * @dev Map of total tokens owner by a specific address.\\r\\n     */\\r\\n    mapping(address => uint256) private _ownedTokensCount;\\r\\n\\r\\n    /**\\r\\n     * @dev Map of array of token ids owned by a specific address.\\r\\n     */\\r\\n    mapping(address => uint256[]) private _ownedTokens;\\r\\n\\r\\n    /**\\r\\n     * @notice Map of full operator approval for a particular address.\\r\\n     * @dev Usually utilised for supporting marketplace proxy wallets.\\r\\n     */\\r\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\r\\n\\r\\n    /**\\r\\n     * @dev Token data mapped by token id.\\r\\n     */\\r\\n    mapping(uint256 => TokenData) private _tokenData;\\r\\n\\r\\n    /**\\r\\n     * @dev Address of admin user. Primarily used as an additional recover address.\\r\\n     */\\r\\n    address private _admin;\\r\\n\\r\\n    /**\\r\\n     * @dev Address of contract owner. This address can run all onlyOwner functions.\\r\\n     */\\r\\n    address private _owner;\\r\\n\\r\\n    /**\\r\\n     * @dev Simple tracker of all minted (not-burned) tokens.\\r\\n     */\\r\\n    uint256 private _totalTokens;\\r\\n\\r\\n    /**\\r\\n     * @dev Mapping from token id to position in the allTokens array.\\r\\n     */\\r\\n    mapping(uint256 => uint256) private _allTokensIndex;\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when an token is minted, transfered, or burned.\\r\\n     * @dev If from is empty, it's a mint. If to is empty, it's a burn. Otherwise, it's a transfer.\\r\\n     * @param from Address from where token is being transfered.\\r\\n     * @param to Address to where token is being transfered.\\r\\n     * @param tokenId Token id that is being minted, Transfered, or burned.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when an address delegates power, for a token, to another address.\\r\\n     * @dev Emits event that informs of address approving a third-party operator for a particular token.\\r\\n     * @param wallet Address of the wallet configuring a token operator.\\r\\n     * @param operator Address of the third-party operator approved for interaction.\\r\\n     * @param tokenId A specific token id that is being authorised to operator.\\r\\n     */\\r\\n    event Approval(address indexed wallet, address indexed operator, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when an address authorises an operator (third-party).\\r\\n     * @dev Emits event that informs of address approving/denying a third-party operator.\\r\\n     * @param wallet Address of the wallet configuring it's operator.\\r\\n     * @param operator Address of the third-party operator that interacts on behalf of the wallet.\\r\\n     * @param approved A boolean indicating whether approval was granted or revoked.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed wallet, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted to signal to OpenSea that a permanent URI was created.\\r\\n     * @dev Even though OpenSea advertises support for this, they do not listen to this event, and do not respond to it.\\r\\n     * @param uri The permanent/static URL of the NFT. Cannot ever be changed again.\\r\\n     * @param id Token id of the NFT.\\r\\n     */\\r\\n    event PermanentURI(string uri, uint256 indexed id);\\r\\n\\r\\n    /**\\r\\n     * @notice Constructor is empty and not utilised.\\r\\n     * @dev To make exact CREATE2 deployment possible, constructor is left empty. We utilize the \\\"init\\\" function instead.\\r\\n     */\\r\\n    constructor() {}\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"CXIP: caller not an owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Enables royaltiy functionality at the ERC721 level when ether is sent with no calldata.\\r\\n     * @dev See implementation of _royaltiesFallback.\\r\\n     */\\r\\n    receive() external payable {\\r\\n        _royaltiesFallback();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Enables royaltiy functionality at the ERC721 level no other function matches the call.\\r\\n     * @dev See implementation of _royaltiesFallback.\\r\\n     */\\r\\n    fallback() external {\\r\\n        _royaltiesFallback();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the URI of the NFT on Arweave.\\r\\n     * @dev Concatenates 2 sections of the arweave URI.\\r\\n     * @return string The URI.\\r\\n     */\\r\\n    function arweaveURI(uint256 tokenId) external view returns (string memory) {\\r\\n        require(_exists(tokenId), \\\"CXIP: token does not exist\\\");\\r\\n        uint256 index = RotatingToken.calculateRotation(tokenId, getTokenSeparator());\\r\\n        return string(abi.encodePacked(\\\"https://arweave.net/\\\", _tokenData[index].arweave, _tokenData[index].arweave2));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the URI of the NFT backup from CXIP.\\r\\n     * @dev Concatenates to https://nft.cxip.io/.\\r\\n     * @return string The URI.\\r\\n     */\\r\\n    function contractURI() external view returns (string memory) {\\r\\n        return string(abi.encodePacked(\\\"https://nft.cxip.io/\\\", Strings.toHexString(address(this)), \\\"/\\\"));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the creator's address.\\r\\n     * @dev If the token Id doesn't exist it will return zero address.\\r\\n     * @return address Creator's address.\\r\\n     */\\r\\n    function creator(uint256 tokenId) external view returns (address) {\\r\\n        require(_exists(tokenId), \\\"CXIP: token does not exist\\\");\\r\\n        uint256 index = RotatingToken.calculateRotation(tokenId, getTokenSeparator());\\r\\n        return _tokenData[index].creator;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the HTTP URI of the token.\\r\\n     * @dev Concatenates to the baseURI.\\r\\n     * @return string The URI.\\r\\n     */\\r\\n    function httpURI(uint256 tokenId) external view returns (string memory) {\\r\\n        require(_exists(tokenId), \\\"CXIP: token does not exist\\\");\\r\\n        return string(abi.encodePacked(baseURI(), \\\"/\\\", Strings.toHexString(tokenId)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the IPFS URI\\r\\n     * @dev Concatenates to the IPFS domain.\\r\\n     * @return string The URI.\\r\\n     */\\r\\n    function ipfsURI(uint256 tokenId) external view returns (string memory) {\\r\\n        require(_exists(tokenId), \\\"CXIP: token does not exist\\\");\\r\\n        uint256 index = RotatingToken.calculateRotation(tokenId, getTokenSeparator());\\r\\n        return string(abi.encodePacked(\\\"https://ipfs.io/ipfs/\\\", _tokenData[index].ipfs, _tokenData[index].ipfs2));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the name of the collection.\\r\\n     * @dev Uses two names to extend the max length of the collection name in bytes\\r\\n     * @return string The collection name.\\r\\n     */\\r\\n    function name() external view returns (string memory) {\\r\\n        return string(abi.encodePacked(Bytes.trim(_collectionData.name), Bytes.trim(_collectionData.name2)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the hash of the NFT data used to create it.\\r\\n     * @dev Payload is used for verification.\\r\\n     * @param tokenId The Id of the token.\\r\\n     * @return bytes32 The hash.\\r\\n     */\\r\\n    function payloadHash(uint256 tokenId) external view returns (bytes32) {\\r\\n        require(_exists(tokenId), \\\"CXIP: token does not exist\\\");\\r\\n        uint256 index = RotatingToken.calculateRotation(tokenId, getTokenSeparator());\\r\\n        return _tokenData[index].payloadHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the signature of the signed NFT data used to create it.\\r\\n     * @dev Used for signature verification.\\r\\n     * @param tokenId The Id of the token.\\r\\n     * @return Verification a struct containing v, r, s values of the signature.\\r\\n     */\\r\\n    function payloadSignature(uint256 tokenId) external view returns (Verification memory) {\\r\\n        require(_exists(tokenId), \\\"CXIP: token does not exist\\\");\\r\\n        uint256 index = RotatingToken.calculateRotation(tokenId, getTokenSeparator());\\r\\n        return _tokenData[index].payloadSignature;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the address of the creator.\\r\\n     * @dev The creator signs a payload while creating the NFT.\\r\\n     * @param tokenId The Id of the token.\\r\\n     * @return address The creator.\\r\\n     */\\r\\n    function payloadSigner(uint256 tokenId) external view returns (address) {\\r\\n        require(_exists(tokenId), \\\"CXIP: token does not exist\\\");\\r\\n        uint256 index = RotatingToken.calculateRotation(tokenId, getTokenSeparator());\\r\\n        return _tokenData[index].creator;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Shows the interfaces the contracts support\\r\\n     * @dev Must add new 4 byte interface Ids here to acknowledge support\\r\\n     * @param interfaceId ERC165 style 4 byte interfaceId.\\r\\n     * @return bool True if supported.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\\r\\n        if (\\r\\n            interfaceId == 0x01ffc9a7 || // ERC165\\r\\n            interfaceId == 0x80ac58cd || // ERC721\\r\\n            interfaceId == 0x780e9d63 || // ERC721Enumerable\\r\\n            interfaceId == 0x5b5e139f || // ERC721Metadata\\r\\n            interfaceId == 0x150b7a02 || // ERC721TokenReceiver\\r\\n            interfaceId == 0xe8a3d485 || // contractURI()\\r\\n            IPA1D(getRegistry().getPA1D()).supportsInterface(interfaceId)\\r\\n        ) {\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the collection's symbol.\\r\\n     * @dev Trims the symbol.\\r\\n     * @return string The symbol.\\r\\n     */\\r\\n    function symbol() external view returns (string memory) {\\r\\n        return string(Bytes.trim(_collectionData.symbol));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get's the URI of the token.\\r\\n     * @dev Defaults the the Arweave URI\\r\\n     * @return string The URI.\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\\r\\n        require(_exists(tokenId), \\\"CXIP: token does not exist\\\");\\r\\n        uint256 index = RotatingToken.calculateRotation(tokenId, getTokenSeparator());\\r\\n        return string(abi.encodePacked(\\\"https://arweave.net/\\\", _tokenData[index].arweave, _tokenData[index].arweave2));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get list of tokens owned by wallet.\\r\\n     * @param wallet The wallet address to get tokens for.\\r\\n     * @return uint256[] Returns an array of token ids owned by wallet.\\r\\n     */\\r\\n    function tokensOfOwner(address wallet) external view returns (uint256[] memory) {\\r\\n        return _ownedTokens[wallet];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if a given hash matches a payload hash.\\r\\n     * @dev Uses sha256 instead of keccak.\\r\\n     * @param hash The hash to check.\\r\\n     * @param payload The payload prehashed.\\r\\n     * @return bool True if the hashes match.\\r\\n     */\\r\\n    function verifySHA256(bytes32 hash, bytes calldata payload) external pure returns (bool) {\\r\\n        bytes32 thePayloadHash = sha256(payload);\\r\\n        return hash == thePayloadHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a new address to the token's approval list.\\r\\n     * @dev Requires the sender to be in the approved addresses.\\r\\n     * @param to The address to approve.\\r\\n     * @param tokenId The affected token.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) public {\\r\\n        address tokenOwner = _tokenOwner[tokenId];\\r\\n        require(to != tokenOwner, \\\"CXIP: can't approve self\\\");\\r\\n        require(_isApproved(msg.sender, tokenId), \\\"CXIP: not approved sender\\\");\\r\\n        _tokenApprovals[tokenId] = to;\\r\\n        emit Approval(tokenOwner, to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Burns the token.\\r\\n     * @dev The sender must be the owner or approved.\\r\\n     * @param tokenId The token to burn.\\r\\n     */\\r\\n    function burn(uint256 tokenId) public {\\r\\n        require(_isApproved(msg.sender, tokenId), \\\"CXIP: not approved sender\\\");\\r\\n        address wallet = _tokenOwner[tokenId];\\r\\n        _clearApproval(tokenId);\\r\\n        _tokenOwner[tokenId] = address(0);\\r\\n        emit Transfer(wallet, address(0), tokenId);\\r\\n        _removeTokenFromOwnerEnumeration(wallet, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes the collection.\\r\\n     * @dev Special function to allow a one time initialisation on deployment. Also configures and deploys royalties.\\r\\n     * @param newOwner The owner of the collection.\\r\\n     * @param collectionData The collection data.\\r\\n     */\\r\\n    function init(address newOwner, CollectionData calldata collectionData) public {\\r\\n        require(Address.isZero(_admin), \\\"CXIP: already initialized\\\");\\r\\n        _admin = msg.sender;\\r\\n        // temporary set to self, to pass rarible royalties logic trap\\r\\n        _owner = address(this);\\r\\n        _collectionData = collectionData;\\r\\n        IPA1D(address(this)).init (0, payable(collectionData.royalties), collectionData.bps);\\r\\n        // set to actual owner\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n     * @param from cannot be the zero address.\\r\\n     * @param to cannot be the zero address.\\r\\n     * @param tokenId token must exist and be owned by `from`.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) public payable {\\r\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n     * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\\r\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n     * @param from cannot be the zero address.\\r\\n     * @param to cannot be the zero address.\\r\\n     * @param tokenId token must exist and be owned by `from`.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory data\\r\\n    ) public payable {\\r\\n        require(_isApproved(msg.sender, tokenId), \\\"CXIP: not approved sender\\\");\\r\\n        _transferFrom(from, to, tokenId);\\r\\n        if (Address.isContract(to)) {\\r\\n            require(\\r\\n                ICxipERC721(to).onERC721Received(address(this), from, tokenId, data) == 0x150b7a02,\\r\\n                \\\"CXIP: onERC721Received fail\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a new approved operator.\\r\\n     * @dev Allows platforms to sell/transfer all your NFTs. Used with proxy contracts like OpenSea/Rarible.\\r\\n     * @param to The address to approve.\\r\\n     * @param approved Turn on or off approval status.\\r\\n     */\\r\\n    function setApprovalForAll(address to, bool approved) public {\\r\\n        require(to != msg.sender, \\\"CXIP: can't approve self\\\");\\r\\n        _operatorApprovals[msg.sender][to] = approved;\\r\\n        emit ApprovalForAll(msg.sender, to, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfers `tokenId` token from `from` to `to`.\\r\\n     * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\r\\n     * @param from  cannot be the zero address.\\r\\n     * @param to cannot be the zero address.\\r\\n     * @param tokenId token must be owned by `from`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) public payable {\\r\\n        transferFrom(from, to, tokenId, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfers `tokenId` token from `from` to `to`.\\r\\n     * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\r\\n     * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\\r\\n     * @param from  cannot be the zero address.\\r\\n     * @param to cannot be the zero address.\\r\\n     * @param tokenId token must be owned by `from`.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory /*_data*/\\r\\n    ) public payable {\\r\\n        require(_isApproved(msg.sender, tokenId), \\\"CXIP: not approved sender\\\");\\r\\n        _transferFrom(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Mints batches of NFTs.\\r\\n     * @dev Limited to maximum number of NFTs that can be minted for this drop. Needs to be called in tokenId sequence.\\r\\n     * @param creatorWallet The wallet address of the NFT creator.\\r\\n     * @param startId The tokenId from which to start batch mint.\\r\\n     * @param length The total number of NFTs to mint starting from the startId.\\r\\n     * @param recipient Optional parameter, to send the token to a recipient right after minting.\\r\\n     */\\r\\n    function batchMint(address creatorWallet, uint256 startId, uint256 length, address recipient) public onlyOwner {\\r\\n        require(!getMintingClosed(), \\\"CXIP: minting is now closed\\\");\\r\\n        require(_allTokens.length + length <= getTokenLimit(), \\\"CXIP: over token limit\\\");\\r\\n        require(isIdentityWallet(creatorWallet), \\\"CXIP: creator not in identity\\\");\\r\\n        bool hasRecipient = !Address.isZero(recipient);\\r\\n        uint256 tokenId;\\r\\n        for (uint256 i = 0; i < length; i++) {\\r\\n            tokenId = (startId + i);\\r\\n            if (hasRecipient) {\\r\\n                require(!_exists(tokenId), \\\"CXIP: token already exists\\\");\\r\\n                emit Transfer(address(0), creatorWallet, tokenId);\\r\\n                emit Transfer(creatorWallet, recipient, tokenId);\\r\\n                _tokenOwner[tokenId] = recipient;\\r\\n                _addTokenToOwnerEnumeration(recipient, tokenId);\\r\\n            } else {\\r\\n                _mint(creatorWallet, tokenId);\\r\\n            }\\r\\n        }\\r\\n        if (_allTokens.length == getTokenLimit()) {\\r\\n            setMintingClosed();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getStartTimestamp() public view returns (uint256) {\\r\\n        return RotatingToken.getStartTimestamp();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the minting status from storage slot.\\r\\n     * @return mintingClosed Whether minting is open or closed permanently.\\r\\n     */\\r\\n    function getMintingClosed() public view returns (bool mintingClosed) {\\r\\n        // The slot hash has been precomputed for gas optimizaion\\r\\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.DanielArshamErosions.mintingClosed')) - 1);\\r\\n        uint256 data;\\r\\n        assembly {\\r\\n            data := sload(\\r\\n                /* slot */\\r\\n                0xab90edbe8f424080ec4ee1e9062e8b7540cbbfd5f4287285e52611030e58b8d4\\r\\n            )\\r\\n        }\\r\\n        mintingClosed = (data == 1);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the minting status to closed in storage slot.\\r\\n     */\\r\\n    function setMintingClosed() public onlyOwner {\\r\\n        // The slot hash has been precomputed for gas optimizaion\\r\\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.DanielArshamErosions.mintingClosed')) - 1);\\r\\n        uint256 data = 1;\\r\\n        assembly {\\r\\n            sstore(\\r\\n                /* slot */\\r\\n                0xab90edbe8f424080ec4ee1e9062e8b7540cbbfd5f4287285e52611030e58b8d4,\\r\\n                data\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the token limit from storage slot.\\r\\n     * @return tokenLimit Maximum number of tokens that can be minted.\\r\\n     */\\r\\n    function getTokenLimit() public view returns (uint256 tokenLimit) {\\r\\n        // The slot hash has been precomputed for gas optimizaion\\r\\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.DanielArshamErosions.tokenLimit')) - 1);\\r\\n        assembly {\\r\\n            tokenLimit := sload(\\r\\n                /* slot */\\r\\n                0xb63653e470fa8e7fcc528e0068173a1969fdee5ae0ee29dd58e7b6111b829c56\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the token limit to storage slot.\\r\\n     * @param tokenLimit Maximum number of tokens that can be minted.\\r\\n     */\\r\\n    function setTokenLimit(uint256 tokenLimit) public onlyOwner {\\r\\n        require(getTokenLimit() == 0, \\\"CXIP: token limit already set\\\");\\r\\n        // The slot hash has been precomputed for gas optimizaion\\r\\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.DanielArshamErosions.tokenLimit')) - 1);\\r\\n        assembly {\\r\\n            sstore(\\r\\n                /* slot */\\r\\n                0xb63653e470fa8e7fcc528e0068173a1969fdee5ae0ee29dd58e7b6111b829c56,\\r\\n                tokenLimit\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the token separator from storage slot.\\r\\n     * @return tokenSeparator The number of tokens before separation.\\r\\n     */\\r\\n    function getTokenSeparator() public view returns (uint256 tokenSeparator) {\\r\\n        // The slot hash has been precomputed for gas optimizaion\\r\\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.DanielArshamErosions.tokenSeparator')) - 1);\\r\\n        assembly {\\r\\n            tokenSeparator := sload(\\r\\n                /* slot */\\r\\n                0x988145eec05de02f4c5d4ecd419a9617237db574d35b27207657cbd8c5b1f045\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the token separator to storage slot.\\r\\n     * @param tokenSeparator The number of tokens before separation.\\r\\n     */\\r\\n    function setTokenSeparator(uint256 tokenSeparator) public onlyOwner {\\r\\n        require(getTokenSeparator() == 0, \\\"CXIP: separator already set\\\");\\r\\n        // The slot hash has been precomputed for gas optimizaion\\r\\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.DanielArshamErosions.tokenSeparator')) - 1);\\r\\n        assembly {\\r\\n            sstore(\\r\\n                /* slot */\\r\\n                0x988145eec05de02f4c5d4ecd419a9617237db574d35b27207657cbd8c5b1f045,\\r\\n                tokenSeparator\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set an NFT state.\\r\\n     * @dev Time-based states will be retrieved by index.\\r\\n     * @param id The index of time slot to set for.\\r\\n     * @param tokenData The token data for the particular time slot.\\r\\n     */\\r\\n    function prepareMintData(uint256 id, TokenData calldata tokenData) public onlyOwner {\\r\\n        require(Address.isZero(_tokenData[id].creator), \\\"CXIP: token data already set\\\");\\r\\n        _tokenData[id] = tokenData;\\r\\n    }\\r\\n\\r\\n    function prepareMintDataBatch(uint256[] calldata ids, TokenData[] calldata tokenData) public onlyOwner {\\r\\n        require(ids.length == tokenData.length, \\\"CXIP: array lengths missmatch\\\");\\r\\n        for (uint256 i = 0; i < ids.length; i++) {\\r\\n            require(Address.isZero(_tokenData[ids[i]].creator), \\\"CXIP: token data already set\\\");\\r\\n            _tokenData[ids[i]] = tokenData[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the configuration for rotation calculations.\\r\\n     * @param interval The number of seconds each rotation is shown for.\\r\\n     * @param steps Total number of steps for complete rotation. Reverse rotation including.\\r\\n     * @param halfwayPoint Step at which to reverse the rotation backwards. Must be exactly in the middle.\\r\\n     */\\r\\n    function setRotationConfig(uint256 index, uint256 interval, uint256 steps, uint256 halfwayPoint) public onlyOwner {\\r\\n        RotatingToken.setRotationConfig(index, interval, steps, halfwayPoint);\\r\\n    }\\r\\n\\r\\n    function getRotationConfig(uint256 index) public view returns (uint256, uint256, uint256) {\\r\\n        return RotatingToken.getRotationConfig(index);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets a name for the collection.\\r\\n     * @dev The name is split in two for gas optimization.\\r\\n     * @param newName First part of name.\\r\\n     * @param newName2 Second part of name.\\r\\n     */\\r\\n    function setName(bytes32 newName, bytes32 newName2) public onlyOwner {\\r\\n        _collectionData.name = newName;\\r\\n        _collectionData.name2 = newName2;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the start timestamp for token rotations.\\r\\n     * @dev All rotation calculations will use this timestamp as the origin point from which to calculate.\\r\\n     * @param _timestamp UNIX timestamp in seconds.\\r\\n     */\\r\\n    function setStartTimestamp(uint256 _timestamp) public onlyOwner {\\r\\n        RotatingToken.setStartTimestamp(_timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set a symbol for the collection.\\r\\n     * @dev This is the ticker symbol for smart contract that shows up on EtherScan.\\r\\n     * @param newSymbol The ticker symbol to set for smart contract.\\r\\n     */\\r\\n    function setSymbol(bytes32 newSymbol) public onlyOwner {\\r\\n        _collectionData.symbol = newSymbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfers ownership of the collection.\\r\\n     * @dev Can't be the zero address.\\r\\n     * @param newOwner Address of new owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        require(!Address.isZero(newOwner), \\\"CXIP: zero address\\\");\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get total number of tokens owned by wallet.\\r\\n     * @dev Used to see total amount of tokens owned by a specific wallet.\\r\\n     * @param wallet Address for which to get token balance.\\r\\n     * @return uint256 Returns an integer, representing total amount of tokens held by address.\\r\\n     */\\r\\n    function balanceOf(address wallet) public view returns (uint256) {\\r\\n        require(!Address.isZero(wallet), \\\"CXIP: zero address\\\");\\r\\n        return _ownedTokensCount[wallet];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get a base URI for the token.\\r\\n     * @dev Concatenates with the CXIP domain name.\\r\\n     * @return string the token URI.\\r\\n     */\\r\\n    function baseURI() public view returns (string memory) {\\r\\n        return string(abi.encodePacked(\\\"https://nft.cxip.io/\\\", Strings.toHexString(address(this))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the approved address for the token.\\r\\n     * @dev Single operator set for a specific token. Usually used for one-time very specific authorisations.\\r\\n     * @param tokenId Token id to get approved operator for.\\r\\n     * @return address Approved address for token.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) public view returns (address) {\\r\\n        return _tokenApprovals[tokenId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the associated identity for the collection.\\r\\n     * @dev Goes up the chain to read from the registry.\\r\\n     * @return address Identity contract address.\\r\\n     */\\r\\n    function getIdentity() public view returns (address) {\\r\\n        return ICxipProvenance(getRegistry().getProvenance()).getWalletIdentity(_owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the address is approved.\\r\\n     * @dev Includes references to OpenSea and Rarible marketplace proxies.\\r\\n     * @param wallet Address of the wallet.\\r\\n     * @param operator Address of the marketplace operator.\\r\\n     * @return bool True if approved.\\r\\n     */\\r\\n    function isApprovedForAll(address wallet, address operator) public view returns (bool) {\\r\\n        // pre-approved OpenSea and Rarible proxies removed, per Nifty Gateway's request\\r\\n        return (_operatorApprovals[wallet][operator]/* ||\\r\\n            // Rarible Transfer Proxy\\r\\n            0x4feE7B061C97C9c496b01DbcE9CDb10c02f0a0Be == operator ||\\r\\n            // OpenSea Transfer Proxy\\r\\n            address(OpenSeaProxyRegistry(0xa5409ec958C83C3f309868babACA7c86DCB077c1).proxies(wallet)) == operator*/);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Check if the sender is the owner.\\r\\n     * @dev The owner could also be the admin or identity contract of the owner.\\r\\n     * @return bool True if owner.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return (msg.sender == _owner || msg.sender == _admin || isIdentityWallet(msg.sender));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the owner's address.\\r\\n     * @dev _owner is first set in init.\\r\\n     * @return address Of ower.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks who the owner of a token is.\\r\\n     * @dev The token must exist.\\r\\n     * @param tokenId The token to look up.\\r\\n     * @return address Owner of the token.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\r\\n        address tokenOwner = _tokenOwner[tokenId];\\r\\n        require(!Address.isZero(tokenOwner), \\\"ERC721: token does not exist\\\");\\r\\n        return tokenOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get token by index.\\r\\n     * @dev Used in conjunction with totalSupply function to iterate over all tokens in collection.\\r\\n     * @param index Index of token in array.\\r\\n     * @return uint256 Returns the token id of token located at that index.\\r\\n     */\\r\\n    function tokenByIndex(uint256 index) public view returns (uint256) {\\r\\n        require(index < totalSupply(), \\\"CXIP: index out of bounds\\\");\\r\\n        return _allTokens[index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get token from wallet by index instead of token id.\\r\\n     * @dev Helpful for wallet token enumeration where token id info is not yet available. Use in conjunction with balanceOf function.\\r\\n     * @param wallet Specific address for which to get token for.\\r\\n     * @param index Index of token in array.\\r\\n     * @return uint256 Returns the token id of token located at that index in specified wallet.\\r\\n     */\\r\\n    function tokenOfOwnerByIndex(\\r\\n        address wallet,\\r\\n        uint256 index\\r\\n    ) public view returns (uint256) {\\r\\n        require(index < balanceOf(wallet));\\r\\n        return _ownedTokens[wallet][index];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Total amount of tokens in the collection.\\r\\n     * @dev Ignores burned tokens.\\r\\n     * @return uint256 Returns the total number of active (not burned) tokens.\\r\\n     */\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _allTokens.length;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Empty function that is triggered by external contract on NFT transfer.\\r\\n     * @dev We have this blank function in place to make sure that external contract sending in NFTs don't error out.\\r\\n     * @dev Since it's not being used, the _operator variable is commented out to avoid compiler warnings.\\r\\n     * @dev Since it's not being used, the _from variable is commented out to avoid compiler warnings.\\r\\n     * @dev Since it's not being used, the _tokenId variable is commented out to avoid compiler warnings.\\r\\n     * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\\r\\n     * @return bytes4 Returns the interfaceId of onERC721Received.\\r\\n     */\\r\\n    function onERC721Received(\\r\\n        address, /*_operator*/\\r\\n        address, /*_from*/\\r\\n        uint256, /*_tokenId*/\\r\\n        bytes calldata /*_data*/\\r\\n    ) public pure returns (bytes4) {\\r\\n        return 0x150b7a02;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows retrieval of royalties from the contract.\\r\\n     * @dev This is a default fallback to ensure the royalties are available.\\r\\n     */\\r\\n    function _royaltiesFallback() internal {\\r\\n        address _target = getRegistry().getPA1D();\\r\\n        assembly {\\r\\n            calldatacopy(0, 0, calldatasize())\\r\\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\\r\\n            returndatacopy(0, 0, returndatasize())\\r\\n            switch result\\r\\n            case 0 {\\r\\n                revert(0, returndatasize())\\r\\n            }\\r\\n            default {\\r\\n                return(0, returndatasize())\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if an address is an identity contract.\\r\\n     * @dev It must also be registred.\\r\\n     * @param sender Address to check if registered to identity.\\r\\n     * @return bool True if registred identity.\\r\\n     */\\r\\n    function isIdentityWallet(address sender) internal view returns (bool) {\\r\\n        address identity = getIdentity();\\r\\n        if (Address.isZero(identity)) {\\r\\n            return false;\\r\\n        }\\r\\n        return ICxipIdentity(identity).isWalletRegistered(sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Get the top-level CXIP Registry smart contract. Function must always be internal to prevent miss-use/abuse through bad programming practices.\\r\\n     * @return ICxipRegistry The address of the top-level CXIP Registry smart contract.\\r\\n     */\\r\\n    function getRegistry() internal pure returns (ICxipRegistry) {\\r\\n        return ICxipRegistry(0xC267d41f81308D7773ecB3BDd863a902ACC01Ade);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Add a newly minted token into managed list of tokens.\\r\\n     * @param to Address of token owner for which to add the token.\\r\\n     * @param tokenId Id of token to add.\\r\\n     */\\r\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\r\\n        _ownedTokensIndex[tokenId] = _ownedTokensCount[to];\\r\\n        _ownedTokensCount[to]++;\\r\\n        _ownedTokens[to].push(tokenId);\\r\\n        _allTokensIndex[tokenId] = _allTokens.length;\\r\\n        _allTokens.push(tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Deletes a token from the approval list.\\r\\n     * @dev Removes from count.\\r\\n     * @param tokenId T.\\r\\n     */\\r\\n    function _clearApproval(uint256 tokenId) private {\\r\\n        delete _tokenApprovals[tokenId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Mints an NFT.\\r\\n     * @dev Can to mint the token to the zero address and the token cannot already exist.\\r\\n     * @param to Address to mint to.\\r\\n     * @param tokenId The new token.\\r\\n     */\\r\\n    function _mint(address to, uint256 tokenId) private {\\r\\n        require(!Address.isZero(to), \\\"CXIP: can't mint a burn\\\");\\r\\n        require(!_exists(tokenId), \\\"CXIP: token already exists\\\");\\r\\n        _tokenOwner[tokenId] = to;\\r\\n        emit Transfer(address(0), to, tokenId);\\r\\n        _addTokenToOwnerEnumeration(to, tokenId);\\r\\n    }\\r\\n\\r\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\r\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\r\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\r\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\r\\n        _allTokens[tokenIndex] = lastTokenId;\\r\\n        _allTokensIndex[lastTokenId] = tokenIndex;\\r\\n        delete _allTokensIndex[tokenId];\\r\\n        delete _allTokens[lastTokenIndex];\\r\\n        _allTokens.pop();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Remove a token from managed list of tokens.\\r\\n     * @param from Address of token owner for which to remove the token.\\r\\n     * @param tokenId Id of token to remove.\\r\\n     */\\r\\n    function _removeTokenFromOwnerEnumeration(\\r\\n        address from,\\r\\n        uint256 tokenId\\r\\n    ) private {\\r\\n        _removeTokenFromAllTokensEnumeration(tokenId);\\r\\n        _ownedTokensCount[from]--;\\r\\n        uint256 lastTokenIndex = _ownedTokensCount[from];\\r\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\r\\n        if(tokenIndex != lastTokenIndex) {\\r\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\r\\n            _ownedTokens[from][tokenIndex] = lastTokenId;\\r\\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\\r\\n        }\\r\\n        if(lastTokenIndex == 0) {\\r\\n            delete _ownedTokens[from];\\r\\n        } else {\\r\\n            delete _ownedTokens[from][lastTokenIndex];\\r\\n            _ownedTokens[from].pop();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Primary internal function that handles the transfer/mint/burn functionality.\\r\\n     * @param from Address from where token is being transferred. Zero address means it is being minted.\\r\\n     * @param to Address to whom the token is being transferred. Zero address means it is being burned.\\r\\n     * @param tokenId Id of token that is being transferred/minted/burned.\\r\\n     */\\r\\n    function _transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) private {\\r\\n        require(_tokenOwner[tokenId] == from, \\\"CXIP: not from's token\\\");\\r\\n        require(!Address.isZero(to), \\\"CXIP: use burn instead\\\");\\r\\n        _clearApproval(tokenId);\\r\\n        _tokenOwner[tokenId] = to;\\r\\n        emit Transfer(from, to, tokenId);\\r\\n        _removeTokenFromOwnerEnumeration(from, tokenId);\\r\\n        _addTokenToOwnerEnumeration(to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the token owner exists.\\r\\n     * @dev If the address is the zero address no owner exists.\\r\\n     * @param tokenId The affected token.\\r\\n     * @return bool True if it exists.\\r\\n     */\\r\\n    function _exists(uint256 tokenId) private view returns (bool) {\\r\\n        address tokenOwner = _tokenOwner[tokenId];\\r\\n        return !Address.isZero(tokenOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the address is an approved one.\\r\\n     * @dev Uses inlined checks for different usecases of approval.\\r\\n     * @param spender Address of the spender.\\r\\n     * @param tokenId The affected token.\\r\\n     * @return bool True if approved.\\r\\n     */\\r\\n    function _isApproved(address spender, uint256 tokenId) private view returns (bool) {\\r\\n        require(_exists(tokenId));\\r\\n        address tokenOwner = _tokenOwner[tokenId];\\r\\n        return (\\r\\n            spender == tokenOwner ||\\r\\n            getApproved(tokenId) == spender ||\\r\\n            isApprovedForAll(tokenOwner, spender)\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"OpenSea.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\ncontract OpenSeaOwnableDelegateProxy {}\\r\\n\\r\\ncontract OpenSeaProxyRegistry {\\r\\n    mapping(address => OpenSeaOwnableDelegateProxy) public proxies;\\r\\n}\\r\\n\"\r\n    },\r\n    \"ICxipERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\nimport \\\"CollectionData.sol\\\";\\r\\nimport \\\"TokenData.sol\\\";\\r\\nimport \\\"Verification.sol\\\";\\r\\n\\r\\ninterface ICxipERC721 {\\r\\n    function arweaveURI(uint256 tokenId) external view returns (string memory);\\r\\n\\r\\n    function contractURI() external view returns (string memory);\\r\\n\\r\\n    function creator(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    function httpURI(uint256 tokenId) external view returns (string memory);\\r\\n\\r\\n    function ipfsURI(uint256 tokenId) external view returns (string memory);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function payloadHash(uint256 tokenId) external view returns (bytes32);\\r\\n\\r\\n    function payloadSignature(uint256 tokenId) external view returns (Verification memory);\\r\\n\\r\\n    function payloadSigner(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n\\r\\n    /* Disabled due to tokenEnumeration not enabled.\\r\\n    function tokensOfOwner(\\r\\n        address wallet\\r\\n    ) external view returns (uint256[] memory);\\r\\n    */\\r\\n\\r\\n    function verifySHA256(bytes32 hash, bytes calldata payload) external pure returns (bool);\\r\\n\\r\\n    function approve(address to, uint256 tokenId) external;\\r\\n\\r\\n    function burn(uint256 tokenId) external;\\r\\n\\r\\n    function init(address newOwner, CollectionData calldata collectionData) external;\\r\\n\\r\\n    /* Disabled since this flow has not been agreed on.\\r\\n    function onERC721Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n    */\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external payable;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory data\\r\\n    ) external payable;\\r\\n\\r\\n    function setApprovalForAll(address to, bool approved) external;\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external payable;\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory data\\r\\n    ) external payable;\\r\\n\\r\\n    function cxipMint(uint256 id, TokenData calldata tokenData) external returns (uint256);\\r\\n\\r\\n    function setApprovalForAll(\\r\\n        address from,\\r\\n        address to,\\r\\n        bool approved\\r\\n    ) external;\\r\\n\\r\\n    function setName(bytes32 newName, bytes32 newName2) external;\\r\\n\\r\\n    function setSymbol(bytes32 newSymbol) external;\\r\\n\\r\\n    function transferOwnership(address newOwner) external;\\r\\n\\r\\n    /*\\r\\n    // Disabled due to tokenEnumeration not enabled.\\r\\n    function balanceOf(address wallet) external view returns (uint256);\\r\\n    */\\r\\n    function baseURI() external view returns (string memory);\\r\\n\\r\\n    function getApproved(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    function getIdentity() external view returns (address);\\r\\n\\r\\n    function isApprovedForAll(address wallet, address operator) external view returns (bool);\\r\\n\\r\\n    function isOwner() external view returns (bool);\\r\\n\\r\\n    function owner() external view returns (address);\\r\\n\\r\\n    function ownerOf(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    /* Disabled due to tokenEnumeration not enabled.\\r\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\r\\n    */\\r\\n\\r\\n    /* Disabled due to tokenEnumeration not enabled.\\r\\n    function tokenOfOwnerByIndex(\\r\\n        address wallet,\\r\\n        uint256 index\\r\\n    ) external view returns (uint256);\\r\\n    */\\r\\n\\r\\n    /* Disabled due to tokenEnumeration not enabled.\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    */\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function onERC721Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external pure returns (bytes4);\\r\\n}\\r\\n\"\r\n    },\r\n    \"ICxipIdentity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\nimport \\\"CollectionData.sol\\\";\\r\\nimport \\\"InterfaceType.sol\\\";\\r\\nimport \\\"Token.sol\\\";\\r\\nimport \\\"TokenData.sol\\\";\\r\\n\\r\\ninterface ICxipIdentity {\\r\\n    function addSignedWallet(\\r\\n        address newWallet,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    function addWallet(address newWallet) external;\\r\\n\\r\\n    function connectWallet() external;\\r\\n\\r\\n    function createERC721Token(\\r\\n        address collection,\\r\\n        uint256 id,\\r\\n        TokenData calldata tokenData,\\r\\n        Verification calldata verification\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    function createERC721Collection(\\r\\n        bytes32 saltHash,\\r\\n        address collectionCreator,\\r\\n        Verification calldata verification,\\r\\n        CollectionData calldata collectionData\\r\\n    ) external returns (address);\\r\\n\\r\\n    function createCustomERC721Collection(\\r\\n        bytes32 saltHash,\\r\\n        address collectionCreator,\\r\\n        Verification calldata verification,\\r\\n        CollectionData calldata collectionData,\\r\\n        bytes32 slot,\\r\\n        bytes memory bytecode\\r\\n    ) external returns (address);\\r\\n\\r\\n    function init(address wallet, address secondaryWallet) external;\\r\\n\\r\\n    function getAuthorizer(address wallet) external view returns (address);\\r\\n\\r\\n    function getCollectionById(uint256 index) external view returns (address);\\r\\n\\r\\n    function getCollectionType(address collection) external view returns (InterfaceType);\\r\\n\\r\\n    function getWallets() external view returns (address[] memory);\\r\\n\\r\\n    function isCollectionCertified(address collection) external view returns (bool);\\r\\n\\r\\n    function isCollectionRegistered(address collection) external view returns (bool);\\r\\n\\r\\n    function isNew() external view returns (bool);\\r\\n\\r\\n    function isOwner() external view returns (bool);\\r\\n\\r\\n    function isTokenCertified(address collection, uint256 tokenId) external view returns (bool);\\r\\n\\r\\n    function isTokenRegistered(address collection, uint256 tokenId) external view returns (bool);\\r\\n\\r\\n    function isWalletRegistered(address wallet) external view returns (bool);\\r\\n\\r\\n    function listCollections(uint256 offset, uint256 length) external view returns (address[] memory);\\r\\n\\r\\n    function nextNonce(address wallet) external view returns (uint256);\\r\\n\\r\\n    function totalCollections() external view returns (uint256);\\r\\n\\r\\n    function isCollectionOpen(address collection) external pure returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"ICxipProvenance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\ninterface ICxipProvenance {\\r\\n    function createIdentity(\\r\\n        bytes32 saltHash,\\r\\n        address wallet,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256, address);\\r\\n\\r\\n    function createIdentityBatch(\\r\\n        bytes32 saltHash,\\r\\n        address[] memory wallets,\\r\\n        uint8[] memory V,\\r\\n        bytes32[] memory RS\\r\\n    ) external returns (uint256, address);\\r\\n\\r\\n    function getIdentity() external view returns (address);\\r\\n\\r\\n    function getWalletIdentity(address wallet) external view returns (address);\\r\\n\\r\\n    function informAboutNewWallet(address newWallet) external;\\r\\n\\r\\n    function isIdentityValid(address identity) external view returns (bool);\\r\\n\\r\\n    function nextNonce(address wallet) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"ICxipRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\ninterface ICxipRegistry {\\r\\n    function getAsset() external view returns (address);\\r\\n\\r\\n    function getAssetSigner() external view returns (address);\\r\\n\\r\\n    function getAssetSource() external view returns (address);\\r\\n\\r\\n    function getCopyright() external view returns (address);\\r\\n\\r\\n    function getCopyrightSource() external view returns (address);\\r\\n\\r\\n    function getCustomSource(bytes32 name) external view returns (address);\\r\\n\\r\\n    function getCustomSourceFromString(string memory name) external view returns (address);\\r\\n\\r\\n    function getERC1155CollectionSource() external view returns (address);\\r\\n\\r\\n    function getERC721CollectionSource() external view returns (address);\\r\\n\\r\\n    function getIdentitySource() external view returns (address);\\r\\n\\r\\n    function getPA1D() external view returns (address);\\r\\n\\r\\n    function getPA1DSource() external view returns (address);\\r\\n\\r\\n    function getProvenance() external view returns (address);\\r\\n\\r\\n    function getProvenanceSource() external view returns (address);\\r\\n\\r\\n    function owner() external view returns (address);\\r\\n\\r\\n    function setAsset(address proxy) external;\\r\\n\\r\\n    function setAssetSigner(address source) external;\\r\\n\\r\\n    function setAssetSource(address source) external;\\r\\n\\r\\n    function setCopyright(address proxy) external;\\r\\n\\r\\n    function setCopyrightSource(address source) external;\\r\\n\\r\\n    function setCustomSource(string memory name, address source) external;\\r\\n\\r\\n    function setERC1155CollectionSource(address source) external;\\r\\n\\r\\n    function setERC721CollectionSource(address source) external;\\r\\n\\r\\n    function setIdentitySource(address source) external;\\r\\n\\r\\n    function setPA1D(address proxy) external;\\r\\n\\r\\n    function setPA1DSource(address source) external;\\r\\n\\r\\n    function setProvenance(address proxy) external;\\r\\n\\r\\n    function setProvenanceSource(address source) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"IPA1D.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\nimport \\\"Zora.sol\\\";\\r\\n\\r\\ninterface IPA1D {\\r\\n    function init(\\r\\n        uint256 tokenId,\\r\\n        address payable receiver,\\r\\n        uint256 bp\\r\\n    ) external;\\r\\n\\r\\n    function configurePayouts(address payable[] memory addresses, uint256[] memory bps) external;\\r\\n\\r\\n    function getPayoutInfo() external view returns (address payable[] memory addresses, uint256[] memory bps);\\r\\n\\r\\n    function getEthPayout() external;\\r\\n\\r\\n    function getTokenPayout(address tokenAddress) external;\\r\\n\\r\\n    function getTokenPayoutByName(string memory tokenName) external;\\r\\n\\r\\n    function getTokensPayout(address[] memory tokenAddresses) external;\\r\\n\\r\\n    function getTokensPayoutByName(string[] memory tokenNames) external;\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool);\\r\\n\\r\\n    function setRoyalties(\\r\\n        uint256 tokenId,\\r\\n        address payable receiver,\\r\\n        uint256 bp\\r\\n    ) external;\\r\\n\\r\\n    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);\\r\\n\\r\\n    function getFeeBps(uint256 tokenId) external view returns (uint256[] memory);\\r\\n\\r\\n    function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory);\\r\\n\\r\\n    function getRoyalties(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\\r\\n\\r\\n    function getFees(uint256 tokenId) external view returns (address payable[] memory, uint256[] memory);\\r\\n\\r\\n    function tokenCreator(address contractAddress, uint256 tokenId) external view returns (address);\\r\\n\\r\\n    function calculateRoyaltyFee(\\r\\n        address contractAddress,\\r\\n        uint256 tokenId,\\r\\n        uint256 amount\\r\\n    ) external view returns (uint256);\\r\\n\\r\\n    function marketContract() external view returns (address);\\r\\n\\r\\n    function tokenCreators(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    function bidSharesForToken(uint256 tokenId) external view returns (Zora.BidShares memory bidShares);\\r\\n\\r\\n    function getStorageSlot(string calldata slot) external pure returns (bytes32);\\r\\n\\r\\n    function getTokenAddress(string memory tokenName) external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\nlibrary Address {\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        bytes32 codehash;\\r\\n        assembly {\\r\\n            codehash := extcodehash(account)\\r\\n        }\\r\\n        return (codehash != 0x0 && codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\\r\\n    }\\r\\n\\r\\n    function isZero(address account) internal pure returns (bool) {\\r\\n        return (account == address(0));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"Bytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\nlibrary Bytes {\\r\\n    function getBoolean(uint192 _packedBools, uint192 _boolNumber) internal pure returns (bool) {\\r\\n        uint192 flag = (_packedBools >> _boolNumber) & uint192(1);\\r\\n        return (flag == 1 ? true : false);\\r\\n    }\\r\\n\\r\\n    function setBoolean(\\r\\n        uint192 _packedBools,\\r\\n        uint192 _boolNumber,\\r\\n        bool _value\\r\\n    ) internal pure returns (uint192) {\\r\\n        if (_value) {\\r\\n            return _packedBools | (uint192(1) << _boolNumber);\\r\\n        } else {\\r\\n            return _packedBools & ~(uint192(1) << _boolNumber);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function slice(\\r\\n        bytes memory _bytes,\\r\\n        uint256 _start,\\r\\n        uint256 _length\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\r\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\r\\n        bytes memory tempBytes;\\r\\n        assembly {\\r\\n            switch iszero(_length)\\r\\n            case 0 {\\r\\n                tempBytes := mload(0x40)\\r\\n                let lengthmod := and(_length, 31)\\r\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\r\\n                let end := add(mc, _length)\\r\\n                for {\\r\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\r\\n                } lt(mc, end) {\\r\\n                    mc := add(mc, 0x20)\\r\\n                    cc := add(cc, 0x20)\\r\\n                } {\\r\\n                    mstore(mc, mload(cc))\\r\\n                }\\r\\n                mstore(tempBytes, _length)\\r\\n                mstore(0x40, and(add(mc, 31), not(31)))\\r\\n            }\\r\\n            default {\\r\\n                tempBytes := mload(0x40)\\r\\n                mstore(tempBytes, 0)\\r\\n                mstore(0x40, add(tempBytes, 0x20))\\r\\n            }\\r\\n        }\\r\\n        return tempBytes;\\r\\n    }\\r\\n\\r\\n    function trim(bytes32 source) internal pure returns (bytes memory) {\\r\\n        uint256 temp = uint256(source);\\r\\n        uint256 length = 0;\\r\\n        while (temp != 0) {\\r\\n            length++;\\r\\n            temp >>= 8;\\r\\n        }\\r\\n        return slice(abi.encodePacked(source), 32 - length, length);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"RotatingToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\nlibrary RotatingToken {\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the timestamp for rotation calculations from storage slot.\\r\\n     * @return _timestamp UNIX timestamp from which to calculate rotations.\\r\\n     */\\r\\n    function getStartTimestamp() internal view returns (uint256 _timestamp) {\\r\\n        // The slot hash has been precomputed for gas optimizaion\\r\\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.RotatingToken.startTimestamp')) - 1);\\r\\n        assembly {\\r\\n            _timestamp := sload(\\r\\n                /* slot */\\r\\n                0xe51ee22146f4be2b058d665ad864b055bc45a4c8ad1bc6964820072aff854bf4\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the timestamp for rotation calculations to storage slot.\\r\\n     * @param _timestamp UNIX timestamp from which to calculate rotations.\\r\\n     */\\r\\n    function setStartTimestamp(uint256 _timestamp) internal {\\r\\n        // The slot hash has been precomputed for gas optimizaion\\r\\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.RotatingToken.startTimestamp')) - 1);\\r\\n        assembly {\\r\\n            sstore(\\r\\n                /* slot */\\r\\n                0xe51ee22146f4be2b058d665ad864b055bc45a4c8ad1bc6964820072aff854bf4,\\r\\n                _timestamp\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Gets the configuration for rotation calculations from storage slot.\\r\\n     * @return interval The number of seconds each rotation is shown for.\\r\\n     * @return steps Total number of steps for complete rotation. Reverse rotation including.\\r\\n     * @return halfwayPoint Step at which to reverse the rotation backwards. Must be exactly in the middle.\\r\\n     */\\r\\n    function getRotationConfig() internal view returns (uint256 interval, uint256 steps, uint256 halfwayPoint) {\\r\\n        uint48 unpacked;\\r\\n        // The slot hash has been precomputed for gas optimizaion\\r\\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.RotatingToken.rotationConfig')) - 1);\\r\\n        assembly {\\r\\n            unpacked := sload(\\r\\n                /* slot */\\r\\n                0xd29f19547f24a5ccc86f14d7d83b6b987865a37f065e1c2eacd6b3b5be17886e\\r\\n            )\\r\\n        }\\r\\n        interval = uint256(uint16(unpacked >> 32));\\r\\n        steps = uint256(uint16(unpacked >> 16));\\r\\n        halfwayPoint = uint256(uint16(unpacked));\\r\\n    }\\r\\n    function getRotationConfig(uint256 index) internal view returns (uint256 interval, uint256 steps, uint256 halfwayPoint) {\\r\\n        uint48 unpacked;\\r\\n        bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(\\\"eip1967.CXIP.RotatingToken.rotationConfig.\\\", index))) - 1);\\r\\n        assembly {\\r\\n            unpacked := sload(slot)\\r\\n        }\\r\\n        interval = uint256(uint16(unpacked >> 32));\\r\\n        steps = uint256(uint16(unpacked >> 16));\\r\\n        halfwayPoint = uint256(uint16(unpacked));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the configuration for rotation calculations to storage slot.\\r\\n     * @param interval The number of seconds each rotation is shown for.\\r\\n     * @param steps Total number of steps for complete rotation. Reverse rotation including.\\r\\n     * @param halfwayPoint Step at which to reverse the rotation backwards. Must be exactly in the middle.\\r\\n     */\\r\\n    function setRotationConfig(uint256 interval, uint256 steps, uint256 halfwayPoint) internal {\\r\\n        // The slot hash has been precomputed for gas optimizaion\\r\\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.CXIP.RotatingToken.rotationConfig')) - 1);\\r\\n        uint256 packed = uint256(interval << 32 | steps << 16 | halfwayPoint);\\r\\n        assembly {\\r\\n            sstore(\\r\\n                /* slot */\\r\\n                0xd29f19547f24a5ccc86f14d7d83b6b987865a37f065e1c2eacd6b3b5be17886e,\\r\\n                packed\\r\\n            )\\r\\n        }\\r\\n    }\\r\\n    function setRotationConfig(uint256 index, uint256 interval, uint256 steps, uint256 halfwayPoint) internal {\\r\\n        bytes32 slot = bytes32(uint256(keccak256(abi.encodePacked(\\\"eip1967.CXIP.RotatingToken.rotationConfig.\\\", index))) - 1);\\r\\n        uint256 packed = uint256(interval << 32 | steps << 16 | halfwayPoint);\\r\\n        assembly {\\r\\n            sstore(slot, packed)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function calculateRotation(uint256 tokenId, uint256 tokenSeparator) internal view returns (uint256 rotationIndex) {\\r\\n        uint256 configIndex = (tokenId / tokenSeparator);\\r\\n        (uint256 interval, uint256 steps, uint256 halfwayPoint) = getRotationConfig(configIndex);\\r\\n        rotationIndex = ((block.timestamp - getStartTimestamp()) % (interval * steps)) / interval;\\r\\n        if (rotationIndex > halfwayPoint) {\\r\\n            rotationIndex = steps - rotationIndex;\\r\\n        }\\r\\n       rotationIndex = rotationIndex + ((halfwayPoint + 1) * configIndex);\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\nlibrary Strings {\\r\\n    function toHexString(address account) internal pure returns (string memory) {\\r\\n        return toHexString(uint256(uint160(account)));\\r\\n    }\\r\\n\\r\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\r\\n        if (value == 0) {\\r\\n            return \\\"0x00\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 length = 0;\\r\\n        while (temp != 0) {\\r\\n            length++;\\r\\n            temp >>= 8;\\r\\n        }\\r\\n        return toHexString(value, length);\\r\\n    }\\r\\n\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\r\\n            buffer[i] = bytes16(\\\"0123456789abcdef\\\")[value & 0xf];\\r\\n            value >>= 4;\\r\\n        }\\r\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\r\\n        return string(buffer);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"CollectionData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\nimport \\\"UriType.sol\\\";\\r\\n\\r\\nstruct CollectionData {\\r\\n    bytes32 name;\\r\\n    bytes32 name2;\\r\\n    bytes32 symbol;\\r\\n    address royalties;\\r\\n    uint96 bps;\\r\\n}\\r\\n\"\r\n    },\r\n    \"TokenData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\nimport \\\"Verification.sol\\\";\\r\\n\\r\\nstruct TokenData {\\r\\n    bytes32 payloadHash;\\r\\n    Verification payloadSignature;\\r\\n    address creator;\\r\\n    bytes32 arweave;\\r\\n    bytes11 arweave2;\\r\\n    bytes32 ipfs;\\r\\n    bytes14 ipfs2;\\r\\n}\\r\\n\"\r\n    },\r\n    \"Verification.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\nstruct Verification {\\r\\n    bytes32 r;\\r\\n    bytes32 s;\\r\\n    uint8 v;\\r\\n}\\r\\n\"\r\n    },\r\n    \"InterfaceType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\n// This is a 256 value limit (uint8)\\r\\nenum InterfaceType {\\r\\n    NULL, // 0\\r\\n    ERC20, // 1\\r\\n    ERC721, // 2\\r\\n    ERC1155 // 3\\r\\n}\\r\\n\"\r\n    },\r\n    \"Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\nimport \\\"InterfaceType.sol\\\";\\r\\n\\r\\nstruct Token {\\r\\n    address collection;\\r\\n    uint256 tokenId;\\r\\n    InterfaceType tokenType;\\r\\n    address creator;\\r\\n}\\r\\n\"\r\n    },\r\n    \"Zora.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\nlibrary Zora {\\r\\n    struct Decimal {\\r\\n        uint256 value;\\r\\n    }\\r\\n\\r\\n    struct BidShares {\\r\\n        // % of sale value that goes to the _previous_ owner of the nft\\r\\n        Decimal prevOwner;\\r\\n        // % of sale value that goes to the original creator of the nft\\r\\n        Decimal creator;\\r\\n        // % of sale value that goes to the seller (current owner) of the nft\\r\\n        Decimal owner;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"UriType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/*______/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_______/\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\r\\n _____/\\\\\\\\\\\\////////__\\\\///\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\/////\\\\\\\\\\\\///__\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\r\\n  ___/\\\\\\\\\\\\/_____________\\\\///\\\\\\\\\\\\\\\\\\\\\\\\/________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\r\\n   __/\\\\\\\\\\\\_________________\\\\//\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/__\\r\\n    _\\\\/\\\\\\\\\\\\__________________\\\\/\\\\\\\\\\\\\\\\__________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\/////////____\\r\\n     _\\\\//\\\\\\\\\\\\_________________/\\\\\\\\\\\\\\\\\\\\\\\\_________\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n      __\\\\///\\\\\\\\\\\\_____________/\\\\\\\\\\\\////\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_____________\\r\\n       ____\\\\////\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\/___\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_____________\\r\\n        _______\\\\/////////__\\\\///_______\\\\///__\\\\///////////__\\\\///____________*/\\r\\n\\r\\n// This is a 256 value limit (uint8)\\r\\nenum UriType {\\r\\n    ARWEAVE, // 0\\r\\n    IPFS, // 1\\r\\n    HTTP // 2\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true,\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"PermanentURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"arweaveURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"creatorWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"batchMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIdentity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMintingClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"mintingClosed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRotationConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenLimit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenSeparator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSeparator\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"httpURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"name2\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"symbol\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"royalties\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"bps\",\"type\":\"uint96\"}],\"internalType\":\"struct CollectionData\",\"name\":\"collectionData\",\"type\":\"tuple\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ipfsURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"payloadHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"payloadSignature\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"payloadSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"payloadSignature\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"arweave\",\"type\":\"bytes32\"},{\"internalType\":\"bytes11\",\"name\":\"arweave2\",\"type\":\"bytes11\"},{\"internalType\":\"bytes32\",\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"internalType\":\"bytes14\",\"name\":\"ipfs2\",\"type\":\"bytes14\"}],\"internalType\":\"struct TokenData\",\"name\":\"tokenData\",\"type\":\"tuple\"}],\"name\":\"prepareMintData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"payloadHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct Verification\",\"name\":\"payloadSignature\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"arweave\",\"type\":\"bytes32\"},{\"internalType\":\"bytes11\",\"name\":\"arweave2\",\"type\":\"bytes11\"},{\"internalType\":\"bytes32\",\"name\":\"ipfs\",\"type\":\"bytes32\"},{\"internalType\":\"bytes14\",\"name\":\"ipfs2\",\"type\":\"bytes14\"}],\"internalType\":\"struct TokenData[]\",\"name\":\"tokenData\",\"type\":\"tuple[]\"}],\"name\":\"prepareMintDataBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setMintingClosed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newName\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"newName2\",\"type\":\"bytes32\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"steps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"halfwayPoint\",\"type\":\"uint256\"}],\"name\":\"setRotationConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"setStartTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newSymbol\",\"type\":\"bytes32\"}],\"name\":\"setSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenLimit\",\"type\":\"uint256\"}],\"name\":\"setTokenLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenSeparator\",\"type\":\"uint256\"}],\"name\":\"setTokenSeparator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"verifySHA256\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"DanielArshamErosions","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"20000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://90a359d684b97c6b713ea9b32b4ba692c0a30c756921303538584e12837dadfe"}]}