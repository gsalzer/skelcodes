{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: Unlicense\r\npragma solidity 0.8.9;\r\n\r\n//This contract only exist in order to run migration test. \r\n//It is a genric fgreely mintable ERC-721 standard.\r\n\r\ninterface ERC721 /* is ERC165 */ {\r\n    \r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\"\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Set or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets.\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators.\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n\r\n}\r\n\r\n\r\ninterface ERC165 {\r\n\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n\r\n}\r\n\r\n\r\ninterface ERC721TokenReceiver {\r\n\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the\r\n    /// recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n    /// of other than the magic value MUST result in the transaction being reverted.\r\n    /// @notice The contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    /// unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n    \r\n}\r\n\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string calldata _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string calldata _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\ncontract IOU is ERC721 {\r\n\r\n    address public owner; //Address of the smart contract creator\r\n\r\n    mapping(address => uint256) internal balanceOfToken; //A counter tracking each owner token balance without having to loop.\r\n    mapping(uint256 => address) internal tokenOwners; //The mapping of the token to their owner\r\n\r\n    // Mapping associating owner with their operators\r\n    mapping(address => mapping(address => bool)) internal ownerOperators; // owner => operator => isOperator. \r\n\r\n    // Mapping associating tokens with an operator\r\n    mapping(uint256 => address) internal tokenOperator; // tokenId => operator\r\n\r\n    mapping(uint256 => address) internal preminters; //Each token preminter\r\n\r\n    mapping(uint256 => string) internal tokenUris; // Each token uri\r\n\r\n    // Total number of minted token\r\n    uint256 public mintedTokens;\r\n\r\n    //Set the owner as the smart contract creator\r\n    constructor(address _owner){\r\n        owner = _owner;\r\n    }\r\n\r\n    /// @notice Mint a token for msg.sender and return the tokenId of this token\r\n    /// @return the newly minted tokenId\r\n    function mint() external returns(uint256){\r\n        require(owner == msg.sender, \"Only the smart contract owner can mint tokens\");\r\n\r\n        mintedTokens = mintedTokens + 1;\r\n        require((preminters[mintedTokens] == address(0) || preminters[mintedTokens] == msg.sender) &&  tokenOwners[mintedTokens] == address(0), \"This token is already minted\");\r\n        tokenOwners[mintedTokens] = msg.sender;\r\n        balanceOfToken[msg.sender] = balanceOfToken[msg.sender] + 1;\r\n\r\n        emit Transfer(address(0x0), msg.sender, mintedTokens);\r\n        return mintedTokens;\r\n    }\r\n\r\n    function setTokenUri (uint256 _tokenId, string calldata tokenUri) external {\r\n        require(owner == msg.sender, \"Only the smart contract owner set tokens uri\");\r\n        require(tokenOwners[_tokenId] == address(0), \"Token must not be transferred to a owner\");\r\n        \r\n        tokenUris[_tokenId] = tokenUri;\r\n    }\r\n\r\n    function mint (uint256 _tokenID, string calldata _tokenUri) external returns(uint256){\r\n        require(owner == msg.sender, \"Only the smart contract owner can mint tokens\");\r\n        require((preminters[_tokenID] == address(0) || preminters[_tokenID] == msg.sender) && tokenOwners[_tokenID] == address(0), \"This token is already minted\");\r\n        mintedTokens = mintedTokens + 1;\r\n        tokenOwners[_tokenID] = msg.sender;\r\n        tokenUris[_tokenID] = _tokenUri;\r\n        balanceOfToken[msg.sender] = balanceOfToken[msg.sender] + 1;\r\n        emit Transfer(address(0x0), msg.sender, _tokenID);\r\n        return _tokenID;\r\n    }\r\n\r\n    /// @notice Mint a token reservation, allowing the preminter to send the non-existing token from address 0\r\n    /// @return the future minted tokenId\r\n    function premintFor(address _preminter) external returns(uint256){\r\n        require(owner == msg.sender, \"Only the smart contract owner can mint tokens\");\r\n\r\n        mintedTokens = mintedTokens + 1;\r\n        require(preminters[mintedTokens] == address(0) &&  tokenOwners[mintedTokens] == address(0), \"This token is already minted\");\r\n        preminters[mintedTokens] = _preminter;\r\n\r\n        return mintedTokens;\r\n    }\r\n\r\n    /// @notice Mint a token reservation, allowing the preminter to send the non-existing token from address 0\r\n    /// @return the future minted tokenId\r\n    function premintFor(address _preminter, uint256 _tokenID) external returns(uint256){\r\n\r\n        require(owner == msg.sender, \"Only the smart contract owner can mint tokens\");\r\n\r\n        mintedTokens = mintedTokens + 1;\r\n        require(preminters[_tokenID] == address(0) &&  tokenOwners[_tokenID] == address(0), \"This token is already minted\");\r\n        preminters[_tokenID] = _preminter;\r\n\r\n        return _tokenID;\r\n    }\r\n\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param _data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external payable override {\r\n        safeTransferInternal(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\"\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable override {\r\n        safeTransferInternal(_from, _to, _tokenId, bytes(\"\"));\r\n    }\r\n\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable override{\r\n        transferInternal(_from, _to, _tokenId);\r\n    }\r\n\r\n    /// @notice Set or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable override{\r\n\r\n        address _owner = tokenOwners[_tokenId];\r\n\r\n        //Operator verification\r\n        require(\r\n            msg.sender == _owner || // the current owner\r\n            ownerOperators[_owner][msg.sender], // an authorized operqtor\r\n            \"msg.sender is not allowed to approve an address for the NFT\"\r\n        );\r\n\r\n        tokenOperator[_tokenId] = _approved;\r\n        emit Approval(_owner, _approved, _tokenId);\r\n    }\r\n\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets.\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators.\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external override{\r\n        ownerOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view override returns (uint256){\r\n        require(_owner != address(0x0), \"0x0 is an invalid owner address\");\r\n        return(balanceOfToken[_owner]);\r\n    }\r\n\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view override returns (address){\r\n        address retour = tokenOwners[_tokenId];\r\n        require(retour != address(0x0), \"0x0 is an invalid owner address\");\r\n        return retour;\r\n    }\r\n\r\n    function preminterOf(uint256 _tokenId) external view returns (address){\r\n        address retour = preminters[_tokenId];\r\n        return retour;\r\n    }\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view  override returns (address) {\r\n        require(tokenOwners[_tokenId] != address(0x0), \"_tokenId is not a valid NFT tokenID\");\r\n        return tokenOperator[_tokenId];\r\n    }\r\n\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view override returns (bool){\r\n        return ownerOperators[_owner][_operator];\r\n    }\r\n\r\n\r\n    function isContract( address _addr ) internal view returns (bool addressCheck)\r\n    {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(_addr) } // solhint-disable-line\r\n        addressCheck = (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n\r\n\r\n    function safeTransferInternal(address _from, address _to, uint256 _tokenId, bytes memory _data) internal {\r\n\r\n        transferInternal(_from, _to, _tokenId);\r\n\r\n        if (isContract(_to))\r\n        {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n            // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")) === 0x150b7a02\r\n            require(retval == 0x150b7a02, \"The NFT was not received properly by the contract\");\r\n        }\r\n\r\n    }\r\n\r\n    /// @notice Transfer ownership of an NFT\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferInternal(address _from, address _to, uint256 _tokenId) internal {\r\n\r\n        if(tokenOwners[_tokenId] != address(0x0)){ //If already minted\r\n            //Ownership verification\r\n            require( tokenOwners[_tokenId] == _from, \"The specified _from does not match the current token owner\");\r\n\r\n            //Valid nft <=> owner != 0x0\r\n            require(_from != address(0x0), \"_tokenId is not a valid NFT\");\r\n\r\n            //Operator verification\r\n            require(\r\n                msg.sender == _from || // the current owner\r\n                ownerOperators[_from][msg.sender] || // an authorized operator\r\n                msg.sender == tokenOperator[_tokenId], // the approved address for this NFT\r\n                \"msg.sender is not allowed to transfer this NFT\"\r\n            );\r\n\r\n\r\n        } else { //If requiring minting\r\n            require(_from == address(0x0), \"_tokenId doesn't exist yet and neet to be minted\");\r\n            require(msg.sender == preminters[_tokenId], \"_tokenId has not be approved for minting by msg.sender\");\r\n            //require(msg.sender == preminters[_tokenId], string(abi.encodePacked(\"_____preminters[_tokenId]_\", toAsciiString(preminters[_tokenId]), \"_____msg.sender_\", toAsciiString(msg.sender))));\r\n            //require(_from == address(0x0), \"_tokenId doesn't exist yet and neet to be minted\");\r\n            //require(_to == preminters[_tokenId], \"_tokenId has not be approved for minting toward _to\");\r\n            //require(msg.sender == owner, \"only this smart contract owner can premint tokens\");\r\n        }\r\n\r\n        //Prevent 0x0 burns\r\n        require(_to != address(0x0), \"_to cannot be the address 0\");\r\n\r\n\r\n\r\n        //Transfer the token ownership record\r\n        tokenOwners[_tokenId] = _to;\r\n\r\n        //Clean the token approved address\r\n        tokenOperator[_tokenId] == address(0x0);\r\n\r\n        if(_from != address(0x0)){\r\n            balanceOfToken[_from] = balanceOfToken[_from] - 1;   \r\n        }\r\n        balanceOfToken[_to] = balanceOfToken[_to] + 1;\r\n\r\n        //Emit the transfer event\r\n        emit Transfer(_from, _to, _tokenId);\r\n\r\n\r\n    }\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns(string memory){\r\n        require(tokenOwners[_tokenId] != address(0), \"This token is not minted\");\r\n\r\n        return tokenUris[_tokenId];\r\n    }\r\n    \r\n        /// @notice Convert an Ethereum address to a human readable string\r\n    /// @param _addr The adress you want to convert\r\n    /// @return The address in 0x... format\r\n    function addressToString(address _addr) internal pure returns(string memory)\r\n    {\r\n        bytes32 addr32 = bytes32(uint256(uint160(_addr))); //Put the address 20 byte address in a bytes32 word\r\n        bytes memory alphabet = \"0123456789abcdef\";  //What are our allowed characters ?\r\n\r\n        //Initializing the array that is gonna get returned\r\n        bytes memory str = new bytes(42);\r\n\r\n        //Prefixing\r\n        str[0] = '0';\r\n        str[1] = 'x';\r\n\r\n        for (uint256 i = 0; i < 20; i++) { //iterating over the actual address\r\n\r\n            /*\r\n                proper offset : output starting at 2 because of '0X' prefix, 1 hexa char == 2 bytes.\r\n                input starting at 12 because of 12 bytes of padding, byteshifted because 2byte == 1char\r\n            */\r\n            str[2+i*2] = alphabet[uint8(addr32[i + 12] >> 4)];\r\n            str[3+i*2] = alphabet[uint8(addr32[i + 12] & 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n    \r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external pure returns(bool) {\r\n        return (\r\n            interfaceID == 0x80ac58cd || //ERC721\r\n            interfaceID == 0x01ffc9a7 //ERC165\r\n        );\r\n        \r\n    }\r\n\r\n    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\r\n        unchecked{\r\n            if (_i == 0) {\r\n                return \"0\";\r\n            }\r\n            uint j = _i;\r\n            uint len;\r\n            while (j != 0) {\r\n                len++;\r\n                j /= 10;\r\n            }\r\n            bytes memory bstr = new bytes(len);\r\n            uint k = len - 1;\r\n            while (_i != 0) {\r\n                bstr[k--] = bytes1(uint8(48 + _i % 10));\r\n                _i /= 10;\r\n            }\r\n            return string(bstr);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_tokenUri\",\"type\":\"string\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_preminter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"}],\"name\":\"premintFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_preminter\",\"type\":\"address\"}],\"name\":\"premintFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"preminterOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tokenUri\",\"type\":\"string\"}],\"name\":\"setTokenUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"IOU","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e4577d73fa5ea7414c966e756d73300a6b821150","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0482eace6077602671f7e302b562c4716abec1e2b2d15fbc37f5b165d17ce336"}]}