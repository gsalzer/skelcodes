{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"ConvexStrategist.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IBooster.sol\\\";\\nimport \\\"./IConvexPooL.sol\\\";\\nimport \\\"./ICurvePooLSize2.sol\\\";\\nimport \\\"./ICurvePooLSize3.sol\\\";\\nimport \\\"./ICurvePooLSize4.sol\\\";\\nimport \\\"./ICurveRegistry.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\ncontract ConvexStrategist is Ownable {\\n    \\n    mapping(address =\\u003e bool) public whitelist;\\n    address constant crv = 0xD533a949740bb3306d119CC777fa900bA034cd52;\\n    address constant cvx = 0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B;\\n    address constant curveRegistry = 0x90E00ACe148ca3b23Ac1bC8C240C2a7Dd9c2d7f5;\\n    address constant cvxBooster = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;\\n\\n    /**\\n     * (see depositAndStakeFor() function.)\\n     * @param amount            : amount of _token deposited\\n     * @param nCoins            : Number of coins inside Curve PooL\\n     * @param indexInAmounts    : Index of the coin deposited inside the amounts array\\n     * @param inner             : used to decide where are located the tokens\\n     * @param token             : the ERC20 token deposited in Curve\\n     * @param curvePooL         : curve pool associated to _token\\n     * @param convexPooL        : convex pool associated to _token\\n     * @param curveLPToken      : the liquidity provider token for the current curvePooL\\n     */\\n    struct Deposit {\\n        uint256 amount;\\n        uint256 nCoins;\\n        uint256 indexInAmounts;\\n        bool inner;\\n        address token;\\n        address curvePooL;\\n        address convexPooL;\\n        address curveLPToken;\\n    }\\n\\n    /**\\n     * (see harvestAndDeposit() function.)\\n     * @param crvSwapTxData  : paraswap buildTx data to swap tokens within this contract\\n     * @param cvxSwapTxData  : paraswap buildTx data to swap tokens within this contract\\n     * @param tokenTo        : destination token swap\\n     * @param curvePooL      : any curve pool\\n     * @param convexPooL     : any convex pool\\n     * @param curveLPToken   : Curve LP Token\\n     * @param crvAmount      : crv amount to be harvested\\n     * @param cvxAmount      : cvx amount to be harvested\\n     * @param nCoins         : Number of coins inside Curve PooL\\n     * @param indexInAmounts : Index of the coin deposited inside the amounts array\\n     * @param crvDex         : chosen dex to swap crv\\n     * @param cvxDex         : chosen dex to swap cvx\\n     */\\n    struct Harvest {\\n        bytes crvSwapTxData;\\n        bytes cvxSwapTxData;\\n        address tokenTo;\\n        address curvePooL;\\n        address convexPooL;\\n        address curveLPToken;\\n        uint256 crvAmount;\\n        uint256 cvxAmount;\\n        uint256 nCoins;\\n        uint256 indexInAmounts;\\n        address crvDex;\\n        address cvxDex;\\n    }\\n\\n    constructor(address[] memory _whiteListed, address[] memory _approved) {\\n        for (uint256 i = 0; i \\u003c _whiteListed.length; i++) {\\n            whitelist[_whiteListed[i]] = true;\\n        }\\n        for (uint256 i = 0; i \\u003c _approved.length; i++) {\\n            IERC20(crv).approve(_approved[i], type(uint256).max);\\n            IERC20(cvx).approve(_approved[i], type(uint256).max);\\n        }\\n    }\\n\\n    modifier onlyWhitelisted(address dex) {\\n        require(isWhitelisted(dex), \\\"!whitelist\\\");\\n        _;\\n    }\\n\\n    function addToWhiteList(address _address) external onlyOwner {\\n        whitelist[_address] = true;\\n    }\\n\\n    function removeFromWhiteList(address _address) external onlyOwner {\\n        delete whitelist[_address];\\n    }\\n\\n    function isWhitelisted(address _address) public view returns (bool) {\\n        return whitelist[_address];\\n    }\\n\\n    function setApprovals(\\n        address _token,\\n        address _spender,\\n        uint256 _amount\\n    ) external onlyOwner {\\n        IERC20(_token).approve(_spender, _amount);\\n    }\\n\\n    /**\\n     * Withdraw any ERC20\\n     * @param _to     : recipient\\n     * @param _token  : token to withdraw\\n     * @param _amount : amount to withdraw\\n     */\\n\\n    function withdrawERC20(\\n        address _to,\\n        address _token,\\n        uint256 _amount\\n    ) external onlyOwner {\\n        IERC20(_token).transfer(_to, _amount);\\n    }\\n\\n    /**\\n     * Handle deposit in multiple Curve pool according to the token number within the pool.\\n     * @param  _curvePooL       : curve pool were we deposit token\\n     * @param  _amount          : amount of token to deposit\\n     * @param _curveLPToken     : the liquidity provider token for the current _curvePooL\\n     * @param _nCoins           : number of tokens in the current _curvePooL\\n     * @param _indexInAmounts   : index of the token in the _curvePooL token list\\n     * @return minted           : the minted amount returned\\n     */\\n    function addCustomLiquidity(\\n        address _curvePooL,\\n        uint256 _amount,\\n        address _curveLPToken,\\n        uint256 _nCoins,\\n        uint256 _indexInAmounts\\n    ) internal returns (uint256 minted) {\\n        uint256 minMintAmout;\\n        uint256 initialBalance = IERC20(_curveLPToken).balanceOf(address(this));\\n        require(_amount \\u003e 0, \\\"!addCustomLiquidity: _amount \\u003e 0\\\");\\n        if (_nCoins == 2) {\\n            uint256[2] memory amounts;\\n            amounts[_indexInAmounts] = _amount;\\n            minMintAmout = 0;\\n            ICurvePooLSize2(_curvePooL).add_liquidity(amounts, minMintAmout);\\n        } else if (_nCoins == 3) {\\n            uint256[3] memory amounts;\\n            amounts[_indexInAmounts] = _amount;\\n            minMintAmout = 0;\\n            ICurvePooLSize3(_curvePooL).add_liquidity(amounts, minMintAmout);\\n        } else if (_nCoins == 4) {\\n            uint256[4] memory amounts;\\n            amounts[_indexInAmounts] = _amount;\\n            minMintAmout = 0;\\n            ICurvePooLSize4(_curvePooL).add_liquidity(amounts, minMintAmout);\\n        } else revert(\\\"!addCustomLiquidity\\\");\\n        uint256 finalBalance = IERC20(_curveLPToken).balanceOf(address(this));\\n        return (finalBalance - initialBalance);\\n    }\\n\\n    /**\\n     * Deposit \\u0026 stake _token on msg.sender behalf, in Curve \\u0026 Convex PooLs.\\n     * @param params    : see the Deposit struct.\\n     * @return          : the return value of stakeFor() from Convex PooL\\n     */\\n    function depositAndStakeFor(Deposit memory params) public returns (bool) {\\n        if (!params.inner) require(IERC20(params.token).transferFrom(msg.sender, address(this), params.amount), \\\"!transferFrom\\\");\\n        IERC20(params.token).approve(params.curvePooL, params.amount);\\n        uint256 minted = addCustomLiquidity(params.curvePooL, params.amount, params.curveLPToken, params.nCoins, params.indexInAmounts);\\n        address lpToken = ICurveRegistry(curveRegistry).get_lp_token(params.curvePooL);\\n        require(IERC20(lpToken).approve(cvxBooster, minted), \\\"!approve\\\");\\n        IBooster(cvxBooster).deposit(IConvexPooL(params.convexPooL).pid(), minted, false);\\n        address stakingToken = IConvexPooL(params.convexPooL).stakingToken();\\n        require(IERC20(stakingToken).approve(params.convexPooL, minted), \\\"!approve\\\");\\n        return IConvexPooL(params.convexPooL).stakeFor(msg.sender, minted);\\n    }\\n\\n    /**\\n     * Perform a swap that has been build off chain.\\n     * @param  _tokenFrom   : token to swap\\n     * @param  _amountIn    : amount of _tokenFrom to swap\\n     * @param  _data        : swap data to be executed\\n     * @param  _dex         : dex address used to swap\\n     */\\n    function swapReward(\\n        address _tokenFrom,\\n        uint256 _amountIn,\\n        address _dex,\\n        bytes memory _data\\n    ) private onlyWhitelisted(_dex) {\\n        IERC20(_tokenFrom).transferFrom(msg.sender, address(this), _amountIn);\\n        (bool success, ) = _dex.call(_data);\\n        require(success, _tokenFrom == crv ? \\\"!swap crv\\\" : \\\"!swap cvx\\\");\\n    }\\n\\n    /**\\n     * Harvest a defined amount of CRV and CVX, then dump them to increase the actual deposit\\n     * @param params         : see the Harvest struct.\\n     */\\n    function harvestAndDeposit(Harvest memory params) external returns (bool) {\\n        uint256 initial = IERC20(params.tokenTo).balanceOf(address(this));\\n        require(IConvexPooL(params.convexPooL).getReward(msg.sender, true), \\\"!getReward\\\");\\n        swapReward(crv, params.crvAmount, params.crvDex, params.crvSwapTxData);\\n        swapReward(cvx, params.cvxAmount, params.cvxDex, params.cvxSwapTxData);\\n        uint256 harvested = IERC20(params.tokenTo).balanceOf(address(this)) - initial;\\n        return\\n            depositAndStakeFor(\\n                Deposit(\\n                    harvested,\\n                    params.nCoins,\\n                    params.indexInAmounts,\\n                    true,\\n                    params.tokenTo,\\n                    params.curvePooL,\\n                    params.convexPooL,\\n                    params.curveLPToken\\n                )\\n            );\\n    }\\n\\n    fallback() external payable {\\n        revert(\\\"!fallback\\\");\\n    }\\n\\n    receive() external payable {\\n        revert(\\\"!receive\\\");\\n    }\\n}\\n\"},\"IAugustusSwapper.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity \\u003e=0.7.0 \\u003c0.8.4;\\npragma experimental ABIEncoderV2;\\n\\ninterface IAugustusSwapper {\\n    /**\\n   * @param fromToken Address of the source token\\n   * @param fromAmount Amount of source tokens to be swapped\\n   * @param toAmount Minimum destination token amount expected out of this swap\\n   * @param expectedAmount Expected amount of destination tokens without slippage\\n   * @param beneficiary Beneficiary address\\n   * 0 then 100% will be transferred to beneficiary. Pass 10000 for 100%\\n   * @param referrer referral id\\n   * @param useReduxToken whether to use redux token or not\\n   * @param path Route to be taken for this swap to take place\\n\\n   */\\n    struct SellData {\\n        address fromToken;\\n        uint256 fromAmount;\\n        uint256 toAmount;\\n        uint256 expectedAmount;\\n        address payable beneficiary;\\n        string referrer;\\n        bool useReduxToken;\\n        Path[] path;\\n    }\\n\\n    struct MegaSwapSellData {\\n        address fromToken;\\n        uint256 fromAmount;\\n        uint256 toAmount;\\n        uint256 expectedAmount;\\n        address payable beneficiary;\\n        string referrer;\\n        bool useReduxToken;\\n        MegaSwapPath[] path;\\n    }\\n\\n    struct BuyData {\\n        address fromToken;\\n        address toToken;\\n        uint256 fromAmount;\\n        uint256 toAmount;\\n        address payable beneficiary;\\n        string referrer;\\n        bool useReduxToken;\\n        BuyRoute[] route;\\n    }\\n\\n    struct Route {\\n        address payable exchange;\\n        address targetExchange;\\n        uint256 percent;\\n        bytes payload;\\n        uint256 networkFee; //Network fee is associated with 0xv3 trades\\n    }\\n\\n    struct MegaSwapPath {\\n        uint256 fromAmountPercent;\\n        Path[] path;\\n    }\\n\\n    struct Path {\\n        address to;\\n        uint256 totalNetworkFee; //Network fee is associated with 0xv3 trades\\n        Route[] routes;\\n    }\\n\\n    struct BuyRoute {\\n        address payable exchange;\\n        address targetExchange;\\n        uint256 fromAmount;\\n        uint256 toAmount;\\n        bytes payload;\\n        uint256 networkFee; //Network fee is associated with 0xv3 trades\\n    }\\n\\n    function getPartnerRegistry() external view returns (address);\\n\\n    function getWhitelistAddress() external view returns (address);\\n\\n    function getFeeWallet() external view returns (address);\\n\\n    function getTokenTransferProxy() external view returns (address);\\n\\n    function getUniswapProxy() external view returns (address);\\n\\n    function getVersion() external view returns (string memory);\\n\\n    /**\\n     * @dev The function which performs the multi path swap.\\n     */\\n    function multiSwap(SellData calldata data) external payable returns (uint256);\\n\\n    /**\\n     * @dev The function which performs the single path buy.\\n     */\\n    function buy(BuyData calldata data) external payable returns (uint256);\\n\\n    function swapOnUniswap(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        uint8 referrer\\n    ) external payable;\\n\\n    function buyOnUniswap(\\n        uint256 amountInMax,\\n        uint256 amountOut,\\n        address[] calldata path,\\n        uint8 referrer\\n    ) external payable;\\n\\n    function buyOnUniswapFork(\\n        address factory,\\n        bytes32 initCode,\\n        uint256 amountInMax,\\n        uint256 amountOut,\\n        address[] calldata path,\\n        uint8 referrer\\n    ) external payable;\\n\\n    function swapOnUniswapFork(\\n        address factory,\\n        bytes32 initCode,\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        uint8 referrer\\n    ) external payable;\\n\\n    function simplBuy(\\n        address fromToken,\\n        address toToken,\\n        uint256 fromAmount,\\n        uint256 toAmount,\\n        address[] memory callees,\\n        bytes memory exchangeData,\\n        uint256[] memory startIndexes,\\n        uint256[] memory values,\\n        address payable beneficiary,\\n        string memory referrer,\\n        bool useReduxToken\\n    ) external payable;\\n\\n    function simpleSwap(\\n        address fromToken,\\n        address toToken,\\n        uint256 fromAmount,\\n        uint256 toAmount,\\n        uint256 expectedAmount,\\n        address[] memory callees,\\n        bytes memory exchangeData,\\n        uint256[] memory startIndexes,\\n        uint256[] memory values,\\n        address payable beneficiary,\\n        string memory referrer,\\n        bool useReduxToken\\n    ) external payable returns (uint256 receivedAmount);\\n\\n    /**\\n     * @dev The function which performs the mega path swap.\\n     * @param data Data required to perform swap.\\n     */\\n    function megaSwap(MegaSwapSellData memory data) external payable returns (uint256);\\n}\\n\"},\"IBooster.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\ninterface IBooster {\\n    function FEE_DENOMINATOR() external view returns (uint256);\\n\\n    function MaxFees() external view returns (uint256);\\n\\n    function addPool(\\n        address _lptoken,\\n        address _gauge,\\n        uint256 _stashVersion\\n    ) external returns (bool);\\n\\n    function claimRewards(uint256 _pid, address _gauge) external returns (bool);\\n\\n    function crv() external view returns (address);\\n\\n    function deposit(\\n        uint256 _pid,\\n        uint256 _amount,\\n        bool _stake\\n    ) external returns (bool);\\n\\n    function depositAll(uint256 _pid, bool _stake) external returns (bool);\\n\\n    function distributionAddressId() external view returns (uint256);\\n\\n    function earmarkFees() external returns (bool);\\n\\n    function earmarkIncentive() external view returns (uint256);\\n\\n    function earmarkRewards(uint256 _pid) external returns (bool);\\n\\n    function feeDistro() external view returns (address);\\n\\n    function feeManager() external view returns (address);\\n\\n    function feeToken() external view returns (address);\\n\\n    function gaugeMap(address) external view returns (bool);\\n\\n    function isShutdown() external view returns (bool);\\n\\n    function lockFees() external view returns (address);\\n\\n    function lockIncentive() external view returns (uint256);\\n\\n    function lockRewards() external view returns (address);\\n\\n    function minter() external view returns (address);\\n\\n    function owner() external view returns (address);\\n\\n    function platformFee() external view returns (uint256);\\n\\n    function poolInfo(uint256)\\n        external\\n        view\\n        returns (\\n            address lptoken,\\n            address token,\\n            address gauge,\\n            address crvRewards,\\n            address stash,\\n            bool shutdown\\n        );\\n\\n    function poolLength() external view returns (uint256);\\n\\n    function poolManager() external view returns (address);\\n\\n    function registry() external view returns (address);\\n\\n    function rewardArbitrator() external view returns (address);\\n\\n    function rewardClaimed(\\n        uint256 _pid,\\n        address _address,\\n        uint256 _amount\\n    ) external returns (bool);\\n\\n    function rewardFactory() external view returns (address);\\n\\n    function setArbitrator(address _arb) external;\\n\\n    function setFactories(\\n        address _rfactory,\\n        address _sfactory,\\n        address _tfactory\\n    ) external;\\n\\n    function setFeeInfo() external;\\n\\n    function setFeeManager(address _feeM) external;\\n\\n    function setFees(\\n        uint256 _lockFees,\\n        uint256 _stakerFees,\\n        uint256 _callerFees,\\n        uint256 _platform\\n    ) external;\\n\\n    function setGaugeRedirect(uint256 _pid) external returns (bool);\\n\\n    function setOwner(address _owner) external;\\n\\n    function setPoolManager(address _poolM) external;\\n\\n    function setRewardContracts(address _rewards, address _stakerRewards) external;\\n\\n    function setTreasury(address _treasury) external;\\n\\n    function setVoteDelegate(address _voteDelegate) external;\\n\\n    function shutdownPool(uint256 _pid) external returns (bool);\\n\\n    function shutdownSystem() external;\\n\\n    function staker() external view returns (address);\\n\\n    function stakerIncentive() external view returns (uint256);\\n\\n    function stakerRewards() external view returns (address);\\n\\n    function stashFactory() external view returns (address);\\n\\n    function tokenFactory() external view returns (address);\\n\\n    function treasury() external view returns (address);\\n\\n    function vote(\\n        uint256 _voteId,\\n        address _votingAddress,\\n        bool _support\\n    ) external returns (bool);\\n\\n    function voteDelegate() external view returns (address);\\n\\n    function voteGaugeWeight(\\n        address[] memory _gauge,\\n        uint256[] memory _weight // MEMORY ADDED\\n    ) external returns (bool);\\n\\n    function voteOwnership() external view returns (address);\\n\\n    function voteParameter() external view returns (address);\\n\\n    function withdraw(uint256 _pid, uint256 _amount) external returns (bool);\\n\\n    function withdrawAll(uint256 _pid) external returns (bool);\\n\\n    function withdrawTo(\\n        uint256 _pid,\\n        uint256 _amount,\\n        address _to\\n    ) external returns (bool);\\n}\\n\"},\"IConvexPooL.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\ninterface IConvexPooL {\\n    function addExtraReward(address _reward) external returns (bool);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function clearExtraRewards() external;\\n\\n    function currentRewards() external view returns (uint256);\\n\\n    function donate(uint256 _amount) external returns (bool);\\n\\n    function duration() external view returns (uint256);\\n\\n    function earned(address account) external view returns (uint256);\\n\\n    function extraRewards(uint256) external view returns (address);\\n\\n    function extraRewardsLength() external view returns (uint256);\\n\\n    function getReward() external returns (bool);\\n\\n    function getReward(address _account, bool _claimExtras) external returns (bool);\\n\\n    function historicalRewards() external view returns (uint256);\\n\\n    function lastTimeRewardApplicable() external view returns (uint256);\\n\\n    function lastUpdateTime() external view returns (uint256);\\n\\n    function newRewardRatio() external view returns (uint256);\\n\\n    function operator() external view returns (address);\\n\\n    function periodFinish() external view returns (uint256);\\n\\n    function pid() external view returns (uint256);\\n\\n    function queueNewRewards(uint256 _rewards) external returns (bool);\\n\\n    function queuedRewards() external view returns (uint256);\\n\\n    function rewardManager() external view returns (address);\\n\\n    function rewardPerToken() external view returns (uint256);\\n\\n    function rewardPerTokenStored() external view returns (uint256);\\n\\n    function rewardRate() external view returns (uint256);\\n\\n    function rewardToken() external view returns (address);\\n\\n    function rewards(address) external view returns (uint256);\\n\\n    function stake(uint256 _amount) external returns (bool);\\n\\n    function stakeAll() external returns (bool);\\n\\n    function stakeFor(address _for, uint256 _amount) external returns (bool);\\n\\n    function stakingToken() external view returns (address);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function userRewardPerTokenPaid(address) external view returns (uint256);\\n\\n    function withdraw(uint256 amount, bool claim) external returns (bool);\\n\\n    function withdrawAll(bool claim) external;\\n\\n    function withdrawAllAndUnwrap(bool claim) external;\\n\\n    function withdrawAndUnwrap(uint256 amount, bool claim) external returns (bool);\\n}\\n\"},\"ICurvePooL.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\ninterface ICurvePooL {\\n    function get_virtual_price() external view returns (uint256);\\n\\n    function exchange(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy\\n    ) external;\\n\\n    function get_dy(\\n        int128 i,\\n        int128 j,\\n        uint256 dx\\n    ) external view returns (uint256);\\n\\n    function A() external view returns (uint256);\\n\\n    function lp_token() external view returns (address);\\n\\n    function calc_token_amount(uint256[3] memory amounts, bool deposit) external view returns (uint256);\\n\\n    function calc_token_amount(uint256[4] memory amounts, bool is_deposit) external view returns (uint256);\\n\\n    function calc_token_amount(uint256[2] memory amounts, bool is_deposit) external view returns (uint256);\\n\\n    function coins(uint256 arg0) external view returns (address);\\n\\n    function coins(int128 arg0) external returns (address out);\\n}\\n\"},\"ICurvePooLSize2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\ninterface ICurvePooLSize2 {\\n    function A() external view returns (uint256);\\n\\n    function A_precise() external view returns (uint256);\\n\\n    function get_virtual_price() external view returns (uint256);\\n\\n    function calc_token_amount(uint256[2] calldata amounts, bool is_deposit) external view returns (uint256);\\n\\n    function add_liquidity(uint256[2] calldata amounts, uint256 min_mint_amount) external returns (uint256);\\n\\n    function get_dy(\\n        int128 i,\\n        int128 j,\\n        uint256 dx\\n    ) external view returns (uint256);\\n\\n    function exchange(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy\\n    ) external returns (uint256);\\n\\n    function remove_liquidity(uint256 _amount, uint256[2] calldata min_amounts) external returns (uint256[2] memory);\\n\\n    function remove_liquidity_imbalance(uint256[2] calldata amounts, uint256 max_burn_amount) external returns (uint256);\\n\\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);\\n\\n    function remove_liquidity_one_coin(\\n        uint256 _token_amount,\\n        int128 i,\\n        uint256 _min_amount\\n    ) external returns (uint256);\\n\\n    function ramp_A(uint256 _future_A, uint256 _future_time) external;\\n\\n    function stop_ramp_A() external;\\n\\n    function commit_new_fee(uint256 new_fee, uint256 new_admin_fee) external;\\n\\n    function apply_new_fee() external;\\n\\n    function revert_new_parameters() external;\\n\\n    function commit_transfer_ownership(address _owner) external;\\n\\n    function apply_transfer_ownership() external;\\n\\n    function revert_transfer_ownership() external;\\n\\n    function admin_balances(uint256 i) external view returns (uint256);\\n\\n    function withdraw_admin_fees() external;\\n\\n    function donate_admin_fees() external;\\n\\n    function kill_me() external;\\n\\n    function unkill_me() external;\\n\\n    function coins(uint256 arg0) external view returns (address);\\n\\n    function balances(uint256 arg0) external view returns (uint256);\\n\\n    function fee() external view returns (uint256);\\n\\n    function admin_fee() external view returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function lp_token() external view returns (address);\\n\\n    function initial_A() external view returns (uint256);\\n\\n    function future_A() external view returns (uint256);\\n\\n    function initial_A_time() external view returns (uint256);\\n\\n    function future_A_time() external view returns (uint256);\\n\\n    function admin_actions_deadline() external view returns (uint256);\\n\\n    function transfer_ownership_deadline() external view returns (uint256);\\n\\n    function future_fee() external view returns (uint256);\\n\\n    function future_admin_fee() external view returns (uint256);\\n\\n    function future_owner() external view returns (address);\\n}\\n\"},\"ICurvePooLSize3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\ninterface ICurvePooLSize3 {\\n    function A() external view returns (uint256);\\n\\n    function get_virtual_price() external view returns (uint256);\\n\\n    function calc_token_amount(uint256[3] calldata amounts, bool deposit) external view returns (uint256);\\n\\n    function add_liquidity(uint256[3] calldata amounts, uint256 min_mint_amount) external;\\n\\n    function get_dy(\\n        int128 i,\\n        int128 j,\\n        uint256 dx\\n    ) external view returns (uint256);\\n\\n    function get_dy_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dx\\n    ) external view returns (uint256);\\n\\n    function exchange(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy\\n    ) external;\\n\\n    function remove_liquidity(uint256 _amount, uint256[3] calldata min_amounts) external;\\n\\n    function remove_liquidity_imbalance(uint256[3] calldata amounts, uint256 max_burn_amount) external;\\n\\n    function calc_withdraw_one_coin(uint256 _token_amount, int128 i) external view returns (uint256);\\n\\n    function remove_liquidity_one_coin(\\n        uint256 _token_amount,\\n        int128 i,\\n        uint256 min_amount\\n    ) external;\\n\\n    function ramp_A(uint256 _future_A, uint256 _future_time) external;\\n\\n    function stop_ramp_A() external;\\n\\n    function commit_new_fee(uint256 new_fee, uint256 new_admin_fee) external;\\n\\n    function apply_new_fee() external;\\n\\n    function revert_new_parameters() external;\\n\\n    function commit_transfer_ownership(address _owner) external;\\n\\n    function apply_transfer_ownership() external;\\n\\n    function revert_transfer_ownership() external;\\n\\n    function admin_balances(uint256 i) external view returns (uint256);\\n\\n    function withdraw_admin_fees() external;\\n\\n    function donate_admin_fees() external;\\n\\n    function kill_me() external;\\n\\n    function unkill_me() external;\\n\\n    function coins(uint256 arg0) external view returns (address);\\n\\n    function balances(uint256 arg0) external view returns (uint256);\\n\\n    function fee() external view returns (uint256);\\n\\n    function admin_fee() external view returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function initial_A() external view returns (uint256);\\n\\n    function future_A() external view returns (uint256);\\n\\n    function initial_A_time() external view returns (uint256);\\n\\n    function future_A_time() external view returns (uint256);\\n\\n    function admin_actions_deadline() external view returns (uint256);\\n\\n    function transfer_ownership_deadline() external view returns (uint256);\\n\\n    function future_fee() external view returns (uint256);\\n\\n    function future_admin_fee() external view returns (uint256);\\n\\n    function future_owner() external view returns (address);\\n}\\n\"},\"ICurvePooLSize4.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\ninterface ICurvePooLSize4 {\\n    function get_virtual_price() external returns (uint256 out);\\n\\n    function calc_token_amount(uint256[4] calldata amounts, bool deposit) external returns (uint256 out);\\n\\n    function add_liquidity(uint256[4] calldata amounts, uint256 min_mint_amount) external;\\n\\n    function get_dy(\\n        int128 i,\\n        int128 j,\\n        uint256 dx\\n    ) external returns (uint256 out);\\n\\n    function get_dx(\\n        int128 i,\\n        int128 j,\\n        uint256 dy\\n    ) external returns (uint256 out);\\n\\n    function get_dy_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dx\\n    ) external returns (uint256 out);\\n\\n    function get_dx_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dy\\n    ) external returns (uint256 out);\\n\\n    function exchange(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy\\n    ) external;\\n\\n    function exchange_underlying(\\n        int128 i,\\n        int128 j,\\n        uint256 dx,\\n        uint256 min_dy\\n    ) external;\\n\\n    function remove_liquidity(uint256 _amount, uint256[4] calldata min_amounts) external;\\n\\n    function remove_liquidity_imbalance(uint256[4] calldata amounts, uint256 max_burn_amount) external;\\n\\n    function commit_new_parameters(\\n        uint256 amplification,\\n        uint256 new_fee,\\n        uint256 new_admin_fee\\n    ) external;\\n\\n    function apply_new_parameters() external;\\n\\n    function revert_new_parameters() external;\\n\\n    function commit_transfer_ownership(address _owner) external;\\n\\n    function apply_transfer_ownership() external;\\n\\n    function revert_transfer_ownership() external;\\n\\n    function withdraw_admin_fees() external;\\n\\n    function kill_me() external;\\n\\n    function unkill_me() external;\\n\\n    function coins(int128 arg0) external returns (address out);\\n\\n    function underlying_coins(int128 arg0) external returns (address out);\\n\\n    function balances(int128 arg0) external returns (uint256 out);\\n\\n    function A() external returns (uint256 out);\\n\\n    function fee() external returns (uint256 out);\\n\\n    function admin_fee() external returns (uint256 out);\\n\\n    function owner() external returns (address out);\\n\\n    function admin_actions_deadline() external returns (uint256 out);\\n\\n    function transfer_ownership_deadline() external returns (uint256 out);\\n\\n    function future_A() external returns (uint256 out);\\n\\n    function future_fee() external returns (uint256 out);\\n\\n    function future_admin_fee() external returns (uint256 out);\\n\\n    function future_owner() external returns (address out);\\n}\\n\"},\"ICurveRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\ninterface ICurveRegistry {\\n    function find_pool_for_coins(address _from, address _to) external view returns (address);\\n\\n    function find_pool_for_coins(\\n        address _from,\\n        address _to,\\n        uint256 i\\n    ) external view returns (address);\\n\\n    function get_n_coins(address _pool) external view returns (uint256[2] memory);\\n\\n    function get_coins(address _pool) external view returns (address[8] memory);\\n\\n    function get_underlying_coins(address _pool) external view returns (address[8] memory);\\n\\n    function get_decimals(address _pool) external view returns (uint256[8] memory);\\n\\n    function get_underlying_decimals(address _pool) external view returns (uint256[8] memory);\\n\\n    function get_rates(address _pool) external view returns (uint256[8] memory);\\n\\n    function get_gauges(address _pool) external view returns (address[10] memory, int128[10] memory);\\n\\n    function get_balances(address _pool) external view returns (uint256[8] memory);\\n\\n    function get_underlying_balances(address _pool) external view returns (uint256[8] memory);\\n\\n    function get_virtual_price_from_lp_token(address _token) external view returns (uint256);\\n\\n    function get_A(address _pool) external view returns (uint256);\\n\\n    function get_parameters(address _pool)\\n        external\\n        view\\n        returns (\\n            uint256 A,\\n            uint256 future_A,\\n            uint256 fee,\\n            uint256 admin_fee,\\n            uint256 future_fee,\\n            uint256 future_admin_fee,\\n            address future_owner,\\n            uint256 initial_A,\\n            uint256 initial_A_time,\\n            uint256 future_A_time\\n        );\\n\\n    function get_fees(address _pool) external view returns (uint256[2] memory);\\n\\n    function get_admin_balances(address _pool) external view returns (uint256[8] memory);\\n\\n    function get_coin_indices(\\n        address _pool,\\n        address _from,\\n        address _to\\n    )\\n        external\\n        view\\n        returns (\\n            int128,\\n            int128,\\n            bool\\n        );\\n\\n    function estimate_gas_used(\\n        address _pool,\\n        address _from,\\n        address _to\\n    ) external view returns (uint256);\\n\\n    function is_meta(address _pool) external view returns (bool);\\n\\n    function get_pool_name(address _pool) external view returns (string memory);\\n\\n    function get_coin_swap_count(address _coin) external view returns (uint256);\\n\\n    function get_coin_swap_complement(address _coin, uint256 _index) external view returns (address);\\n\\n    function get_pool_asset_type(address _pool) external view returns (uint256);\\n\\n    function add_pool(\\n        address _pool,\\n        uint256 _n_coins,\\n        address _lp_token,\\n        bytes32 _rate_info,\\n        uint256 _decimals,\\n        uint256 _underlying_decimals,\\n        bool _has_initial_A,\\n        bool _is_v1,\\n        string memory _name\\n    ) external;\\n\\n    function add_pool_without_underlying(\\n        address _pool,\\n        uint256 _n_coins,\\n        address _lp_token,\\n        bytes32 _rate_info,\\n        uint256 _decimals,\\n        uint256 _use_rates,\\n        bool _has_initial_A,\\n        bool _is_v1,\\n        string memory _name\\n    ) external;\\n\\n    function add_metapool(\\n        address _pool,\\n        uint256 _n_coins,\\n        address _lp_token,\\n        uint256 _decimals,\\n        string memory _name\\n    ) external;\\n\\n    function add_metapool(\\n        address _pool,\\n        uint256 _n_coins,\\n        address _lp_token,\\n        uint256 _decimals,\\n        string memory _name,\\n        address _base_pool\\n    ) external;\\n\\n    function remove_pool(address _pool) external;\\n\\n    function set_pool_gas_estimates(address[5] memory _addr, uint256[2][5] memory _amount) external;\\n\\n    function set_coin_gas_estimates(address[10] memory _addr, uint256[10] memory _amount) external;\\n\\n    function set_gas_estimate_contract(address _pool, address _estimator) external;\\n\\n    function set_liquidity_gauges(address _pool, address[10] memory _liquidity_gauges) external;\\n\\n    function set_pool_asset_type(address _pool, uint256 _asset_type) external;\\n\\n    function batch_set_pool_asset_type(address[32] memory _pools, uint256[32] memory _asset_types) external;\\n\\n    function address_provider() external view returns (address);\\n\\n    function gauge_controller() external view returns (address);\\n\\n    function pool_list(uint256 arg0) external view returns (address);\\n\\n    function pool_count() external view returns (uint256);\\n\\n    function coin_count() external view returns (uint256);\\n\\n    function get_coin(uint256 arg0) external view returns (address);\\n\\n    function get_pool_from_lp_token(address arg0) external view returns (address);\\n\\n    function get_lp_token(address arg0) external view returns (address);\\n\\n    function last_updated() external view returns (uint256);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"ISushiswapRouter.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.3;\\n\\ninterface ISushiswapRouter {\\n    function WETH() external view returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function factory() external view returns (address);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountsIn(uint256 amountOut, address[] memory path) external view returns (uint256[] memory amounts);\\n\\n    function getAmountsOut(uint256 amountIn, address[] memory path) external view returns (uint256[] memory amounts);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] memory path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n}\\n\"},\"ITokenTransferProxy.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity \\u003e=0.7.0 \\u003c0.8.4;\\n\\ninterface ITokenTransferProxy {\\n    function transferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function freeReduxTokens(address user, uint256 tokensToFree) external;\\n}\\n\"},\"ITriCryptoZap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\ninterface ITriCryptoZap {\\n    function add_liquidity(uint256[3] memory _amounts, uint256 _min_mint_amount) external returns (uint256);\\n\\n    function add_liquidity(\\n        uint256[3] memory _amounts,\\n        uint256 _min_mint_amount,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function remove_liquidity(uint256 _amount, uint256[3] memory _min_amounts) external returns (uint256[3] memory);\\n\\n    function remove_liquidity(\\n        uint256 _amount,\\n        uint256[3] memory _min_amounts,\\n        address _receiver\\n    ) external returns (uint256[3] memory);\\n\\n    function remove_liquidity_one_coin(\\n        uint256 _token_amount,\\n        uint256 i,\\n        uint256 _min_amount\\n    ) external returns (uint256);\\n\\n    function remove_liquidity_one_coin(\\n        uint256 _token_amount,\\n        uint256 i,\\n        uint256 _min_amount,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function pool() external view returns (address);\\n\\n    function token() external view returns (address);\\n\\n    function coins(uint256 arg0) external view returns (address);\\n}\\n\"},\"ITriPoolZap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\ninterface ITriPoolZap {\\n    function add_liquidity(\\n        address _pool,\\n        uint256[4] memory _deposit_amounts,\\n        uint256 _min_mint_amount\\n    ) external returns (uint256);\\n\\n    function add_liquidity(\\n        address _pool,\\n        uint256[4] memory _deposit_amounts,\\n        uint256 _min_mint_amount,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function remove_liquidity(\\n        address _pool,\\n        uint256 _burn_amount,\\n        uint256[4] memory _min_amounts\\n    ) external returns (uint256[4] memory);\\n\\n    function remove_liquidity(\\n        address _pool,\\n        uint256 _burn_amount,\\n        uint256[4] memory _min_amounts,\\n        address _receiver\\n    ) external returns (uint256[4] memory);\\n\\n    function remove_liquidity_one_coin(\\n        address _pool,\\n        uint256 _burn_amount,\\n        int128 i,\\n        uint256 _min_amount\\n    ) external returns (uint256);\\n\\n    function remove_liquidity_one_coin(\\n        address _pool,\\n        uint256 _burn_amount,\\n        int128 i,\\n        uint256 _min_amount,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function remove_liquidity_imbalance(\\n        address _pool,\\n        uint256[4] memory _amounts,\\n        uint256 _max_burn_amount\\n    ) external returns (uint256);\\n\\n    function remove_liquidity_imbalance(\\n        address _pool,\\n        uint256[4] memory _amounts,\\n        uint256 _max_burn_amount,\\n        address _receiver\\n    ) external returns (uint256);\\n\\n    function calc_withdraw_one_coin(\\n        address _pool,\\n        uint256 _token_amount,\\n        int128 i\\n    ) external view returns (uint256);\\n\\n    function calc_token_amount(\\n        address _pool,\\n        uint256[4] memory _amounts,\\n        bool _is_deposit\\n    ) external view returns (uint256);\\n}\\n\"},\"IUniswapV3Router.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.3;\\n\\ninterface IUniswapV3Router {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    function WETH9() external view returns (address);\\n\\n    function exactInput(ExactInputParams memory params) external payable returns (uint256 amountOut);\\n\\n    function exactInputSingle(ExactInputSingleParams memory params) external returns (uint256 amountOut);\\n\\n    function exactOutput(ExactOutputParams memory params) external returns (uint256 amountIn);\\n\\n    function exactOutputSingle(ExactOutputSingleParams memory params) external returns (uint256 amountIn);\\n\\n    function factory() external view returns (address);\\n\\n    function multicall(bytes[] memory data) external returns (bytes[] memory results);\\n\\n    function refundETH() external;\\n\\n    function selfPermit(\\n        address token,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function selfPermitAllowed(\\n        address token,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function selfPermitAllowedIfNecessary(\\n        address token,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function selfPermitIfNecessary(\\n        address token,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function sweepToken(\\n        address token,\\n        uint256 amountMinimum,\\n        address recipient\\n    ) external;\\n\\n    function sweepTokenWithFee(\\n        address token,\\n        uint256 amountMinimum,\\n        address recipient,\\n        uint256 feeBips,\\n        address feeRecipient\\n    ) external;\\n\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes memory _data\\n    ) external;\\n\\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external;\\n\\n    function unwrapWETH9WithFee(\\n        uint256 amountMinimum,\\n        address recipient,\\n        uint256 feeBips,\\n        address feeRecipient\\n    ) external;\\n}\\n\"},\"IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.3;\\n\\ninterface IWETH {\\n    event Approval(address indexed src, address indexed guy, uint256 wad);\\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\\n    event Deposit(address indexed dst, uint256 wad);\\n    event Withdrawal(address indexed src, uint256 wad);\\n\\n    function name() external view returns (string memory);\\n\\n    function approve(address guy, uint256 wad) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 wad\\n    ) external returns (bool);\\n\\n    function withdraw(uint256 wad) external;\\n\\n    function decimals() external view returns (uint8);\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function deposit() external payable;\\n\\n    function allowance(address, address) external view returns (uint256);\\n}\\n\"},\"IZapperCurveRegistryV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\ninterface IZapperCurveRegistryV2 {\\n    function CurveRegistry() external view returns (address);\\n\\n    function FactoryRegistry() external view returns (address);\\n\\n    function getDepositAddress(address swapAddress) external view returns (address depositAddress);\\n\\n    function getNumTokens(address swapAddress) external view returns (uint256);\\n\\n    function getPoolTokens(address swapAddress) external view returns (address[4] memory poolTokens);\\n\\n    function getSwapAddress(address tokenAddress) external view returns (address swapAddress);\\n\\n    function getTokenAddress(address swapAddress) external view returns (address tokenAddress);\\n\\n    function isBtcPool(address swapAddress) external view returns (bool);\\n\\n    function isCurvePool(address swapAddress) external view returns (bool);\\n\\n    function isEthPool(address swapAddress) external view returns (bool);\\n\\n    function isFactoryPool(address swapAddress) external view returns (bool);\\n\\n    function isMetaPool(address swapAddress) external view returns (bool);\\n\\n    function isOwner() external view returns (bool);\\n\\n    function isUnderlyingToken(address swapAddress, address tokenContractAddress) external view returns (bool, uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function renounceOwnership() external;\\n\\n    function shouldAddUnderlying(address) external view returns (bool);\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function updateDepositAddresses(address[] calldata swapAddresses, address[] calldata _depositAddresses) external;\\n\\n    function updateShouldAddUnderlying(address[] calldata swapAddresses, bool[] calldata addUnderlying) external;\\n\\n    function update_curve_registry() external;\\n\\n    function update_factory_registry() external;\\n\\n    function withdrawTokens(address[] calldata tokens) external;\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_whiteListed\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_approved\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addToWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nCoins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"indexInAmounts\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"inner\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curvePooL\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"convexPooL\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curveLPToken\",\"type\":\"address\"}],\"internalType\":\"struct ConvexStrategist.Deposit\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"depositAndStakeFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"crvSwapTxData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"cvxSwapTxData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"tokenTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curvePooL\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"convexPooL\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curveLPToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"crvAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cvxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nCoins\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"indexInAmounts\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"crvDex\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"cvxDex\",\"type\":\"address\"}],\"internalType\":\"struct ConvexStrategist.Harvest\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"harvestAndDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeFromWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setApprovals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ConvexStrategist","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000300000000000000000000000011111112542d85b3ef69ae05771c2dccff4faa260000000000000000000000001bd435f3c054b6e901b7b108a0ab7617c808677b000000000000000000000000def171fe48cf0115b1d80b88dc8eab59176fee57000000000000000000000000000000000000000000000000000000000000000300000000000000000000000011111112542d85b3ef69ae05771c2dccff4faa26000000000000000000000000b70bc06d2c9bf03b3373799606dc7d39346c06b3000000000000000000000000216b4b4ba9f3e719726886d34a177484278bfcae","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://30d8431004ff43be880bd27bf9542b745f9962a7041f7e525825fa5def9b983a"}]}