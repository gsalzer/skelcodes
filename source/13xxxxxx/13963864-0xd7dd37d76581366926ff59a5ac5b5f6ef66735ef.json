{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/RocRenderer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport './Roc.sol';\\r\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\r\\nimport './Randomize.sol';\\r\\nimport './Trignometry.sol';\\r\\n\\r\\n\\r\\n/**\\r\\n * @title RocRenderer\\r\\n * @notice Renderer for roc-male-gen0\\r\\n * @author Tfs128.eth (@trickerfs128)\\r\\n */\\r\\ncontract RocRenderer {\\r\\n    \\r\\n    using Strings for uint256;\\r\\n    using Strings for uint16;\\r\\n    using Strings for uint8;\\r\\n    using Randomize for Randomize.Random;\\r\\n\\r\\n\\r\\n    Roc public immutable rocContract;\\r\\n    address public immutable  pathsContractAddress;\\r\\n\\r\\n    /** \\r\\n     * @notice constructor\\r\\n     * @param pathsAddress - address of contract which contains paths.\\r\\n     * @param rocMainContractAddress - Roc Main contract address\\r\\n     */\\r\\n    constructor(address pathsAddress, address rocMainContractAddress) {\\r\\n        pathsContractAddress = pathsAddress;\\r\\n        rocContract = Roc(rocMainContractAddress);\\r\\n    }\\r\\n\\r\\n    struct Info {\\r\\n        uint8 facePoints;\\r\\n        uint8 hat;\\r\\n        uint8 glasses;\\r\\n        uint8 moustache;\\r\\n        uint8 race;\\r\\n    }\\r\\n\\r\\n    /** \\r\\n     * @notice render the svg.\\r\\n     * @param tokenId - tokenId\\r\\n     * @param dna - dna\\r\\n     * @return json\\r\\n     */\\r\\n    function render(uint256 tokenId, uint256 dna)\\r\\n        public\\r\\n        view\\r\\n        returns (string memory)\\r\\n    {\\r\\n        Randomize.Random memory random = Randomize.Random({seed: dna,nonce: 0});\\r\\n        Info memory info = Info({\\r\\n            facePoints: uint8(random.next(4, 40)),\\r\\n            hat: uint8(random.next(1,8)), //≈62%\\r\\n            glasses: uint8(random.next(1,10)), //10%\\r\\n            moustache: uint8(random.next(1,9)), //≈%33\\r\\n            race: uint8(random.next(1,4)) //Fency 25% Normal 75%;\\r\\n        });\\r\\n        uint16[] memory charAttributes = _getAttributesValues(info);\\r\\n        bytes memory svg = _getSvg(info,random,charAttributes);\\r\\n        bytes memory metaData = _getMetaData(info,charAttributes,rocContract._child_rem(tokenId));\\r\\n        bytes memory json = abi.encodePacked(\\r\\n            'data:application/json;utf8,{\\\"name\\\":\\\"ROC #',\\r\\n            tokenId.toString(),\\r\\n            '\\\",\\\"image\\\":\\\"data:image/svg+xml;utf8,',\\r\\n            svg,\\r\\n            '\\\",\\\"description\\\":\\\"Rebels On Chain - Male Gen-0\\\",\\\"attributes\\\":[',\\r\\n            metaData,\\r\\n            ']}'\\r\\n            );\\r\\n        return string(json);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice getSvg\\r\\n     */\\r\\n    function _getSvg(\\r\\n        Info memory info,\\r\\n        Randomize.Random memory random,\\r\\n        uint16[] memory charAttributes\\r\\n        )\\r\\n    internal\\r\\n    view\\r\\n    returns (bytes memory)\\r\\n    {\\r\\n        uint256 clrHue = random.next(1,360);\\r\\n        bytes memory facePath = _getFacePath(info,random);\\r\\n        bytes memory background = _getBackground(random,info.race);\\r\\n        (bytes memory face, bytes memory defs) = _getFaceAndDefs(random,info.race,facePath);\\r\\n        bytes memory mouth = _getMouth(random.next(1,4));\\r\\n        bytes memory hat;\\r\\n        bytes memory glasses;\\r\\n        bytes memory moustache;\\r\\n        bytes memory eyes;\\r\\n        bytes memory attributesSvg;\\r\\n        if(info.hat < 6) {\\r\\n            hat = _extractWearable(info.hat,clrHue);\\r\\n        }\\r\\n\\r\\n        if(info.moustache > 6) {\\r\\n            moustache = _extractWearable(info.moustache,clrHue);\\r\\n        }\\r\\n\\r\\n        if(info.glasses == 6) {\\r\\n            glasses = _extractWearable(info.glasses,clrHue);\\r\\n        }\\r\\n        else {\\r\\n            eyes = _getEyes(random);\\r\\n        }\\r\\n\\r\\n        attributesSvg = _getCharAttributesSvg(charAttributes);\\r\\n        bytes memory svg = abi.encodePacked(\\r\\n            \\\"<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 200 200'>\\\",\\r\\n            background,\\r\\n            face,\\r\\n            eyes,\\r\\n            mouth,\\r\\n            moustache,\\r\\n            glasses,\\r\\n            hat,\\r\\n            attributesSvg,\\r\\n            defs,\\r\\n            \\\"</svg>\\\"\\r\\n            );\\r\\n        return svg;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice get path of svg layer stores in a seperate\\r\\n     * @notice contract.\\r\\n     */\\r\\n    function _extractWearable(uint8 index,uint256 clrHue) \\r\\n    internal\\r\\n    view\\r\\n    returns(bytes memory)\\r\\n    {\\r\\n        bytes memory layer;\\r\\n\\r\\n        uint24[3][] memory pathsInfo = _getPathsInfo(index);\\r\\n        for(uint8 i = 0; i < pathsInfo.length; i++) {\\r\\n            uint24 offset = pathsInfo[i][0];\\r\\n            uint24 size = pathsInfo[i][1];\\r\\n            bytes memory path_ = new bytes(size);\\r\\n            address contractAddress = pathsContractAddress;\\r\\n            assembly {\\r\\n                extcodecopy(contractAddress, add(path_, 32), offset, size)\\r\\n            }\\r\\n            bytes memory clr;\\r\\n            uint16 clr1Sat = (index == 6) ? 75 : 100;\\r\\n            uint16 clr1Ligth = (index == 6) ? 40 : 55;\\r\\n            if(pathsInfo[i][2] == 0x000000) {\\r\\n                clr = abi.encodePacked('hsl(',clrHue.toString(),' ',clr1Sat.toString(),'% ',clr1Ligth.toString(),'%)');\\r\\n            }\\r\\n            else if(pathsInfo[i][2] == 0xffffff) {\\r\\n                clr = abi.encodePacked('hsl(',clrHue.toString(),' 78% 50%)');\\r\\n            }\\r\\n            else {\\r\\n                clr = abi.encodePacked('#',_bytes3ToHexBytes(bytes3(pathsInfo[i][2])));\\r\\n            }\\r\\n\\r\\n            if(index == 5 && i == 0) {\\r\\n                layer = abi.encodePacked(layer,\\\"<path fill='\\\",clr,\\\"' stroke='black' d='\\\",path_,\\\"' />\\\");\\r\\n            }\\r\\n            else {\\r\\n                layer = abi.encodePacked(\\r\\n                    layer,\\\"<path fill='\\\",clr,\\\"' d='\\\",path_,\\\"' />\\\");\\r\\n            }\\r\\n        }\\r\\n        bytes memory transform = (index > 1 && index < 6) ? bytes('5') : bytes('0');\\r\\n        layer = abi.encodePacked( \\r\\n            \\\"<g transform='matrix(1,0,0,1,0,\\\",\\r\\n            transform,\\r\\n            \\\")'>\\\",\\r\\n            layer,\\r\\n            \\\"</g>\\\"\\r\\n             );\\r\\n        return layer;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice getMetaData\\r\\n     */\\r\\n    function _getMetaData(\\r\\n        Info memory info,\\r\\n        uint16[] memory charAttributes,\\r\\n        uint256 childRemaining\\r\\n        )\\r\\n    internal\\r\\n    pure\\r\\n    returns(bytes memory metadata) {\\r\\n        string[10] memory names = ['Null','Derby','Beret','Trilby','Witch','Cowboy','Yes','Chevron','Pencil','HandleBar'];\\r\\n        string memory hatName;\\r\\n        string memory glassesName;\\r\\n        string memory moustacheName;\\r\\n        string memory raceName;\\r\\n        hatName = info.hat < 6 ? names[info.hat]: 'No';\\r\\n        glassesName = (info.glasses == 6) ? names[info.glasses] : 'No';\\r\\n        moustacheName = info.moustache > 6 ? names[info.moustache] : 'No';\\r\\n        raceName = info.race == 4 ? 'Fency' : 'Normal';\\r\\n        bytes memory scoreMeta;\\r\\n        {\\r\\n            scoreMeta = abi.encodePacked(\\r\\n            '{\\\"trait_type\\\": \\\"Strength\\\", \\\"value\\\": ',\\r\\n            charAttributes[0].toString(),\\r\\n            '},{\\\"trait_type\\\": \\\"Knowledge\\\", \\\"value\\\": ',\\r\\n            charAttributes[1].toString(),\\r\\n            '},{\\\"trait_type\\\": \\\"Charm\\\", \\\"value\\\": ',\\r\\n            charAttributes[2].toString(),\\r\\n            '},{\\\"trait_type\\\": \\\"Money\\\", \\\"value\\\": ',\\r\\n            charAttributes[3].toString(),\\r\\n            '}'\\r\\n            );\\r\\n        }\\r\\n\\r\\n        metadata = abi.encodePacked(\\r\\n            '{\\\"trait_type\\\": \\\"Childs Remaining\\\", \\\"value\\\": \\\"',\\r\\n            childRemaining.toString(),\\r\\n            '\\\"},{\\\"trait_type\\\": \\\"Hat\\\", \\\"value\\\": \\\"',\\r\\n            hatName,\\r\\n            '\\\"},{\\\"trait_type\\\": \\\"Glasses\\\", \\\"value\\\": \\\"',\\r\\n            glassesName,\\r\\n            '\\\"},{\\\"trait_type\\\": \\\"Moustache\\\", \\\"value\\\": \\\"',\\r\\n            moustacheName,\\r\\n            '\\\"},{\\\"trait_type\\\": \\\"Race\\\", \\\"value\\\": \\\"',\\r\\n            raceName,\\r\\n            '\\\"},{\\\"trait_type\\\": \\\"FacePoints\\\", \\\"value\\\": \\\"',\\r\\n            info.facePoints.toString(),\\r\\n            '\\\"},',\\r\\n            scoreMeta\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice calculate character attributes\\r\\n     */\\r\\n    function _getAttributesValues(Info memory info)\\r\\n    internal\\r\\n    pure\\r\\n    returns (uint16[] memory)\\r\\n    {\\r\\n        uint16 initialPoints = info.facePoints / 2;\\r\\n        //Set initial score based on facepoints.\\r\\n        uint16 knowledge = (20 + initialPoints);\\r\\n        uint16 strength = (20 + initialPoints);\\r\\n        uint16 charm = (40 - initialPoints);\\r\\n        //if race == fency add charm and strength.\\r\\n        if(info.race == 4) {\\r\\n            strength += 5;\\r\\n            charm += 5;\\r\\n        }\\r\\n        //if hat, add knowledge\\r\\n        if(info.hat < 6) {\\r\\n            knowledge += 10;\\r\\n        }\\r\\n        //if glasses, add charm\\r\\n        if(info.glasses == 6) {\\r\\n            knowledge += 10;\\r\\n            charm += 25;\\r\\n            strength += 5;\\r\\n        }\\r\\n        //if moustach, add stregth.\\r\\n        if(info.moustache > 6) {\\r\\n            strength += 15;\\r\\n        }\\r\\n        //if hat,moustach and glasses then add extra score\\r\\n        if(info.hat < 6 && info.glasses == 6 && info.moustache > 6) {\\r\\n            charm += 15;\\r\\n            knowledge += 15;\\r\\n            strength += 15;\\r\\n        }\\r\\n        uint16 money = (strength + knowledge + charm) / 3;\\r\\n        uint16[] memory charAttributes = new uint16[](4);\\r\\n        charAttributes[0] = strength;\\r\\n        charAttributes[1] = knowledge;\\r\\n        charAttributes[2] = charm;\\r\\n        charAttributes[3] = money;\\r\\n        return charAttributes;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice getfacepath by generating random points around circumference\\r\\n     * @notice of a circle and then generating path using spline.\\r\\n     */\\r\\n    function _getFacePath(Info memory info,Randomize.Random memory random)\\r\\n    internal\\r\\n    pure\\r\\n    returns (bytes memory)\\r\\n    {\\r\\n        uint8 z = 4;\\r\\n        uint8 facePoints = info.facePoints;\\r\\n        int256[] memory points = new int256[](facePoints * 2 + 8);\\r\\n        int256 oneAtPrecision = 18446744073709551616;  // 2**64\\r\\n        int256 twoPi = 115904311329233965478; //2pi @ oneAtPrecision\\r\\n        int256 angle = twoPi / int8(facePoints);\\r\\n        for (int8 i = 1; i <= int8(facePoints); i++) {\\r\\n            int8 pull = int8(uint8(random.next(80,100)));\\r\\n            int256 xx = 100 + (Trignometry.cos(i * angle) * 50 * pull) / oneAtPrecision / 100;\\r\\n            int256 yy = 100 + (Trignometry.sin(i * angle) * 50 * pull) / oneAtPrecision / 100;\\r\\n            points[z] = xx;\\r\\n            z++;\\r\\n            points[z] = yy;\\r\\n            z++;\\r\\n        }\\r\\n        points[0] = points[facePoints * 2];\\r\\n        points[1] = points[facePoints * 2 + 1];\\r\\n        points[2] = points[facePoints * 2 + 2];\\r\\n        points[3] = points[facePoints * 2 + 3];\\r\\n        points[facePoints * 2 + 4] = points[4];\\r\\n        points[facePoints * 2 + 5] = points[5];\\r\\n        points[facePoints * 2 + 6] = points[6];\\r\\n        points[facePoints * 2 + 7] = points[7];\\r\\n        return _calculateFacePath(points);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice convert points into svg path.\\r\\n     * @dev https://github.com/georgedoescode/splinejs/blob/main/spline.js\\r\\n     */\\r\\n    function _calculateFacePath(int256[] memory points)\\r\\n    internal\\r\\n    pure\\r\\n    returns (bytes memory)\\r\\n    {\\r\\n        uint256 last = points.length - 4;\\r\\n        uint256 maxIteration = last;\\r\\n        bytes memory path = abi.encodePacked('M',uint256(points[2]).toString(),',',uint256(points[3]).toString());\\r\\n        for (uint256 ii = 2; ii < maxIteration; ii+=2) {\\r\\n           int256[] memory values = new int256[](6);\\r\\n           values[0] = ii != last ? points[ii + 4] : points[ii + 2];\\r\\n           values[1] = ii != last ? points[ii + 5] : points[ii + 3];\\r\\n           values[2] = points[ii + 0] + ((points[ii + 2] - points[ii - 2]) / 6);\\r\\n           values[3] = points[ii + 1] + ((points[ii + 3] - points[ii - 1]) / 6);\\r\\n           values[4] = points[ii + 2] - ((values[0] - points[ii + 0] ) / 6);\\r\\n           values[5] = points[ii + 3] - ((values[1] - points[ii + 1] ) / 6);\\r\\n           path = abi.encodePacked(\\r\\n            path,\\r\\n            'C',\\r\\n            uint256(values[2]).toString(),\\r\\n            ',',\\r\\n            uint256(values[3]).toString(),\\r\\n            ',',\\r\\n            uint256(values[4]).toString(),\\r\\n            ',',\\r\\n            uint256(values[5]).toString(),\\r\\n            ',',\\r\\n            uint256(points[ii + 2]).toString(),\\r\\n            ',',\\r\\n            uint256(points[ii + 3]).toString()\\r\\n            );\\r\\n        }\\r\\n        return path;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice getBackground\\r\\n     */\\r\\n    function _getBackground(Randomize.Random memory random, uint8 race)\\r\\n    internal\\r\\n    pure\\r\\n    returns(bytes memory) {\\r\\n        uint256 lightness = race == 4 ? 10 : 90;\\r\\n        uint256 backgroundClrHue = random.next(1,360);\\r\\n        bytes memory background = abi.encodePacked(\\r\\n            \\\"<rect width='200' height='200' fill='hsl(\\\",\\r\\n            backgroundClrHue.toString(),\\r\\n            \\\" 100% \\\",\\r\\n            lightness.toString(),\\r\\n            \\\"%)' />\\\"\\r\\n            ); \\r\\n        return background;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice getFaceAndDefs\\r\\n     */\\r\\n    function _getFaceAndDefs(Randomize.Random memory random ,uint256 race, bytes memory facePath)\\r\\n    internal\\r\\n    pure\\r\\n    returns(bytes memory face, bytes memory defs)\\r\\n    {\\r\\n        if(race == 4) {\\r\\n            defs = abi.encodePacked(\\r\\n                \\\"<defs>\\\",\\r\\n                \\\"<clipPath id='face'><path d='\\\",\\r\\n                facePath,\\r\\n                \\\"'></path></clipPath></defs>\\\"\\r\\n                );\\r\\n            bytes memory skin = _getSkin(random);\\r\\n            face = abi.encodePacked(\\r\\n                \\\"<g clip-path='url(#face)'>\\\",\\r\\n                skin,\\r\\n                \\\"</g>\\\"\\r\\n                );\\r\\n        }\\r\\n        else {\\r\\n            uint256 hue = random.next(1,360);\\r\\n            uint256 saturation = random.next(75,100);\\r\\n            uint256 lightness = random.next(50,90);\\r\\n            face = abi.encodePacked(\\r\\n                \\\"<path d='\\\",\\r\\n                facePath,\\r\\n                \\\"' stroke-width='0.1' stroke='hsl(\\\",\\r\\n                hue.toString(),\\r\\n                \\\", \\\",\\r\\n                saturation.toString(),\\r\\n                \\\"%, 30%)' fill='hsl(\\\",\\r\\n                hue.toString(),\\r\\n                \\\", \\\",\\r\\n                saturation.toString(),\\r\\n                \\\"%, \\\",\\r\\n                lightness.toString(),\\r\\n                \\\"%)'></path>\\\"\\r\\n                );\\r\\n        }\\r\\n        return (face, defs);\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice get skin by generating random Lines\\r\\n     * @notice and filling with random colors\\r\\n     */\\r\\n    function _getSkin(Randomize.Random memory random)\\r\\n    internal\\r\\n    pure\\r\\n    returns(bytes memory) {\\r\\n        bytes memory lines = abi.encodePacked(\\r\\n            \\\"<rect width='200' height='200' fill='hsl(\\\",\\r\\n            random.next(1, 360).toString(),\\r\\n            \\\" \\\",\\r\\n            random.next(1, 100).toString(),\\r\\n            \\\"% 25%)'></rect>\\\"\\r\\n            );\\r\\n        uint256 totalLines = random.next(2,6);\\r\\n        for(uint i; i <= totalLines; i++) {\\r\\n            uint256[] memory points = new uint256[](8);\\r\\n            points[0] = random.next(1,200);\\r\\n            points[1] = random.next(1,200);\\r\\n            points[2] = random.next(50,150);\\r\\n            points[3] = random.next(50,150);\\r\\n            points[4] = random.next(50,150);\\r\\n            points[5] = random.next(50,150);\\r\\n            points[6] = random.next(1,200);\\r\\n            points[7] = random.next(1,200);\\r\\n            uint256 hue = random.next(1, 360);\\r\\n            uint256 saturation = random.next(75, 100);\\r\\n            uint256 lightness = random.next(50, 90);\\r\\n            bytes memory path = abi.encodePacked(\\r\\n                points[0].toString(),\\r\\n                \\\",\\\",\\r\\n                points[1].toString(),\\r\\n                \\\" \\\",\\r\\n                points[2].toString(),\\r\\n                \\\",\\\",\\r\\n                points[3].toString(),\\r\\n                \\\" \\\",\\r\\n                points[4].toString(),\\r\\n                \\\",\\\",\\r\\n                points[5].toString(),\\r\\n                \\\" S50,150 \\\",\\r\\n                points[7].toString(),\\r\\n                \\\",200'\\\"\\r\\n                );\\r\\n            lines = abi.encodePacked(\\r\\n                lines,\\r\\n                \\\"<path d='M\\\",\\r\\n                points[6].toString(),\\r\\n                \\\",0 C\\\",\\r\\n                path,\\r\\n                \\\" stroke-width='3' fill='hsl(\\\",\\r\\n                hue.toString(),\\r\\n                \\\",\\\",\\r\\n                saturation.toString(),\\r\\n                \\\"%,\\\",\\r\\n                lightness.toString(),\\r\\n                \\\"%)' fill-opacity='0.5'></path>\\\"\\r\\n                );\\r\\n        }\\r\\n        return lines;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice getMouth\\r\\n     */\\r\\n    function _getMouth(uint256 mouthType)\\r\\n    internal\\r\\n    pure\\r\\n    returns(bytes memory)\\r\\n    {\\r\\n        bytes memory mouth = abi.encodePacked(\\r\\n            \\\"<ellipse cx='100' cy='125' rx='20' ry='\\\",\\r\\n            mouthType.toString(),\\r\\n            \\\"' fill='white' stroke='black' stroke-width='2'></ellipse>\\\"\\r\\n            );\\r\\n        return mouth;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice getEyes\\r\\n     */\\r\\n    function _getEyes(Randomize.Random memory random) \\r\\n    internal \\r\\n    pure \\r\\n    returns(bytes memory)\\r\\n    {\\r\\n        uint256 eyeInnerType = random.next(1,2);\\r\\n        uint256 eyePositionX = random.next(1,8); //random (-4,4);\\r\\n        uint256 eyePositionY = random.next(1,10); //random(-5,5);\\r\\n        uint256 circlePostionX = random.next(1,5); //random (-2,3);\\r\\n        bytes memory inner;\\r\\n        bytes memory outer;\\r\\n        bytes memory eyePositionBytesX = eyePositionX < 5 ? abi.encodePacked('-',eyePositionX.toString()) : abi.encodePacked((eyePositionX - 4).toString());\\r\\n        bytes memory eyePositionBytesY = eyePositionY < 6 ? abi.encodePacked('-',eyePositionY.toString()) : abi.encodePacked((eyePositionY - 5).toString());\\r\\n        bytes memory circlePostionBytesX = circlePostionX < 3 ? abi.encodePacked('-',circlePostionX.toString()) : abi.encodePacked((circlePostionX - 2).toString());\\r\\n        if(eyeInnerType == 1) {\\r\\n            inner = \\\"<ellipse rx='7' ry='5' cx='0' cy='0' fill='hsl(315, 87%, 2%)'></ellipse>\\\";\\r\\n        }\\r\\n        else {\\r\\n            inner = abi.encodePacked(\\\"<circle r='\\\",random.next(4,7).toString(),\\\"' cx='0' cy='0' fill='hsl(315, 87%, 2%)'></circle>\\\"\\r\\n                );\\r\\n        }\\r\\n        outer = abi.encodePacked(\\r\\n            \\\"<g transform='matrix(1,0,0,1,\\\",\\r\\n            eyePositionBytesX,\\r\\n            \\\",\\\",\\r\\n            eyePositionBytesY,\\r\\n            \\\")'><ellipse rx='7' ry='5' cx='0' cy='0' fill='hsl(315, 87%, 2%)'></ellipse>\\\",\\r\\n            \\\"<circle r='2' cx='\\\",\\r\\n            circlePostionBytesX,\\r\\n            \\\"' cy='-2' fill='white'></circle></g>\\\"\\r\\n            );\\r\\n        bytes memory eyes = abi.encodePacked(\\r\\n            \\\"<g transform='matrix(1,0,0,1,82.5,90)'><circle r='10' cx='0' cy='0' stroke-width='2' stroke='hsl(315, 87%, 2%)' fill='hsl(315, 87%, 98%)'></circle>\\\",\\r\\n            outer,\\r\\n            \\\"</g><g transform='matrix(1,0,0,1,117.5,90)'><circle r='10' cx='0' cy='0' stroke-width='2' stroke='hsl(315, 87%, 2%)' fill='hsl(315, 87%, 98%)'></circle>\\\",\\r\\n            outer,\\r\\n            \\\"</g>\\\"\\r\\n            );\\r\\n        return eyes;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice get Attributes Svg to display attributes score.\\r\\n     */\\r\\n    function _getCharAttributesSvg(uint16[] memory charAttributes)\\r\\n    internal\\r\\n    pure\\r\\n    returns(bytes memory attributesSvg)\\r\\n    {\\r\\n        attributesSvg = abi.encodePacked(\\r\\n            \\\"<rect x='5' y='150' width='50' height='10' fill='#C2B280' stroke='#C2B280'></rect><text x='7' y='158' font-size='7'>Strength</text><rect x='45' y='150' width='20' height='10' fill='#000' stroke='#C2B280'></rect><text x='50' y='158' font-size='8' fill='#fff'>\\\",\\r\\n            charAttributes[0].toString(),\\r\\n            \\\"</text><rect x='5' y='162' width='50' height='10' fill='#C2B280' stroke='#C2B280'></rect><text x='7' y='170' font-size='7'>Knowledge</text><rect x='45' y='162' width='20' height='10' fill='#000' stroke='#C2B280'></rect><text x='50' y='170' font-size='8' fill='#fff'>\\\",\\r\\n            charAttributes[1].toString(),\\r\\n            \\\"</text><rect x='5' y='174' width='50' height='10' fill='#C2B280' stroke='#C2B280'></rect><text x='7' y='182' font-size='7'>Charm</text><rect x='45' y='174' width='20' height='10' fill='#000' stroke='#C2B280'></rect><text x='50' y='182' font-size='8' fill='#fff'>\\\",\\r\\n            charAttributes[2].toString(),\\r\\n            \\\"</text><rect x='5' y='186' width='50' height='10' fill='#C2B280' stroke='#C2B280'></rect><text x='7' y='194' font-size='7'>Money</text><rect x='45' y='186' width='20' height='10' fill='#000' stroke='#C2B280'></rect><text x='50' y='194' font-size='8' fill='#fff'>\\\",\\r\\n            charAttributes[3].toString(),\\r\\n            \\\"</text>\\\"\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice getPathsInfo\\r\\n     * @dev 0=offset, 1=size, 2=clr\\r\\n     */\\r\\n    function _getPathsInfo(uint8 index)\\r\\n    internal\\r\\n    pure\\r\\n    returns(uint24[3][] memory) {\\r\\n        if(index == 1) {\\r\\n            uint24[3][] memory info = new uint24[3][](6);\\r\\n            info[0] = [uint24(0), uint24(175), 0x000001];\\r\\n            info[1] = [uint24(175), uint24(121), 0x2b2c2d];\\r\\n            info[2] = [uint24(296), uint24(89), 0x2b2c2d];\\r\\n            info[3] = [uint24(385), uint24(117), 0x6a6a6d];\\r\\n            info[4] = [uint24(502), uint24(86), 0x000000];\\r\\n            info[5] = [uint24(588), uint24(63), 0xffffff];\\r\\n            return (info);\\r\\n        }\\r\\n        else if(index == 2) {\\r\\n            uint24[3][] memory info = new uint24[3][](4);\\r\\n            info[0] = [uint24(651), uint24(128), 0x333333];\\r\\n            info[1] = [uint24(779), uint24(209), 0x1e1e1e];\\r\\n            info[2] = [uint24(988), uint24(49), 0x333333];\\r\\n            info[3] = [uint24(1037), uint24(87), 0x474c51];\\r\\n            return (info);\\r\\n        }\\r\\n        else if(index == 3) {\\r\\n            uint24[3][] memory info = new uint24[3][](6);\\r\\n            info[0] = [uint24(1124), uint24(93), 0x303030];\\r\\n            info[1] = [uint24(1217), uint24(36), 0x303030];\\r\\n            info[2] = [uint24(1253), uint24(33), 0x000000];\\r\\n            info[3] = [uint24(1286), uint24(44), 0xffffff];\\r\\n            info[4] = [uint24(1330), uint24(62), 0x000000];\\r\\n            info[5] = [uint24(1392), uint24(90), 0x21201e];\\r\\n            return (info);\\r\\n        }\\r\\n        else if(index == 4) {\\r\\n            uint24[3][] memory info = new uint24[3][](4);\\r\\n            info[0] = [uint24(1482), uint24(139), 0x2b2c2d];\\r\\n            info[1] = [uint24(1621), uint24(183), 0x111111];\\r\\n            info[2] = [uint24(1804), uint24(58), 0x000000];\\r\\n            info[3] = [uint24(1862), uint24(96), 0xffffff];\\r\\n            return (info);\\r\\n        }\\r\\n        else if(index == 5) {\\r\\n            uint24[3][] memory info = new uint24[3][](2);\\r\\n            info[0] = [uint24(1958), uint24(1436), 0x2b2c2d];\\r\\n            info[1] = [uint24(3394), uint24(998), 0x222222];\\r\\n            return (info);\\r\\n        }\\r\\n        else if(index == 6) {\\r\\n            uint24[3][] memory info = new uint24[3][](3);\\r\\n            info[0] = [uint24(4392), uint24(131), 0x272626];\\r\\n            info[1] = [uint24(4523), uint24(420), 0x000000];\\r\\n            info[2] = [uint24(4943), uint24(93), 0xfcfadd];\\r\\n            return (info);\\r\\n        }\\r\\n        else if(index == 7) {\\r\\n            uint24[3][] memory info = new uint24[3][](2);\\r\\n            info[0] = [uint24(5036), uint24(535), 0x1c1c1c];\\r\\n            info[1] = [uint24(5571), uint24(346), 0x848484];\\r\\n            return (info);\\r\\n        }\\r\\n        else if(index == 8) {\\r\\n            uint24[3][] memory info = new uint24[3][](2);\\r\\n            info[0] = [uint24(5917), uint24(484), 0x1c1c1c];\\r\\n            info[1] = [uint24(6401), uint24(488), 0x848484];\\r\\n            return (info);\\r\\n        }\\r\\n        else { //index == 9\\r\\n            uint24[3][] memory info = new uint24[3][](2);\\r\\n            info[0] = [uint24(6889), uint24(734), 0x1c1c1c];\\r\\n            info[1] = [uint24(7623), uint24(315), 0x848484];\\r\\n            return (info);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice bytes3ToHexBytes\\r\\n     */\\r\\n    function _bytes3ToHexBytes(bytes3 _color)\\r\\n    internal\\r\\n    pure\\r\\n    returns (bytes memory)\\r\\n    {\\r\\n        bytes memory numbers = \\\"0123456789ABCDEF\\\";\\r\\n        bytes memory hexBytes = new bytes(6);\\r\\n        uint256 pos;\\r\\n        for (uint256 i; i < 3; i++) {\\r\\n            hexBytes[pos] = numbers[uint8(_color[i] >> 4)];\\r\\n            pos++;\\r\\n            hexBytes[pos] = numbers[uint8(_color[i] & 0x0f)];\\r\\n            pos++;\\r\\n        }\\r\\n        return hexBytes;\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/Roc.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Roc\\r\\n * @author Tfs128.eth (@trickerfs128)\\r\\n */\\r\\ncontract Roc {\\r\\n    mapping(uint256 => uint256) public _child_rem;\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/Randomize.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// small library to get random number\\r\\nlibrary Randomize {\\r\\n    struct Random {\\r\\n        uint256 seed;\\r\\n        uint256 nonce;\\r\\n    }\\r\\n\\r\\n    function next(\\r\\n        Random memory random,\\r\\n        uint256 min,\\r\\n        uint256 max\\r\\n    ) internal pure returns (uint256 result) {\\r\\n        max += 1;\\r\\n        uint256 number = uint256(keccak256(abi.encode(random.seed,random.nonce))) % (max - min);\\r\\n        random.nonce++;\\r\\n        result = number + min;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/Trignometry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @notice library to evaluate sin and cos using expanded taylor series by horner's rule.\\r\\n */\\r\\nlibrary Trignometry {\\r\\n\\r\\n    int256 private constant PRECISION = 64;\\r\\n    int256 private constant ONE_AT_PRECISION = 18446744073709551616; //2**64\\r\\n    int256 private constant PI = 57952155664616982739; // PI * ONE_AT_PRECISION\\r\\n\\r\\n    /**\\r\\n     * @notice evaluate sin(x).\\r\\n     * @dev sin(x) != sin(x + 2pi)\\r\\n     */\\r\\n    function sin(int256 x) internal pure returns(int256) {\\r\\n        int256 value;\\r\\n        assembly {\\r\\n            let xsq := sar(PRECISION, mul(x, x)) // xsq = x^2\\r\\n            let xx := add(51862, sar(PRECISION, mul(xsq, sub(0, 151)))) // b8 = 1/17! + xsq*(-1/19!)\\r\\n            xx := add(sub(0, 14106527), sar(PRECISION, mul(xsq, xx))) // b7 = -1/15! + xsq*b8\\r\\n            xx := add(2962370717, sar(PRECISION, mul(xsq, xx))) // b6 = 1/13! + xsq*b7\\r\\n            xx := add(sub(0, 462129831893), sar(PRECISION, mul(xsq, xx))) // b5 = -1/11! + xsq*b6\\r\\n            xx := add(50834281508238, sar(PRECISION, mul(xsq, xx))) // b4 = 1/9! + xsq*b5\\r\\n            xx := add(sub(0, 3660068268593165), sar(PRECISION, mul(xsq, xx))) // b3 = -1/7! + xsq*b4\\r\\n            xx := add(153722867280912930, sar(PRECISION, mul(xsq, xx))) // b2 = 1/5! + xsq*b3\\r\\n            xx := add(sub(0, 3074457345618258602), sar(PRECISION, mul(xsq, xx))) // b1 = -1/3! + xsq*b2\\r\\n            xx := add(ONE_AT_PRECISION, sar(PRECISION, mul(xsq, xx))) // t = 1 + xsq*b1\\r\\n            xx := sar(PRECISION, mul(xx, x)) // sin(x) = t*x\\r\\n            value := xx\\r\\n           }\\r\\n           return value;\\r\\n       }\\r\\n\\r\\n    /**\\r\\n     * @notice evaluate cos(x)\\r\\n     * @dev cos(x) = sin(90 - x)\\r\\n     */\\r\\n    function cos(int256 x) internal pure returns(int256) {\\r\\n        int256 cx = PI/2 - x;\\r\\n        if(cx < 0) {\\r\\n            return -sin(cx * -1); //sin(-x) = -sin(x)\\r\\n        }\\r\\n        else {\\r\\n            return sin(cx);\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pathsAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rocMainContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"pathsContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dna\",\"type\":\"uint256\"}],\"name\":\"render\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rocContract\",\"outputs\":[{\"internalType\":\"contract Roc\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RocRenderer","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a4790f4a9dee35d4d73d6112a2f24d57ccb57f700000000000000000000000002f56683f5cd026716caa74d021f4eaba285a1449","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}