{"status":"1","message":"OK","result":[{"SourceCode":"// File: iface/IERC20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: iface/IParassetGovernance.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @dev This interface defines the governance methods\r\ninterface IParassetGovernance {\r\n    /// @dev Set governance authority\r\n    /// @param addr Destination address\r\n    /// @param flag Weight. 0 means to delete the governance permission of the target address. Weight is not \r\n    ///        implemented in the current system, only the difference between authorized and unauthorized. \r\n    ///        Here, a uint96 is used to represent the weight, which is only reserved for expansion\r\n    function setGovernance(address addr, uint flag) external;\r\n\r\n    /// @dev Get governance rights\r\n    /// @param addr Destination address\r\n    /// @return Weight. 0 means to delete the governance permission of the target address. Weight is not \r\n    ///        implemented in the current system, only the difference between authorized and unauthorized. \r\n    ///        Here, a uint96 is used to represent the weight, which is only reserved for expansion\r\n    function getGovernance(address addr) external view returns (uint);\r\n\r\n    /// @dev Check whether the target address has governance rights for the given target\r\n    /// @param addr Destination address\r\n    /// @param flag Permission weight. The permission of the target address must be greater than this weight to pass the check\r\n    /// @return True indicates permission\r\n    function checkGovernance(address addr, uint flag) external view returns (bool);\r\n}\r\n// File: ParassetBase.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\ncontract ParassetBase {\r\n\r\n    // Lock flag\r\n    uint256 _locked;\r\n\r\n\t/// @dev To support open-zeppelin/upgrades\r\n    /// @param governance IParassetGovernance implementation contract address\r\n    function initialize(address governance) public virtual {\r\n        require(_governance == address(0), \"Log:ParassetBase!initialize\");\r\n        _governance = governance;\r\n        _locked = 0;\r\n    }\r\n\r\n    /// @dev IParassetGovernance implementation contract address\r\n    address public _governance;\r\n\r\n    /// @dev Rewritten in the implementation contract, for load other contract addresses. Call \r\n    ///      super.update(newGovernance) when overriding, and override method without onlyGovernance\r\n    /// @param newGovernance IParassetGovernance implementation contract address\r\n    function update(address newGovernance) public virtual {\r\n\r\n        address governance = _governance;\r\n        require(governance == msg.sender || IParassetGovernance(governance).checkGovernance(msg.sender, 0), \"Log:ParassetBase:!gov\");\r\n        _governance = newGovernance;\r\n    }\r\n\r\n    /// @dev Uniform accuracy\r\n    /// @param inputToken Initial token\r\n    /// @param inputTokenAmount Amount of token\r\n    /// @param outputToken Converted token\r\n    /// @return stability Amount of outputToken\r\n    function getDecimalConversion(\r\n        address inputToken, \r\n        uint256 inputTokenAmount, \r\n        address outputToken\r\n    ) public view returns(uint256) {\r\n    \tuint256 inputTokenDec = 18;\r\n    \tuint256 outputTokenDec = 18;\r\n    \tif (inputToken != address(0x0)) {\r\n    \t\tinputTokenDec = IERC20(inputToken).decimals();\r\n    \t}\r\n    \tif (outputToken != address(0x0)) {\r\n    \t\toutputTokenDec = IERC20(outputToken).decimals();\r\n    \t}\r\n    \treturn inputTokenAmount * (10**outputTokenDec) / (10**inputTokenDec);\r\n    }\r\n\r\n    //---------modifier------------\r\n\r\n    modifier onlyGovernance() {\r\n        require(IParassetGovernance(_governance).checkGovernance(msg.sender, 0), \"Log:ParassetBase:!gov\");\r\n        _;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_locked == 0, \"Log:ParassetBase:!_locked\");\r\n        _locked = 1;\r\n        _;\r\n        _locked = 0;\r\n    }\r\n}\r\n// File: lib/TransferHelper.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n// File: iface/IPriceController.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface IPriceController {\r\n    /// @dev Get price\r\n    /// @param token mortgage asset address\r\n    /// @param uToken underlying asset address\r\n    /// @param payback return address of excess fee\r\n    /// @return tokenPrice Mortgage asset price(1 ETH = ? token)\r\n    /// @return pTokenPrice PToken price(1 ETH = ? pToken)\r\n    function getPriceForPToken(\r\n    \taddress token, \r\n        address uToken,\r\n        address payback\r\n\t) external payable returns (uint256 tokenPrice, uint256 pTokenPrice);\r\n}\r\n// File: iface/IInsurancePool.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface IInsurancePool {\r\n    \r\n    /// @dev Destroy ptoken, update negative ledger\r\n    /// @param amount quantity destroyed\r\n    function destroyPToken(uint256 amount) external;\r\n\r\n    /// @dev Clear negative books\r\n    function eliminate() external;\r\n}\r\n// File: iface/IParasset.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface IParasset {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function destroy(uint256 amount, address account) external;\r\n    function issuance(uint256 amount, address account) external;\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n// File: MortgagePool.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\ncontract MortgagePool is ParassetBase {\r\n\r\n    Config _config;\r\n    // mortgage asset address => mortgage config\r\n    mapping(address=>MortgageInfo) _mortgageConfig;\r\n    // mortgage asset address => ledger info\r\n    mapping(address=>MortgageLeader) _ledgerList;\r\n    // priceController contract\r\n    IPriceController _query;\r\n    // insurance pool contract\r\n    IInsurancePool _insurancePool;\r\n    // contract base num\r\n    uint256 constant BASE_NUM = 100000;\r\n\r\n    struct MortgageInfo {\r\n        // allow mortgage\r\n        bool mortgageAllow;\r\n        // six digits, 0.75=75000\r\n        uint88 maxRate;\r\n        // six digits, 1.3=130000\r\n        uint80 k;\r\n        // six digits, 0.02=2000\r\n        uint40 r0;\r\n        // liquidation rate 90000=90%\r\n        uint40 liquidateRate;\r\n    }\r\n    struct MortgageLeader {\r\n        // debt data\r\n        PersonalLedger[] ledgerArray;\r\n        // users who have created debt positions(address)\r\n        mapping(address => uint256) accountMapping;\r\n    }\r\n    struct PersonalLedger {\r\n        // amount of mortgaged assets\r\n        uint256 mortgageAssets;\r\n        // amount of debt(PToken,Stability fee not included)      \r\n        uint256 parassetAssets;\r\n        // the block height of the last operation       \r\n        uint160 blockHeight;\r\n        // mortgage rate(Initial mortgage rate,Mortgage rate after the last operation)           \r\n        uint88 rate;\r\n    }\r\n    struct Config {\r\n        // pToken address\r\n        address pTokenAdd;\r\n        // amount of blocks produced in a year            \r\n        uint96 oneYearBlock;\r\n        // underlyingToken address           \r\n        address underlyingTokenAdd;\r\n        // = 0: pause\r\n        // = 1: active\r\n        // = 2: out only  \r\n        uint96 flag;                    \r\n    }\r\n\r\n    event FeeValue(uint256 value);\r\n    event LedgerLog(address mToken, uint256 mTokenAmount, uint256 pTokenAmount, uint256 tokenPrice, uint256 pTokenPrice, uint88 rate);\r\n\r\n    //---------modifier---------\r\n\r\n    modifier whenActive() {\r\n        require(_config.flag == 1, \"Log:MortgagePool:!active\");\r\n        _;\r\n    }\r\n\r\n    modifier outOnly() {\r\n        require(_config.flag != 0, \"Log:MortgagePool:!0\");\r\n        _;\r\n    }\r\n\r\n    //---------view---------\r\n\r\n    /// @dev Calculate the stability fee\r\n    /// @param parassetAssets Amount of debt(PToken,Stability fee not included)\r\n    /// @param blockHeight The block height of the last operation\r\n    /// @param rate Mortgage rate(Initial mortgage rate,Mortgage rate after the last operation)\r\n    /// @param nowRate Current mortgage rate (not including stability fee)\r\n    /// @param r0Value Market base interest rate\r\n    /// @return fee\r\n    function getFee(\r\n        uint256 parassetAssets, \r\n        uint160 blockHeight,\r\n        uint256 rate,\r\n        uint256 nowRate,\r\n        uint40 r0Value\r\n    ) public view returns(uint256) {\r\n        uint256 top = (uint256(2) * (rate + nowRate) + BASE_NUM)\r\n                      * parassetAssets\r\n                      * uint256(r0Value)\r\n                      * (block.number - uint256(blockHeight));\r\n        uint256 bottom = BASE_NUM \r\n                         * BASE_NUM \r\n                         * uint256(_config.oneYearBlock);\r\n        return top / bottom;\r\n    }\r\n\r\n    /// @dev Calculate the mortgage rate\r\n    /// @param mortgageAssets Amount of mortgaged assets\r\n    /// @param parassetAssets Amount of debt\r\n    /// @param tokenPrice Mortgage asset price(1 ETH = ? token)\r\n    /// @param pTokenPrice PToken price(1 ETH = ? pToken)\r\n    /// @return mortgage rate\r\n    function getMortgageRate(\r\n        uint256 mortgageAssets,\r\n        uint256 parassetAssets, \r\n        uint256 tokenPrice, \r\n        uint256 pTokenPrice\r\n    ) public pure returns(uint256) {\r\n        if (mortgageAssets == 0) {\r\n            return 0;\r\n        }\r\n    \treturn parassetAssets * tokenPrice * BASE_NUM / (pTokenPrice * mortgageAssets);\r\n    }\r\n\r\n    /// @dev Get real-time data of the current debt warehouse\r\n    /// @param mortgageToken Mortgage asset address\r\n    /// @param tokenPrice Mortgage asset price(1 ETH = ? token)\r\n    /// @param uTokenPrice Underlying asset price(1 ETH = ? Underlying asset)\r\n    /// @param maxRateNum Maximum mortgage rate\r\n    /// @param owner Debt owner\r\n    /// @return fee Stability fee\r\n    /// @return mortgageRate Real-time mortgage rate(Including stability fee)\r\n    /// @return maxSubM The maximum amount of mortgage assets can be reduced\r\n    /// @return maxAddP Maximum number of coins that can be added\r\n    function getInfoRealTime(\r\n        address mortgageToken,\r\n        uint256 tokenPrice, \r\n        uint256 uTokenPrice,\r\n        uint88 maxRateNum,\r\n        address owner\r\n    ) external view returns(\r\n        uint256 fee, \r\n        uint256 mortgageRate, \r\n        uint256 maxSubM, \r\n        uint256 maxAddP\r\n    ) {\r\n        address mToken = mortgageToken;\r\n        MortgageLeader storage mLedger = _ledgerList[mToken];\r\n        if (mLedger.accountMapping[address(owner)] == 0) {\r\n            return (0,0,0,0);\r\n        }\r\n        PersonalLedger memory pLedger = mLedger.ledgerArray[mLedger.accountMapping[address(owner)] - 1];\r\n        if (pLedger.mortgageAssets == 0 && pLedger.parassetAssets == 0) {\r\n            return (0,0,0,0);\r\n        }\r\n        uint256 pTokenPrice = getDecimalConversion(_config.underlyingTokenAdd, \r\n                                                   uTokenPrice, \r\n                                                   _config.pTokenAdd);\r\n        uint256 tokenPriceAmount = tokenPrice;\r\n        fee = getFee(pLedger.parassetAssets, \r\n                     pLedger.blockHeight, \r\n                     pLedger.rate, \r\n                     getMortgageRate(pLedger.mortgageAssets, pLedger.parassetAssets, tokenPriceAmount, pTokenPrice), \r\n                     _mortgageConfig[mToken].r0);\r\n        mortgageRate = getMortgageRate(pLedger.mortgageAssets, \r\n                                       pLedger.parassetAssets + fee, \r\n                                       tokenPriceAmount, \r\n                                       pTokenPrice);\r\n        uint256 mRateNum = maxRateNum;\r\n        if (mortgageRate >= mRateNum) {\r\n            maxSubM = 0;\r\n            maxAddP = 0;\r\n        } else {\r\n            maxSubM = pLedger.mortgageAssets - (pLedger.parassetAssets * tokenPriceAmount * BASE_NUM / (mRateNum * pTokenPrice));\r\n            maxAddP = pLedger.mortgageAssets * pTokenPrice * mRateNum / (BASE_NUM * tokenPriceAmount) - pLedger.parassetAssets;\r\n        }\r\n    }\r\n    \r\n    /// @dev View debt warehouse data\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param owner debt owner\r\n    /// @return mortgageAssets amount of mortgaged assets\r\n    /// @return parassetAssets amount of debt(PToken,Stability fee not included)\r\n    /// @return blockHeight the block height of the last operation\r\n    /// @return rate Mortgage rate(Initial mortgage rate,Mortgage rate after the last operation)\r\n    /// @return created is it created\r\n    function getLedger(\r\n        address mortgageToken,\r\n        address owner\r\n    ) public view returns(\r\n        uint256 mortgageAssets, \r\n        uint256 parassetAssets, \r\n        uint160 blockHeight,\r\n        uint88 rate,\r\n        bool created\r\n    ) {\r\n        MortgageLeader storage mLedger = _ledgerList[mortgageToken];\r\n        if (mLedger.accountMapping[address(owner)] == 0) {\r\n            return (0,0,0,0,false);\r\n        }\r\n        PersonalLedger memory pLedger = mLedger.ledgerArray[mLedger.accountMapping[address(owner)] - 1];\r\n    \treturn (pLedger.mortgageAssets, \r\n                pLedger.parassetAssets, \r\n                pLedger.blockHeight, \r\n                pLedger.rate,\r\n                true);\r\n    }\r\n\r\n    /// @dev View the insurance pool address\r\n    /// @return insurance pool address\r\n    function getInsurancePool() external view returns(address) {\r\n        return address(_insurancePool);\r\n    }\r\n\r\n    /// @dev View the market base interest rate\r\n    /// @return market base interest rate\r\n    function getR0(address mortgageToken) external view returns(uint40) {\r\n    \treturn _mortgageConfig[mortgageToken].r0;\r\n    }\r\n\r\n    /// @dev View the liquidation rate\r\n    /// @return liquidation rate\r\n    function getLiquidateRate(address mortgageToken) external view returns(uint40) {\r\n    \treturn _mortgageConfig[mortgageToken].liquidateRate;\r\n    }\r\n\r\n    /// @dev View the amount of blocks produced in a year\r\n    /// @return amount of blocks produced in a year\r\n    function getOneYear() external view returns(uint96) {\r\n    \treturn _config.oneYearBlock;\r\n    }\r\n\r\n    /// @dev View the maximum mortgage rate\r\n    /// @param mortgageToken Mortgage asset address\r\n    /// @return maximum mortgage rate\r\n    function getMaxRate(address mortgageToken) external view returns(uint88) {\r\n    \treturn _mortgageConfig[mortgageToken].maxRate;\r\n    }\r\n\r\n    /// @dev View the k value\r\n    /// @param mortgageToken Mortgage asset address\r\n    /// @return k value\r\n    function getK(address mortgageToken) external view returns(uint256) {\r\n        return _mortgageConfig[mortgageToken].k;\r\n    }\r\n\r\n    /// @dev View the priceController contract address\r\n    /// @return priceController contract address\r\n    function getPriceController() external view returns(address) {\r\n        return address(_query);\r\n    }\r\n\r\n    /// @dev View the debt array length\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @return debt array length\r\n    function getLedgerArrayNum(address mortgageToken) external view returns(uint256) {\r\n        return _ledgerList[mortgageToken].ledgerArray.length;\r\n    }\r\n\r\n    /// @dev View the debt index\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param owner debt owner\r\n    /// @return index\r\n    function getLedgerIndex(\r\n        address mortgageToken, \r\n        address owner\r\n    ) external view returns(uint256) {\r\n        MortgageLeader storage mLedger = _ledgerList[mortgageToken];\r\n        return mLedger.accountMapping[address(owner)];\r\n    }\r\n\r\n    /// @dev View the pToken address\r\n    /// @return pToken address\r\n    function getPTokenAddress() external view returns(address) {\r\n        return _config.pTokenAdd;\r\n    }\r\n\r\n    /// @dev View the underlyingToken address\r\n    /// @return underlyingToken address\r\n    function getUnderlyingToken() external view returns(address) {\r\n        return _config.underlyingTokenAdd;\r\n    }\r\n\r\n    /// @dev View the flag num\r\n    /// @return flag num\r\n    function getFlag() external view returns(uint96) {\r\n        return _config.flag;\r\n    }\r\n\r\n    //---------governance----------\r\n\r\n    /// @dev Set mortgage pool parameters\r\n    /// @param pTokenAdd pToken address\r\n    /// @param oneYear number of blocks in a year\r\n    /// @param underlyingTokenAdd underlying asset address\r\n    /// @param flag current state of the contract\r\n    function setConfig(\r\n        address pTokenAdd, \r\n        uint96 oneYear, \r\n        address underlyingTokenAdd, \r\n        uint96 flag\r\n    ) public onlyGovernance {\r\n        _config.pTokenAdd = pTokenAdd;\r\n        _config.oneYearBlock = oneYear;\r\n        _config.underlyingTokenAdd = underlyingTokenAdd;\r\n        _config.flag = flag;\r\n    }\r\n\r\n    /// @dev Set contract status\r\n    /// @param num 0: pause, 1: active, 2: out only\r\n    function setFlag(uint96 num) public onlyGovernance {\r\n        _config.flag = num;\r\n    }\r\n\r\n    /// @dev Allow asset mortgage to generate PToken\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param allow allow mortgage\r\n    function setMortgageAllow(address mortgageToken, bool allow) public onlyGovernance {\r\n    \t_mortgageConfig[mortgageToken].mortgageAllow = allow;\r\n    }\r\n\r\n    /// @dev Set insurance pool contract\r\n    /// @param add insurance pool contract\r\n    function setInsurancePool(address add) public onlyGovernance {\r\n        _insurancePool = IInsurancePool(add);\r\n    }\r\n\r\n    /// @dev Set liquidation rate\r\n    /// @param num liquidation rate, 90000=90%\r\n    function setLiquidateRate(address mortgageToken, uint40 num) public onlyGovernance {\r\n    \t_mortgageConfig[mortgageToken].liquidateRate = num;\r\n    }\r\n\r\n    /// @dev Set market base interest rate\r\n    /// @param num market base interest rate(num = ? * 1 ether)\r\n    function setR0(address mortgageToken, uint40 num) public onlyGovernance {\r\n    \t_mortgageConfig[mortgageToken].r0 = num;\r\n    }\r\n\r\n    /// @dev Set the amount of blocks produced in a year\r\n    /// @param num amount of blocks produced in a year\r\n    function setOneYear(uint96 num) public onlyGovernance {\r\n    \t_config.oneYearBlock = num;\r\n    }\r\n\r\n    /// @dev Set K value\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param num K value\r\n    function setK(address mortgageToken, uint80 num) public onlyGovernance {\r\n        _mortgageConfig[mortgageToken].k = num;\r\n    }\r\n\r\n    /// @dev Set the maximum mortgage rate\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param num maximum mortgage rate(num = ? * 1000)\r\n    function setMaxRate(address mortgageToken, uint88 num) public onlyGovernance {\r\n        _mortgageConfig[mortgageToken].maxRate = num;\r\n    }\r\n\r\n    /// @dev Set priceController contract address\r\n    /// @param add priceController contract address\r\n    function setPriceController(address add) public onlyGovernance {\r\n        _query = IPriceController(add);\r\n    }\r\n\r\n    /// @dev Set the underlying asset and PToken mapping and\r\n    /// @param uToken underlying asset address\r\n    /// @param pToken PToken address\r\n    function setInfo(address uToken, address pToken) public onlyGovernance {\r\n        _config.pTokenAdd = pToken;\r\n        _config.underlyingTokenAdd = uToken;\r\n    }\r\n\r\n    //---------transaction---------\r\n\r\n    /// @dev Mortgage asset casting PToken\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param amount amount of mortgaged assets\r\n    /// @param rate custom mortgage rate\r\n    function coin(\r\n        address mortgageToken,\r\n        uint256 amount, \r\n        uint88 rate\r\n    ) public payable whenActive nonReentrant {\r\n        MortgageInfo memory morInfo = _mortgageConfig[mortgageToken];\r\n    \trequire(morInfo.mortgageAllow, \"Log:MortgagePool:!mortgageAllow\");\r\n        require(rate > 0 && rate <= morInfo.maxRate, \"Log:MortgagePool:rate!=0\");\r\n        require(amount > 0, \"Log:MortgagePool:amount!=0\");\r\n        MortgageLeader storage mLedger = _ledgerList[mortgageToken];\r\n        uint256 ledgerNum = mLedger.accountMapping[msg.sender];\r\n        if (ledgerNum == 0) {\r\n            // create\r\n            mLedger.ledgerArray.push();\r\n            mLedger.accountMapping[msg.sender] = mLedger.ledgerArray.length;\r\n        }\r\n        PersonalLedger storage pLedger = mLedger.ledgerArray[mLedger.accountMapping[msg.sender] - 1];\r\n        uint256 parassetAssets = pLedger.parassetAssets;\r\n        uint256 mortgageAssets = pLedger.mortgageAssets;\r\n\r\n    \t// Get the price and transfer to the mortgage token\r\n        uint256 tokenPrice;\r\n        uint256 pTokenPrice;\r\n        if (mortgageToken != address(0x0)) {\r\n            TransferHelper.safeTransferFrom(mortgageToken, msg.sender, address(this), amount);\r\n            (tokenPrice, pTokenPrice) = getPriceForPToken(mortgageToken, msg.value);\r\n        } else {\r\n            require(msg.value >= amount, \"Log:MortgagePool:!msg.value\");\r\n            (tokenPrice, pTokenPrice) = getPriceForPToken(mortgageToken, uint256(msg.value) - amount);\r\n        }\r\n\r\n        // Calculate the stability fee\r\n        transferFee(pLedger, tokenPrice, pTokenPrice, morInfo.r0);\r\n\r\n        // Additional PToken issuance\r\n        uint256 pTokenAmount = amount * pTokenPrice * rate / (tokenPrice * BASE_NUM);\r\n        IParasset(_config.pTokenAdd).issuance(pTokenAmount, msg.sender);\r\n\r\n        // Update debt information\r\n        pLedger.mortgageAssets = mortgageAssets + amount;\r\n        pLedger.parassetAssets = parassetAssets + pTokenAmount;\r\n        pLedger.blockHeight = uint160(block.number);\r\n        pLedger.rate = uint88(getMortgageRate(pLedger.mortgageAssets, pLedger.parassetAssets, tokenPrice, pTokenPrice));\r\n        emit LedgerLog(mortgageToken, pLedger.mortgageAssets, pLedger.parassetAssets, tokenPrice, pTokenPrice, pLedger.rate);\r\n    }\r\n\r\n    /// @dev Increase mortgage assets\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param amount amount of mortgaged assets\r\n    function supplement(address mortgageToken, uint256 amount) public payable outOnly nonReentrant {\r\n        MortgageInfo memory morInfo = _mortgageConfig[mortgageToken];\r\n    \trequire(morInfo.mortgageAllow, \"Log:MortgagePool:!mortgageAllow\");\r\n        require(amount > 0, \"Log:MortgagePool:!amount\");\r\n        MortgageLeader storage mLedger = _ledgerList[mortgageToken];\r\n        uint256 ledgerNum = mLedger.accountMapping[msg.sender];\r\n        if (ledgerNum == 0) {\r\n            // create\r\n            mLedger.ledgerArray.push();\r\n            mLedger.accountMapping[msg.sender] = mLedger.ledgerArray.length;\r\n        }\r\n        PersonalLedger storage pLedger = mLedger.ledgerArray[mLedger.accountMapping[msg.sender] - 1];\r\n        uint256 parassetAssets = pLedger.parassetAssets;\r\n        uint256 mortgageAssets = pLedger.mortgageAssets;\r\n\r\n    \t// Get the price and transfer to the mortgage token\r\n        uint256 tokenPrice;\r\n        uint256 pTokenPrice;\r\n        if (mortgageToken != address(0x0)) {\r\n            TransferHelper.safeTransferFrom(mortgageToken, msg.sender, address(this), amount);\r\n            (tokenPrice, pTokenPrice) = getPriceForPToken(mortgageToken, msg.value);\r\n        } else {\r\n            require(msg.value >= amount, \"Log:MortgagePool:!msg.value\");\r\n            (tokenPrice, pTokenPrice) = getPriceForPToken(mortgageToken, uint256(msg.value) - amount);\r\n        }\r\n\r\n        // Calculate the stability fee\r\n        transferFee(pLedger, tokenPrice, pTokenPrice, morInfo.r0);\r\n\r\n        // Update debt information\r\n    \tpLedger.mortgageAssets = mortgageAssets + amount;\r\n    \tpLedger.blockHeight = uint160(block.number);\r\n        pLedger.rate = uint88(getMortgageRate(pLedger.mortgageAssets, parassetAssets, tokenPrice, pTokenPrice));\r\n        emit LedgerLog(mortgageToken, pLedger.mortgageAssets, pLedger.parassetAssets, tokenPrice, pTokenPrice, pLedger.rate);\r\n    }\r\n\r\n    /// @dev Reduce mortgage assets\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param amount amount of mortgaged assets\r\n    function decrease(address mortgageToken, uint256 amount) public payable outOnly nonReentrant {\r\n        MortgageInfo memory morInfo = _mortgageConfig[mortgageToken];\r\n    \trequire(morInfo.mortgageAllow, \"Log:MortgagePool:!mortgageAllow\");\r\n        MortgageLeader storage mLedger = _ledgerList[mortgageToken];\r\n        uint256 ledgerNum = mLedger.accountMapping[msg.sender];\r\n        require(ledgerNum != 0, \"Log:MortgagePool:index=0\");\r\n        PersonalLedger storage pLedger = mLedger.ledgerArray[ledgerNum - 1];\r\n        uint256 parassetAssets = pLedger.parassetAssets;\r\n        uint256 mortgageAssets = pLedger.mortgageAssets;\r\n        require(amount > 0 && amount <= mortgageAssets, \"Log:MortgagePool:!amount\");\r\n\r\n    \t// Get the price\r\n        (uint256 tokenPrice, uint256 pTokenPrice) = getPriceForPToken(mortgageToken, msg.value);\r\n\r\n        // Calculate the stability fee\r\n        transferFee(pLedger, tokenPrice, pTokenPrice, morInfo.r0);\r\n\r\n        // Update debt information\r\n    \tpLedger.mortgageAssets = mortgageAssets - amount;\r\n    \tpLedger.blockHeight = uint160(block.number);\r\n        if (pLedger.mortgageAssets == 0) {\r\n            require(pLedger.parassetAssets == 0, \"Log:MortgagePool:!parassetAssets\");\r\n            pLedger.rate == 0;\r\n        } else {\r\n            uint256 newRate = getMortgageRate(pLedger.mortgageAssets, parassetAssets, tokenPrice, pTokenPrice);\r\n            // The debt warehouse mortgage rate cannot be greater than the maximum mortgage rate\r\n    \t    require(newRate <= uint256(morInfo.maxRate), \"Log:MortgagePool:!maxRate\");\r\n            pLedger.rate = uint88(newRate);\r\n        }\r\n        emit LedgerLog(mortgageToken, pLedger.mortgageAssets, pLedger.parassetAssets, tokenPrice, pTokenPrice, pLedger.rate);\r\n\r\n    \t// Transfer out mortgage assets\r\n    \tif (mortgageToken != address(0x0)) {\r\n            TransferHelper.safeTransfer(mortgageToken, msg.sender, amount);\r\n    \t} else {\r\n            TransferHelper.safeTransferETH(msg.sender, amount);\r\n    \t}\r\n    }\r\n\r\n    /// @dev Increase debt (increase coinage)\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param amount amount of debt\r\n    function increaseCoinage(address mortgageToken, uint256 amount) public payable whenActive nonReentrant {\r\n        MortgageInfo memory morInfo = _mortgageConfig[mortgageToken];\r\n        require(morInfo.mortgageAllow, \"Log:MortgagePool:!mortgageAllow\");\r\n        require(amount > 0, \"Log:MortgagePool:!amount\");\r\n        MortgageLeader storage mLedger = _ledgerList[mortgageToken];\r\n        uint256 ledgerNum = mLedger.accountMapping[msg.sender];\r\n        require(ledgerNum != 0, \"Log:MortgagePool:index=0\");\r\n        PersonalLedger storage pLedger = mLedger.ledgerArray[ledgerNum - 1];\r\n        uint256 parassetAssets = pLedger.parassetAssets;\r\n        uint256 mortgageAssets = pLedger.mortgageAssets;\r\n        require(mortgageAssets > 0, \"Log:MortgagePool:!mortgageAssets\");\r\n\r\n        // Get the price\r\n        (uint256 tokenPrice, uint256 pTokenPrice) = getPriceForPToken(mortgageToken, msg.value);\r\n\r\n        // Calculate the stability fee\r\n        transferFee(pLedger, tokenPrice, pTokenPrice, morInfo.r0);\r\n\r\n        // Update debt information\r\n        pLedger.parassetAssets = parassetAssets + amount;\r\n        pLedger.blockHeight = uint160(block.number);\r\n        uint256 newRate = getMortgageRate(mortgageAssets, pLedger.parassetAssets, tokenPrice, pTokenPrice);\r\n        // The debt warehouse mortgage rate cannot be greater than the maximum mortgage rate\r\n        require(newRate <= uint256(morInfo.maxRate), \"Log:MortgagePool:!maxRate\");\r\n        pLedger.rate = uint88(newRate);\r\n        emit LedgerLog(mortgageToken, pLedger.mortgageAssets, pLedger.parassetAssets, tokenPrice, pTokenPrice, pLedger.rate);\r\n\r\n        // Additional PToken issuance\r\n        IParasset(_config.pTokenAdd).issuance(amount, msg.sender);\r\n    }\r\n\r\n    /// @dev Reduce debt (increase coinage)\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param amount amount of debt\r\n    function reducedCoinage(address mortgageToken, uint256 amount) public payable outOnly nonReentrant {\r\n        MortgageInfo memory morInfo = _mortgageConfig[mortgageToken];\r\n        require(morInfo.mortgageAllow, \"Log:MortgagePool:!mortgageAllow\");\r\n        MortgageLeader storage mLedger = _ledgerList[mortgageToken];\r\n        uint256 ledgerNum = mLedger.accountMapping[msg.sender];\r\n        require(ledgerNum != 0, \"Log:MortgagePool:index=0\");\r\n        PersonalLedger storage pLedger = mLedger.ledgerArray[ledgerNum - 1];\r\n        uint256 parassetAssets = pLedger.parassetAssets;\r\n        uint256 mortgageAssets = pLedger.mortgageAssets;\r\n        require(amount > 0 && amount <= parassetAssets, \"Log:MortgagePool:!amount\");\r\n\r\n        // Get the price\r\n        (uint256 tokenPrice, uint256 pTokenPrice) = getPriceForPToken(mortgageToken, msg.value);\r\n\r\n        // Calculate the stability fee\r\n        transferFee(pLedger, tokenPrice, pTokenPrice, morInfo.r0);\r\n\r\n        // Update debt information\r\n        pLedger.parassetAssets = parassetAssets - amount;\r\n        pLedger.blockHeight = uint160(block.number);\r\n        pLedger.rate = uint88(getMortgageRate(mortgageAssets, pLedger.parassetAssets, tokenPrice, pTokenPrice));\r\n        emit LedgerLog(mortgageToken, pLedger.mortgageAssets, pLedger.parassetAssets, tokenPrice, pTokenPrice, pLedger.rate);\r\n\r\n        TransferHelper.safeTransferFrom(_config.pTokenAdd, \r\n                                        msg.sender, \r\n                                        address(this), \r\n                                        amount);\r\n        // Destroy PToken\r\n        IParasset(_config.pTokenAdd).destroy(amount, address(this));\r\n    }\r\n\r\n    /// @dev Liquidation of debt\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param account debt owner address\r\n    /// @param amount amount of mortgaged assets\r\n    /// @param pTokenAmountLimit pay PToken limit\r\n    function liquidation(\r\n        address mortgageToken,\r\n        address account,\r\n        uint256 amount,\r\n        uint256 pTokenAmountLimit\r\n    ) public payable outOnly nonReentrant {\r\n        MortgageInfo memory morInfo = _mortgageConfig[mortgageToken];\r\n    \trequire(morInfo.mortgageAllow, \"Log:MortgagePool:!mortgageAllow\");\r\n        MortgageLeader storage mLedger = _ledgerList[mortgageToken];\r\n        uint256 ledgerNum = mLedger.accountMapping[address(account)];\r\n        require(ledgerNum != 0, \"Log:MortgagePool:index=0\");\r\n        PersonalLedger storage pLedger = mLedger.ledgerArray[ledgerNum - 1];\r\n        uint256 parassetAssets = pLedger.parassetAssets;\r\n        uint256 mortgageAssets = pLedger.mortgageAssets;\r\n        require(amount > 0 && amount <= mortgageAssets, \"Log:MortgagePool:!amount\");\r\n\r\n    \t// Get the price\r\n    \t(uint256 tokenPrice, uint256 pTokenPrice) = getPriceForPToken(mortgageToken, msg.value);\r\n        \r\n        // Judging the liquidation line\r\n        _checkLine(pLedger, tokenPrice, pTokenPrice, morInfo.k, morInfo.r0);\r\n\r\n        // Calculate the amount of PToken\r\n        uint256 pTokenAmount = amount * pTokenPrice * uint256(morInfo.liquidateRate) / (tokenPrice * BASE_NUM);\r\n    \t// Transfer to PToken\r\n        require(pTokenAmount <= pTokenAmountLimit, \"Log:MortgagePool:!pTokenAmountLimit\");\r\n        TransferHelper.safeTransferFrom(_config.pTokenAdd, msg.sender, address(_insurancePool), pTokenAmount);\r\n\r\n        // Calculate the debt for destruction\r\n        uint256 offset = parassetAssets * amount / mortgageAssets;\r\n\r\n        // Destroy PToken\r\n    \t_insurancePool.destroyPToken(offset);\r\n\r\n    \t// Update debt information\r\n    \tpLedger.mortgageAssets = mortgageAssets - amount;\r\n        pLedger.parassetAssets = parassetAssets - offset;\r\n        emit LedgerLog(mortgageToken, pLedger.mortgageAssets, pLedger.parassetAssets, tokenPrice, pTokenPrice, pLedger.rate);\r\n\r\n        // MortgageAssets liquidation, mortgage rate and block number are not updated\r\n        if (pLedger.mortgageAssets == 0) {\r\n            pLedger.parassetAssets = 0;\r\n            pLedger.blockHeight = 0;\r\n            pLedger.rate = 0;\r\n        }\r\n\r\n    \t// Transfer out mortgage asset\r\n    \tif (mortgageToken != address(0x0)) {\r\n            TransferHelper.safeTransfer(mortgageToken, msg.sender, amount);\r\n    \t} else {\r\n            TransferHelper.safeTransferETH(msg.sender, amount);\r\n    \t}\r\n    }\r\n\r\n    /// @dev Check the liquidation line\r\n    /// @param pLedger debt warehouse ledger\r\n    /// @param tokenPrice Mortgage asset price(1 ETH = ? token)\r\n    /// @param pTokenPrice PToken price(1 ETH = ? pToken)\r\n    function _checkLine(\r\n        PersonalLedger memory pLedger, \r\n        uint256 tokenPrice, \r\n        uint256 pTokenPrice, \r\n        uint80 kValue,\r\n        uint40 r0Value\r\n    ) public view {\r\n        uint256 parassetAssets = pLedger.parassetAssets;\r\n        uint256 mortgageAssets = pLedger.mortgageAssets;\r\n\r\n        // The current mortgage rate cannot exceed the liquidation line\r\n        uint256 mortgageRate = getMortgageRate(pLedger.mortgageAssets, parassetAssets, tokenPrice, pTokenPrice);\r\n        uint256 fee = 0;\r\n        uint160 blockHeight = pLedger.blockHeight;\r\n        if (parassetAssets > 0 && block.number > uint256(blockHeight) && blockHeight != 0) {\r\n            fee = getFee(parassetAssets, blockHeight, pLedger.rate, mortgageRate, r0Value);\r\n        }\r\n        require(((parassetAssets + fee) * uint256(kValue) * tokenPrice / (mortgageAssets * BASE_NUM)) > pTokenPrice, \"Log:MortgagePool:!liquidationLine\");\r\n    }\r\n\r\n    function transferFee(\r\n        PersonalLedger memory pLedger, \r\n        uint256 tokenPrice, \r\n        uint256 pTokenPrice, \r\n        uint40 r0Value\r\n    ) private {\r\n        uint256 parassetAssets = pLedger.parassetAssets;\r\n        uint256 mortgageAssets = pLedger.mortgageAssets;\r\n        uint256 rate = pLedger.rate;\r\n        uint160 blockHeight = pLedger.blockHeight;\r\n        if (parassetAssets > 0 && block.number > uint256(blockHeight) && blockHeight != 0) {\r\n            uint256 fee = getFee(parassetAssets, \r\n                                 blockHeight, \r\n                                 rate, \r\n                                 getMortgageRate(mortgageAssets, parassetAssets, tokenPrice, pTokenPrice), \r\n                                 r0Value);\r\n\r\n            // The stability fee is transferred to the insurance pool\r\n            TransferHelper.safeTransferFrom(_config.pTokenAdd, \r\n                                            msg.sender, \r\n                                            address(_insurancePool), \r\n                                            fee);\r\n\r\n            // Eliminate negative accounts\r\n            _insurancePool.eliminate();\r\n            emit FeeValue(fee);\r\n        }\r\n    }\r\n\r\n    /// @dev Get price\r\n    /// @param mortgageToken mortgage asset address\r\n    /// @param priceValue price fee\r\n    /// @return tokenPrice Mortgage asset price(1 ETH = ? token)\r\n    /// @return pTokenPrice PToken price(1 ETH = ? pToken)\r\n    function getPriceForPToken(\r\n        address mortgageToken,\r\n        uint256 priceValue\r\n    ) private returns (\r\n        uint256 tokenPrice, \r\n        uint256 pTokenPrice\r\n    ) {\r\n        (tokenPrice, pTokenPrice) = _query.getPriceForPToken{value:priceValue}(mortgageToken, \r\n                                                                               _config.underlyingTokenAdd,\r\n                                                                               msg.sender);   \r\n    }\r\n\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FeeValue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pTokenPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint88\",\"name\":\"rate\",\"type\":\"uint88\"}],\"name\":\"LedgerLog\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"mortgageAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parassetAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"blockHeight\",\"type\":\"uint160\"},{\"internalType\":\"uint88\",\"name\":\"rate\",\"type\":\"uint88\"}],\"internalType\":\"struct MortgagePool.PersonalLedger\",\"name\":\"pLedger\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"kValue\",\"type\":\"uint80\"},{\"internalType\":\"uint40\",\"name\":\"r0Value\",\"type\":\"uint40\"}],\"name\":\"_checkLine\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint88\",\"name\":\"rate\",\"type\":\"uint88\"}],\"name\":\"coin\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decrease\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"}],\"name\":\"getDecimalConversion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"parassetAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"blockHeight\",\"type\":\"uint160\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nowRate\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"r0Value\",\"type\":\"uint40\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFlag\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint88\",\"name\":\"maxRateNum\",\"type\":\"uint88\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getInfoRealTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mortgageRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubM\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAddP\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInsurancePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"}],\"name\":\"getK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getLedger\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mortgageAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parassetAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"blockHeight\",\"type\":\"uint160\"},{\"internalType\":\"uint88\",\"name\":\"rate\",\"type\":\"uint88\"},{\"internalType\":\"bool\",\"name\":\"created\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"}],\"name\":\"getLedgerArrayNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getLedgerIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"}],\"name\":\"getLiquidateRate\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"}],\"name\":\"getMaxRate\",\"outputs\":[{\"internalType\":\"uint88\",\"name\":\"\",\"type\":\"uint88\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mortgageAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parassetAssets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pTokenPrice\",\"type\":\"uint256\"}],\"name\":\"getMortgageRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOneYear\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriceController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"}],\"name\":\"getR0\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnderlyingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseCoinage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pTokenAmountLimit\",\"type\":\"uint256\"}],\"name\":\"liquidation\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reducedCoinage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pTokenAdd\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"oneYear\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"underlyingTokenAdd\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"flag\",\"type\":\"uint96\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"num\",\"type\":\"uint96\"}],\"name\":\"setFlag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pToken\",\"type\":\"address\"}],\"name\":\"setInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"setInsurancePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"uint80\",\"name\":\"num\",\"type\":\"uint80\"}],\"name\":\"setK\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"num\",\"type\":\"uint40\"}],\"name\":\"setLiquidateRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"uint88\",\"name\":\"num\",\"type\":\"uint88\"}],\"name\":\"setMaxRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allow\",\"type\":\"bool\"}],\"name\":\"setMortgageAllow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"num\",\"type\":\"uint96\"}],\"name\":\"setOneYear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"setPriceController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"num\",\"type\":\"uint40\"}],\"name\":\"setR0\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mortgageToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"supplement\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MortgagePool","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"6666","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://bda530618e071a1b38c57673b6cbefade4497b748d2648623e0640602bda01fb"}]}