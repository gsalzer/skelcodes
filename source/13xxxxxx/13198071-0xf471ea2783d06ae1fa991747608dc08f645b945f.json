{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\ninterface Token {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n// MerkleDistributor for ongoing EPS airdrop to veCRV holders\r\n// Based on the EMN refund contract by banteg - https://github.com/banteg/your-eminence\r\ncontract MerkleDistributor {\r\n\r\n    bytes32[] public merkleRoots;\r\n    bytes32 public pendingMerkleRoot;\r\n    uint256 public lastRoot;\r\n\r\n    // admin address which can propose adding a new merkle root\r\n    address public proposalAuthority;\r\n    // admin address which approves or rejects a proposed merkle root\r\n    address public reviewAuthority;\r\n\r\n    event Claimed(\r\n        uint256 merkleIndex,\r\n        uint256 index,\r\n        address account,\r\n        uint256 amount\r\n    );\r\n\r\n    // This is a packed array of booleans.\r\n    mapping(uint256 => mapping(uint256 => uint256)) private claimedBitMap;\r\n    Token public tokenContract;\r\n\r\n    constructor(address _authority, Token _tokenContract) {\r\n        proposalAuthority = _authority;\r\n        reviewAuthority = _authority;\r\n        tokenContract = _tokenContract;\r\n    }\r\n\r\n    function setProposalAuthority(address _account) public {\r\n        require(msg.sender == proposalAuthority);\r\n        proposalAuthority = _account;\r\n    }\r\n\r\n    function setReviewAuthority(address _account) public {\r\n        require(msg.sender == reviewAuthority);\r\n        reviewAuthority = _account;\r\n    }\r\n\r\n    // Each week, the proposal authority calls to submit the merkle root for a new airdrop.\r\n    function proposewMerkleRoot(bytes32 _merkleRoot) public {\r\n        require(msg.sender == proposalAuthority);\r\n        require(pendingMerkleRoot == 0x00);\r\n        require(merkleRoots.length < 52);\r\n        // require(block.timestamp > lastRoot + 604800);\r\n        pendingMerkleRoot = _merkleRoot;\r\n    }\r\n\r\n    // After validating the correctness of the pending merkle root, the reviewing authority\r\n    // calls to confirm it and the distribution may begin.\r\n    function reviewPendingMerkleRoot(bool _approved) public {\r\n        require(msg.sender == reviewAuthority);\r\n        require(pendingMerkleRoot != 0x00);\r\n        if (_approved) {\r\n            merkleRoots.push(pendingMerkleRoot);\r\n            lastRoot = block.timestamp / 604800 * 604800;\r\n        }\r\n        delete pendingMerkleRoot;\r\n    }\r\n\r\n    function isClaimed(uint256 merkleIndex, uint256 index) public view returns (bool) {\r\n        uint256 claimedWordIndex = index / 256;\r\n        uint256 claimedBitIndex = index % 256;\r\n        uint256 claimedWord = claimedBitMap[merkleIndex][claimedWordIndex];\r\n        uint256 mask = (1 << claimedBitIndex);\r\n        return claimedWord & mask == mask;\r\n    }\r\n\r\n    function _setClaimed(uint256 merkleIndex, uint256 index) private {\r\n        uint256 claimedWordIndex = index / 256;\r\n        uint256 claimedBitIndex = index % 256;\r\n        claimedBitMap[merkleIndex][claimedWordIndex] = claimedBitMap[merkleIndex][claimedWordIndex] | (1 << claimedBitIndex);\r\n    }\r\n\r\n    function claim(uint256 merkleIndex, uint256 index, uint256 amount, bytes32[] calldata merkleProof) external {\r\n        require(merkleIndex < merkleRoots.length, \"MerkleDistributor: Invalid merkleIndex\");\r\n        require(!isClaimed(merkleIndex, index), 'MerkleDistributor: Drop already claimed.');\r\n\r\n        // Verify the merkle proof.\r\n        bytes32 node = keccak256(abi.encodePacked(index, msg.sender, amount));\r\n        require(verify(merkleProof, merkleRoots[merkleIndex], node), 'MerkleDistributor: Invalid proof.');\r\n\r\n        // Mark it claimed and send the token.\r\n        _setClaimed(merkleIndex, index);\r\n        tokenContract.transfer(msg.sender, amount  * (10**18));\r\n\r\n        emit Claimed(merkleIndex, index, msg.sender, amount);\r\n    }\r\n\r\n    function verify(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authority\",\"type\":\"address\"},{\"internalType\":\"contract Token\",\"name\":\"_tokenContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"merkleIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRoot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"merkleRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalAuthority\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"proposewMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reviewAuthority\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"reviewPendingMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"setProposalAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"setReviewAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"internalType\":\"contract Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MerkleDistributor","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000f459b83f676467e55ed557a45b1e64569450f0510000000000000000000000006a55b1105497ce7939349f83cfe8b966845b1eb8","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e8053f489146c69ef1dc902966d91b9e8cacc17d128c399f7ef0f7bfe481b0eb"}]}