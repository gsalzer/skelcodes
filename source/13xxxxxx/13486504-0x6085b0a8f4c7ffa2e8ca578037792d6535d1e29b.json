{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/external/adapters/ChainlinkAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\nimport \\\"../../math/SafeInt256.sol\\\";\\nimport \\\"interfaces/chainlink/AggregatorV2V3Interface.sol\\\";\\n\\ncontract ChainlinkAdapter is AggregatorV2V3Interface {\\n    using SafeInt256 for int256;\\n    uint8 public override constant decimals = 18;\\n    uint256 public override constant version = 1;\\n    int256 public constant rateDecimals = 10**18;\\n\\n    string public override description;\\n    AggregatorV2V3Interface public immutable baseToUSDOracle;\\n    int256 public immutable baseToUSDDecimals;\\n    AggregatorV2V3Interface public immutable quoteToUSDOracle;\\n    int256 public immutable quoteToUSDDecimals;\\n\\n    constructor (\\n        AggregatorV2V3Interface baseToUSDOracle_,\\n        AggregatorV2V3Interface quoteToUSDOracle_,\\n        string memory description_\\n    ) {\\n        description = description_;\\n        baseToUSDOracle = baseToUSDOracle_;\\n        quoteToUSDOracle = quoteToUSDOracle_;\\n        baseToUSDDecimals = int256(10**baseToUSDOracle_.decimals());\\n        quoteToUSDDecimals = int256(10**quoteToUSDOracle_.decimals());\\n    }\\n\\n    function _calculateBaseToQuote() internal view returns (\\n        uint80 roundId,\\n        int256 answer,\\n        uint256 startedAt,\\n        uint256 updatedAt,\\n        uint80 answeredInRound\\n    ) {\\n        int256 baseToUSD;\\n        (\\n            roundId,\\n            baseToUSD,\\n            startedAt,\\n            updatedAt,\\n            answeredInRound\\n        ) = baseToUSDOracle.latestRoundData();\\n        require(baseToUSD > 0, \\\"Chainlink Rate Error\\\");\\n        (\\n            /* roundId */,\\n            int256 quoteToUSD,\\n            /* uint256 startedAt */,\\n            /* updatedAt */,\\n            /* answeredInRound */\\n        ) = quoteToUSDOracle.latestRoundData();\\n        require(quoteToUSD > 0, \\\"Chainlink Rate Error\\\");\\n\\n        // To convert from USDC/USD (base) and ETH/USD (quote) to USDC/ETH we do:\\n        // (USDC/USD * quoteDecimals * 1e18) / (ETH/USD * baseDecimals)\\n        answer = baseToUSD\\n            .mul(quoteToUSDDecimals)\\n            .mul(rateDecimals)\\n            .div(quoteToUSD)\\n            .div(baseToUSDDecimals);\\n    }\\n\\n    function latestRoundData() external view override returns (\\n        uint80 roundId,\\n        int256 answer,\\n        uint256 startedAt,\\n        uint256 updatedAt,\\n        uint80 answeredInRound\\n    ) {\\n        return _calculateBaseToQuote();\\n    }\\n\\n    function latestAnswer() external view override returns (int256 answer) {\\n        (/* */, answer, /* */, /* */, /* */) = _calculateBaseToQuote();\\n    }\\n\\n    function latestTimestamp() external view override returns (uint256 updatedAt) {\\n        (/* */, /* */, /* */, updatedAt, /* */) = _calculateBaseToQuote();\\n    }\\n\\n    function latestRound() external view override returns (uint256 roundId) {\\n        (roundId, /* */, /* */, /* */, /* */) = _calculateBaseToQuote();\\n    }\\n\\n    function getRoundData(uint80 _roundId) external view override returns (\\n        uint80 roundId,\\n        int256 answer,\\n        uint256 startedAt,\\n        uint256 updatedAt,\\n        uint80 answeredInRound\\n    ) {\\n        revert();\\n    }\\n\\n    function getAnswer(uint256 roundId) external view override returns (int256) { revert(); }\\n    function getTimestamp(uint256 roundId) external view override returns (uint256) { revert(); }\\n}\\n\"\r\n    },\r\n    \"contracts/math/SafeInt256.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\nimport \\\"../global/Constants.sol\\\";\\n\\nlibrary SafeInt256 {\\n    int256 private constant _INT256_MIN = type(int256).min;\\n\\n    /// @dev Returns the multiplication of two signed integers, reverting on\\n    /// overflow.\\n\\n    /// Counterpart to Solidity's `*` operator.\\n\\n    /// Requirements:\\n\\n    /// - Multiplication cannot overflow.\\n\\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\\n        c = a * b;\\n        if (a == -1) require (b == 0 || c / b == a);\\n        else require (a == 0 || c / a == b);\\n    }\\n\\n    /// @dev Returns the integer division of two signed integers. Reverts on\\n    /// division by zero. The result is rounded towards zero.\\n\\n    /// Counterpart to Solidity's `/` operator. Note: this function uses a\\n    /// `revert` opcode (which leaves remaining gas untouched) while Solidity\\n    /// uses an invalid opcode to revert (consuming all remaining gas).\\n\\n    /// Requirements:\\n\\n    /// - The divisor cannot be zero.\\n\\n    function div(int256 a, int256 b) internal pure returns (int256 c) {\\n        require(!(b == -1 && a == _INT256_MIN)); // dev: int256 div overflow\\n        // NOTE: solidity will automatically revert on divide by zero\\n        c = a / b;\\n    }\\n\\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\\n        //  taken from uniswap v3\\n        require((z = x - y) <= x == (y >= 0));\\n    }\\n\\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\\n        require((z = x + y) >= x == (y >= 0));\\n    }\\n\\n    function neg(int256 x) internal pure returns (int256 y) {\\n        return mul(-1, x);\\n    }\\n\\n    function abs(int256 x) internal pure returns (int256) {\\n        if (x < 0) return neg(x);\\n        else return x;\\n    }\\n\\n    function subNoNeg(int256 x, int256 y) internal pure returns (int256 z) {\\n        z = sub(x, y);\\n        require(z >= 0); // dev: int256 sub to negative\\n\\n        return z;\\n    }\\n\\n    /// @dev Calculates x * RATE_PRECISION / y while checking overflows\\n    function divInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\\n        return div(mul(x, Constants.RATE_PRECISION), y);\\n    }\\n\\n    /// @dev Calculates x * y / RATE_PRECISION while checking overflows\\n    function mulInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\\n        return div(mul(x, y), Constants.RATE_PRECISION);\\n    }\\n\\n    function toUint(int256 x) internal pure returns (uint256) {\\n        require(x >= 0);\\n        return uint256(x);\\n    }\\n\\n    function toInt(uint256 x) internal pure returns (int256) {\\n        require (x <= uint256(type(int256).max)); // dev: toInt overflow\\n        return int256(x);\\n    }\\n\\n    function max(int256 x, int256 y) internal pure returns (int256) {\\n        return x > y ? x : y;\\n    }\\n\\n    function min(int256 x, int256 y) internal pure returns (int256) {\\n        return x < y ? x : y;\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\\n{\\n}\"\r\n    },\r\n    \"contracts/global/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.7.0;\\n\\n/// @title All shared constants for the Notional system should be declared here.\\nlibrary Constants {\\n    // Return code for cTokens that represents no error\\n    uint256 internal constant COMPOUND_RETURN_CODE_NO_ERROR = 0;\\n    uint8 internal constant CETH_DECIMAL_PLACES = 8;\\n\\n    // Token precision used for all internal balances, TokenHandler library ensures that we\\n    // limit the dust amount caused by precision mismatches\\n    int256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;\\n\\n    // ETH will be initialized as the first currency\\n    uint256 internal constant ETH_CURRENCY_ID = 1;\\n    uint8 internal constant ETH_DECIMAL_PLACES = 18;\\n    int256 internal constant ETH_DECIMALS = 1e18;\\n    // Used to prevent overflow when converting decimal places to decimal precision values via\\n    // 10**decimalPlaces. This is a safe value for int256 and uint256 variables. We apply this\\n    // constraint when storing decimal places in governance.\\n    uint256 internal constant MAX_DECIMAL_PLACES = 36;\\n\\n    // Address of the reserve account\\n    address internal constant RESERVE = address(0);\\n    // NOTE: this address is hardcoded in the library, must update this on deployment\\n    address constant NOTE_TOKEN_ADDRESS = 0xCFEAead4947f0705A14ec42aC3D44129E1Ef3eD5;\\n\\n    // Most significant bit\\n    bytes32 internal constant MSB =\\n        0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n    // Basis for percentages\\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\\n    // Max number of traded markets, also used as the maximum number of assets in a portfolio array\\n    uint256 internal constant MAX_TRADED_MARKET_INDEX = 7;\\n    // Max number of fCash assets in a bitmap, this is based on the gas costs of calculating free collateral\\n    // for a bitmap portfolio\\n    uint256 internal constant MAX_BITMAP_ASSETS = 20;\\n    uint256 internal constant FIVE_MINUTES = 300;\\n\\n    // Internal date representations, note we use a 6/30/360 week/month/year convention here\\n    uint256 internal constant DAY = 86400;\\n    // We use six day weeks to ensure that all time references divide evenly\\n    uint256 internal constant WEEK = DAY * 6;\\n    uint256 internal constant MONTH = WEEK * 5;\\n    uint256 internal constant QUARTER = MONTH * 3;\\n    uint256 internal constant YEAR = QUARTER * 4;\\n    \\n    // These constants are used in DateTime.sol\\n    uint256 internal constant DAYS_IN_WEEK = 6;\\n    uint256 internal constant DAYS_IN_MONTH = 30;\\n    uint256 internal constant DAYS_IN_QUARTER = 90;\\n\\n    // Offsets for each time chunk denominated in days\\n    uint256 internal constant MAX_DAY_OFFSET = 90;\\n    uint256 internal constant MAX_WEEK_OFFSET = 360;\\n    uint256 internal constant MAX_MONTH_OFFSET = 2160;\\n    uint256 internal constant MAX_QUARTER_OFFSET = 7650;\\n\\n    // Offsets for each time chunk denominated in bits\\n    uint256 internal constant WEEK_BIT_OFFSET = 90;\\n    uint256 internal constant MONTH_BIT_OFFSET = 135;\\n    uint256 internal constant QUARTER_BIT_OFFSET = 195;\\n\\n    // This is a constant that represents the time period that all rates are normalized by, 360 days\\n    uint256 internal constant IMPLIED_RATE_TIME = 360 * DAY;\\n    // Number of decimal places that rates are stored in, equals 100%\\n    int256 internal constant RATE_PRECISION = 1e9;\\n    // One basis point in RATE_PRECISION terms\\n    uint256 internal constant BASIS_POINT = uint256(RATE_PRECISION / 10000);\\n    // Used to when calculating the amount to deleverage of a market when minting nTokens\\n    uint256 internal constant DELEVERAGE_BUFFER = 300 * BASIS_POINT;\\n    // Used for scaling cash group factors\\n    uint256 internal constant FIVE_BASIS_POINTS = 5 * BASIS_POINT;\\n    // Used for residual purchase incentive and cash withholding buffer\\n    uint256 internal constant TEN_BASIS_POINTS = 10 * BASIS_POINT;\\n\\n    // This is the ABDK64x64 representation of RATE_PRECISION\\n    // RATE_PRECISION_64x64 = ABDKMath64x64.fromUint(RATE_PRECISION)\\n    int128 internal constant RATE_PRECISION_64x64 = 0x3b9aca000000000000000000;\\n    int128 internal constant LOG_RATE_PRECISION_64x64 = 382276781265598821176;\\n    // Limit the market proportion so that borrowing cannot hit extremely high interest rates\\n    int256 internal constant MAX_MARKET_PROPORTION = RATE_PRECISION * 96 / 100;\\n\\n    uint8 internal constant FCASH_ASSET_TYPE = 1;\\n    // Liquidity token asset types are 1 + marketIndex (where marketIndex is 1-indexed)\\n    uint8 internal constant MIN_LIQUIDITY_TOKEN_INDEX = 2;\\n    uint8 internal constant MAX_LIQUIDITY_TOKEN_INDEX = 8;\\n\\n    // Used for converting bool to bytes1, solidity does not have a native conversion\\n    // method for this\\n    bytes1 internal constant BOOL_FALSE = 0x00;\\n    bytes1 internal constant BOOL_TRUE = 0x01;\\n\\n    // Account context flags\\n    bytes1 internal constant HAS_ASSET_DEBT = 0x01;\\n    bytes1 internal constant HAS_CASH_DEBT = 0x02;\\n    bytes2 internal constant ACTIVE_IN_PORTFOLIO = 0x8000;\\n    bytes2 internal constant ACTIVE_IN_BALANCES = 0x4000;\\n    bytes2 internal constant UNMASK_FLAGS = 0x3FFF;\\n    uint16 internal constant MAX_CURRENCIES = uint16(UNMASK_FLAGS);\\n\\n    // Equal to 100% of all deposit amounts for nToken liquidity across fCash markets.\\n    int256 internal constant DEPOSIT_PERCENT_BASIS = 1e8;\\n\\n    // nToken Parameters: there are offsets in the nTokenParameters bytes6 variable returned\\n    // in nTokenHandler. Each constant represents a position in the byte array.\\n    uint8 internal constant LIQUIDATION_HAIRCUT_PERCENTAGE = 0;\\n    uint8 internal constant CASH_WITHHOLDING_BUFFER = 1;\\n    uint8 internal constant RESIDUAL_PURCHASE_TIME_BUFFER = 2;\\n    uint8 internal constant PV_HAIRCUT_PERCENTAGE = 3;\\n    uint8 internal constant RESIDUAL_PURCHASE_INCENTIVE = 4;\\n\\n    // Liquidation parameters\\n    // Default percentage of collateral that a liquidator is allowed to liquidate, will be higher if the account\\n    // requires more collateral to be liquidated\\n    int256 internal constant DEFAULT_LIQUIDATION_PORTION = 40;\\n    // Percentage of local liquidity token cash claim delivered to the liquidator for liquidating liquidity tokens\\n    int256 internal constant TOKEN_REPO_INCENTIVE_PERCENT = 30;\\n\\n    // Pause Router liquidation enabled states\\n    bytes1 internal constant LOCAL_CURRENCY_ENABLED = 0x01;\\n    bytes1 internal constant COLLATERAL_CURRENCY_ENABLED = 0x02;\\n    bytes1 internal constant LOCAL_FCASH_ENABLED = 0x04;\\n    bytes1 internal constant CROSS_CURRENCY_FCASH_ENABLED = 0x08;\\n}\\n\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n  function latestTimestamp() external view returns (uint256);\\n  function latestRound() external view returns (uint256);\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\"\r\n    },\r\n    \"interfaces/chainlink/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract AggregatorV2V3Interface\",\"name\":\"baseToUSDOracle_\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorV2V3Interface\",\"name\":\"quoteToUSDOracle_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"description_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"name\":\"AnswerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"startedBy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"baseToUSDDecimals\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseToUSDOracle\",\"outputs\":[{\"internalType\":\"contract AggregatorV2V3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"}],\"name\":\"getRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"getTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteToUSDDecimals\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteToUSDOracle\",\"outputs\":[{\"internalType\":\"contract AggregatorV2V3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rateDecimals\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ChainlinkAdapter","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000aed0c38402a5d19df6e4c03f4e2dced6e29c1ee90000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000224e6f74696f6e616c204441492f45544820436861696e6c696e6b2041646170746572000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}