// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

/// @author: manifold.xyz

import "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";

import "./access/AdminControl.sol";

import "./IRedeemBase.sol";

struct range {
    uint256 min;
    uint256 max;
}

/**
 * @dev Burn NFT's to receive another lazy minted NFT
 */
abstract contract RedeemBase is AdminControl, IRedeemBase {
    using EnumerableSet for EnumerableSet.UintSet;

    // approved contract tokens
    mapping(address => bool) private _approvedContracts;

    // approved specific tokens
    mapping(address => EnumerableSet.UintSet) private _approvedTokens;
    mapping(address => range[]) private _approvedTokenRange;

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(AdminControl, IERC165)
        returns (bool)
    {
        return
            interfaceId == type(IRedeemBase).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {IRedeemBase-updateApprovedContracts}
     */
    function updateApprovedContracts(
        address[] memory contracts,
        bool[] memory approved
    ) public virtual override adminRequired {
        require(
            contracts.length == approved.length,
            "Redeem: Invalid input parameters"
        );
        for (uint256 i = 0; i < contracts.length; i++) {
            _approvedContracts[contracts[i]] = approved[i];
        }
        emit UpdateApprovedContracts(contracts, approved);
    }

    /**
     * @dev See {IRedeemBase-updateApprovedTokens}
     */
    function updateApprovedTokens(
        address contract_,
        uint256[] memory tokenIds,
        bool[] memory approved
    ) public virtual override adminRequired {
        require(
            tokenIds.length == approved.length,
            "Redeem: Invalid input parameters"
        );

        for (uint256 i = 0; i < tokenIds.length; i++) {
            if (
                approved[i] && !_approvedTokens[contract_].contains(tokenIds[i])
            ) {
                _approvedTokens[contract_].add(tokenIds[i]);
            } else if (
                !approved[i] && _approvedTokens[contract_].contains(tokenIds[i])
            ) {
                _approvedTokens[contract_].remove(tokenIds[i]);
            }
        }
        emit UpdateApprovedTokens(contract_, tokenIds, approved);
    }

    /**
     * @dev See {IRedeemBase-updateApprovedTokenRanges}
     */
    function updateApprovedTokenRanges(
        address contract_,
        uint256[] memory minTokenIds,
        uint256[] memory maxTokenIds
    ) public virtual override adminRequired {
        require(
            minTokenIds.length == maxTokenIds.length,
            "Redeem: Invalid input parameters"
        );

        uint256 existingRangesLength = _approvedTokenRange[contract_].length;
        for (uint256 i = 0; i < existingRangesLength; i++) {
            _approvedTokenRange[contract_][i].min = 0;
            _approvedTokenRange[contract_][i].max = 0;
        }

        for (uint256 i = 0; i < minTokenIds.length; i++) {
            require(
                minTokenIds[i] < maxTokenIds[i],
                "Redeem: min must be less than max"
            );
            if (i < existingRangesLength) {
                _approvedTokenRange[contract_][i].min = minTokenIds[i];
                _approvedTokenRange[contract_][i].max = maxTokenIds[i];
            } else {
                _approvedTokenRange[contract_].push(
                    range(minTokenIds[i], maxTokenIds[i])
                );
            }
        }
        emit UpdateApprovedTokenRanges(contract_, minTokenIds, maxTokenIds);
    }

    /**
     * @dev See {IRedeemBase-redeemable}
     */
    function redeemable(address contract_, uint256 tokenId)
        public
        view
        virtual
        override
        returns (bool)
    {
        if (_approvedContracts[contract_]) {
            return true;
        }
        if (_approvedTokens[contract_].contains(tokenId)) {
            return true;
        }
        if (_approvedTokenRange[contract_].length > 0) {
            for (
                uint256 i = 0;
                i < _approvedTokenRange[contract_].length;
                i++
            ) {
                if (
                    _approvedTokenRange[contract_][i].max != 0 &&
                    tokenId >= _approvedTokenRange[contract_][i].min &&
                    tokenId <= _approvedTokenRange[contract_][i].max
                ) {
                    return true;
                }
            }
        }
        return false;
    }
}

