{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/AragonCourtDisputerV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport \\\"./interfaces/IRegistry.sol\\\";\\nimport \\\"./interfaces/IAragonCourt.sol\\\";\\nimport \\\"./interfaces/IInsurance.sol\\\";\\nimport \\\"./libs/AragonCourtMetadataLib.sol\\\";\\nimport \\\"../node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\ncontract AragonCourtDisputerV1 {\\n    using SafeERC20 for IERC20;\\n\\n    string private constant ERROR_NOT_VALIDATOR = \\\"Not a validator\\\";\\n    string private constant ERROR_NOT_DISPUTER = \\\"Not a disputer\\\";\\n    string private constant ERROR_IN_DISPUTE = \\\"In dispute\\\";\\n    string private constant ERROR_NOT_IN_DISPUTE = \\\"Not in dispute\\\";\\n    string private constant ERROR_NOT_READY = \\\"Not ready for dispute\\\";\\n    string private constant ERROR_ALREADY_RESOLVED = \\\"Resolution applied\\\";\\n    string private constant ERROR_INVALID_RULING = \\\"Invalid ruling\\\";\\n\\n    IRegistry public immutable TRUSTED_REGISTRY;\\n    IAragonCourt public immutable ARBITER;\\n\\n    uint256 public immutable SETTLEMENT_DELAY;\\n\\n    uint256 private constant EMPTY_INT = 0;\\n    uint256 private constant RULE_LEAKED = 1;\\n    uint256 private constant RULE_IGNORED = 2;\\n    uint256 private constant RULE_PAYEE_WON = 3;\\n    uint256 private constant RULE_PAYER_WON = 4;\\n\\n    string private constant PAYER_STATEMENT_LABEL = \\\"Statement (Payer)\\\";\\n    string private constant PAYEE_STATEMENT_LABEL = \\\"Statement (Payee)\\\";\\n\\n    bytes32 private constant EMPTY_BYTES32 = bytes32(0);\\n\\n    using AragonCourtMetadataLib for AragonCourtMetadataLib.EnforceableSettlement;\\n\\n    mapping (bytes32 => uint256) public resolutions;\\n    mapping (bytes32 => AragonCourtMetadataLib.EnforceableSettlement) public enforceableSettlements;\\n\\n    event UsedInsurance(\\n        bytes32 indexed cid,\\n        uint16 indexed index,\\n        address indexed feeToken,\\n        uint256 covered,\\n        uint256 notCovered\\n    );\\n\\n    event SettlementProposed(\\n        bytes32 indexed cid,\\n        uint16 indexed index,\\n        address indexed plaintiff,\\n        uint256 refundedPercent,\\n        uint256 releasedPercent,\\n        uint256 fillingStartsAt,\\n        bytes32 statement\\n    );\\n\\n    event DisputeStarted(\\n        bytes32 indexed cid,\\n        uint16 indexed index,\\n        address indexed plaintiff,\\n        uint256 did,\\n        bool ignoreCoverage\\n    );\\n\\n    event DisputeWitnessed(\\n        bytes32 indexed cid,\\n        uint16 indexed index,\\n        address indexed witness,\\n        uint256 did,\\n        bytes evidence\\n    );\\n\\n    event DisputeConcluded(\\n        bytes32 indexed cid,\\n        uint16 indexed index,\\n        uint256 indexed rule,\\n        uint256 did\\n    );\\n\\n    /**\\n     * @dev Can only be an escrow contract registered in Greet registry.\\n     */\\n    modifier isEscrow() {\\n        require(TRUSTED_REGISTRY.escrowContracts(msg.sender), ERROR_NOT_DISPUTER);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Dispute manager for Aragon Court.\\n     *\\n     * @param _registry Address of universal registry of all contracts.\\n     * @param _arbiter Address of Aragon Court subjective oracle.\\n     * @param _settlementDelay Seconds for second party to customise dispute proposal.\\n     */\\n    constructor(address _registry, address _arbiter, uint256 _settlementDelay) {\\n        TRUSTED_REGISTRY = IRegistry(_registry);\\n        ARBITER = IAragonCourt(_arbiter);\\n        SETTLEMENT_DELAY = _settlementDelay;\\n    }\\n\\n    /**\\n     * @dev Can only be an escrow contract which initiated settlement.\\n     *\\n     * @param _mid Milestone index.\\n     */\\n    function _requireDisputedEscrow(bytes32 _mid) internal view {\\n        require(msg.sender == enforceableSettlements[_mid].escrowContract, ERROR_NOT_VALIDATOR);\\n    }\\n\\n    /**\\n     * @dev Checks if milestone has ongoing settlement dispute.\\n     *\\n     * @param _mid Milestone uid.\\n     * @return true if there is ongoing settlement process.\\n     */\\n    function hasSettlementDispute(bytes32 _mid) public view returns (bool) {\\n        return enforceableSettlements[_mid].fillingStartsAt > 0;\\n    }\\n\\n    /**\\n     * @dev Checks if milestone has ongoing settlement dispute.\\n     *\\n     * @param _mid Milestone uid.\\n     * @param _ruling Aragon Court dispute resolution.\\n     * @return ruling, refunded percent, released percent.\\n     */\\n    function getSettlementByRuling(bytes32 _mid, uint256 _ruling) public view returns (uint256, uint256, uint256) {\\n        if (_ruling == RULE_PAYEE_WON) {\\n            AragonCourtMetadataLib.Claim memory _claim = enforceableSettlements[_mid].payeeClaim;\\n            return (_ruling, _claim.refundedPercent, _claim.releasedPercent);\\n        } else if (_ruling == RULE_PAYER_WON) {\\n            AragonCourtMetadataLib.Claim memory _claim = enforceableSettlements[_mid].payerClaim;\\n            return (_ruling, _claim.refundedPercent, _claim.releasedPercent);\\n        } else {\\n            return (_ruling, 0, 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Propose settlement enforceable in court.\\n     * We automatically fill the best outcome for opponent's proposal,\\n     * he has 1 week time to propose alternative distribution which he considers fair.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Milestone to amend.\\n     * @param _plaintiff Payer or Payee address who sends settlement for enforcement.\\n     * @param _payer Payer address.\\n     * @param _payee Payee address.\\n     * @param _refundedPercent Amount to refund (in percents).\\n     * @param _releasedPercent Amount to release (in percents).\\n     * @param _statement IPFS cid for statement.\\n     */\\n    function proposeSettlement(\\n        bytes32 _cid,\\n        uint16 _index,\\n        address _plaintiff,\\n        address _payer,\\n        address _payee,\\n        uint _refundedPercent,\\n        uint _releasedPercent,\\n        bytes32 _statement\\n    ) external isEscrow {\\n        bytes32 _mid = _genMid(_cid, _index);\\n        require(enforceableSettlements[_mid].did == EMPTY_INT, ERROR_IN_DISPUTE);\\n        uint256 _resolution = resolutions[_mid];\\n        require(_resolution != RULE_PAYEE_WON && _resolution != RULE_PAYER_WON, ERROR_ALREADY_RESOLVED);\\n\\n        AragonCourtMetadataLib.Claim memory _proposal = AragonCourtMetadataLib.Claim({\\n            refundedPercent: _refundedPercent,\\n            releasedPercent: _releasedPercent,\\n            statement: _statement\\n        });\\n\\n        uint256 _fillingStartsAt = enforceableSettlements[_mid].fillingStartsAt; \\n        if (_plaintiff == _payer) {\\n            enforceableSettlements[_mid].payerClaim = _proposal;\\n            if (_fillingStartsAt == 0) {\\n                _fillingStartsAt = block.timestamp + SETTLEMENT_DELAY;\\n                enforceableSettlements[_mid].fillingStartsAt = _fillingStartsAt;\\n                enforceableSettlements[_mid].payeeClaim = AragonCourtMetadataLib.defaultPayeeClaim();\\n                enforceableSettlements[_mid].escrowContract = msg.sender;\\n            }\\n        } else if (_plaintiff == _payee) {\\n            enforceableSettlements[_mid].payeeClaim = _proposal;\\n            if (_fillingStartsAt == 0) {\\n                _fillingStartsAt = block.timestamp + SETTLEMENT_DELAY;\\n                enforceableSettlements[_mid].fillingStartsAt = _fillingStartsAt;\\n                enforceableSettlements[_mid].payerClaim = AragonCourtMetadataLib.defaultPayerClaim();\\n                enforceableSettlements[_mid].escrowContract = msg.sender;\\n            }\\n        } else {\\n            revert();\\n        }\\n        emit SettlementProposed(_cid, _index, _plaintiff, _refundedPercent, _releasedPercent, _fillingStartsAt, _statement);\\n    }\\n\\n    /**\\n     * @dev Payee accepts Payer settlement without going to Aragon court.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Milestone challenged.\\n     */\\n    function acceptSettlement(\\n        bytes32 _cid,\\n        uint16 _index,\\n        uint256 _ruling\\n    ) external {\\n        bytes32 _mid = _genMid(_cid, _index);\\n        _requireDisputedEscrow(_mid);\\n        require(_ruling == RULE_PAYER_WON || _ruling == RULE_PAYEE_WON, ERROR_INVALID_RULING);\\n        resolutions[_mid] = _ruling;\\n        emit DisputeConcluded(_cid, _index, _ruling, 0);\\n    }\\n\\n    /**\\n     * @dev Send collected proposals for settlement to Aragon Court as arbiter.\\n     *\\n     * @param _feePayer Address which will pay a dispute fee (should approve this contract).\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Milestone to amend.\\n     * @param _termsCid Latest approved contract's IPFS cid.\\n     * @param _ignoreCoverage Don't try to use insurance.\\n     * @param _multiMilestone More than one milestone in contract?\\n     */\\n    function disputeSettlement(\\n        address _feePayer,\\n        bytes32 _cid,\\n        uint16 _index,\\n        bytes32 _termsCid,\\n        bool _ignoreCoverage,\\n        bool _multiMilestone\\n    ) external returns (uint256) {\\n        bytes32 _mid = _genMid(_cid, _index);\\n        _requireDisputedEscrow(_mid);\\n        require(enforceableSettlements[_mid].did == EMPTY_INT, ERROR_IN_DISPUTE);\\n        uint256 _fillingStartsAt = enforceableSettlements[_mid].fillingStartsAt;\\n        require(_fillingStartsAt > 0 && _fillingStartsAt < block.timestamp, ERROR_NOT_READY);\\n        uint256 _resolution = resolutions[_mid];\\n        require(_resolution != RULE_PAYEE_WON && _resolution != RULE_PAYER_WON, ERROR_ALREADY_RESOLVED);\\n\\n        _payDisputeFees(_feePayer, _cid, _index, _ignoreCoverage);\\n\\n        AragonCourtMetadataLib.EnforceableSettlement memory _enforceableSettlement = enforceableSettlements[_mid];\\n        bytes memory _metadata = _enforceableSettlement.generatePayload(_termsCid, _feePayer, _index, _multiMilestone);\\n        uint256 _did = ARBITER.createDispute(2, _metadata);\\n        enforceableSettlements[_mid].did = _did;\\n\\n\\n        bytes32 __payerStatement = enforceableSettlements[_mid].payerClaim.statement;\\n        if (__payerStatement != EMPTY_BYTES32) {\\n            bytes memory _payerStatement = AragonCourtMetadataLib.toIpfsCid(__payerStatement);\\n            ARBITER.submitEvidence(_did, address(this), abi.encode(_payerStatement, PAYER_STATEMENT_LABEL));\\n        }\\n\\n        bytes32 __payeeStatement = enforceableSettlements[_mid].payeeClaim.statement;\\n        if (__payeeStatement != EMPTY_BYTES32) {\\n            bytes memory _payeeStatement = AragonCourtMetadataLib.toIpfsCid(__payeeStatement);\\n            ARBITER.submitEvidence(_did, address(this), abi.encode(_payeeStatement, PAYEE_STATEMENT_LABEL));\\n        }\\n\\n        emit DisputeStarted(_cid, _index, _feePayer, _did, _ignoreCoverage);\\n        return _did;\\n    }\\n\\n    /**\\n     * @dev Execute settlement favored by Aragon Court as arbiter.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone to dispute.\\n     * @param _mid Milestone key.\\n     * @return Ruling, refundedPercent, releasedPercent\\n     */\\n    function executeSettlement(bytes32 _cid, uint16 _index, bytes32 _mid) public returns(uint256, uint256, uint256) {\\n        uint256 _ruling = ruleDispute(_cid, _index, _mid);\\n        return getSettlementByRuling(_mid, _ruling);\\n    }\\n\\n    /**\\n     * @dev Submit evidence to help dispute resolution.\\n     *\\n     * @param _from Address which submits evidence.\\n     * @param _label Label for address.\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone to dispute.\\n     * @param _evidence Additonal evidence which should help to resolve the dispute.\\n     */\\n    function submitEvidence(address _from, string memory _label, bytes32 _cid, uint16 _index, bytes calldata _evidence) external isEscrow {\\n        bytes32 _mid = _genMid(_cid, _index);\\n        uint256 _did = enforceableSettlements[_mid].did;\\n        require(_did != EMPTY_INT, ERROR_NOT_IN_DISPUTE);\\n        ARBITER.submitEvidence(_did, _from, abi.encode(_evidence, _label));\\n        emit DisputeWitnessed(_cid, _index, _from, _did, _evidence);\\n    }\\n\\n    /**\\n     * @dev Apply Aragon Court descision to milestone.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone to dispute.\\n     * @param _mid Milestone key.\\n     * @return ruling of Aragon Court.\\n     */\\n    function ruleDispute(bytes32 _cid, uint16 _index, bytes32 _mid) public returns(uint256) {\\n        _requireDisputedEscrow(_mid);\\n        uint256 _resolved = resolutions[_mid];\\n        if (_resolved != EMPTY_INT && _resolved != RULE_IGNORED && _resolved != RULE_LEAKED) return _resolved;\\n\\n        uint256 _did = enforceableSettlements[_mid].did;\\n        require(_did != EMPTY_INT || enforceableSettlements[_mid].did != EMPTY_INT, ERROR_NOT_IN_DISPUTE);\\n\\n        (, uint256 _ruling) = ARBITER.rule(_did);\\n        resolutions[_mid] = _ruling;\\n        if (_ruling == RULE_IGNORED || _ruling == RULE_LEAKED) {\\n            // Allow to send the same case again after SETTLEMENT_DELAY period\\n            enforceableSettlements[_mid].fillingStartsAt = block.timestamp + SETTLEMENT_DELAY;\\n            delete enforceableSettlements[_mid].did;\\n        } else {\\n            if (_ruling != RULE_PAYER_WON && _ruling != RULE_PAYEE_WON) revert();\\n        }\\n        \\n        emit DisputeConcluded(_cid, _index, _ruling, _did);\\n        return _ruling;\\n    }\\n\\n    /**\\n     * @dev Charge standard fees for dispute\\n     *\\n     * @param _feePayer Address which will pay a dispute fee (should approve this contract).\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone to dispute.\\n     * @param _ignoreCoverage Don't try to use insurance\\n     */\\n    function _payDisputeFees(address _feePayer, bytes32 _cid, uint16 _index, bool _ignoreCoverage) private {\\n        (address _recipient, IERC20 _feeToken, uint256 _feeAmount) = ARBITER.getDisputeFees();\\n        if (!_ignoreCoverage) {\\n            IInsurance _insuranceManager = IInsurance(TRUSTED_REGISTRY.insuranceManager());\\n            (uint256 _notCovered, uint256 _covered) = _insuranceManager.getCoverage(_cid, address(_feeToken), _feeAmount);\\n            if (_notCovered > 0) _feeToken.safeTransferFrom(_feePayer, address(this), _notCovered);\\n            if (_covered > 0) require(_insuranceManager.useCoverage(_cid, address(_feeToken), _covered));\\n            emit UsedInsurance(_cid, _index, address(_feeToken), _covered, _notCovered);\\n        } else {\\n            _feeToken.safeTransferFrom(_feePayer, address(this), _feeAmount);\\n        }\\n        _feeToken.safeApprove(_recipient, _feeAmount);\\n    }\\n\\n    /**\\n     * @dev Generate bytes32 uid for contract's milestone.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone (255 max).\\n     * @return milestone id (mid).\\n     */\\n    function _genMid(bytes32 _cid, uint16 _index) public pure returns(bytes32) {\\n        return keccak256(abi.encode(_cid, _index));\\n    }\\n} \"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/interfaces/IAragonCourt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport \\\"../../node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IAragonCourt {\\n    function createDispute(uint256 _possibleRulings, bytes calldata _metadata) external returns (uint256);\\n    function submitEvidence(uint256 _disputeId, address _submitter, bytes calldata _evidence) external;\\n    function rule(uint256 _disputeId) external returns (address subject, uint256 ruling);\\n    function getDisputeFees() external view returns (address recipient, IERC20 feeToken, uint256 feeAmount);\\n    function closeEvidencePeriod(uint256 _disputeId) external;\\n}\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/interfaces/IInsurance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\ninterface IInsurance {\\n    function getCoverage(bytes32 _cid, address _token, uint256 _feeAmount) external view returns (uint256, uint256);\\n    function useCoverage(bytes32 _cid, address _token, uint256 _amount) external returns (bool);\\n}\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/interfaces/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\ninterface IRegistry {\\n    function registerNewContract(bytes32 _cid, address _payer, address _payee) external;\\n    function escrowContracts(address _addr) external returns (bool);\\n    function insuranceManager() external returns (address);\\n}\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/libs/AragonCourtMetadataLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport \\\"./EscrowUtilsLib.sol\\\";\\n\\nlibrary AragonCourtMetadataLib {\\n    bytes2 private constant IPFS_V1_PREFIX = 0x1220;\\n    bytes32 private constant AC_GREET_PREFIX = 0x4752454554000000000000000000000000000000000000000000000000000000; // GREET\\n    bytes32 private constant PAYEE_BUTTON_COLOR = 0xffb46d0000000000000000000000000000000000000000000000000000000000; // Orange\\n    bytes32 private constant PAYER_BUTTON_COLOR = 0xffb46d0000000000000000000000000000000000000000000000000000000000; // Orange\\n    bytes32 private constant DEFAULT_STATEMENT_PAYER = bytes32(0);\\n    bytes32 private constant DEFAULT_STATEMENT_PAYEE = bytes32(0);\\n    string private constant PAYER_BUTTON = \\\"Payer\\\";\\n    string private constant PAYEE_BUTTON = \\\"Payee\\\";\\n    string private constant PAYEE_SETTLEMENT = \\\" % released to Payee\\\";\\n    string private constant PAYER_SETTLEMENT = \\\" % refunded to Payer\\\";\\n    string private constant SEPARATOR = \\\", \\\";\\n    string private constant NEW_LINE = \\\"\\\\n\\\";\\n    string private constant DESC_PREFIX = \\\"Should the escrow funds associated with \\\";\\n    string private constant DESC_SUFFIX = \\\"the contract be distributed according to the claim of Payer or Payee?\\\";\\n    string private constant DESC_MILESTONE_PREFIX = \\\"Milestone \\\";\\n    string private constant DESC_MILESTONE_SUFFIX = \\\" of \\\";\\n    string private constant PAYER_CLAIM_PREFIX = \\\"Payer claim: \\\";\\n    string private constant PAYEE_CLAIM_PREFIX = \\\"Payee claim: \\\";\\n\\n    struct Claim {\\n        uint refundedPercent;\\n        uint releasedPercent;\\n        bytes32 statement;\\n    }\\n\\n    struct EnforceableSettlement {\\n        address escrowContract;\\n        Claim payerClaim;\\n        Claim payeeClaim;\\n        uint256 fillingStartsAt;\\n        uint256 did;\\n        uint256 ruling;\\n    }\\n\\n    /**\\n     * @dev ABI encoded payload for Aragon Court dispute metadata.\\n     *\\n     * @param _enforceableSettlement EnforceableSettlement suggested by both parties.\\n     * @param _termsCid Latest approved version of IPFS cid for contract in dispute.\\n     * @param  _plaintiff Address of disputer.\\n     * @param _index Milestone index to dispute.\\n     * @param _multi Does contract has many milestones?\\n     * @return description text\\n     */\\n    function generatePayload(\\n        EnforceableSettlement memory _enforceableSettlement,\\n        bytes32 _termsCid,\\n        address _plaintiff,\\n        uint16 _index,\\n        bool _multi\\n    ) internal pure returns (bytes memory) {\\n        bytes memory _desc = textForDescription(\\n            _index,\\n            _multi,\\n            _enforceableSettlement.payeeClaim,\\n            _enforceableSettlement.payerClaim\\n        );\\n        \\n        return abi.encode(\\n            AC_GREET_PREFIX,\\n            toIpfsCid(_termsCid),\\n            _plaintiff,\\n            PAYER_BUTTON,\\n            PAYER_BUTTON_COLOR,\\n            PAYEE_BUTTON,\\n            PAYER_BUTTON_COLOR,\\n            _desc\\n        );\\n    }\\n\\n    /**\\n     * @dev By default Payee asks for a full release of escrow funds.\\n     *\\n     * @return structured claim.\\n     */\\n    function defaultPayeeClaim() internal pure returns (Claim memory) {\\n        return Claim({\\n            refundedPercent: 0,\\n            releasedPercent: 100,\\n            statement: DEFAULT_STATEMENT_PAYEE\\n        });\\n    }\\n\\n    /**\\n     * @dev By default Payer asks for a full refund of escrow funds.\\n     *\\n     * @return structured claim.\\n     */\\n    function defaultPayerClaim() internal pure returns (Claim memory) {\\n        return Claim({\\n            refundedPercent: 100,\\n            releasedPercent: 0,\\n            statement: DEFAULT_STATEMENT_PAYER\\n        });\\n    }\\n\\n    /**\\n     * @dev Adds prefix to produce compliant hex encoded IPFS cid.\\n     *\\n     * @param _chunkedCid Bytes32 chunked cid version.\\n     * @return full IPFS cid\\n     */\\n    function toIpfsCid(bytes32 _chunkedCid) internal pure returns (bytes memory) {\\n        return abi.encodePacked(IPFS_V1_PREFIX, _chunkedCid);\\n    }\\n\\n    /**\\n     * @dev Produces different texts based on milestone to be disputed.\\n     * e.g. \\\"Should the funds in the escrow associated with (Milestone X of)\\n     * the contract be released/refunded according to Payer or Payee's claim?\\\" or\\n     * \\\"Should the funds in the escrow associated with the contract ...\\\"  in case\\n     * of single milestone.\\n     *\\n     * @param _index Milestone index to dispute.\\n     * @param _multi Does contract has many milestones?\\n     * @param _payeeClaim Suggested claim from Payee.\\n     * @param _payerClaim Suggested claim from Payer.\\n     * @return description text\\n     */\\n    function textForDescription(\\n        uint256 _index,\\n        bool _multi,\\n        Claim memory _payeeClaim,\\n        Claim memory _payerClaim\\n    ) internal pure returns (bytes memory) {\\n        bytes memory _claims = abi.encodePacked(\\n            NEW_LINE,\\n            NEW_LINE,\\n            PAYER_CLAIM_PREFIX,\\n            textForClaim(_payerClaim.refundedPercent, _payerClaim.releasedPercent),\\n            NEW_LINE,\\n            NEW_LINE,\\n            PAYEE_CLAIM_PREFIX,\\n            textForClaim(_payeeClaim.refundedPercent, _payeeClaim.releasedPercent)\\n        );\\n\\n        if (_multi) {\\n            return abi.encodePacked(\\n                DESC_PREFIX,\\n                DESC_MILESTONE_PREFIX,\\n                uint2str(_index),\\n                DESC_MILESTONE_SUFFIX,\\n                DESC_SUFFIX,\\n                _claims\\n            );\\n        } else {\\n            return abi.encodePacked(\\n                DESC_PREFIX,\\n                DESC_SUFFIX,\\n                _claims\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Produces different texts for buttons in context of refunded and released percents.\\n     * e.g. \\\"90 % released to Payee, 10 % refunded to Payer\\\" or \\\"100 % released to Payee\\\" etc\\n     *\\n     * @param _refundedPercent Percent to refund 0-100.\\n     * @param _releasedPercent Percent to release 0-100.\\n     * @return button text\\n     */\\n    function textForClaim(uint256 _refundedPercent, uint256 _releasedPercent) internal pure returns (string memory) {\\n        if (_refundedPercent == 0) {\\n            return string(abi.encodePacked(uint2str(_releasedPercent), PAYEE_SETTLEMENT));\\n        } else if (_releasedPercent == 0) {\\n            return string(abi.encodePacked(uint2str(_refundedPercent), PAYER_SETTLEMENT));\\n        } else {\\n            return string(abi.encodePacked(\\n                uint2str(_releasedPercent),\\n                PAYEE_SETTLEMENT,\\n                SEPARATOR,\\n                uint2str(_refundedPercent),\\n                PAYER_SETTLEMENT\\n            ));\\n        }\\n    }\\n\\n    /**\\n     * @dev oraclizeAPI function to convert uint256 to memory string.\\n     *\\n     * @param _i Number to convert.\\n     * @return number in string encoding.\\n     */\\n    function uint2str(uint _i) internal pure returns (string memory) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint j = _i;\\n        uint len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint k = len - 1;\\n        \\n        unchecked {\\n            while (_i != 0) {\\n                bstr[k--] = bytes1(uint8(48 + _i % 10));\\n                _i /= 10;\\n            }\\n        }\\n        return string(bstr);\\n    }\\n}\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/libs/EscrowUtilsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nlibrary EscrowUtilsLib {\\n    struct MilestoneParams {\\n        address paymentToken;\\n        address treasury;\\n        address payeeAccount;\\n        address refundAccount;\\n        address escrowDisputeManager;\\n        uint autoReleasedAt;\\n        uint amount;\\n        uint16 parentIndex;\\n    }\\n    \\n    struct Contract {\\n        address payer;\\n        address payerDelegate;\\n        address payee;\\n        address payeeDelegate;\\n    }\\n\\n    /**\\n     * @dev Generate bytes32 uid for contract's milestone.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone (255 max).\\n     * @return milestone id (mid).\\n     */\\n    function genMid(bytes32 _cid, uint16 _index) internal pure returns(bytes32) {\\n        return keccak256(abi.encode(_cid, _index));\\n    }\\n\\n    /**\\n     * @dev Generate unique terms key in scope of a contract.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _termsCid cid of suggested contract version.\\n     * @return unique storage key for amendment.\\n     */\\n    function genTermsKey(bytes32 _cid, bytes32 _termsCid) internal pure returns(bytes32) {\\n        return keccak256(abi.encode(_cid, _termsCid));\\n    }\\n\\n    /**\\n     * @dev Generate unique settlement key in scope of a contract milestone.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Milestone index.\\n     * @param _revision Current version of milestone extended terms.\\n     * @return unique storage key for amendment.\\n     */\\n    function genSettlementKey(bytes32 _cid, uint16 _index, uint8 _revision) internal pure returns(bytes32) {\\n        return keccak256(abi.encode(_cid, _index, _revision));\\n    }\\n}\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/node_modules/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_arbiter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_settlementDelay\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rule\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"did\",\"type\":\"uint256\"}],\"name\":\"DisputeConcluded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"plaintiff\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"did\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"ignoreCoverage\",\"type\":\"bool\"}],\"name\":\"DisputeStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"witness\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"did\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"evidence\",\"type\":\"bytes\"}],\"name\":\"DisputeWitnessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"plaintiff\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refundedPercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"releasedPercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fillingStartsAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"statement\",\"type\":\"bytes32\"}],\"name\":\"SettlementProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"covered\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"notCovered\",\"type\":\"uint256\"}],\"name\":\"UsedInsurance\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ARBITER\",\"outputs\":[{\"internalType\":\"contract IAragonCourt\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SETTLEMENT_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRUSTED_REGISTRY\",\"outputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"}],\"name\":\"_genMid\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_ruling\",\"type\":\"uint256\"}],\"name\":\"acceptSettlement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feePayer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"_termsCid\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_ignoreCoverage\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_multiMilestone\",\"type\":\"bool\"}],\"name\":\"disputeSettlement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"enforceableSettlements\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"escrowContract\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"refundedPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasedPercent\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"statement\",\"type\":\"bytes32\"}],\"internalType\":\"struct AragonCourtMetadataLib.Claim\",\"name\":\"payerClaim\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"refundedPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasedPercent\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"statement\",\"type\":\"bytes32\"}],\"internalType\":\"struct AragonCourtMetadataLib.Claim\",\"name\":\"payeeClaim\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"fillingStartsAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"did\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ruling\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"_mid\",\"type\":\"bytes32\"}],\"name\":\"executeSettlement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_mid\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_ruling\",\"type\":\"uint256\"}],\"name\":\"getSettlementByRuling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_mid\",\"type\":\"bytes32\"}],\"name\":\"hasSettlementDispute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_plaintiff\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_payer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_payee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_refundedPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_releasedPercent\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_statement\",\"type\":\"bytes32\"}],\"name\":\"proposeSettlement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"resolutions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"_mid\",\"type\":\"bytes32\"}],\"name\":\"ruleDispute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_label\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_evidence\",\"type\":\"bytes\"}],\"name\":\"submitEvidence\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AragonCourtDisputerV1","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d30be688c053e0a308468b1c567bdfd6a210b020000000000000000000000000fb072baa713b01ce944a0515c3e1e98170977daf0000000000000000000000000000000000000000000000000000000000002760","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}