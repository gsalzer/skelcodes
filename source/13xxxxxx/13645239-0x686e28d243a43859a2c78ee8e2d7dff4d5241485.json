{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"ERC1155Holder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./ERC1155Receiver.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ncontract ERC1155Holder is ERC1155Receiver {\\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"},\"ERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"./ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    constructor() {\\n        _registerInterface(\\n            ERC1155Receiver(0).onERC1155Received.selector ^\\n            ERC1155Receiver(0).onERC1155BatchReceived.selector\\n        );\\n    }\\n}\\n\"},\"ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256(\\u0027supportsInterface(bytes4)\\u0027)) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it\\u0027s supported.\\n     */\\n    mapping(bytes4 =\\u003e bool) private _supportedInterfaces;\\n\\n    constructor () {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"},\"ERC721Holder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./IERC721Receiver.sol\\\";\\n\\n  /**\\n   * @dev Implementation of the {IERC721Receiver} interface.\\n   *\\n   * Accepts all token transfers. \\n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n   */\\ncontract ERC721Holder is IERC721Receiver {\\n\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"},\"IERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\n\\ninterface IERC1155 {\\n\\n  /****************************************|\\n  |                 Events                 |\\n  |_______________________________________*/\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\\n\\n  /**\\n   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\\n   *   Operator MUST be msg.sender\\n   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\\n   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\\n   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the \\\"circulating supply\\\" for a given token ID\\n   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\\n   */\\n  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\\n\\n  /**\\n   * @dev MUST emit when an approval is updated\\n   */\\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n\\n  /****************************************|\\n  |                Functions               |\\n  |_______________________________________*/\\n\\n  /**\\n    * @notice Transfers amount of an _id from the _from address to the _to address specified\\n    * @dev MUST emit TransferSingle event on success\\n    * Caller must be approved to manage the _from account\\u0027s tokens (see isApprovedForAll)\\n    * MUST throw if `_to` is the zero address\\n    * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\\n    * MUST throw on any other error\\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \\u003e 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n    * @param _from    Source address\\n    * @param _to      Target address\\n    * @param _id      ID of the token type\\n    * @param _amount  Transfered amount\\n    * @param _data    Additional data with no specified format, sent in call to `_to`\\n    */\\n  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\\n\\n  /**\\n    * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\\n    * @dev MUST emit TransferBatch event on success\\n    * Caller must be approved to manage the _from account\\u0027s tokens (see isApprovedForAll)\\n    * MUST throw if `_to` is the zero address\\n    * MUST throw if length of `_ids` is not the same as length of `_amounts`\\n    * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\\n    * MUST throw on any other error\\n    * When transfer is complete, this function MUST check if `_to` is a smart contract (code size \\u003e 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n    * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\\n    * @param _from     Source addresses\\n    * @param _to       Target addresses\\n    * @param _ids      IDs of each token type\\n    * @param _amounts  Transfer amounts per token type\\n    * @param _data     Additional data with no specified format, sent in call to `_to`\\n  */\\n  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\\n\\n  /**\\n   * @notice Get the balance of an account\\u0027s Tokens\\n   * @param _owner  The address of the token holder\\n   * @param _id     ID of the Token\\n   * @return        The _owner\\u0027s balance of the Token type requested\\n   */\\n  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the balance of multiple account/token pairs\\n   * @param _owners The addresses of the token holders\\n   * @param _ids    ID of the Tokens\\n   * @return        The _owner\\u0027s balance of the Token types requested (i.e. balance for each (owner, id) pair)\\n   */\\n  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\\n\\n  /**\\n   * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage all of caller\\u0027s tokens\\n   * @dev MUST emit the ApprovalForAll event on success\\n   * @param _operator  Address to add to the set of authorized operators\\n   * @param _approved  True if the operator is approved, false to revoke approval\\n   */\\n  function setApprovalForAll(address _operator, bool _approved) external;\\n\\n  /**\\n   * @notice Queries the approval status of an operator for a given owner\\n   * @param _owner     The owner of the Tokens\\n   * @param _operator  Address of authorized operator\\n   * @return isOperator True if the operator is approved, false if not\\n   */\\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\\n}\\n\"},\"IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\\n\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.2 \\u003c0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``\\u0027s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"},\"IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"},\"IStaterDiscounts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\n\\ninterface IStaterDiscounts {\\n    function getDiscountTokenId(uint256 _discountId, uint256 tokenIdIndex) external view returns(uint256);\\n    function calculateDiscount(address requester) external view returns(uint256);\\n}\"},\"LendingCore.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\nimport \\\"./StaterTransfers.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IStaterDiscounts.sol\\\";\\n\\ncontract LendingCore is StaterTransfers {\\n    using SafeMath for uint256;\\n    using SafeMath for uint8;\\n    \\n    /*\\n     * @DIIMIIM : The loan events\\n     */\\n    event NewLoan(\\n        address indexed owner,\\n        address indexed currency,\\n        uint256 indexed loanId,\\n        address[] nftAddressArray,\\n        uint256[] nftTokenIdArray,\\n        uint8[] nftTokenTypeArray\\n    );\\n    event EditLoan(\\n        address indexed currency,\\n        uint256 indexed loanId,\\n        uint256 loanAmount,\\n        uint256 amountDue,\\n        uint256 installmentAmount,\\n        uint256 assetsValue,\\n        uint256 frequencyTime,\\n        uint256 frequencyTimeUnit\\n    );\\n    event LoanApproved(\\n        address indexed lender,\\n        uint256 indexed loanId,\\n        uint256 loanPaymentEnd\\n    );\\n    event LoanCancelled(\\n        uint256 indexed loanId\\n    );\\n    event ItemsWithdrawn(\\n        address indexed requester,\\n        uint256 indexed loanId,\\n        Status status\\n    );\\n    event LoanPayment(\\n        uint256 indexed loanId,\\n        uint256 installmentAmount,\\n        uint256 amountPaidAsInstallmentToLender,\\n        uint256 interestPerInstallement,\\n        uint256 interestToStaterPerInstallement,\\n        Status status\\n    );\\n    \\n    /*\\n     * @DIIMIIM Public \\u0026 global variables for the lending contract\\n     * id : the loan ID, id will be the actual loans mapping length\\n     * ltv : max allowed 60%\\n     * interestRate : 20% of the payment\\n     * interestRateToStater : 40% of interestRate\\n     * discountNft : 50% discount\\n     * discountGeyser : 5% discount\\n     * lenderFee : 1%\\n     * Status : provides the loans status \\n     *   LISTED - loan is created and visible on lending.stater.co\\n     *   APPROVED - lender found and assigned to loan\\n     *   LIQUIDATED - all loan payments are paid\\n     *   CANCELLED - loan is cancelled before a lender to be assigned\\n     *   WITHDRAWN - loan is LIQUIDATED and items are withdrawn to either lender or borrower\\n     */\\n    address public promissoryNoteAddress;\\n    address public lendingMethodsAddress;\\n    IStaterDiscounts public discounts;\\n    uint256 public id = 1; // the loan ID\\n    uint256 public ltv = 60; // 60%\\n    uint256 public interestRate = 20;\\n    uint256 public interestRateToStater = 40;\\n    uint32 public lenderFee = 100;\\n    enum Status{ \\n        LISTED, \\n        APPROVED, \\n        LIQUIDATED, \\n        CANCELLED, \\n        WITHDRAWN \\n    }\\n    \\n    \\n    /*\\n     * @DIIMIIM : The loan structure\\n     */\\n    struct Loan {\\n        address[] nftAddressArray; // the adderess of the ERC721\\n        address payable borrower; // the address who receives the loan\\n        address payable lender; // the address who gives/offers the loan to the borrower\\n        address currency; // the token that the borrower lends, address(0) for ETH\\n        Status status; // the loan status\\n        uint256[] nftTokenIdArray; // the unique identifier of the NFT token that the borrower uses as collateral\\n        uint256 installmentTime; // the installment unix timestamp\\n        uint256 nrOfPayments; // the number of installments paid\\n        uint256 loanAmount; // the amount, denominated in tokens (see next struct entry), the borrower lends\\n        uint256 assetsValue; // important for determintng LTV which has to be under 50-60%\\n        uint256[2] startEnd; // startEnd[0] loan start date , startEnd[1] loan end date\\n        uint256 installmentAmount; // amount expected for each installment\\n        uint256 amountDue; // loanAmount + interest that needs to be paid back by borrower\\n        uint256 paidAmount; // the amount that has been paid back to the lender to date\\n        uint16 nrOfInstallments; // the number of installments that the borrower must pay.\\n        uint8 defaultingLimit; // the number of installments allowed to be missed without getting defaulted\\n        uint8[] nftTokenTypeArray; // the token types : ERC721 , ERC1155 , ...\\n    }\\n    \\n    /*\\n     * @DIIMIIM : public mappings\\n     *   loans - the loans mapping\\n     */\\n    mapping(uint256 =\\u003e Loan) public loans;\\n    \\n    // @notice Mapping for all the loans that are approved by the owner in order to be used in the promissory note\\n    mapping(uint256 =\\u003e address) public promissoryPermissions;\\n    \\n    modifier isPromissoryNote {\\n        require(msg.sender == promissoryNoteAddress, \\\"Lending Methods: Access denied\\\");\\n        _;\\n    }\\n    \\n    /*\\n     * @DIIMIIM Determines if a loan has passed the maximum unpaid installments limit or not\\n     * @ =\\u003e TRUE = Loan has exceed the maximum unpaid installments limit, lender can terminate the loan and get the NFTs\\n     * @ =\\u003e FALSE = Loan has not exceed the maximum unpaid installments limit, lender can not terminate the loan\\n     */\\n    function canBeTerminated(uint256 loanId) public view returns(bool) {\\n        require(loans[loanId].status == Status.APPROVED || loans[loanId].status == Status.LIQUIDATED, \\\"Loan is not yet approved\\\");\\n        // return last paid installment date + defaultingLimit * installment time interval \\u003c= block.timestamp\\n        return loans[loanId].startEnd[0].add(loans[loanId].nrOfPayments.mul(loans[loanId].installmentTime)).add(loans[loanId].defaultingLimit.mul(loans[loanId].installmentTime)) \\u003c= min(block.timestamp,loans[loanId].startEnd[1]);\\n    }\\n\\n    // Checks the loan to value ratio\\n    function checkLtv(uint256 loanValue, uint256 assetsValue) public view {\\n        require(loanValue \\u003c= assetsValue.div(100).mul(ltv), \\\"LTV too high\\\");\\n    }\\n\\n\\n    function min(uint256 a, uint256 b) internal pure returns(uint256) {\\n        return a \\u003c b ? a : b;\\n    }\\n\\n    function getLoanStartEnd(uint256 loanId) external view returns(uint256[2] memory) {\\n        return loans[loanId].startEnd;\\n    }\\n\\n    function getPromissoryPermission(uint256 loanId) external view returns(address) {\\n        require(loans[loanId].status == Status.APPROVED, \\\"Loan is no longer approved\\\");\\n        return promissoryPermissions[loanId];\\n    }\\n\\n}\\n\"},\"LendingMethods.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\nimport \\\"./LendingCore.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\n\\ncontract LendingMethods is Ownable, LendingCore {\\n    using SafeMath for uint256;\\n    using SafeMath for uint16;\\n    \\n    // Borrower creates a loan\\n    function createLoan(\\n        uint256 loanAmount,\\n        uint16 nrOfInstallments,\\n        address currency,\\n        uint256 assetsValue,\\n        address[] calldata nftAddressArray, \\n        uint256[] calldata nftTokenIdArray,\\n        uint8[] calldata nftTokenTypeArray\\n    ) external {\\n        require(nrOfInstallments \\u003e 0 \\u0026\\u0026 loanAmount \\u003e 0 \\u0026\\u0026 nftAddressArray.length \\u003e 0);\\n        require(nftAddressArray.length == nftTokenIdArray.length \\u0026\\u0026 nftTokenIdArray.length == nftTokenTypeArray.length);\\n        \\n        loans[id].assetsValue = assetsValue;\\n        \\n        // Checks the loan to value ration\\n        checkLtv(loanAmount, loans[id].assetsValue);\\n        \\n        // Computing the defaulting limit\\n        if ( nrOfInstallments \\u003c= 3 )\\n            loans[id].defaultingLimit = 1;\\n        else if ( nrOfInstallments \\u003c= 5 )\\n            loans[id].defaultingLimit = 2;\\n        else if ( nrOfInstallments \\u003e= 6 )\\n            loans[id].defaultingLimit = 3;\\n        \\n        // Set loan fields\\n        \\n        loans[id].nftTokenIdArray = nftTokenIdArray;\\n        loans[id].loanAmount = loanAmount;\\n        loans[id].amountDue = loanAmount.mul(interestRate.add(100)).div(100); // interest rate \\u003e\\u003e 20%\\n        loans[id].nrOfInstallments = nrOfInstallments;\\n        loans[id].installmentAmount = loans[id].amountDue.mod(nrOfInstallments) \\u003e 0 ? loans[id].amountDue.div(nrOfInstallments).add(1) : loans[id].amountDue.div(nrOfInstallments);\\n        loans[id].status = Status.LISTED;\\n        loans[id].nftAddressArray = nftAddressArray;\\n        loans[id].borrower = msg.sender;\\n        loans[id].currency = currency;\\n        loans[id].nftTokenTypeArray = nftTokenTypeArray;\\n        loans[id].installmentTime = 1 weeks;\\n        \\n        // Transfer the items from lender to stater contract\\n        transferItems(\\n            msg.sender, \\n            address(this), \\n            nftAddressArray, \\n            nftTokenIdArray,\\n            nftTokenTypeArray\\n        );\\n        \\n        // Fire event\\n        emit NewLoan(\\n            msg.sender, \\n            currency, \\n            id,\\n            nftAddressArray,\\n            nftTokenIdArray,\\n            nftTokenTypeArray\\n        );\\n        ++id;\\n    }\\n\\n\\n    /*\\n     * @ Edit loan\\n     * @ Accessible for borrower until a lender is found\\n     */\\n    function editLoan(\\n        uint256 loanId,\\n        uint256 loanAmount,\\n        uint16 nrOfInstallments,\\n        address currency,\\n        uint256 assetsValue,\\n        uint256 installmentTime\\n    ) external {\\n        require(nrOfInstallments \\u003e 0 \\u0026\\u0026 loanAmount \\u003e 0);\\n        require(loans[loanId].borrower == msg.sender);\\n        require(loans[loanId].status \\u003c Status.APPROVED);\\n        checkLtv(loanAmount, assetsValue);\\n        \\n\\n        loans[loanId].installmentTime = installmentTime;\\n        loans[loanId].loanAmount = loanAmount;\\n        loans[loanId].amountDue = loanAmount.mul(interestRate.add(100)).div(100);\\n        loans[loanId].installmentAmount = loans[loanId].amountDue.mod(nrOfInstallments) \\u003e 0 ? loans[loanId].amountDue.div(nrOfInstallments).add(1) : loans[loanId].amountDue.div(nrOfInstallments);\\n        loans[loanId].assetsValue = assetsValue;\\n        loans[loanId].nrOfInstallments = nrOfInstallments;\\n        loans[loanId].currency = currency;\\n        \\n        \\n        /*\\n         * Computing the defaulting limit\\n         */\\n        if ( nrOfInstallments \\u003c= 3 )\\n            loans[loanId].defaultingLimit = 1;\\n        else if ( nrOfInstallments \\u003c= 5 )\\n            loans[loanId].defaultingLimit = 2;\\n        else if ( nrOfInstallments \\u003e= 6 )\\n            loans[loanId].defaultingLimit = 3;\\n\\n        // Fire event\\n        emit EditLoan(\\n            currency, \\n            loanId,\\n            loanAmount,\\n            loans[loanId].amountDue,\\n            loans[loanId].installmentAmount,\\n            loans[loanId].assetsValue,\\n            installmentTime,\\n            nrOfInstallments\\n        );\\n\\n    }\\n    \\n    // Lender approves a loan\\n    function approveLoan(uint256 loanId) external payable {\\n        require(loans[loanId].lender == address(0));\\n        require(loans[loanId].paidAmount == 0);\\n        require(loans[loanId].status == Status.LISTED);\\n        \\n        // Borrower assigned , status is 1 , first installment ( payment ) completed\\n        loans[loanId].lender = msg.sender;\\n        loans[loanId].startEnd[1] = block.timestamp.add(loans[loanId].nrOfInstallments.mul(loans[loanId].installmentTime));\\n        loans[loanId].status = Status.APPROVED;\\n        loans[loanId].startEnd[0] = block.timestamp;\\n        uint256 discount = discounts.calculateDiscount(msg.sender);\\n        \\n        // We check if currency is ETH\\n        if ( loans[loanId].currency == address(0) )\\n            require(msg.value \\u003e= loans[loanId].loanAmount.add(loans[loanId].loanAmount.div(lenderFee).div(discount)));\\n        \\n        // We send the tokens here\\n        transferTokens(\\n            msg.sender,\\n            payable(loans[loanId].borrower),\\n            loans[loanId].currency,\\n            loans[loanId].loanAmount,\\n            loans[loanId].loanAmount.div(lenderFee).div(discount)\\n        );\\n        \\n        emit LoanApproved(\\n            msg.sender,\\n            loanId,\\n            loans[loanId].startEnd[1]\\n        );\\n\\n    }\\n\\n    // Borrower cancels a loan\\n    function cancelLoan(uint256 loanId) external {\\n        require(loans[loanId].lender == address(0));\\n        require(loans[loanId].borrower == msg.sender);\\n        require(loans[loanId].status != Status.CANCELLED);\\n        require(loans[loanId].status == Status.LISTED);\\n        loans[loanId].status = Status.CANCELLED;\\n\\n        // We send the items back to him\\n        transferItems(\\n        address(this), \\n            loans[loanId].borrower, \\n            loans[loanId].nftAddressArray, \\n            loans[loanId].nftTokenIdArray,\\n            loans[loanId].nftTokenTypeArray\\n        );\\n\\n        emit LoanCancelled(\\n            loanId\\n        );\\n    }\\n\\n    // Borrower pays installment for loan\\n    // Multiple installments : OK\\n    function payLoan(uint256 loanId,uint256 amount) external payable {\\n        require(loans[loanId].borrower == msg.sender);\\n        require(loans[loanId].status == Status.APPROVED);\\n        require(loans[loanId].startEnd[1] \\u003e= block.timestamp);\\n        require((msg.value \\u003e 0 \\u0026\\u0026 loans[loanId].currency == address(0) \\u0026\\u0026 msg.value == amount) || (loans[loanId].currency != address(0) \\u0026\\u0026 msg.value == 0 \\u0026\\u0026 amount \\u003e 0));\\n        \\n        uint256 paidByBorrower = msg.value \\u003e 0 ? msg.value : amount;\\n        uint256 amountPaidAsInstallmentToLender = paidByBorrower; // \\u003e\\u003e amount of installment that goes to lender\\n        uint256 interestPerInstallement = paidByBorrower.mul(interestRate).div(100); // entire interest for installment\\n        uint256 discount = discounts.calculateDiscount(msg.sender);\\n        uint256 interestToStaterPerInstallement = interestPerInstallement.mul(interestRateToStater).div(100);\\n\\n        if ( discount != 1 ){\\n            if ( loans[loanId].currency == address(0) ){\\n                require(msg.sender.send(interestToStaterPerInstallement.div(discount)));\\n                amountPaidAsInstallmentToLender = amountPaidAsInstallmentToLender.sub(interestToStaterPerInstallement.div(discount));\\n            }\\n            interestToStaterPerInstallement = interestToStaterPerInstallement.sub(interestToStaterPerInstallement.div(discount));\\n        }\\n        amountPaidAsInstallmentToLender = amountPaidAsInstallmentToLender.sub(interestToStaterPerInstallement);\\n\\n        loans[loanId].paidAmount = loans[loanId].paidAmount.add(paidByBorrower);\\n        loans[loanId].nrOfPayments = loans[loanId].nrOfPayments.add(paidByBorrower.div(loans[loanId].installmentAmount));\\n\\n        if (loans[loanId].paidAmount \\u003e= loans[loanId].amountDue)\\n        loans[loanId].status = Status.LIQUIDATED;\\n\\n        // We transfer the tokens to borrower here\\n        transferTokens(\\n            msg.sender,\\n            loans[loanId].lender,\\n            loans[loanId].currency,\\n            amountPaidAsInstallmentToLender,\\n            interestToStaterPerInstallement\\n        );\\n\\n        emit LoanPayment(\\n            loanId,\\n            paidByBorrower,\\n            amountPaidAsInstallmentToLender,\\n            interestPerInstallement,\\n            interestToStaterPerInstallement,\\n            loans[loanId].status\\n        );\\n    }\\n\\n    // Borrower can withdraw loan items if loan is LIQUIDATED\\n    // Lender can withdraw loan item is loan is DEFAULTED\\n    function terminateLoan(uint256 loanId) external {\\n        require(msg.sender == loans[loanId].borrower || msg.sender == loans[loanId].lender);\\n        require(loans[loanId].status != Status.WITHDRAWN);\\n        require((block.timestamp \\u003e= loans[loanId].startEnd[1] || loans[loanId].paidAmount \\u003e= loans[loanId].amountDue) || canBeTerminated(loanId));\\n        require(loans[loanId].status == Status.LIQUIDATED || loans[loanId].status == Status.APPROVED);\\n\\n        if ( canBeTerminated(loanId) ) {\\n            loans[loanId].status = Status.WITHDRAWN;\\n            // We send the items back to lender\\n            transferItems(\\n                address(this),\\n                loans[loanId].lender,\\n                loans[loanId].nftAddressArray,\\n                loans[loanId].nftTokenIdArray,\\n                loans[loanId].nftTokenTypeArray\\n            );\\n        } else {\\n            if ( block.timestamp \\u003e= loans[loanId].startEnd[1] \\u0026\\u0026 loans[loanId].paidAmount \\u003c loans[loanId].amountDue ) {\\n                loans[loanId].status = Status.WITHDRAWN;\\n                // We send the items back to lender\\n                transferItems(\\n                    address(this),\\n                    loans[loanId].lender,\\n                    loans[loanId].nftAddressArray,\\n                    loans[loanId].nftTokenIdArray,\\n                    loans[loanId].nftTokenTypeArray\\n                );\\n            } else if ( loans[loanId].paidAmount \\u003e= loans[loanId].amountDue ){\\n                loans[loanId].status = Status.WITHDRAWN;\\n                // We send the items back to borrower\\n                transferItems(\\n                    address(this),\\n                    loans[loanId].borrower,\\n                    loans[loanId].nftAddressArray,\\n                    loans[loanId].nftTokenIdArray,\\n                    loans[loanId].nftTokenTypeArray\\n                );\\n            }\\n        }\\n        \\n        emit ItemsWithdrawn(\\n            msg.sender,\\n            loanId,\\n            loans[loanId].status\\n        );\\n    }\\n    \\n    /**\\n     * @notice Used by the Promissory Note contract to change the ownership of the loan when the Promissory Note NFT is sold \\n     * @param from The address of the current owner\\n     * @param to The address of the new owner\\n     * @param loanIds The ids of the loans that will be transferred to the new owner\\n     */\\n    function promissoryExchange(address from, address payable to, uint256[] calldata loanIds) external isPromissoryNote {\\n        for (uint256 i = 0; i \\u003c loanIds.length; ++i) {\\n            require(loans[loanIds[i]].lender == from);\\n            require(loans[loanIds[i]].status == Status.APPROVED);\\n            require(promissoryPermissions[loanIds[i]] == from);\\n            loans[loanIds[i]].lender = to;\\n            promissoryPermissions[loanIds[i]] = to;\\n        }\\n    }\\n  \\n    /**\\n     * @notice Used by the Promissory Note contract to approve a list of loans to be used as a Promissory Note NFT\\n     * @param loanIds The ids of the loans that will be approved\\n     */\\n     function setPromissoryPermissions(uint256[] calldata loanIds, address allowed) external {\\n        require(allowed != address(0));\\n        for (uint256 i = 0; i \\u003c loanIds.length; ++i) {\\n            require(loans[loanIds[i]].lender == msg.sender);\\n            require(loans[loanIds[i]].status == Status.APPROVED);\\n            promissoryPermissions[loanIds[i]] = allowed;\\n        }\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"StaterTransfers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./ERC721Holder.sol\\\";\\nimport \\\"./ERC1155Holder.sol\\\";\\n\\ncontract StaterTransfers is Ownable, ERC721Holder, ERC1155Holder {\\n    \\n\\n    /*\\n     * @DIIMIIM : standard method to send tokens from an account to another ( + payment fee to admin )\\n     */\\n    function transferTokens(\\n        address from,\\n        address payable to,\\n        address currency,\\n        uint256 qty1,\\n        uint256 qty2\\n    ) public {\\n      if ( currency != address(0) ){\\n          require(IERC20(currency).transferFrom(\\n              from,\\n              to, \\n              qty1\\n          ), \\\"Transfer of tokens to receiver failed\\\");\\n          require(IERC20(currency).transferFrom(\\n              from,\\n              owner(), \\n              qty2\\n          ), \\\"Transfer of tokens to Stater failed\\\");\\n      }else{\\n          require(to.send(qty1), \\\"Transfer of ETH to receiver failed\\\");\\n          require(payable(owner()).send(qty2), \\\"Transfer of ETH to Stater failed\\\");\\n      }\\n    }\\n\\n\\n    /*\\n     * @DIIMIIM : standard method to send items from an account to another\\n     */\\n    function transferItems(\\n        address from, \\n        address to, \\n        address[] memory nftAddressArray, \\n        uint256[] memory nftTokenIdArray,\\n        uint8[] memory nftTokenTypeArray\\n    ) public {\\n        uint256 length = nftAddressArray.length;\\n        require(length == nftTokenIdArray.length \\u0026\\u0026 nftTokenTypeArray.length == length, \\\"Token infos provided are invalid\\\");\\n        for(uint256 i = 0; i \\u003c length; ++i) \\n            if ( nftTokenTypeArray[i] == 0 )\\n                IERC721(nftAddressArray[i]).safeTransferFrom(\\n                    from,\\n                    to,\\n                    nftTokenIdArray[i]\\n                );\\n            else\\n                IERC1155(nftAddressArray[i]).safeTransferFrom(\\n                    from,\\n                    to,\\n                    nftTokenIdArray[i],\\n                    1,\\n                    \\u00270x00\\u0027\\n                );\\n    }\\n\\n}\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"installmentAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetsValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"frequencyTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"frequencyTimeUnit\",\"type\":\"uint256\"}],\"name\":\"EditLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum LendingCore.Status\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"ItemsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanPaymentEnd\",\"type\":\"uint256\"}],\"name\":\"LoanApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"LoanCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"installmentAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPaidAsInstallmentToLender\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestPerInstallement\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestToStaterPerInstallement\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum LendingCore.Status\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"LoanPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"nftAddressArray\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"nftTokenIdArray\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint8[]\",\"name\":\"nftTokenTypeArray\",\"type\":\"uint8[]\"}],\"name\":\"NewLoan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"approveLoan\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"canBeTerminated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"cancelLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetsValue\",\"type\":\"uint256\"}],\"name\":\"checkLtv\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"nrOfInstallments\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetsValue\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"nftAddressArray\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nftTokenIdArray\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"nftTokenTypeArray\",\"type\":\"uint8[]\"}],\"name\":\"createLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"discounts\",\"outputs\":[{\"internalType\":\"contract IStaterDiscounts\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"nrOfInstallments\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assetsValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"installmentTime\",\"type\":\"uint256\"}],\"name\":\"editLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"getLoanStartEnd\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"getPromissoryPermission\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"id\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestRateToStater\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lenderFee\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingMethodsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"loans\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"enum LendingCore.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"installmentTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nrOfPayments\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetsValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"installmentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountDue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"nrOfInstallments\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"defaultingLimit\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ltv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"payLoan\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"loanIds\",\"type\":\"uint256[]\"}],\"name\":\"promissoryExchange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"promissoryNoteAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"promissoryPermissions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"loanIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"allowed\",\"type\":\"address\"}],\"name\":\"setPromissoryPermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"}],\"name\":\"terminateLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"nftAddressArray\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nftTokenIdArray\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"nftTokenTypeArray\",\"type\":\"uint8[]\"}],\"name\":\"transferItems\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qty1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty2\",\"type\":\"uint256\"}],\"name\":\"transferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LendingMethods","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://90ab9e078ad9b4a0c0e8f645a000f262d5404c5c9e03c471e63555b359db6665"}]}