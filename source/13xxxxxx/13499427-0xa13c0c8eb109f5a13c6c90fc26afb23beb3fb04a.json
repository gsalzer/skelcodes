{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\n// Copyright (C) 2021 Dai Foundation\r\n//\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface TokenLike {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address) external view returns (uint256);\r\n    function approve(address, uint256) external returns (bool);\r\n    function transfer(address, uint256) external returns (bool);\r\n    function scaledBalanceOf(address) external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ninterface ChainlogLike {\r\n    function getAddress(bytes32) external view returns (address);\r\n}\r\n\r\ninterface DaiJoinLike {\r\n    function wards(address) external view returns (uint256);\r\n    function rely(address usr) external;\r\n    function deny(address usr) external;\r\n    function vat() external view returns (address);\r\n    function dai() external view returns (address);\r\n    function live() external view returns (uint256);\r\n    function cage() external;\r\n    function join(address, uint256) external;\r\n    function exit(address, uint256) external;\r\n}\r\n\r\ninterface VatLike {\r\n    function hope(address) external;\r\n    function ilks(bytes32) external view returns (uint256, uint256, uint256, uint256, uint256);\r\n    function urns(bytes32, address) external view returns (uint256, uint256);\r\n    function gem(bytes32, address) external view returns (uint256);\r\n    function live() external view returns (uint256);\r\n    function slip(bytes32, address, int256) external;\r\n    function move(address, address, uint256) external;\r\n    function frob(bytes32, address, address, address, int256, int256) external;\r\n    function grab(bytes32, address, address, address, int256, int256) external;\r\n    function fork(bytes32, address, address, int256, int256) external;\r\n    function suck(address, address, uint256) external;\r\n}\r\n\r\ninterface LendingPoolLike {\r\n    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\r\n    function withdraw(address asset, uint256 amount, address to) external;\r\n    function getReserveNormalizedIncome(address asset) external view returns (uint256);\r\n    function getReserveData(address asset) external view returns (\r\n        uint256,    // Configuration\r\n        uint128,    // the liquidity index. Expressed in ray\r\n        uint128,    // variable borrow index. Expressed in ray\r\n        uint128,    // the current supply rate. Expressed in ray\r\n        uint128,    // the current variable borrow rate. Expressed in ray\r\n        uint128,    // the current stable borrow rate. Expressed in ray\r\n        uint40,\r\n        address,    // address of the adai interest bearing token\r\n        address,    // address of the stable debt token\r\n        address,    // address of the variable debt token\r\n        address,    // address of the interest rate strategy\r\n        uint8\r\n    );\r\n}\r\n\r\ninterface InterestRateStrategyLike {\r\n    function OPTIMAL_UTILIZATION_RATE() external view returns (uint256);\r\n    function EXCESS_UTILIZATION_RATE() external view returns (uint256);\r\n    function variableRateSlope1() external view returns (uint256);\r\n    function variableRateSlope2() external view returns (uint256);\r\n    function baseVariableBorrowRate() external view returns (uint256);\r\n    function getMaxVariableBorrowRate() external view returns (uint256);\r\n}\r\n\r\ninterface RewardsClaimerLike {\r\n    function claimRewards(address[] calldata assets, uint256 amount, address to) external returns (uint256);\r\n}\r\n\r\ninterface EndLike {\r\n    function debt() external view returns (uint256);\r\n    function skim(bytes32, address) external;\r\n}\r\n\r\ncontract DssDirectDepositAaveDai {\r\n\r\n    // --- Auth ---\r\n    mapping (address => uint) public wards;\r\n    function rely(address usr) external auth {\r\n        wards[usr] = 1;\r\n\r\n        emit Rely(usr);\r\n    }\r\n    function deny(address usr) external auth {\r\n        wards[usr] = 0;\r\n\r\n        emit Deny(usr);\r\n    }\r\n    modifier auth {\r\n        require(wards[msg.sender] == 1, \"DssDirectDepositAaveDai/not-authorized\");\r\n        _;\r\n    }\r\n\r\n    ChainlogLike public immutable chainlog;\r\n    VatLike public immutable vat;\r\n    bytes32 public immutable ilk;\r\n    LendingPoolLike public immutable pool;\r\n    InterestRateStrategyLike public immutable interestStrategy;\r\n    RewardsClaimerLike public immutable rewardsClaimer;\r\n    TokenLike public immutable adai;\r\n    TokenLike public immutable stableDebt;\r\n    TokenLike public immutable variableDebt;\r\n    TokenLike public immutable dai;\r\n    DaiJoinLike public immutable daiJoin;\r\n    TokenLike public immutable gem;\r\n    uint256 public immutable dec;\r\n\r\n    uint256 public tau;             // Time until you can write off the debt [sec]\r\n    uint256 public bar;             // Target Interest Rate [ray]\r\n    uint256 public live = 1;\r\n    uint256 public culled;\r\n    uint256 public tic;             // Timestamp when the system is caged\r\n    address public king;            // Who gets the rewards\r\n\r\n    enum Mode{ NORMAL, MODULE_CULLED, MCD_CAGED }\r\n\r\n    // --- Events ---\r\n    event Rely(address indexed usr);\r\n    event Deny(address indexed usr);\r\n    event File(bytes32 indexed what, address data);\r\n    event File(bytes32 indexed what, uint256 data);\r\n    event Wind(uint256 amount);\r\n    event Unwind(uint256 amount);\r\n    event Reap();\r\n    event Cage();\r\n    event Cull();\r\n    event Uncull();\r\n\r\n    constructor(address chainlog_, bytes32 ilk_, address pool_, address _rewardsClaimer) public {\r\n        address vat_ = ChainlogLike(chainlog_).getAddress(\"MCD_VAT\");\r\n        address daiJoin_ = ChainlogLike(chainlog_).getAddress(\"MCD_JOIN_DAI\");\r\n        TokenLike dai_ = dai = TokenLike(DaiJoinLike(daiJoin_).dai());\r\n\r\n        // Fetch the reserve data from Aave\r\n        (,,,,,,, address adai_, address stableDebt_, address variableDebt_, address interestStrategy_,) = LendingPoolLike(pool_).getReserveData(address(dai_));\r\n        require(adai_ != address(0), \"DssDirectDepositAaveDai/invalid-adai\");\r\n        require(stableDebt_ != address(0), \"DssDirectDepositAaveDai/invalid-stableDebt\");\r\n        require(variableDebt_ != address(0), \"DssDirectDepositAaveDai/invalid-variableDebt\");\r\n        require(interestStrategy_ != address(0), \"DssDirectDepositAaveDai/invalid-interestStrategy\");\r\n\r\n        chainlog = ChainlogLike(chainlog_);\r\n        vat = VatLike(vat_);\r\n        ilk = ilk_;\r\n        pool = LendingPoolLike(pool_);\r\n        gem = adai = TokenLike(adai_);\r\n        dec = TokenLike(adai_).decimals();\r\n        stableDebt = TokenLike(stableDebt_);\r\n        variableDebt = TokenLike(variableDebt_);\r\n        daiJoin = DaiJoinLike(daiJoin_);\r\n        interestStrategy = InterestRateStrategyLike(interestStrategy_);\r\n        rewardsClaimer = RewardsClaimerLike(_rewardsClaimer);\r\n\r\n        wards[msg.sender] = 1;\r\n        emit Rely(msg.sender);\r\n\r\n        // Auths\r\n        VatLike(vat_).hope(daiJoin_);\r\n        dai_.approve(pool_, type(uint256).max);\r\n        dai_.approve(daiJoin_, type(uint256).max);\r\n    }\r\n\r\n    // --- Math ---\r\n    function _add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x, \"DssDirectDepositAaveDai/overflow\");\r\n    }\r\n    function _sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x, \"DssDirectDepositAaveDai/underflow\");\r\n    }\r\n    function _mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"DssDirectDepositAaveDai/overflow\");\r\n    }\r\n    uint256 constant RAY  = 10 ** 27;\r\n    function _rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = _mul(x, y) / RAY;\r\n    }\r\n    function _rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = _mul(x, RAY) / y;\r\n    }\r\n    function _min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x <= y ? x : y;\r\n    }\r\n\r\n    // --- Administration ---\r\n    function file(bytes32 what, uint256 data) external auth {\r\n        if (what == \"bar\") {\r\n            require(data <= interestStrategy.getMaxVariableBorrowRate(), \"DssDirectDepositAaveDai/above-max-interest\");\r\n\r\n            bar = data;\r\n        } else if (what == \"tau\" ) {\r\n            require(live == 1, \"DssDirectDepositAaveDai/not-live\");\r\n\r\n            tau = data;\r\n        } else revert(\"DssDirectDepositAaveDai/file-unrecognized-param\");\r\n\r\n        emit File(what, data);\r\n    }\r\n\r\n    function file(bytes32 what, address data) external auth {\r\n        require(vat.live() == 1, \"DssDirectDepositAaveDai/no-file-during-shutdown\");\r\n\r\n        if (what == \"king\") king = data;\r\n        else revert(\"DssDirectDepositAaveDai/file-unrecognized-param\");\r\n        emit File(what, data);\r\n    }\r\n\r\n    // --- Automated Rate targeting ---\r\n    function calculateTargetSupply(uint256 targetInterestRate) public view returns (uint256) {\r\n        uint256 base = interestStrategy.baseVariableBorrowRate();\r\n        require(targetInterestRate > base, \"DssDirectDepositAaveDai/target-interest-base\");\r\n        require(targetInterestRate <= interestStrategy.getMaxVariableBorrowRate(), \"DssDirectDepositAaveDai/above-max-interest\");\r\n\r\n        // Do inverse calculation of interestStrategy\r\n        uint256 targetUtil;\r\n        if (targetInterestRate > _add(base, interestStrategy.variableRateSlope1())) {\r\n            // Excess interest rate\r\n            uint256 r = targetInterestRate - base - interestStrategy.variableRateSlope1();\r\n            targetUtil = _add(_rdiv(_rmul(interestStrategy.EXCESS_UTILIZATION_RATE(), r), interestStrategy.variableRateSlope2()), interestStrategy.OPTIMAL_UTILIZATION_RATE());\r\n        } else {\r\n            // Optimal interest rate\r\n            targetUtil = _rdiv(_rmul(_sub(targetInterestRate, base), interestStrategy.OPTIMAL_UTILIZATION_RATE()), interestStrategy.variableRateSlope1());\r\n        }\r\n        return _rdiv(_add(stableDebt.totalSupply(), variableDebt.totalSupply()), targetUtil);\r\n    }\r\n\r\n    // --- Deposit controls ---\r\n    function _wind(uint256 amount) internal {\r\n        // IMPORTANT: this function assumes Vat rate of this ilk will always be == 1 * RAY (no fees).\r\n        // That's why this module converts normalized debt (art) to Vat DAI generated with a simple RAY multiplication or division\r\n        // This module will have an unintended behaviour if rate is changed to some other value.\r\n\r\n        // Wind amount is limited by the debt ceiling\r\n        (uint256 Art,,, uint256 line,) = vat.ilks(ilk);\r\n        uint256 lineWad = line / RAY; // Round down to always be under the actual limit\r\n        if (_add(Art, amount) > lineWad) {\r\n            amount = _sub(lineWad, Art);\r\n        }\r\n\r\n        if (amount == 0) {\r\n            emit Wind(0);\r\n            return;\r\n        }\r\n\r\n        require(int256(amount) >= 0, \"DssDirectDepositAaveDai/overflow\");\r\n\r\n        uint256 scaledPrev = adai.scaledBalanceOf(address(this));\r\n\r\n        vat.slip(ilk, address(this), int256(amount));\r\n        vat.frob(ilk, address(this), address(this), address(this), int256(amount), int256(amount));\r\n        // normalized debt == erc20 DAI to join (Vat rate for this ilk fixed to 1 RAY)\r\n        daiJoin.exit(address(this), amount);\r\n        pool.deposit(address(dai), amount, address(this), 0);\r\n\r\n        // Verify the correct amount of adai shows up\r\n        uint256 interestIndex = pool.getReserveNormalizedIncome(address(dai));\r\n        uint256 scaledAmount = _rdiv(amount, interestIndex);\r\n        require(adai.scaledBalanceOf(address(this)) >= _add(scaledPrev, scaledAmount), \"DssDirectDepositAaveDai/no-receive-adai\");\r\n\r\n        emit Wind(amount);\r\n    }\r\n\r\n    function _unwind(uint256 supplyReduction, uint256 availableLiquidity, Mode mode) internal {\r\n        // IMPORTANT: this function assumes Vat rate of this ilk will always be == 1 * RAY (no fees).\r\n        // That's why it converts normalized debt (art) to Vat DAI generated with a simple RAY multiplication or division\r\n        // This module will have an unintended behaviour if rate is changed to some other value.\r\n\r\n        address end;\r\n        uint256 adaiBalance = adai.balanceOf(address(this));\r\n        uint256 daiDebt;\r\n        if (mode == Mode.NORMAL) {\r\n            // Normal mode or module just caged (no culled)\r\n            // debt is obtained from CDP art\r\n            (,daiDebt) = vat.urns(ilk, address(this));\r\n        } else if (mode == Mode.MODULE_CULLED) {\r\n            // Module shutdown and culled\r\n            // debt is obtained from free collateral owned by this contract\r\n            daiDebt = vat.gem(ilk, address(this));\r\n        } else {\r\n            // MCD caged\r\n            // debt is obtained from free collateral owned by the End module\r\n            end = chainlog.getAddress(\"MCD_END\");\r\n            EndLike(end).skim(ilk, address(this));\r\n            daiDebt = vat.gem(ilk, address(end));\r\n        }\r\n\r\n        // Unwind amount is limited by how much:\r\n        // - max reduction desired\r\n        // - liquidity available\r\n        // - adai we have to withdraw\r\n        // - dai debt tracked in vat (CDP or free)\r\n        uint256 amount = _min(\r\n                            _min(\r\n                                _min(\r\n                                    supplyReduction,\r\n                                    availableLiquidity\r\n                                ),\r\n                                adaiBalance\r\n                            ),\r\n                            daiDebt\r\n                        );\r\n\r\n        // Determine the amount of fees to bring back\r\n        uint256 fees = 0;\r\n        if (adaiBalance > daiDebt) {\r\n            fees = adaiBalance - daiDebt;\r\n\r\n            if (_add(amount, fees) > availableLiquidity) {\r\n                // Don't need safe-math because this is constrained above\r\n                fees = availableLiquidity - amount;\r\n            }\r\n        }\r\n\r\n        if (amount == 0 && fees == 0) {\r\n            emit Unwind(0);\r\n            return;\r\n        }\r\n\r\n        require(amount <= 2 ** 255, \"DssDirectDepositAaveDai/overflow\");\r\n\r\n        // To save gas you can bring the fees back with the unwind\r\n        uint256 total = _add(amount, fees);\r\n        pool.withdraw(address(dai), total, address(this));\r\n        daiJoin.join(address(this), total);\r\n\r\n        // normalized debt == erc20 DAI to join (Vat rate for this ilk fixed to 1 RAY)\r\n\r\n        address vow = chainlog.getAddress(\"MCD_VOW\");\r\n        if (mode == Mode.NORMAL) {\r\n            vat.frob(ilk, address(this), address(this), address(this), -int256(amount), -int256(amount));\r\n            vat.slip(ilk, address(this), -int256(amount));\r\n            vat.move(address(this), vow, _mul(fees, RAY));\r\n        } else if (mode == Mode.MODULE_CULLED) {\r\n            vat.slip(ilk, address(this), -int256(amount));\r\n            vat.move(address(this), vow, _mul(total, RAY));\r\n        } else {\r\n            // This can be done with the assumption that the price of 1 aDai equals 1 DAI.\r\n            // That way we know that the prev End.skim call kept its gap[ilk] emptied as the CDP was always collateralized.\r\n            // Otherwise we couldn't just simply take away the collateral from the End module as the next line will be doing.\r\n            vat.slip(ilk, end, -int256(amount));\r\n            vat.move(address(this), vow, _mul(total, RAY));\r\n        }\r\n\r\n        emit Unwind(amount);\r\n    }\r\n\r\n    function exec() external {\r\n        uint256 availableLiquidity = dai.balanceOf(address(adai));\r\n\r\n        if (vat.live() == 0) {\r\n            // MCD caged\r\n            require(EndLike(chainlog.getAddress(\"MCD_END\")).debt() == 0, \"DssDirectDepositAaveDai/end-debt-already-set\");\r\n            require(culled == 0, \"DssDirectDepositAaveDai/module-has-to-be-unculled-first\");\r\n            _unwind(\r\n                type(uint256).max,\r\n                availableLiquidity,\r\n                Mode.MCD_CAGED\r\n            );\r\n        } else if (live == 0) {\r\n            // This module caged\r\n            _unwind(\r\n                type(uint256).max,\r\n                availableLiquidity,\r\n                culled == 1\r\n                ? Mode.MODULE_CULLED\r\n                : Mode.NORMAL\r\n            );\r\n        } else {\r\n            // Normal path\r\n            uint256 supplyAmount = _add(\r\n                                    availableLiquidity,\r\n                                    _add(\r\n                                        stableDebt.totalSupply(),\r\n                                        variableDebt.totalSupply()\r\n                                    )\r\n                                );\r\n            uint256 targetSupply = bar > 0 ? calculateTargetSupply(bar) : 0;\r\n\r\n            if (targetSupply > supplyAmount) {\r\n                _wind(targetSupply - supplyAmount);\r\n            } else if (targetSupply < supplyAmount) {\r\n                _unwind(\r\n                    supplyAmount - targetSupply,\r\n                    availableLiquidity,\r\n                    Mode.NORMAL\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    // --- Collect Interest ---\r\n    function reap() external {\r\n        require(vat.live() == 1, \"DssDirectDepositAaveDai/no-reap-during-shutdown\");\r\n        require(live == 1, \"DssDirectDepositAaveDai/no-reap-during-cage\");\r\n        uint256 adaiBalance = adai.balanceOf(address(this));\r\n        (, uint256 daiDebt) = vat.urns(ilk, address(this));\r\n        if (adaiBalance > daiDebt) {\r\n            uint256 fees = adaiBalance - daiDebt;\r\n            uint256 availableLiquidity = dai.balanceOf(address(adai));\r\n            if (fees > availableLiquidity) {\r\n                fees = availableLiquidity;\r\n            }\r\n            pool.withdraw(address(dai), fees, address(this));\r\n            daiJoin.join(address(chainlog.getAddress(\"MCD_VOW\")), fees);\r\n        }\r\n    }\r\n\r\n    // --- Collect any rewards ---\r\n    function collect(address[] memory assets, uint256 amount) external returns (uint256) {\r\n        require(king != address(0), \"DssDirectDepositAaveDai/king-not-set\");\r\n\r\n        return rewardsClaimer.claimRewards(assets, amount, king);\r\n    }\r\n\r\n    // --- Allow DAI holders to exit during global settlement ---\r\n    function exit(address usr, uint256 wad) external {\r\n        require(wad <= 2 ** 255, \"DssDirectDepositAaveDai/overflow\");\r\n        vat.slip(ilk, msg.sender, -int256(wad));\r\n        require(adai.transfer(usr, wad), \"DssDirectDepositAaveDai/failed-transfer\");\r\n    }\r\n\r\n    // --- Shutdown ---\r\n    function cage() external {\r\n        require(vat.live() == 1, \"DssDirectDepositAaveDai/no-cage-during-shutdown\");\r\n        // Can shut this down if we are authed\r\n        // or if the interest rate strategy changes\r\n        (,,,,,,,,,, address strategy,) = pool.getReserveData(address(dai));\r\n        require(\r\n            wards[msg.sender] == 1 ||\r\n            strategy != address(interestStrategy)\r\n        , \"DssDirectDepositAaveDai/not-authorized\");\r\n\r\n        live = 0;\r\n        tic = block.timestamp;\r\n        emit Cage();\r\n    }\r\n\r\n    // --- Write-off ---\r\n    function cull() external {\r\n        require(vat.live() == 1, \"DssDirectDepositAaveDai/no-cull-during-shutdown\");\r\n        require(live == 0, \"DssDirectDepositAaveDai/live\");\r\n        require(_add(tic, tau) <= block.timestamp || wards[msg.sender] == 1, \"DssDirectDepositAaveDai/unauthorized-cull\");\r\n        require(culled == 0, \"DssDirectDepositAaveDai/already-culled\");\r\n\r\n        (uint256 ink, uint256 art) = vat.urns(ilk, address(this));\r\n        require(ink <= 2 ** 255, \"DssDirectDepositAaveDai/overflow\");\r\n        require(art <= 2 ** 255, \"DssDirectDepositAaveDai/overflow\");\r\n        vat.grab(ilk, address(this), address(this), chainlog.getAddress(\"MCD_VOW\"), -int256(ink), -int256(art));\r\n\r\n        culled = 1;\r\n        emit Cull();\r\n    }\r\n\r\n    // --- Rollback Write-off (only if General Shutdown happened) ---\r\n    // This function is required to have the collateral back in the vault so it can be taken by End module\r\n    // and eventually be shared to DAI holders (as any other collateral) or maybe even unwinded\r\n    function uncull() external {\r\n        require(culled == 1, \"DssDirectDepositAaveDai/not-prev-culled\");\r\n        require(vat.live() == 0, \"DssDirectDepositAaveDai/no-uncull-normal-operation\");\r\n\r\n        uint256 wad = vat.gem(ilk, address(this));\r\n        require(wad < 2 ** 255, \"DssDirectDepositAaveDai/overflow\");\r\n        address vow = chainlog.getAddress(\"MCD_VOW\");\r\n        vat.suck(vow, vow, _mul(wad, RAY)); // This needs to be done to make sure we can deduct sin[vow] and vice in the next call\r\n        vat.grab(ilk, address(this), address(this), vow, int256(wad), int256(wad));\r\n\r\n        culled = 0;\r\n        emit Uncull();\r\n    }\r\n\r\n    // --- Emergency Quit Everything ---\r\n    function quit(address who) external auth {\r\n        require(vat.live() == 1, \"DssDirectDepositAaveDai/no-quit-during-shutdown\");\r\n\r\n        // Send all adai in the contract to who\r\n        require(adai.transfer(who, adai.balanceOf(address(this))), \"DssDirectDepositAaveDai/failed-transfer\");\r\n\r\n        if (culled == 1) {\r\n            // Culled - just zero out the gems\r\n            uint256 wad = vat.gem(ilk, address(this));\r\n            require(wad <= 2 ** 255, \"DssDirectDepositAaveDai/overflow\");\r\n            vat.slip(ilk, address(this), -int256(wad));\r\n        } else {\r\n            // Regular operation - transfer the debt position (requires who to accept the transfer)\r\n            (uint256 ink, uint256 art) = vat.urns(ilk, address(this));\r\n            require(ink < 2 ** 255, \"DssDirectDepositAaveDai/overflow\");\r\n            require(art < 2 ** 255, \"DssDirectDepositAaveDai/overflow\");\r\n            vat.fork(ilk, address(this), who, int256(ink), int256(art));\r\n        }\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"chainlog_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"ilk_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsClaimer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Cage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Cull\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Deny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"File\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"File\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Reap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Rely\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Uncull\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unwind\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Wind\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"adai\",\"outputs\":[{\"internalType\":\"contract TokenLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetInterestRate\",\"type\":\"uint256\"}],\"name\":\"calculateTargetSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainlog\",\"outputs\":[{\"internalType\":\"contract ChainlogLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"collect\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"culled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"contract TokenLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daiJoin\",\"outputs\":[{\"internalType\":\"contract DaiJoinLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dec\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exec\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"file\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"what\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"data\",\"type\":\"address\"}],\"name\":\"file\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gem\",\"outputs\":[{\"internalType\":\"contract TokenLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ilk\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interestStrategy\",\"outputs\":[{\"internalType\":\"contract InterestRateStrategyLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"king\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"live\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract LendingPoolLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"quit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsClaimer\",\"outputs\":[{\"internalType\":\"contract RewardsClaimerLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stableDebt\",\"outputs\":[{\"internalType\":\"contract TokenLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tau\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uncull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"variableDebt\",\"outputs\":[{\"internalType\":\"contract TokenLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vat\",\"outputs\":[{\"internalType\":\"contract VatLike\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DssDirectDepositAaveDai","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000da0ab1e0017debcd72be8599041a2aa3ba7e740f4449524543542d4141564556322d4441490000000000000000000000000000000000000000000000000000007d2768de32b0b80b7a3454c06bdac94a69ddc7a9000000000000000000000000d784927ff2f95ba542bfc824c8a8a98f3495f6b5","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":"ipfs://53816f62227854301045899cc71f50dc0b4294eb8ef0307d6fd6e8f182d1322f"}]}