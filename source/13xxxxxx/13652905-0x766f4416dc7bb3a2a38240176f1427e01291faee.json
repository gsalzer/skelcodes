{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/LinearVestingHubHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport {ILinearVestingHub} from \\\"./interfaces/ILinearVestingHub.sol\\\";\\nimport {Vesting} from \\\"./structs/SVesting.sol\\\";\\nimport {\\n    _getVestedTkns,\\n    _getTknMaxWithdraw\\n} from \\\"./functions/VestingFormulaFunctions.sol\\\";\\n\\ncontract LinearVestingHubHelper {\\n    // solhint-disable-next-line var-name-mixedcase\\n    ILinearVestingHub public immutable LINEAR_VESTING_HUB;\\n\\n    constructor(ILinearVestingHub linearVestingHub_) {\\n        LINEAR_VESTING_HUB = linearVestingHub_;\\n    }\\n\\n    function isLinearVestingHubHealthy() external view returns (bool) {\\n        return\\n            LINEAR_VESTING_HUB.TOKEN().balanceOf(address(LINEAR_VESTING_HUB)) ==\\n            calcTotalBalance();\\n    }\\n\\n    function getVestingsPaginated(\\n        address receiver_,\\n        uint256 startVestingId_,\\n        uint256 pageSize_\\n    ) external view returns (Vesting[] memory vestings) {\\n        uint256 nextVestingId = LINEAR_VESTING_HUB.nextVestingIdByReceiver(\\n            receiver_\\n        );\\n        uint256 endVestingId = nextVestingId > startVestingId_ + pageSize_\\n            ? startVestingId_ + pageSize_\\n            : nextVestingId;\\n        vestings = new Vesting[](endVestingId - startVestingId_);\\n\\n        uint8 j = 0;\\n        for (uint256 i = startVestingId_; i < endVestingId; i++) {\\n            vestings[j] = LINEAR_VESTING_HUB.vestingsByReceiver(receiver_, i);\\n            j++;\\n        }\\n    }\\n\\n    function getMaxWithdrawByVesting(address receiver_, uint256 vestingId_)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        try\\n            LINEAR_VESTING_HUB.vestingsByReceiver(receiver_, vestingId_)\\n        returns (Vesting memory vesting) {\\n            return\\n                vesting.receiver != address(0)\\n                    ? _getTknMaxWithdraw(\\n                        vesting.tokenBalance,\\n                        vesting.withdrawnTokens,\\n                        vesting.startTime,\\n                        vesting.cliffDuration,\\n                        vesting.duration\\n                    )\\n                    : 0;\\n        } catch {\\n            return 0;\\n        }\\n    }\\n\\n    function getMaxWithdrawByReceiver(address receiver_)\\n        public\\n        view\\n        returns (uint256 maxWithdraw)\\n    {\\n        uint256 nextVestingId = LINEAR_VESTING_HUB.nextVestingIdByReceiver(\\n            receiver_\\n        );\\n\\n        for (uint256 i = 0; i < nextVestingId; i++)\\n            maxWithdraw += getMaxWithdrawByVesting(receiver_, i);\\n    }\\n\\n    function getVestedTkn(address receiver_, uint256 vestingId_)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        try\\n            LINEAR_VESTING_HUB.vestingsByReceiver(receiver_, vestingId_)\\n        returns (Vesting memory vesting) {\\n            return\\n                vesting.receiver != address(0)\\n                    ? _getVestedTkns(\\n                        vesting.tokenBalance,\\n                        vesting.withdrawnTokens,\\n                        vesting.startTime,\\n                        vesting.duration\\n                    )\\n                    : 0;\\n        } catch {\\n            return 0;\\n        }\\n    }\\n\\n    function getUnvestedTkn(address receiver_, uint256 vestingId_)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        try\\n            LINEAR_VESTING_HUB.vestingsByReceiver(receiver_, vestingId_)\\n        returns (Vesting memory vesting) {\\n            return\\n                vesting.receiver != address(0)\\n                    ? vesting.tokenBalance -\\n                        _getTknMaxWithdraw(\\n                            vesting.tokenBalance,\\n                            vesting.withdrawnTokens,\\n                            vesting.startTime,\\n                            vesting.cliffDuration,\\n                            vesting.duration\\n                        )\\n                    : 0;\\n        } catch {\\n            return 0;\\n        }\\n    }\\n\\n    function calcTotalVestedTokens()\\n        public\\n        view\\n        returns (uint256 totalVestedTkn)\\n    {\\n        address[] memory receivers = LINEAR_VESTING_HUB.receivers();\\n\\n        for (uint256 i = 0; i < receivers.length; i++) {\\n            uint256 nextVestingId = LINEAR_VESTING_HUB.nextVestingIdByReceiver(\\n                receivers[i]\\n            );\\n            for (uint256 j = 0; j < nextVestingId; j++)\\n                totalVestedTkn += getVestedTkn(receivers[i], j);\\n        }\\n    }\\n\\n    function calcTotalUnvestedTokens()\\n        public\\n        view\\n        returns (uint256 totalUnvestedTkn)\\n    {\\n        address[] memory receivers = LINEAR_VESTING_HUB.receivers();\\n\\n        for (uint256 i = 0; i < receivers.length; i++) {\\n            uint256 nextVestingId = LINEAR_VESTING_HUB.nextVestingIdByReceiver(\\n                receivers[i]\\n            );\\n            for (uint256 j = 0; j < nextVestingId; j++)\\n                totalUnvestedTkn += getUnvestedTkn(receivers[i], j);\\n        }\\n    }\\n\\n    function getVestingBalance(address receiver_, uint256 vestingId_)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        try\\n            LINEAR_VESTING_HUB.vestingsByReceiver(receiver_, vestingId_)\\n        returns (Vesting memory vesting) {\\n            return vesting.receiver != address(0) ? vesting.tokenBalance : 0;\\n        } catch {\\n            return 0;\\n        }\\n    }\\n\\n    function calcTotalBalance() public view returns (uint256 totalBalance) {\\n        address[] memory receivers = LINEAR_VESTING_HUB.receivers();\\n\\n        for (uint256 i = 0; i < receivers.length; i++) {\\n            uint256 nextVestingId = LINEAR_VESTING_HUB.nextVestingIdByReceiver(\\n                receivers[i]\\n            );\\n            for (uint256 j = 0; j < nextVestingId; j++)\\n                totalBalance += getVestingBalance(receivers[i], j);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/functions/VestingFormulaFunctions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nfunction _getVestedTkns(\\n    uint256 tknBalance_,\\n    uint256 tknWithdrawn_,\\n    uint256 startDate_,\\n    uint256 duration_\\n) view returns (uint256) {\\n    if (block.timestamp < startDate_) return 0;\\n    if (block.timestamp >= startDate_ + duration_)\\n        return tknBalance_ + tknWithdrawn_;\\n    return\\n        ((tknBalance_ + tknWithdrawn_) * (block.timestamp - startDate_)) /\\n        duration_;\\n}\\n\\nfunction _getTknMaxWithdraw(\\n    uint256 tknBalance_,\\n    uint256 tknWithdrawn_,\\n    uint256 startDate_,\\n    uint256 cliffDuration_,\\n    uint256 duration_\\n) view returns (uint256) {\\n    // Vesting has not started and/or cliff has not passed\\n    if (block.timestamp < startDate_ + cliffDuration_) return 0;\\n\\n    uint256 vestedTkns = _getVestedTkns(\\n        tknBalance_,\\n        tknWithdrawn_,\\n        startDate_,\\n        duration_\\n    );\\n\\n    return vestedTkns > tknWithdrawn_ ? vestedTkns - tknWithdrawn_ : 0;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILinearVestingHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport {Vesting} from \\\"../structs/SVesting.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface ILinearVestingHub {\\n    // solhint-disable-next-line func-name-mixedcase\\n    function TOKEN() external view returns (IERC20);\\n\\n    function nextVestingIdByReceiver(address receiver_)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function vestingsByReceiver(address receiver_, uint256 id_)\\n        external\\n        view\\n        returns (Vesting memory);\\n\\n    function totalWithdrawn() external view returns (uint256);\\n\\n    function isReceiver(address receiver_) external view returns (bool);\\n\\n    function receiverAt(uint256 index_) external view returns (address);\\n\\n    function receivers() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/structs/SVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nstruct Vesting {\\n    uint8 id;\\n    address receiver;\\n    uint256 tokenBalance; // remaining token balance\\n    uint256 withdrawnTokens; //\\n    uint256 startTime; // vesting start time.\\n    uint256 cliffDuration; // lockup time.\\n    uint256 duration;\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract ILinearVestingHub\",\"name\":\"linearVestingHub_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"LINEAR_VESTING_HUB\",\"outputs\":[{\"internalType\":\"contract ILinearVestingHub\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcTotalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcTotalUnvestedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalUnvestedTkn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcTotalVestedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalVestedTkn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"}],\"name\":\"getMaxWithdrawByReceiver\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWithdraw\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vestingId_\",\"type\":\"uint256\"}],\"name\":\"getMaxWithdrawByVesting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vestingId_\",\"type\":\"uint256\"}],\"name\":\"getUnvestedTkn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vestingId_\",\"type\":\"uint256\"}],\"name\":\"getVestedTkn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vestingId_\",\"type\":\"uint256\"}],\"name\":\"getVestingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startVestingId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize_\",\"type\":\"uint256\"}],\"name\":\"getVestingsPaginated\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliffDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"internalType\":\"struct Vesting[]\",\"name\":\"vestings\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLinearVestingHubHealthy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LinearVestingHubHelper","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"0000000000000000000000004a7c7652abd5e5e3467c458e42493630aaa7ddd6","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}