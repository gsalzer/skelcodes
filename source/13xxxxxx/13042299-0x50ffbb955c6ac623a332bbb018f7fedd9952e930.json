{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/governance/BasketBalancer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\nimport \\\"../interfaces/IReign.sol\\\";\\nimport \\\"../interfaces/IPoolRouter.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract BasketBalancer {\\n    using SafeMath for uint256;\\n\\n    uint256 public fullAllocation;\\n    uint128 public lastEpochUpdate;\\n    uint256 public lastEpochEnd;\\n    uint256 public maxDelta;\\n\\n    address[] private allTokens;\\n\\n    mapping(address => uint256) public continuousVote;\\n    mapping(address => uint256) private tokenAllocation;\\n    mapping(address => uint256) private tokenAllocationBefore;\\n    mapping(address => mapping(uint128 => bool)) private votedInEpoch;\\n\\n    IReign private reign;\\n    address public poolRouter;\\n    address public reignDAO;\\n    address public reignDiamond;\\n\\n    event UpdateAllocation(\\n        uint128 indexed epoch,\\n        address indexed pool,\\n        uint256 indexed allocation\\n    );\\n    event VoteOnAllocation(\\n        address indexed sender,\\n        address indexed pool,\\n        uint256 indexed allocation,\\n        uint128 epoch\\n    );\\n\\n    event NewToken(address indexed pool, uint256 indexed allocation);\\n    event RemoveToken(address indexed pool);\\n\\n    modifier onlyDAO() {\\n        require(msg.sender == reignDAO, \\\"Only the DAO can execute this\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _reignDiamond,\\n        address _reignDAO,\\n        address _poolRouter,\\n        uint256 _maxDelta\\n    ) {\\n        uint256 amountAllocated = 0;\\n\\n        address[] memory tokens = IPoolRouter(_poolRouter).getPoolTokens();\\n        uint256[] memory weights = IPoolRouter(_poolRouter).getTokenWeights();\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            tokenAllocation[tokens[i]] = weights[i];\\n            tokenAllocationBefore[tokens[i]] = weights[i];\\n            continuousVote[tokens[i]] = weights[i];\\n            amountAllocated = amountAllocated.add(weights[i]);\\n        }\\n        fullAllocation = amountAllocated;\\n\\n        lastEpochUpdate = 0;\\n        maxDelta = _maxDelta;\\n        allTokens = tokens;\\n        reign = IReign(_reignDiamond);\\n        reignDiamond = _reignDiamond;\\n        reignDAO = _reignDAO;\\n        poolRouter = _poolRouter;\\n    }\\n\\n    // Counts votes and sets the outcome allocation for each pool,\\n    // can be called by anyone through DAO after an epoch ends.\\n    // The new allocation value is the average of the vote outcome and the current value\\n    function updateBasketBalance() public onlyDAO {\\n        uint128 _epochId = getCurrentEpoch();\\n        require(lastEpochUpdate < _epochId, \\\"Epoch is not over\\\");\\n\\n        for (uint256 i = 0; i < allTokens.length; i++) {\\n            uint256 _currentValue = continuousVote[allTokens[i]]; // new vote outcome\\n            uint256 _previousValue = tokenAllocation[allTokens[i]]; // before this vote\\n\\n            // the new current value is the average between the 2 values\\n            tokenAllocation[allTokens[i]] = (_currentValue.add(_previousValue))\\n                .div(2);\\n\\n            // update the previous value\\n            tokenAllocationBefore[allTokens[i]] = _previousValue;\\n\\n            emit UpdateAllocation(\\n                _epochId,\\n                allTokens[i],\\n                tokenAllocation[allTokens[i]]\\n            );\\n        }\\n\\n        lastEpochUpdate = _epochId;\\n        lastEpochEnd = block.timestamp;\\n    }\\n\\n    // Allows users to update their vote by giving a desired allocation for each pool\\n    // tokens and allocations need to share the index, pool at index 1 will get allocation at index 1\\n    function updateAllocationVote(\\n        address[] calldata tokens,\\n        uint256[] calldata allocations\\n    ) external {\\n        uint128 _epoch = getCurrentEpoch();\\n\\n        // Checks\\n        require(\\n            tokens.length == allTokens.length,\\n            \\\"Need to vote for all tokens\\\"\\n        );\\n        require(\\n            tokens.length == allocations.length,\\n            \\\"Need to have same length\\\"\\n        );\\n        require(reign.balanceOf(msg.sender) > 0, \\\"Not allowed to vote\\\");\\n\\n        require(\\n            votedInEpoch[msg.sender][_epoch] == false,\\n            \\\"Can not vote twice in an epoch\\\"\\n        );\\n\\n        // we take the voting power as it was at the end of the last epoch to avoid flashloan attacks\\n        // or users sending their stake to new wallets and vote again\\n        uint256 _votingPower = reign.votingPowerAtTs(msg.sender, lastEpochEnd);\\n        uint256 _totalPower = reign.reignStaked();\\n\\n        //users vote \\\"against\\\" all other users\\n        uint256 _remainingPower = _totalPower.sub(_votingPower);\\n\\n        uint256 amountAllocated = 0;\\n        for (uint256 i = 0; i < allTokens.length; i++) {\\n            //tokens need to have the same order as allTokens\\n            require(allTokens[i] == tokens[i], \\\"tokens have incorrect order\\\");\\n            uint256 _votedFor = allocations[i];\\n            uint256 _current = continuousVote[allTokens[i]];\\n            amountAllocated = amountAllocated.add(_votedFor);\\n\\n            // The difference between the voted for allocation and the current value can not exceed maxDelta\\n            if (_votedFor > _current) {\\n                require(_votedFor - _current <= maxDelta, \\\"Above Max Delta\\\");\\n            } else {\\n                require(_current - _votedFor <= maxDelta, \\\"Above Max Delta\\\");\\n            }\\n            // if all checks have passed, we update the allocation vote\\n            continuousVote[allTokens[i]] = (\\n                _current.mul(_remainingPower).add(_votedFor.mul(_votingPower))\\n            )\\n                .div(_totalPower);\\n\\n            //emit event for each token\\n            emit VoteOnAllocation(msg.sender, allTokens[i], _votedFor, _epoch);\\n        }\\n\\n        //transaction will revert if allocation is not complete\\n        require(\\n            amountAllocated == fullAllocation,\\n            \\\"Allocation is not complete\\\"\\n        );\\n\\n        // apply boost\\n        votedInEpoch[msg.sender][_epoch] = true;\\n    }\\n\\n    // adds a token to the baskte balancer\\n    // this mirrors the tokens in the pool both in allocation and order added\\n    // every time a token is added to the pool it needs to be added here as well\\n    function addToken(address token, uint256 allocation)\\n        external\\n        onlyDAO\\n        returns (uint256)\\n    {\\n        // add token and store allocation\\n        allTokens.push(token);\\n        tokenAllocationBefore[token] = allocation;\\n        tokenAllocation[token] = allocation;\\n        continuousVote[token] = allocation;\\n\\n        //update total allocation\\n        fullAllocation = fullAllocation.add(allocation);\\n\\n        emit NewToken(token, allocation);\\n\\n        return allTokens.length;\\n    }\\n\\n    // removes a token from the baskte balancer\\n    // every time a token is removed to the pool it needs to be removed here as well\\n    function removeToken(address token) external onlyDAO returns (uint256) {\\n        require(tokenAllocation[token] != 0, \\\"Token is not part of Basket\\\");\\n\\n        fullAllocation = fullAllocation.sub(continuousVote[token]);\\n\\n        //remove token from array, moving all others 1 down if necessary\\n        uint256 index;\\n        for (uint256 i = 0; i < allTokens.length; i++) {\\n            if (allTokens[i] == token) {\\n                index = i;\\n                break;\\n            }\\n        }\\n\\n        for (uint256 i = index; i < allTokens.length - 1; i++) {\\n            allTokens[i] = allTokens[i + 1];\\n        }\\n        allTokens.pop();\\n\\n        // reset allocations\\n        tokenAllocationBefore[token] = 0;\\n        tokenAllocation[token] = 0;\\n        continuousVote[token] = 0;\\n\\n        emit RemoveToken(token);\\n\\n        return allTokens.length;\\n    }\\n\\n    /*\\n     *   SETTERS\\n     */\\n\\n    function setRouter(address _poolRouter) public onlyDAO {\\n        poolRouter = _poolRouter;\\n    }\\n\\n    function setReignDAO(address _reignDAO) public onlyDAO {\\n        reignDAO = _reignDAO;\\n    }\\n\\n    function setMaxDelta(uint256 _maxDelta) public onlyDAO {\\n        maxDelta = _maxDelta;\\n    }\\n\\n    /*\\n     *   VIEWS\\n     */\\n\\n    // gets the current target allocation\\n    function getTargetAllocation(address pool) public view returns (uint256) {\\n        return tokenAllocation[pool];\\n    }\\n\\n    //Returns the id of the current epoch from reignDiamond\\n    function getCurrentEpoch() public view returns (uint128) {\\n        return reign.getCurrentEpoch();\\n    }\\n\\n    function getTokens() external view returns (address[] memory) {\\n        return allTokens;\\n    }\\n\\n    function hasVotedInEpoch(address user, uint128 epoch)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return votedInEpoch[user][epoch];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReign.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../libraries/LibReignStorage.sol\\\";\\n\\ninterface IReign {\\n    function BASE_MULTIPLIER() external view returns (uint256);\\n\\n    // deposit allows a user to add more bond to his staked balance\\n    function deposit(uint256 amount) external;\\n\\n    // withdraw allows a user to withdraw funds if the balance is not locked\\n    function withdraw(uint256 amount) external;\\n\\n    // lock a user's currently staked balance until timestamp & add the bonus to his voting power\\n    function lock(uint256 timestamp) external;\\n\\n    // delegate allows a user to delegate his voting power to another user\\n    function delegate(address to) external;\\n\\n    // stopDelegate allows a user to take back the delegated voting power\\n    function stopDelegate() external;\\n\\n    // lock the balance of a proposal creator until the voting ends; only callable by DAO\\n    function lockCreatorBalance(address user, uint256 timestamp) external;\\n\\n    // balanceOf returns the current BOND balance of a user (bonus not included)\\n    function balanceOf(address user) external view returns (uint256);\\n\\n    // balanceAtTs returns the amount of BOND that the user currently staked (bonus NOT included)\\n    function balanceAtTs(address user, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    // stakeAtTs returns the Stake object of the user that was valid at `timestamp`\\n    function stakeAtTs(address user, uint256 timestamp)\\n        external\\n        view\\n        returns (LibReignStorage.Stake memory);\\n\\n    // votingPower returns the voting power (bonus included) + delegated voting power for a user at the current block\\n    function votingPower(address user) external view returns (uint256);\\n\\n    // votingPowerAtTs returns the voting power (bonus included) + delegated voting power for a user at a point in time\\n    function votingPowerAtTs(address user, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    // bondStaked returns the total raw amount of BOND staked at the current block\\n    function reignStaked() external view returns (uint256);\\n\\n    // reignStakedAtTs returns the total raw amount of BOND users have deposited into the contract\\n    // it does not include any bonus\\n    function reignStakedAtTs(uint256 timestamp) external view returns (uint256);\\n\\n    // delegatedPower returns the total voting power that a user received from other users\\n    function delegatedPower(address user) external view returns (uint256);\\n\\n    // delegatedPowerAtTs returns the total voting power that a user received from other users at a point in time\\n    function delegatedPowerAtTs(address user, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    // stakingBoost calculates the multiplier on the user's stake at the current timestamp\\n    function stakingBoost(address user) external view returns (uint256);\\n\\n    // stackingBoostAtTs calculates the multiplier at a given timestamp based on the user's stake a the given timestamp\\n    function stackingBoostAtTs(address user, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    // userLockedUntil returns the timestamp until the user's balance is locked\\n    function userLockedUntil(address user) external view returns (uint256);\\n\\n    // userDidDelegate returns the address to which a user delegated their voting power; address(0) if not delegated\\n    function userDelegatedTo(address user) external view returns (address);\\n\\n    // returns the last timestamp in which the user intercated with the staking contarct\\n    function userLastAction(address user) external view returns (uint256);\\n\\n    // reignCirculatingSupply returns the current circulating supply of BOND\\n    function reignCirculatingSupply() external view returns (uint256);\\n\\n    function getEpochDuration() external view returns (uint256);\\n\\n    function getEpoch1Start() external view returns (uint256);\\n\\n    function getCurrentEpoch() external view returns (uint128);\\n\\n    function stakingBoostAtEpoch(address, uint128)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getEpochUserBalance(address, uint128)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\n\\ninterface IPoolRouter {\\n    // gets all tokens currently in the pool\\n    function getPoolTokens() external view returns (address[] memory);\\n\\n    // gets all tokens currently in the pool\\n    function getTokenWeights() external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibReignStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary LibReignStorage {\\n\\n    bytes32 constant STORAGE_POSITION = keccak256(\\\"org.sovreign.reign.storage\\\");\\n\\n    struct Checkpoint {\\n        uint256 timestamp;\\n        uint256 amount;\\n    }\\n\\n    struct EpochBalance {\\n        uint128 epochId;\\n        uint128 multiplier;\\n        uint256 startBalance;\\n        uint256 newDeposits;\\n    }\\n\\n    struct Stake {\\n        uint256 timestamp;\\n        uint256 amount;\\n        uint256 expiryTimestamp;\\n        address delegatedTo;\\n        uint256 stakingBoost;\\n    }\\n\\n    struct Storage {\\n        bool initialized;\\n        // mapping of user address to history of Stake objects\\n        // every user action creates a new object in the history\\n        mapping(address => Stake[]) userStakeHistory;\\n        mapping(address => EpochBalance[]) userBalanceHistory;\\n        mapping(address => uint128) lastWithdrawEpochId;\\n        // array of reign staked Checkpoint\\n        // deposits/withdrawals create a new object in the history (max one per block)\\n        Checkpoint[] reignStakedHistory;\\n        // mapping of user address to history of delegated power\\n        // every delegate/stopDelegate call create a new checkpoint (max one per block)\\n        mapping(address => Checkpoint[]) delegatedPowerHistory;\\n        IERC20 reign; // the reign Token\\n        uint256 epoch1Start;\\n        uint256 epochDuration;\\n    }\\n\\n    function reignStorage() internal pure returns (Storage storage ds) {\\n        bytes32 position = STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reignDiamond\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reignDAO\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poolRouter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxDelta\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"}],\"name\":\"NewToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"RemoveToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint128\",\"name\":\"epoch\",\"type\":\"uint128\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"}],\"name\":\"UpdateAllocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"epoch\",\"type\":\"uint128\"}],\"name\":\"VoteOnAllocation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"}],\"name\":\"addToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"continuousVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fullAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"getTargetAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"epoch\",\"type\":\"uint128\"}],\"name\":\"hasVotedInEpoch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastEpochEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastEpochUpdate\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDelta\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reignDAO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reignDiamond\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxDelta\",\"type\":\"uint256\"}],\"name\":\"setMaxDelta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reignDAO\",\"type\":\"address\"}],\"name\":\"setReignDAO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolRouter\",\"type\":\"address\"}],\"name\":\"setRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"allocations\",\"type\":\"uint256[]\"}],\"name\":\"updateAllocationVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateBasketBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"BasketBalancer","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000043fad3bd3fae2b445bcfd0d20acadc24ba12aec00000000000000000000000000bd5f7290eae951a13b935b4e7702dd05d50b8130000000000000000000000001297c4a1f9ce8623aa357cd6dbe2fd2640a42b010000000000000000000000000000000000000000000000001bc16d674ec80000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}