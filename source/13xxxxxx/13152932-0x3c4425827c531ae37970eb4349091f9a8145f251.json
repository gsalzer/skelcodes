{"status":"1","message":"OK","result":[{"SourceCode":"// File: ClubRare/Broker.sol\r\n\r\npragma solidity ^0.5.17;\r\npragma experimental ABIEncoderV2;\r\n\r\nlibrary TokenDetArrayLibV1 {\r\n    // Using for array of strcutres for storing mintable address and token id\r\n    using TokenDetArrayLibV1 for TokenDets;\r\n\r\n    struct TokenDet {\r\n        address NFTAddress;\r\n        uint256 tokenID;\r\n    }\r\n\r\n    // custom type array TokenDets\r\n    struct TokenDets {\r\n        TokenDet[] array;\r\n    }\r\n\r\n    /**\r\n     * @notice push an tokenDet to the array\r\n     * @dev if the address already exists, it will not be added again\r\n     * @param self Storage array containing tokenDet type variables\r\n     */\r\n    function addTokenDet(\r\n        TokenDets storage self,\r\n        address _mintableaddress,\r\n        uint256 _tokenID\r\n    ) public {\r\n        if (!self.exists(_mintableaddress, _tokenID)) {\r\n            self.array.push(TokenDet(_mintableaddress, _tokenID));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice get the tokenDet at a specific index from array\r\n     * @dev revert if the index is out of bounds\r\n     * @param self Storage array containing tokenDet type variables\r\n     */\r\n    function getIndexByTokenDet(\r\n        TokenDets storage self,\r\n        address _mintableaddress,\r\n        uint256 _tokenID\r\n    ) internal view returns (uint256, bool) {\r\n        uint256 index;\r\n        bool exists = false;\r\n        for (uint256 i = 0; i < self.array.length; i++) {\r\n            if (\r\n                self.array[i].NFTAddress == _mintableaddress &&\r\n                self.array[i].tokenID == _tokenID\r\n            ) {\r\n                index = i;\r\n                exists = true;\r\n                break;\r\n            }\r\n        }\r\n        return (index, exists);\r\n    }\r\n\r\n    /**\r\n     * @notice remove an tokenDet from the array\r\n     * @dev finds the tokenDet, swaps it with the last tokenDet, and then deletes it;\r\n     *      returns a boolean whether the tokenDet was found and deleted\r\n     * @param self Storage array containing tokenDet type variables\r\n     */\r\n    function removeTokenDet(\r\n        TokenDets storage self,\r\n        address _mintableaddress,\r\n        uint256 _tokenID\r\n    ) internal returns (bool) {\r\n        (uint256 i, bool exists) = self.getIndexByTokenDet(\r\n            _mintableaddress,\r\n            _tokenID\r\n        );\r\n        if (exists == true) {\r\n            self.array[i] = self.array[self.array.length - 1];\r\n            self.array.pop();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice check if an tokenDet exist in the array\r\n     * @param self Storage array containing tokenDet type variables\r\n     */\r\n    function exists(\r\n        TokenDets storage self,\r\n        address _mintableaddress,\r\n        uint256 _tokenID\r\n    ) internal view returns (bool) {\r\n        for (uint256 i = 0; i < self.array.length; i++) {\r\n            if (\r\n                self.array[i].NFTAddress == _mintableaddress &&\r\n                self.array[i].tokenID == _tokenID\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n// Interface of ERC721Receiver\r\ncontract IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes memory data\r\n    ) public returns (bytes4);\r\n}\r\n\r\n// Contract for Managing the ERC721 Holding\r\ncontract ERC721Holder is IERC721Receiver {\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes memory\r\n    ) public returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n// ERC721 Interface\r\ncontract IMintableToken {\r\n    // Required methods\r\n    function totalSupply() public view returns (uint256 total);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\r\n\r\n    function approve(address _to, uint256 _tokenId) external;\r\n\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external;\r\n\r\n    function royalities(uint256 _tokenId) public view returns (uint256);\r\n\r\n    function creators(uint256 _tokenId) public view returns (address payable);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public;\r\n\r\n    function getApproved(uint256 tokenId)\r\n        public\r\n        view\r\n        returns (address operator);\r\n\r\n    // Events\r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n// Broker Contract\r\ncontract Broker is ERC721Holder {\r\n    using TokenDetArrayLibV1 for TokenDetArrayLibV1.TokenDets;\r\n\r\n    // events\r\n    event Bid(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        address bidder,\r\n        uint256 amouont,\r\n        uint256 time\r\n    );\r\n    event Buy(\r\n        address indexed collection,\r\n        uint256 tokenId,\r\n        address indexed seller,\r\n        address indexed buyer,\r\n        uint256 amount,\r\n        uint256 time\r\n    );\r\n    event Collect(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        address buyer,\r\n        address collector,\r\n        uint256 time\r\n    );\r\n    event OnSale(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        uint256 auctionType,\r\n        uint256 amount,\r\n        uint256 time\r\n    );\r\n    event PriceUpdated(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        uint256 auctionType,\r\n        uint256 oldAmount,\r\n        uint256 amount,\r\n        uint256 time\r\n    );\r\n    event OffSale(\r\n        address indexed collection,\r\n        uint256 indexed tokenId,\r\n        address indexed seller,\r\n        uint256 time\r\n    );\r\n\r\n    address owner;\r\n    uint16 public brokerage;\r\n    mapping(address => mapping(uint256 => bool)) tokenOpenForSale;\r\n    mapping(address => TokenDetArrayLibV1.TokenDets) tokensForSalePerUser;\r\n\r\n    TokenDetArrayLibV1.TokenDets fixedPriceTokens;\r\n    TokenDetArrayLibV1.TokenDets auctionTokens;\r\n\r\n    //auction type :\r\n    // 1 : only direct buy\r\n    // 2 : only bid\r\n    // 3 : both buy and bid\r\n\r\n    struct auction {\r\n        address payable lastOwner;\r\n        uint256 currentBid;\r\n        address payable highestBidder;\r\n        uint256 auctionType;\r\n        uint256 startingPrice;\r\n        uint256 buyPrice;\r\n        bool buyer;\r\n        uint256 startingTime;\r\n        uint256 closingTime;\r\n    }\r\n\r\n    mapping(address => mapping(uint256 => auction)) public auctions;\r\n\r\n    TokenDetArrayLibV1.TokenDets tokensForSale;\r\n\r\n    constructor(uint16 _brokerage) public {\r\n        owner = msg.sender;\r\n        brokerage = _brokerage;\r\n    }\r\n\r\n    function getTokensForSale()\r\n        public\r\n        view\r\n        returns (TokenDetArrayLibV1.TokenDet[] memory)\r\n    {\r\n        return tokensForSale.array;\r\n    }\r\n\r\n    function getFixedPriceTokensForSale()\r\n        public\r\n        view\r\n        returns (TokenDetArrayLibV1.TokenDet[] memory)\r\n    {\r\n        return fixedPriceTokens.array;\r\n    }\r\n\r\n    function getAuctionTokensForSale()\r\n        public\r\n        view\r\n        returns (TokenDetArrayLibV1.TokenDet[] memory)\r\n    {\r\n        return auctionTokens.array;\r\n    }\r\n\r\n    function getTokensForSalePerUser(address _user)\r\n        public\r\n        view\r\n        returns (TokenDetArrayLibV1.TokenDet[] memory)\r\n    {\r\n        return tokensForSalePerUser[_user].array;\r\n    }\r\n\r\n    function setBrokerage(uint16 _brokerage) public onlyOwner {\r\n        brokerage = _brokerage;\r\n    }\r\n\r\n    function bid(uint256 tokenID, address _mintableToken) public payable {\r\n        IMintableToken Token = IMintableToken(_mintableToken);\r\n        require(\r\n            tokenOpenForSale[_mintableToken][tokenID] == true,\r\n            \"Token Not For Sale\"\r\n        );\r\n        require(\r\n            msg.value > auctions[_mintableToken][tokenID].currentBid,\r\n            \"Insufficient Payment\"\r\n        );\r\n        require(\r\n            block.timestamp < auctions[_mintableToken][tokenID].closingTime,\r\n            \"Auction Time Over!\"\r\n        );\r\n        require(\r\n            auctions[_mintableToken][tokenID].auctionType != 1,\r\n            \"Auction Not For Bid\"\r\n        );\r\n\r\n        if (auctions[_mintableToken][tokenID].buyer == true) {\r\n            auctions[_mintableToken][tokenID].highestBidder.transfer(\r\n                auctions[_mintableToken][tokenID].currentBid\r\n            );\r\n        }\r\n\r\n        Token.safeTransferFrom(Token.ownerOf(tokenID), address(this), tokenID);\r\n        auctions[_mintableToken][tokenID].currentBid = msg.value;\r\n        auctions[_mintableToken][tokenID].buyer = true;\r\n        auctions[_mintableToken][tokenID].highestBidder = msg.sender;\r\n\r\n        // Bid event\r\n        emit Bid(\r\n            _mintableToken,\r\n            tokenID,\r\n            auctions[_mintableToken][tokenID].lastOwner,\r\n            msg.sender,\r\n            msg.value,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function collect(uint256 tokenID, address _mintableToken) public {\r\n        IMintableToken Token = IMintableToken(_mintableToken);\r\n        // Check expiry time\r\n        require(\r\n            block.timestamp > auctions[_mintableToken][tokenID].closingTime,\r\n            \"Auction Not Over!\"\r\n        );\r\n        // Get seller of the NFT\r\n        address payable lastOwner2 = auctions[_mintableToken][tokenID]\r\n            .lastOwner;\r\n\r\n        // Check if this auction had even a single bid\r\n        if (auctions[_mintableToken][tokenID].buyer == true) {\r\n            // Get royality and creator of NFT from collection\r\n            uint256 royalities = Token.royalities(tokenID);\r\n            address payable creator = Token.creators(tokenID);\r\n\r\n            // auctions[_mintableToken][tokenID].buyPrice = uint256(0);\r\n            // NFT transfer\r\n            Token.safeTransferFrom(\r\n                Token.ownerOf(tokenID),\r\n                auctions[_mintableToken][tokenID].highestBidder,\r\n                tokenID\r\n            );\r\n            // Royality transfer\r\n            creator.transfer(\r\n                (royalities * auctions[_mintableToken][tokenID].currentBid) /\r\n                    10000\r\n            );\r\n            // Fund transfer after brockerage and royality charges\r\n            lastOwner2.transfer(\r\n                ((10000 - royalities - brokerage) *\r\n                    auctions[_mintableToken][tokenID].currentBid) / 10000\r\n            );\r\n\r\n            // Buy event\r\n            emit Buy(\r\n                _mintableToken,\r\n                tokenID,\r\n                lastOwner2,\r\n                auctions[_mintableToken][tokenID].highestBidder,\r\n                auctions[_mintableToken][tokenID].currentBid,\r\n                block.timestamp\r\n            );\r\n        }\r\n\r\n        // Disabling the on sale status\r\n        tokenOpenForSale[_mintableToken][tokenID] = false;\r\n        // Collect event\r\n        emit Collect(\r\n            _mintableToken,\r\n            tokenID,\r\n            lastOwner2,\r\n            auctions[_mintableToken][tokenID].highestBidder,\r\n            msg.sender,\r\n            block.timestamp\r\n        );\r\n\r\n        // Remove from sale list\r\n        tokensForSale.removeTokenDet(_mintableToken, tokenID);\r\n        // Remove from sale per user list\r\n        tokensForSalePerUser[lastOwner2].removeTokenDet(\r\n            _mintableToken,\r\n            tokenID\r\n        );\r\n        // Remove form auctions list\r\n        auctionTokens.removeTokenDet(_mintableToken, tokenID);\r\n        // Delete the auction details\r\n        delete auctions[_mintableToken][tokenID];\r\n    }\r\n\r\n    function buy(uint256 tokenID, address _mintableToken) public payable {\r\n        IMintableToken Token = IMintableToken(_mintableToken);\r\n        require(\r\n            tokenOpenForSale[_mintableToken][tokenID] == true,\r\n            \"Token Not For Sale\"\r\n        );\r\n        require(\r\n            msg.value >= auctions[_mintableToken][tokenID].buyPrice,\r\n            \"Insufficient Payment\"\r\n        );\r\n        require(\r\n            auctions[_mintableToken][tokenID].auctionType != 2,\r\n            \"Auction for Bid only!\"\r\n        );\r\n        address payable lastOwner2 = auctions[_mintableToken][tokenID]\r\n            .lastOwner;\r\n        uint256 royalities = Token.royalities(tokenID);\r\n        address payable creator = Token.creators(tokenID);\r\n\r\n        tokenOpenForSale[_mintableToken][tokenID] = false;\r\n        auctions[_mintableToken][tokenID].buyer = true;\r\n        auctions[_mintableToken][tokenID].highestBidder = msg.sender;\r\n        auctions[_mintableToken][tokenID].currentBid = auctions[_mintableToken][\r\n            tokenID\r\n        ].buyPrice;\r\n\r\n        Token.safeTransferFrom(\r\n            Token.ownerOf(tokenID),\r\n            auctions[_mintableToken][tokenID].highestBidder,\r\n            tokenID\r\n        );\r\n        creator.transfer(\r\n            (royalities * auctions[_mintableToken][tokenID].currentBid) / 10000\r\n        );\r\n        lastOwner2.transfer(\r\n            ((10000 - royalities - brokerage) *\r\n                auctions[_mintableToken][tokenID].currentBid) / 10000\r\n        );\r\n\r\n        // Buy event\r\n        emit Buy(\r\n            _mintableToken,\r\n            tokenID,\r\n            lastOwner2,\r\n            msg.sender,\r\n            auctions[_mintableToken][tokenID].buyPrice,\r\n            block.timestamp\r\n        );\r\n\r\n        tokensForSale.removeTokenDet(_mintableToken, tokenID);\r\n\r\n        tokensForSalePerUser[lastOwner2].removeTokenDet(\r\n            _mintableToken,\r\n            tokenID\r\n        );\r\n\r\n        fixedPriceTokens.removeTokenDet(_mintableToken, tokenID);\r\n    }\r\n\r\n    function withdraw() public onlyOwner {\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n\r\n    function putOnSale(\r\n        uint256 _tokenID,\r\n        uint256 _startingPrice,\r\n        uint256 _auctionType,\r\n        uint256 _buyPrice,\r\n        uint256 _duration,\r\n        address _mintableToken\r\n    ) public {\r\n        IMintableToken Token = IMintableToken(_mintableToken);\r\n        require(Token.ownerOf(_tokenID) == msg.sender, \"Permission Denied\");\r\n        require(\r\n            Token.getApproved(_tokenID) == address(this),\r\n            \"Broker Not approved\"\r\n        );\r\n        // Allow to put on sale to already on sale NFT \\\r\n        // only if it was on auction and have 0 bids and auction is over\r\n        if (tokenOpenForSale[_mintableToken][_tokenID] == true) {\r\n            require(\r\n                auctions[_mintableToken][_tokenID].auctionType == 2 &&\r\n                    auctions[_mintableToken][_tokenID].buyer == false &&\r\n                    block.timestamp >\r\n                    auctions[_mintableToken][_tokenID].closingTime,\r\n                \"This NFT is already on sale.\"\r\n            );\r\n        }\r\n\r\n        auction memory newAuction = auction(\r\n            msg.sender,\r\n            _startingPrice,\r\n            address(0),\r\n            _auctionType,\r\n            _startingPrice,\r\n            _buyPrice,\r\n            false,\r\n            block.timestamp,\r\n            block.timestamp + _duration\r\n        );\r\n\r\n        auctions[_mintableToken][_tokenID] = newAuction;\r\n\r\n        // Store data in all mappings if adding fresh token on sale\r\n        if (tokenOpenForSale[_mintableToken][_tokenID] == false) {\r\n            tokenOpenForSale[_mintableToken][_tokenID] = true;\r\n\r\n            tokensForSale.addTokenDet(_mintableToken, _tokenID);\r\n            tokensForSalePerUser[msg.sender].addTokenDet(\r\n                _mintableToken,\r\n                _tokenID\r\n            );\r\n\r\n            // Add token to fixedPrice on Timed list\r\n            if (_auctionType == 1) {\r\n                fixedPriceTokens.addTokenDet(_mintableToken, _tokenID);\r\n            } else if (_auctionType == 2) {\r\n                auctionTokens.addTokenDet(_mintableToken, _tokenID);\r\n            }\r\n        }\r\n\r\n        // OnSale event\r\n        emit OnSale(\r\n            _mintableToken,\r\n            _tokenID,\r\n            msg.sender,\r\n            _auctionType,\r\n            _auctionType == 1 ? _buyPrice : _startingPrice,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function updatePrice(\r\n        uint256 tokenID,\r\n        address _mintableToken,\r\n        uint256 _newPrice\r\n    ) public {\r\n        IMintableToken Token = IMintableToken(_mintableToken);\r\n        // Sender will be owner only if no have bidded on auction.\r\n        require(\r\n            Token.ownerOf(tokenID) == msg.sender,\r\n            \"You must be owner and Token should not have any bid\"\r\n        );\r\n        require(\r\n            tokenOpenForSale[_mintableToken][tokenID] == true,\r\n            \"Token Must be on sale to change price\"\r\n        );\r\n        if (auctions[_mintableToken][tokenID].auctionType == 2) {\r\n            require(\r\n                block.timestamp < auctions[_mintableToken][tokenID].closingTime,\r\n                \"Auction Time Over!\"\r\n            );\r\n        }\r\n        // Trigger event PriceUpdated with Old and new price\r\n        emit PriceUpdated(\r\n            _mintableToken,\r\n            tokenID,\r\n            auctions[_mintableToken][tokenID].lastOwner,\r\n            auctions[_mintableToken][tokenID].auctionType,\r\n            auctions[_mintableToken][tokenID].auctionType == 1\r\n                ? auctions[_mintableToken][tokenID].buyPrice\r\n                : auctions[_mintableToken][tokenID].startingPrice,\r\n            _newPrice,\r\n            block.timestamp\r\n        );\r\n        // Update Price\r\n        if (auctions[_mintableToken][tokenID].auctionType == 1) {\r\n            auctions[_mintableToken][tokenID].buyPrice = _newPrice;\r\n        } else {\r\n            auctions[_mintableToken][tokenID].startingPrice = _newPrice;\r\n            auctions[_mintableToken][tokenID].currentBid = _newPrice;\r\n        }\r\n    }\r\n\r\n    function putSaleOff(uint256 tokenID, address _mintableToken) public {\r\n        IMintableToken Token = IMintableToken(_mintableToken);\r\n        require(Token.ownerOf(tokenID) == msg.sender, \"Permission Denied\");\r\n        auctions[_mintableToken][tokenID].buyPrice = uint256(0);\r\n        tokenOpenForSale[_mintableToken][tokenID] = false;\r\n\r\n        // OffSale event\r\n        emit OffSale(_mintableToken, tokenID, msg.sender, block.timestamp);\r\n\r\n        tokensForSale.removeTokenDet(_mintableToken, tokenID);\r\n\r\n        tokensForSalePerUser[msg.sender].removeTokenDet(\r\n            _mintableToken,\r\n            tokenID\r\n        );\r\n        // Remove token from list\r\n        if (auctions[_mintableToken][tokenID].auctionType == 1) {\r\n            fixedPriceTokens.removeTokenDet(_mintableToken, tokenID);\r\n        } else if (auctions[_mintableToken][tokenID].auctionType == 2) {\r\n            auctionTokens.removeTokenDet(_mintableToken, tokenID);\r\n        }\r\n    }\r\n\r\n    function getOnSaleStatus(address _mintableToken, uint256 tokenID)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return tokenOpenForSale[_mintableToken][tokenID];\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function() external payable {\r\n        //call your function here / implement your actions\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_brokerage\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amouont\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Bid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"Collect\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"OffSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"OnSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"PriceUpdated\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctions\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"lastOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currentBid\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"highestBidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"auctionType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"buyer\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"startingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closingTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_mintableToken\",\"type\":\"address\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"brokerage\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_mintableToken\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_mintableToken\",\"type\":\"address\"}],\"name\":\"collect\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAuctionTokensForSale\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"NFTAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenDetArrayLibV1.TokenDet[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFixedPriceTokensForSale\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"NFTAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenDetArrayLibV1.TokenDet[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mintableToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"getOnSaleStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokensForSale\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"NFTAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenDetArrayLibV1.TokenDet[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTokensForSalePerUser\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"NFTAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenDetArrayLibV1.TokenDet[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_auctionType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_mintableToken\",\"type\":\"address\"}],\"name\":\"putOnSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_mintableToken\",\"type\":\"address\"}],\"name\":\"putSaleOff\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_brokerage\",\"type\":\"uint16\"}],\"name\":\"setBrokerage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_mintableToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"updatePrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Broker","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000fa","EVMVersion":"Default","Library":"TokenDetArrayLibV1:e851ad98f07fd75a99fd5b17c0007bc587c697de","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f976428e1fde39324347d3a4e7809136ded1124dea3745091f13c25262e05e1c"}]}