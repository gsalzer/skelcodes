{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Molecules.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./interfaces/IAtomReader.sol\\\";\\r\\nimport \\\"./interfaces/IPOWNFT.sol\\\";\\r\\nimport \\\"./interfaces/IERC721TokenReceiver.sol\\\";\\r\\n\\r\\nimport \\\"./libraries/Base64.sol\\\";\\r\\n\\r\\ncontract Molecules{\\r\\n\\r\\n    IAtomReader atomReader;\\r\\n    IPOWNFT pownft;\\r\\n\\r\\n    bytes32[] TOKENS;\\r\\n\\r\\n    string[10] _subscripts = [\\r\\n        unicode\\\"₀\\\",\\r\\n        unicode\\\"₁\\\",\\r\\n        unicode\\\"₂\\\",\\r\\n        unicode\\\"₃\\\",\\r\\n        unicode\\\"₄\\\",\\r\\n        unicode\\\"₅\\\",\\r\\n        unicode\\\"₆\\\",\\r\\n        unicode\\\"₇\\\",\\r\\n        unicode\\\"₈\\\",\\r\\n        unicode\\\"₉\\\"\\r\\n    ];\\r\\n    string[119] elements = [ \\\"\\\", \\\"H\\\",\\\"He\\\", \\\"Li\\\", \\\"Be\\\", \\\"B\\\", \\\"C\\\",\\\"N\\\", \\\"O\\\", \\\"F\\\", \\\"Ne\\\", \\\"Na\\\",\\\"Mg\\\", \\\"Al\\\", \\\"Si\\\", \\\"P\\\", \\\"S\\\",\\\"Cl\\\", \\\"Ar\\\", \\\"K\\\", \\\"Ca\\\", \\\"Sc\\\",\\\"Ti\\\", \\\"V\\\", \\\"Cr\\\", \\\"Mn\\\", \\\"Fe\\\",\\\"Co\\\", \\\"Ni\\\", \\\"Cu\\\", \\\"Zn\\\", \\\"Ga\\\",\\\"Ge\\\", \\\"As\\\", \\\"Se\\\", \\\"Br\\\", \\\"Kr\\\",\\\"Rb\\\", \\\"Sr\\\", \\\"Y\\\", \\\"Zr\\\", \\\"Nb\\\",\\\"Mo\\\", \\\"Tc\\\", \\\"Ru\\\", \\\"Rh\\\", \\\"Pd\\\",\\\"Ag\\\", \\\"Cd\\\", \\\"In\\\", \\\"Sn\\\", \\\"Sb\\\",\\\"Te\\\", \\\"I\\\", \\\"Xe\\\", \\\"Cs\\\", \\\"Ba\\\",\\\"La\\\", \\\"Ce\\\", \\\"Pr\\\", \\\"Nd\\\", \\\"Pm\\\",\\\"Sm\\\", \\\"Eu\\\", \\\"Gd\\\", \\\"Tb\\\", \\\"Dy\\\",\\\"Ho\\\", \\\"Er\\\", \\\"Tm\\\", \\\"Yb\\\", \\\"Lu\\\",\\\"Hf\\\", \\\"Ta\\\", \\\"W\\\", \\\"Re\\\", \\\"Os\\\",\\\"Ir\\\", \\\"Pt\\\", \\\"Au\\\", \\\"Hg\\\", \\\"Tl\\\",\\\"Pb\\\", \\\"Bi\\\", \\\"Po\\\", \\\"At\\\", \\\"Rn\\\",\\\"Fr\\\", \\\"Ra\\\", \\\"Ac\\\", \\\"Th\\\", \\\"Pa\\\",\\\"U\\\", \\\"Np\\\", \\\"Pu\\\", \\\"Am\\\", \\\"Cm\\\",\\\"Bk\\\", \\\"Cf\\\", \\\"Es\\\", \\\"Fm\\\", \\\"Md\\\",\\\"No\\\", \\\"Lr\\\", \\\"Rf\\\", \\\"Db\\\", \\\"Sg\\\",\\\"Bh\\\", \\\"Hs\\\", \\\"Mt\\\", \\\"Ds\\\", \\\"Rg\\\",\\\"Cn\\\", \\\"Nh\\\", \\\"Fl\\\", \\\"Mc\\\", \\\"Lv\\\",\\\"Ts\\\", \\\"Og\\\"];\\r\\n\\r\\n    mapping(bytes32 => uint8[32]) configs;\\r\\n\\r\\n\\r\\n    address _contractOwner;\\r\\n\\r\\n    constructor(address _pownft, address _atomReader){\\r\\n        atomReader = IAtomReader(_atomReader);\\r\\n        pownft = IPOWNFT(_pownft);\\r\\n\\r\\n        _contractOwner = msg.sender;\\r\\n\\r\\n        supportedInterfaces[0x80ac58cd] = true; //ERC721\\r\\n        supportedInterfaces[0x5b5e139f] = true; //ERC721Metadata\\r\\n        supportedInterfaces[0x780e9d63] = true; //ERC721Enumerable\\r\\n        supportedInterfaces[0x01ffc9a7] = true; //ERC165\\r\\n    }\\r\\n\\r\\n    function switchOwner(address newOwner) public onlyOwner{\\r\\n        _contractOwner = newOwner;\\r\\n    }\\r\\n    function owner() public view returns (address) {\\r\\n        return _contractOwner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_contractOwner == msg.sender, \\\"owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function initMolecules(uint8[][] calldata composition) public onlyOwner {\\r\\n        for(uint i = 0; i < composition.length; i++){\\r\\n            configs[configId(composition[i])] = toFixedLength(composition[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function configId(uint8[] memory composition) internal pure returns(bytes32) {\\r\\n            return keccak256(abi.encode(composition));\\r\\n    }\\r\\n    function toFixedLength(uint8[] memory composition) internal pure returns(uint8[32] memory){\\r\\n        uint8[32] memory _fixed;\\r\\n        for(uint j = 0; j < composition.length; j++){\\r\\n            require(composition[j] > 0 && composition[j] <= 118,\\\"bad element\\\");\\r\\n            _fixed[j] = composition[j];\\r\\n        }\\r\\n        return _fixed;\\r\\n    }\\r\\n    function fromFixedLength(uint8[32] memory _fixed) internal pure returns(uint8[] memory){\\r\\n        uint8[] memory _composition;\\r\\n        for(uint j = 32; j > 0; j--){\\r\\n            if(_composition.length > 0){\\r\\n                _composition[j - 1] = _fixed[j - 1];\\r\\n            }else if(_fixed[j - 1] != 0){\\r\\n                _composition = new uint8[](j);\\r\\n                _composition[j - 1] = _fixed[j - 1];\\r\\n            }\\r\\n        }\\r\\n        return _composition;\\r\\n    }\\r\\n\\r\\n    function moleculeOf(uint _tokenId) public view returns(string memory){\\r\\n        require(_tokenId > 0 && _tokenId <= TOKENS.length,\\\"exists\\\");\\r\\n        return _getFormula(fromFixedLength(configs[TOKENS[_tokenId - 1]]));\\r\\n    }\\r\\n\\r\\n    function checkFormula(uint8[] calldata _composition) public view returns(string memory){\\r\\n        require(configs[ configId(_composition)][0] != 0,\\\"Molecule does not exist\\\");\\r\\n        return _getFormula(_composition);\\r\\n    }\\r\\n\\r\\n    function _getFormula(uint8[] memory _config) internal view returns(string memory){\\r\\n        uint8 last;\\r\\n        uint8 count = 0;\\r\\n        string memory _formula;\\r\\n        for(uint i = 0; i < _config.length; i++){\\r\\n            if(_config[i] == last){\\r\\n                count++;\\r\\n            }else{\\r\\n                if(count > 1){\\r\\n                    _formula = string(abi.encodePacked(_formula,subscript(count),elements[_config[i]]));\\r\\n                }else{\\r\\n                    _formula = string(abi.encodePacked(_formula,elements[_config[i]]));\\r\\n                }\\r\\n                count = 1;\\r\\n                last = _config[i];\\r\\n            }\\r\\n        }\\r\\n        if(count > 1){\\r\\n            _formula = string(abi.encodePacked(_formula,subscript(count)));\\r\\n        }\\r\\n\\r\\n        return _formula;\\r\\n    }\\r\\n    function subscript(uint value) internal view returns(string memory){\\r\\n        if (value == 0) {\\r\\n            return _subscripts[0];\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n\\r\\n        bytes memory _subscript = \\\"\\\";\\r\\n        while (value != 0) {\\r\\n            _subscript = abi.encodePacked(_subscripts[value%10],_subscript);\\r\\n            value /= 10;\\r\\n        }\\r\\n        return string(_subscript);\\r\\n    }\\r\\n\\r\\n    function myMolecules(uint start_index, uint limit) public view returns(uint[] memory tokenIds, string[] memory formulas){\\r\\n        uint balance = this.balanceOf(msg.sender);\\r\\n        if(balance == 0){\\r\\n            uint[] memory __tokenIds;\\r\\n            string[] memory __formulas;\\r\\n            return (__tokenIds,__formulas);\\r\\n        }\\r\\n        require(start_index < balance,\\\"Invalid start index\\\");\\r\\n\\r\\n        uint sampleSize = balance - start_index;\\r\\n        if(limit != 0 && sampleSize > limit){\\r\\n            sampleSize = limit;\\r\\n        }\\r\\n\\r\\n        uint[] memory _tokenIds   = new uint[](sampleSize);\\r\\n        string[] memory _formulas = new string[](sampleSize);\\r\\n\\r\\n        for(uint i = 0; i < sampleSize; i++){\\r\\n            _tokenIds[i] = tokenOfOwnerByIndex(msg.sender,i + start_index);\\r\\n            _formulas[i] = moleculeOf(_tokenIds[i]);\\r\\n        }\\r\\n\\r\\n        return (_tokenIds, _formulas);\\r\\n    }\\r\\n\\r\\n    function myAtoms(uint start_index, uint limit) public view returns(uint[] memory tokenIds, uint8[] memory atomicNumbers){\\r\\n        uint balance = pownft.balanceOf(msg.sender);\\r\\n        if(balance == 0){\\r\\n            uint[] memory __tokenIds;\\r\\n            uint8[] memory __atomicNumbers;\\r\\n            return (__tokenIds,__atomicNumbers);\\r\\n        }\\r\\n        require(start_index < balance,\\\"Invalid start index\\\");\\r\\n        uint sampleSize = balance - start_index;\\r\\n        if(limit != 0 && sampleSize > limit){\\r\\n            sampleSize = limit;\\r\\n        }\\r\\n\\r\\n        uint[] memory _tokenIds       = new uint[](sampleSize);\\r\\n        uint8[] memory _atomicNumbers = new uint8[](sampleSize);\\r\\n\\r\\n        for(uint i = 0; i < sampleSize; i++){\\r\\n            _tokenIds[i] = pownft.tokenOfOwnerByIndex(msg.sender,i + start_index);\\r\\n            _atomicNumbers[i] = uint8(atomReader.getAtomicNumber(_tokenIds[i]));\\r\\n        }\\r\\n\\r\\n        return (_tokenIds, _atomicNumbers);\\r\\n    }\\r\\n\\r\\n\\r\\n    function claim(uint[] calldata _atomIds) public{\\r\\n        require(TOKENS.length < pownft.totalSupply(),\\\"totalSupply\\\");\\r\\n\\r\\n        uint8[] memory _composition = new uint8[](_atomIds.length);\\r\\n\\r\\n        for(uint i = 0; i < _atomIds.length; i++){\\r\\n            for(uint j = 0; j < i; j++){\\r\\n                require(_atomIds[i] != _atomIds[j],\\\"reuse\\\");\\r\\n            }\\r\\n            _composition[i] = uint8(atomReader.getAtomicNumber(_atomIds[i]));\\r\\n\\r\\n            require(pownft.ownerOf(_atomIds[i]) == msg.sender,\\\"owner\\\");\\r\\n        }\\r\\n        bytes32 _configId = configId(_composition);\\r\\n        require(configs[_configId][0] != 0,\\\"Molecule does not exist\\\");\\r\\n\\r\\n\\r\\n        TOKENS.push(_configId);\\r\\n\\r\\n        uint tokenId = TOKENS.length;\\r\\n\\r\\n        //Normal ERC721 mint stuff\\r\\n        OWNERS[tokenId] = msg.sender;\\r\\n        BALANCES[msg.sender]++;\\r\\n        OWNER_ID_TO_INDEX[tokenId] = OWNER_INDEX_TO_ID[msg.sender].length;\\r\\n        OWNER_INDEX_TO_ID[msg.sender].push(tokenId);\\r\\n\\r\\n        emit Transfer(address(0),msg.sender,tokenId);\\r\\n    }\\r\\n\\r\\n\\r\\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\\r\\n        require(OWNERS[tokenId] != address(0),\\\"invalid\\\");\\r\\n\\r\\n        string[3] memory parts;\\r\\n        string memory formula = _getFormula(fromFixedLength(configs[TOKENS[tokenId - 1]]));\\r\\n\\r\\n        parts[0] = '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 350 350\\\"><style>.base { fill: white; font-family: sans-serif; font-size: 30px; text-anchor: middle; dominant-baseline: central;}</style><rect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"black\\\" /><text x=\\\"175\\\" y=\\\"175\\\" class=\\\"base\\\">';\\r\\n        parts[1] = formula;\\r\\n        parts[2] = '</text></svg>';\\r\\n\\r\\n        string memory output = string(abi.encodePacked(parts[0], parts[1], parts[2]));\\r\\n        string memory json = Base64.encode(bytes(string(abi.encodePacked('{\\\"name\\\": \\\"#', toString(tokenId), ' ',formula,'\\\", \\\"description\\\": \\\"POW NFT Molecules are made by combining POW NFT Atoms.\\\", \\\"attributes\\\":[{\\\"trait_type\\\":\\\"Formula\\\",\\\"value\\\":\\\"',formula,'\\\"}], \\\"image\\\": \\\"data:image/svg+xml;base64,', Base64.encode(bytes(output)), '\\\"}'))));\\r\\n        output = string(abi.encodePacked('data:application/json;base64,', json));\\r\\n        return output;\\r\\n    }\\r\\n\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        // Inspired by OraclizeAPI's implementation - MIT license\\r\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        while (value != 0) {\\r\\n            digits -= 1;\\r\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\r\\n            value /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    // NORMAL STUFF\\r\\n\\r\\n    //////===721 Standard\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\r\\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\r\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\r\\n\\r\\n    //////===721 Implementation\\r\\n    mapping(address => uint256) internal BALANCES;\\r\\n    mapping (uint256 => address) internal ALLOWANCE;\\r\\n    mapping (address => mapping (address => bool)) internal AUTHORISED;\\r\\n\\r\\n    mapping(uint256 => address) OWNERS;  //Mapping of owners\\r\\n\\r\\n\\r\\n    //    ENUMERABLE VARS\\r\\n    mapping(address => uint[]) internal OWNER_INDEX_TO_ID;\\r\\n    mapping(uint => uint) internal OWNER_ID_TO_INDEX;\\r\\n\\r\\n    function isValidToken(uint256 _tokenId) internal view returns(bool){\\r\\n        return OWNERS[_tokenId] != address(0);\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _owner) external view returns (uint256){\\r\\n        return BALANCES[_owner];\\r\\n    }\\r\\n\\r\\n    function ownerOf(uint256 _tokenId) public view returns(address){\\r\\n        require(isValidToken(_tokenId),\\\"invalid\\\");\\r\\n        return OWNERS[_tokenId];\\r\\n    }\\r\\n\\r\\n\\r\\n    function approve(address _approved, uint256 _tokenId)  external{\\r\\n        address _owner = ownerOf(_tokenId);\\r\\n        require( _owner == msg.sender                    //Require Sender Owns Token\\r\\n            || AUTHORISED[_owner][msg.sender]                //  or is approved for all.\\r\\n        ,\\\"permission\\\");\\r\\n        emit Approval(_owner, _approved, _tokenId);\\r\\n        ALLOWANCE[_tokenId] = _approved;\\r\\n    }\\r\\n\\r\\n    function getApproved(uint256 _tokenId) external view returns (address) {\\r\\n        require(isValidToken(_tokenId),\\\"invalid\\\");\\r\\n        return ALLOWANCE[_tokenId];\\r\\n    }\\r\\n\\r\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\\r\\n        return AUTHORISED[_owner][_operator];\\r\\n    }\\r\\n\\r\\n\\r\\n    function setApprovalForAll(address _operator, bool _approved) external {\\r\\n        emit ApprovalForAll(msg.sender,_operator, _approved);\\r\\n        AUTHORISED[msg.sender][_operator] = _approved;\\r\\n    }\\r\\n\\r\\n\\r\\n    function transferFrom(address _from, address _to, uint256 _tokenId) public {\\r\\n\\r\\n        //Check Transferable\\r\\n        //There is a token validity check in ownerOf\\r\\n        address _owner = ownerOf(_tokenId);\\r\\n\\r\\n        require ( _owner == msg.sender             //Require sender owns token\\r\\n        //Doing the two below manually instead of referring to the external methods saves gas\\r\\n        || ALLOWANCE[_tokenId] == msg.sender      //or is approved for this token\\r\\n            || AUTHORISED[_owner][msg.sender]          //or is approved for all\\r\\n        ,\\\"permission\\\");\\r\\n        require(_owner == _from,\\\"owner\\\");\\r\\n        require(_to != address(0),\\\"zero\\\");\\r\\n\\r\\n        emit Transfer(_from, _to, _tokenId);\\r\\n\\r\\n\\r\\n        OWNERS[_tokenId] =_to;\\r\\n\\r\\n        BALANCES[_from]--;\\r\\n        BALANCES[_to]++;\\r\\n\\r\\n        //Reset approved if there is one\\r\\n        if(ALLOWANCE[_tokenId] != address(0)){\\r\\n            delete ALLOWANCE[_tokenId];\\r\\n        }\\r\\n\\r\\n        //Enumerable Additions\\r\\n        uint oldIndex = OWNER_ID_TO_INDEX[_tokenId];\\r\\n        //If the token isn't the last one in the owner's index\\r\\n        if(oldIndex != OWNER_INDEX_TO_ID[_from].length - 1){\\r\\n            //Move the old one in the index list\\r\\n            OWNER_INDEX_TO_ID[_from][oldIndex] = OWNER_INDEX_TO_ID[_from][OWNER_INDEX_TO_ID[_from].length - 1];\\r\\n            //Update the token's reference to its place in the index list\\r\\n            OWNER_ID_TO_INDEX[OWNER_INDEX_TO_ID[_from][oldIndex]] = oldIndex;\\r\\n        }\\r\\n        OWNER_INDEX_TO_ID[_from].pop();\\r\\n\\r\\n        OWNER_ID_TO_INDEX[_tokenId] = OWNER_INDEX_TO_ID[_to].length;\\r\\n        OWNER_INDEX_TO_ID[_to].push(_tokenId);\\r\\n\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public {\\r\\n        transferFrom(_from, _to, _tokenId);\\r\\n\\r\\n        //Get size of \\\"_to\\\" address, if 0 it's a wallet\\r\\n        uint32 size;\\r\\n        assembly {\\r\\n            size := extcodesize(_to)\\r\\n        }\\r\\n        if(size > 0){\\r\\n            IERC721TokenReceiver receiver = IERC721TokenReceiver(_to);\\r\\n            require(receiver.onERC721Received(msg.sender,_from,_tokenId,data) == bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\")),\\\"receiver\\\");\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\\r\\n        safeTransferFrom(_from,_to,_tokenId,\\\"\\\");\\r\\n    }\\r\\n\\r\\n    function name() external pure returns (string memory _name){\\r\\n        return \\\"POW NFT Molecules\\\";\\r\\n    }\\r\\n\\r\\n    function symbol() external pure returns (string memory _symbol){\\r\\n        return \\\"MOLECULE\\\";\\r\\n    }\\r\\n\\r\\n\\r\\n    // ENUMERABLE FUNCTIONS\\r\\n    function totalSupply() external view returns (uint256){\\r\\n        return TOKENS.length;\\r\\n    }\\r\\n\\r\\n    function tokenByIndex(uint256 _index) external view returns(uint256){\\r\\n        require(_index < TOKENS.length,\\\"index\\\");\\r\\n        return _index + 1;\\r\\n        //        return INDEX_TO_ID[_index];\\r\\n    }\\r\\n\\r\\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256){\\r\\n        require(_index < BALANCES[_owner],\\\"index\\\");\\r\\n        return OWNER_INDEX_TO_ID[_owner][_index];\\r\\n    }\\r\\n\\r\\n    // End 721 Implementation\\r\\n\\r\\n    ///////===165 Implementation\\r\\n    mapping (bytes4 => bool) internal supportedInterfaces;\\r\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool){\\r\\n        return supportedInterfaces[interfaceID];\\r\\n    }\\r\\n    ///==End 165\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IAtomReader.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Licence to thrill\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/// @title POWNFT Atom Reader\\r\\n/// @author AnAllergyToAnalogy\\r\\n/// @notice On-chain calculation atomic number and ionisation data about POWNFT Atoms. Replicates functionality done off-chain for metadata.\\r\\ninterface IAtomReader{\\r\\n\\r\\n    /// @notice Get atomic number and ionic charge of a specified POWNFT Atom\\r\\n    /// @dev Gets Atom hash from POWNFT contract, so will throw for _tokenId of non-existent token.\\r\\n    /// @param _tokenId TokenId of the Atom to query\\r\\n    /// @return atomicNumber Atomic number of the Atom\\r\\n    /// @return ionCharge Ionic charge of the Atom\\r\\n    function getAtomData(uint _tokenId) external view returns(uint atomicNumber, int8 ionCharge);\\r\\n\\r\\n    /// @notice Get atomic number of a specified POWNFT Atom\\r\\n    /// @dev Gets Atom hash from POWNFT contract, so will throw for _tokenId of non-existent token.\\r\\n    /// @param _tokenId TokenId of the Atom to query\\r\\n    /// @return Atomic number of the Atom\\r\\n    function getAtomicNumber(uint _tokenId) external view returns(uint);\\r\\n\\r\\n    /// @notice Get ionic charge of a specified POWNFT Atom\\r\\n    /// @dev Gets Atom hash from POWNFT contract, so will throw for _tokenId of non-existent token.\\r\\n    /// @param _tokenId TokenId of the Atom to query\\r\\n    /// @return ionic charge of the Atom\\r\\n    function getIonCharge(uint _tokenId) external view returns(int8);\\r\\n\\r\\n    /// @notice Get array of all possible ions for a specified element\\r\\n    /// @param atomicNumber Atomic number of element to query\\r\\n    /// @return Array of possible ionic charges\\r\\n    function getIons(uint atomicNumber) external pure returns(int8[] memory);\\r\\n\\r\\n    /// @notice Check if a given element can have a particular ionic charge\\r\\n    /// @param atomicNumber Atomic number of element to query\\r\\n    /// @param ionCharge Ionic charge to check\\r\\n    /// @return True if this element can have this ion, false otherwise.\\r\\n    function isValidIonCharge(uint atomicNumber, int8 ionCharge) external pure returns(bool);\\r\\n\\r\\n    /// @notice Check if a given element has any potential ions\\r\\n    /// @param atomicNumber Atomic number of element to query\\r\\n    /// @return True if this element can ionise, false otherwise.\\r\\n    function canIonise(uint atomicNumber) external pure returns(bool);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPOWNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPOWNFT{\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function ownerOf(uint256 tokenId) external view returns (address);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC721TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC721TokenReceiver {\\r\\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\\r\\n}\"\r\n    },\r\n    \"contracts/libraries/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/// @title Base64\\r\\n/// @notice Provides a function for encoding some bytes in base64\\r\\n/// @author Brecht Devos <brecht@loopring.org>\\r\\nlibrary Base64 {\\r\\n    bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\r\\n\\r\\n    /// @notice Encodes some bytes to the base64 representation\\r\\n    function encode(bytes memory data) internal pure returns (string memory) {\\r\\n        uint256 len = data.length;\\r\\n        if (len == 0) return \\\"\\\";\\r\\n\\r\\n        // multiply by 4/3 rounded up\\r\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\r\\n\\r\\n        // Add some extra buffer at the end\\r\\n        bytes memory result = new bytes(encodedLen + 32);\\r\\n\\r\\n        bytes memory table = TABLE;\\r\\n\\r\\n        assembly {\\r\\n            let tablePtr := add(table, 1)\\r\\n            let resultPtr := add(result, 32)\\r\\n\\r\\n            for {\\r\\n                let i := 0\\r\\n            } lt(i, len) {\\r\\n\\r\\n            } {\\r\\n                i := add(i, 3)\\r\\n                let input := and(mload(add(data, i)), 0xffffff)\\r\\n\\r\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\r\\n                out := shl(8, out)\\r\\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\r\\n                out := shl(8, out)\\r\\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\r\\n                out := shl(8, out)\\r\\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\r\\n                out := shl(224, out)\\r\\n\\r\\n                mstore(resultPtr, out)\\r\\n\\r\\n                resultPtr := add(resultPtr, 4)\\r\\n            }\\r\\n\\r\\n            switch mod(len, 3)\\r\\n            case 1 {\\r\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\r\\n            }\\r\\n            case 2 {\\r\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\r\\n            }\\r\\n\\r\\n            mstore(result, encodedLen)\\r\\n        }\\r\\n\\r\\n        return string(result);\\r\\n    }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pownft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_atomReader\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"_composition\",\"type\":\"uint8[]\"}],\"name\":\"checkFormula\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_atomIds\",\"type\":\"uint256[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[][]\",\"name\":\"composition\",\"type\":\"uint8[][]\"}],\"name\":\"initMolecules\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"moleculeOf\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"myAtoms\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint8[]\",\"name\":\"atomicNumbers\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start_index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"myMolecules\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"formulas\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"switchOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Molecules","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009abb7bddc43fa67c76a62d8c016513827f59be1b00000000000000000000000041d44e1cd2b335dc7662380d58eb03c5539b907f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}