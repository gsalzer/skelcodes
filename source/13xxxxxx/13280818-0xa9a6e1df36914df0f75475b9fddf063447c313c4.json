{"status":"1","message":"OK","result":[{"SourceCode":"// Sources flattened with hardhat v2.6.0 https://hardhat.org\r\n\r\n// File contracts/interfaces/IArmorMaster.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ninterface IArmorMaster {\r\n    function registerModule(bytes32 _key, address _module) external;\r\n    function getModule(bytes32 _key) external view returns(address);\r\n    function keep() external;\r\n}\r\n\r\n\r\n// File contracts/general/Ownable.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n * \r\n * @dev Completely default OpenZeppelin.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function initializeOwnable() internal {\r\n        require(_owner == address(0), \"already initialized\");\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"msg.sender is not owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _pendingOwner = newOwner;\r\n    }\r\n\r\n    function receiveOwnership() public {\r\n        require(msg.sender == _pendingOwner, \"only pending owner can call this function\");\r\n        _transferOwnership(_pendingOwner);\r\n        _pendingOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}\r\n\r\n\r\n// File contracts/general/Bytes32.sol\r\n\r\npragma solidity ^0.6.6;\r\nlibrary Bytes32 {\r\n    function toString(bytes32 x) internal pure returns (string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint256 j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (uint256 j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/general/ArmorModule.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Each arCore contract is a module to enable simple communication and interoperability. ArmorMaster.sol is master.\r\n**/\r\ncontract ArmorModule {\r\n    IArmorMaster internal _master;\r\n\r\n    using Bytes32 for bytes32;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == Ownable(address(_master)).owner(), \"only owner can call this function\");\r\n        _;\r\n    }\r\n\r\n    modifier doKeep() {\r\n        _master.keep();\r\n        _;\r\n    }\r\n\r\n    modifier onlyModule(bytes32 _module) {\r\n        string memory message = string(abi.encodePacked(\"only module \", _module.toString(),\" can call this function\"));\r\n        require(msg.sender == getModule(_module), message);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Used when multiple can call.\r\n    **/\r\n    modifier onlyModules(bytes32 _moduleOne, bytes32 _moduleTwo) {\r\n        string memory message = string(abi.encodePacked(\"only module \", _moduleOne.toString(),\" or \", _moduleTwo.toString(),\" can call this function\"));\r\n        require(msg.sender == getModule(_moduleOne) || msg.sender == getModule(_moduleTwo), message);\r\n        _;\r\n    }\r\n\r\n    function initializeModule(address _armorMaster) internal {\r\n        require(address(_master) == address(0), \"already initialized\");\r\n        require(_armorMaster != address(0), \"master cannot be zero address\");\r\n        _master = IArmorMaster(_armorMaster);\r\n    }\r\n\r\n    function changeMaster(address _newMaster) external onlyOwner {\r\n        _master = IArmorMaster(_newMaster);\r\n    }\r\n\r\n    function getModule(bytes32 _key) internal view returns(address) {\r\n        return _master.getModule(_key);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/SafeMath.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Unsigned math operations with safety checks that revert on error\r\n * \r\n * @dev Default OpenZeppelin\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/general/BalanceWrapper.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\ncontract BalanceWrapper {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal _totalSupply;\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function _addStake(address user, uint256 amount) internal {\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[user] = _balances[user].add(amount);\r\n    }\r\n\r\n    function _removeStake(address user, uint256 amount) internal {\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        _balances[user] = _balances[user].sub(amount);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/Math.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IPlanManager.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\ninterface IPlanManager {\r\n  // Mapping = protocol => cover amount\r\n  struct Plan {\r\n      uint64 startTime;\r\n      uint64 endTime;\r\n      uint128 length;\r\n  }\r\n  \r\n  struct ProtocolPlan {\r\n      uint64 protocolId;\r\n      uint192 amount;\r\n  }\r\n    \r\n  // Event to notify frontend of plan update.\r\n  event PlanUpdate(address indexed user, address[] protocols, uint256[] amounts, uint256 endTime);\r\n  function userCoverageLimit(address _user, address _protocol) external view returns(uint256);\r\n  function markup() external view returns(uint256);\r\n  function nftCoverPrice(address _protocol) external view returns(uint256);\r\n  function initialize(address _armorManager) external;\r\n  function changePrice(address _scAddress, uint256 _pricePerAmount) external;\r\n  function updatePlan(address[] calldata _protocols, uint256[] calldata _coverAmounts) external;\r\n  function checkCoverage(address _user, address _protocol, uint256 _hacktime, uint256 _amount) external view returns (uint256, bool);\r\n  function coverageLeft(address _protocol) external view returns(uint256);\r\n  function getCurrentPlan(address _user) external view returns(uint256 idx, uint128 start, uint128 end);\r\n  function updateExpireTime(address _user, uint256 _expiry) external;\r\n  function planRedeemed(address _user, uint256 _planIndex, address _protocol) external;\r\n  function totalUsedCover(address _scAddress) external view returns (uint256);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IRewardManagerV2.sol\r\n\r\npragma solidity ^0.6.6;\r\n\r\ninterface IRewardManagerV2 {\r\n    function initialize(address _armorMaster, uint256 _rewardCycleBlocks)\r\n        external;\r\n\r\n    function deposit(\r\n        address _user,\r\n        address _protocol,\r\n        uint256 _amount,\r\n        uint256 _nftId\r\n    ) external;\r\n\r\n    function withdraw(\r\n        address _user,\r\n        address _protocol,\r\n        uint256 _amount,\r\n        uint256 _nftId\r\n    ) external;\r\n\r\n    function updateAllocPoint(address _protocol, uint256 _allocPoint) external;\r\n\r\n    function initPool(address _protocol) external;\r\n\r\n    function notifyRewardAmount() external payable;\r\n}\r\n\r\n\r\n// File contracts/core/RewardManagerV2.sol\r\n\r\n// SPDX-License-Identifier: (c) Armor.Fi DAO, 2021\r\n\r\npragma solidity ^0.6.6;\r\n\r\n\r\n/**\r\n * @dev RewardManagerV2 is a updated RewardManager to distribute rewards.\r\n *      based on total used cover per protocols.\r\n **/\r\n\r\ncontract RewardManagerV2 is BalanceWrapper, ArmorModule, IRewardManagerV2 {\r\n    /**\r\n     * @dev Universal requirements:\r\n     *      - Calculate reward per protocol by totalUsedCover.\r\n     *      - onlyGov functions must only ever be able to be accessed by governance.\r\n     *      - Total of refBals must always equal refTotal.\r\n     *      - depositor should always be address(0) if contract is not locked.\r\n     *      - totalTokens must always equal pToken.balanceOf( address(this) ) - (refTotal + sum(feesToLiq) ).\r\n    **/\r\n\r\n    event RewardPaid(address indexed user, address indexed protocol, uint256 reward, uint256 timestamp);\r\n    event BalanceAdded(\r\n        address indexed user,\r\n        address indexed protocol,\r\n        uint256 indexed nftId,\r\n        uint256 amount,\r\n        uint256 totalStaked,\r\n        uint256 timestamp\r\n    );\r\n    event BalanceWithdrawn(\r\n        address indexed user,\r\n        address indexed protocol,\r\n        uint256 indexed nftId,\r\n        uint256 amount,\r\n        uint256 totalStaked,\r\n        uint256 timestamp\r\n    );\r\n\r\n    struct UserInfo {\r\n        uint256 amount; // How much cover staked\r\n        uint256 rewardDebt; // Reward debt.\r\n    }\r\n    struct PoolInfo {\r\n        address protocol; // Address of protocol contract.\r\n        uint256 totalStaked; // Total staked amount in the pool\r\n        uint256 allocPoint; // Allocation of protocol - same as totalUsedCover.\r\n        uint256 accEthPerShare; // Accumulated ETHs per share, times 1e12.\r\n        uint256 rewardDebt; // Pool Reward debt.\r\n    }\r\n\r\n    // Total alloc point - sum of totalUsedCover for initialized pools\r\n    uint256 public totalAllocPoint;\r\n    // Accumlated ETHs per alloc, times 1e12.\r\n    uint256 public accEthPerAlloc;\r\n    // Last reward updated block\r\n    uint256 public lastRewardBlock;\r\n    // Reward per block - updates when reward notified\r\n    uint256 public rewardPerBlock;\r\n    // Time when all reward will be distributed - updates when reward notified\r\n    uint256 public rewardCycleEnd;\r\n    // Currently used reward in cycle - used to calculate remaining reward at the reward notification\r\n    uint256 public usedReward;\r\n\r\n    // reward cycle period\r\n    uint256 public rewardCycle;\r\n    // last reward amount\r\n    uint256 public lastReward;\r\n\r\n    // Reward info for each protocol\r\n    mapping(address => PoolInfo) public poolInfo;\r\n\r\n    // Reward info for user in each protocol\r\n    mapping(address => mapping(address => UserInfo)) public userInfo;\r\n\r\n    /**\r\n     * @notice Controller immediately initializes contract with this.\r\n     * @dev - Must set all included variables properly.\r\n     *      - Update last reward block as initialized block.\r\n     * @param _armorMaster Address of ArmorMaster.\r\n     * @param _rewardCycleBlocks Block amounts in one cycle.\r\n    **/\r\n    function initialize(address _armorMaster, uint256 _rewardCycleBlocks)\r\n        external\r\n        override\r\n    {\r\n        initializeModule(_armorMaster);\r\n        require(_rewardCycleBlocks > 0, \"Invalid cycle blocks\");\r\n        rewardCycle = _rewardCycleBlocks;\r\n        lastRewardBlock = block.number;\r\n    }\r\n\r\n    /**\r\n     * @notice Only BalanceManager can call this function to notify reward.\r\n     * @dev - Reward must be greater than 0.\r\n     *      - Must update reward info before notify.\r\n     *      - Must contain remaining reward of previous cycle\r\n     *      - Update reward cycle info\r\n    **/\r\n    function notifyRewardAmount()\r\n        external\r\n        payable\r\n        override\r\n        onlyModule(\"BALANCE\")\r\n    {\r\n        require(msg.value > 0, \"Invalid reward\");\r\n        updateReward();\r\n        uint256 remainingReward = lastReward > usedReward\r\n            ? lastReward.sub(usedReward)\r\n            : 0;\r\n        lastReward = msg.value.add(remainingReward);\r\n        usedReward = 0;\r\n        rewardCycleEnd = block.number.add(rewardCycle);\r\n        rewardPerBlock = lastReward.div(rewardCycle);\r\n    }\r\n\r\n    /**\r\n     * @notice Update RewardManagerV2 reward information.\r\n     * @dev - Skip if already updated.\r\n     *      - Skip if totalAllocPoint is zero or reward not notified yet.\r\n    **/\r\n    function updateReward() public {\r\n        if (block.number <= lastRewardBlock || rewardCycleEnd <= lastRewardBlock) {\r\n            return;\r\n        }\r\n\r\n        if (rewardCycleEnd == 0 || totalAllocPoint == 0) {\r\n            lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n\r\n        uint256 reward = Math\r\n            .min(rewardCycleEnd, block.number)\r\n            .sub(lastRewardBlock)\r\n            .mul(rewardPerBlock);\r\n        usedReward = usedReward.add(reward);\r\n        accEthPerAlloc = accEthPerAlloc.add(\r\n            reward.mul(1e12).div(totalAllocPoint)\r\n        );\r\n        lastRewardBlock = block.number;\r\n    }\r\n\r\n    /**\r\n     * @notice Only Plan and Stake manager can call this function.\r\n     * @dev - Must update reward info before initialize pool.\r\n     *      - Cannot initlize again.\r\n     *      - Must update pool rewardDebt and totalAllocPoint.\r\n     * @param _protocol Protocol address.\r\n    **/\r\n    function initPool(address _protocol)\r\n        public\r\n        override\r\n        onlyModules(\"PLAN\", \"STAKE\")\r\n    {\r\n        require(_protocol != address(0), \"zero address!\");\r\n        PoolInfo storage pool = poolInfo[_protocol];\r\n        require(pool.protocol == address(0), \"already initialized\");\r\n        updateReward();\r\n        pool.protocol = _protocol;\r\n        pool.allocPoint = IPlanManager(_master.getModule(\"PLAN\"))\r\n            .totalUsedCover(_protocol);\r\n        totalAllocPoint = totalAllocPoint.add(pool.allocPoint);\r\n        pool.rewardDebt = pool.allocPoint.mul(accEthPerAlloc).div(1e12);\r\n    }\r\n\r\n    /**\r\n     * @notice Update alloc point when totalUsedCover updates.\r\n     * @dev - Only Plan Manager can call this function.\r\n     *      - Init pool if not initialized.\r\n     * @param _protocol Protocol address.\r\n     * @param _allocPoint New allocPoint.\r\n    **/\r\n    function updateAllocPoint(address _protocol, uint256 _allocPoint)\r\n        external\r\n        override\r\n        onlyModule(\"PLAN\")\r\n    {\r\n        PoolInfo storage pool = poolInfo[_protocol];\r\n        if (poolInfo[_protocol].protocol == address(0)) {\r\n            initPool(_protocol);\r\n        } else {\r\n            updatePool(_protocol);\r\n            totalAllocPoint = totalAllocPoint.sub(pool.allocPoint).add(\r\n                _allocPoint\r\n            );\r\n            pool.allocPoint = _allocPoint;\r\n            pool.rewardDebt = pool.allocPoint.mul(accEthPerAlloc).div(1e12);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice StakeManager call this function to deposit for user.\r\n     * @dev - Must update pool info\r\n     *      - Must give pending reward to user.\r\n     *      - Emit `BalanceAdded` event.\r\n     * @param _user User address.\r\n     * @param _protocol Protocol address.\r\n     * @param _amount Stake amount.\r\n     * @param _nftId NftId.\r\n    **/\r\n    function deposit(\r\n        address _user,\r\n        address _protocol,\r\n        uint256 _amount,\r\n        uint256 _nftId\r\n    ) external override onlyModule(\"STAKE\") {\r\n        PoolInfo storage pool = poolInfo[_protocol];\r\n        UserInfo storage user = userInfo[_protocol][_user];\r\n        if (pool.protocol == address(0)) {\r\n            initPool(_protocol);\r\n        } else {\r\n            updatePool(_protocol);\r\n            if (user.amount > 0) {\r\n                uint256 pending = user\r\n                    .amount\r\n                    .mul(pool.accEthPerShare)\r\n                    .div(1e12)\r\n                    .sub(user.rewardDebt);\r\n                safeRewardTransfer(_user, _protocol, pending);\r\n            }\r\n        }\r\n        user.amount = user.amount.add(_amount);\r\n        user.rewardDebt = user.amount.mul(pool.accEthPerShare).div(1e12);\r\n        pool.totalStaked = pool.totalStaked.add(_amount);\r\n\r\n        emit BalanceAdded(\r\n            _user,\r\n            _protocol,\r\n            _nftId,\r\n            _amount,\r\n            pool.totalStaked,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice StakeManager call this function to withdraw for user.\r\n     * @dev - Must update pool info\r\n     *      - Must give pending reward to user.\r\n     *      - Emit `BalanceWithdrawn` event.\r\n     * @param _user User address.\r\n     * @param _protocol Protocol address.\r\n     * @param _amount Withdraw amount.\r\n     * @param _nftId NftId.\r\n    **/\r\n    function withdraw(\r\n        address _user,\r\n        address _protocol,\r\n        uint256 _amount,\r\n        uint256 _nftId\r\n    ) public override onlyModule(\"STAKE\") {\r\n        PoolInfo storage pool = poolInfo[_protocol];\r\n        UserInfo storage user = userInfo[_protocol][_user];\r\n        require(user.amount >= _amount, \"insufficient to withdraw\");\r\n        updatePool(_protocol);\r\n        uint256 pending = user.amount.mul(pool.accEthPerShare).div(1e12).sub(\r\n            user.rewardDebt\r\n        );\r\n        if (pending > 0) {\r\n            safeRewardTransfer(_user, _protocol, pending);\r\n        }\r\n        user.amount = user.amount.sub(_amount);\r\n        user.rewardDebt = user.amount.mul(pool.accEthPerShare).div(1e12);\r\n        pool.totalStaked = pool.totalStaked.sub(_amount);\r\n\r\n        emit BalanceWithdrawn(\r\n            _user,\r\n            _protocol,\r\n            _nftId,\r\n            _amount,\r\n            pool.totalStaked,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Claim pending reward.\r\n     * @dev - Must update pool info\r\n     *      - Emit `RewardPaid` event.\r\n     * @param _protocol Protocol address.\r\n    **/\r\n    function claimReward(address _protocol) public {\r\n        PoolInfo storage pool = poolInfo[_protocol];\r\n        UserInfo storage user = userInfo[_protocol][msg.sender];\r\n\r\n        updatePool(_protocol);\r\n        uint256 pending = user.amount.mul(pool.accEthPerShare).div(1e12).sub(\r\n            user.rewardDebt\r\n        );\r\n        user.rewardDebt = user.amount.mul(pool.accEthPerShare).div(1e12);\r\n        if (pending > 0) {\r\n            safeRewardTransfer(msg.sender, _protocol, pending);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Claim pending reward of several protocols.\r\n     * @dev - Must update pool info of each protocol\r\n     *      - Emit `RewardPaid` event per protocol.\r\n     * @param _protocols Array of protocol addresses.\r\n    **/\r\n    function claimRewardInBatch(address[] calldata _protocols) external {\r\n        for (uint256 i = 0; i < _protocols.length; i += 1) {\r\n            claimReward(_protocols[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update pool info.\r\n     * @dev - Skip if already updated.\r\n     *      - Skip if totalStaked is zero.\r\n     * @param _protocol Protocol address.\r\n    **/\r\n    function updatePool(address _protocol) public {\r\n        PoolInfo storage pool = poolInfo[_protocol];\r\n        if (block.number <= lastRewardBlock) {\r\n            return;\r\n        }\r\n        if (pool.totalStaked == 0) {\r\n            return;\r\n        }\r\n\r\n        updateReward();\r\n        uint256 poolReward = pool.allocPoint.mul(accEthPerAlloc).div(1e12).sub(\r\n            pool.rewardDebt\r\n        );\r\n        pool.accEthPerShare = pool.accEthPerShare.add(\r\n            poolReward.mul(1e12).div(pool.totalStaked)\r\n        );\r\n        pool.rewardDebt = pool.allocPoint.mul(accEthPerAlloc).div(1e12);\r\n    }\r\n\r\n    /**\r\n     * @notice Check contract balance to avoid tx failure.\r\n    **/\r\n    function safeRewardTransfer(address _to, address _protocol, uint256 _amount) internal {\r\n        uint256 reward = Math.min(address(this).balance, _amount);\r\n        payable(_to).transfer(reward);\r\n\r\n        emit RewardPaid(_to, _protocol, reward, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Get pending reward amount.\r\n     * @param _user User address.\r\n     * @param _protocol Protocol address.\r\n     * @return pending reward amount\r\n    **/\r\n    function getPendingReward(address _user, address _protocol)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if (rewardCycleEnd == 0 || totalAllocPoint == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 reward = Math\r\n            .min(rewardCycleEnd, block.number)\r\n            .sub(lastRewardBlock)\r\n            .mul(rewardPerBlock);\r\n        uint256 _accEthPerAlloc = accEthPerAlloc.add(\r\n            reward.mul(1e12).div(totalAllocPoint)\r\n        );\r\n\r\n        PoolInfo memory pool = poolInfo[_protocol];\r\n        if (pool.protocol == address(0) || pool.totalStaked == 0) {\r\n            return 0;\r\n        }\r\n        uint256 poolReward = pool.allocPoint.mul(_accEthPerAlloc).div(1e12).sub(\r\n            pool.rewardDebt\r\n        );\r\n        uint256 _accEthPerShare = pool.accEthPerShare.add(\r\n            poolReward.mul(1e12).div(pool.totalStaked)\r\n        );\r\n        UserInfo memory user = userInfo[_protocol][_user];\r\n        return user.amount.mul(_accEthPerShare).div(1e12).sub(user.rewardDebt);\r\n    }\r\n\r\n    /**\r\n     * @notice Get pending total reward amount for several protocols.\r\n     * @param _user User address.\r\n     * @param _protocols Array of protocol addresses.\r\n     * @return pending reward amount\r\n    **/\r\n    function getTotalPendingReward(address _user, address[] memory _protocols)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 reward;\r\n        for (uint256 i = 0; i < _protocols.length; i += 1) {\r\n            reward = reward.add(getPendingReward(_user, _protocols[i]));\r\n        }\r\n        return reward;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"BalanceAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"BalanceWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accEthPerAlloc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMaster\",\"type\":\"address\"}],\"name\":\"changeMaster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocol\",\"type\":\"address\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_protocols\",\"type\":\"address[]\"}],\"name\":\"claimRewardInBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protocol\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protocol\",\"type\":\"address\"}],\"name\":\"getPendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_protocols\",\"type\":\"address[]\"}],\"name\":\"getTotalPendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocol\",\"type\":\"address\"}],\"name\":\"initPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_armorMaster\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardCycleBlocks\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"protocol\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accEthPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardCycleEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocol\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"}],\"name\":\"updateAllocPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocol\",\"type\":\"address\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protocol\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RewardManagerV2","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e7effe49dd943fdd7bc490d34abd46b8631afb64aa15ba9e8f66eae21558ca01"}]}