{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\n// Ayusocoin - simple ERC20 token for a campaign to educate\r\n// spanish politicians about Ethereum and cryptocurrencies\r\n// in general.\r\n\r\npragma solidity >=0.6.6; \r\n\r\n// Interfaz ERC20 - Estandar para tokens sobre Ethereum\r\n// En Ethereum los \"tokens\" o \"monedas\" son contratos.\r\n// Ojo: un contrato es un programa de ordenador.\r\n\r\n// El código viene después de definir la interfaz del contrato.\r\n// Es decir, primero decimos qué cosas se pueden hacer con el contrato\r\n// y después ponemos el código del contrato.\r\n\r\n/* Esto el lo que implementa el contrato:\r\n  function totalSupply() public returns (uint256 supply);\r\n  function balanceOf(address _owner) public returns (uint256 balance);\r\n  function transfer(address _to, uint256 _value) public returns (bool success);\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n  function approve(address _spender, uint256 _value) public returns (bool success);\r\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n  // solhint-disable-next-line no-simple-event-func-name\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n}\r\n */\r\n\r\ncontract Ayusocoin {\r\n\r\n  // Nombre y símbolo con el que se da a conocer el 'token':\r\n  // Algunas wallets ignoran esto, pero mola verlo ;-)\r\n  string public constant name = \"Ayuso Coin v1\";\r\n  string public constant symbol = \"AYUSOS\";\r\n\r\n  // Parámetros técnicos\r\n  uint8 public constant decimals = 7; // La bandera de la Comunida de Madrid tiene siete estrellas.\r\n  uint256 public _totalSupply = 470000000000000000; // 1000 ayusos * 47.000.000 de españoles (*10_000_000 por los 7 decimales) - un número divertido\r\n\r\n  \r\n  // Propio de este token\r\n\r\n  // El contrato tiene un balance maximo por direccion para evitar\r\n  // que se haga trading con el token durante los primeros días.\r\n  // Tambien sirve para \"pausar\" temporalmente el movimiento del token de un usuario a otro.\r\n  // Al poner un límite al balance por dirección, si alguien quiere manipular el precio \r\n  // tiene que hacer una operación coordinada grande con un coste importante.\r\n\r\n  uint256 public maxbalance_per_addr = 10000000000; // El limite de tokens que puede tener una direccion.\r\n\r\n  address private _root ; // Direccion del superusuario del contrato: puede cambiar los limites y parámetros\r\n\r\n  // Eventos\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  // Estos dos mapping sirven para guardar datos en el blockchain de Ethereum\r\n  // el almacenamiento en el blockchain es _muy_ caro: estamos guardando\r\n  // datos en millones de ordenadores hasta el final de los tiempos y eso\r\n  // hay que pagarlo (con el GAS)\r\n\r\n  // Primer mapping: ¿cuántos ayusos tiene cada dirección de Ethereum?\r\n  mapping (address => uint256) private balance;\r\n\r\n  // Segundo mapping: permisos para enviar tokens a otras direcciones\r\n  // esto es lo que se toca cuando una aplicación pide permiso a tu wallet\r\n  // para hacer una transacción.\r\n  // Hay un doble mapping: el primero es para identificar el dueño,\r\n  // y el segundo a qué dirección tiene permiso para enviar tokens.\r\n  // El uint256 es la cantidad con la que se puede operar (MAX_UINT256 = ilimitado)\r\n  mapping (address => mapping (address => uint256)) public allowed;\r\n\r\n  // necesitamos esto por seguridad...\r\n  uint256 constant private MAX_UINT256 = 2**256 - 1;\r\n\r\n  // métodos del token\r\n\r\n  // totalSupply -> ¿cuántos tokens hay en circulación\r\n  function totalSupply() public view returns (uint256) { return _totalSupply; }\r\n\r\n  // balanceOf -> ¿cuántos tiene cada dirección?\r\n  function balanceOf(address _quien) public view returns (uint256 _balance) {\r\n    return balance[_quien];\r\n  }\r\n\r\n  /*\r\n  ** Gestion del contrato por el superusuario.\r\n  */\r\n\r\n  event SetRootAttempt(address tx_origin, address msg_sender, address oldroot, address newroot);\r\n  function setRoot(address _newroot) public returns (address) {\r\n    emit SetRootAttempt(tx.origin, msg.sender, _root, _newroot);\r\n    require(isRoot(msg.sender));\r\n    _root = _newroot;\r\n    return _newroot;\r\n  }\r\n\r\n  function getRoot() public view returns (address) {\r\n     return _root;\r\n  }\r\n   \r\n  function isRoot(address addy) public view returns (bool) {\r\n    require(msg.sender == tx.origin);\r\n    address myroot = getRoot();\r\n    return addy == myroot;\r\n   //   return (tx.origin == _root) && (msg.sender == _root); // Humans only\r\n  }\r\n\r\n  function setMaxBalancePerAddress(uint256 maxbal) public returns (uint256) {\r\n      require(isRoot(tx.origin)); // OnlyRoot\r\n      maxbalance_per_addr = maxbal;\r\n      return maxbal;\r\n  }\r\n\r\n  /*\r\n  ** A partir de aqui _movemos_ \"dinero\" virtual.\r\n  */\r\n\r\n  // La funcion transfer(to,value) ordena uan transferencia de los tokens.\r\n  // Se utiliza por el dueño de los tokens (sea o no un contrato).\r\n  \r\n  function transfer(address _to, uint256 _value) public returns (bool success) {\r\n\r\n    // Antes de mover los tokens hay que asegurarse de que:\r\n    // 1 - Tenemos saldo suficiente \r\n    // 2 - No nos llaman desde un contrato. Sólo para humanos.\r\n\r\n    require(balance[msg.sender] >= _value);\r\n    // require(msg.sender == tx.origin, 'Humans only');\r\n    require(balance[_to] + _value <= maxbalance_per_addr, 'Limite de balance alcanzado');\r\n\r\n    // Movemos balances\r\n\r\n    balance[msg.sender] -= _value ;\r\n    balance[_to] += _value;\r\n\r\n    // Este mensaje avisa de que ha ocurrido algo...\r\n    emit Transfer(msg.sender, _to, _value);\r\n\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\r\n    // Esta funcion es casi igual que transfer(), pero dando con una dirección de origem.\r\n    // ¿Para qué necesitamos esta función? ¿no basta con transfer() ?\r\n    // Pues no, esta funcion se llama desde otro smart contract (como Uniswap, o cualquier otro DEX)\r\n    // Por eso tenemos ese parámetro \"allowance\" en ERC20: Para que el smart contract\r\n    // que llama a esta función no nos pueda dejar vacía la billetera.\r\n    \r\n    uint256 limit;\r\n\r\n    // Por seguridad evitamos reentrada pero la transacción es más cara (cuesta más gas) :-S\r\n    limit = allowed[_from][_to];\r\n\r\n    // Antes de mover los tokens hay que asegurarse de que\r\n    // 1 - Tenemos saldo suficiente \r\n    // 2 - Se permite mandar esa cantidad al destino\r\n\r\n    require(balance[_from] >= _value);\r\n    require(limit >= _value, 'Se debe permitir transferencia' );\r\n    require(balance[_to] + _value <= maxbalance_per_addr, 'Limite de balance alcanzado');\r\n\r\n    // Movemos balances\r\n\r\n    if (limit < MAX_UINT256) {\r\n        // actualizamos los permisos... con cuidado para que no nos ataquen con un underflow.\r\n        require(limit - _value < limit, \"Evita integer underflow\");\r\n        allowed[_from][_to] = 0;\r\n        limit -= _value;\r\n        allowed[msg.sender][_to] = limit;\r\n    }\r\n\r\n    balance[msg.sender] -= _value ;\r\n    balance[_to] += _value;  // Lo ultimo que se hace siempre es _mover_ hacia otra direccion,\r\n\r\n    // Este mensaje notifica que ha ocurrido algo... (se puede consultar en Etherscan / web3 / infura...)\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n\r\n  }\r\n\r\n  // Gestión de allowance (la asignación)\r\n\r\n  // approve(_direccion, _valor) -> Aprueba que la dirección haga un gasto\r\n  // Esta función se suele llamar desde el wallet.\r\n  // No queremos que un contrato lo cambie. Sólo personas humanas.\r\n  \r\n  function approve(address _to, uint256 _value) public returns (bool success) {\r\n    require(msg.sender == tx.origin, \"Humans only\");\r\n    allowed[msg.sender][_to] = _value;\r\n    emit Approval(msg.sender, _to, _value);\r\n\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  // Constructor - desde aqui se crea el contrato y se acuñan los tokens\r\n\r\n  constructor () {\r\n     balance[msg.sender] = _totalSupply;\r\n     _root = tx.origin; // Direccion del dueño del contrato\r\n  }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tx_origin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldroot\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newroot\",\"type\":\"address\"}],\"name\":\"SetRootAttempt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_quien\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRoot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"isRoot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxbalance_per_addr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxbal\",\"type\":\"uint256\"}],\"name\":\"setMaxBalancePerAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newroot\",\"type\":\"address\"}],\"name\":\"setRoot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Ayusocoin","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://73121acee90f968c0ea88742091952c9cffefdb8bd6da456ac6c7972ba3c0610"}]}