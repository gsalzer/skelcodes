{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SwitchAcross.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport './libraries/TransferHelper.sol';\\nimport './modules/Initializable.sol';\\nimport './modules/ReentrancyGuard.sol';\\nimport './modules/Pausable.sol';\\nimport './modules/UserTokenLimit.sol';\\nimport './interfaces/IWETH.sol';\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport './interfaces/ISwitchTreasury.sol';\\nimport './interfaces/ISwitchSigner.sol';\\nimport './interfaces/ISwitchTicketFactory.sol';\\nimport './interfaces/IRewardToken.sol';\\n\\ncontract SwitchAcross is UserTokenLimit, Pausable, ReentrancyGuard, Initializable{\\n    using SafeMath for uint;\\n    address public weth;\\n    address public treasury;\\n    address public signer;\\n    address public ticketFactory;\\n    uint public constant DENOMINATOR = 10000;\\n    address public feeWallet;\\n    address public gasWallet;\\n    \\n    uint public totalGas;\\n    uint public totalFee;\\n    //(token => total fee)\\n    mapping (address => uint) public totalSlideOfToken;\\n    \\n\\n    uint public collectedAccuGas;\\n    uint public collectedAccuFee;\\n    //(token => total fee)\\n    mapping (address => uint) public collectedAccuSlideOfToken;\\n\\n    //(chainIdOut, tokenOut, tokenIn)\\n    mapping (uint => mapping (address => address)) public tokenMap;\\n\\n    struct TargetToken {\\n        address tokenOut;\\n        uint decimals;\\n        uint fee;\\n        uint slideMin;\\n        uint slideMax;\\n        uint slidePre;\\n        uint limit;\\n    }\\n\\n    //(source token, chainIdOut)\\n    mapping (address => mapping (uint => TargetToken)) public targetTokens;\\n\\n    struct SourceToken {\\n        uint decimals;\\n        bool enabledIn;\\n        bool enabledOut;\\n        uint rewardRate; // its denominator is 1e18\\n        bool added;\\n    }\\n    //key: (token address)\\n    mapping (address => SourceToken) public sourceTokens;\\n\\n    address[] public tokens;\\n    uint public inSn;\\n    uint public outSn;\\n\\n    //(chainId => fee)\\n    mapping (uint => uint) public chainFees;\\n    uint public baseFee;\\n    uint public mode;     // supported mode(0: none, 1:self, 2:other)\\n\\n    // from chainId=>from inSn=> outSn\\n    mapping (uint => mapping (uint => uint)) public outOrders;\\n    address public rewardToken;\\n    mapping (address => uint) public rewards;\\n\\n    event ChianFeeChanged(uint indexed chainId, uint indexed fee);\\n    event TokenMapChanged(address indexed tokenIn, address indexed tokenOut, uint indexed chainIdOut);\\n    event TransferIned(\\n        uint indexed sn,\\n        address user,\\n        uint chainId,\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountIn,\\n        uint amountOut,\\n        uint mode,\\n        uint slide,\\n        uint fee\\n    );\\n    event TransferOuted(\\n        uint indexed sn,\\n        address user,\\n        uint chainId,\\n        address tokenIn,\\n        address tokenOut,\\n        uint amountIn,\\n        uint amountOut,\\n        uint mode,\\n        uint slide,\\n        uint inSn\\n    );\\n\\n    event ConfigureChanged(address indexed _user, address _treasury, address _signer, address _ticketFactory, uint _mode);\\n    event FeeWalletChanged(address indexed _user, address _old, address _new);\\n    event GasWalletChanged(address indexed _user, address _old, address _new);\\n    event BaseFeeChanged(address indexed _user, uint _old, uint _new);\\n    event TokenEnableChanged(address indexed _tokenIn, bool _enabledIn, bool _enabledOut);\\n    event RewardRateChanged(address indexed _tokenIn, uint _old, uint _new);\\n\\n    function initialize(address _weth, address _rewardToken) external initializer {\\n        require(_weth != address(0), 'SwitchAcross: ZERO_ADDRESS');\\n        owner = msg.sender;\\n        feeWallet = msg.sender;\\n        gasWallet = msg.sender;\\n        weth = _weth;\\n        rewardToken = _rewardToken;\\n        inSn = 1;\\n        outSn = 1;\\n    }\\n\\n\\n    modifier onlyFeeWallet() {\\n        require(msg.sender == owner || msg.sender == feeWallet, 'SwitchAcross: FEE_FORBIDDEN');\\n        _;\\n    }\\n\\n    modifier onlyGasWallet() {\\n        require(msg.sender == owner || msg.sender == gasWallet, 'SwitchAcross: GAS_FORBIDDEN');\\n        _;\\n    }\\n    \\n    receive() external payable {\\n        assert(msg.sender == weth);\\n    }\\n\\n    function pause() external onlyManager whenNotPaused {\\n        _pause();\\n    }\\n\\n    function unpause() external onlyManager whenPaused {\\n        _unpause();\\n    }\\n\\n    function configure(address _treasury, address _signer, address _ticketFactory, uint _mode, uint _baseFee) external onlyDev {\\n        require(_treasury != address(0) && _signer != address(0) && _ticketFactory != address(0), 'SwitchAcross: ZERO_ADDRESS');\\n        emit ConfigureChanged(msg.sender, _treasury, _signer, _ticketFactory, _mode);\\n        emit BaseFeeChanged(msg.sender, baseFee, _baseFee);\\n        treasury = _treasury;\\n        signer = _signer;\\n        ticketFactory = _ticketFactory;\\n        mode = _mode;\\n        baseFee = _baseFee;\\n    }\\n    \\n    function countToken() public view returns (uint) {\\n        return tokens.length;\\n    }\\n\\n    function changeFeeWallet(address _user) external onlyFeeWallet {\\n        require(feeWallet != _user, 'SwitchAcross: NO_CHANGE');\\n        emit FeeWalletChanged(msg.sender, feeWallet, _user);\\n        feeWallet = _user;\\n    }\\n\\n    function changeGasWallet(address _user) external onlyGasWallet {\\n        require(gasWallet != _user, 'SwitchAcross: NO_CHANGE');\\n        emit GasWalletChanged(msg.sender, gasWallet, _user);\\n        gasWallet = _user;\\n    }\\n\\n    function checkMode(uint _mode) public view returns (bool) {\\n        return (mode & _mode) == _mode;\\n    }\\n\\n    function setBaseFee(uint _baseFee) external onlyDev {\\n        emit BaseFeeChanged(msg.sender, baseFee, _baseFee);\\n        baseFee = _baseFee;\\n    }\\n\\n    function setTokenMap(address _tokenIn, address _tokenOut, uint _chainIdOut, uint _tokenOutDecimals, uint _tokenOutLimit, uint _fee, uint _slideMin, uint _slideMax, uint _slidePre, uint _rewardRate) public onlyDev {\\n        require(_slideMax >= _slideMin, \\\"SwitchAcross: INVALID_PARAM\\\");\\n        if(_tokenIn == address(0)) {\\n            _tokenIn = weth;\\n        }\\n        tokenMap[_chainIdOut][_tokenOut] = _tokenIn;\\n\\n        SourceToken storage sourceToken = sourceTokens[_tokenIn];\\n        if(sourceToken.added == false) {\\n            tokens.push(_tokenIn);\\n            sourceToken.added = true;\\n            sourceToken.enabledIn = true;\\n            sourceToken.enabledOut = true;\\n            sourceToken.decimals = IERC20(_tokenIn).decimals();\\n        }\\n        \\n        if(sourceToken.rewardRate != _rewardRate) sourceToken.rewardRate = _rewardRate;\\n\\n        TargetToken storage targetToken = targetTokens[_tokenIn][_chainIdOut];\\n        if(targetToken.tokenOut == address(0) && targetToken.decimals != _tokenOutDecimals) targetToken.decimals = _tokenOutDecimals;\\n        if(targetToken.tokenOut != _tokenOut) targetToken.tokenOut = _tokenOut;\\n        if(targetToken.fee != _fee) targetToken.fee = _fee;\\n        if(targetToken.limit != _tokenOutLimit) targetToken.limit = _tokenOutLimit;\\n        if(targetToken.slideMin != _slideMin) targetToken.slideMin = _slideMin;\\n        if(targetToken.slideMax != _slideMax) targetToken.slideMax = _slideMax;\\n        if(targetToken.slidePre != _slidePre) targetToken.slidePre = _slidePre;\\n\\n        emit TokenMapChanged(_tokenIn, _tokenOut, _chainIdOut);\\n    }\\n\\n    function setTokenMaps(address[] memory _tokenIn, address[] memory _tokenOut, uint[] memory _chainIdOut, uint[] memory _tokenOutDecimals, uint[] memory _tokenOutLimit, uint[] memory _fee, uint[] memory _slideMin, uint[] memory _slideMax, uint[] memory _slidePre, uint[] memory _rewardRate) external onlyDev {\\n        require(\\n            _tokenIn.length == _tokenOut.length \\n            && _tokenOut.length == _chainIdOut.length \\n            && _chainIdOut.length == _tokenOutDecimals.length \\n            && _tokenOutDecimals.length == _tokenOutLimit.length \\n            && _tokenOutLimit.length == _fee.length \\n            && _fee.length == _slideMin.length \\n            && _slideMin.length == _slideMax.length \\n            && _slideMax.length == _slidePre.length \\n            && _slidePre.length == _rewardRate.length \\n            , \\\"SwitchAcross: INVALID_PARAM\\\"\\n        );\\n        for (uint i; i < _tokenIn.length; i++) {\\n            setTokenMap(_tokenIn[i], _tokenOut[i], _chainIdOut[i], _tokenOutDecimals[i], _tokenOutLimit[i], _fee[i], _slideMin[i], _slideMax[i], _slidePre[i], _rewardRate[i]);\\n        }\\n    }\\n\\n    function setTokenEnable(address _tokenIn, bool _enabledIn, bool _enabledOut) public onlyDev {\\n        if(_tokenIn == address(0)) {\\n            _tokenIn = weth;\\n        }\\n        SourceToken storage sourceToken = sourceTokens[_tokenIn];\\n        if(sourceToken.enabledIn != _enabledIn) sourceToken.enabledIn = _enabledIn;\\n        if(sourceToken.enabledOut != _enabledOut) sourceToken.enabledOut = _enabledOut;\\n        emit TokenEnableChanged(_tokenIn, _enabledIn, _enabledOut);\\n    }\\n\\n    function setTokenEnables(address[] memory _tokenIn, bool[] memory _enabledIn, bool[] memory _enabledOut) external onlyDev {\\n        require(\\n            _tokenIn.length == _enabledIn.length \\n            && _enabledIn.length == _enabledOut.length \\n            , \\\"SwitchAcross: INVALID_PARAM\\\"\\n        );\\n        for (uint i; i < _tokenIn.length; i++) {\\n            setTokenEnable(_tokenIn[i], _enabledIn[i], _enabledOut[i]);\\n        }\\n    }\\n\\n    function setRewardRate(address _tokenIn, uint _rewardRate) public onlyDev {\\n        if(_tokenIn == address(0)) {\\n            _tokenIn = weth;\\n        }\\n        SourceToken storage sourceToken = sourceTokens[_tokenIn];\\n        emit RewardRateChanged(_tokenIn, sourceToken.rewardRate, _rewardRate);\\n        sourceToken.rewardRate = _rewardRate;\\n    }\\n\\n    function setRewardRates(address[] memory _tokenIn, uint[] memory _rewardRate) external onlyDev {\\n        require(\\n            _tokenIn.length == _rewardRate.length \\n            , \\\"SwitchAcross: INVALID_PARAM\\\"\\n        );\\n        for (uint i; i < _tokenIn.length; i++) {\\n            setRewardRate(_tokenIn[i], _rewardRate[i]);\\n        }\\n    }\\n\\n    function setChainFee(uint _chainId, uint _fee) public onlyDev {\\n        chainFees[_chainId] = _fee;\\n        emit ChianFeeChanged(_chainId, _fee);\\n    }\\n\\n    function setChainFees(uint[] memory _chainId, uint[] memory _fee) external onlyDev {\\n        require(_chainId.length == _fee.length, \\\"SwitchAcross: INVALID_PARAM\\\");\\n        for (uint i; i < _chainId.length; i++) {\\n            setChainFee(_chainId[i], _fee[i]);\\n        }\\n    }\\n\\n    function collectGasFee() external onlyGasWallet nonReentrant returns (uint amount) {\\n        require(totalGas > 0, \\\"SwitchAcross: NO_GAS_FEE\\\");\\n        amount = totalGas;\\n        collectedAccuGas += amount;\\n        ISwitchTreasury(treasury).withdraw(true, gasWallet, weth, amount);\\n        totalGas = 0;\\n    }\\n\\n    function collectFee() external onlyFeeWallet nonReentrant returns (uint amount) {\\n        require(totalFee > 0, \\\"SwitchAcross: NO_FEE\\\");\\n        amount = totalFee;\\n        collectedAccuFee += amount;\\n        ISwitchTreasury(treasury).withdraw(true, feeWallet, weth, amount);\\n        totalFee = 0;\\n    }\\n\\n    function collectSlide(address _token) external onlyFeeWallet nonReentrant returns (uint amount) {\\n        amount = totalSlideOfToken[_token];\\n        require(amount > 0, \\\"SwitchAcross: NO_SLIDE\\\");\\n        collectedAccuSlideOfToken[_token] += amount;\\n        ISwitchTreasury(treasury).withdraw(false, feeWallet, _token, amount);\\n        totalSlideOfToken[_token] = 0;\\n    }\\n\\n    function getSlide(address _tokenIn, uint _toChainId, uint amountIn) public view returns (uint) {\\n        if(_tokenIn == address(0)) {\\n            _tokenIn = weth;\\n        }\\n        TargetToken memory targetToken = targetTokens[_tokenIn][_toChainId];\\n        uint amount = amountIn.mul(targetToken.slidePre).div(DENOMINATOR);\\n        if(amount > targetToken.slideMax) {\\n            amount = targetToken.slideMax;\\n        }\\n        if(amount < targetToken.slideMin) {\\n            amount = targetToken.slideMin;\\n        }\\n        return amount;\\n    }\\n\\n    function getAmountIn(address _tokenIn, uint _toChainId, uint _amountOut) public view returns (uint amount, uint slide) {\\n        if(_tokenIn == address(0)) {\\n            _tokenIn = weth;\\n        }\\n        TargetToken memory targetToken = targetTokens[_tokenIn][_toChainId];\\n        SourceToken memory sourceToken = sourceTokens[_tokenIn];\\n        amount = _amountOut;\\n        if(sourceToken.decimals < targetToken.decimals) {\\n            amount = amount / 10** (targetToken.decimals - sourceToken.decimals);\\n        } else if(sourceToken.decimals > targetToken.decimals) {\\n            amount = amount * 10** (sourceToken.decimals - targetToken.decimals);\\n        }\\n        slide = getSlide(_tokenIn, _toChainId, amount);\\n        amount = amount.add(slide);\\n    }\\n\\n    function getAmountOut(address _tokenIn, uint _toChainId, uint _amountIn) public view returns (uint amount, uint slide) {\\n        if(_tokenIn == address(0)) {\\n            _tokenIn = weth;\\n        }\\n        TargetToken memory targetToken = targetTokens[_tokenIn][_toChainId];\\n        SourceToken memory sourceToken = sourceTokens[_tokenIn];\\n        slide = getSlide(_tokenIn, _toChainId, _amountIn);\\n        if(_amountIn <= slide) {\\n            slide = _amountIn;\\n        }\\n\\n        amount = _amountIn.sub(slide);\\n        if(sourceToken.decimals < targetToken.decimals) {\\n            amount = amount * 10** (targetToken.decimals - sourceToken.decimals);\\n            slide = slide * 10** (targetToken.decimals - sourceToken.decimals);\\n        } else if(sourceToken.decimals > targetToken.decimals) {\\n            amount = amount / 10** (sourceToken.decimals - targetToken.decimals);\\n            slide = slide / 10** (sourceToken.decimals - targetToken.decimals);\\n        }\\n        return (amount, slide);\\n    }\\n\\n    function getOutInfo(address _tokenIn, uint _toChainId, uint _amountIn, uint _mode) public view returns (uint amountIn, address tokenOut, uint amountOut, uint slide, uint fee, uint inLimit, uint outLimit) {\\n        if(_tokenIn == address(0)) {\\n            _tokenIn = weth;\\n        }\\n        TargetToken memory targetToken = targetTokens[_tokenIn][_toChainId];\\n        tokenOut = targetToken.tokenOut;\\n        fee = baseFee.add(targetToken.fee);\\n        // mode != 1\\n        if(_mode != 1) {\\n            fee = fee.add(chainFees[_toChainId]);\\n        }\\n        amountIn = _amountIn;\\n        (uint _amountOut, uint _slide) = getAmountOut(_tokenIn, _toChainId, _amountIn);\\n        amountOut = _amountOut;\\n        slide = _slide;\\n        inLimit = getUserLimit(msg.sender, _tokenIn, _amountIn);\\n        outLimit = targetToken.limit;\\n    }\\n\\n    function getInInfo(address _tokenIn, uint _toChainId, uint _amountOut, uint _mode) public view returns (uint amountIn, address tokenOut, uint amountOut, uint slide, uint fee, uint inLimit, uint outLimit) {\\n        if(_tokenIn == address(0)) {\\n            _tokenIn = weth;\\n        }\\n        (amountIn,) = getAmountIn(_tokenIn, _toChainId, _amountOut);\\n        return getOutInfo(_tokenIn, _toChainId, amountIn, _mode);\\n    }\\n\\n    function isTicket(address _token) public view returns (bool) {\\n        return ISwitchTicketFactory(ticketFactory).isTicket(_token);\\n    }\\n    \\n    /**\\n        transferIn \\n        address _to\\n        address[] _tokens, 0:_tokenIn, 1:_tokenOut\\n        uint[] _values, 0:_amountIn, 1:_amountOut, 2:_toChainId, 3:_mode\\n     */\\n    function transferIn(address _to, address[] memory _tokens, uint[] memory _values) external payable whenNotPaused nonReentrant  {\\n        require(_values[0] > 0 && _values[1] > 0, \\\"SwitchAcross: ZERO_AMOUNT\\\");\\n        require(checkMode(_values[3]), \\\"SwitchAcross: INVALID_MODE\\\");\\n        require(ISwitchSigner(signer).checkUser(_to), 'SwitchAcross: DENNY');\\n        bool isETH;\\n        if(_tokens[0] == address(0)) {\\n            isETH = true;\\n            _tokens[0] = weth;\\n        }\\n        SourceToken storage sourceToken = sourceTokens[_tokens[0]];\\n        require(sourceToken.enabledIn, \\\"SwitchAcross: TOKEN_DISABLED\\\");\\n        TargetToken memory targetToken = targetTokens[_tokens[0]][_values[2]];\\n        require(_tokens[1] == targetToken.tokenOut, \\\"SwitchAcross: INVALID_TOKENOUT\\\");\\n        require(getUserLimit(msg.sender, _tokens[0],  _values[0]) >= _values[0], \\\"SwitchAcross: USER_LIMIT_OVERFLOW\\\");\\n        (uint amountOut, uint slide) = getAmountOut(_tokens[0], _values[2], _values[0]);\\n        require(_values[1] == amountOut, \\\"SwitchAcross: AMOUNTOUT_INCORRECT\\\");\\n        require(targetToken.limit >= _values[1], \\\"SwitchAcross: AMOUNTOUT_OVERFLOW\\\");\\n\\n        uint fee = baseFee.add(targetToken.fee);\\n        totalFee = totalFee.add(fee);\\n        uint gas = fee;\\n        // mode != 1\\n        if(_values[3] != 1) {\\n            gas = gas.add(chainFees[_values[2]]);\\n            totalGas = totalGas.add(chainFees[_values[2]]);\\n        }\\n        { // avoid Stack too deep, try removing local variables.\\n        uint depositAmount;\\n        if(isETH) {\\n            require(msg.value >= gas.add(_values[0]), \\\"SwitchAcross: INSUFFICIENT_GAS_TOKEN_VALUE\\\");\\n            _values[0] = msg.value.sub(gas);\\n            depositAmount = ISwitchTreasury(treasury).deposit{value: _values[0]}(msg.sender, address(0), _values[0]);\\n        } else {\\n            require(msg.value >= gas, \\\"SwitchAcross: INSUFFICIENT_GAS_VALUE\\\");\\n            if(isTicket(_tokens[0])) {\\n                depositAmount = ISwitchTreasury(treasury).burn(_tokens[0], msg.sender, _values[0]);\\n            } else {\\n                depositAmount = ISwitchTreasury(treasury).deposit(msg.sender, _tokens[0], _values[0]);\\n            }\\n        }\\n        require(depositAmount == _values[0], \\\"SwitchAcross: TREASURY_DEPOSIT_FAIL\\\");\\n        }\\n\\n        _updateUserTokenLimit(_tokens[0],  _values[0]);\\n\\n        emit TransferIned(inSn, _to, _values[2], _tokens[0], _tokens[1], _values[0], _values[1], _values[3], slide, fee);\\n        inSn = inSn.add(1);\\n    }\\n\\n    function getDataHash(address _from, address[] memory _tokens, uint[] memory _values) public view returns (bytes32) {\\n        return keccak256(abi.encodePacked(_from, _values[2], _tokens[0], _tokens[1], _values[0], _values[1], _values[3], _values[4], _values[5], msg.sender));\\n    }\\n\\n    /**\\n        transferOut \\n        address _from\\n        address[] _tokens, 0:_tokenIn, 1:_tokenOut\\n        uint[] _values, 0:_amountIn, 1:_amountOut, 2:from chainId, 3:_mode, 4:slide, 5:from inSn\\n        bytes calldata _signature\\n     */\\n    function transferOut(address _from, address[] memory _tokens, uint[] memory _values, bytes[] memory _signatures) external whenNotPaused nonReentrant  {\\n        SourceToken storage sourceToken = sourceTokens[_tokens[1]];\\n        require(sourceToken.enabledOut, \\\"SwitchAcross: TOKEN_DISABLED\\\");\\n        require(outOrders[_values[2]][_values[5]] == 0, \\\"SwitchAcross: ALREADY_EXECUTED\\\");\\n   \\n        require(_values[1] > 0, \\\"SwitchAcross: NOTHING_TO_WITHDRAW\\\");\\n        require(queryWithdraw(_tokens[1], _values[1]) >= _values[1], 'SwitchAcross: INSUFFICIENT_BALANCE');\\n        \\n        bytes32 message = getDataHash(_from, _tokens, _values);\\n        require(signer != address(0), 'SwitchAcross: NO_SIGNER');\\n        require(ISwitchSigner(signer).mverify(_values[3], _from, msg.sender, message, _signatures), \\\"SwitchAcross: INVALID_SIGNATURE\\\");\\n\\n        if(isTicket(_tokens[1])) {\\n            ISwitchTreasury(treasury).mint(_tokens[1], _from, _values[1]);\\n            if(_values[4] > 0) {\\n                address _token = ISwitchTicketFactory(ticketFactory).getTokenMap(_tokens[1]);\\n                require(_token != address(0), 'SwitchAcross: INVALID_TICKET');\\n                totalSlideOfToken[_token] = totalSlideOfToken[_token].add(_values[4]);\\n            }\\n        } else {\\n            bool isETH = false;\\n            if(_tokens[1] == weth) {\\n                isETH = true;\\n            }\\n            ISwitchTreasury(treasury).withdraw(isETH, _from, _tokens[1], _values[1]);\\n            totalSlideOfToken[_tokens[1]] = totalSlideOfToken[_tokens[1]].add(_values[4]);\\n        }\\n     \\n        outOrders[_values[2]][_values[5]] = outSn;\\n\\n        rewards[_from] = rewards[_from].add(computeReward(_tokens[1], _values[1]));\\n \\n        emit TransferOuted(outSn, _from, _values[2], _tokens[0], _tokens[1], _values[0], _values[1], _values[3], _values[4], _values[5]);\\n        outSn = outSn.add(1);\\n    }\\n\\n    function computeReward(address token, uint amount) public view returns (uint) {\\n        SourceToken memory sourceToken = sourceTokens[token];\\n        if(sourceToken.decimals < 18) {\\n            amount = amount.mul(10**(18-sourceToken.decimals));\\n        } else {\\n            amount = amount.div(10**(sourceToken.decimals-18));\\n        }\\n        uint reward = amount.mul(sourceToken.rewardRate).div(1e18);\\n        if(reward > IRewardToken(rewardToken).take()) {\\n            reward = 0;\\n        }\\n        return reward;\\n    }\\n\\n    function queryWithdraw(address _token, uint _value) public view returns (uint) {\\n        if(!isTicket(_token)) {\\n            uint amount = ISwitchTreasury(treasury).queryWithdraw(address(this), _token);\\n            if(amount < _value) {\\n                _value = amount;\\n            }\\n        }\\n        return _value;\\n    }\\n\\n    function claimReward() external nonReentrant returns (uint) {\\n        uint reward = rewards[msg.sender];\\n        require(reward > 0, 'SwitchAcross: ZERO');\\n        require(reward <= IRewardToken(rewardToken).take(), 'SwitchAcross: STOP');\\n        rewards[msg.sender] = 0;\\n        IRewardToken(rewardToken).mint(msg.sender, reward);\\n        return reward;\\n    }\\n}\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n\\n/**\\n * @title Initializable\\n *\\n * @dev Helper contract to support initializer functions. To use it, replace\\n * the constructor with a function that has the `initializer` modifier.\\n * WARNING: Unlike constructors, initializer functions must be manually\\n * invoked. This applies both to deploying an Initializable contract, as well\\n * as extending an Initializable contract via inheritance.\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\n * because this is not dealt with automatically as with constructors.\\n */\\ncontract Initializable {\\n\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private initializing;\\n\\n  /**\\n   * @dev Modifier to use in the initializer function of a contract.\\n   */\\n  modifier initializer() {\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\n\\n    bool isTopLevelCall = !initializing;\\n    if (isTopLevelCall) {\\n      initializing = true;\\n      initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      initializing = false;\\n    }\\n  }\\n\\n  /// @dev Returns true if and only if the function is running in the constructor\\n  function isConstructor() private view returns (bool) {\\n    // extcodesize checks the size of the code stored in an address, and\\n    // address returns the current address. Since the code is still not\\n    // deployed when running a constructor, any checks on its code size will\\n    // yield zero, making it an effective way to detect if a contract is\\n    // under construction or not.\\n    address self = address(this);\\n    uint256 cs;\\n    assembly { cs := extcodesize(self) }\\n    return cs == 0;\\n  }\\n\\n  // Reserved storage space to allow for layout changes in the future.\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/modules/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 0;\\n    uint256 private constant _ENTERED = 1;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused();\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused();\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused();\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/modules/UserTokenLimit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.6;\\n\\nimport '../libraries/SafeMath.sol';\\nimport '../modules/Configable.sol';\\n\\ncontract UserTokenLimit is Configable {\\n    using SafeMath for uint;\\n\\n    struct TokenLimit {\\n        bool enabled;\\n        uint blocks;\\n        uint amount;\\n    }\\n    //key:(token)\\n    mapping(address => TokenLimit) public tokenLimits;\\n\\n    struct UserLimit {\\n        uint lastBlock;\\n        uint consumption;\\n    }\\n    //key:(white user, token)\\n    mapping(address => mapping(address => UserLimit)) public userLimits;\\n\\n    function setTokenLimit(address _token, bool _enabled, uint _blocks, uint _amount) public onlyManager {\\n        TokenLimit storage limit = tokenLimits[_token];\\n        limit.enabled = _enabled;\\n        limit.blocks = _blocks;\\n        limit.amount = _amount;\\n    }\\n\\n    function setTokenLimits(address[] memory _token, bool[] memory _enabled, uint[] memory _blocks, uint[] memory _amount) external onlyManager {\\n        require(\\n            _token.length == _enabled.length \\n            && _enabled.length == _blocks.length \\n            && _blocks.length == _amount.length \\n            , \\\"UserTokenLimit: INVALID_PARAM\\\"\\n        );\\n        for (uint i; i < _token.length; i++) {\\n            setTokenLimit(_token[i], _enabled[i], _blocks[i], _amount[i]);\\n        }\\n    }\\n\\n    function setTokenLimitEnable(address _token, bool _enabled) public onlyManager {\\n        TokenLimit storage limit = tokenLimits[_token];\\n        limit.enabled = _enabled;\\n    }\\n\\n    function setTokenLimitEnables(address[] memory _token, bool[] memory _enabled) external onlyManager {\\n        require(\\n            _token.length == _enabled.length \\n            , \\\"UserTokenLimit: INVALID_PARAM\\\"\\n        );\\n        for (uint i; i < _token.length; i++) {\\n            setTokenLimitEnable(_token[i], _enabled[i]);\\n        }\\n    }\\n\\n    function getUserLimit(address _user, address _token, uint _value) public view returns (uint) {\\n        TokenLimit memory tokenLimit = tokenLimits[_token];\\n        if (tokenLimit.enabled == false) {\\n            return _value;\\n        }\\n        \\n        if(_value > tokenLimit.amount) {\\n            _value = tokenLimit.amount;\\n        }\\n\\n        UserLimit memory limit = userLimits[_user][_token];\\n        if (block.number.sub(limit.lastBlock) >= tokenLimit.blocks) {\\n            return _value;\\n        }\\n\\n        if (limit.consumption.add(_value) > tokenLimit.amount) {\\n            _value = tokenLimit.amount.sub(limit.consumption);\\n        }\\n        return _value;\\n    }\\n\\n    function _updateUserTokenLimit(address _token, uint _value) internal {\\n        TokenLimit memory tokenLimit = tokenLimits[_token];\\n        if(tokenLimit.enabled == false) {\\n            return;\\n        }\\n\\n        UserLimit storage limit = userLimits[msg.sender][_token];\\n        if(block.number.sub(limit.lastBlock) > tokenLimit.blocks) {\\n            limit.consumption = 0;\\n        }\\n        limit.lastBlock = block.number;\\n        limit.consumption = limit.consumption.add(_value);\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwitchTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\ninterface ISwitchTreasury {\\n    function tokenBalanceOf(address _token) external returns (uint);\\n    function mint(address _token, address _to, uint _value) external returns (uint);\\n    function burn(address _token, address _from, uint _value) external returns (uint);\\n    function deposit(address _from, address _token, uint _value) external payable returns (uint);\\n    function queryWithdraw(address _user, address _token) external view returns (uint);\\n    function withdraw(bool _isETH, address _to, address _token, uint _value) external returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwitchSigner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\ninterface ISwitchSigner {\\n    function checkUser(address _user) external view returns (bool);\\n    function verify(uint _mode, address _user, address _singer, bytes32 _message, bytes memory _signature) external view returns (bool);\\n    function mverify(uint _mode, address _user, address _singer, bytes32 _message, bytes[] memory _signatures) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwitchTicketFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\ninterface ISwitchTicketFactory {\\n    function treasury() external view returns (address);\\n    function getTokenMap(address _token) external view returns (address);\\n    function isTicket(address _ticket) external view returns (bool);\\n    function deposit(address _token, uint _value, address _to) external payable returns (address);\\n    function queryWithdrawInfo(address _user, address _ticket) external view returns (uint balance, uint amount);\\n    function queryWithdraw(address _user, address _ticket) external view returns (uint);\\n    function withdraw(bool isETH, address _to, address _ticket, uint _value) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IRewardToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\ninterface IRewardToken {\\n    function balanceOf(address owner) external view returns (uint);\\n    function take() external view returns (uint);\\n    function funds(address user) external view returns (uint);\\n    function mint(address to, uint value) external returns (bool);\\n}\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/modules/Configable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.6;\\n\\ninterface IConfig {\\n    function dev() external view returns (address);\\n    function admin() external view returns (address);\\n}\\n\\ncontract Configable {\\n    address public config;\\n    address public owner;\\n\\n    event ConfigChanged(address indexed _user, address indexed _old, address indexed _new);\\n    event OwnerChanged(address indexed _user, address indexed _old, address indexed _new);\\n \\n    function setupConfig(address _config) external onlyOwner {\\n        emit ConfigChanged(msg.sender, config, _config);\\n        config = _config;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, 'OWNER FORBIDDEN');\\n        _;\\n    }\\n\\n    function admin() public view returns(address) {\\n        if(config != address(0)) {\\n            return IConfig(config).admin();\\n        }\\n        return owner;\\n    }\\n\\n    function dev() public view returns(address) {\\n        if(config != address(0)) {\\n            return IConfig(config).dev();\\n        }\\n        return owner;\\n    }\\n\\n    function changeOwner(address _user) external onlyOwner {\\n        require(owner != _user, 'Owner: NO CHANGE');\\n        emit OwnerChanged(msg.sender, owner, _user);\\n        owner = _user;\\n    }\\n    \\n    modifier onlyDev() {\\n        require(msg.sender == dev() || msg.sender == owner, 'dev FORBIDDEN');\\n        _;\\n    }\\n    \\n    modifier onlyAdmin() {\\n        require(msg.sender == admin(), 'admin FORBIDDEN');\\n        _;\\n    }\\n  \\n    modifier onlyManager() {\\n        require(msg.sender == dev() || msg.sender == admin() || msg.sender == owner, 'manager FORBIDDEN');\\n        _;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_old\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"BaseFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"ChianFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"ConfigChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_ticketFactory\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_mode\",\"type\":\"uint256\"}],\"name\":\"ConfigureChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"FeeWalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"GasWalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_old\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"RewardRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_enabledIn\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_enabledOut\",\"type\":\"bool\"}],\"name\":\"TokenEnableChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainIdOut\",\"type\":\"uint256\"}],\"name\":\"TokenMapChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"sn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mode\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slide\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"TransferIned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"sn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mode\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slide\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inSn\",\"type\":\"uint256\"}],\"name\":\"TransferOuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"chainFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"changeFeeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"changeGasWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mode\",\"type\":\"uint256\"}],\"name\":\"checkMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectGasFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"collectSlide\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectedAccuFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectedAccuGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"collectedAccuSlideOfToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"computeReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ticketFactory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_mode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_baseFee\",\"type\":\"uint256\"}],\"name\":\"configure\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_toChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"name\":\"getAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slide\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_toChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slide\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"getDataHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_toChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mode\",\"type\":\"uint256\"}],\"name\":\"getInInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slide\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outLimit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_toChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mode\",\"type\":\"uint256\"}],\"name\":\"getOutInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slide\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outLimit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_toChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"getSlide\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getUserLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isTicket\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mode\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"outOrders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"outSn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"queryWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_baseFee\",\"type\":\"uint256\"}],\"name\":\"setBaseFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setChainFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_chainId\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_fee\",\"type\":\"uint256[]\"}],\"name\":\"setChainFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardRate\",\"type\":\"uint256\"}],\"name\":\"setRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenIn\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_rewardRate\",\"type\":\"uint256[]\"}],\"name\":\"setRewardRates\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabledIn\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_enabledOut\",\"type\":\"bool\"}],\"name\":\"setTokenEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenIn\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_enabledIn\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"_enabledOut\",\"type\":\"bool[]\"}],\"name\":\"setTokenEnables\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_blocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setTokenLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setTokenLimitEnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_token\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_enabled\",\"type\":\"bool[]\"}],\"name\":\"setTokenLimitEnables\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_token\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_enabled\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_blocks\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount\",\"type\":\"uint256[]\"}],\"name\":\"setTokenLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_chainIdOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenOutDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenOutLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slideMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slideMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_slidePre\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardRate\",\"type\":\"uint256\"}],\"name\":\"setTokenMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenIn\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_tokenOut\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_chainIdOut\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenOutDecimals\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenOutLimit\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_fee\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_slideMin\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_slideMax\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_slidePre\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_rewardRate\",\"type\":\"uint256[]\"}],\"name\":\"setTokenMaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_config\",\"type\":\"address\"}],\"name\":\"setupConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sourceTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabledIn\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"enabledOut\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"added\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"targetTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slideMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slideMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slidePre\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"blocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalSlideOfToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"transferIn\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_signatures\",\"type\":\"bytes[]\"}],\"name\":\"transferOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"consumption\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SwitchAcross","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}