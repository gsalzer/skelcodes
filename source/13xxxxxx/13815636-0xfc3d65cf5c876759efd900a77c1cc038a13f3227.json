{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/loans/direct/loanTypes/LoanChecksAndCalculations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./IDirectLoanBase.sol\\\";\\nimport \\\"./LoanData.sol\\\";\\nimport \\\"../../../interfaces/IDirectLoanCoordinator.sol\\\";\\nimport \\\"../../../utils/ContractKeys.sol\\\";\\nimport \\\"../../../interfaces/INftfiHub.sol\\\";\\nimport \\\"../../../interfaces/IPermittedPartners.sol\\\";\\nimport \\\"../../../interfaces/IPermittedERC20s.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/**\\n * @title  LoanChecksAndCalculations\\n * @author NFTfi\\n * @notice Helper library for LoanBase\\n */\\nlibrary LoanChecksAndCalculations {\\n    uint16 private constant HUNDRED_PERCENT = 10000;\\n\\n    /**\\n     * @dev Function that performs some validation checks before trying to repay a loan\\n     *\\n     * @param _loanId - The id of the loan being repaid\\n     */\\n    function payBackChecks(uint256 _loanId, INftfiHub _hub) external view {\\n        checkLoanIdValidity(_loanId, _hub);\\n        // Sanity check that payBackLoan() and liquidateOverdueLoan() have never been called on this loanId.\\n        // Depending on how the rest of the code turns out, this check may be unnecessary.\\n        require(!IDirectLoanBase(address(this)).loanRepaidOrLiquidated(_loanId), \\\"Loan already repaid/liquidated\\\");\\n\\n        // Fetch loan details from storage, but store them in memory for the sake of saving gas.\\n        (, , , , , , uint64 loanStartTime, uint32 loanDuration, , ) = IDirectLoanBase(address(this)).loanIdToLoan(\\n            _loanId\\n        );\\n\\n        // When a loan exceeds the loan term, it is expired. At this stage the Lender can call Liquidate Loan to resolve\\n        // the loan.\\n        require(block.timestamp <= (uint256(loanStartTime) + uint256(loanDuration)), \\\"Loan is expired\\\");\\n    }\\n\\n    function checkLoanIdValidity(uint256 _loanId, INftfiHub _hub) public view {\\n        require(\\n            IDirectLoanCoordinator(_hub.getContract(IDirectLoanBase(address(this)).LOAN_COORDINATOR())).isValidLoanId(\\n                _loanId,\\n                address(this)\\n            ),\\n            \\\"invalid loanId\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Function that the partner is permitted and returns its shared percent.\\n     *\\n     * @param _revenueSharePartner - Partner's address\\n     *\\n     * @return The revenue share percent for the partner.\\n     */\\n    function getRevenueSharePercent(address _revenueSharePartner, INftfiHub _hub) external view returns (uint16) {\\n        // return soon if no partner is set to avoid a public call\\n        if (_revenueSharePartner == address(0)) {\\n            return 0;\\n        }\\n\\n        uint16 revenueSharePercent = IPermittedPartners(_hub.getContract(ContractKeys.PERMITTED_PARTNERS))\\n        .getPartnerPermit(_revenueSharePartner);\\n\\n        return revenueSharePercent;\\n    }\\n\\n    /**\\n     * @dev Performs some validation checks over loan parameters\\n     *\\n     */\\n    function loanSanityChecks(\\n        LoanData.Offer memory _offer,\\n        address nftWrapper,\\n        INftfiHub _hub\\n    ) external view {\\n        require(\\n            IPermittedERC20s(_hub.getContract(ContractKeys.PERMITTED_ERC20S)).getERC20Permit(\\n                _offer.loanERC20Denomination\\n            ),\\n            \\\"Currency denomination is not permitted\\\"\\n        );\\n        require(nftWrapper != address(0), \\\"NFT collateral contract is not permitted\\\");\\n        require(\\n            uint256(_offer.loanDuration) <= IDirectLoanBase(address(this)).maximumLoanDuration(),\\n            \\\"Loan duration exceeds maximum loan duration\\\"\\n        );\\n        require(uint256(_offer.loanDuration) != 0, \\\"Loan duration cannot be zero\\\");\\n        require(\\n            _offer.loanAdminFeeInBasisPoints == IDirectLoanBase(address(this)).adminFeeInBasisPoints(),\\n            \\\"The admin fee has changed since this order was signed.\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Function that performs some validation checks over loan parameters when accepting an offer\\n     *\\n     */\\n    function loanSanityChecksOffer(LoanData.Offer memory _offer) external pure {\\n        require(\\n            _offer.maximumRepaymentAmount >= _offer.loanPrincipalAmount,\\n            \\\"Negative interest rate loans are not allowed.\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Performs some validation checks before trying to renegotiate a loan.\\n     * Needed to avoid stack too deep.\\n     *\\n     * @param _loan - The main Loan Terms struct.\\n     * @param _loanId - The unique identifier for the loan to be renegotiated\\n     * @param _newLoanDuration - The new amount of time (measured in seconds) that can elapse before the lender can\\n     * liquidate the loan and seize the underlying collateral NFT.\\n     * @param _newMaximumRepaymentAmount - The new maximum amount of money that the borrower would be required to\\n     * retrieve their collateral, measured in the smallest units of the ERC20 currency used for the loan. The\\n     * borrower will always have to pay this amount to retrieve their collateral, regardless of whether they repay\\n     * early.\\n     * @param _lenderNonce - The nonce referred to here is not the same as an Ethereum account's nonce. We are\\n     * referring instead to nonces that are used by both the lender and the borrower when they are first signing\\n     * off-chain NFTfi orders. These nonces can be any uint256 value that the user has not previously used to sign an\\n     * off-chain order. Each nonce can be used at most once per user within NFTfi, regardless of whether they are the\\n     * lender or the borrower in that situation. This serves two purposes:\\n     * - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\\n     * - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun()\\n     , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains\\n     * that nonce.\\n     * @return Borrower and Lender addresses\\n     */\\n    function renegotiationChecks(\\n        LoanData.LoanTerms memory _loan,\\n        uint256 _loanId,\\n        uint32 _newLoanDuration,\\n        uint256 _newMaximumRepaymentAmount,\\n        uint256 _lenderNonce,\\n        INftfiHub _hub\\n    ) external view returns (address, address) {\\n        checkLoanIdValidity(_loanId, _hub);\\n        IDirectLoanCoordinator loanCoordinator = IDirectLoanCoordinator(\\n            _hub.getContract(IDirectLoanBase(address(this)).LOAN_COORDINATOR())\\n        );\\n        uint256 smartNftId = loanCoordinator.getLoanData(_loanId).smartNftId;\\n\\n        address borrower = IERC721(loanCoordinator.obligationReceiptToken()).ownerOf(smartNftId);\\n\\n        require(msg.sender == borrower, \\\"Only borrower can initiate\\\");\\n        require(block.timestamp <= (uint256(_loan.loanStartTime) + _newLoanDuration), \\\"New duration already expired\\\");\\n        require(\\n            uint256(_newLoanDuration) <= IDirectLoanBase(address(this)).maximumLoanDuration(),\\n            \\\"New duration exceeds maximum loan duration\\\"\\n        );\\n        require(!IDirectLoanBase(address(this)).loanRepaidOrLiquidated(_loanId), \\\"Loan already repaid/liquidated\\\");\\n        require(\\n            _newMaximumRepaymentAmount >= _loan.loanPrincipalAmount,\\n            \\\"Negative interest rate loans are not allowed.\\\"\\n        );\\n\\n        // Fetch current owner of loan promissory note.\\n        address lender = IERC721(loanCoordinator.promissoryNoteToken()).ownerOf(smartNftId);\\n\\n        require(\\n            !IDirectLoanBase(address(this)).getWhetherNonceHasBeenUsedForUser(lender, _lenderNonce),\\n            \\\"Lender nonce invalid\\\"\\n        );\\n\\n        return (borrower, lender);\\n    }\\n\\n    /**\\n     * @dev Performs some validation checks over loan parameters when accepting a listing\\n     *\\n     */\\n    function bindingTermsSanityChecks(LoanData.ListingTerms memory _listingTerms, LoanData.Offer memory _offer)\\n        external\\n        pure\\n    {\\n        // offer vs listing validations\\n        require(_offer.loanERC20Denomination == _listingTerms.loanERC20Denomination, \\\"Invalid loanERC20Denomination\\\");\\n        require(\\n            _offer.loanPrincipalAmount >= _listingTerms.minLoanPrincipalAmount &&\\n                _offer.loanPrincipalAmount <= _listingTerms.maxLoanPrincipalAmount,\\n            \\\"Invalid loanPrincipalAmount\\\"\\n        );\\n        uint256 maxRepaymentLimit = _offer.loanPrincipalAmount +\\n            (_offer.loanPrincipalAmount * _listingTerms.maxInterestRateForDurationInBasisPoints) /\\n            HUNDRED_PERCENT;\\n        require(_offer.maximumRepaymentAmount <= maxRepaymentLimit, \\\"maxInterestRateForDurationInBasisPoints violated\\\");\\n\\n        require(\\n            _offer.loanDuration >= _listingTerms.minLoanDuration &&\\n                _offer.loanDuration <= _listingTerms.maxLoanDuration,\\n            \\\"Invalid loanDuration\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice A convenience function computing the revenue share taken from the admin fee to transferr to the permitted\\n     * partner.\\n     *\\n     * @param _adminFee - The quantity of ERC20 currency (measured in smalled units of that ERC20 currency) that is due\\n     * as an admin fee.\\n     * @param _revenueShareInBasisPoints - The percent (measured in basis points) of the admin fee amount that will be\\n     * taken as a revenue share for a the partner, at the moment the loan is begun.\\n     *\\n     * @return The quantity of ERC20 currency (measured in smalled units of that ERC20 currency) that should be sent to\\n     * the `revenueSharePartner`.\\n     */\\n    function computeRevenueShare(uint256 _adminFee, uint256 _revenueShareInBasisPoints)\\n        external\\n        pure\\n        returns (uint256)\\n    {\\n        return (_adminFee * _revenueShareInBasisPoints) / HUNDRED_PERCENT;\\n    }\\n\\n    /**\\n     * @notice A convenience function computing the adminFee taken from a specified quantity of interest.\\n     *\\n     * @param _interestDue - The amount of interest due, measured in the smallest quantity of the ERC20 currency being\\n     * used to pay the interest.\\n     * @param _adminFeeInBasisPoints - The percent (measured in basis points) of the interest earned that will be taken\\n     * as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\\n     * earned.\\n     *\\n     * @return The quantity of ERC20 currency (measured in smalled units of that ERC20 currency) that is due as an admin\\n     * fee.\\n     */\\n    function computeAdminFee(uint256 _interestDue, uint256 _adminFeeInBasisPoints) external pure returns (uint256) {\\n        return (_interestDue * _adminFeeInBasisPoints) / HUNDRED_PERCENT;\\n    }\\n\\n    /**\\n     * @notice A convenience function computing the referral fee taken from the loan principal amount to transferr to\\n     * the referrer.\\n     *\\n     * @param _loanPrincipalAmount - The original sum of money transferred from lender to borrower at the beginning of\\n     * the loan, measured in loanERC20Denomination's smallest units.\\n     * @param _referralFeeInBasisPoints - The percent (measured in basis points) of the loan principal amount that will\\n     * be taken as a fee to pay to the referrer, 0 if the lender is not paying referral fee.\\n     * @param _referrer - The address of the referrer who found the lender matching the listing, Zero address to signal\\n     * that there is no referrer.\\n     *\\n     * @return The quantity of ERC20 currency (measured in smalled units of that ERC20 currency) that should be sent to\\n     * the referrer.\\n     */\\n    function computeReferralFee(\\n        uint256 _loanPrincipalAmount,\\n        uint256 _referralFeeInBasisPoints,\\n        address _referrer\\n    ) external pure returns (uint256) {\\n        if (_referralFeeInBasisPoints == 0 || _referrer == address(0)) {\\n            return 0;\\n        }\\n        return (_loanPrincipalAmount * _referralFeeInBasisPoints) / HUNDRED_PERCENT;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/loans/direct/loanTypes/IDirectLoanBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\nimport \\\"./LoanData.sol\\\";\\n\\npragma solidity 0.8.4;\\n\\ninterface IDirectLoanBase {\\n    function maximumLoanDuration() external view returns (uint256);\\n\\n    function adminFeeInBasisPoints() external view returns (uint16);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function LOAN_COORDINATOR() external view returns (bytes32);\\n\\n    function loanIdToLoan(uint256)\\n        external\\n        view\\n        returns (\\n            address,\\n            uint256,\\n            uint256,\\n            address,\\n            address,\\n            uint256,\\n            uint64,\\n            uint32,\\n            uint16,\\n            uint16\\n        );\\n\\n    function loanRepaidOrLiquidated(uint256) external view returns (bool);\\n\\n    function getWhetherNonceHasBeenUsedForUser(address _user, uint256 _nonce) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/loans/direct/loanTypes/LoanData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title  LoanData\\n * @author NFTfi\\n * @notice A convenience contract containg the main Loan struct shared by Direct Loans types.\\n */\\nabstract contract LoanData {\\n    /* ********** */\\n    /* DATA TYPES */\\n    /* ********** */\\n\\n    /**\\n     * @notice The main Loan Terms struct. This data is saved upon loan creation.\\n     *\\n     * @param loanERC20Denomination - The address of the ERC20 contract of the currency being used as principal/interest\\n     * for this loan.\\n     * @param loanPrincipalAmount - The original sum of money transferred from lender to borrower at the beginning of\\n     * the loan, measured in loanERC20Denomination's smallest units.\\n     * @param maximumRepaymentAmount - The maximum amount of money that the borrower would be required to retrieve their\\n     * collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have\\n     * to pay this amount to retrieve their collateral, regardless of whether they repay early.\\n     * @param nftCollateralContract - The address of the the NFT collateral contract.\\n     * @param nftCollateralWrapper - The NFTfi wrapper of the NFT collateral contract.\\n     * @param nftCollateralId - The ID within the NFTCollateralContract for the NFT being used as collateral for this\\n     * loan. The NFT is stored within this contract during the duration of the loan.\\n     * @param loanStartTime - The block.timestamp when the loan first began (measured in seconds).\\n     * @param loanDuration - The amount of time (measured in seconds) that can elapse before the lender can liquidate\\n     * the loan and seize the underlying collateral NFT.\\n     * @param loanInterestRateForDurationInBasisPoints - This is the interest rate (measured in basis points, e.g.\\n     * hundreths of a percent) for the loan, that must be repaid pro-rata by the borrower at the conclusion of the loan\\n     * or risk seizure of their nft collateral. Note if the type of the loan is fixed then this value  is not used and\\n     * is irrelevant so it should be set to 0.\\n     * @param loanAdminFeeInBasisPoints - The percent (measured in basis points) of the interest earned that will be\\n     * taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\\n     * earned.\\n     */\\n    struct LoanTerms {\\n        address loanERC20Denomination;\\n        uint256 loanPrincipalAmount;\\n        uint256 maximumRepaymentAmount;\\n        address nftCollateralContract;\\n        address nftCollateralWrapper;\\n        uint256 nftCollateralId;\\n        uint64 loanStartTime;\\n        uint32 loanDuration;\\n        uint16 loanInterestRateForDurationInBasisPoints;\\n        uint16 loanAdminFeeInBasisPoints;\\n    }\\n\\n    /**\\n     * @notice Some extra Loan's settings struct. This data is saved upon loan creation.\\n     * We need this to avoid stack too deep errors.\\n     *\\n     * @param revenueSharePartner - The address of the partner that will receive the revenue share.\\n     * @param revenueShareInBasisPoints - The percent (measured in basis points) of the admin fee amount that will be\\n     * taken as a revenue share for a t\\n     * @param referralFeeInBasisPoints - The percent (measured in basis points) of the loan principal amount that will\\n     * be taken as a fee to pay to the referrer, 0 if the lender is not paying referral fee.he partner, at the moment\\n     * the loan is begun.\\n     */\\n    struct LoanExtras {\\n        address revenueSharePartner;\\n        uint16 revenueShareInBasisPoints;\\n        uint16 referralFeeInBasisPoints;\\n    }\\n\\n    /**\\n     * @notice The offer made by the lender. Used as parameter on both acceptOffer (initiated by the borrower) and\\n     * acceptListing (initiated by the lender).\\n     *\\n     * @param loanERC20Denomination - The address of the ERC20 contract of the currency being used as principal/interest\\n     * for this loan.\\n     * @param loanPrincipalAmount - The original sum of money transferred from lender to borrower at the beginning of\\n     * the loan, measured in loanERC20Denomination's smallest units.\\n     * @param maximumRepaymentAmount - The maximum amount of money that the borrower would be required to retrieve their\\n     *  collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always\\n     * have to pay this amount to retrieve their collateral, regardless of whether they repay early.\\n     * @param nftCollateralContract - The address of the ERC721 contract of the NFT collateral.\\n     * @param nftCollateralId - The ID within the NFTCollateralContract for the NFT being used as collateral for this\\n     * loan. The NFT is stored within this contract during the duration of the loan.\\n     * @param referrer - The address of the referrer who found the lender matching the listing, Zero address to signal\\n     * this there is no referrer.\\n     * @param loanDuration - The amount of time (measured in seconds) that can elapse before the lender can liquidate\\n     * the loan and seize the underlying collateral NFT.\\n     * @param loanAdminFeeInBasisPoints - The percent (measured in basis points) of the interest earned that will be\\n     * taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\\n     * earned.\\n     */\\n    struct Offer {\\n        address loanERC20Denomination;\\n        uint256 loanPrincipalAmount;\\n        uint256 maximumRepaymentAmount;\\n        address nftCollateralContract;\\n        uint256 nftCollateralId;\\n        address referrer;\\n        uint32 loanDuration;\\n        uint16 loanAdminFeeInBasisPoints;\\n    }\\n\\n    /**\\n     * @notice Signature related params. Used as parameter on both acceptOffer (containing borrower signature) and\\n     * acceptListing (containing lender signature).\\n     *\\n     * @param signer - The address of the signer. The borrower for `acceptOffer` the lender for `acceptListing`.\\n     * @param nonce - The nonce referred here is not the same as an Ethereum account's nonce.\\n     * We are referring instead to a nonce that is used by the lender or the borrower when they are first signing\\n     * off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an\\n     * off-chain order. Each nonce can be used at most once per user within NFTfi, regardless of whether they are the\\n     * lender or the borrower in that situation. This serves two purposes:\\n     * - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\\n     * - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun()\\n     * , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains\\n     * that nonce.\\n     * @param expiry - Date when the signature expires\\n     * @param signature - The ECDSA signature of the borrower or the lender, obtained off-chain ahead of time, signing\\n     * the following combination of parameters:\\n     * - Borrower\\n     *   - ListingTerms.loanERC20Denomination,\\n     *   - ListingTerms.minLoanPrincipalAmount,\\n     *   - ListingTerms.maxLoanPrincipalAmount,\\n     *   - ListingTerms.nftCollateralContract,\\n     *   - ListingTerms.nftCollateralId,\\n     *   - ListingTerms.revenueSharePartner,\\n     *   - ListingTerms.minLoanDuration,\\n     *   - ListingTerms.maxLoanDuration,\\n     *   - ListingTerms.maxInterestRateForDurationInBasisPoints,\\n     *   - ListingTerms.referralFeeInBasisPoints,\\n     *   - Signature.signer,\\n     *   - Signature.nonce,\\n     *   - Signature.expiry,\\n     *   - address of the loan type contract\\n     *   - chainId\\n     * - Lender:\\n     *   - Offer.loanERC20Denomination\\n     *   - Offer.loanPrincipalAmount\\n     *   - Offer.maximumRepaymentAmount\\n     *   - Offer.nftCollateralContract\\n     *   - Offer.nftCollateralId\\n     *   - Offer.referrer\\n     *   - Offer.loanDuration\\n     *   - Offer.loanAdminFeeInBasisPoints\\n     *   - Signature.signer,\\n     *   - Signature.nonce,\\n     *   - Signature.expiry,\\n     *   - address of the loan type contract\\n     *   - chainId\\n     */\\n    struct Signature {\\n        address signer;\\n        uint256 nonce;\\n        uint256 expiry;\\n        bytes signature;\\n    }\\n\\n    /**\\n     * @notice Some extra parameters that the borrower needs to set when accepting an offer.\\n     *\\n     * @param revenueSharePartner - The address of the partner that will receive the revenue share.\\n     * @param referralFeeInBasisPoints - The percent (measured in basis points) of the loan principal amount that will\\n     * be taken as a fee to pay to the referrer, 0 if the lender is not paying referral fee.\\n     */\\n    struct BorrowerSettings {\\n        address revenueSharePartner;\\n        uint16 referralFeeInBasisPoints;\\n    }\\n\\n    /**\\n     * @notice Terms the borrower set off-chain and is willing to accept automatically when fulfiled by a lender's\\n     * offer.\\n     *\\n     * @param loanERC20Denomination - The address of the ERC20 contract of the currency being used as principal/interest\\n     * for this loan.\\n     * @param minLoanPrincipalAmount - The minumum sum of money transferred from lender to borrower at the beginning of\\n     * the loan, measured in loanERC20Denomination's smallest units.\\n     * @param maxLoanPrincipalAmount - The  sum of money transferred from lender to borrower at the beginning of\\n     * the loan, measured in loanERC20Denomination's smallest units.\\n     * @param maximumRepaymentAmount - The maximum amount of money that the borrower would be required to retrieve their\\n     * collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have\\n     * to pay this amount to retrieve their collateral, regardless of whether they repay early.\\n     * @param nftCollateralContract - The address of the ERC721 contract of the NFT collateral.\\n     * @param nftCollateralId - The ID within the NFTCollateralContract for the NFT being used as collateral for this\\n     * loan. The NFT is stored within this contract during the duration of the loan.\\n     * @param revenueSharePartner - The address of the partner that will receive the revenue share.\\n     * @param minLoanDuration - The minumum amount of time (measured in seconds) that can elapse before the lender can\\n     * liquidate the loan and seize the underlying collateral NFT.\\n     * @param maxLoanDuration - The maximum amount of time (measured in seconds) that can elapse before the lender can\\n     * liquidate the loan and seize the underlying collateral NFT.\\n     * @param maxInterestRateForDurationInBasisPoints - This is maximum the interest rate (measured in basis points,\\n     * e.g. hundreths of a percent) for the loan.\\n     * @param referralFeeInBasisPoints - The percent (measured in basis points) of the loan principal amount that will\\n     * be taken as a fee to pay to the referrer, 0 if the lender is not paying referral fee.\\n     */\\n    struct ListingTerms {\\n        address loanERC20Denomination;\\n        uint256 minLoanPrincipalAmount;\\n        uint256 maxLoanPrincipalAmount;\\n        address nftCollateralContract;\\n        uint256 nftCollateralId;\\n        address revenueSharePartner;\\n        uint32 minLoanDuration;\\n        uint32 maxLoanDuration;\\n        uint16 maxInterestRateForDurationInBasisPoints;\\n        uint16 referralFeeInBasisPoints;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDirectLoanCoordinator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title IDirectLoanCoordinator\\n * @author NFTfi\\n * @dev DirectLoanCoordinator interface.\\n */\\ninterface IDirectLoanCoordinator {\\n    enum StatusType {\\n        NOT_EXISTS,\\n        NEW,\\n        RESOLVED\\n    }\\n\\n    /**\\n     * @notice This struct contains data related to a loan\\n     *\\n     * @param smartNftId - The id of both the promissory note and obligation receipt.\\n     * @param status - The status in which the loan currently is.\\n     * @param loanContract - Address of the LoanType contract that created the loan.\\n     */\\n    struct Loan {\\n        uint256 smartNftId;\\n        StatusType status;\\n        address loanContract;\\n    }\\n\\n    function registerLoan(\\n        address _lender,\\n        address _borrower,\\n        bytes32 _loanType\\n    ) external returns (uint256);\\n\\n    function resolveLoan(uint256 _loanId) external;\\n\\n    function promissoryNoteToken() external view returns (address);\\n\\n    function obligationReceiptToken() external view returns (address);\\n\\n    function getLoanData(uint256 _loanId) external view returns (Loan memory);\\n\\n    function isValidLoanId(uint256 _loanId, address _loanContract) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ContractKeys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title ContractKeys\\n * @author NFTfi\\n * @dev Common library for contract keys\\n */\\nlibrary ContractKeys {\\n    bytes32 public constant PERMITTED_ERC20S = bytes32(\\\"PERMITTED_ERC20S\\\");\\n    bytes32 public constant PERMITTED_NFTS = bytes32(\\\"PERMITTED_NFTS\\\");\\n    bytes32 public constant PERMITTED_PARTNERS = bytes32(\\\"PERMITTED_PARTNERS\\\");\\n    bytes32 public constant NFT_TYPE_REGISTRY = bytes32(\\\"NFT_TYPE_REGISTRY\\\");\\n    bytes32 public constant LOAN_REGISTRY = bytes32(\\\"LOAN_REGISTRY\\\");\\n    bytes32 public constant PERMITTED_SNFT_RECEIVER = bytes32(\\\"PERMITTED_SNFT_RECEIVER\\\");\\n    bytes32 public constant PERMITTED_BUNDLE_ERC20S = bytes32(\\\"PERMITTED_BUNDLE_ERC20S\\\");\\n    bytes32 public constant PERMITTED_AIRDROPS = bytes32(\\\"PERMITTED_AIRDROPS\\\");\\n    bytes32 public constant AIRDROP_RECEIVER = bytes32(\\\"AIRDROP_RECEIVER\\\");\\n    bytes32 public constant AIRDROP_FACTORY = bytes32(\\\"AIRDROP_FACTORY\\\");\\n    bytes32 public constant AIRDROP_FLASH_LOAN = bytes32(\\\"AIRDROP_FLASH_LOAN\\\");\\n    bytes32 public constant NFTFI_BUNDLER = bytes32(\\\"NFTFI_BUNDLER\\\");\\n\\n    string public constant AIRDROP_WRAPPER_STRING = \\\"AirdropWrapper\\\";\\n\\n    /**\\n     * @notice Returns the bytes32 representation of a string\\n     * @param _key the string key\\n     * @return id bytes32 representation\\n     */\\n    function getIdFromStringKey(string memory _key) external pure returns (bytes32 id) {\\n        require(bytes(_key).length <= 32, \\\"invalid key\\\");\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            id := mload(add(_key, 32))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INftfiHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title INftfiHub\\n * @author NFTfi\\n * @dev NftfiHub interface\\n */\\ninterface INftfiHub {\\n    function setContract(string calldata _contractKey, address _contractAddress) external;\\n\\n    function getContract(bytes32 _contractKey) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPermittedPartners.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\ninterface IPermittedPartners {\\n    function getPartnerPermit(address _partner) external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPermittedERC20s.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\ninterface IPermittedERC20s {\\n    function getERC20Permit(address _erc20) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"loanERC20Denomination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minLoanPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLoanPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"revenueSharePartner\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"minLoanDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxLoanDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"maxInterestRateForDurationInBasisPoints\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"referralFeeInBasisPoints\",\"type\":\"uint16\"}],\"internalType\":\"struct LoanData.ListingTerms\",\"name\":\"_listingTerms\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"loanERC20Denomination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loanPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRepaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"loanDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"loanAdminFeeInBasisPoints\",\"type\":\"uint16\"}],\"internalType\":\"struct LoanData.Offer\",\"name\":\"_offer\",\"type\":\"tuple\"}],\"name\":\"bindingTermsSanityChecks\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"},{\"internalType\":\"contract INftfiHub\",\"name\":\"_hub\",\"type\":\"INftfiHub\"}],\"name\":\"checkLoanIdValidity\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_interestDue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_adminFeeInBasisPoints\",\"type\":\"uint256\"}],\"name\":\"computeAdminFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_referralFeeInBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"computeReferralFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_adminFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_revenueShareInBasisPoints\",\"type\":\"uint256\"}],\"name\":\"computeRevenueShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_revenueSharePartner\",\"type\":\"address\"},{\"internalType\":\"contract INftfiHub\",\"name\":\"_hub\",\"type\":\"INftfiHub\"}],\"name\":\"getRevenueSharePercent\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"loanERC20Denomination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loanPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRepaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"loanDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"loanAdminFeeInBasisPoints\",\"type\":\"uint16\"}],\"internalType\":\"struct LoanData.Offer\",\"name\":\"_offer\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"nftWrapper\",\"type\":\"address\"},{\"internalType\":\"contract INftfiHub\",\"name\":\"_hub\",\"type\":\"INftfiHub\"}],\"name\":\"loanSanityChecks\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"loanERC20Denomination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loanPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRepaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"loanDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"loanAdminFeeInBasisPoints\",\"type\":\"uint16\"}],\"internalType\":\"struct LoanData.Offer\",\"name\":\"_offer\",\"type\":\"tuple\"}],\"name\":\"loanSanityChecksOffer\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"},{\"internalType\":\"contract INftfiHub\",\"name\":\"_hub\",\"type\":\"INftfiHub\"}],\"name\":\"payBackChecks\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"loanERC20Denomination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loanPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumRepaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftCollateralContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftCollateralWrapper\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftCollateralId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"loanStartTime\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"loanDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"loanInterestRateForDurationInBasisPoints\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"loanAdminFeeInBasisPoints\",\"type\":\"uint16\"}],\"internalType\":\"struct LoanData.LoanTerms\",\"name\":\"_loan\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_loanId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_newLoanDuration\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"_newMaximumRepaymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lenderNonce\",\"type\":\"uint256\"},{\"internalType\":\"contract INftfiHub\",\"name\":\"_hub\",\"type\":\"INftfiHub\"}],\"name\":\"renegotiationChecks\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LoanChecksAndCalculations","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}