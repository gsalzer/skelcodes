{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/EscrowV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport \\\"./extensions/EscrowContract.sol\\\";\\nimport \\\"./extensions/WithPreSignedMilestones.sol\\\";\\nimport \\\"./extensions/AmendablePreSigned.sol\\\";\\nimport \\\"./interfaces/IEscrowDisputeManager.sol\\\";\\n\\ncontract EscrowV1 is EscrowContract, AmendablePreSigned, WithPreSignedMilestones {\\n    using Address for address;\\n\\n    string private constant ERROR_INVALID_PARTIES = \\\"Invalid parties\\\";\\n    string private constant ERROR_NOT_DISPUTER = \\\"Not a disputer\\\";\\n    string private constant ERROR_NO_MONEY = \\\"Nothing to withdraw\\\";\\n    string private constant ERROR_NOT_APPROVED = \\\"Not signed\\\";\\n    string private constant ERROR_INVALID_SETTLEMENT = \\\"100% required\\\";\\n    string private constant ERROR_DISPUTE_PARENT = \\\"Dispute parent\\\";\\n\\n    uint256 private constant RULE_PAYEE_WON = 3;\\n    uint256 private constant RULE_PAYER_WON = 4;\\n\\n    string private constant PAYER_EVIDENCE_LABEL = \\\"Evidence (Payer)\\\";\\n    string private constant PAYEE_EVIDENCE_LABEL = \\\"Evidence (Payee)\\\";\\n\\n    bytes32 private constant EMPTY_BYTES32 = bytes32(0);\\n\\n    /**\\n     * @dev Can only be a contract party, either payer (or his delegate) or payee.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     */\\n    modifier isDisputer(bytes32 _cid) {\\n        _isParty(_cid);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Version of Escrow which uses Aragon Court dispute interfaces.\\n     *\\n     * @param _registry Address of universal registry of all contracts.\\n     */\\n    constructor(address _registry) EscrowContract(_registry) ReentrancyGuard() {\\n    }\\n\\n    /**\\n     * @dev Can only be a contract party, either payer or payee (or their delegates).\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     */\\n    function _isParty(bytes32 _cid) internal view {\\n        require(_isPayerParty(_cid) || _isPayeeParty(_cid), ERROR_NOT_DISPUTER);\\n    }\\n\\n    /**\\n     * @dev Either payer or his delegate.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     */\\n    function _isPayerParty(bytes32 _cid) internal view returns (bool) {\\n        return msg.sender == contracts[_cid].payerDelegate || msg.sender == contracts[_cid].payer;\\n    }\\n\\n    /**\\n     * @dev Either payee or his delegate.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     */\\n    function _isPayeeParty(bytes32 _cid) internal view returns (bool) {\\n        return msg.sender == contracts[_cid].payeeDelegate || msg.sender == contracts[_cid].payee;\\n    }\\n\\n    /**\\n     * @dev Prepare contract between parties, with initial milestones.\\n     * Initial milestone term cid, will be the same as contract cid.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _payer Party which pays for the contract or on behalf of which the funding was done.\\n     * @param _payerDelegate Delegate who can release or dispute contract on behalf of payer.\\n     * @param _payee Party which recieves the payment.\\n     * @param _payeeDelegate Delegate who can refund or dispute contract on behalf of payee.\\n     * @param _milestones Delivery amounts and payment tokens.\\n     */\\n    function registerContract(\\n        bytes32 _cid,\\n        address _payer,\\n        address _payerDelegate,\\n        address _payee,\\n        address _payeeDelegate,\\n        EscrowUtilsLib.MilestoneParams[] calldata _milestones\\n    ) external {\\n        require(_payer != _payee && _payerDelegate != _payeeDelegate, ERROR_INVALID_PARTIES);\\n        _registerContract(_cid, _payer, _payerDelegate, _payee, _payeeDelegate);\\n\\n        bytes32 _mid;\\n        EscrowUtilsLib.MilestoneParams calldata _mp;\\n        uint16 _index;\\n        uint16 _oldIndex;\\n        uint16 _subIndex = 1;\\n        for (uint16 _i=0; _i<_milestones.length; _i++) {\\n            _mp = _milestones[_i];\\n            if (_mp.parentIndex > 0) {\\n                _oldIndex = _index;\\n                _index = _mp.parentIndex * MILESTONE_INDEX_BASE + _subIndex;\\n                _subIndex += 1;\\n            } else {\\n                _index += 1;\\n            }\\n\\n            _mid = EscrowUtilsLib.genMid(_cid, _index);\\n            _registerMilestoneStorage(\\n                _mid,\\n                _mp.paymentToken,\\n                _mp.treasury,\\n                _mp.payeeAccount,\\n                _mp.refundAccount,\\n                _mp.escrowDisputeManager,\\n                _mp.autoReleasedAt,\\n                _mp.amount\\n            );\\n            emit NewMilestone(_cid, _index, _mid, _mp.paymentToken, _mp.escrowDisputeManager, _mp.autoReleasedAt, _mp.amount);\\n            if (_mp.parentIndex > 0) {\\n                emit ChildMilestone(_cid, _index, _mp.parentIndex, _mid);\\n                _index = _oldIndex;\\n            }\\n        }\\n        lastMilestoneIndex[_cid] = _index;\\n    }\\n\\n    /**\\n     * @dev Add new milestone for the existing contract with amendment to contract terms.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone (100 max, higher than 100 are child milestones, calculated by the following formula: parent index * 100 + index of child).\\n     * @param _paymentToken Payment token for amount.\\n     * @param _treasury Address where the escrow funds will be stored (farming?).\\n     * @param _payeeAccount Address where payment should be recieved, should be the same as payee or vesting contract address.\\n     * @param _refundAccount Address where payment should be refunded, should be the same as payer or sponsor.\\n     * @param _escrowDisputeManager Smart contract which implements disputes for the escrow.\\n     * @param _autoReleasedAt UNIX timestamp for delivery deadline, pass 0 if none.\\n     * @param _amount Amount to be paid in payment token for the milestone.\\n     * @param _amendmentCid Should be the same as _cid if no change in contract terms are needed.\\n     */\\n    function registerMilestone(\\n        bytes32 _cid,\\n        uint16 _index,\\n        address _paymentToken,\\n        address _treasury,\\n        address _payeeAccount,\\n        address _refundAccount,\\n        address _escrowDisputeManager,\\n        uint _autoReleasedAt,\\n        uint _amount,\\n        bytes32 _amendmentCid\\n    ) external {\\n        _registerMilestone(\\n            _cid,\\n            _index,\\n            _paymentToken,\\n            _treasury,\\n            _payeeAccount,\\n            _refundAccount,\\n            _escrowDisputeManager,\\n            _autoReleasedAt,\\n            _amount\\n        );\\n\\n        // One amendment can cover terms for several milestones\\n        if (_cid != _amendmentCid && _amendmentCid != EMPTY_BYTES32 && _amendmentCid != getLatestApprovedContractVersion(_cid)) {\\n            _proposeAmendment(_cid, _amendmentCid, contracts[_cid].payer, contracts[_cid].payee);\\n        }\\n\\n        if (_index < MILESTONE_INDEX_BASE) lastMilestoneIndex[_cid] = _index;\\n    }\\n\\n    /**\\n     * @dev Stop auto-release of milestone funds.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone to dispute.\\n     */\\n    function stopMilestoneAutoRelease(bytes32 _cid, uint16 _index) external isDisputer(_cid) {\\n        bytes32 _mid = EscrowUtilsLib.genMid(_cid, _index);\\n        milestones[_mid].autoReleasedAt = 0;\\n    }\\n\\n    /**\\n     * @dev Fund milestone with payment token, partial funding is possible.\\n     * To increase the maximum funding amount, just add a new milestone.\\n     *\\n     * Anyone can fund milestone, payment token should be approved for this contract.\\n     *\\n     * Keep in mind that specific milestone terms can be not the final contract terms.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone.\\n     * @param _amountToFund amount of payment token to fund the milestone.\\n     */\\n    function fundMilestone(bytes32 _cid, uint16 _index, uint _amountToFund) external {\\n        require(getLatestApprovedContractVersion(_cid) != EMPTY_BYTES32, ERROR_NOT_APPROVED);\\n        _fundMilestone(_cid, _index, _amountToFund);\\n    }\\n\\n    /**\\n     * @dev If payee has signed contract off-chain, allow funding with payee signature as a proof\\n     * that he has agreed the terms.\\n     *\\n     * If contract is not approved by both parties, approve the signed terms cid.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone.\\n     * @param _termsCid Contract IPFS cid signed by payee.\\n     * @param _amountToFund Amount to fund.\\n     * @param _payeeSignature Signed digest of terms cid by payee.\\n     * @param _payerSignature Signed digest of terms cid by payer, can be bytes32(0) if caller is payer.\\n     */\\n    function signAndFundMilestone(\\n        bytes32 _cid,\\n        uint16 _index,\\n        bytes32 _termsCid,\\n        uint _amountToFund,\\n        bytes calldata _payeeSignature,\\n        bytes calldata _payerSignature\\n    ) external {\\n        _signAndFundMilestone(_cid, _index, _termsCid, _amountToFund, _payeeSignature, _payerSignature);\\n\\n        if (contractVersions[_cid].cid == EMPTY_BYTES32) {\\n            bytes32 _key = EscrowUtilsLib.genTermsKey(_cid, _termsCid);\\n            _approveAmendment(_cid, _termsCid, _key);\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as signAndProposeContractVersion amendment, but pre-approved with signature of non-sender party.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _amendmentCid New version of contract's IPFS cid.\\n     * @param _payeeSignature Signed digest of amendment cid by payee, can be bytes(0) if payee is msg.sender.\\n     * @param _payerSignature Signed digest of amendment cid by payer, can be bytes(0) if payer is msg.sender.\\n     */\\n    function preApprovedAmendment(\\n        bytes32 _cid,\\n        bytes32 _amendmentCid,\\n        bytes calldata _payeeSignature,\\n        bytes calldata _payerSignature\\n    ) external {\\n        address _payee = contracts[_cid].payee;\\n        require(msg.sender == _payee || isPreApprovedAmendment(_cid, _amendmentCid, _payee, _payeeSignature), ERROR_NOT_DISPUTER);\\n        address _payer = contracts[_cid].payer;\\n        require(msg.sender == _payer || isPreApprovedAmendment(_cid, _amendmentCid, _payer, _payerSignature), ERROR_NOT_DISPUTER);\\n        \\n        bytes32 _key = EscrowUtilsLib.genTermsKey(_cid, _amendmentCid);\\n        _approveAmendment(_cid, _amendmentCid, _key);\\n    }\\n\\n    /**\\n     * @dev Initiate a disputed settlement for a milestone and plead to Aragon Court as arbiter.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone to dispute.\\n     * @param _refundedPercent Amount to refund (in percents).\\n     * @param _releasedPercent Amount to release (in percents).\\n     * @param _statement IPFS cid for statement.\\n     */\\n    function proposeSettlement(\\n        bytes32 _cid,\\n        uint16 _index,\\n        uint256 _refundedPercent,\\n        uint256 _releasedPercent,\\n        bytes32 _statement\\n    ) external {\\n        require(_index < MILESTONE_INDEX_BASE, ERROR_DISPUTE_PARENT);\\n        require(_refundedPercent + _releasedPercent == 100, ERROR_INVALID_SETTLEMENT);\\n\\n        EscrowUtilsLib.Contract memory _c = contracts[_cid];\\n        address _plaintiff;\\n        if (msg.sender == _c.payeeDelegate || msg.sender == _c.payee) {\\n            _plaintiff = _c.payee;\\n        } else if (msg.sender == _c.payerDelegate || msg.sender == _c.payer) {\\n            _plaintiff = _c.payer;\\n        } else {\\n            revert(ERROR_NOT_DISPUTER);\\n        }\\n        \\n        bytes32 _mid = EscrowUtilsLib.genMid(_cid, _index);\\n        milestones[_mid].escrowDisputeManager.proposeSettlement(\\n            _cid,\\n            _index,\\n            _plaintiff,\\n            _c.payer,\\n            _c.payee,\\n            _refundedPercent,\\n            _releasedPercent,\\n            _statement\\n        );\\n    }\\n\\n    /**\\n     * @dev Accept the resolution suggested by an opposite party.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone to dispute.\\n     */\\n    function acceptSettlement(bytes32 _cid, uint16 _index) external {\\n        bytes32 _mid = EscrowUtilsLib.genMid(_cid, _index);\\n        if (_isPayerParty(_cid)) {\\n            milestones[_mid].escrowDisputeManager.acceptSettlement(_cid, _index, RULE_PAYEE_WON);\\n        } else if (_isPayeeParty(_cid)) {\\n            milestones[_mid].escrowDisputeManager.acceptSettlement(_cid, _index, RULE_PAYER_WON);\\n        } else {\\n            revert();\\n        }\\n    }\\n\\n    /**\\n     * @dev When settlement proposals are gathered, send final proposals to arbiter for resolution.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone to dispute.\\n     * @param _ignoreCoverage Don't try to use insurance\\n     */\\n    function disputeSettlement(bytes32 _cid, uint16 _index, bool _ignoreCoverage) external isDisputer(_cid) {\\n        bytes32 _termsCid = getLatestApprovedContractVersion(_cid);\\n        bytes32 _mid = EscrowUtilsLib.genMid(_cid, _index);\\n        milestones[_mid].escrowDisputeManager.disputeSettlement(\\n            msg.sender,\\n            _cid,\\n            _index,\\n            _termsCid,\\n            _ignoreCoverage,\\n            lastMilestoneIndex[_cid] > 1\\n        );\\n    }\\n\\n    /**\\n     * @dev Apply Aragon Court decision to milestone.\\n     *\\n     * Can be called by anyone, as ruling is static.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone in dispute.\\n     */\\n    function executeSettlement(bytes32 _cid, uint16 _index) external nonReentrant {\\n        bytes32 _mid = EscrowUtilsLib.genMid(_cid, _index);\\n        uint256 _ruling;\\n        uint256 _refundedPercent;\\n        uint256 _releasedPercent;\\n        IEscrowDisputeManager _disputer;\\n\\n        if (_index > MILESTONE_INDEX_BASE) {\\n            uint16 _parentIndex = _index / MILESTONE_INDEX_BASE; // Integer division will floor the result\\n            bytes32 _parentMid = EscrowUtilsLib.genMid(_cid, _parentIndex);\\n            _disputer = milestones[_parentMid].escrowDisputeManager;\\n            _ruling = _disputer.resolutions(_parentMid);\\n            require(_ruling != 0, ERROR_DISPUTE_PARENT);\\n            (, uint256 __refundedPercent, uint256 __releasedPercent) = _disputer.getSettlementByRuling(_parentMid, _ruling);\\n            _refundedPercent = __refundedPercent;\\n            _releasedPercent = __releasedPercent;\\n        } else {\\n            _disputer = milestones[_mid].escrowDisputeManager;\\n            (uint256 __ruling, uint256 __refundedPercent, uint256 __releasedPercent) = _disputer.executeSettlement(_cid, _index, _mid);\\n            _ruling = __ruling;\\n            _refundedPercent = __refundedPercent;\\n            _releasedPercent = __releasedPercent;\\n        }\\n\\n        if (_ruling == RULE_PAYER_WON || _ruling == RULE_PAYEE_WON) {\\n            require(_refundedPercent + _releasedPercent == 100, ERROR_INVALID_SETTLEMENT);\\n            Milestone memory _m = milestones[_mid];\\n            uint _available = _m.fundedAmount - _m.claimedAmount - _m.refundedAmount - _m.releasedAmount;\\n            require(_available > 0, ERROR_NO_MONEY);\\n\\n            uint256 _refundedAmount = _available / 100 * _refundedPercent;\\n            uint256 _releasedAmount = _available / 100 * _releasedPercent;\\n\\n            address _arbiter = _disputer.ARBITER();\\n            if (_refundedAmount > 0) _cancelMilestone(_mid, _refundedAmount + _m.refundedAmount, _refundedAmount, _arbiter);\\n            if (_releasedAmount > 0) _releaseMilestone(_mid, _releasedAmount + _m.releasedAmount, _releasedAmount, _arbiter);\\n        }\\n    }\\n\\n    /**\\n     * @dev Submit evidence to help dispute resolution.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone to dispute.\\n     * @param _evidence Additonal evidence which should help to resolve the dispute.\\n     */\\n    function submitEvidence(bytes32 _cid, uint16 _index, bytes calldata _evidence) external {\\n        string memory _label;\\n        if (_isPayerParty(_cid)) {\\n            _label = PAYER_EVIDENCE_LABEL;\\n        } else if (_isPayeeParty(_cid)) {\\n            _label = PAYEE_EVIDENCE_LABEL;\\n        } else {\\n            revert(ERROR_NOT_DISPUTER);\\n        }\\n\\n        bytes32 _mid = EscrowUtilsLib.genMid(_cid, _index);\\n        milestones[_mid].escrowDisputeManager.submitEvidence(msg.sender, _label, _cid, _index, _evidence);\\n    }\\n\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract (taken from OZ).\\n     * @param data ABI encoded function calls for this contract.\\n     * @return results Array with execution results.\\n     */\\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint i = 0; i < data.length; i++) {\\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n}\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/contexts/ContractContext.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport \\\"../libs/EscrowUtilsLib.sol\\\";\\n\\nabstract contract ContractContext {\\n    mapping (bytes32 => EscrowUtilsLib.Contract) public contracts;\\n\\n    event ApprovedContractVersion(\\n        bytes32 indexed cid,\\n        bytes32 indexed approvedCid,\\n        bytes32 indexed key\\n    );\\n}\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/contexts/MilestoneContext.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport \\\"../../node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../interfaces/IEscrowDisputeManager.sol\\\";\\nimport \\\"../libs/EscrowUtilsLib.sol\\\";\\n\\nabstract contract MilestoneContext {\\n    struct Milestone {\\n        IERC20 paymentToken;\\n        address treasury;\\n        address payeeAccount;\\n        address refundAccount;\\n        IEscrowDisputeManager escrowDisputeManager;\\n        uint256 autoReleasedAt;\\n        uint256 amount;\\n        uint256 fundedAmount;\\n        uint256 refundedAmount;\\n        uint256 releasedAmount;\\n        uint256 claimedAmount;\\n        uint8 revision;\\n    }\\n\\n    mapping (bytes32 => Milestone) public milestones;\\n    mapping (bytes32 => uint16) public lastMilestoneIndex;\\n\\n    using EscrowUtilsLib for bytes32;\\n\\n    event NewMilestone(\\n        bytes32 indexed cid,\\n        uint16 indexed index,\\n        bytes32 mid,\\n        address indexed paymentToken,\\n        address escrowDisputeManager,\\n        uint256 autoReleasedAt,\\n        uint256 amount\\n    );\\n\\n    event ChildMilestone(\\n        bytes32 indexed cid,\\n        uint16 indexed index,\\n        uint16 indexed parentIndex,\\n        bytes32 mid\\n    );\\n\\n    event FundedMilestone(\\n        bytes32 indexed mid,\\n        address indexed funder,\\n        uint256 indexed amount\\n    );\\n\\n    event ReleasedMilestone(\\n        bytes32 indexed mid,\\n        address indexed releaser,\\n        uint256 indexed amount\\n    );\\n\\n    event CanceledMilestone(\\n        bytes32 indexed mid,\\n        address indexed releaser,\\n        uint256 indexed amount\\n    );\\n\\n    event WithdrawnMilestone(\\n        bytes32 indexed mid,\\n        address indexed recipient,\\n        uint256 indexed amount\\n    );\\n\\n    event RefundedMilestone(\\n        bytes32 indexed mid,\\n        address indexed recipient,\\n        uint256 indexed amount\\n    );\\n}\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/extensions/Amendable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport \\\"../contexts/ContractContext.sol\\\";\\nimport \\\"../contexts/MilestoneContext.sol\\\";\\nimport \\\"../interfaces/IEscrowDisputeManager.sol\\\";\\n\\nabstract contract Amendable is ContractContext, MilestoneContext {\\n    string private constant ERROR_NOT_PARTY = \\\"Not a payer or payee\\\";\\n    string private constant ERROR_EMPTY = \\\"Empty amendment\\\";\\n    string private constant ERROR_AMENDMENT_EXIST = \\\"Amendment exist\\\";\\n    string private constant ERROR_NOT_VALIDATOR = \\\"Not a validator\\\";\\n    string private constant ERROR_EARLIER_AMENDMENT = \\\"Not final amendment\\\";\\n    string private constant ERROR_OVERFUNDED = \\\"Overfunded milestone\\\";\\n\\n    bytes32 private constant EMPTY_BYTES32 = bytes32(0);\\n    address private constant EMPTY_ADDRESS = address(0);\\n\\n    struct Amendment{\\n        bytes32 cid;\\n        uint256 timestamp;\\n    }\\n\\n    struct AmendmentProposal {\\n        bytes32 termsCid;\\n        address validator;\\n        uint256 timestamp;\\n    }\\n\\n    struct SettlementParams {\\n        bytes32 termsCid;\\n        address payeeAccount;\\n        address refundAccount;\\n        address escrowDisputeManager;\\n        uint autoReleasedAt;\\n        uint amount;\\n        uint refundedAmount;\\n        uint releasedAmount;\\n    }\\n\\n    struct SettlementProposal {\\n        SettlementParams params;\\n        address validator;\\n        uint256 timestamp;\\n    }\\n\\n    mapping (bytes32 => Amendment) public contractVersions;\\n    mapping (bytes32 => bool) public contractVersionApprovals;\\n    mapping (bytes32 => AmendmentProposal) public contractVersionProposals;\\n    mapping (bytes32 => SettlementProposal) public settlementProposals;\\n\\n    event NewContractVersion(\\n        bytes32 indexed cid,\\n        bytes32 indexed amendmentCid,\\n        address indexed validator,\\n        bytes32 key\\n    );\\n\\n    event NewSettlement(\\n        bytes32 indexed cid,\\n        uint16 indexed index,\\n        uint8 revision,\\n        address indexed validator,\\n        bytes32 key,\\n        SettlementParams data\\n    );\\n\\n    event ApprovedSettlement(\\n        bytes32 indexed cid,\\n        uint16 indexed index,\\n        uint8 revision,\\n        bytes32 indexed key,\\n        address validator\\n    );\\n\\n    /**\\n     * @dev Return IPFS cid of a latest approved contract version.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @return IPFS cid in hex form for a final approved version of a contract or\\n     * bytes32(0) if no version was approved by both parties.\\n     */\\n    function getLatestApprovedContractVersion(bytes32 _cid) public view returns (bytes32) {\\n        return contractVersions[_cid].cid;\\n    }\\n\\n    /**\\n     * @dev Check if specific contract version was approved by both parties.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _termsCid cid of suggested contract version.\\n     * @return approval by both parties.\\n     */\\n    function isApprovedContractVersion(bytes32 _cid, bytes32 _termsCid) public view returns (bool) {\\n        bytes32 _key = EscrowUtilsLib.genTermsKey(_cid, _termsCid);\\n        return contractVersionApprovals[_key];\\n    }\\n\\n    /**\\n     * @dev Propose change for the current contract terms.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _termsCid New version of contract's IPFS cid.\\n     */\\n    function signAndProposeContractVersion(bytes32 _cid, bytes32 _termsCid) external {\\n        address _payer = contracts[_cid].payer;\\n        address _payee = contracts[_cid].payee;\\n        require(msg.sender == _payee || msg.sender == _payer, ERROR_NOT_PARTY);\\n        _proposeAmendment(_cid, _termsCid, _payee, _payer);\\n    }\\n\\n    /**\\n     * @dev Validate contract version by the opposite party.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _termsCid Amendment IPFS cid for approval.\\n     */\\n    function signAndApproveContractVersion(bytes32 _cid, bytes32 _termsCid) public {\\n        bytes32 _key = EscrowUtilsLib.genTermsKey(_cid, _termsCid);\\n        require(_termsCid != EMPTY_BYTES32, ERROR_EMPTY);\\n        require(!contractVersionApprovals[_key], ERROR_AMENDMENT_EXIST);\\n        require(contractVersionProposals[_key].validator == msg.sender, ERROR_NOT_VALIDATOR);\\n        require(contractVersionProposals[_key].timestamp > contractVersions[_cid].timestamp, ERROR_EARLIER_AMENDMENT);\\n\\n        _approveAmendment(_cid, contractVersionProposals[_key].termsCid, _key);\\n        \\n        // Gas refund\\n        delete contractVersionProposals[_key];\\n    }\\n\\n    /**\\n     * @dev Propose change to milestone on-chain data.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Milestone to amend.\\n     * @param _termsCid New version of contract's IPFS cid, pass bytes32(0) to leave old terms.\\n     * @param _payeeAccount Change address for withdrawals, pass address(0) to leave the old one.\\n     * @param _refundAccount Change address for refunds, pass address(0) to leave the old one.\\n     * @param _escrowDisputeManager Smart contract which implements disputes for the escrow, pass address(0) to leave the old one.\\n     * @param _autoReleasedAt UNIX timestamp for delivery deadline, pass 0 if none.\\n     * @param _amount Change total size of milestone, may require refund or release.\\n     * @param _refundedAmount Amount to refund, should't be more than current fundedAmount - claimedAmount - releasedAmount.\\n     * @param _releasedAmount Amount to release, should't be more than current fundedAmount - claimedAmount - refundedAmount.\\n     */\\n    function signAndProposeMilestoneSettlement(\\n        bytes32 _cid,\\n        uint16 _index,\\n        bytes32 _termsCid,\\n        address _payeeAccount,\\n        address _refundAccount,\\n        address _escrowDisputeManager,\\n        uint _autoReleasedAt,\\n        uint _amount,\\n        uint _refundedAmount,\\n        uint _releasedAmount\\n    ) external returns (bytes32) {\\n        address _payer = contracts[_cid].payer;\\n        address _payee = contracts[_cid].payee;\\n        require(msg.sender == _payee || msg.sender == _payer, ERROR_NOT_PARTY);\\n\\n        SettlementParams memory _sp = SettlementParams({\\n            termsCid: _termsCid,\\n            payeeAccount: _payeeAccount,\\n            refundAccount: _refundAccount,\\n            escrowDisputeManager: _escrowDisputeManager,\\n            autoReleasedAt: _autoReleasedAt,\\n            amount: _amount,\\n            refundedAmount: _refundedAmount,\\n            releasedAmount: _releasedAmount\\n        });\\n        \\n        return _proposeMilestoneSettlement(\\n            _cid,\\n            _index,\\n            _sp,\\n            _payer,\\n            _payee\\n        );\\n    }\\n\\n    /**\\n     * @dev Save new approved contract version.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Milestone index.\\n     * @param _revision Current version of milestone extended terms.\\n     */\\n    function signApproveAndExecuteMilestoneSettlement(bytes32 _cid, uint16 _index, uint8 _revision) public {\\n        bytes32 _key = EscrowUtilsLib.genSettlementKey(_cid, _index, _revision);\\n        require(settlementProposals[_key].validator == msg.sender, ERROR_NOT_VALIDATOR);\\n        _approveAndExecuteMilestoneSettlement(_cid, _index, _revision);\\n        \\n        // Gas refund\\n        delete settlementProposals[_key];\\n    }\\n\\n    /**\\n     * @dev Proposals are saved in a temporary dictionary until they are approved to contractVersions mapping.\\n     *\\n     * It's possible to override existing proposal with a same key, for instance to increase timestamp.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _termsCid New version of contract's IPFS cid, pass bytes32(0) to leave old terms.\\n     * @param _party1 Address of first party (e.g. payer).\\n     * @param _party2 Address of second party (e.g. payee).\\n     * @return key for amendment.\\n     */\\n    function _proposeAmendment(\\n        bytes32 _cid,\\n        bytes32 _termsCid,\\n        address _party1,\\n        address _party2\\n    ) internal returns (bytes32) {\\n        bytes32 _key = EscrowUtilsLib.genTermsKey(_cid, _termsCid);\\n        require(_termsCid != EMPTY_BYTES32, ERROR_EMPTY);\\n\\n        address _validator = _party1;\\n        if (msg.sender == _party1) _validator = _party2;\\n        contractVersionProposals[_key] = AmendmentProposal({\\n            termsCid: _termsCid,\\n            validator: _validator,\\n            timestamp: block.timestamp\\n        });\\n        emit NewContractVersion(_cid, _termsCid, _validator, _key);\\n        return _key;\\n    }\\n\\n    /**\\n     * @dev Save new approved contract version.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _termsCid New version of contract's IPFS cid.\\n     */\\n    function _approveAmendment(bytes32 _cid, bytes32 _termsCid, bytes32 _key) internal {\\n        contractVersionApprovals[_key] = true;\\n        contractVersions[_cid] = Amendment({ cid: _termsCid, timestamp: block.timestamp });\\n        emit ApprovedContractVersion(_cid, _termsCid, _key);\\n    }\\n\\n    /**\\n     * @dev Proposals are saved in a temporary dictionary until they are approved to contractVersions mapping.\\n     *\\n     * It's possible to override unapproved settlement proposal with a new one.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Milestone to amend.\\n     * @param _settlementParams Settlement data, see signAndProposeMilestoneSettlement.\\n     * @param _party1 Address of first party (e.g. payer).\\n     * @param _party2 Address of second party (e.g. payee).\\n     * @return key for settlement.\\n     */\\n    function _proposeMilestoneSettlement(\\n        bytes32 _cid,\\n        uint16 _index,\\n        SettlementParams memory _settlementParams,\\n        address _party1,\\n        address _party2\\n    ) internal returns (bytes32) {\\n        uint8 _revision = milestones[EscrowUtilsLib.genMid(_cid, _index)].revision + 1;\\n        bytes32 _key = EscrowUtilsLib.genSettlementKey(_cid, _index, _revision);\\n\\n        address _validator = _party1;\\n        if (msg.sender == _party1) _validator = _party2;\\n        settlementProposals[_key] = SettlementProposal({\\n            params: _settlementParams,\\n            validator: _validator,\\n            timestamp: block.timestamp\\n        });\\n        emit NewSettlement(\\n            _cid,\\n            _index,\\n            _revision,\\n            _validator,\\n            _key,\\n            _settlementParams\\n        );\\n        return _key;\\n    }\\n\\n    /**\\n     * @dev Save new approved contract version.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Milestone index.\\n     * @param _revision Current version of milestone extended terms.\\n     */\\n    function _approveAndExecuteMilestoneSettlement(bytes32 _cid, uint16 _index, uint8 _revision) internal {\\n        bytes32 _key = EscrowUtilsLib.genSettlementKey(_cid, _index, _revision);\\n        SettlementProposal memory _sp = settlementProposals[_key];\\n        bytes32 _mid = EscrowUtilsLib.genMid(_cid, _index);\\n        Milestone memory _m = milestones[_mid];\\n        require(_revision > _m.revision, ERROR_EARLIER_AMENDMENT);\\n\\n        uint _leftAmount = _m.fundedAmount - _m.claimedAmount;\\n        if (_sp.params.amount < _leftAmount) {\\n            uint _overfundedAmount = _leftAmount - _sp.params.amount;\\n            require(_sp.params.refundedAmount + _sp.params.releasedAmount >= _overfundedAmount, ERROR_OVERFUNDED);\\n        }\\n\\n        // Maybe approve new milestone terms\\n        if (_sp.params.termsCid != EMPTY_BYTES32) {\\n            require(_sp.timestamp > contractVersions[_cid].timestamp, ERROR_EARLIER_AMENDMENT);\\n            bytes32 _termsKey = EscrowUtilsLib.genTermsKey(_cid, _sp.params.termsCid);\\n            // Can be double approval, but will override the current contract version\\n            _approveAmendment(_cid, _sp.params.termsCid, _termsKey);\\n        }\\n\\n        milestones[_mid].revision += 1;\\n        milestones[_mid].amount = _sp.params.amount;\\n\\n        if (_sp.params.refundedAmount != _m.refundedAmount) {\\n            milestones[_mid].refundedAmount = _sp.params.refundedAmount;\\n        }\\n        if (_sp.params.releasedAmount != _m.releasedAmount) {\\n            milestones[_mid].releasedAmount = _sp.params.releasedAmount;\\n        }\\n\\n        if (_sp.params.payeeAccount != EMPTY_ADDRESS) milestones[_mid].payeeAccount = _sp.params.payeeAccount;\\n        if (_sp.params.refundAccount != EMPTY_ADDRESS) milestones[_mid].refundAccount = _sp.params.refundAccount;\\n        if (_sp.params.escrowDisputeManager != EMPTY_ADDRESS) milestones[_mid].escrowDisputeManager = IEscrowDisputeManager(_sp.params.escrowDisputeManager);\\n        if (_sp.params.autoReleasedAt != _m.autoReleasedAt) milestones[_mid].autoReleasedAt = _sp.params.autoReleasedAt;\\n\\n        emit ApprovedSettlement(_cid, _index, _revision, _key, msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/extensions/AmendablePreSigned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport \\\"./Amendable.sol\\\";\\nimport \\\"../libs/EIP712.sol\\\";\\n\\nabstract contract AmendablePreSigned is Amendable {\\n    using EIP712 for address;\\n\\n    /// @dev Value returned by a call to `_isPreApprovedAmendment` if the check\\n    /// was successful. The value is defined as:\\n    /// bytes4(keccak256(\\\"_isPreApprovedAmendment(address,bytes)\\\"))\\n    bytes4 private constant MAGICVALUE = 0xe3f756de;\\n\\n    /// @dev The EIP-712 domain type hash used for computing the domain\\n    /// separator.\\n    bytes32 internal constant AMENDMENT_DOMAIN_TYPE_HASH =\\n        keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n\\n    /// @dev The EIP-712 domain name used for computing the domain separator.\\n    bytes32 internal constant AMENDMENT_DOMAIN_NAME = keccak256(\\\"ApprovedAmendment\\\");\\n\\n    /// @dev The EIP-712 domain version used for computing the domain separator.\\n    bytes32 internal constant AMENDMENT_DOMAIN_VERSION = keccak256(\\\"v1\\\");\\n\\n    /// @dev The domain separator used for signing orders that gets mixed in\\n    /// making signatures for different domains incompatible. This domain\\n    /// separator is computed following the EIP-712 standard and has replay\\n    /// protection mixed in so that signed orders are only valid for specific\\n    /// contracts.\\n    bytes32 public immutable AMENDMENT_DOMAIN_SEPARATOR;\\n\\n    constructor() {\\n        // NOTE: Currently, the only way to get the chain ID in solidity is\\n        // using assembly.\\n        uint256 chainId;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        AMENDMENT_DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                AMENDMENT_DOMAIN_TYPE_HASH,\\n                AMENDMENT_DOMAIN_NAME,\\n                AMENDMENT_DOMAIN_VERSION,\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Get domain separator in scope of EIP-712.\\n     *\\n     * @return EIP-712 domain.\\n     */\\n    function getAmendmentDomainSeparator() public virtual view returns(bytes32) {\\n        return AMENDMENT_DOMAIN_SEPARATOR;\\n    }\\n\\n    /**\\n     * @dev Check if amendment was pre-approved.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _amendmentCid New version of contract's IPFS cid.\\n     * @param _validator Address of opposite party which approval is needed.\\n     * @param _signature Digest of amendment cid.\\n     * @return true or false.\\n     */\\n    function isPreApprovedAmendment(\\n        bytes32 _cid,\\n        bytes32 _amendmentCid,\\n        address _validator,\\n        bytes calldata _signature\\n    ) internal view returns (bool) {\\n        bytes32 _currentCid = getLatestApprovedContractVersion(_cid);\\n        return _isPreApprovedAmendment(\\n            _cid,\\n            _currentCid,\\n            _amendmentCid,\\n            _validator,\\n            getAmendmentDomainSeparator(),\\n            _signature\\n        ) == MAGICVALUE;\\n    }\\n\\n    /**\\n     * @dev Check if amendment was pre-approved, EIP-712\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _currentCid Cid of last proposed contract version.\\n     * @param _amendmentCid New version of contract's IPFS cid.\\n     * @param _validator Address of opposite party which approval is needed.\\n     * @param _domain EIP-712 domain.\\n     * @param _callData Digest of amendment cid.\\n     * @return 0xe3f756de for success 0x00000000 for failure.\\n     */\\n    function _isPreApprovedAmendment(\\n        bytes32 _cid,\\n        bytes32 _currentCid,\\n        bytes32 _amendmentCid,\\n        address _validator,\\n        bytes32 _domain,\\n        bytes calldata _callData\\n    ) internal pure returns (bytes4) {\\n        return EIP712._isValidEIP712Signature(\\n            _validator,\\n            MAGICVALUE,\\n            abi.encode(_domain, _cid, _currentCid, _amendmentCid),\\n            _callData\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/extensions/EscrowContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport \\\"../interfaces/IRegistry.sol\\\";\\nimport \\\"../contexts/ContractContext.sol\\\";\\n\\nabstract contract EscrowContract is ContractContext {\\n    string private constant ERROR_CONTRACT_EXITS = \\\"Contract exists\\\";\\n    string private constant ERROR_EMPTY_DELEGATE = \\\"Invalid delegate\\\";\\n\\n    address private constant EMPTY_ADDRESS = address(0);\\n\\n    IRegistry public immutable TRUSTED_REGISTRY;\\n\\n    event NewContractPayer(\\n        bytes32 indexed cid,\\n        address indexed payer,\\n        address indexed delegate\\n    );\\n\\n    event NewContractPayee(\\n        bytes32 indexed cid,\\n        address indexed payee,\\n        address indexed delegate\\n    );\\n\\n    /**\\n     * @dev Single registry is used to store contract data from different versions of escrow contracts.\\n     *\\n     * @param _registry Address of universal registry of all contracts.\\n     */\\n    constructor(address _registry) {\\n        TRUSTED_REGISTRY = IRegistry(_registry);\\n    }\\n\\n    /**\\n     * @dev Prepare contract between parties.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _payer Party which pays for the contract or on behalf of which the funding was done.\\n     * @param _payerDelegate Delegate who can release or dispute contract on behalf of payer.\\n     * @param _payee Party which recieves the payment.\\n     * @param _payeeDelegate Delegate who can refund or dispute contract on behalf of payee.\\n     */\\n    function _registerContract(\\n        bytes32 _cid,\\n        address _payer,\\n        address _payerDelegate,\\n        address _payee,\\n        address _payeeDelegate\\n    ) internal {\\n        require(contracts[_cid].payer == EMPTY_ADDRESS, ERROR_CONTRACT_EXITS);\\n\\n        if (_payerDelegate == EMPTY_ADDRESS) _payerDelegate = _payer;\\n        if (_payerDelegate == EMPTY_ADDRESS) _payeeDelegate = _payee;\\n        contracts[_cid] = EscrowUtilsLib.Contract({\\n            payer: _payer,\\n            payerDelegate: _payerDelegate,\\n            payee: _payee,\\n            payeeDelegate: _payeeDelegate\\n        });\\n        emit NewContractPayer(_cid, _payer, _payerDelegate);\\n        emit NewContractPayee(_cid, _payee, _payeeDelegate);\\n\\n        TRUSTED_REGISTRY.registerNewContract(_cid, _payer, _payee);\\n    }\\n\\n    /**\\n     * @dev Change delegate for one party of a deal.\\n     * Caller should be either payer or payee.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _newDelegate Address for a new delegate.\\n     */\\n    function changeDelegate(bytes32 _cid, address _newDelegate) external {\\n        require(_newDelegate != EMPTY_ADDRESS, ERROR_EMPTY_DELEGATE);\\n        if (contracts[_cid].payer == msg.sender) {\\n            contracts[_cid].payerDelegate = _newDelegate;\\n        } else if (contracts[_cid].payee == msg.sender) {\\n            contracts[_cid].payeeDelegate = _newDelegate;\\n        } else {\\n            revert();\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/extensions/WithMilestones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport \\\"../../node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../../node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../../node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"../contexts/ContractContext.sol\\\";\\nimport \\\"../contexts/MilestoneContext.sol\\\";\\nimport \\\"../interfaces/ITreasury.sol\\\";\\nimport \\\"../interfaces/IEscrowDisputeManager.sol\\\";\\n\\nabstract contract WithMilestones is ContractContext, MilestoneContext, ReentrancyGuard {\\n    using SafeERC20 for IERC20;\\n\\n    string private constant ERROR_MILESTONE_EXITS = \\\"Milestone exists\\\";\\n    string private constant ERROR_FUNDING = \\\"Funding failed\\\";\\n    string private constant ERROR_FUNDED = \\\"Funding not needed\\\";\\n    string private constant ERROR_RELEASED = \\\"Invalid release amount\\\";\\n    string private constant ERROR_NOT_DISPUTER = \\\"Not a party\\\";\\n    string private constant ERROR_NOT_VALIDATOR = \\\"Not a validator\\\";\\n    string private constant ERROR_NO_MONEY = \\\"Nothing to withdraw\\\";\\n\\n    uint16 internal constant MILESTONE_INDEX_BASE = 100;\\n\\n    uint256 private constant EMPTY_INT = 0;\\n\\n    /**\\n     * @dev As payer or delegater allow payee to claim released amount of payment token.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone.\\n     * @param _amountToRelease amount of payment token to release from the milestone.\\n     */\\n    function releaseMilestone(bytes32 _cid, uint16 _index, uint _amountToRelease) public {\\n        require(msg.sender == contracts[_cid].payerDelegate || msg.sender == contracts[_cid].payer, ERROR_NOT_VALIDATOR);\\n\\n        bytes32 _mid = EscrowUtilsLib.genMid(_cid, _index);\\n        Milestone memory _m = milestones[_mid];\\n        uint _releasedAmount = _m.releasedAmount + _amountToRelease;\\n        // Can pontentially pre-release the full amount before funding, so we check full amount instead of fundedAmount\\n        require(_amountToRelease > 0 && _m.amount >= _releasedAmount, ERROR_RELEASED);\\n\\n        _releaseMilestone(_mid, _releasedAmount, _amountToRelease, msg.sender);\\n    }\\n\\n    /**\\n     * @dev As payee allow payer or delegate to claim refunded amount from funded payment token.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone.\\n     * @param _amountToRefund amount of payment token to refund from funded milestone.\\n     */\\n    function cancelMilestone(bytes32 _cid, uint16 _index, uint _amountToRefund) public {\\n        require(msg.sender == contracts[_cid].payeeDelegate || msg.sender == contracts[_cid].payee, ERROR_NOT_VALIDATOR);\\n\\n        bytes32 _mid = EscrowUtilsLib.genMid(_cid, _index);\\n        require(_amountToRefund > 0 && milestones[_mid].fundedAmount >= milestones[_mid].claimedAmount + _amountToRefund, ERROR_RELEASED);\\n\\n        uint _refundedAmount = milestones[_mid].refundedAmount + _amountToRefund;\\n        _cancelMilestone(_mid, _refundedAmount, _amountToRefund, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Withdraw payment token amount released by payer or arbiter.\\n     *\\n     * Can be called by anyone, as recipient is static,\\n     * can be potenatially used to sponsor gas fees by payer.\\n     *\\n     * If milestone supports automatic releases by autoReleasedAt,\\n     * it will allow to withdraw funded amount without explicit release\\n     * from another party.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone.\\n     */\\n    function withdrawMilestone(bytes32 _cid, uint16 _index) public nonReentrant {\\n        bytes32 _mid = EscrowUtilsLib.genMid(_cid, _index);\\n        Milestone memory _m = milestones[_mid];\\n        milestones[_mid].releasedAmount = 0;\\n\\n        uint _withdrawn;\\n        uint _toWithdraw;\\n        uint _inEscrow = _m.fundedAmount - _m.claimedAmount;\\n        if (_m.releasedAmount == 0 && _inEscrow > 0 && isAutoReleaseAvailable(_mid, _m.escrowDisputeManager, _m.autoReleasedAt)) {\\n            _toWithdraw = _inEscrow;\\n            _releaseMilestone(_mid, _toWithdraw, _toWithdraw, msg.sender);\\n        } else {\\n            _toWithdraw = _m.releasedAmount;\\n        }\\n        _withdrawn = _withdrawMilestone(_cid, _mid, _m, _m.payeeAccount, _toWithdraw);\\n        emit WithdrawnMilestone(_mid, _m.payeeAccount, _withdrawn); \\n    }\\n\\n    /**\\n     * @dev Refund payment token amount released by payee or arbiter.\\n     *\\n     * Can be called by anyone, as recipient is static,\\n     * can be potenatially used to sponsor gas fees by payee.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone.\\n     */\\n    function refundMilestone(bytes32 _cid, uint16 _index) public nonReentrant {\\n        bytes32 _mid = EscrowUtilsLib.genMid(_cid, _index);\\n        Milestone memory _m = milestones[_mid];\\n        milestones[_mid].refundedAmount = 0;\\n        uint _withdrawn = _withdrawMilestone(_cid, _mid, _m, _m.refundAccount, _m.refundedAmount);\\n        emit RefundedMilestone(_mid, _m.refundAccount, _withdrawn); \\n    }\\n\\n    /**\\n     * @dev Add new milestone for the existing contract.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone (255 max).\\n     * @param _paymentToken Payment token for amount.\\n     * @param _treasury Address where the escrow funds will be stored (farming?).\\n     * @param _payeeAccount Address where payment should be recieved, should be the same as payee or vesting contract address.\\n     * @param _refundAccount Address where payment should be refunded, should be the same as payer or sponsor.\\n     * @param _escrowDisputeManager Smart contract which implements disputes for the escrow.\\n     * @param _autoReleasedAt UNIX timestamp for delivery deadline, pass 0 if none.\\n     * @param _amount Amount to be paid in payment token for the milestone.\\n     */\\n    function _registerMilestone(\\n        bytes32 _cid,\\n        uint16 _index,\\n        address _paymentToken,\\n        address _treasury,\\n        address _payeeAccount,\\n        address _refundAccount,\\n        address _escrowDisputeManager,\\n        uint256 _autoReleasedAt,\\n        uint256 _amount\\n    ) internal {\\n        bool _isPayer = msg.sender == contracts[_cid].payer;\\n        require(msg.sender == contracts[_cid].payee || _isPayer, ERROR_NOT_DISPUTER);\\n\\n        bytes32 _mid = EscrowUtilsLib.genMid(_cid, _index);\\n        require(milestones[_mid].amount == 0, ERROR_MILESTONE_EXITS);\\n        _registerMilestoneStorage(\\n            _mid,\\n            _paymentToken,\\n            _treasury,\\n            _payeeAccount,\\n            _refundAccount,\\n            _escrowDisputeManager,\\n            _autoReleasedAt,\\n            _amount\\n        );\\n        emit NewMilestone(_cid, _index, _mid, _paymentToken, _escrowDisputeManager, _autoReleasedAt, _amount);\\n        if (_index > MILESTONE_INDEX_BASE) {\\n            emit ChildMilestone(_cid, _index, _index / MILESTONE_INDEX_BASE, _mid);\\n        }\\n    }\\n\\n    /**\\n     * @dev Add new milestone for the existing contract.\\n     *\\n     * @param _mid UID of contract's milestone.\\n     * @param _paymentToken Address of ERC20 token to be used as payment currency in this escrow.\\n     * @param _treasury Address where milestone funds are kept in escrow.\\n     * @param _payeeAccount Address where payment should be recieved, should be the same as payer or vesting contract address.\\n     * @param _refundAccount Address where payment should be refunded, should be the same as payer or sponsor.\\n     * @param _escrowDisputeManager Smart contract which implements disputes for the escrow.\\n     * @param _autoReleasedAt UNIX timestamp for delivery deadline, pass 0 if none.\\n     * @param _amount Amount to be paid in payment token for the milestone.\\n     */\\n    function _registerMilestoneStorage(\\n        bytes32 _mid,\\n        address _paymentToken,\\n        address _treasury,\\n        address _payeeAccount,\\n        address _refundAccount,\\n        address _escrowDisputeManager,\\n        uint256 _autoReleasedAt,\\n        uint256 _amount\\n    ) internal {\\n        milestones[_mid] = Milestone({\\n            paymentToken: IERC20(_paymentToken),\\n            treasury: _treasury,\\n            payeeAccount: _payeeAccount,\\n            escrowDisputeManager: IEscrowDisputeManager(_escrowDisputeManager),\\n            refundAccount: _refundAccount,\\n            autoReleasedAt: _autoReleasedAt,\\n            amount: _amount,\\n            fundedAmount: 0,\\n            releasedAmount: 0,\\n            refundedAmount: 0,\\n            claimedAmount: 0,\\n            revision: 0\\n        });\\n    }\\n\\n    /**\\n     * @dev Fund milestone with payment token, partial funding is possible.\\n     * To increase the maximum funding amount, just add a new milestone.\\n     *\\n     * Anyone can fund milestone, payment token should be approved for this contract.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Milestone index.\\n     * @param _amountToFund amount of payment token to fund the milestone.\\n     * @return false if it wasn't possible to transfer tokens.\\n     */\\n    function _fundMilestone(bytes32 _cid, uint16 _index, uint _amountToFund) internal returns(bool) {\\n        bytes32 _mid = EscrowUtilsLib.genMid(_cid, _index);\\n        Milestone memory _m = milestones[_mid];\\n        uint _fundedAmount = _m.fundedAmount;\\n        require(_amountToFund > 0 && _m.amount >= (_fundedAmount + _amountToFund), ERROR_FUNDED);\\n        _m.paymentToken.safeTransferFrom(msg.sender, address(this), _amountToFund);\\n\\n        if (_m.treasury != address(this)) {\\n            _m.paymentToken.safeApprove(_m.treasury, _amountToFund);\\n            require(ITreasury(_m.treasury).registerClaim(\\n                _cid,\\n                _m.refundAccount,\\n                _m.payeeAccount,\\n                address(_m.paymentToken),\\n                _amountToFund\\n            ), ERROR_FUNDING);\\n        }\\n        milestones[_mid].fundedAmount += _amountToFund;\\n        emit FundedMilestone(_mid, msg.sender, _amountToFund);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Release payment for withdrawal by payee.\\n     *\\n     * @param _mid UID of contract's milestone.\\n     * @param _totalReleased Total amount of released payment token.\\n     * @param _amountToRelease Amount of payment token to release.\\n     * @param _releaser Address which released (payer or arbiter).\\n     */\\n    function _releaseMilestone(bytes32 _mid, uint _totalReleased, uint _amountToRelease, address _releaser) internal {\\n        milestones[_mid].releasedAmount = _totalReleased;\\n        emit ReleasedMilestone(_mid, _releaser, _amountToRelease);\\n    }\\n\\n    /**\\n     * @dev Release payment for refund by payer.\\n     *\\n     * @param _mid UID of contract's milestone.\\n     * @param _totalRefunded Total amount of refunded payment token.\\n     * @param _amountToRefund Amount of payment token to refund.\\n     * @param _refunder Address which refunded (payee or arbiter).\\n     */\\n    function _cancelMilestone(bytes32 _mid, uint _totalRefunded, uint _amountToRefund, address _refunder) internal {\\n        milestones[_mid].refundedAmount = _totalRefunded;\\n        emit CanceledMilestone(_mid, _refunder, _amountToRefund);\\n    }\\n\\n    /**\\n     * @dev Transfer released funds to payee or refund account.\\n     *\\n     * Make sure to reduce milestone releasedAmount or refundAmount\\n     * by _withdrawAmount before calling this low-level method.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _mid UID of contract's milestone.\\n     * @param _m Milestone data.\\n     * @param _account Address where payment is withdrawn.\\n     * @param _withdrawAmount Amount of released or refunded payment token.\\n     * @return withdrawn amount\\n     */\\n    function _withdrawMilestone(bytes32 _cid, bytes32 _mid, Milestone memory _m, address _account, uint _withdrawAmount) internal returns(uint) {\\n        uint _leftAmount = _m.fundedAmount - _m.claimedAmount;\\n        if (_leftAmount < _withdrawAmount) _withdrawAmount = _leftAmount;\\n        require(_withdrawAmount > 0, ERROR_NO_MONEY);\\n\\n        milestones[_mid].claimedAmount = _m.claimedAmount + _withdrawAmount;\\n        if (_m.treasury == address(this)) {\\n            _m.paymentToken.safeTransfer(_account, _withdrawAmount);\\n        } else {\\n            require(ITreasury(_m.treasury).requestWithdraw(\\n                _cid,\\n                _account,\\n                address(_m.paymentToken),\\n                _withdrawAmount\\n            ), ERROR_FUNDING);\\n        }\\n        return _withdrawAmount;\\n    }\\n\\n    /**\\n     * @dev Check if auto release of milestone funds is available\\n     * and maturity date has been reached.\\n     *\\n     * Also checks if there were no active or past disputes for this milestone.\\n     *\\n     * @param _mid UID of contract's milestone.\\n     * @param _escrowDisputeManager Smart contract which manages the disputes.\\n     * @param _autoReleasedAt UNIX timestamp for maturity date.\\n     * @return true if funds can be withdrawn.\\n     */\\n    function isAutoReleaseAvailable(\\n        bytes32 _mid,\\n        IEscrowDisputeManager _escrowDisputeManager,\\n        uint _autoReleasedAt\\n    ) public view returns (bool) {\\n        return _autoReleasedAt > 0 && block.timestamp > _autoReleasedAt\\n            && !_escrowDisputeManager.hasSettlementDispute(_mid)\\n            && _escrowDisputeManager.resolutions(_mid) == EMPTY_INT;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/extensions/WithPreSignedMilestones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nimport \\\"./WithMilestones.sol\\\";\\nimport \\\"../libs/EIP712.sol\\\";\\n\\nabstract contract WithPreSignedMilestones is WithMilestones {\\n    using EIP712 for address;\\n\\n    string private constant ERROR_INVALID_SIGNATURE = \\\"Invalid signature\\\";\\n    string private constant ERROR_RELEASED = \\\"Invalid release amount\\\";\\n\\n    /// @dev Value returned by a call to `_isPreApprovedMilestoneRelease` if the check\\n    /// was successful. The value is defined as:\\n    /// bytes4(keccak256(\\\"_isPreApprovedMilestoneRelease(bytes32,uint16,uint256,address,bytes32,bytes)\\\"))\\n    bytes4 private constant MAGICVALUE = 0x8a9db909;\\n    /// bytes4(keccak256(\\\"_isSignedContractTerms(bytes32,bytes32,address,bytes32,bytes)\\\"))\\n    bytes4 private constant SIGNED_CONTRACT_MAGICVALUE = 0xda041b1b;\\n\\n    /// @dev The EIP-712 domain type hash used for computing the domain\\n    /// separator.\\n    /// keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n    bytes32 internal constant MILESTONE_DOMAIN_TYPE_HASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\\n\\n    /// @dev The EIP-712 domain name used for computing the domain separator.\\n    /// keccak256(\\\"ReleasedMilestone\\\");\\n    bytes32 internal constant MILESTONE_RELEASE_DOMAIN_NAME = 0xf7a7a250652776e79083ebf7548d7f678c46dd027033d24129ec9e00e571ea9b;\\n    /// keccak256(\\\"RefundedMilestone\\\");\\n    bytes32 internal constant MILESTONE_REFUND_DOMAIN_NAME = 0x5dac513728b4cea6b6904b8f3b5f9c178f0cf83a3ecf4e94ad498e7cc75192ec;\\n    /// keccak256(\\\"SignedContract\\\");\\n    bytes32 internal constant SIGNED_CONTRACT_DOMAIN_NAME = 0x288d28d1a9a71cba45c3234f023dd66e1f027ac6e031e2d93e302aea3277fb64;\\n\\n    /// @dev The EIP-712 domain version used for computing the domain separator.\\n    /// keccak256(\\\"v1\\\");\\n    bytes32 internal constant DOMAIN_VERSION = 0x0984d5efd47d99151ae1be065a709e56c602102f24c1abc4008eb3f815a8d217;\\n\\n    /// @dev The domain separator used for signing orders that gets mixed in\\n    /// making signatures for different domains incompatible. This domain\\n    /// separator is computed following the EIP-712 standard and has replay\\n    /// protection mixed in so that signed orders are only valid for specific\\n    /// contracts.\\n    bytes32 public immutable MILESTONE_RELEASE_DOMAIN_SEPARATOR;\\n    bytes32 public immutable MILESTONE_REFUND_DOMAIN_SEPARATOR;\\n    bytes32 public immutable SIGNED_CONTRACT_DOMAIN_SEPARATOR;\\n\\n    // solhint-ignore-contructors\\n    constructor() {\\n        // NOTE: Currently, the only way to get the chain ID in solidity is\\n        // using assembly.\\n        uint256 chainId;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            chainId := chainid()\\n        }\\n\\n        MILESTONE_RELEASE_DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                MILESTONE_DOMAIN_TYPE_HASH,\\n                MILESTONE_RELEASE_DOMAIN_NAME,\\n                DOMAIN_VERSION,\\n                chainId,\\n                address(this)\\n            )\\n        );\\n\\n        MILESTONE_REFUND_DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                MILESTONE_DOMAIN_TYPE_HASH,\\n                MILESTONE_REFUND_DOMAIN_NAME,\\n                DOMAIN_VERSION,\\n                chainId,\\n                address(this)\\n            )\\n        );\\n\\n        SIGNED_CONTRACT_DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                MILESTONE_DOMAIN_TYPE_HASH,\\n                SIGNED_CONTRACT_DOMAIN_NAME,\\n                DOMAIN_VERSION,\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @dev Get domain separator in scope of EIP-712.\\n     *\\n     * @return EIP-712 domain.\\n     */\\n    function getMilestoneReleaseDomainSeparator() public virtual view returns(bytes32) {\\n        return MILESTONE_RELEASE_DOMAIN_SEPARATOR;\\n    }\\n\\n    /**\\n     * @dev Get domain separator in scope of EIP-712.\\n     *\\n     * @return EIP-712 domain.\\n     */\\n    function getMilestoneRefundDomainSeparator() public virtual view returns(bytes32) {\\n        return MILESTONE_REFUND_DOMAIN_SEPARATOR;\\n    }\\n\\n    /**\\n     * @dev Get domain separator in scope of EIP-712.\\n     *\\n     * @return EIP-712 domain.\\n     */\\n    function getSignedContractDomainSeparator() public virtual view returns(bytes32) {\\n        return SIGNED_CONTRACT_DOMAIN_SEPARATOR;\\n    }\\n\\n    /**\\n     * @dev Withdraw payment token amount released by payer.\\n     *\\n     * Works only for the full milestone amount,\\n     * partial withdrawals with off-chain signatures are currently not supported.\\n     *\\n     * Can be called by anyone, as recipient is static,\\n     * can be potenatially used to sponsor gas fees by payer.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone.\\n     * @param _amount Amount to withdraw.\\n     * @param _payerDelegateSignature Signed digest for release of amount.\\n     */\\n    function withdrawPreApprovedMilestone(\\n        bytes32 _cid,\\n        uint16 _index,\\n        uint _amount,\\n        bytes calldata _payerDelegateSignature\\n    ) public nonReentrant {\\n        address _payerDelegate = contracts[_cid].payerDelegate;\\n        bytes32 _mid = EscrowUtilsLib.genMid(_cid, _index);\\n        Milestone memory _m = milestones[_mid];\\n        require(_m.amount == _amount, ERROR_RELEASED);\\n        require(_amount > 0 && _m.fundedAmount >= _m.claimedAmount + _amount, ERROR_RELEASED);\\n        require(_isPreApprovedMilestoneRelease(\\n            _cid,\\n            _index,\\n            _amount,\\n            _payerDelegate,\\n            getMilestoneReleaseDomainSeparator(),\\n            _payerDelegateSignature\\n        ) == MAGICVALUE, ERROR_INVALID_SIGNATURE);\\n        \\n        _m.releasedAmount += _amount;\\n        _releaseMilestone(_mid, _m.releasedAmount, _amount, _payerDelegate);\\n\\n        milestones[_mid].releasedAmount = 0;\\n        uint _withdrawn = _withdrawMilestone(_cid, _mid, _m, _m.payeeAccount, _m.releasedAmount);\\n        emit WithdrawnMilestone(_mid, _m.payeeAccount, _withdrawn); \\n    }\\n\\n    /**\\n     * @dev Withdraw payment token amount refunded by payee.\\n     *\\n     * Works only for the full milestone amount,\\n     * partial withdrawals with off-chain signatures are currently not supported.\\n     *\\n     * Can be called by anyone, as recipient is static,\\n     * can be potenatially used to sponsor gas fees by payer.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone.\\n     * @param _amount Amount to refund.\\n     * @param _payeeDelegateSignature Signed digest for release of amount.\\n     */\\n    function refundPreApprovedMilestone(\\n        bytes32 _cid,\\n        uint16 _index,\\n        uint _amount,\\n        bytes calldata _payeeDelegateSignature\\n    ) public nonReentrant {\\n        address _payeeDelegate = contracts[_cid].payeeDelegate;\\n        bytes32 _mid = EscrowUtilsLib.genMid(_cid, _index);\\n        Milestone memory _m = milestones[_mid];\\n        require(_m.amount == _amount, ERROR_RELEASED);\\n        require(_amount > 0 && _m.fundedAmount >= _m.claimedAmount + _amount, ERROR_RELEASED);\\n        require(_isPreApprovedMilestoneRelease(\\n            _cid,\\n            _index,\\n            _amount,\\n            _payeeDelegate,\\n            getMilestoneRefundDomainSeparator(),\\n            _payeeDelegateSignature\\n        ) == MAGICVALUE, ERROR_INVALID_SIGNATURE);\\n        \\n        _m.refundedAmount += _amount;\\n        _cancelMilestone(_mid, _m.refundedAmount, _amount, _payeeDelegate);\\n\\n        milestones[_mid].refundedAmount = 0;\\n        uint _withdrawn = _withdrawMilestone(_cid, _mid, _m, _m.refundAccount, _m.refundedAmount);\\n        emit RefundedMilestone(_mid, _m.refundAccount, _withdrawn);\\n    }\\n\\n    /**\\n     * @dev If payee has signed contract off-chain, allow funding with payee signature as a proof\\n     * that he has agreed the terms.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone.\\n     * @param _termsCid Contract IPFS cid signed by payee.\\n     * @param _amountToFund Amount to fund.\\n     * @param _payeeSignature Signed digest of terms cid by payee.\\n     * @param _payerSignature Signed digest of terms cid by payer, can be bytes32(0) if caller is payer.\\n     */\\n    function _signAndFundMilestone(\\n        bytes32 _cid,\\n        uint16 _index,\\n        bytes32 _termsCid,\\n        uint _amountToFund,\\n        bytes calldata _payeeSignature,\\n        bytes calldata _payerSignature\\n    ) internal {\\n        address _payer = contracts[_cid].payer;\\n        require(msg.sender == _payer || _isSignedContractTerms(\\n            _cid,\\n            _termsCid,\\n            _payer,\\n            getSignedContractDomainSeparator(),\\n            _payerSignature\\n        ) == SIGNED_CONTRACT_MAGICVALUE, ERROR_INVALID_SIGNATURE);\\n        require(_isSignedContractTerms(\\n            _cid,\\n            _termsCid,\\n            contracts[_cid].payee,\\n            getSignedContractDomainSeparator(),\\n            _payeeSignature\\n        ) == SIGNED_CONTRACT_MAGICVALUE, ERROR_INVALID_SIGNATURE);\\n\\n        _fundMilestone(_cid, _index, _amountToFund);\\n    }\\n\\n    /**\\n     * @dev Check if milestone release was pre-approved.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Index of milestone in scope of contract.\\n     * @param _amount Amount of payment token to release.\\n     * @param _validator Address of opposite party which approval is needed.\\n     * @param _domain EIP-712 domain.\\n     * @param _callData Digest of milestone data.\\n     * @return MAGICVALUE for success 0x00000000 for failure.\\n     */\\n    function _isPreApprovedMilestoneRelease(\\n        bytes32 _cid,\\n        uint16 _index,\\n        uint256 _amount,\\n        address _validator,\\n        bytes32 _domain,\\n        bytes calldata _callData\\n    ) internal pure returns (bytes4) {\\n        return EIP712._isValidEIP712Signature(\\n            _validator,\\n            MAGICVALUE,\\n            abi.encode(_domain, _cid, _index, _amount),\\n            _callData\\n        );\\n    }\\n\\n    /**\\n     * @dev Check if contract terms were signed by all parties.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _termsCid Specific version of contract cid which was signed, can be the same as _cid\\n     * @param _validator Address of opposite party which approval is needed.\\n     * @param _domain EIP-712 domain.\\n     * @param _callData Digest of contract data in scope of milestone.\\n     * @return SIGNED_CONTRACT_MAGICVALUE for success 0x00000000 for failure.\\n     */\\n    function _isSignedContractTerms(\\n        bytes32 _cid,\\n        bytes32 _termsCid,\\n        address _validator,\\n        bytes32 _domain,\\n        bytes calldata _callData\\n    ) internal pure returns (bytes4) {\\n        return EIP712._isValidEIP712Signature(\\n            _validator,\\n            SIGNED_CONTRACT_MAGICVALUE,\\n            abi.encode(_domain, _cid, _termsCid),\\n            _callData\\n        );\\n    }\\n}\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/interfaces/IEscrowDisputeManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\ninterface IEscrowDisputeManager {\\n    function proposeSettlement(\\n        bytes32 _cid,\\n        uint16 _index,\\n        address _plaintiff,\\n        address _payer,\\n        address _payee,\\n        uint _refundedPercent,\\n        uint _releasedPercent,\\n        bytes32 _statement\\n    ) external;\\n\\n    function acceptSettlement(bytes32 _cid, uint16 _index, uint256 _ruling) external;\\n\\n    function disputeSettlement(\\n        address _feePayer,\\n        bytes32 _cid,\\n        uint16 _index,\\n        bytes32 _termsCid,\\n        bool _ignoreCoverage,\\n        bool _multiMilestone\\n    ) external;\\n\\n    function executeSettlement(bytes32 _cid, uint16 _index, bytes32 _mid) external returns(uint256, uint256, uint256);\\n    function getSettlementByRuling(bytes32 _mid, uint256 _ruling) external returns(uint256, uint256, uint256); \\n\\n    function submitEvidence(address _from, string memory _label, bytes32 _cid, uint16 _index, bytes calldata _evidence) external;\\n    function ruleDispute(bytes32 _cid, uint16 _index, bytes32 _mid) external returns(uint256);\\n    \\n    function resolutions(bytes32 _mid) external view returns(uint256);\\n    function hasSettlementDispute(bytes32 _mid) external view returns(bool);\\n    function ARBITER() external view returns(address);\\n}\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/interfaces/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\ninterface IRegistry {\\n    function registerNewContract(bytes32 _cid, address _payer, address _payee) external;\\n    function escrowContracts(address _addr) external returns (bool);\\n    function insuranceManager() external returns (address);\\n}\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\ninterface ITreasury {\\n    function registerClaim(bytes32 _termsCid, address _fromAccount, address _toAccount, address _token, uint _amount) external returns(bool);\\n    function requestWithdraw(bytes32 _termsCid, address _toAccount, address _token, uint _amount) external returns(bool);\\n}\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/libs/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nlibrary EIP712 {\\n    /**\\n     * @dev Check if milestone release was pre-approved.\\n     *\\n     * @param _validator Address of opposite party which approval is needed.\\n     * @param _success bytes4 hash of called function, returned as success result.\\n     * @param _encodedChallenge abi encoded string of variables to proof.\\n     * @param _signature Digest of challenge.\\n     * @return _success for success 0x00000000 for failure.\\n     */\\n    function _isValidEIP712Signature(\\n        address _validator,\\n        bytes4 _success,\\n        bytes memory _encodedChallenge,\\n        bytes calldata _signature\\n    ) internal pure returns (bytes4) {\\n        uint8 _v;\\n        bytes32 _r;\\n        bytes32 _s;\\n        (_v, _r, _s) = abi.decode(_signature, (uint8, bytes32, bytes32));\\n        bytes32 _hash = keccak256(_encodedChallenge);\\n        address _signer =\\n            ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", _hash)\\n                ),\\n                _v,\\n                _r,\\n                _s\\n            );\\n\\n        if (_validator == _signer) {\\n            return _success;\\n        } else {\\n            return bytes4(0);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/contracts/libs/EscrowUtilsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MPL-2.0\\n\\npragma solidity >=0.8.4 <0.9.0;\\n\\nlibrary EscrowUtilsLib {\\n    struct MilestoneParams {\\n        address paymentToken;\\n        address treasury;\\n        address payeeAccount;\\n        address refundAccount;\\n        address escrowDisputeManager;\\n        uint autoReleasedAt;\\n        uint amount;\\n        uint16 parentIndex;\\n    }\\n    \\n    struct Contract {\\n        address payer;\\n        address payerDelegate;\\n        address payee;\\n        address payeeDelegate;\\n    }\\n\\n    /**\\n     * @dev Generate bytes32 uid for contract's milestone.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Number of milestone (255 max).\\n     * @return milestone id (mid).\\n     */\\n    function genMid(bytes32 _cid, uint16 _index) internal pure returns(bytes32) {\\n        return keccak256(abi.encode(_cid, _index));\\n    }\\n\\n    /**\\n     * @dev Generate unique terms key in scope of a contract.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _termsCid cid of suggested contract version.\\n     * @return unique storage key for amendment.\\n     */\\n    function genTermsKey(bytes32 _cid, bytes32 _termsCid) internal pure returns(bytes32) {\\n        return keccak256(abi.encode(_cid, _termsCid));\\n    }\\n\\n    /**\\n     * @dev Generate unique settlement key in scope of a contract milestone.\\n     *\\n     * @param _cid Contract's IPFS cid.\\n     * @param _index Milestone index.\\n     * @param _revision Current version of milestone extended terms.\\n     * @return unique storage key for amendment.\\n     */\\n    function genSettlementKey(bytes32 _cid, uint16 _index, uint8 _revision) internal pure returns(bytes32) {\\n        return keccak256(abi.encode(_cid, _index, _revision));\\n    }\\n}\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/vyacheslavvoronchuk/projects/greet_escrow/node_modules/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"approvedCid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"ApprovedContractVersion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"revision\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"ApprovedSettlement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"mid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"releaser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CanceledMilestone\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"parentIndex\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"mid\",\"type\":\"bytes32\"}],\"name\":\"ChildMilestone\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"mid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"funder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundedMilestone\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"NewContractPayee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"}],\"name\":\"NewContractPayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"amendmentCid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"NewContractVersion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"mid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"escrowDisputeManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"autoReleasedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewMilestone\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"revision\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"termsCid\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"payeeAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refundAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"escrowDisputeManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"autoReleasedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refundedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasedAmount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Amendable.SettlementParams\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"NewSettlement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"mid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefundedMilestone\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"mid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"releaser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReleasedMilestone\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"mid\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawnMilestone\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AMENDMENT_DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MILESTONE_REFUND_DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MILESTONE_RELEASE_DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SIGNED_CONTRACT_DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRUSTED_REGISTRY\",\"outputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"}],\"name\":\"acceptSettlement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_amountToRefund\",\"type\":\"uint256\"}],\"name\":\"cancelMilestone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_newDelegate\",\"type\":\"address\"}],\"name\":\"changeDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"contractVersionApprovals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"contractVersionProposals\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"termsCid\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"contractVersions\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"contracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payerDelegate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payeeDelegate\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"_ignoreCoverage\",\"type\":\"bool\"}],\"name\":\"disputeSettlement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"}],\"name\":\"executeSettlement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_amountToFund\",\"type\":\"uint256\"}],\"name\":\"fundMilestone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAmendmentDomainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"}],\"name\":\"getLatestApprovedContractVersion\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMilestoneRefundDomainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMilestoneReleaseDomainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSignedContractDomainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_termsCid\",\"type\":\"bytes32\"}],\"name\":\"isApprovedContractVersion\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_mid\",\"type\":\"bytes32\"},{\"internalType\":\"contract IEscrowDisputeManager\",\"name\":\"_escrowDisputeManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_autoReleasedAt\",\"type\":\"uint256\"}],\"name\":\"isAutoReleaseAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lastMilestoneIndex\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"milestones\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payeeAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refundAccount\",\"type\":\"address\"},{\"internalType\":\"contract IEscrowDisputeManager\",\"name\":\"escrowDisputeManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"autoReleasedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refundedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"revision\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_amendmentCid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_payeeSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_payerSignature\",\"type\":\"bytes\"}],\"name\":\"preApprovedAmendment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_refundedPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_releasedPercent\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_statement\",\"type\":\"bytes32\"}],\"name\":\"proposeSettlement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"}],\"name\":\"refundMilestone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_payeeDelegateSignature\",\"type\":\"bytes\"}],\"name\":\"refundPreApprovedMilestone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_payer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_payerDelegate\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_payee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_payeeDelegate\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"payeeAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refundAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"escrowDisputeManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"autoReleasedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"parentIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct EscrowUtilsLib.MilestoneParams[]\",\"name\":\"_milestones\",\"type\":\"tuple[]\"}],\"name\":\"registerContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_paymentToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_payeeAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_refundAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_escrowDisputeManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_autoReleasedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_amendmentCid\",\"type\":\"bytes32\"}],\"name\":\"registerMilestone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_amountToRelease\",\"type\":\"uint256\"}],\"name\":\"releaseMilestone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"settlementProposals\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"termsCid\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"payeeAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refundAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"escrowDisputeManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"autoReleasedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refundedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasedAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct Amendable.SettlementParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_termsCid\",\"type\":\"bytes32\"}],\"name\":\"signAndApproveContractVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"_termsCid\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_amountToFund\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_payeeSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_payerSignature\",\"type\":\"bytes\"}],\"name\":\"signAndFundMilestone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_termsCid\",\"type\":\"bytes32\"}],\"name\":\"signAndProposeContractVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"_termsCid\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_payeeAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_refundAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_escrowDisputeManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_autoReleasedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_refundedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_releasedAmount\",\"type\":\"uint256\"}],\"name\":\"signAndProposeMilestoneSettlement\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"_revision\",\"type\":\"uint8\"}],\"name\":\"signApproveAndExecuteMilestoneSettlement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"}],\"name\":\"stopMilestoneAutoRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_evidence\",\"type\":\"bytes\"}],\"name\":\"submitEvidence\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"}],\"name\":\"withdrawMilestone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_cid\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_index\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_payerDelegateSignature\",\"type\":\"bytes\"}],\"name\":\"withdrawPreApprovedMilestone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EscrowV1","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d30be688c053e0a308468b1c567bdfd6a210b020","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}