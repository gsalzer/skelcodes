{"status":"1","message":"OK","result":[{"SourceCode":"{\"ApproveAndCallFallBack.sol\":{\"content\":\"    //SPDX-License-Identifier: MIT\\n    pragma solidity 0.8.5;\\n\\n\\n\\n    // ----------------------------------------------------------------------------\\n\\n    // Contract function to receive approval and execute function in one call\\n\\n    // Borrowed from MiniMeToken\\n\\n    // ----------------------------------------------------------------------------\\n\\n    abstract contract ApproveAndCallFallBack {\\n\\n        function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public virtual ;\\n\\n    }\\n\\n\"},\"ERC20.sol\":{\"content\":\"    //SPDX-License-Identifier: MIT\\n    pragma solidity 0.8.5;\\n\\n\\n    // ----------------------------------------------------------------------------\\n\\n    // ERC Token Standard #20 Interface\\n\\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\\n\\n    // ----------------------------------------------------------------------------\\n\\n    abstract contract ERC20Interface {\\n\\n        function totalSupply() public view virtual returns (uint);\\n\\n        function balanceOf(address tokenOwner) public view virtual returns (uint balance);\\n\\n        function allowance(address tokenOwner, address spender) public view virtual returns (uint remaining);\\n\\n        function transfer(address to, uint tokens) public virtual returns (bool success);\\n\\n        function approve(address spender, uint tokens) public virtual returns (bool success);\\n\\n        function transferFrom(address from, address to, uint tokens) public virtual returns (bool success);\\n\\n\\n        event Transfer(address indexed from, address indexed to, uint tokens);\\n\\n        event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\\n\\n    }\\n\\n\\n\"},\"ERC721TokenReceiver.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\npragma abicoder v2;\\n\\ninterface ERC721TokenReceiver {\\n        /// @notice Handle the receipt of an NFT\\n        /// @dev The ERC721 smart contract calls this function on the\\n        /// recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\\n        /// of other than the magic value MUST result in the transaction being reverted.\\n        /// @notice The contract address is always the message sender.\\n        /// @param _operator The address which called `safeTransferFrom` function\\n        /// @param _from The address which previously owned the token\\n        /// @param _tokenId The NFT identifier which is being transferred\\n        /// @param _data Additional data with no specified format\\n        /// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n        /// unless throwing\\n        function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes memory _data) external returns(bytes4);\\n     }\"},\"safeTransferFrom.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\npragma abicoder v2;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\n// Contract function calls from the OpenZeppelin library\\n\\nlibrary Address {\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size \\u003e 0;\\n    }\\n\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length \\u003e 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\n\\n// safeTransferFrom function from OpenZeppelin\\u0027s SafeERC20 library\\n\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransferFrom(\\n        ERC20Interface token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function _callOptionalReturn(ERC20Interface token, bytes memory data) private {\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length \\u003e 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"},\"SeasonalTokenFarm.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\npragma abicoder v2;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./ERC721TokenReceiver.sol\\\";\\nimport \\\"./ApproveAndCallFallBack.sol\\\";\\nimport \\\"./safeTransferFrom.sol\\\";\\n\\n\\n/*\\n * Seasonal Token Farm\\n *\\n * This contract receives donations of seasonal tokens and distributes them to providers of liquidity\\n * for the token/ETH trading pairs on Uniswap v3.\\n *\\n * Warning: Tokens can be lost if they are not transferred to the farm contract in the correct way.\\n *\\n * Seasonal tokens must be donated using the safeApproveAndCall() function of the seasonal token contracts.\\n * Tokens sent directly to the farm address will be lost.\\n *\\n * Contracts that deposit Uniswap liquidy tokens need to implement the onERC721Received() function in order\\n * to be able to withdraw those tokens. Any contracts that interact with the farm must be tested prior to \\n * deployment on the main network.\\n * \\n * The developers accept no responsibility for tokens irretrievably lost in accidental transfers.\\n * \\n */\\n\\n\\n\\n\\n\\ninterface INonfungiblePositionManager {\\n    function positions(uint256 tokenId)\\n        external\\n        view\\n        returns (\\n            uint96 nonce,\\n            address operator,\\n            address token0,\\n            address token1,\\n            uint24 fee,\\n            int24 tickLower,\\n            int24 tickUpper,\\n            uint128 liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n        );\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\\n}\\n\\n\\nstruct LiquidityToken {\\n    address owner;\\n    address seasonalToken;\\n    uint256 depositTime;\\n    uint256 initialCumulativeSpringTokensFarmed;\\n    uint256 initialCumulativeSummerTokensFarmed;\\n    uint256 initialCumulativeAutumnTokensFarmed;\\n    uint256 initialCumulativeWinterTokensFarmed;\\n    uint256 liquidity;\\n    uint256 position;\\n}\\n\\n\\ncontract SeasonalTokenFarm is ERC721TokenReceiver, ApproveAndCallFallBack {\\n\\n    // The Seasonal Token Farm runs on voluntary donations.\\n\\n    // Incoming donated tokens are distributed to liquidity providers for the ETH/Token trading pairs.\\n    // Each trading pair has an allocationSize. Incoming tokens are allocated to trading pairs in\\n    // proportion to their allocationSizes. The fraction of tokens allocated to a trading pair is\\n    // equal to that trading pair\\u0027s allocationSize divided by the sum of the allocationSizes.\\n\\n    // The initial allocationSizes are 5, 6, 7 and 8 for Spring, Summer, Autumn and Winter.\\n    // Four months after each token\\u0027s halving, the allocationSize for the ETH/Token trading pair\\n    // doubles. \\n    //\\n    // When the doubling of the Winter allocation occurs, the allocationSizes become 10, 12, 14 and 16,\\n    // which are simplified to 5, 6, 7, 8, and then the cycle repeats.\\n\\n    // Initially, the allocationSizes will be 5, 6, 7 and 8.\\n    //\\n    // After the Spring halving, they will be 10, 6, 7 and 8.\\n    // After the Summer halving, they will be 10, 12, 7 and 8.\\n    // After the Autumn halving, they will be 10, 12, 14 and 8.\\n    // After the Winter halving, they will be 5, 6, 7 and 8 again.\\n\\n    // The reduction of the allocationSizes from 10, 12, 14, 16 to 5, 6, 7, 8 doesn\\u0027t change the\\n    // payouts received. The fraction of farm rewards allocated to Spring, for example, \\n    // is 10/(10+12+14+16) = 5/(5+6+7+8).\\n\\n    uint256 public constant REALLOCATION_INTERVAL = (365 * 24 * 60 * 60 * 3) / 4; // 9 months\\n\\n\\n    // Liquidity positions must cover the full range of prices\\n\\n    int24 public constant REQUIRED_TICK_UPPER = 887200;\\n    int24 public constant REQUIRED_TICK_LOWER = -887200;\\n\\n\\n    // Liquidity tokens can be withdrawn for 7 days out of every 37.\\n    //\\n    // This means that about one fifth of the liquidity can be withdrawn at any given time,\\n    // preventing liquidity from disappearing in a panic, but liquidity providers can withdraw\\n    // to adjust their positions monthly.\\n\\n    uint256 public constant WITHDRAWAL_UNAVAILABLE_DAYS = 30;\\n    uint256 public constant WITHDRAWAL_AVAILABLE_DAYS = 7;\\n\\n\\n    // Each liquidity token deposited adds a specific amount of liquidity to the ETH/Seasonal Token\\n    // trading pair. Incoming tokens allocated to that trading pair are distributed to liquidity\\n    // token owners in proportion to the liquidity they have provided.\\n\\n    mapping(address =\\u003e uint256) public totalLiquidity;\\n    mapping(address =\\u003e uint256[]) public tokenOfOwnerByIndex;\\n    mapping(uint256 =\\u003e LiquidityToken) public liquidityTokens;\\n\\n    address public immutable springTokenAddress;\\n    address public immutable summerTokenAddress;\\n    address public immutable autumnTokenAddress;\\n    address public immutable winterTokenAddress;\\n    address public immutable wethAddress;\\n\\n    INonfungiblePositionManager public immutable nonfungiblePositionManager;\\n\\n    uint256 public immutable startTime;\\n    \\n\\n    // We keep track of the cumulative number of farmed (donated and allocated) tokens of each type per unit\\n    // liquidity, for each trading pair. This allows us to calculate the payout for each liquidity token.\\n    // \\n    // When a liquidity token is deposited, the value of the cumulative number of farmed tokens per unit\\n    // liquidity is recorded. The number of tokens farmed by that liquidity position is given by the\\n    // amount of liquidity multiplied by the increase in the cumulative number of tokens farmed per\\n    // unit liquidity.\\n    //\\n    // cumulativeTokensFarmedPerUnitLiquidity[trading_pair_token][farmed_token] = farmed tokens/liquidity\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public cumulativeTokensFarmedPerUnitLiquidity;\\n\\n    event Deposit(address indexed from, uint256 liquidityTokenId);\\n    event Withdraw(address indexed tokenOwner, uint256 liquidityTokenId);\\n    event Donate(address indexed from, address seasonalTokenAddress, uint256 amount);\\n    event Harvest(address indexed tokenOwner, uint256 liquidityTokenId, \\n                  uint256 springAmount, uint256 summerAmount, uint256 autumnAmount, uint256 winterAmount);\\n\\n\\n    constructor (INonfungiblePositionManager nonfungiblePositionManager_, \\n                 address springTokenAddress_, \\n                 address summerTokenAddress_,\\n                 address autumnTokenAddress_,\\n                 address winterTokenAddress_,\\n                 address wethAddress_,\\n                 uint256 startTime_) {\\n\\n        nonfungiblePositionManager = nonfungiblePositionManager_;\\n\\n        springTokenAddress = springTokenAddress_;\\n        summerTokenAddress = summerTokenAddress_;\\n        autumnTokenAddress = autumnTokenAddress_;\\n        winterTokenAddress = winterTokenAddress_;\\n        wethAddress = wethAddress_;\\n\\n        startTime = startTime_;\\n    }\\n\\n    function balanceOf(address liquidityProvider) external view returns (uint256) {\\n        return tokenOfOwnerByIndex[liquidityProvider].length;\\n    }\\n\\n    function numberOfReallocations() internal view returns (uint256) {\\n        if (block.timestamp \\u003c startTime + REALLOCATION_INTERVAL)\\n            return 0;\\n        uint256 timeSinceStart = block.timestamp - startTime;\\n        return timeSinceStart / REALLOCATION_INTERVAL;\\n    }\\n\\n    function hasDoubledAllocation(uint256 tokenNumber) internal view returns (uint256) {\\n\\n        if (numberOfReallocations() % 4 \\u003c tokenNumber)\\n            return 0;\\n        \\n        return 1;\\n    }\\n\\n    function springAllocationSize() public view returns (uint256) {\\n        return 5 * 2 ** hasDoubledAllocation(1);\\n    }\\n\\n    function summerAllocationSize() public view returns (uint256) {\\n        return 6 * 2 ** hasDoubledAllocation(2);\\n    }\\n\\n    function autumnAllocationSize() public view returns (uint256) {\\n        return 7 * 2 ** hasDoubledAllocation(3);\\n    }\\n\\n    function winterAllocationSize() public pure returns (uint256) {\\n        return 8;\\n    }\\n\\n    function getEffectiveTotalAllocationSize(uint256 totalSpringLiquidity, \\n                                             uint256 totalSummerLiquidity,\\n                                             uint256 totalAutumnLiquidity,\\n                                             uint256 totalWinterLiquidity) internal view returns (uint256) {\\n        uint256 effectiveTotal = 0;\\n\\n        if (totalSpringLiquidity \\u003e 0)\\n            effectiveTotal += springAllocationSize();\\n        if (totalSummerLiquidity \\u003e 0)\\n            effectiveTotal += summerAllocationSize();\\n        if (totalAutumnLiquidity \\u003e 0)\\n            effectiveTotal += autumnAllocationSize();\\n        if (totalWinterLiquidity \\u003e 0)\\n            effectiveTotal += winterAllocationSize();\\n        \\n        return effectiveTotal;\\n    }\\n\\n    function allocateIncomingTokensToTradingPairs(address incomingTokenAddress, uint256 amount) internal {\\n\\n        uint256 totalSpringLiquidity = totalLiquidity[springTokenAddress];\\n        uint256 totalSummerLiquidity = totalLiquidity[summerTokenAddress];\\n        uint256 totalAutumnLiquidity = totalLiquidity[autumnTokenAddress];\\n        uint256 totalWinterLiquidity = totalLiquidity[winterTokenAddress];\\n\\n        uint256 effectiveTotalAllocationSize = getEffectiveTotalAllocationSize(totalSpringLiquidity,\\n                                                                               totalSummerLiquidity,\\n                                                                               totalAutumnLiquidity,\\n                                                                               totalWinterLiquidity);\\n\\n        require(effectiveTotalAllocationSize \\u003e 0, \\\"No liquidity in farm\\\");\\n\\n        uint256 springPairAllocation = (amount * springAllocationSize()) / effectiveTotalAllocationSize;\\n        uint256 summerPairAllocation = (amount * summerAllocationSize()) / effectiveTotalAllocationSize;\\n        uint256 autumnPairAllocation = (amount * autumnAllocationSize()) / effectiveTotalAllocationSize;\\n        uint256 winterPairAllocation = (amount * winterAllocationSize()) / effectiveTotalAllocationSize;\\n\\n        if (totalSpringLiquidity \\u003e 0)\\n            cumulativeTokensFarmedPerUnitLiquidity[springTokenAddress][incomingTokenAddress] \\n                += (2 ** 128) * springPairAllocation / totalSpringLiquidity;\\n\\n        if (totalSummerLiquidity \\u003e 0)\\n            cumulativeTokensFarmedPerUnitLiquidity[summerTokenAddress][incomingTokenAddress] \\n                += (2 ** 128) * summerPairAllocation / totalSummerLiquidity;\\n\\n        if (totalAutumnLiquidity \\u003e 0)\\n            cumulativeTokensFarmedPerUnitLiquidity[autumnTokenAddress][incomingTokenAddress] \\n                += (2 ** 128) * autumnPairAllocation / totalAutumnLiquidity;\\n\\n        if (totalWinterLiquidity \\u003e 0)\\n            cumulativeTokensFarmedPerUnitLiquidity[winterTokenAddress][incomingTokenAddress] \\n                += (2 ** 128) * winterPairAllocation / totalWinterLiquidity;\\n    }\\n\\n    function receiveApproval(address from, uint256 tokens, address token, bytes calldata data) public override {\\n        data; // suppress unused variable compiler warnings\\n        receiveSeasonalTokens(from, token, tokens);\\n    }\\n\\n    function receiveSeasonalTokens(address from, address tokenAddress, uint256 amount) internal {\\n\\n        require(msg.sender == springTokenAddress || msg.sender == summerTokenAddress\\n                || msg.sender == autumnTokenAddress || msg.sender == winterTokenAddress,\\n                \\\"Only Seasonal Tokens can be donated\\\");\\n        \\n        allocateIncomingTokensToTradingPairs(tokenAddress, amount);\\n\\n        emit Donate(from, tokenAddress, amount);\\n\\n        SafeERC20.safeTransferFrom(ERC20Interface(tokenAddress), from, address(this), amount);\\n    }\\n\\n    function onERC721Received(address _operator, address _from, uint256 liquidityTokenId, bytes calldata _data) \\n                             external override returns(bytes4) {\\n\\n        require(msg.sender == address(nonfungiblePositionManager), \\n                \\\"Only Uniswap v3 liquidity tokens can be deposited\\\");\\n\\n        LiquidityToken memory liquidityToken = getLiquidityToken(liquidityTokenId);\\n        \\n        liquidityToken.owner = _from;\\n        liquidityToken.depositTime = block.timestamp;\\n\\n        liquidityToken.position = tokenOfOwnerByIndex[_from].length;\\n        tokenOfOwnerByIndex[_from].push(liquidityTokenId);\\n\\n        liquidityToken.initialCumulativeSpringTokensFarmed\\n            = cumulativeTokensFarmedPerUnitLiquidity[liquidityToken.seasonalToken][springTokenAddress];\\n\\n        liquidityToken.initialCumulativeSummerTokensFarmed\\n            = cumulativeTokensFarmedPerUnitLiquidity[liquidityToken.seasonalToken][summerTokenAddress];\\n\\n        liquidityToken.initialCumulativeAutumnTokensFarmed\\n            = cumulativeTokensFarmedPerUnitLiquidity[liquidityToken.seasonalToken][autumnTokenAddress];\\n\\n        liquidityToken.initialCumulativeWinterTokensFarmed\\n            = cumulativeTokensFarmedPerUnitLiquidity[liquidityToken.seasonalToken][winterTokenAddress];\\n\\n        liquidityTokens[liquidityTokenId] = liquidityToken;\\n        totalLiquidity[liquidityToken.seasonalToken] += liquidityToken.liquidity;\\n\\n        emit Deposit(_from, liquidityTokenId);\\n\\n        _data; _operator; // suppress unused variable compiler warnings\\n        return bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"));\\n    }\\n\\n    function getLiquidityToken(uint256 tokenId) internal view returns(LiquidityToken memory) {\\n\\n        LiquidityToken memory liquidityToken;\\n        address token0;\\n        address token1;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        uint256 liquidity;\\n        uint24 fee;\\n        \\n        (token0, token1, fee, tickLower, tickUpper, liquidity) = getPositionDataForLiquidityToken(tokenId);\\n        liquidityToken.liquidity = liquidity;\\n        \\n        if (token0 == wethAddress)\\n            liquidityToken.seasonalToken = token1;\\n        else if (token1 == wethAddress)\\n            liquidityToken.seasonalToken = token0;\\n\\n        require(liquidityToken.seasonalToken == springTokenAddress ||\\n                liquidityToken.seasonalToken == summerTokenAddress ||\\n                liquidityToken.seasonalToken == autumnTokenAddress ||\\n                liquidityToken.seasonalToken == winterTokenAddress,\\n                \\\"Invalid trading pair\\\");\\n\\n        require(tickLower == REQUIRED_TICK_LOWER \\u0026\\u0026 tickUpper == REQUIRED_TICK_UPPER,\\n                \\\"Liquidity must cover full range of prices\\\");\\n\\n        require(fee == 10000, \\\"Fee tier must be 1%\\\");\\n\\n        return liquidityToken;\\n    }\\n\\n    function getPositionDataForLiquidityToken(uint256 tokenId) \\n                                             internal view returns (address, address, uint24, int24, int24, uint256){\\n        address token0;\\n        address token1;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        uint256 liquidity;\\n        uint24 fee;\\n\\n        (,, token0, token1, fee, tickLower, tickUpper, liquidity,,,,) \\n            = nonfungiblePositionManager.positions(tokenId);\\n\\n        return (token0, token1, fee, tickLower, tickUpper, liquidity);\\n    }\\n\\n    function setCumulativeSpringTokensFarmedToCurrentValue(uint256 liquidityTokenId, address seasonalToken) internal {\\n        liquidityTokens[liquidityTokenId].initialCumulativeSpringTokensFarmed\\n            = cumulativeTokensFarmedPerUnitLiquidity[seasonalToken][springTokenAddress];\\n    }\\n\\n    function setCumulativeSummerTokensFarmedToCurrentValue(uint256 liquidityTokenId, address seasonalToken) internal {\\n        liquidityTokens[liquidityTokenId].initialCumulativeSummerTokensFarmed\\n            = cumulativeTokensFarmedPerUnitLiquidity[seasonalToken][summerTokenAddress];\\n    }\\n\\n    function setCumulativeAutumnTokensFarmedToCurrentValue(uint256 liquidityTokenId, address seasonalToken) internal {\\n        liquidityTokens[liquidityTokenId].initialCumulativeAutumnTokensFarmed\\n            = cumulativeTokensFarmedPerUnitLiquidity[seasonalToken][autumnTokenAddress];\\n    }\\n\\n    function setCumulativeWinterTokensFarmedToCurrentValue(uint256 liquidityTokenId, address seasonalToken) internal {\\n        liquidityTokens[liquidityTokenId].initialCumulativeWinterTokensFarmed\\n            = cumulativeTokensFarmedPerUnitLiquidity[seasonalToken][winterTokenAddress];\\n    }\\n\\n    function getPayoutSize(uint256 liquidityTokenId, address farmedSeasonalToken, \\n                           address tradingPairSeasonalToken) internal view returns (uint256) {\\n\\n        uint256 initialCumulativeTokensFarmed;\\n\\n        if (farmedSeasonalToken == springTokenAddress)\\n            initialCumulativeTokensFarmed = liquidityTokens[liquidityTokenId].initialCumulativeSpringTokensFarmed;\\n        else if (farmedSeasonalToken == summerTokenAddress)\\n            initialCumulativeTokensFarmed = liquidityTokens[liquidityTokenId].initialCumulativeSummerTokensFarmed;\\n        else if (farmedSeasonalToken == autumnTokenAddress)\\n            initialCumulativeTokensFarmed = liquidityTokens[liquidityTokenId].initialCumulativeAutumnTokensFarmed;\\n        else\\n            initialCumulativeTokensFarmed = liquidityTokens[liquidityTokenId].initialCumulativeWinterTokensFarmed;\\n\\n        uint256 tokensFarmedPerUnitLiquiditySinceDeposit \\n            = cumulativeTokensFarmedPerUnitLiquidity[tradingPairSeasonalToken][farmedSeasonalToken]\\n              - initialCumulativeTokensFarmed;\\n\\n        return (tokensFarmedPerUnitLiquiditySinceDeposit \\n                * liquidityTokens[liquidityTokenId].liquidity) / (2 ** 128);\\n    }\\n\\n    function getPayoutSizes(uint256 liquidityTokenId) external view returns (uint256, uint256, uint256, uint256) {\\n\\n        address tradingPairSeasonalToken = liquidityTokens[liquidityTokenId].seasonalToken;\\n\\n        uint256 springPayout = getPayoutSize(liquidityTokenId, springTokenAddress, tradingPairSeasonalToken);\\n        uint256 summerPayout = getPayoutSize(liquidityTokenId, summerTokenAddress, tradingPairSeasonalToken);\\n        uint256 autumnPayout = getPayoutSize(liquidityTokenId, autumnTokenAddress, tradingPairSeasonalToken);\\n        uint256 winterPayout = getPayoutSize(liquidityTokenId, winterTokenAddress, tradingPairSeasonalToken);\\n\\n        return (springPayout, summerPayout, autumnPayout, winterPayout);\\n    }\\n\\n    function harvestSpring(uint256 liquidityTokenId, address tradingPairSeasonalToken) internal returns(uint256) {\\n\\n        uint256 amount = getPayoutSize(liquidityTokenId, springTokenAddress, tradingPairSeasonalToken);\\n        setCumulativeSpringTokensFarmedToCurrentValue(liquidityTokenId, tradingPairSeasonalToken);\\n        return amount;\\n    }\\n\\n    function harvestSummer(uint256 liquidityTokenId, address tradingPairSeasonalToken) internal returns(uint256) {\\n\\n        uint256 amount = getPayoutSize(liquidityTokenId, summerTokenAddress, tradingPairSeasonalToken);\\n        setCumulativeSummerTokensFarmedToCurrentValue(liquidityTokenId, tradingPairSeasonalToken);\\n        return amount;\\n    }\\n\\n    function harvestAutumn(uint256 liquidityTokenId, address tradingPairSeasonalToken) internal returns(uint256) {\\n\\n        uint256 amount = getPayoutSize(liquidityTokenId, autumnTokenAddress, tradingPairSeasonalToken);\\n        setCumulativeAutumnTokensFarmedToCurrentValue(liquidityTokenId, tradingPairSeasonalToken);\\n        return amount;\\n    }\\n\\n    function harvestWinter(uint256 liquidityTokenId, address tradingPairSeasonalToken) internal returns(uint256) {\\n\\n        uint256 amount = getPayoutSize(liquidityTokenId, winterTokenAddress, tradingPairSeasonalToken);\\n        setCumulativeWinterTokensFarmedToCurrentValue(liquidityTokenId, tradingPairSeasonalToken);\\n        return amount;\\n    }\\n\\n    function harvestAll(uint256 liquidityTokenId, address tradingPairSeasonalToken) \\n            internal returns (uint256, uint256, uint256, uint256) {\\n\\n        uint256 springAmount = harvestSpring(liquidityTokenId, tradingPairSeasonalToken);\\n        uint256 summerAmount = harvestSummer(liquidityTokenId, tradingPairSeasonalToken);\\n        uint256 autumnAmount = harvestAutumn(liquidityTokenId, tradingPairSeasonalToken);\\n        uint256 winterAmount = harvestWinter(liquidityTokenId, tradingPairSeasonalToken);\\n\\n        return (springAmount, summerAmount, autumnAmount, winterAmount);\\n    }\\n\\n    function sendHarvestedTokensToOwner(address tokenOwner, uint256 springAmount, uint256 summerAmount,\\n                                        uint256 autumnAmount, uint256 winterAmount) internal {\\n\\n        if (springAmount \\u003e 0)\\n            ERC20Interface(springTokenAddress).transfer(tokenOwner, springAmount);\\n        if (summerAmount \\u003e 0)\\n            ERC20Interface(summerTokenAddress).transfer(tokenOwner, summerAmount);\\n        if (autumnAmount \\u003e 0)\\n            ERC20Interface(autumnTokenAddress).transfer(tokenOwner, autumnAmount);\\n        if (winterAmount \\u003e 0)\\n            ERC20Interface(winterTokenAddress).transfer(tokenOwner, winterAmount);\\n    }\\n\\n    function harvest(uint256 liquidityTokenId) external {\\n        \\n        LiquidityToken storage liquidityToken = liquidityTokens[liquidityTokenId];\\n        require(msg.sender == liquidityToken.owner, \\\"Only owner can harvest\\\");\\n        \\n        (uint256 springAmount, \\n         uint256 summerAmount,\\n         uint256 autumnAmount,\\n         uint256 winterAmount) = harvestAll(liquidityTokenId, liquidityToken.seasonalToken);\\n\\n        emit Harvest(msg.sender, liquidityTokenId, springAmount, summerAmount, autumnAmount, winterAmount);\\n        \\n        sendHarvestedTokensToOwner(msg.sender, springAmount, summerAmount, autumnAmount, winterAmount);\\n    }\\n\\n    function canWithdraw(uint256 liquidityTokenId) public view returns (bool) {\\n\\n        uint256 depositTime = liquidityTokens[liquidityTokenId].depositTime;\\n        uint256 timeSinceDepositTime = block.timestamp - depositTime;\\n        uint256 daysSinceDepositTime = timeSinceDepositTime / (24 * 60 * 60);\\n\\n        return (daysSinceDepositTime) % (WITHDRAWAL_UNAVAILABLE_DAYS + WITHDRAWAL_AVAILABLE_DAYS) \\n                    \\u003e= WITHDRAWAL_UNAVAILABLE_DAYS;\\n    }\\n\\n    function nextWithdrawalTime(uint256 liquidityTokenId) external view returns (uint256) {\\n        \\n        uint256 depositTime = liquidityTokens[liquidityTokenId].depositTime;\\n        uint256 timeSinceDepositTime = block.timestamp - depositTime;\\n        uint256 withdrawalUnavailableTime = WITHDRAWAL_UNAVAILABLE_DAYS * 24 * 60 * 60;\\n        uint256 withdrawalAvailableTime = WITHDRAWAL_AVAILABLE_DAYS * 24 * 60 * 60;\\n\\n        if (timeSinceDepositTime \\u003c withdrawalUnavailableTime)\\n            return depositTime + withdrawalUnavailableTime;\\n\\n        uint256 numberOfWithdrawalCyclesUntilNextWithdrawalTime \\n                    = 1 + (timeSinceDepositTime - withdrawalUnavailableTime) \\n                          / (withdrawalUnavailableTime + withdrawalAvailableTime);\\n\\n        return depositTime + withdrawalUnavailableTime \\n                           + numberOfWithdrawalCyclesUntilNextWithdrawalTime\\n                             * (withdrawalUnavailableTime + withdrawalAvailableTime);\\n    }\\n\\n    function withdraw(uint256 liquidityTokenId) external {\\n\\n        require(canWithdraw(liquidityTokenId), \\\"This token cannot be withdrawn at this time\\\");\\n\\n        LiquidityToken memory liquidityToken = liquidityTokens[liquidityTokenId];\\n\\n        require(msg.sender == liquidityToken.owner, \\\"Only owner can withdraw\\\");\\n\\n        (uint256 springAmount, \\n         uint256 summerAmount,\\n         uint256 autumnAmount,\\n         uint256 winterAmount) = harvestAll(liquidityTokenId, liquidityToken.seasonalToken);\\n\\n        totalLiquidity[liquidityToken.seasonalToken] -= liquidityToken.liquidity;\\n        removeTokenFromListOfOwnedTokens(msg.sender, liquidityToken.position, liquidityTokenId);\\n        \\n        emit Harvest(msg.sender, liquidityTokenId, springAmount, summerAmount, autumnAmount, winterAmount);\\n        emit Withdraw(msg.sender, liquidityTokenId);\\n\\n        sendHarvestedTokensToOwner(msg.sender, springAmount, summerAmount, autumnAmount, winterAmount);\\n        nonfungiblePositionManager.safeTransferFrom(address(this), liquidityToken.owner, liquidityTokenId);\\n    }\\n\\n    function removeTokenFromListOfOwnedTokens(address owner, uint256 index, uint256 liquidityTokenId) internal {\\n\\n        // to remove an element from a list efficiently, we copy the last element in the list into the\\n        // position of the element we want to remove, and then remove the last element from the list\\n\\n        uint256 length = tokenOfOwnerByIndex[owner].length;\\n        if (length \\u003e 1) {\\n            uint256 liquidityTokenIdOfLastTokenInList = tokenOfOwnerByIndex[owner][length - 1];\\n            LiquidityToken memory lastToken = liquidityTokens[liquidityTokenIdOfLastTokenInList];\\n            lastToken.position = index;\\n            tokenOfOwnerByIndex[owner][index] = liquidityTokenIdOfLastTokenInList;\\n            liquidityTokens[liquidityTokenIdOfLastTokenInList] = lastToken;\\n        }\\n        tokenOfOwnerByIndex[owner].pop();\\n        delete liquidityTokens[liquidityTokenId];\\n    }\\n\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract INonfungiblePositionManager\",\"name\":\"nonfungiblePositionManager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"springTokenAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"summerTokenAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"autumnTokenAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"winterTokenAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wethAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityTokenId\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seasonalTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Donate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"springAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"summerAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"autumnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winterAmount\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityTokenId\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"REALLOCATION_INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REQUIRED_TICK_LOWER\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REQUIRED_TICK_UPPER\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WITHDRAWAL_AVAILABLE_DAYS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WITHDRAWAL_UNAVAILABLE_DAYS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autumnAllocationSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autumnTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityTokenId\",\"type\":\"uint256\"}],\"name\":\"canWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"cumulativeTokensFarmedPerUnitLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityTokenId\",\"type\":\"uint256\"}],\"name\":\"getPayoutSizes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityTokenId\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liquidityTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seasonalToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialCumulativeSpringTokensFarmed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialCumulativeSummerTokensFarmed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialCumulativeAutumnTokensFarmed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialCumulativeWinterTokensFarmed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityTokenId\",\"type\":\"uint256\"}],\"name\":\"nextWithdrawalTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonfungiblePositionManager\",\"outputs\":[{\"internalType\":\"contract INonfungiblePositionManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidityTokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"springAllocationSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"springTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"summerAllocationSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"summerTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winterAllocationSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"winterTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityTokenId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SeasonalTokenFarm","CompilerVersion":"v0.8.5+commit.a4f2e591","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c36442b4a4522e871399cd717abdd847ab11fe88000000000000000000000000f04af3f4e4929f7cd25a751e6149a3318373d4fe0000000000000000000000004d4f3715050571a447fffa2cd4cf091c7014ca5c0000000000000000000000004c3bae16c79c30eeb1004fb03c878d89695e3a99000000000000000000000000ccba0b2bc4babe4cbfb6bd2f1edc2a9e86b7845f000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000000000000000000000000000000000000061d4df80","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c15f99f5231ccdbc1e16cbfd5f9d49b62dfff04fc6bde1ea3ab2b043634fc13e"}]}