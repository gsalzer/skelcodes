{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-or-later\r\npragma solidity 0.7.5;\r\n\r\nlibrary SafeMath {\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  function sub(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  function div(\r\n    uint256 a,\r\n    uint256 b,\r\n    string memory errorMessage\r\n  ) internal pure returns (uint256) {\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary Address {\r\n  function isContract(address account) internal view returns (bool) {\r\n    // This method relies in extcodesize, which returns 0 for contracts in\r\n    // construction, since the code is only stored at the end of the\r\n    // constructor execution.\r\n\r\n    uint256 size;\r\n    // solhint-disable-next-line no-inline-assembly\r\n    assembly {\r\n      size := extcodesize(account)\r\n    }\r\n    return size > 0;\r\n  }\r\n\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    return _functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  function _functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 weiValue,\r\n    string memory errorMessage\r\n  ) private returns (bytes memory) {\r\n    require(isContract(target), \"Address: call to non-contract\");\r\n\r\n    // solhint-disable-next-line avoid-low-level-calls\r\n    (bool success, bytes memory returndata) = target.call{value: weiValue}(\r\n      data\r\n    );\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      if (returndata.length > 0) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n\r\n  function _verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) private pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      if (returndata.length > 0) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n          let returndata_size := mload(returndata)\r\n          revert(add(32, returndata), returndata_size)\r\n        }\r\n      } else {\r\n        revert(errorMessage);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\ninterface IOwnable {\r\n  function manager() external view returns (address);\r\n\r\n  function renounceManagement() external;\r\n\r\n  function pushManagement(address newOwner_) external;\r\n\r\n  function pullManagement() external;\r\n}\r\n\r\ncontract Ownable is IOwnable {\r\n  address internal _owner;\r\n  address internal _newOwner;\r\n\r\n  event OwnershipPushed(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n  event OwnershipPulled(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  constructor() {\r\n    _owner = msg.sender;\r\n    emit OwnershipPushed(address(0), _owner);\r\n  }\r\n\r\n  function manager() public view override returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  modifier onlyManager() {\r\n    require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  function renounceManagement() public virtual override onlyManager {\r\n    emit OwnershipPushed(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  function pushManagement(address newOwner_)\r\n    public\r\n    virtual\r\n    override\r\n    onlyManager\r\n  {\r\n    require(newOwner_ != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipPushed(_owner, newOwner_);\r\n    _newOwner = newOwner_;\r\n  }\r\n\r\n  function pullManagement() public virtual override {\r\n    require(msg.sender == _newOwner, \"Ownable: must be new owner to pull\");\r\n    emit OwnershipPulled(_owner, _newOwner);\r\n    _owner = _newOwner;\r\n  }\r\n}\r\n\r\ninterface IERC20 {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.transfer.selector, to, value)\r\n    );\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n    );\r\n  }\r\n\r\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n    bytes memory returndata = address(token).functionCall(\r\n      data,\r\n      \"SafeERC20: low-level call failed\"\r\n    );\r\n    if (returndata.length > 0) {\r\n      // Return data is optional\r\n      // solhint-disable-next-line max-line-length\r\n      require(\r\n        abi.decode(returndata, (bool)),\r\n        \"SafeERC20: ERC20 operation did not succeed\"\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\ninterface IERC20Mintable {\r\n  function mint(uint256 amount_) external;\r\n\r\n  function mint(address account_, uint256 ammount_) external;\r\n}\r\n\r\ninterface ILOBIERC20 {\r\n  function burnFrom(address account_, uint256 amount_) external;\r\n}\r\n\r\ninterface IUniswapV2ERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n}\r\n\r\ninterface IUniswapV2Pair is IUniswapV2ERC20 {\r\n  function getReserves()\r\n    external\r\n    view\r\n    returns (\r\n      uint112 reserve0,\r\n      uint112 reserve1,\r\n      uint32 blockTimestampLast\r\n    );\r\n\r\n  function token0() external view returns (address);\r\n\r\n  function token1() external view returns (address);\r\n}\r\n\r\ncontract LobisTreasury is Ownable {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  event Deposit(address indexed token, uint256 amount, uint256 value);\r\n  event Withdrawal(address indexed token, uint256 amount, uint256 value);\r\n  event CreateDebt(\r\n    address indexed debtor,\r\n    address indexed token,\r\n    uint256 amount,\r\n    uint256 value\r\n  );\r\n  event RepayDebt(\r\n    address indexed debtor,\r\n    address indexed token,\r\n    uint256 amount,\r\n    uint256 value\r\n  );\r\n  event ReservesManaged(address indexed token, uint256 amount);\r\n  event ReservesUpdated(uint256 indexed totalReserves);\r\n  event ReservesAudited(uint256 indexed totalReserves);\r\n  event RewardsMinted(\r\n    address indexed caller,\r\n    address indexed recipient,\r\n    uint256 amount\r\n  );\r\n  event ChangeQueued(MANAGING indexed managing, address queued);\r\n  event ChangeActivated(\r\n    MANAGING indexed managing,\r\n    address activated,\r\n    bool result\r\n  );\r\n\r\n  enum MANAGING {\r\n    RESERVEDEPOSITOR,\r\n    RESERVESPENDER,\r\n    RESERVETOKEN,\r\n    RESERVEMANAGER,\r\n    LIQUIDITYDEPOSITOR,\r\n    LIQUIDITYTOKEN,\r\n    LIQUIDITYMANAGER,\r\n    DEBTOR,\r\n    REWARDMANAGER,\r\n    SLOBI\r\n  }\r\n\r\n  address public immutable LOBI;\r\n  uint256 public immutable blocksNeededForQueue;\r\n\r\n  address[] public reserveTokens; // Push only, beware false-positives.\r\n  mapping(address => bool) public isReserveToken;\r\n  mapping(address => uint256) public reserveTokenQueue; // Delays changes to mapping.\r\n\r\n  address[] public reserveDepositors; // Push only, beware false-positives. Only for viewing.\r\n  mapping(address => bool) public isReserveDepositor;\r\n  mapping(address => uint256) public reserveDepositorQueue; // Delays changes to mapping.\r\n\r\n  address[] public reserveSpenders; // Push only, beware false-positives. Only for viewing.\r\n  mapping(address => bool) public isReserveSpender;\r\n  mapping(address => uint256) public reserveSpenderQueue; // Delays changes to mapping.\r\n\r\n  address[] public liquidityTokens; // Push only, beware false-positives.\r\n  mapping(address => bool) public isLiquidityToken;\r\n  mapping(address => uint256) public LiquidityTokenQueue; // Delays changes to mapping.\r\n\r\n  address[] public liquidityDepositors; // Push only, beware false-positives. Only for viewing.\r\n  mapping(address => bool) public isLiquidityDepositor;\r\n  mapping(address => uint256) public LiquidityDepositorQueue; // Delays changes to mapping.\r\n\r\n  address[] public reserveManagers; // Push only, beware false-positives. Only for viewing.\r\n  mapping(address => bool) public isReserveManager;\r\n  mapping(address => uint256) public ReserveManagerQueue; // Delays changes to mapping.\r\n\r\n  address[] public liquidityManagers; // Push only, beware false-positives. Only for viewing.\r\n  mapping(address => bool) public isLiquidityManager;\r\n  mapping(address => uint256) public LiquidityManagerQueue; // Delays changes to mapping.\r\n\r\n  address[] public debtors; // Push only, beware false-positives. Only for viewing.\r\n  mapping(address => bool) public isDebtor;\r\n  mapping(address => uint256) public debtorQueue; // Delays changes to mapping.\r\n  mapping(address => uint256) public debtorBalance;\r\n\r\n  address[] public rewardManagers; // Push only, beware false-positives. Only for viewing.\r\n  mapping(address => bool) public isRewardManager;\r\n  mapping(address => uint256) public rewardManagerQueue; // Delays changes to mapping.\r\n\r\n  mapping(address => uint256) public tokenFactors;\r\n\r\n  address public sLOBI;\r\n  uint256 public sLOBIQueue; // Delays change to sLOBI address\r\n\r\n  uint256 public totalReserves; // Risk-free value of all assets\r\n  uint256 public totalDebt;\r\n\r\n  constructor(address _LOBI, uint256 _blocksNeededForQueue) {\r\n    require(_LOBI != address(0));\r\n    LOBI = _LOBI;\r\n    blocksNeededForQueue = _blocksNeededForQueue;\r\n  }\r\n\r\n  /**\r\n        @notice allow approved address to deposit an asset for LOBI\r\n        @param _amount uint\r\n        @param _token address\r\n        @param _profit uint\r\n        @return send_ uint\r\n     */\r\n  function deposit(\r\n    uint256 _amount,\r\n    address _token,\r\n    uint256 _profit\r\n  ) external returns (uint256 send_) {\r\n    require(isReserveToken[_token] || isLiquidityToken[_token], \"Not accepted\");\r\n    IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n    if (isReserveToken[_token]) {\r\n      require(isReserveDepositor[msg.sender], \"Not approved\");\r\n    } else {\r\n      require(isLiquidityDepositor[msg.sender], \"Not approved\");\r\n    }\r\n\r\n    uint256 value = valueOfToken(_token, _amount);\r\n    // mint LOBI needed and store amount of rewards for distribution\r\n    send_ = value.sub(_profit);\r\n    IERC20Mintable(LOBI).mint(msg.sender, send_);\r\n\r\n    totalReserves = totalReserves.add(value);\r\n    emit ReservesUpdated(totalReserves);\r\n\r\n    emit Deposit(_token, _amount, value);\r\n  }\r\n\r\n  /**\r\n        @notice allow approved address to burn LOBI for reserves\r\n        @param _amount uint\r\n        @param _token address\r\n     */\r\n  function withdraw(uint256 _amount, address _token) external {\r\n    require(isReserveToken[_token], \"Not accepted\"); // Only reserves can be used for redemptions\r\n    require(isReserveSpender[msg.sender] == true, \"Not approved\");\r\n\r\n    uint256 value = valueOfToken(_token, _amount);\r\n    ILOBIERC20(LOBI).burnFrom(msg.sender, value);\r\n\r\n    totalReserves = totalReserves.sub(value);\r\n    emit ReservesUpdated(totalReserves);\r\n\r\n    IERC20(_token).safeTransfer(msg.sender, _amount);\r\n\r\n    emit Withdrawal(_token, _amount, value);\r\n  }\r\n\r\n  /**\r\n       @notice allow approved address to borrow reserves\r\n       @param _amount uint\r\n       @param _token address\r\n    */\r\n  function incurDebt(uint256 _amount, address _token) external {\r\n    require(isDebtor[msg.sender], \"Not approved\");\r\n    require(isReserveToken[_token], \"Not accepted\");\r\n\r\n    uint256 value = valueOfToken(_token, _amount);\r\n\r\n    uint256 maximumDebt = IERC20(sLOBI).balanceOf(msg.sender); // Can only borrow against sLOBI held\r\n    uint256 availableDebt = maximumDebt.sub(debtorBalance[msg.sender]);\r\n    require(value <= availableDebt, \"Exceeds debt limit\");\r\n\r\n    debtorBalance[msg.sender] = debtorBalance[msg.sender].add(value);\r\n    totalDebt = totalDebt.add(value);\r\n\r\n    totalReserves = totalReserves.sub(value);\r\n    emit ReservesUpdated(totalReserves);\r\n\r\n    IERC20(_token).transfer(msg.sender, _amount);\r\n\r\n    emit CreateDebt(msg.sender, _token, _amount, value);\r\n  }\r\n\r\n  /**\r\n        @notice allow approved address to repay borrowed reserves with reserves\r\n        @param _amount uint\r\n        @param _token address\r\n     */\r\n  function repayDebtWithReserve(uint256 _amount, address _token) external {\r\n    require(isDebtor[msg.sender], \"Not approved\");\r\n    require(isReserveToken[_token], \"Not accepted\");\r\n\r\n    IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\r\n\r\n    uint256 value = valueOfToken(_token, _amount);\r\n    debtorBalance[msg.sender] = debtorBalance[msg.sender].sub(value);\r\n    totalDebt = totalDebt.sub(value);\r\n\r\n    totalReserves = totalReserves.add(value);\r\n    emit ReservesUpdated(totalReserves);\r\n\r\n    emit RepayDebt(msg.sender, _token, _amount, value);\r\n  }\r\n\r\n  /**\r\n        @notice allow approved address to repay borrowed reserves with LOBI\r\n        @param _amount uint\r\n     */\r\n  function repayDebtWithLOBI(uint256 _amount) external {\r\n    require(isDebtor[msg.sender], \"Not approved\");\r\n\r\n    ILOBIERC20(LOBI).burnFrom(msg.sender, _amount);\r\n\r\n    debtorBalance[msg.sender] = debtorBalance[msg.sender].sub(_amount);\r\n    totalDebt = totalDebt.sub(_amount);\r\n\r\n    emit RepayDebt(msg.sender, LOBI, _amount, _amount);\r\n  }\r\n\r\n  /**\r\n        @notice allow approved address to withdraw assets\r\n        @param _token address\r\n        @param _amount uint\r\n     */\r\n  function manage(address _token, uint256 _amount) external {\r\n    if (isLiquidityToken[_token]) {\r\n      require(isLiquidityManager[msg.sender], \"Not approved\");\r\n    } else {\r\n      require(isReserveManager[msg.sender], \"Not approved\");\r\n    }\r\n\r\n    uint256 value = valueOfToken(_token, _amount);\r\n    require(value <= excessReserves(), \"Insufficient reserves\");\r\n\r\n    totalReserves = totalReserves.sub(value);\r\n    emit ReservesUpdated(totalReserves);\r\n\r\n    IERC20(_token).safeTransfer(msg.sender, _amount);\r\n\r\n    emit ReservesManaged(_token, _amount);\r\n  }\r\n\r\n  /**\r\n        @notice send epoch reward to staking contract\r\n     */\r\n  function mintRewards(address _recipient, uint256 _amount) external {\r\n    require(isRewardManager[msg.sender], \"Not approved\");\r\n    require(_amount <= excessReserves(), \"Insufficient reserves\");\r\n\r\n    IERC20Mintable(LOBI).mint(_recipient, _amount);\r\n\r\n    emit RewardsMinted(msg.sender, _recipient, _amount);\r\n  }\r\n\r\n  /**\r\n        @notice returns excess reserves not backing tokens\r\n        @return uint\r\n     */\r\n  function excessReserves() public view returns (uint256) {\r\n    return totalReserves.sub(IERC20(LOBI).totalSupply().sub(totalDebt));\r\n  }\r\n\r\n  function updateReserve(address _token, uint256 _amount) external {\r\n    require(isRewardManager[msg.sender], \"Not approved\");\r\n\r\n    if (isReserveToken[_token] || isLiquidityToken[_token]) {\r\n      totalReserves = totalReserves.add(\r\n        _amount.mul(tokenFactors[_token]).div(10000)\r\n      );\r\n    }\r\n\r\n    emit ReservesUpdated(totalReserves);\r\n  }\r\n\r\n  /**\r\n        @notice takes inventory of all tracked assets\r\n        @notice always consolidate to recognized reserves before audit\r\n     */\r\n  function auditReserves() external onlyManager {\r\n    uint256 reserves;\r\n    for (uint256 i = 0; i < reserveTokens.length; i++) {\r\n      reserves = reserves.add(\r\n        valueOfToken(\r\n          reserveTokens[i],\r\n          IERC20(reserveTokens[i]).balanceOf(address(this))\r\n        ).mul(tokenFactors[reserveTokens[i]]).div(10000)\r\n      );\r\n    }\r\n    for (uint256 i = 0; i < liquidityTokens.length; i++) {\r\n      reserves = reserves.add(\r\n        valueOfToken(\r\n          liquidityTokens[i],\r\n          IERC20(liquidityTokens[i]).balanceOf(address(this))\r\n        ).mul(tokenFactors[liquidityTokens[i]]).div(10000)\r\n      );\r\n    }\r\n    totalReserves = reserves;\r\n    emit ReservesUpdated(reserves);\r\n    emit ReservesAudited(reserves);\r\n  }\r\n\r\n  // get the amount of LOB mintable by treasury\r\n  /**\r\n        @notice returns LOBI valuation of asset\r\n        @param _token address\r\n        @param _amount uint\r\n        @return value_ uint\r\n     */\r\n  function valueOfToken(address _token, uint256 _amount)\r\n    public\r\n    view\r\n    returns (uint256 value_)\r\n  {\r\n    if (isReserveToken[_token]) {\r\n      value_ = _amount.mul(10**IERC20(LOBI).decimals()).div(\r\n        10**IERC20(_token).decimals()\r\n      );\r\n    } else if (isLiquidityToken[_token]) {\r\n      address token0 = IUniswapV2Pair(_token).token0();\r\n\r\n      (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(_token)\r\n        .getReserves();\r\n\r\n      uint256 totalSupply = IUniswapV2Pair(_token).totalSupply();\r\n      uint256 reserve = token0 == LOBI ? reserve1 : reserve0;\r\n      return _amount.mul(reserve).div(totalSupply);\r\n    }\r\n  }\r\n\r\n  /**\r\n        @notice queue address to change boolean in mapping\r\n        @param _managing MANAGING\r\n        @param _address address\r\n        @return bool\r\n     */\r\n  function queue(MANAGING _managing, address _address)\r\n    external\r\n    onlyManager\r\n    returns (bool)\r\n  {\r\n    require(_address != address(0));\r\n    if (_managing == MANAGING.RESERVEDEPOSITOR) {\r\n      // 0\r\n      reserveDepositorQueue[_address] = block.number.add(blocksNeededForQueue);\r\n    } else if (_managing == MANAGING.RESERVESPENDER) {\r\n      // 1\r\n      reserveSpenderQueue[_address] = block.number.add(blocksNeededForQueue);\r\n    } else if (_managing == MANAGING.RESERVETOKEN) {\r\n      // 2\r\n      reserveTokenQueue[_address] = block.number.add(blocksNeededForQueue);\r\n    } else if (_managing == MANAGING.RESERVEMANAGER) {\r\n      // 3\r\n      ReserveManagerQueue[_address] = block.number.add(\r\n        blocksNeededForQueue.mul(2)\r\n      );\r\n    } else if (_managing == MANAGING.LIQUIDITYDEPOSITOR) {\r\n      // 4\r\n      LiquidityDepositorQueue[_address] = block.number.add(\r\n        blocksNeededForQueue\r\n      );\r\n    } else if (_managing == MANAGING.LIQUIDITYTOKEN) {\r\n      // 5\r\n      LiquidityTokenQueue[_address] = block.number.add(blocksNeededForQueue);\r\n    } else if (_managing == MANAGING.LIQUIDITYMANAGER) {\r\n      // 6\r\n      LiquidityManagerQueue[_address] = block.number.add(\r\n        blocksNeededForQueue.mul(2)\r\n      );\r\n    } else if (_managing == MANAGING.DEBTOR) {\r\n      // 7\r\n      debtorQueue[_address] = block.number.add(blocksNeededForQueue);\r\n    } else if (_managing == MANAGING.REWARDMANAGER) {\r\n      // 8\r\n      rewardManagerQueue[_address] = block.number.add(blocksNeededForQueue);\r\n    } else if (_managing == MANAGING.SLOBI) {\r\n      // 9\r\n      sLOBIQueue = block.number.add(blocksNeededForQueue);\r\n    } else return false;\r\n\r\n    emit ChangeQueued(_managing, _address);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n        @notice verify queue then set boolean in mapping\r\n        @param _managing MANAGING\r\n        @param _address address\r\n        @return bool\r\n     */\r\n  function toggle(MANAGING _managing, address _address)\r\n    external\r\n    onlyManager\r\n    returns (bool)\r\n  {\r\n    require(_address != address(0));\r\n    bool result;\r\n    if (_managing == MANAGING.RESERVEDEPOSITOR) {\r\n      // 0\r\n      if (requirements(reserveDepositorQueue, isReserveDepositor, _address)) {\r\n        reserveDepositorQueue[_address] = 0;\r\n        if (!listContains(reserveDepositors, _address)) {\r\n          reserveDepositors.push(_address);\r\n        }\r\n      }\r\n      result = !isReserveDepositor[_address];\r\n      isReserveDepositor[_address] = result;\r\n    } else if (_managing == MANAGING.RESERVESPENDER) {\r\n      // 1\r\n      if (requirements(reserveSpenderQueue, isReserveSpender, _address)) {\r\n        reserveSpenderQueue[_address] = 0;\r\n        if (!listContains(reserveSpenders, _address)) {\r\n          reserveSpenders.push(_address);\r\n        }\r\n      }\r\n      result = !isReserveSpender[_address];\r\n      isReserveSpender[_address] = result;\r\n    } else if (_managing == MANAGING.RESERVETOKEN) {\r\n      // 2\r\n      if (requirements(reserveTokenQueue, isReserveToken, _address)) {\r\n        reserveTokenQueue[_address] = 0;\r\n        if (!listContains(reserveTokens, _address)) {\r\n          reserveTokens.push(_address);\r\n        }\r\n      }\r\n      result = !isReserveToken[_address];\r\n      isReserveToken[_address] = result;\r\n      tokenFactors[_address] = 10000;\r\n    } else if (_managing == MANAGING.RESERVEMANAGER) {\r\n      // 3\r\n      if (requirements(ReserveManagerQueue, isReserveManager, _address)) {\r\n        reserveManagers.push(_address);\r\n        ReserveManagerQueue[_address] = 0;\r\n        if (!listContains(reserveManagers, _address)) {\r\n          reserveManagers.push(_address);\r\n        }\r\n      }\r\n      result = !isReserveManager[_address];\r\n      isReserveManager[_address] = result;\r\n    } else if (_managing == MANAGING.LIQUIDITYDEPOSITOR) {\r\n      // 4\r\n      if (\r\n        requirements(LiquidityDepositorQueue, isLiquidityDepositor, _address)\r\n      ) {\r\n        liquidityDepositors.push(_address);\r\n        LiquidityDepositorQueue[_address] = 0;\r\n        if (!listContains(liquidityDepositors, _address)) {\r\n          liquidityDepositors.push(_address);\r\n        }\r\n      }\r\n      result = !isLiquidityDepositor[_address];\r\n      isLiquidityDepositor[_address] = result;\r\n    } else if (_managing == MANAGING.LIQUIDITYTOKEN) {\r\n      // 5\r\n      if (requirements(LiquidityTokenQueue, isLiquidityToken, _address)) {\r\n        LiquidityTokenQueue[_address] = 0;\r\n        if (!listContains(liquidityTokens, _address)) {\r\n          liquidityTokens.push(_address);\r\n        }\r\n      }\r\n      result = !isLiquidityToken[_address];\r\n      isLiquidityToken[_address] = result;\r\n      tokenFactors[_address] = 10000;\r\n    } else if (_managing == MANAGING.LIQUIDITYMANAGER) {\r\n      // 6\r\n      if (requirements(LiquidityManagerQueue, isLiquidityManager, _address)) {\r\n        LiquidityManagerQueue[_address] = 0;\r\n        if (!listContains(liquidityManagers, _address)) {\r\n          liquidityManagers.push(_address);\r\n        }\r\n      }\r\n      result = !isLiquidityManager[_address];\r\n      isLiquidityManager[_address] = result;\r\n    } else if (_managing == MANAGING.DEBTOR) {\r\n      // 7\r\n      if (requirements(debtorQueue, isDebtor, _address)) {\r\n        debtorQueue[_address] = 0;\r\n        if (!listContains(debtors, _address)) {\r\n          debtors.push(_address);\r\n        }\r\n      }\r\n      result = !isDebtor[_address];\r\n      isDebtor[_address] = result;\r\n    } else if (_managing == MANAGING.REWARDMANAGER) {\r\n      // 8\r\n      if (requirements(rewardManagerQueue, isRewardManager, _address)) {\r\n        rewardManagerQueue[_address] = 0;\r\n        if (!listContains(rewardManagers, _address)) {\r\n          rewardManagers.push(_address);\r\n        }\r\n      }\r\n      result = !isRewardManager[_address];\r\n      isRewardManager[_address] = result;\r\n    } else if (_managing == MANAGING.SLOBI) {\r\n      // 9\r\n      sLOBIQueue = 0;\r\n      sLOBI = _address;\r\n      result = true;\r\n    } else return false;\r\n\r\n    emit ChangeActivated(_managing, _address, result);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n        @notice checks requirements and returns altered structs\r\n        @param queue_ mapping( address => uint )\r\n        @param status_ mapping( address => bool )\r\n        @param _address address\r\n        @return bool \r\n     */\r\n  function requirements(\r\n    mapping(address => uint256) storage queue_,\r\n    mapping(address => bool) storage status_,\r\n    address _address\r\n  ) internal view returns (bool) {\r\n    if (!status_[_address]) {\r\n      require(queue_[_address] != 0, \"Must queue\");\r\n      require(queue_[_address] <= block.number, \"Queue not expired\");\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n        @notice checks array to ensure against duplicate\r\n        @param _list address[]\r\n        @param _token address\r\n        @return bool\r\n     */\r\n  function listContains(address[] storage _list, address _token)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    for (uint256 i = 0; i < _list.length; i++) {\r\n      if (_list[i] == _token) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function setTokenFactor(address _token, uint256 _factor)\r\n    external\r\n    onlyManager\r\n  {\r\n    tokenFactors[_token] = _factor;\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_LOBI\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blocksNeededForQueue\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum LobisTreasury.MANAGING\",\"name\":\"managing\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"activated\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"name\":\"ChangeActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum LobisTreasury.MANAGING\",\"name\":\"managing\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"queued\",\"type\":\"address\"}],\"name\":\"ChangeQueued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"debtor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"CreateDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipPulled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipPushed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"debtor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RepayDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"totalReserves\",\"type\":\"uint256\"}],\"name\":\"ReservesAudited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReservesManaged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"totalReserves\",\"type\":\"uint256\"}],\"name\":\"ReservesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LOBI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"LiquidityDepositorQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"LiquidityManagerQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"LiquidityTokenQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ReserveManagerQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auditReserves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blocksNeededForQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"debtorBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"debtorQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"debtors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_profit\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"send_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"excessReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"incurDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isDebtor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLiquidityDepositor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLiquidityManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isLiquidityToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isReserveDepositor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isReserveManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isReserveSpender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isReserveToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isRewardManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liquidityDepositors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liquidityManagers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liquidityTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"manage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pullManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"pushManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum LobisTreasury.MANAGING\",\"name\":\"_managing\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"queue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"repayDebtWithLOBI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"repayDebtWithReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reserveDepositorQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reserveDepositors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reserveManagers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reserveSpenderQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reserveSpenders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"reserveTokenQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reserveTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardManagerQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardManagers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sLOBI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sLOBIQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_factor\",\"type\":\"uint256\"}],\"name\":\"setTokenFactor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum LobisTreasury.MANAGING\",\"name\":\"_managing\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"toggle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenFactors\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"valueOfToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LobisTreasury","CompilerVersion":"v0.7.5+commit.eb77ed08","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000dec41db0c33f3f6f3cb615449c311ba22d418a8d0000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f6833e2f8ae9bb472b6d3feff0a4766a2a41249e5c6ee30fd6dd0105f885db27"}]}