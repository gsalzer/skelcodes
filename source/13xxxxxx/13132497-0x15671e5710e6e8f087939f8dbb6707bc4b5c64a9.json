{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/claims/ClaimsReward.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../abstract/LegacyMasterAware.sol\\\";\\nimport \\\"../../interfaces/IClaims.sol\\\";\\nimport \\\"../../interfaces/IClaimsData.sol\\\";\\nimport \\\"../../interfaces/IClaimsReward.sol\\\";\\nimport \\\"../../interfaces/IGovernance.sol\\\";\\nimport \\\"../../interfaces/IMCR.sol\\\";\\nimport \\\"../../interfaces/IMemberRoles.sol\\\";\\nimport \\\"../../interfaces/INXMToken.sol\\\";\\nimport \\\"../../interfaces/IPool.sol\\\";\\nimport \\\"../../interfaces/IPooledStaking.sol\\\";\\nimport \\\"../../interfaces/IQuotationData.sol\\\";\\nimport \\\"../../interfaces/ITokenController.sol\\\";\\nimport \\\"../../interfaces/ITokenData.sol\\\";\\n\\n//Claims Reward Contract contains the functions for calculating number of tokens\\n// that will get rewarded, unlocked or burned depending upon the status of claim.\\n\\ncontract ClaimsReward is IClaimsReward, LegacyMasterAware {\\n  using SafeMath for uint;\\n\\n  INXMToken internal tk;\\n  ITokenController internal tc;\\n  ITokenData internal td;\\n  IQuotationData internal qd;\\n  IClaims internal c1;\\n  IClaimsData internal cd;\\n  IPool internal pool;\\n  IGovernance internal gv;\\n  IPooledStaking internal pooledStaking;\\n  IMemberRoles internal memberRoles;\\n  IMCR public mcr;\\n\\n  // assigned in constructor\\n  address public DAI;\\n\\n  // constants\\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n  uint private constant DECIMAL1E18 = uint(10) ** 18;\\n\\n  constructor (address masterAddress, address _daiAddress) public {\\n    changeMasterAddress(masterAddress);\\n    DAI = _daiAddress;\\n  }\\n\\n  function changeDependentContractAddress() public onlyInternal {\\n    c1 = IClaims(ms.getLatestAddress(\\\"CL\\\"));\\n    cd = IClaimsData(ms.getLatestAddress(\\\"CD\\\"));\\n    tk = INXMToken(ms.tokenAddress());\\n    tc = ITokenController(ms.getLatestAddress(\\\"TC\\\"));\\n    td = ITokenData(ms.getLatestAddress(\\\"TD\\\"));\\n    qd = IQuotationData(ms.getLatestAddress(\\\"QD\\\"));\\n    gv = IGovernance(ms.getLatestAddress(\\\"GV\\\"));\\n    pooledStaking = IPooledStaking(ms.getLatestAddress(\\\"PS\\\"));\\n    memberRoles = IMemberRoles(ms.getLatestAddress(\\\"MR\\\"));\\n    pool = IPool(ms.getLatestAddress(\\\"P1\\\"));\\n    mcr = IMCR(ms.getLatestAddress(\\\"MC\\\"));\\n  }\\n\\n  /**\\n   * @dev Claims are closable by anyone\\n   * @param _claimId id of claim to be closed.\\n   */\\n  function closeClaim(uint _claimId) external {\\n\\n    (, , , uint status, uint dateUpd,) = cd.getClaim(_claimId);\\n    bool canRetryPayout = status != 12 || dateUpd.add(cd.payoutRetryTime()) < block.timestamp;\\n    require(canRetryPayout, \\\"ClaimsReward: Payout retry time not reached.\\\");\\n\\n    _changeClaimStatus(_claimId);\\n  }\\n\\n  function changeClaimStatus(uint claimId) public checkPause onlyInternal {\\n    _changeClaimStatus(claimId);\\n  }\\n\\n  /// @dev Decides the next course of action for a given claim.\\n  function _changeClaimStatus(uint claimId) internal {\\n\\n    (, uint coverid) = cd.getClaimCoverId(claimId);\\n    (, uint status) = cd.getClaimStatusNumber(claimId);\\n\\n    // when current status is \\\"Pending-Claim Assessor Vote\\\"\\n    if (status == 0) {\\n      _changeClaimStatusCA(claimId, coverid, status);\\n    } else if (status >= 1 && status <= 5) {\\n      _changeClaimStatusMV(claimId, coverid, status);\\n    } else if (status == 12) {// when current status is \\\"Claim Accepted Payout Pending\\\"\\n\\n      bool payoutSucceeded = attemptClaimPayout(coverid);\\n\\n      if (payoutSucceeded) {\\n        c1.setClaimStatus(claimId, 14);\\n      } else {\\n        c1.setClaimStatus(claimId, 12);\\n      }\\n    }\\n  }\\n\\n  function getCurrencyAssetAddress(bytes4 currency) public view returns (address) {\\n\\n    if (currency == \\\"ETH\\\") {\\n      return ETH;\\n    }\\n\\n    if (currency == \\\"DAI\\\") {\\n      return DAI;\\n    }\\n\\n    revert(\\\"ClaimsReward: unknown asset\\\");\\n  }\\n\\n  function attemptClaimPayout(uint coverId) internal returns (bool success) {\\n\\n    uint sumAssured = qd.getCoverSumAssured(coverId);\\n    // TODO: when adding new cover currencies, fetch the correct decimals for this multiplication\\n    uint sumAssuredWei = sumAssured.mul(1e18);\\n\\n    // get asset address\\n    bytes4 coverCurrency = qd.getCurrencyOfCover(coverId);\\n    address asset = getCurrencyAssetAddress(coverCurrency);\\n\\n    // get payout address\\n    address payable coverHolder = qd.getCoverMemberAddress(coverId);\\n    address payable payoutAddress = memberRoles.getClaimPayoutAddress(coverHolder);\\n\\n    // execute the payout\\n    bool payoutSucceeded = pool.sendClaimPayout(asset, payoutAddress, sumAssuredWei);\\n\\n    if (payoutSucceeded) {\\n\\n      // burn staked tokens\\n      (, address scAddress) = qd.getscAddressOfCover(coverId);\\n      uint tokenPrice = pool.getTokenPrice(asset);\\n\\n      // note: for new assets \\\"18\\\" needs to be replaced with target asset decimals\\n      uint burnNXMAmount = sumAssuredWei.mul(1e18).div(tokenPrice);\\n      pooledStaking.pushBurn(scAddress, burnNXMAmount);\\n\\n      // adjust total sum assured\\n      (, address coverContract) = qd.getscAddressOfCover(coverId);\\n      qd.subFromTotalSumAssured(coverCurrency, sumAssured);\\n      qd.subFromTotalSumAssuredSC(coverContract, coverCurrency, sumAssured);\\n\\n      // update MCR since total sum assured and MCR% change\\n      mcr.updateMCRInternal(pool.getPoolValueInEth(), true);\\n      return true;\\n    }\\n\\n    return false;\\n  }\\n\\n  /// @dev Amount of tokens to be rewarded to a user for a particular vote id.\\n  /// @param check 1 -> CA vote, else member vote\\n  /// @param voteid vote id for which reward has to be Calculated\\n  /// @param flag if 1 calculate even if claimed,else don't calculate if already claimed\\n  /// @return tokenCalculated reward to be given for vote id\\n  /// @return lastClaimedCheck true if final verdict is still pending for that voteid\\n  /// @return tokens number of tokens locked under that voteid\\n  /// @return perc percentage of reward to be given.\\n  function getRewardToBeGiven(\\n    uint check,\\n    uint voteid,\\n    uint flag\\n  )\\n  public\\n  view\\n  returns (\\n    uint tokenCalculated,\\n    bool lastClaimedCheck,\\n    uint tokens,\\n    uint perc\\n  )\\n\\n  {\\n    uint claimId;\\n    int8 verdict;\\n    bool claimed;\\n    uint tokensToBeDist;\\n    uint totalTokens;\\n    (tokens, claimId, verdict, claimed) = cd.getVoteDetails(voteid);\\n    lastClaimedCheck = false;\\n    int8 claimVerdict = cd.getFinalVerdict(claimId);\\n    if (claimVerdict == 0) {\\n      lastClaimedCheck = true;\\n    }\\n\\n    if (claimVerdict == verdict && (claimed == false || flag == 1)) {\\n\\n      if (check == 1) {\\n        (perc, , tokensToBeDist) = cd.getClaimRewardDetail(claimId);\\n      } else {\\n        (, perc, tokensToBeDist) = cd.getClaimRewardDetail(claimId);\\n      }\\n\\n      if (perc > 0) {\\n        if (check == 1) {\\n          if (verdict == 1) {\\n            (, totalTokens,) = cd.getClaimsTokenCA(claimId);\\n          } else {\\n            (,, totalTokens) = cd.getClaimsTokenCA(claimId);\\n          }\\n        } else {\\n          if (verdict == 1) {\\n            (, totalTokens,) = cd.getClaimsTokenMV(claimId);\\n          } else {\\n            (,, totalTokens) = cd.getClaimsTokenMV(claimId);\\n          }\\n        }\\n        tokenCalculated = (perc.mul(tokens).mul(tokensToBeDist)).div(totalTokens.mul(100));\\n\\n\\n      }\\n    }\\n  }\\n\\n  /// @dev Transfers all tokens held by contract to a new contract in case of upgrade.\\n  function upgrade(address _newAdd) public onlyInternal {\\n    uint amount = tk.balanceOf(address(this));\\n    if (amount > 0) {\\n      require(tk.transfer(_newAdd, amount));\\n    }\\n\\n  }\\n\\n  /// @dev Total reward in token due for claim by a user.\\n  /// @return total total number of tokens\\n  function getRewardToBeDistributedByUser(address _add) public view returns (uint total) {\\n    uint lengthVote = cd.getVoteAddressCALength(_add);\\n    uint lastIndexCA;\\n    uint lastIndexMV;\\n    uint tokenForVoteId;\\n    uint voteId;\\n    (lastIndexCA, lastIndexMV) = cd.getRewardDistributedIndex(_add);\\n\\n    for (uint i = lastIndexCA; i < lengthVote; i++) {\\n      voteId = cd.getVoteAddressCA(_add, i);\\n      (tokenForVoteId,,,) = getRewardToBeGiven(1, voteId, 0);\\n      total = total.add(tokenForVoteId);\\n    }\\n\\n    lengthVote = cd.getVoteAddressMemberLength(_add);\\n\\n    for (uint j = lastIndexMV; j < lengthVote; j++) {\\n      voteId = cd.getVoteAddressMember(_add, j);\\n      (tokenForVoteId,,,) = getRewardToBeGiven(0, voteId, 0);\\n      total = total.add(tokenForVoteId);\\n    }\\n    return (total);\\n  }\\n\\n  /// @dev Gets reward amount and claiming status for a given claim id.\\n  /// @return reward amount of tokens to user.\\n  /// @return claimed true if already claimed false if yet to be claimed.\\n  function getRewardAndClaimedStatus(uint check, uint claimId) public view returns (uint reward, bool claimed) {\\n    uint voteId;\\n    uint claimid;\\n    uint lengthVote;\\n\\n    if (check == 1) {\\n      lengthVote = cd.getVoteAddressCALength(msg.sender);\\n      for (uint i = 0; i < lengthVote; i++) {\\n        voteId = cd.getVoteAddressCA(msg.sender, i);\\n        (, claimid, , claimed) = cd.getVoteDetails(voteId);\\n        if (claimid == claimId) {break;}\\n      }\\n    } else {\\n      lengthVote = cd.getVoteAddressMemberLength(msg.sender);\\n      for (uint j = 0; j < lengthVote; j++) {\\n        voteId = cd.getVoteAddressMember(msg.sender, j);\\n        (, claimid, , claimed) = cd.getVoteDetails(voteId);\\n        if (claimid == claimId) {break;}\\n      }\\n    }\\n    (reward,,,) = getRewardToBeGiven(check, voteId, 1);\\n\\n  }\\n\\n  /**\\n   * @dev Function used to claim all pending rewards : Claims Assessment + Risk Assessment + Governance\\n   * Claim assesment, Risk assesment, Governance rewards\\n   */\\n  function claimAllPendingReward(uint records) public isMemberAndcheckPause {\\n    _claimRewardToBeDistributed(records);\\n    pooledStaking.withdrawReward(msg.sender);\\n    uint governanceRewards = gv.claimReward(msg.sender, records);\\n    if (governanceRewards > 0) {\\n      require(tk.transfer(msg.sender, governanceRewards));\\n    }\\n  }\\n\\n  /**\\n   * @dev Function used to get pending rewards of a particular user address.\\n   * @param _add user address.\\n   * @return total reward amount of the user\\n   */\\n  function getAllPendingRewardOfUser(address _add) public view returns (uint) {\\n    uint caReward = getRewardToBeDistributedByUser(_add);\\n    uint pooledStakingReward = pooledStaking.stakerReward(_add);\\n    uint governanceReward = gv.getPendingReward(_add);\\n    return caReward.add(pooledStakingReward).add(governanceReward);\\n  }\\n\\n  /// @dev Rewards/Punishes users who  participated in Claims assessment.\\n  //    Unlocking and burning of the tokens will also depend upon the status of claim.\\n  /// @param claimid Claim Id.\\n  function _rewardAgainstClaim(uint claimid, uint coverid, uint status) internal {\\n\\n    uint premiumNXM = qd.getCoverPremiumNXM(coverid);\\n    uint distributableTokens = premiumNXM.mul(cd.claimRewardPerc()).div(100); // 20% of premium\\n\\n    uint percCA;\\n    uint percMV;\\n\\n    (percCA, percMV) = cd.getRewardStatus(status);\\n    cd.setClaimRewardDetail(claimid, percCA, percMV, distributableTokens);\\n\\n    if (percCA > 0 || percMV > 0) {\\n      tc.mint(address(this), distributableTokens);\\n    }\\n\\n    // denied\\n    if (status == 6 || status == 9 || status == 11) {\\n\\n      cd.changeFinalVerdict(claimid, -1);\\n      tc.markCoverClaimClosed(coverid, false);\\n      _burnCoverNoteDeposit(coverid);\\n\\n    // accepted\\n    } else if (status == 7 || status == 8 || status == 10) {\\n\\n      cd.changeFinalVerdict(claimid, 1);\\n      tc.markCoverClaimClosed(coverid, true);\\n      _unlockCoverNote(coverid);\\n\\n      bool payoutSucceeded = attemptClaimPayout(coverid);\\n\\n      // 12 = payout pending, 14 = payout succeeded\\n      uint nextStatus = payoutSucceeded ? 14 : 12;\\n      c1.setClaimStatus(claimid, nextStatus);\\n    }\\n  }\\n\\n  function _burnCoverNoteDeposit(uint coverId) internal {\\n\\n    address _of = qd.getCoverMemberAddress(coverId);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", _of, coverId));\\n    uint lockedAmount = tc.tokensLocked(_of, reason);\\n\\n    (uint amount,) = td.depositedCN(coverId);\\n    amount = amount.div(2);\\n\\n    // limit burn amount to actual amount locked\\n    uint burnAmount = lockedAmount < amount ? lockedAmount : amount;\\n\\n    if (burnAmount != 0) {\\n      tc.burnLockedTokens(_of, reason, amount);\\n    }\\n  }\\n\\n  function unlockCoverNote(uint coverId) external onlyInternal {\\n    _unlockCoverNote(coverId);\\n  }\\n\\n  function _unlockCoverNote(uint coverId) internal {\\n\\n    address coverHolder = qd.getCoverMemberAddress(coverId);\\n    bytes32 reason = keccak256(abi.encodePacked(\\\"CN\\\", coverHolder, coverId));\\n    uint lockedCN = tc.tokensLocked(coverHolder, reason);\\n\\n    if (lockedCN != 0) {\\n      tc.releaseLockedTokens(coverHolder, reason, lockedCN);\\n    }\\n  }\\n\\n  /// @dev Computes the result of Claim Assessors Voting for a given claim id.\\n  function _changeClaimStatusCA(uint claimid, uint coverid, uint status) internal {\\n    // Check if voting should be closed or not\\n    if (c1.checkVoteClosing(claimid) == 1) {\\n      uint caTokens = c1.getCATokens(claimid, 0); // converted in cover currency.\\n      uint accept;\\n      uint deny;\\n      uint acceptAndDeny;\\n      bool rewardOrPunish;\\n      uint sumAssured;\\n      (, accept) = cd.getClaimVote(claimid, 1);\\n      (, deny) = cd.getClaimVote(claimid, - 1);\\n      acceptAndDeny = accept.add(deny);\\n      accept = accept.mul(100);\\n      deny = deny.mul(100);\\n\\n      if (caTokens == 0) {\\n        status = 3;\\n      } else {\\n        sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\\n        // Min threshold reached tokens used for voting > 5* sum assured\\n        if (caTokens > sumAssured.mul(5)) {\\n\\n          if (accept.div(acceptAndDeny) > 70) {\\n            status = 7;\\n            qd.changeCoverStatusNo(coverid, uint8(IQuotationData.CoverStatus.ClaimAccepted));\\n            rewardOrPunish = true;\\n          } else if (deny.div(acceptAndDeny) > 70) {\\n            status = 6;\\n            qd.changeCoverStatusNo(coverid, uint8(IQuotationData.CoverStatus.ClaimDenied));\\n            rewardOrPunish = true;\\n          } else if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {\\n            status = 4;\\n          } else {\\n            status = 5;\\n          }\\n\\n        } else {\\n\\n          if (accept.div(acceptAndDeny) > deny.div(acceptAndDeny)) {\\n            status = 2;\\n          } else {\\n            status = 3;\\n          }\\n        }\\n      }\\n\\n      c1.setClaimStatus(claimid, status);\\n\\n      if (rewardOrPunish) {\\n        _rewardAgainstClaim(claimid, coverid, status);\\n      }\\n    }\\n  }\\n\\n  /// @dev Computes the result of Member Voting for a given claim id.\\n  function _changeClaimStatusMV(uint claimid, uint coverid, uint status) internal {\\n\\n    // Check if voting should be closed or not\\n    if (c1.checkVoteClosing(claimid) == 1) {\\n      uint8 coverStatus;\\n      uint statusOrig = status;\\n      uint mvTokens = c1.getCATokens(claimid, 1); // converted in cover currency.\\n\\n      // If tokens used for acceptance >50%, claim is accepted\\n      uint sumAssured = qd.getCoverSumAssured(coverid).mul(DECIMAL1E18);\\n      uint thresholdUnreached = 0;\\n      // Minimum threshold for member voting is reached only when\\n      // value of tokens used for voting > 5* sum assured of claim id\\n      if (mvTokens < sumAssured.mul(5)) {\\n        thresholdUnreached = 1;\\n      }\\n\\n      uint accept;\\n      (, accept) = cd.getClaimMVote(claimid, 1);\\n      uint deny;\\n      (, deny) = cd.getClaimMVote(claimid, - 1);\\n\\n      if (accept.add(deny) > 0) {\\n        if (accept.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 &&\\n        statusOrig <= 5 && thresholdUnreached == 0) {\\n          status = 8;\\n          coverStatus = uint8(IQuotationData.CoverStatus.ClaimAccepted);\\n        } else if (deny.mul(100).div(accept.add(deny)) >= 50 && statusOrig > 1 &&\\n        statusOrig <= 5 && thresholdUnreached == 0) {\\n          status = 9;\\n          coverStatus = uint8(IQuotationData.CoverStatus.ClaimDenied);\\n        }\\n      }\\n\\n      if (thresholdUnreached == 1 && (statusOrig == 2 || statusOrig == 4)) {\\n        status = 10;\\n        coverStatus = uint8(IQuotationData.CoverStatus.ClaimAccepted);\\n      } else if (thresholdUnreached == 1 && (statusOrig == 5 || statusOrig == 3 || statusOrig == 1)) {\\n        status = 11;\\n        coverStatus = uint8(IQuotationData.CoverStatus.ClaimDenied);\\n      }\\n\\n      c1.setClaimStatus(claimid, status);\\n      qd.changeCoverStatusNo(coverid, uint8(coverStatus));\\n      // Reward/Punish Claim Assessors and Members who participated in Claims assessment\\n      _rewardAgainstClaim(claimid, coverid, status);\\n    }\\n  }\\n\\n  /// @dev Allows a user to claim all pending  Claims assessment rewards.\\n  function _claimRewardToBeDistributed(uint _records) internal {\\n    uint lengthVote = cd.getVoteAddressCALength(msg.sender);\\n    uint voteid;\\n    uint lastIndex;\\n    (lastIndex,) = cd.getRewardDistributedIndex(msg.sender);\\n    uint total = 0;\\n    uint tokenForVoteId = 0;\\n    bool lastClaimedCheck;\\n    uint _days = td.lockCADays();\\n    bool claimed;\\n    uint counter = 0;\\n    uint claimId;\\n    uint perc;\\n    uint i;\\n    uint lastClaimed = lengthVote;\\n\\n    for (i = lastIndex; i < lengthVote && counter < _records; i++) {\\n      voteid = cd.getVoteAddressCA(msg.sender, i);\\n      (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\\n      if (lastClaimed == lengthVote && lastClaimedCheck == true) {\\n        lastClaimed = i;\\n      }\\n      (, claimId, , claimed) = cd.getVoteDetails(voteid);\\n\\n      if (perc > 0 && !claimed) {\\n        counter++;\\n        cd.setRewardClaimed(voteid, true);\\n      } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\\n        (perc,,) = cd.getClaimRewardDetail(claimId);\\n        if (perc == 0) {\\n          counter++;\\n        }\\n        cd.setRewardClaimed(voteid, true);\\n      }\\n      if (tokenForVoteId > 0) {\\n        total = tokenForVoteId.add(total);\\n      }\\n    }\\n    if (lastClaimed == lengthVote) {\\n      cd.setRewardDistributedIndexCA(msg.sender, i);\\n    }\\n    else {\\n      cd.setRewardDistributedIndexCA(msg.sender, lastClaimed);\\n    }\\n    lengthVote = cd.getVoteAddressMemberLength(msg.sender);\\n    lastClaimed = lengthVote;\\n    _days = _days.mul(counter);\\n    if (tc.tokensLockedAtTime(msg.sender, \\\"CLA\\\", now) > 0) {\\n      tc.reduceLock(msg.sender, \\\"CLA\\\", _days);\\n    }\\n    (, lastIndex) = cd.getRewardDistributedIndex(msg.sender);\\n    lastClaimed = lengthVote;\\n    counter = 0;\\n    for (i = lastIndex; i < lengthVote && counter < _records; i++) {\\n      voteid = cd.getVoteAddressMember(msg.sender, i);\\n      (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\\n      if (lastClaimed == lengthVote && lastClaimedCheck == true) {\\n        lastClaimed = i;\\n      }\\n      (, claimId, , claimed) = cd.getVoteDetails(voteid);\\n      if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\\n        cd.setRewardClaimed(voteid, true);\\n        counter++;\\n      }\\n      if (tokenForVoteId > 0) {\\n        total = tokenForVoteId.add(total);\\n      }\\n    }\\n    if (total > 0) {\\n      require(tk.transfer(msg.sender, total));\\n    }\\n    if (lastClaimed == lengthVote) {\\n      cd.setRewardDistributedIndexMV(msg.sender, i);\\n    }\\n    else {\\n      cd.setRewardDistributedIndexMV(msg.sender, lastClaimed);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/LegacyMasterAware.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"../interfaces/INXMMaster.sol\\\";\\n\\ncontract LegacyMasterAware {\\n\\n  INXMMaster public ms;\\n  address public nxMasterAddress;\\n\\n  modifier onlyInternal {\\n    require(ms.isInternal(msg.sender));\\n    _;\\n  }\\n\\n  modifier isMemberAndcheckPause {\\n    require(ms.isPause() == false && ms.isMember(msg.sender) == true);\\n    _;\\n  }\\n\\n  modifier onlyOwner {\\n    require(ms.isOwner(msg.sender));\\n    _;\\n  }\\n\\n  modifier checkPause {\\n    require(ms.isPause() == false);\\n    _;\\n  }\\n\\n  modifier isMember {\\n    require(ms.isMember(msg.sender), \\\"Not member\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public;\\n\\n  /**\\n   * @dev change master address\\n   * @param _masterAddress is the new address\\n   */\\n  function changeMasterAddress(address _masterAddress) public {\\n    if (address(ms) != address(0)) {\\n      require(address(ms) == msg.sender, \\\"Not master\\\");\\n    }\\n\\n    ms = INXMMaster(_masterAddress);\\n    nxMasterAddress = _masterAddress;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IClaims.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IClaims {\\n\\n  function setClaimStatus(uint claimId, uint stat) external;\\n\\n  function getCATokens(uint claimId, uint member) external view returns (uint tokens);\\n\\n  function submitClaim(uint coverId) external;\\n\\n  function submitClaimForMember(uint coverId, address member) external;\\n\\n  function submitClaimAfterEPOff() external pure;\\n\\n  function submitCAVote(uint claimId, int8 verdict) external;\\n\\n  function submitMemberVote(uint claimId, int8 verdict) external;\\n\\n  function pauseAllPendingClaimsVoting() external pure;\\n\\n  function startAllPendingClaimsVoting() external pure;\\n\\n  function checkVoteClosing(uint claimId) external view returns (int8 close);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IClaimsData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IClaimsData {\\n\\n  function pendingClaimStart() external view returns (uint);\\n  function claimDepositTime() external view returns (uint);\\n  function maxVotingTime() external view returns (uint);\\n  function minVotingTime() external view returns (uint);\\n  function payoutRetryTime() external view returns (uint);\\n  function claimRewardPerc() external view returns (uint);\\n  function minVoteThreshold() external view returns (uint);\\n  function maxVoteThreshold() external view returns (uint);\\n  function majorityConsensus() external view returns (uint);\\n  function pauseDaysCA() external view returns (uint);\\n\\n  function userClaimVotePausedOn(address) external view returns (uint);\\n\\n  function setpendingClaimStart(uint _start) external;\\n\\n  function setRewardDistributedIndexCA(address _voter, uint caIndex) external;\\n\\n  function setUserClaimVotePausedOn(address user) external;\\n\\n  function setRewardDistributedIndexMV(address _voter, uint mvIndex) external;\\n\\n\\n  function setClaimRewardDetail(\\n    uint claimid,\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  ) external;\\n\\n  function setRewardClaimed(uint _voteid, bool claimed) external;\\n\\n  function changeFinalVerdict(uint _claimId, int8 _verdict) external;\\n\\n  function addClaim(\\n    uint _claimId,\\n    uint _coverId,\\n    address _from,\\n    uint _nowtime\\n  ) external;\\n\\n  function addVote(\\n    address _voter,\\n    uint _tokens,\\n    uint claimId,\\n    int8 _verdict\\n  ) external;\\n\\n  function addClaimVoteCA(uint _claimId, uint _voteid) external;\\n\\n  function setUserClaimVoteCA(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  ) external;\\n\\n  function setClaimTokensCA(uint _claimId, int8 _vote, uint _tokens) external;\\n\\n  function setClaimTokensMV(uint _claimId, int8 _vote, uint _tokens) external;\\n\\n  function addClaimVotemember(uint _claimId, uint _voteid) external;\\n\\n  function setUserClaimVoteMember(\\n    address _from,\\n    uint _claimId,\\n    uint _voteid\\n  ) external;\\n\\n  function updateState12Count(uint _claimId, uint _cnt) external;\\n\\n  function setClaimStatus(uint _claimId, uint _stat) external;\\n\\n  function setClaimdateUpd(uint _claimId, uint _dateUpd) external;\\n\\n  function setClaimAtEmergencyPause(\\n    uint _coverId,\\n    uint _dateUpd,\\n    bool _submit\\n  ) external;\\n\\n  function setClaimSubmittedAtEPTrue(uint _index, bool _submit) external;\\n\\n\\n  function setFirstClaimIndexToSubmitAfterEP(\\n    uint _firstClaimIndexToSubmit\\n  ) external;\\n\\n\\n  function setPendingClaimDetails(\\n    uint _claimId,\\n    uint _pendingTime,\\n    bool _voting\\n  ) external;\\n\\n  function setPendingClaimVoteStatus(uint _claimId, bool _vote) external;\\n\\n  function setFirstClaimIndexToStartVotingAfterEP(\\n    uint _claimStartVotingFirstIndex\\n  ) external;\\n\\n  function callVoteEvent(\\n    address _userAddress,\\n    uint _claimId,\\n    bytes4 _typeOf,\\n    uint _tokens,\\n    uint _submitDate,\\n    int8 _verdict\\n  ) external;\\n\\n  function callClaimEvent(\\n    uint _coverId,\\n    address _userAddress,\\n    uint _claimId,\\n    uint _datesubmit\\n  ) external;\\n\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val);\\n\\n  function getClaimOfEmergencyPauseByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    uint dateUpd,\\n    bool submit\\n  );\\n\\n  function getAllClaimsByIndex(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  );\\n\\n  function getUserClaimVoteCA(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote);\\n\\n  function getUserClaimVoteMember(\\n    address _add,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint idVote);\\n\\n  function getAllVoteLength() external view returns (uint voteCount);\\n\\n  function getClaimStatusNumber(uint _claimId) external view returns (uint claimId, uint statno);\\n\\n  function getRewardStatus(uint statusNumber) external view returns (uint percCA, uint percMV);\\n\\n  function getClaimState12Count(uint _claimId) external view returns (uint num);\\n\\n  function getClaimDateUpd(uint _claimId) external view returns (uint dateupd);\\n\\n  function getAllClaimsByAddress(address _member) external view returns (uint[] memory claimarr);\\n\\n\\n  function getClaimsTokenCA(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  );\\n\\n  function getClaimsTokenMV(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint accept,\\n    uint deny\\n  );\\n  function getCaClaimVotesToken(uint _claimId) external view returns (uint claimId, uint cnt);\\n\\n  function getMemberClaimVotesToken(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint cnt);\\n\\n  function getVoteDetails(uint _voteid)\\n  external view\\n  returns (\\n    uint tokens,\\n    uint claimId,\\n    int8 verdict,\\n    bool rewardClaimed\\n  );\\n\\n  function getVoterVote(uint _voteid) external view returns (address voter);\\n\\n  function getClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint coverId,\\n    int8 vote,\\n    uint status,\\n    uint dateUpd,\\n    uint state12Count\\n  );\\n\\n  function getClaimVoteLength(\\n    uint _claimId,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint claimId, uint len);\\n\\n  function getVoteVerdict(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (int8 ver);\\n\\n  function getVoteToken(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (uint tok);\\n\\n  function getVoteVoter(\\n    uint _claimId,\\n    uint _index,\\n    uint8 _ca\\n  )\\n  external\\n  view\\n  returns (address voter);\\n\\n  function getUserClaimCount(address _add) external view returns (uint len);\\n\\n  function getClaimLength() external view returns (uint len);\\n\\n  function actualClaimLength() external view returns (uint len);\\n\\n\\n  function getClaimFromNewStart(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint coverid,\\n    uint claimId,\\n    int8 voteCA,\\n    int8 voteMV,\\n    uint statusnumber\\n  );\\n\\n  function getUserClaimByIndex(\\n    uint _index,\\n    address _add\\n  )\\n  external\\n  view\\n  returns (\\n    uint status,\\n    uint coverid,\\n    uint claimId\\n  );\\n\\n  function getAllVotesForClaim(\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint[] memory ca,\\n    uint[] memory mv\\n  );\\n\\n\\n  function getTokensClaim(\\n    address _of,\\n    uint _claimId\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint tokens\\n  );\\n\\n  function getRewardDistributedIndex(\\n    address _voter\\n  )\\n  external\\n  view\\n  returns (\\n    uint lastCAvoteIndex,\\n    uint lastMVvoteIndex\\n  );\\n\\n  function getClaimRewardDetail(\\n    uint claimid\\n  )\\n  external\\n  view\\n  returns (\\n    uint percCA,\\n    uint percMV,\\n    uint tokens\\n  );\\n\\n  function getClaimCoverId(uint _claimId) external view returns (uint claimId, uint coverid);\\n\\n  function getClaimVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token);\\n\\n  function getClaimMVote(uint _claimId, int8 _verdict) external view returns (uint claimId, uint token);\\n\\n  function getVoteAddressCA(address _voter, uint index) external view returns (uint);\\n\\n  function getVoteAddressMember(address _voter, uint index) external view returns (uint);\\n\\n  function getVoteAddressCALength(address _voter) external view returns (uint);\\n\\n  function getVoteAddressMemberLength(address _voter) external view returns (uint);\\n\\n  function getFinalVerdict(uint _claimId) external view returns (int8 verdict);\\n\\n  function getLengthOfClaimSubmittedAtEP() external view returns (uint len);\\n\\n  function getFirstClaimIndexToSubmitAfterEP() external view returns (uint indexToSubmit);\\n\\n  function getLengthOfClaimVotingPause() external view returns (uint len);\\n\\n  function getPendingClaimDetailsByIndex(\\n    uint _index\\n  )\\n  external\\n  view\\n  returns (\\n    uint claimId,\\n    uint pendingTime,\\n    bool voting\\n  );\\n\\n  function getFirstClaimIndexToStartVotingAfterEP() external view returns (uint firstindex);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IClaimsReward.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IClaimsReward {\\n\\n  /// @dev Decides the next course of action for a given claim.\\n  function changeClaimStatus(uint claimid) external;\\n\\n  function getCurrencyAssetAddress(bytes4 currency) external view returns (address);\\n\\n  function getRewardToBeGiven(\\n    uint check,\\n    uint voteid,\\n    uint flag\\n  )\\n  external\\n  view\\n  returns (\\n    uint tokenCalculated,\\n    bool lastClaimedCheck,\\n    uint tokens,\\n    uint perc\\n  );\\n\\n  function upgrade(address _newAdd) external;\\n\\n  function getRewardToBeDistributedByUser(address _add) external view returns (uint total);\\n\\n  function getRewardAndClaimedStatus(uint check, uint claimId) external view returns (uint reward, bool claimed);\\n\\n  function claimAllPendingReward(uint records) external;\\n\\n  function getAllPendingRewardOfUser(address _add) external view returns (uint);\\n\\n  function unlockCoverNote(uint coverId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IGovernance {\\n\\n  event Proposal(\\n    address indexed proposalOwner,\\n    uint256 indexed proposalId,\\n    uint256 dateAdd,\\n    string proposalTitle,\\n    string proposalSD,\\n    string proposalDescHash\\n  );\\n\\n  event Solution(\\n    uint256 indexed proposalId,\\n    address indexed solutionOwner,\\n    uint256 indexed solutionId,\\n    string solutionDescHash,\\n    uint256 dateAdd\\n  );\\n\\n  event Vote(\\n    address indexed from,\\n    uint256 indexed proposalId,\\n    uint256 indexed voteId,\\n    uint256 dateAdd,\\n    uint256 solutionChosen\\n  );\\n\\n  event RewardClaimed(\\n    address indexed member,\\n    uint gbtReward\\n  );\\n\\n  /// @dev VoteCast event is called whenever a vote is cast that can potentially close the proposal.\\n  event VoteCast (uint256 proposalId);\\n\\n  /// @dev ProposalAccepted event is called when a proposal is accepted so that a server can listen that can\\n  ///      call any offchain actions\\n  event ProposalAccepted (uint256 proposalId);\\n\\n  /// @dev CloseProposalOnTime event is called whenever a proposal is created or updated to close it on time.\\n  event CloseProposalOnTime (\\n    uint256 indexed proposalId,\\n    uint256 time\\n  );\\n\\n  /// @dev ActionSuccess event is called whenever an onchain action is executed.\\n  event ActionSuccess (\\n    uint256 proposalId\\n  );\\n\\n  /// @dev Creates a new proposal\\n  /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\\n  /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\\n  function createProposal(\\n    string calldata _proposalTitle,\\n    string calldata _proposalSD,\\n    string calldata _proposalDescHash,\\n    uint _categoryId\\n  )\\n  external;\\n\\n  /// @dev Edits the details of an existing proposal and creates new version\\n  /// @param _proposalId Proposal id that details needs to be updated\\n  /// @param _proposalDescHash Proposal description hash having long and short description of proposal.\\n  function updateProposal(\\n    uint _proposalId,\\n    string calldata _proposalTitle,\\n    string calldata _proposalSD,\\n    string calldata _proposalDescHash\\n  )\\n  external;\\n\\n  /// @dev Categorizes proposal to proceed further. Categories shows the proposal objective.\\n  function categorizeProposal(\\n    uint _proposalId,\\n    uint _categoryId,\\n    uint _incentives\\n  )\\n  external;\\n\\n  /// @dev Submit proposal with solution\\n  /// @param _proposalId Proposal id\\n  /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\\n  function submitProposalWithSolution(\\n    uint _proposalId,\\n    string calldata _solutionHash,\\n    bytes calldata _action\\n  )\\n  external;\\n\\n  /// @dev Creates a new proposal with solution and votes for the solution\\n  /// @param _proposalDescHash Proposal description hash through IPFS having Short and long description of proposal\\n  /// @param _categoryId This id tells under which the proposal is categorized i.e. Proposal's Objective\\n  /// @param _solutionHash Solution hash contains  parameters, values and description needed according to proposal\\n  function createProposalwithSolution(\\n    string calldata _proposalTitle,\\n    string calldata _proposalSD,\\n    string calldata _proposalDescHash,\\n    uint _categoryId,\\n    string calldata _solutionHash,\\n    bytes calldata _action\\n  )\\n  external;\\n\\n  /// @dev Casts vote\\n  /// @param _proposalId Proposal id\\n  /// @param _solutionChosen solution chosen while voting. _solutionChosen[0] is the chosen solution\\n  function submitVote(uint _proposalId, uint _solutionChosen) external;\\n\\n  function closeProposal(uint _proposalId) external;\\n\\n  function claimReward(address _memberAddress, uint _maxRecords) external returns (uint pendingDAppReward);\\n\\n  function proposal(uint _proposalId)\\n  external\\n  view\\n  returns (\\n    uint proposalId,\\n    uint category,\\n    uint status,\\n    uint finalVerdict,\\n    uint totalReward\\n  );\\n\\n  function canCloseProposal(uint _proposalId) external view returns (uint closeValue);\\n\\n  function allowedToCatgorize() external view returns (uint roleId);\\n\\n  function removeDelegation(address _add) external;\\n\\n  function getPendingReward(address _memberAddress) external view returns (uint pendingDAppReward);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMCR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IMCR {\\n\\n  function updateMCRInternal(uint poolValueInEth, bool forceUpdate) external;\\n  function getMCR() external view returns (uint);\\n\\n\\n  function maxMCRFloorIncrement() external view returns (uint24);\\n\\n  function mcrFloor() external view returns (uint112);\\n  function mcr() external view returns (uint112);\\n  function desiredMCR() external view returns (uint112);\\n  function lastUpdateTime() external view returns (uint32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMemberRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IMemberRoles {\\n\\n  enum Role {UnAssigned, AdvisoryBoard, Member, Owner}\\n\\n  function payJoiningFee(address _userAddress) external payable;\\n\\n  function switchMembership(address _newAddress) external;\\n\\n  function switchMembershipOf(address member, address _newAddress) external;\\n\\n  function swapOwner(address _newOwnerAddress) external;\\n\\n  function kycVerdict(address payable _userAddress, bool verdict) external;\\n\\n  function getClaimPayoutAddress(address payable _member) external view returns (address payable);\\n\\n  function setClaimPayoutAddress(address payable _address) external;\\n\\n  function totalRoles() external view returns (uint256);\\n\\n  function changeAuthorized(uint _roleId, address _newAuthorized) external;\\n\\n  function members(uint _memberRoleId) external view returns (uint, address[] memory memberArray);\\n\\n  function numberOfMembers(uint _memberRoleId) external view returns (uint);\\n\\n  function authorized(uint _memberRoleId) external view returns (address);\\n\\n  function roles(address _memberAddress) external view returns (uint[] memory);\\n\\n  function checkRole(address _memberAddress, uint _roleId) external view returns (bool);\\n\\n  function getMemberLengthForAllRoles() external view returns (uint[] memory totalMembers);\\n\\n  function memberAtIndex(uint _memberRoleId, uint index) external view returns (address, bool);\\n\\n  function membersLength(uint _memberRoleId) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INXMToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface INXMToken {\\n\\n  function burn(uint256 amount) external returns (bool);\\n\\n  function burnFrom(address from, uint256 value) external returns (bool);\\n\\n  function operatorTransfer(address from, uint256 value) external returns (bool);\\n\\n  function mint(address account, uint256 amount) external;\\n\\n  function isLockedForMV(address member) external view returns (uint);\\n\\n  function addToWhiteList(address _member) external returns (bool);\\n\\n  function removeFromWhiteList(address _member) external returns (bool);\\n\\n  function changeOperator(address _newOperator) external returns (bool);\\n\\n  function lockForMemberVote(address _of, uint _days) external;\\n\\n  /**\\n * @dev Returns the amount of tokens in existence.\\n */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./IPriceFeedOracle.sol\\\";\\n\\ninterface IPool {\\n  function sellNXM(uint tokenAmount, uint minEthOut) external;\\n\\n  function sellNXMTokens(uint tokenAmount) external returns (bool);\\n\\n  function minPoolEth() external returns (uint);\\n\\n  function transferAssetToSwapOperator(address asset, uint amount) external;\\n\\n  function setAssetDataLastSwapTime(address asset, uint32 lastSwapTime) external;\\n\\n  function getAssetDetails(address _asset) external view returns (\\n    uint112 min,\\n    uint112 max,\\n    uint32 lastAssetSwapTime,\\n    uint maxSlippageRatio\\n  );\\n\\n  function sendClaimPayout (\\n    address asset,\\n    address payable payoutAddress,\\n    uint amount\\n  ) external returns (bool success);\\n\\n  function transferAsset(\\n    address asset,\\n    address payable destination,\\n    uint amount\\n  ) external;\\n\\n  function upgradeCapitalPool(address payable newPoolAddress) external;\\n\\n  function priceFeedOracle() external view returns (IPriceFeedOracle);\\n\\n  function getPoolValueInEth() external view returns (uint);\\n\\n\\n  function transferAssetFrom(address asset, address from, uint amount) external;\\n\\n  function getEthForNXM(uint nxmAmount) external view returns (uint ethAmount);\\n\\n  function calculateEthForNXM(\\n    uint nxmAmount,\\n    uint currentTotalAssetValue,\\n    uint mcrEth\\n  ) external pure returns (uint);\\n\\n  function calculateMCRRatio(uint totalAssetValue, uint mcrEth) external pure returns (uint);\\n\\n  function calculateTokenSpotPrice(uint totalAssetValue, uint mcrEth) external pure returns (uint tokenPrice);\\n\\n  function getTokenPrice(address asset) external view returns (uint tokenPrice);\\n\\n  function getMCRRatio() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPooledStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IPooledStaking {\\n\\n  function accumulateReward(address contractAddress, uint amount) external;\\n\\n  function pushBurn(address contractAddress, uint amount) external;\\n\\n  function hasPendingActions() external view returns (bool);\\n\\n  function processPendingActions(uint maxIterations) external returns (bool finished);\\n\\n  function contractStake(address contractAddress) external view returns (uint);\\n\\n  function stakerReward(address staker) external view returns (uint);\\n\\n  function stakerDeposit(address staker) external view returns (uint);\\n\\n  function stakerContractStake(address staker, address contractAddress) external view returns (uint);\\n\\n  function withdraw(uint amount) external;\\n\\n  function stakerMaxWithdrawable(address stakerAddress) external view returns (uint);\\n\\n  function withdrawReward(address stakerAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQuotationData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IQuotationData {\\n\\n  function authQuoteEngine() external view returns (address);\\n  function stlp() external view returns (uint);\\n  function stl() external view returns (uint);\\n  function pm() external view returns (uint);\\n  function minDays() external view returns (uint);\\n  function tokensRetained() external view returns (uint);\\n  function kycAuthAddress() external view returns (address);\\n\\n  function refundEligible(address) external view returns (bool);\\n  function holdedCoverIDStatus(uint) external view returns (uint);\\n  function timestampRepeated(uint) external view returns (bool);\\n\\n  enum HCIDStatus {NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover}\\n  enum CoverStatus {Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested}\\n\\n  function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external;\\n\\n  function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external;\\n\\n  function subFromTotalSumAssured(bytes4 _curr, uint _amount) external;\\n\\n  function addInTotalSumAssured(bytes4 _curr, uint _amount) external;\\n\\n  function setTimestampRepeated(uint _timestamp) external;\\n\\n  /// @dev Creates a blank new cover.\\n  function addCover(\\n    uint16 _coverPeriod,\\n    uint _sumAssured,\\n    address payable _userAddress,\\n    bytes4 _currencyCode,\\n    address _scAddress,\\n    uint premium,\\n    uint premiumNXM\\n  ) external;\\n\\n\\n  function addHoldCover(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod\\n  ) external;\\n\\n  function setRefundEligible(address _add, bool status) external;\\n\\n  function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external;\\n\\n  function setKycAuthAddress(address _add) external;\\n\\n  function changeAuthQuoteEngine(address _add) external;\\n\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val);\\n\\n  function getProductDetails()\\n  external\\n  view\\n  returns (\\n    uint _minDays,\\n    uint _pm,\\n    uint _stl,\\n    uint _stlp\\n  );\\n\\n  function getCoverLength() external view returns (uint len);\\n\\n  function getAuthQuoteEngine() external view returns (address _add);\\n\\n  function getTotalSumAssured(bytes4 _curr) external view returns (uint amount);\\n\\n  function getAllCoversOfUser(address _add) external view returns (uint[] memory allCover);\\n\\n  function getUserCoverLength(address _add) external view returns (uint len);\\n\\n  function getCoverStatusNo(uint _cid) external view returns (uint8);\\n\\n  function getCoverPeriod(uint _cid) external view returns (uint32 cp);\\n\\n  function getCoverSumAssured(uint _cid) external view returns (uint sa);\\n\\n  function getCurrencyOfCover(uint _cid) external view returns (bytes4 curr);\\n\\n  function getValidityOfCover(uint _cid) external view returns (uint date);\\n\\n  function getscAddressOfCover(uint _cid) external view returns (uint, address);\\n\\n  function getCoverMemberAddress(uint _cid) external view returns (address payable _add);\\n\\n  function getCoverPremiumNXM(uint _cid) external view returns (uint _premiumNXM);\\n\\n  function getCoverDetailsByCoverID1(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    address _memberAddress,\\n    address _scAddress,\\n    bytes4 _currencyCode,\\n    uint _sumAssured,\\n    uint premiumNXM\\n  );\\n\\n  function getCoverDetailsByCoverID2(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    uint8 status,\\n    uint sumAssured,\\n    uint16 coverPeriod,\\n    uint validUntil\\n  );\\n\\n  function getHoldedCoverDetailsByID1(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint16 coverPeriod\\n  );\\n\\n  function getUserHoldedCoverLength(address _add) external view returns (uint);\\n\\n  function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint);\\n\\n  function getHoldedCoverDetailsByID2(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address payable memberAddress,\\n    uint[] memory coverDetails\\n  );\\n\\n  function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns (uint amount);\\n\\n  function changeCoverStatusNo(uint _cid, uint8 _stat) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface ITokenController {\\n\\n  function coverInfo(uint id) external view returns (uint16 claimCount, bool hasOpenClaim, bool hasAcceptedClaim);\\n\\n  function claimSubmissionGracePeriod() external view returns (uint);\\n\\n  function withdrawCoverNote(\\n    address _of,\\n    uint[] calldata _coverIds,\\n    uint[] calldata _indexes\\n  ) external;\\n\\n  function markCoverClaimOpen(uint coverId) external;\\n\\n  function markCoverClaimClosed(uint coverId, bool isAccepted) external;\\n\\n  function changeOperator(address _newOperator) external;\\n\\n  function operatorTransfer(address _from, address _to, uint _value) external returns (bool);\\n\\n  function lockClaimAssessmentTokens(uint256 _amount, uint256 _time) external;\\n\\n  function lockOf(address _of, bytes32 _reason, uint256 _amount, uint256 _time) external returns (bool);\\n\\n  function mintCoverNote(\\n    address _of,\\n    bytes32 _reason,\\n    uint256 _amount,\\n    uint256 _time\\n  ) external;\\n\\n  function extendClaimAssessmentLock(uint256 _time) external;\\n\\n  function extendLockOf(address _of, bytes32 _reason, uint256 _time) external returns (bool);\\n\\n  function increaseClaimAssessmentLock(uint256 _amount) external;\\n\\n  function burnFrom(address _of, uint amount) external returns (bool);\\n\\n  function burnLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\\n\\n  function reduceLock(address _of, bytes32 _reason, uint256 _time) external;\\n\\n  function releaseLockedTokens(address _of, bytes32 _reason, uint256 _amount) external;\\n\\n  function addToWhitelist(address _member) external;\\n\\n  function removeFromWhitelist(address _member) external;\\n\\n  function mint(address _member, uint _amount) external;\\n\\n  function lockForMemberVote(address _of, uint _days) external;\\n  function withdrawClaimAssessmentTokens(address _of) external;\\n\\n  function getLockReasons(address _of) external view returns (bytes32[] memory reasons);\\n\\n  function getLockedTokensValidity(address _of, bytes32 reason) external view returns (uint256 validity);\\n\\n  function getUnlockableTokens(address _of) external view returns (uint256 unlockableTokens);\\n\\n  function tokensLocked(address _of, bytes32 _reason) external view returns (uint256 amount);\\n\\n  function tokensLockedWithValidity(address _of, bytes32 _reason)\\n  external\\n  view\\n  returns (uint256 amount, uint256 validity);\\n\\n  function tokensUnlockable(address _of, bytes32 _reason) external view returns (uint256 amount);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function tokensLockedAtTime(address _of, bytes32 _reason, uint256 _time) external view returns (uint256 amount);\\n  function totalBalanceOf(address _of) external view returns (uint256 amount);\\n\\n  function totalLockedBalance(address _of) external view returns (uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface ITokenData {\\n\\n  function walletAddress() external view returns (address payable);\\n  function lockTokenTimeAfterCoverExp() external view returns (uint);\\n  function bookTime() external view returns (uint);\\n  function lockCADays() external view returns (uint);\\n  function lockMVDays() external view returns (uint);\\n  function scValidDays() external view returns (uint);\\n  function joiningFee() external view returns (uint);\\n  function stakerCommissionPer() external view returns (uint);\\n  function stakerMaxCommissionPer() external view returns (uint);\\n  function tokenExponent() external view returns (uint);\\n  function priceStep() external view returns (uint);\\n\\n  function depositedCN(uint) external view returns (uint amount, bool isDeposited);\\n\\n  function lastCompletedStakeCommission(address) external view returns (uint);\\n\\n  function changeWalletAddress(address payable _address) external;\\n\\n  function getStakerStakedContractByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (address stakedContractAddress);\\n\\n  function getStakerStakedBurnedByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint burnedAmount);\\n\\n  function getStakerStakedUnlockableBeforeLastBurnByIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint unlockable);\\n\\n  function getStakerStakedContractIndex(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint scIndex);\\n\\n  function getStakedContractStakerIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  external\\n  view\\n  returns (uint sIndex);\\n\\n  function getStakerInitialStakedAmountOnContract(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint amount);\\n\\n  function getStakerStakedContractLength(\\n    address _stakerAddress\\n  )\\n  external\\n  view\\n  returns (uint length);\\n\\n  function getStakerUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint amount);\\n\\n  function pushUnlockedStakedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n\\n  function pushBurnedTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function pushUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function setUnlockableBeforeLastBurnTokens(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function pushEarnedStakeCommissions(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex,\\n    uint _commissionAmount\\n  ) external;\\n\\n  function pushRedeemedStakeCommissions(\\n    address _stakerAddress,\\n    uint _stakerIndex,\\n    uint _amount\\n  ) external;\\n\\n  function getStakerEarnedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint);\\n\\n  function getStakerRedeemedStakeCommission(\\n    address _stakerAddress,\\n    uint _stakerIndex\\n  )\\n  external\\n  view\\n  returns (uint);\\n\\n  function getStakerTotalEarnedStakeCommission(\\n    address _stakerAddress\\n  )\\n  external\\n  view\\n  returns (uint totalCommissionEarned);\\n\\n  function getStakerTotalReedmedStakeCommission(\\n    address _stakerAddress\\n  )\\n  external\\n  view\\n  returns (uint totalCommissionRedeemed);\\n\\n  function setDepositCN(uint coverId, bool flag) external;\\n\\n  function getStakedContractStakerByIndex(\\n    address _stakedContractAddress,\\n    uint _stakedContractIndex\\n  )\\n  external\\n  view\\n  returns (address stakerAddress);\\n\\n  function getStakedContractStakersLength(\\n    address _stakedContractAddress\\n  ) external view returns (uint length);\\n\\n  function addStake(\\n    address _stakerAddress,\\n    address _stakedContractAddress,\\n    uint _amount\\n  ) external returns (uint scIndex);\\n\\n  function bookCATokens(address _of) external;\\n\\n  function isCATokensBooked(address _of) external view returns (bool res);\\n\\n  function setStakedContractCurrentCommissionIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  ) external;\\n\\n  function setLastCompletedStakeCommissionIndex(\\n    address _stakerAddress,\\n    uint _index\\n  ) external;\\n\\n\\n  function setStakedContractCurrentBurnIndex(\\n    address _stakedContractAddress,\\n    uint _index\\n  ) external;\\n\\n  function setDepositCNAmount(uint coverId, uint amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INXMMaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface INXMMaster {\\n\\n  function tokenAddress() external view returns (address);\\n\\n  function owner() external view returns (address);\\n\\n  function masterInitialized() external view returns (bool);\\n\\n  function isInternal(address _add) external view returns (bool);\\n\\n  function isPause() external view returns (bool check);\\n\\n  function isOwner(address _add) external view returns (bool);\\n\\n  function isMember(address _add) external view returns (bool);\\n\\n  function checkIsAuthToGoverned(address _add) external view returns (bool);\\n\\n  function dAppLocker() external view returns (address _add);\\n\\n  function getLatestAddress(bytes2 _contractName) external view returns (address payable contractAddress);\\n\\n  function upgradeMultipleContracts(\\n    bytes2[] calldata _contractCodes,\\n    address payable[] calldata newAddresses\\n  ) external;\\n\\n  function removeContracts(bytes2[] calldata contractCodesToRemove) external;\\n\\n  function addNewInternalContracts(\\n    bytes2[] calldata _contractCodes,\\n    address payable[] calldata newAddresses,\\n    uint[] calldata _types\\n  ) external;\\n\\n  function updateOwnerParameters(bytes8 code, address payable val) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceFeedOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IPriceFeedOracle {\\n\\n  function daiAddress() external view returns (address);\\n  function stETH() external view returns (address);\\n  function ETH() external view returns (address);\\n\\n  function getAssetToEthRate(address asset) external view returns (uint);\\n  function getAssetForEth(address asset, uint ethIn) external view returns (uint);\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"masterAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_daiAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"}],\"name\":\"changeClaimStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeDependentContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_masterAddress\",\"type\":\"address\"}],\"name\":\"changeMasterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"records\",\"type\":\"uint256\"}],\"name\":\"claimAllPendingReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimId\",\"type\":\"uint256\"}],\"name\":\"closeClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"getAllPendingRewardOfUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"currency\",\"type\":\"bytes4\"}],\"name\":\"getCurrencyAssetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"check\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimId\",\"type\":\"uint256\"}],\"name\":\"getRewardAndClaimedStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"getRewardToBeDistributedByUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"check\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flag\",\"type\":\"uint256\"}],\"name\":\"getRewardToBeGiven\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenCalculated\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"lastClaimedCheck\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perc\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mcr\",\"outputs\":[{\"internalType\":\"contract IMCR\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ms\",\"outputs\":[{\"internalType\":\"contract INXMMaster\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nxMasterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coverId\",\"type\":\"uint256\"}],\"name\":\"unlockCoverNote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdd\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ClaimsReward","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000001bfd82675dbcc7762c84019ca518e701c0cd07e0000000000000000000000006b175474e89094c44da98b954eedeac495271d0f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}