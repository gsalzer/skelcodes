{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/adapter/FixedPriceAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0; \\n\\nimport \\\"@mochifi/library/contracts/Float.sol\\\";\\nimport \\\"../interfaces/IGovernanceOwned.sol\\\";\\nimport \\\"../interfaces/ICSSRAdapter.sol\\\";\\n\\ncontract FixedPriceAdapter is ICSSRAdapter {\\n    IGovernanceOwned public immutable owned;\\n\\n    mapping(address => uint256) public numerator;\\n    \\n    modifier onlyGov() {\\n        require(msg.sender == owned.governance(), \\\"!gov\\\");\\n        _;\\n    }\\n\\n    constructor(address _owned) {\\n        owned = IGovernanceOwned(_owned);\\n    }\\n\\n    function setPrice(address[] calldata _assets, uint256[] calldata _numerators) external onlyGov {\\n        for(uint256 i = 0; i<_assets.length; i++) {\\n            numerator[_assets[i]] = _numerators[i];\\n        }\\n    }\\n\\n    function update(address _asset, bytes calldata _data)\\n        external\\n        override\\n        returns (float memory)\\n    {\\n        return getPrice(_asset);\\n    }\\n    \\n    function support(address _asset) external view override returns (bool) {\\n        return numerator[_asset] != 0;\\n    }\\n\\n    function getPrice(address _asset)\\n        public\\n        view\\n        override\\n        returns (float memory)\\n    {\\n        require(numerator[_asset] != 0, \\\"!supported\\\");\\n        return float({\\n            numerator: numerator[_asset],\\n            denominator: 1e18\\n        });\\n    }\\n\\n    function getLiquidity(address _asset)\\n        public\\n        view\\n        override\\n        returns(uint256)\\n    {\\n        revert(\\\"fixed price adapter does not support liquidity\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@mochifi/library/contracts/Float.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nstruct float {\\n    uint256 numerator;\\n    uint256 denominator;\\n}\\n\\nlibrary Float {\\n    function multiply(uint256 a, float memory f) internal pure returns(uint256) {\\n        require(f.denominator != 0, \\\"div 0\\\");\\n        return a * f.numerator / f.denominator;\\n    }\\n\\n    function inverse(float memory f) internal pure returns(float memory) {\\n        require(f.numerator != 0 && f.denominator != 0, \\\"div 0\\\");\\n        return float({\\n            numerator: f.denominator,\\n            denominator: f.numerator\\n        });\\n    }\\n\\n    function divide(uint256 a, float memory f) internal pure returns(uint256) {\\n        require(f.denominator != 0, \\\"div 0\\\");\\n        return a * f.denominator / f.numerator;\\n    }\\n\\n    function add(float memory a, float memory b) internal pure returns(float memory res) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        res = float({\\n            numerator : a.numerator*b.denominator + a.denominator*b.numerator,\\n            denominator : a.denominator*b.denominator\\n        });\\n        if(res.numerator > 2**128 && res.denominator > 2**128){\\n            res.numerator = res.numerator / 2**64;\\n            res.denominator = res.denominator / 2**64;\\n        }\\n    }\\n    \\n    function sub(float memory a, float memory b) internal pure returns(float memory res) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        res = float({\\n            numerator : a.numerator*b.denominator - b.numerator*a.denominator,\\n            denominator : a.denominator*b.denominator\\n        });\\n        if(res.numerator > 2**128 && res.denominator > 2**128){\\n            res.numerator = res.numerator / 2**64;\\n            res.denominator = res.denominator / 2**64;\\n        }\\n    }\\n\\n    function mul(float memory a, float memory b) internal pure returns(float memory res) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        res = float({\\n            numerator : a.numerator * b.numerator,\\n            denominator : a.denominator * b.denominator\\n        });\\n        if(res.numerator > 2**128 && res.denominator > 2**128){\\n            res.numerator = res.numerator / 2**64;\\n            res.denominator = res.denominator / 2**64;\\n        }\\n    }\\n\\n    function gt(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator > a.denominator * b.numerator;\\n    }\\n\\n    function lt(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator < a.denominator * b.numerator;\\n    }\\n\\n    function gte(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator >= a.denominator * b.numerator;\\n    }\\n\\n    function lte(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator <= a.denominator * b.numerator;\\n    }\\n\\n    function equals(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator == b.numerator * a.denominator;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGovernanceOwned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IGovernanceOwned {\\n    function governance() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICSSRAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@mochifi/library/contracts/Float.sol\\\";\\n\\ninterface ICSSRAdapter {\\n    function update(address _asset, bytes memory _data)\\n        external\\n        returns (float memory price);\\n\\n    function support(address _asset) external view returns (bool);\\n\\n    function getPrice(address _asset)\\n        external\\n        view\\n        returns (float memory price);\\n\\n    function getLiquidity(address _asset)\\n        external\\n        view\\n        returns (uint256 _liquidity);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owned\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"internalType\":\"struct float\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"numerator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owned\",\"outputs\":[{\"internalType\":\"contract IGovernanceOwned\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_assets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_numerators\",\"type\":\"uint256[]\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"support\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"update\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"internalType\":\"struct float\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FixedPriceAdapter","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000860e47e6d6f4a6bcaaddfc7f17f772d2ab55be2f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}