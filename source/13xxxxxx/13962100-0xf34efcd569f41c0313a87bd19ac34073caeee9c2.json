{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/GenesisSupply.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/State.sol\\\";\\n\\ncontract GenesisSupply is Ownable, State {\\n    enum TokenType {\\n        NONE,\\n        GOD,\\n        DEMI_GOD,\\n        ELEMENTAL\\n    }\\n    enum TokenSubtype {\\n        NONE,\\n        CREATIVE,\\n        DESTRUCTIVE,\\n        AIR,\\n        EARTH,\\n        ELECTRICITY,\\n        FIRE,\\n        MAGMA,\\n        METAL,\\n        WATER\\n    }\\n\\n    struct TokenTraits {\\n        TokenType tokenType;\\n        TokenSubtype tokenSubtype;\\n    }\\n\\n    /**\\n     * Supply\\n     */\\n    uint256 public constant MAX_SUPPLY = 1077;\\n    uint256 public constant GODS_MAX_SUPPLY = 51;\\n    uint256 public constant DEMI_GODS_MAX_SUPPLY = 424;\\n    uint256 public constant DEMI_GODS_SUBTYPE_MAX_SUPPLY = 212;\\n    uint256 public constant ELEMENTALS_MAX_SUPPLY = 602;\\n    uint256 public constant ELEMENTALS_MAJOR_SUBTYPE_MAX_SUPPLY = 110;\\n    uint256 public constant ELEMENTALS_MINOR_SUBTYPE_MAX_SUPPLY = 54;\\n    uint256 public constant RESERVED_GODS_MAX_SUPPLY = 6;\\n\\n    /**\\n     * Counters\\n     */\\n    uint256 private tokenCounter;\\n    uint256 private godsCounter;\\n    uint256 private creativeDemiGodsCounter;\\n    uint256 private destructiveDemiGodsCounter;\\n    uint256 private earthElementalsCounter;\\n    uint256 private waterElementalsCounter;\\n    uint256 private fireElementalsCounter;\\n    uint256 private airElementalsCounter;\\n    uint256 private electricityElementalsCounter;\\n    uint256 private metalElementalsCounter;\\n    uint256 private magmaElementalsCounter;\\n    uint256 private reservedGodsTransfered;\\n\\n    /**\\n     * Minting properties\\n     */\\n    mapping(uint256 => TokenTraits) private tokenIdToTraits;\\n\\n    /**\\n     * Utils\\n     */\\n    bool public isRevealed;\\n    address private genesisAddress;\\n\\n    constructor() {\\n        isRevealed = false;\\n        // reserve 6 gods for owner\\n        for (uint256 i = 0; i < RESERVED_GODS_MAX_SUPPLY; i++) {\\n            godsCounter += 1;\\n            tokenCounter += 1;\\n        }\\n    }\\n\\n    /**\\n     * Setters\\n     */\\n    function setIsRevealed(bool _isRevealed) external isGenesis {\\n        require(mintState == MintState.Maintenance, \\\"Mint not maintenance\\\");\\n        isRevealed = _isRevealed;\\n    }\\n\\n    function setGenesis(address _genesisAddress) external onlyOwner closed {\\n        genesisAddress = _genesisAddress;\\n    }\\n\\n    function setMintState(MintState _mintState) external isGenesis {\\n        require(_mintState > mintState, \\\"State can't go back\\\");\\n        mintState = _mintState;\\n    }\\n\\n    /**\\n     * Getters\\n     */\\n    /**\\n     * Returns the current index to mint\\n     * @return index current index of the collection\\n     */\\n    function currentIndex() public view returns (uint256 index) {\\n        return tokenCounter;\\n    }\\n\\n    /**\\n     * Returns the number of reserved gods left with the supply\\n     * @return index current index of reserved gods\\n     * @return supply max supply of reserved gods\\n     */\\n    function reservedGodsCurrentIndexAndSupply()\\n        public\\n        view\\n        isGenesis\\n        returns (uint256 index, uint256 supply)\\n    {\\n        return (reservedGodsTransfered, RESERVED_GODS_MAX_SUPPLY);\\n    }\\n\\n    /**\\n     * Minting functions\\n     */\\n\\n    /**\\n     * Mint a token\\n     * @param count the number of item to mint\\n     * @return startIndex index of first mint\\n     * @return endIndex index of last mint\\n     */\\n    function mint(uint256 count)\\n        public\\n        isGenesis\\n        returns (uint256 startIndex, uint256 endIndex)\\n    {\\n        require(\\n            mintState == MintState.Closed || mintState == MintState.Active,\\n            \\\"Mint not active or closed\\\"\\n        );\\n        require(tokenCounter + count < MAX_SUPPLY + 1, \\\"Not enough supply\\\");\\n        uint256 firstTokenId = tokenCounter;\\n        for (uint256 i = 0; i < count; i++) {\\n            // On closed, we airdrop, we generate randomness with a moving nonce\\n            if (mintState == MintState.Closed) {\\n                tokenIdToTraits[firstTokenId + i] = generateRandomTraits(\\n                    generateRandomNumber(tokenCounter)\\n                );\\n            } else {\\n                // During WL we use a fix nonce\\n                tokenIdToTraits[firstTokenId + i] = generateRandomTraits(\\n                    generateRandomNumber(0)\\n                );\\n            }\\n            tokenCounter += 1;\\n        }\\n        return (firstTokenId, firstTokenId + count);\\n    }\\n\\n    /**\\n     * Mint reserved gods\\n     * This function needs to be ran BEFORE the mint is opened to avoid\\n     * @param count number of gods to transfer\\n     */\\n    function mintReservedGods(uint256 count) public isGenesis closed {\\n        uint256 nextIndex = reservedGodsTransfered;\\n        // Here we don't need to increment counter and god supply counter because we already do in the constructor\\n        // to not initialize the counters at 0\\n        for (uint256 i = nextIndex; i < count + nextIndex; i++) {\\n            tokenIdToTraits[i] = TokenTraits(TokenType.GOD, TokenSubtype.NONE);\\n            reservedGodsTransfered += 1;\\n        }\\n    }\\n\\n    /**\\n     * Metadata functions\\n     */\\n\\n    /**\\n     * @dev Generates a uint256 random number from seed, nonce and transaction block\\n     * @param nonce The nonce to be used for the randomization\\n     * @return randomNumber random number generated\\n     */\\n    function generateRandomNumber(uint256 nonce)\\n        private\\n        view\\n        returns (uint256 randomNumber)\\n    {\\n        return\\n            uint256(\\n                keccak256(abi.encodePacked(msg.sender, block.timestamp, nonce))\\n            );\\n    }\\n\\n    /**\\n     * Generate and returns the token traits (type & subtype) given a random number.\\n     * Function will adjust supply based on the type and subtypes generated\\n     * @param randomNumber random number provided\\n     * @return tokenTraits randomly picked token traits\\n     */\\n    function generateRandomTraits(uint256 randomNumber)\\n        private\\n        returns (TokenTraits memory tokenTraits)\\n    {\\n        // GODS\\n        uint256 godsLeft = GODS_MAX_SUPPLY - godsCounter;\\n\\n        // DEMI-GODS\\n        uint256 creativeDemiGodsLeft = DEMI_GODS_SUBTYPE_MAX_SUPPLY -\\n            creativeDemiGodsCounter;\\n        uint256 destructiveDemiGodsLeft = DEMI_GODS_SUBTYPE_MAX_SUPPLY -\\n            destructiveDemiGodsCounter;\\n        uint256 demiGodsLeft = creativeDemiGodsLeft + destructiveDemiGodsLeft;\\n\\n        // ELEMENTALS\\n        uint256 elementalsLeft = ELEMENTALS_MAX_SUPPLY -\\n            earthElementalsCounter -\\n            waterElementalsCounter -\\n            fireElementalsCounter -\\n            airElementalsCounter -\\n            electricityElementalsCounter -\\n            metalElementalsCounter -\\n            magmaElementalsCounter;\\n\\n        uint256 totalCountLeft = godsLeft + demiGodsLeft + elementalsLeft;\\n\\n        // We add 1 to modulos because we use the counts to define the type. If a count is at 0, we ignore it.\\n        // That's why we don't ever want the modulo to return 0.\\n        uint256 randomTypeIndex = (randomNumber % totalCountLeft) + 1;\\n        if (randomTypeIndex <= godsLeft) {\\n            godsCounter += 1;\\n            return TokenTraits(TokenType.GOD, TokenSubtype.NONE);\\n        } else if (randomTypeIndex <= godsLeft + demiGodsLeft) {\\n            uint256 randomSubtypeIndex = (randomNumber % demiGodsLeft) + 1;\\n            if (randomSubtypeIndex <= creativeDemiGodsLeft) {\\n                creativeDemiGodsCounter += 1;\\n                return TokenTraits(TokenType.DEMI_GOD, TokenSubtype.CREATIVE);\\n            } else {\\n                destructiveDemiGodsCounter += 1;\\n                return\\n                    TokenTraits(TokenType.DEMI_GOD, TokenSubtype.DESTRUCTIVE);\\n            }\\n        } else {\\n            return generateElementalSubtype(randomNumber);\\n        }\\n    }\\n\\n    function generateElementalSubtype(uint256 randomNumber)\\n        private\\n        returns (TokenTraits memory traits)\\n    {\\n        // ELEMENTALS\\n        uint256 earthElementalsLeft = ELEMENTALS_MAJOR_SUBTYPE_MAX_SUPPLY -\\n            earthElementalsCounter;\\n        uint256 waterElementalsLeft = ELEMENTALS_MAJOR_SUBTYPE_MAX_SUPPLY -\\n            waterElementalsCounter;\\n        uint256 fireElementalsLeft = ELEMENTALS_MAJOR_SUBTYPE_MAX_SUPPLY -\\n            fireElementalsCounter;\\n        uint256 airElementalsLeft = ELEMENTALS_MAJOR_SUBTYPE_MAX_SUPPLY -\\n            airElementalsCounter;\\n        uint256 electricityElementalsLeft = ELEMENTALS_MINOR_SUBTYPE_MAX_SUPPLY -\\n                electricityElementalsCounter;\\n        uint256 metalElementalsLeft = ELEMENTALS_MINOR_SUBTYPE_MAX_SUPPLY -\\n            metalElementalsCounter;\\n        uint256 magmaElementalsLeft = ELEMENTALS_MINOR_SUBTYPE_MAX_SUPPLY -\\n            magmaElementalsCounter;\\n        uint256 elementalsLeft = earthElementalsLeft +\\n            waterElementalsLeft +\\n            fireElementalsLeft +\\n            airElementalsLeft +\\n            electricityElementalsLeft +\\n            metalElementalsLeft +\\n            magmaElementalsLeft;\\n\\n        uint256 randomSubtypeIndex = (randomNumber % elementalsLeft) + 1;\\n        if (randomSubtypeIndex <= earthElementalsLeft) {\\n            earthElementalsCounter += 1;\\n            return TokenTraits(TokenType.ELEMENTAL, TokenSubtype.EARTH);\\n        } else if (\\n            randomSubtypeIndex <= earthElementalsLeft + waterElementalsLeft\\n        ) {\\n            waterElementalsCounter += 1;\\n            return TokenTraits(TokenType.ELEMENTAL, TokenSubtype.WATER);\\n        } else if (\\n            randomSubtypeIndex <=\\n            earthElementalsLeft + waterElementalsLeft + fireElementalsLeft\\n        ) {\\n            fireElementalsCounter += 1;\\n            return TokenTraits(TokenType.ELEMENTAL, TokenSubtype.FIRE);\\n        } else if (\\n            randomSubtypeIndex <=\\n            earthElementalsLeft +\\n                waterElementalsLeft +\\n                fireElementalsLeft +\\n                airElementalsLeft\\n        ) {\\n            airElementalsCounter += 1;\\n            return TokenTraits(TokenType.ELEMENTAL, TokenSubtype.AIR);\\n        } else if (\\n            randomSubtypeIndex <=\\n            earthElementalsLeft +\\n                waterElementalsLeft +\\n                fireElementalsLeft +\\n                airElementalsLeft +\\n                electricityElementalsLeft\\n        ) {\\n            electricityElementalsCounter += 1;\\n            return TokenTraits(TokenType.ELEMENTAL, TokenSubtype.ELECTRICITY);\\n        } else if (\\n            randomSubtypeIndex <=\\n            earthElementalsLeft +\\n                waterElementalsLeft +\\n                fireElementalsLeft +\\n                airElementalsLeft +\\n                electricityElementalsLeft +\\n                metalElementalsLeft\\n        ) {\\n            metalElementalsCounter += 1;\\n            return TokenTraits(TokenType.ELEMENTAL, TokenSubtype.METAL);\\n        } else {\\n            magmaElementalsCounter += 1;\\n            return TokenTraits(TokenType.ELEMENTAL, TokenSubtype.MAGMA);\\n        }\\n    }\\n\\n    /**\\n     * Returns the metadata of a token\\n     * @param tokenId id of the token\\n     * @return traits metadata of the token\\n     */\\n    function getMetadataForTokenId(uint256 tokenId)\\n        public\\n        view\\n        validTokenId(tokenId)\\n        returns (TokenTraits memory traits)\\n    {\\n        require(isRevealed, \\\"Not revealed yet\\\");\\n        return tokenIdToTraits[tokenId];\\n    }\\n\\n    /**\\n     *  Modifiers\\n     */\\n\\n    /**\\n     * Modifier that checks for a valid tokenId\\n     * @param tokenId token id\\n     */\\n    modifier validTokenId(uint256 tokenId) {\\n        require(tokenId < MAX_SUPPLY, \\\"Invalid tokenId\\\");\\n        require(tokenId >= 0, \\\"Invalid tokenId\\\");\\n        _;\\n    }\\n\\n    /**\\n     * Modifier that checks sender is Genesis\\n     */\\n    modifier isGenesis() {\\n        require(msg.sender == genesisAddress, \\\"Not Genesis\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/State.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract State {\\n    enum MintState {\\n        Closed,\\n        Active,\\n        Maintenance,\\n        Finalized\\n    }\\n    MintState public mintState = MintState.Closed;\\n\\n    /**\\n     * Modifier that checks mint state to be closed\\n     */\\n    modifier closed() {\\n        require(mintState == MintState.Closed, \\\"Mint not closed\\\");\\n        _;\\n    }\\n\\n    /**\\n     * Modifier that checks mint state to be active\\n     */\\n    modifier active() {\\n        require(mintState == MintState.Active, \\\"Mint not active\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEMI_GODS_MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEMI_GODS_SUBTYPE_MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ELEMENTALS_MAJOR_SUBTYPE_MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ELEMENTALS_MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ELEMENTALS_MINOR_SUBTYPE_MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GODS_MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RESERVED_GODS_MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getMetadataForTokenId\",\"outputs\":[{\"components\":[{\"internalType\":\"enum GenesisSupply.TokenType\",\"name\":\"tokenType\",\"type\":\"uint8\"},{\"internalType\":\"enum GenesisSupply.TokenSubtype\",\"name\":\"tokenSubtype\",\"type\":\"uint8\"}],\"internalType\":\"struct GenesisSupply.TokenTraits\",\"name\":\"traits\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRevealed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"mintReservedGods\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintState\",\"outputs\":[{\"internalType\":\"enum State.MintState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reservedGodsCurrentIndexAndSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_genesisAddress\",\"type\":\"address\"}],\"name\":\"setGenesis\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isRevealed\",\"type\":\"bool\"}],\"name\":\"setIsRevealed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum State.MintState\",\"name\":\"_mintState\",\"type\":\"uint8\"}],\"name\":\"setMintState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GenesisSupply","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}