{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/ChainlinkConversionPath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./legacy_openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\\\";\\n\\ninterface ERC20fraction {\\n  function decimals() external view returns (uint8);\\n}\\n\\ninterface AggregatorFraction {\\n  function decimals() external view returns (uint8);\\n  function latestAnswer() external view returns (int256);\\n  function latestTimestamp() external view returns (uint256);\\n}\\n\\n\\n/**\\n * @title ChainlinkConversionPath\\n *\\n * @notice ChainlinkConversionPath is a contract computing currency conversion rates based on Chainlink aggretators\\n */\\ncontract ChainlinkConversionPath is WhitelistAdminRole {\\n  uint constant DECIMALS = 1e18;\\n\\n  // Mapping of Chainlink aggregators (input currency => output currency => contract address)\\n  // input & output currencies are the addresses of the ERC20 contracts OR the sha3(\\\"currency code\\\")\\n  mapping(address => mapping(address => address)) public allAggregators;\\n\\n  // declare a new aggregator\\n  event AggregatorUpdated(address _input, address _output, address _aggregator);\\n\\n  /**\\n    * @notice Update an aggregator\\n    * @param _input address representing the input currency\\n    * @param _output address representing the output currency\\n    * @param _aggregator address of the aggregator contract\\n  */\\n  function updateAggregator(address _input, address _output, address _aggregator)\\n    external\\n    onlyWhitelistAdmin\\n  {\\n    allAggregators[_input][_output] = _aggregator;\\n    emit AggregatorUpdated(_input, _output, _aggregator);\\n  }\\n\\n  /**\\n    * @notice Update a list of aggregators\\n    * @param _inputs list of addresses representing the input currencies\\n    * @param _outputs list of addresses representing the output currencies\\n    * @param _aggregators list of addresses of the aggregator contracts\\n  */\\n  function updateAggregatorsList(\\n    address[] calldata _inputs,\\n    address[] calldata _outputs,\\n    address[] calldata _aggregators\\n  )\\n    external\\n    onlyWhitelistAdmin\\n  {\\n    require(_inputs.length == _outputs.length, \\\"arrays must have the same length\\\");\\n    require(_inputs.length == _aggregators.length, \\\"arrays must have the same length\\\");\\n\\n    // For every conversions of the path\\n    for (uint i; i < _inputs.length; i++) {\\n      allAggregators[_inputs[i]][_outputs[i]] = _aggregators[i];\\n      emit AggregatorUpdated(_inputs[i], _outputs[i], _aggregators[i]);\\n    }\\n  }\\n\\n  /**\\n  * @notice Computes the conversion of an amount through a list of intermediate conversions\\n  * @param _amountIn Amount to convert\\n  * @param _path List of addresses representing the currencies for the intermediate conversions\\n  * @return result The result after all the conversions\\n  * @return oldestRateTimestamp The oldest timestamp of the path\\n  */\\n  function getConversion(\\n    uint256 _amountIn,\\n    address[] calldata _path\\n  )\\n    external\\n    view\\n    returns (uint256 result, uint256 oldestRateTimestamp)\\n  {\\n    (uint256 rate, uint256 timestamp, uint256 decimals) = getRate(_path);\\n\\n    // initialize the result\\n    result = (_amountIn * rate) / decimals;\\n\\n    oldestRateTimestamp = timestamp;\\n  }\\n\\n  /**\\n  * @notice Computes the conversion rate from a list of currencies\\n  * @param _path List of addresses representing the currencies for the conversions\\n  * @return rate The rate\\n  * @return oldestRateTimestamp The oldest timestamp of the path\\n  * @return decimals of the conversion rate\\n  */\\n  function getRate(\\n    address[] memory _path\\n  )\\n    public\\n    view\\n    returns (uint256 rate, uint256 oldestRateTimestamp, uint256 decimals)\\n  {\\n    // initialize the result with 18 decimals (for more precision)\\n    rate = DECIMALS;\\n    decimals = DECIMALS;\\n    oldestRateTimestamp = block.timestamp;\\n\\n    // For every conversion of the path\\n    for (uint i; i < _path.length - 1; i++) {\\n      (\\n        AggregatorFraction aggregator,\\n        bool reverseAggregator,\\n        uint256 decimalsInput,\\n        uint256 decimalsOutput\\n      ) = getAggregatorAndDecimals(_path[i], _path[i + 1]);\\n\\n      // store the latest timestamp of the path\\n      uint256 currentTimestamp = aggregator.latestTimestamp();\\n      if (currentTimestamp < oldestRateTimestamp) {\\n        oldestRateTimestamp = currentTimestamp;\\n      }\\n\\n      // get the rate of the current step\\n      uint256 currentRate = uint256(aggregator.latestAnswer());\\n      // get the number of decimals of the current rate\\n      uint256 decimalsAggregator = uint256(aggregator.decimals());\\n\\n      // mul with the difference of decimals before the current rate computation (for more precision)\\n      if (decimalsAggregator > decimalsInput) {\\n        rate = rate * (10**(decimalsAggregator-decimalsInput));\\n      }\\n      if (decimalsAggregator < decimalsOutput) {\\n        rate = rate * (10**(decimalsOutput-decimalsAggregator));\\n      }\\n\\n      // Apply the current rate (if path uses an aggregator in the reverse way, div instead of mul)\\n      if (reverseAggregator) {\\n        rate = rate * (10**decimalsAggregator) / currentRate;\\n      } else {\\n        rate = rate * currentRate / (10**decimalsAggregator);\\n      }\\n\\n      // div with the difference of decimals AFTER the current rate computation (for more precision)\\n      if (decimalsAggregator < decimalsInput) {\\n        rate = rate / (10**(decimalsInput-decimalsAggregator));\\n      }\\n      if (decimalsAggregator > decimalsOutput) {\\n        rate = rate / (10**(decimalsAggregator-decimalsOutput));\\n      }\\n    }\\n  }\\n\\n  /**\\n  * @notice Gets aggregators and decimals of two currencies\\n  * @param _input input Address\\n  * @param _output output Address\\n  * @return aggregator to get the rate between the two currencies\\n  * @return reverseAggregator true if the aggregator returned give the rate from _output to _input\\n  * @return decimalsInput decimals of _input\\n  * @return decimalsOutput decimals of _output\\n  */\\n  function getAggregatorAndDecimals(address _input, address _output)\\n    private\\n    view\\n    returns (AggregatorFraction aggregator, bool reverseAggregator, uint256 decimalsInput, uint256 decimalsOutput)\\n  {\\n    // Try to get the right aggregator for the conversion\\n    aggregator = AggregatorFraction(allAggregators[_input][_output]);\\n    reverseAggregator = false;\\n\\n    // if no aggregator found we try to find an aggregator in the reverse way\\n    if (address(aggregator) == address(0x00)) {\\n      aggregator = AggregatorFraction(allAggregators[_output][_input]);\\n      reverseAggregator = true;\\n    }\\n\\n    require(address(aggregator) != address(0x00), \\\"No aggregator found\\\");\\n\\n    // get the decimals for the two currencies\\n    decimalsInput = getDecimals(_input);\\n    decimalsOutput = getDecimals(_output);\\n  }\\n\\n  /**\\n  * @notice Gets decimals from an address currency\\n  * @param _addr address to check\\n  * @return decimals number of decimals\\n  */\\n  function getDecimals(address _addr)\\n    private\\n    view\\n    returns (uint256 decimals)\\n  {\\n    // by default we assume it is FIAT so 8 decimals\\n    decimals = 8;\\n    // if address is the hash of the ETH currency\\n    if (_addr == address(0xF5AF88e117747e87fC5929F2ff87221B1447652E)) {\\n      decimals = 18;\\n    } else if (isContract(_addr)) {\\n      // otherwise, we get the decimals from the erc20 directly\\n      decimals = ERC20fraction(_addr).decimals();\\n    }\\n  }\\n\\n  /**\\n  * @notice Checks if an address is a contract\\n  * @param _addr Address to check\\n  * @return true if the address hosts a contract, false otherwise\\n  */\\n  function isContract(address _addr)\\n    private\\n    view\\n    returns (bool)\\n  {\\n    uint32 size;\\n    // solium-disable security/no-inline-assembly\\n    assembly {\\n      size := extcodesize(_addr)\\n    }\\n    return (size > 0);\\n  }\\n}\\n\"\r\n    },\r\n    \"src/contracts/legacy_openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/Context.sol';\\nimport \\\"../Roles.sol\\\";\\n\\n/**\\n * @title WhitelistAdminRole\\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\\n */\\nabstract contract WhitelistAdminRole is Context {\\n    using Roles for Roles.Role;\\n\\n    event WhitelistAdminAdded(address indexed account);\\n    event WhitelistAdminRemoved(address indexed account);\\n\\n    Roles.Role private _whitelistAdmins;\\n\\n    constructor () {\\n        _addWhitelistAdmin(_msgSender());\\n    }\\n\\n    modifier onlyWhitelistAdmin() {\\n        require(isWhitelistAdmin(_msgSender()), \\\"WhitelistAdminRole: caller does not have the WhitelistAdmin role\\\");\\n        _;\\n    }\\n\\n    function isWhitelistAdmin(address account) public view returns (bool) {\\n        return _whitelistAdmins.has(account);\\n    }\\n\\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\\n        _addWhitelistAdmin(account);\\n    }\\n\\n    function renounceWhitelistAdmin() public {\\n        _removeWhitelistAdmin(_msgSender());\\n    }\\n\\n    function _addWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.add(account);\\n        emit WhitelistAdminAdded(account);\\n    }\\n\\n    function _removeWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.remove(account);\\n        emit WhitelistAdminRemoved(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/legacy_openzeppelin/contracts/access/Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address => bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account's access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"}],\"name\":\"AggregatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"WhitelistAdminRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addWhitelistAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allAggregators\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"}],\"name\":\"getConversion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldestRateTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"}],\"name\":\"getRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldestRateTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isWhitelistAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceWhitelistAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_input\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_output\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"}],\"name\":\"updateAggregator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_inputs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_outputs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_aggregators\",\"type\":\"address[]\"}],\"name\":\"updateAggregatorsList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ChainlinkConversionPath","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}