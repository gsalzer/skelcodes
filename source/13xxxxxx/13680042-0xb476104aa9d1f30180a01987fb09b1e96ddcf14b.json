{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/VestingPools.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./interfaces/Constants.sol\\\";\\nimport { PoolParams } from \\\"./interfaces/Types.sol\\\";\\nimport \\\"./interfaces/IMintable.sol\\\";\\nimport \\\"./interfaces/IVestingPools.sol\\\";\\nimport \\\"./utils/Claimable.sol\\\";\\nimport { TokenAddress } from \\\"./utils/Linking.sol\\\";\\nimport \\\"./utils/SafeUints.sol\\\";\\n\\n/**\\n * @title VestingPools\\n * @notice It mints and vests a (mintable) ERC-20 token to \\\"Vesting Pools\\\".\\n * @dev Each \\\"Vesting Pool\\\" (or a \\\"pool\\\") has a `wallet` and `PoolParams`.\\n * The `wallet` requests vesting and receives vested tokens, or nominate\\n * another address that receives them.\\n * `PoolParams` deterministically define minting and unlocking schedule.\\n * Once added, a pool can not be removed. Subject to strict limitations,\\n * owner may update a few parameters of a pool.\\n */\\ncontract VestingPools is\\n    Ownable,\\n    Claimable,\\n    SafeUints,\\n    Constants,\\n    IVestingPools\\n{\\n    /// @notice Accumulated amount to be vested to all pools\\n    uint96 public totalAllocation;\\n    /// @notice Total amount already vested to all pools\\n    uint96 public totalVested;\\n\\n    // ID of a pool (i.e. `poolId`) is the index in these two arrays\\n    address[] internal _wallets;\\n    PoolParams[] internal _pools;\\n\\n    /// @inheritdoc IVestingPools\\n    function token() external view override returns (address) {\\n        return _getToken();\\n    }\\n\\n    /// @inheritdoc IVestingPools\\n    function getWallet(uint256 poolId)\\n        external\\n        view\\n        override\\n        returns (address)\\n    {\\n        _throwInvalidPoolId(poolId);\\n        return _wallets[poolId];\\n    }\\n\\n    /// @inheritdoc IVestingPools\\n    function getPool(uint256 poolId)\\n        external\\n        view\\n        override\\n        returns (PoolParams memory)\\n    {\\n        return _getPool(poolId);\\n    }\\n\\n    /// @inheritdoc IVestingPools\\n    function releasableAmount(uint256 poolId)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        PoolParams memory pool = _getPool(poolId);\\n        return _getReleasable(pool, _timeNow());\\n    }\\n\\n    /// @inheritdoc IVestingPools\\n    function vestedAmount(uint256 poolId)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        PoolParams memory pool = _getPool(poolId);\\n        return uint256(pool.vested);\\n    }\\n\\n    /// @inheritdoc IVestingPools\\n    function release(uint256 poolId, uint256 amount)\\n        external\\n        override\\n        returns (uint256 released)\\n    {\\n        return _releaseTo(poolId, msg.sender, amount);\\n    }\\n\\n    /// @inheritdoc IVestingPools\\n    function releaseTo(\\n        uint256 poolId,\\n        address account,\\n        uint256 amount\\n    ) external override returns (uint256 released) {\\n        _throwZeroAddress(account);\\n        return _releaseTo(poolId, account, amount);\\n    }\\n\\n    /// @inheritdoc IVestingPools\\n    function updatePoolWallet(uint256 poolId, address newWallet)\\n        external\\n        override\\n    {\\n        _throwZeroAddress(newWallet);\\n        _throwUnauthorizedWallet(poolId, msg.sender);\\n\\n        _wallets[poolId] = newWallet;\\n        emit WalletUpdated(poolId, newWallet);\\n    }\\n\\n    /// @inheritdoc IVestingPools\\n    function addVestingPools(\\n        address[] memory wallets,\\n        PoolParams[] memory pools\\n    ) external override onlyOwner {\\n        require(wallets.length == pools.length, \\\"VPools: length mismatch\\\");\\n\\n        uint256 timeNow = _timeNow();\\n        IMintable theToken = IMintable(_getToken());\\n        uint256 updAllocation = uint256(totalAllocation);\\n        uint256 preMinted = 0;\\n        uint256 poolId = _pools.length;\\n        for (uint256 i = 0; i < wallets.length; i++) {\\n            _throwZeroAddress(wallets[i]);\\n            require(pools[i].start >= timeNow, \\\"VPools: start already passed\\\");\\n            require(pools[i].sAllocation != 0, \\\"VPools: zero sAllocation\\\");\\n            require(\\n                pools[i].sAllocation >= pools[i].sUnlocked,\\n                \\\"VPools: too big sUnlocked\\\"\\n            );\\n            require(pools[i].vested == 0, \\\"VPools: zero vested expected\\\");\\n\\n            uint256 allocation = uint256(pools[i].sAllocation) * SCALE;\\n            updAllocation += allocation;\\n\\n            _wallets.push(wallets[i]);\\n            _pools.push(pools[i]);\\n            emit PoolAdded(poolId++, wallets[i], allocation);\\n\\n            if (pools[i].isPreMinted) {\\n                preMinted += allocation;\\n            }\\n        }\\n        // left outside the cycle to save gas for a non-reverting transaction\\n        require(updAllocation <= MAX_SUPPLY, \\\"VPools: supply exceeded\\\");\\n        totalAllocation = _safe96(updAllocation);\\n\\n        if (preMinted != 0) {\\n            require(theToken.mint(address(this), preMinted), \\\"VPools:E5\\\");\\n        }\\n    }\\n\\n    /// @inheritdoc IVestingPools\\n    /// @dev Vesting schedule for a pool may be significantly altered by this.\\n    /// However, pool allocation (i.e. token amount to vest) remains unchanged.\\n    function updatePoolTime(\\n        uint256 poolId,\\n        uint32 start,\\n        uint16 vestingDays\\n    ) external override onlyOwner {\\n        PoolParams memory pool = _getPool(poolId);\\n\\n        require(pool.isAdjustable, \\\"VPools: non-adjustable\\\");\\n        require(\\n            uint256(pool.sAllocation) * SCALE > uint256(pool.vested),\\n            \\\"VPools: fully vested\\\"\\n        );\\n        uint256 end = uint256(start) + uint256(vestingDays) * 1 days;\\n        // `end` may NOT be in the past, unlike `start` that may be even zero\\n        require(_timeNow() > end, \\\"VPools: too late updates\\\");\\n\\n        pool.start = start;\\n        pool.vestingDays = vestingDays;\\n        _pools[poolId] = pool;\\n\\n        emit PoolUpdated(poolId, start, vestingDays);\\n    }\\n\\n    /**\\n     * @notice Withdraws accidentally sent token from this contract.\\n     * @dev Owner may call only.\\n     */\\n    function claimErc20(\\n        address claimedToken,\\n        address to,\\n        uint256 amount\\n    ) external onlyOwner nonReentrant {\\n        IERC20 vestedToken = IERC20(_getToken());\\n        if (claimedToken == address(vestedToken)) {\\n            uint256 actual = vestedToken.balanceOf(address(this));\\n            uint256 expected = vestedToken.totalSupply() - totalVested;\\n            require(actual >= expected + amount, \\\"VPools: too big amount\\\");\\n        }\\n        _claimErc20(claimedToken, to, amount);\\n    }\\n\\n    /// @notice Removes the contract from blockchain if there is no tokens to vest.\\n    /// @dev Owner may call only.\\n    function removeContract() external onlyOwner {\\n        // intended \\\"strict comparison\\\"\\n        require(totalAllocation == totalVested, \\\"VPools:E1\\\");\\n        selfdestruct(payable(msg.sender));\\n    }\\n\\n    //////////////////\\n    //// Internal ////\\n    //////////////////\\n\\n    /// @dev Returns token contract address\\n    // (declared `view` rather than `pure` to facilitate testing)\\n    function _getToken() internal view virtual returns (address) {\\n        return address(TokenAddress);\\n    }\\n\\n    /// @dev Returns pool params for the pool with the given ID\\n    function _getPool(uint256 poolId)\\n        internal\\n        view\\n        returns (PoolParams memory)\\n    {\\n        _throwInvalidPoolId(poolId);\\n        return _pools[poolId];\\n    }\\n\\n    /// @dev Returns amount that may be released now for the pool given\\n    function _getReleasable(PoolParams memory pool, uint256 timeNow)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (timeNow < pool.start) return 0;\\n\\n        uint256 allocation = uint256(pool.sAllocation) * SCALE;\\n        if (pool.vested >= allocation) return 0;\\n\\n        uint256 releasable = allocation - uint256(pool.vested);\\n        uint256 duration = uint256(pool.vestingDays) * 1 days;\\n        uint256 end = uint256(pool.start) + duration;\\n        if (timeNow < end) {\\n            uint256 unlocked = uint256(pool.sUnlocked) * SCALE;\\n            uint256 locked = ((allocation - unlocked) * (end - timeNow)) /\\n                duration; // can't be 0 here\\n\\n            releasable = locked > releasable ? 0 : releasable - locked;\\n        }\\n\\n        return releasable;\\n    }\\n\\n    /// @dev Vests from the pool the given or releasable amount to the given address\\n    function _releaseTo(\\n        uint256 poolId,\\n        address to,\\n        uint256 amount\\n    ) internal returns (uint256 released) {\\n        PoolParams memory pool = _getPool(poolId);\\n        _throwUnauthorizedWallet(poolId, msg.sender);\\n\\n        uint256 releasable = _getReleasable(pool, _timeNow());\\n        require(releasable >= amount, \\\"VPools: not enough to release\\\");\\n\\n        released = amount == 0 ? releasable : amount;\\n\\n        _pools[poolId].vested = _safe96(released + uint256(pool.vested));\\n        totalVested = _safe96(released + uint256(totalVested));\\n\\n        // reentrancy impossible (known contract called)\\n        if (pool.isPreMinted) {\\n            require(IERC20(_getToken()).transfer(to, released), \\\"VPools:E6\\\");\\n        } else {\\n            require(IMintable(_getToken()).mint(to, released), \\\"VPools:E7\\\");\\n        }\\n        emit Released(poolId, to, released);\\n    }\\n\\n    function _throwZeroAddress(address account) private pure {\\n        require(account != address(0), \\\"VPools: zero address(account|wallet)\\\");\\n    }\\n\\n    function _throwInvalidPoolId(uint256 poolId) private view {\\n        require(poolId < _pools.length, \\\"VPools: invalid pool id\\\");\\n    }\\n\\n    function _throwUnauthorizedWallet(uint256 poolId, address wallet)\\n        private\\n        view\\n    {\\n        _throwZeroAddress(wallet);\\n        require(_wallets[poolId] == wallet, \\\"VPools: unauthorized\\\");\\n    }\\n\\n    /// @dev Returns the current block timestamp (added to ease testing)\\n    function _timeNow() internal view virtual returns (uint256) {\\n        return block.timestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract Constants {\\n    // $ZKP token max supply\\n    uint256 internal constant MAX_SUPPLY = 1e27;\\n\\n    // Scaling factor in token amount calculations\\n    uint256 internal constant SCALE = 1e12;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev To save gas, params are packed to fit into a single storage slot.\\n * Some amounts are scaled (divided) by {SCALE} - note names starting with\\n * the letter \\\"s\\\" (stands for \\\"scaled\\\") followed by a capital letter.\\n */\\nstruct PoolParams {\\n    // if `true`, allocation gets pre-minted, otherwise minted when vested\\n    bool isPreMinted;\\n    // if `true`, the owner may change {start} and {duration}\\n    bool isAdjustable;\\n    // (UNIX) time when vesting starts\\n    uint32 start;\\n    // period in days (since the {start}) of vesting\\n    uint16 vestingDays;\\n    // scaled total amount to (ever) vest from the pool\\n    uint48 sAllocation;\\n    // out of {sAllocation}, amount (also scaled) to be unlocked on the {start}\\n    uint48 sUnlocked;\\n    // amount vested from the pool so far (without scaling)\\n    uint96 vested;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMintable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IMintable is IERC20 {\\n    function mint(address account, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVestingPools.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { PoolParams } from \\\"./Types.sol\\\";\\n\\ninterface IVestingPools {\\n    /**\\n     * @notice Returns Token address.\\n     */\\n    function token() external view returns (address);\\n\\n    /**\\n     * @notice Returns the wallet address of the specified pool.\\n     */\\n    function getWallet(uint256 poolId) external view returns (address);\\n\\n    /**\\n     * @notice Returns parameters of the specified pool.\\n     */\\n    function getPool(uint256 poolId) external view returns (PoolParams memory);\\n\\n    /**\\n     * @notice Returns the amount that may be vested now from the given pool.\\n     */\\n    function releasableAmount(uint256 poolId) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the amount that has been vested from the given pool\\n     */\\n    function vestedAmount(uint256 poolId) external view returns (uint256);\\n\\n    /**\\n     * @notice Vests the specified amount from the given pool to the pool wallet.\\n     * If the amount is zero, it vests the entire \\\"releasable\\\" amount.\\n     * @dev Pool wallet may call only.\\n     * @return released - Amount released.\\n     */\\n    function release(uint256 poolId, uint256 amount)\\n        external\\n        returns (uint256 released);\\n\\n    /**\\n     * @notice Vests the specified amount from the given pool to the given address.\\n     * If the amount is zero, it vests the entire \\\"releasable\\\" amount.\\n     * @dev Pool wallet may call only.\\n     * @return released - Amount released.\\n     */\\n    function releaseTo(\\n        uint256 poolId,\\n        address account,\\n        uint256 amount\\n    ) external returns (uint256 released);\\n\\n    /**\\n     * @notice Updates the wallet for the given pool.\\n     * @dev (Current) wallet may call only.\\n     */\\n    function updatePoolWallet(uint256 poolId, address newWallet) external;\\n\\n    /**\\n     * @notice Adds new vesting pools with given wallets and parameters.\\n     * @dev Owner may call only.\\n     */\\n    function addVestingPools(\\n        address[] memory wallets,\\n        PoolParams[] memory params\\n    ) external;\\n\\n    /**\\n     * @notice Update `start` and `duration` for the given pool.\\n     * @param start - new (UNIX) time vesting starts at\\n     * @param vestingDays - new period in days, when vesting lasts\\n     * @dev Owner may call only.\\n     */\\n    function updatePoolTime(\\n        uint256 poolId,\\n        uint32 start,\\n        uint16 vestingDays\\n    ) external;\\n\\n    /// @notice Emitted on an amount vesting.\\n    event Released(uint256 indexed poolId, address to, uint256 amount);\\n\\n    /// @notice Emitted on a pool wallet update.\\n    event WalletUpdated(uint256 indexedpoolId, address indexed newWallet);\\n\\n    /// @notice Emitted on a new pool added.\\n    event PoolAdded(\\n        uint256 indexed poolId,\\n        address indexed wallet,\\n        uint256 allocation\\n    );\\n\\n    /// @notice Emitted on a pool params update.\\n    event PoolUpdated(\\n        uint256 indexed poolId,\\n        uint256 start,\\n        uint256 vestingDays\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Claimable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.8.0;\\n\\n/**\\n * @title Claimable\\n * @notice It withdraws accidentally sent tokens from this contract.\\n * @dev It provides reentrancy guard. The code borrowed from openzeppelin-contracts.\\n * Unlike original code, this version does not require `constructor` call.\\n */\\ncontract Claimable {\\n    bytes4 private constant SELECTOR_TRANSFER =\\n        bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _reentrancyStatus;\\n\\n    /// @dev Withdraws ERC20 tokens from this contract\\n    /// (take care of reentrancy attack risk mitigation)\\n    function _claimErc20(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        // solhint-disable avoid-low-level-calls\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(SELECTOR_TRANSFER, to, amount)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"claimErc20: TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_reentrancyStatus != _ENTERED, \\\"claimErc20: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _reentrancyStatus = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _reentrancyStatus = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Linking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This file contains fake libs just for static linking.\\n * These fake libs' code is assumed to never run.\\n * On compilation of dependant contracts, instead of fake libs addresses,\\n * indicate addresses of deployed real contracts (or accounts).\\n */\\n\\n/// @dev Address of the ZKPToken contract ('../ZKPToken.sol') instance\\nlibrary TokenAddress {\\n    function neverCallIt() external pure {\\n        revert(\\\"FAKE\\\");\\n    }\\n}\\n\\n/// @dev Address of the VestingPools ('../VestingPools.sol') instance\\nlibrary VestingPoolsAddress {\\n    function neverCallIt() external pure {\\n        revert(\\\"FAKE\\\");\\n    }\\n}\\n\\n/// @dev Address of the PoolStakes._defaultOwner\\n// (NB: if it's not a multisig, transfer ownership to a Multisig contract)\\nlibrary DefaultOwnerAddress {\\n    function neverCallIt() external pure {\\n        revert(\\\"FAKE\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SafeUints.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.8.0;\\n\\n/**\\n * @title SafeUints\\n * @notice Util functions which throws if a uint256 can't fit into smaller uints.\\n */\\ncontract SafeUints {\\n    // @dev Checks if the given uint256 does not overflow uint96\\n    function _safe96(uint256 n) internal pure returns (uint96) {\\n        require(n < 2**96, \\\"VPools: Unsafe96\\\");\\n        return uint96(n);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/utils/Linking.sol\": {\r\n        \"TokenAddress\": \"0x909e34d3f6124c324ac83dcca84b74398a6fa173\"\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"}],\"name\":\"PoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestingDays\",\"type\":\"uint256\"}],\"name\":\"PoolUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"indexedpoolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"WalletUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isPreMinted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAdjustable\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"vestingDays\",\"type\":\"uint16\"},{\"internalType\":\"uint48\",\"name\":\"sAllocation\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"sUnlocked\",\"type\":\"uint48\"},{\"internalType\":\"uint96\",\"name\":\"vested\",\"type\":\"uint96\"}],\"internalType\":\"struct PoolParams[]\",\"name\":\"pools\",\"type\":\"tuple[]\"}],\"name\":\"addVestingPools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getPool\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isPreMinted\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAdjustable\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"vestingDays\",\"type\":\"uint16\"},{\"internalType\":\"uint48\",\"name\":\"sAllocation\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"sUnlocked\",\"type\":\"uint48\"},{\"internalType\":\"uint96\",\"name\":\"vested\",\"type\":\"uint96\"}],\"internalType\":\"struct PoolParams\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"releasableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"released\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"releaseTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"released\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocation\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVested\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"vestingDays\",\"type\":\"uint16\"}],\"name\":\"updatePoolTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"updatePoolWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"vestedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VestingPools","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"800","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}