{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/oracle/UniswapTWAPOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"../interfaces/IUniswapV2Pair.sol\\\";\\n\\n// Copy from https://github.com/keep3r-network/keep3r.network/blob/master/contracts/Keep3rV2OracleFactory.sol\\n// sliding oracle that uses observations collected to provide moving price averages in the past\\ncontract UniswapTWAPOracle {\\n  constructor(address _feeder, address _pair) {\\n    feeder = _feeder;\\n    pair = _pair;\\n    (, , uint32 timestamp) = IUniswapV2Pair(_pair).getReserves();\\n    uint112 _price0CumulativeLast = uint112((IUniswapV2Pair(_pair).price0CumulativeLast() * e10) / Q112);\\n    uint112 _price1CumulativeLast = uint112((IUniswapV2Pair(_pair).price1CumulativeLast() * e10) / Q112);\\n    observations[length++] = Observation(timestamp, _price0CumulativeLast, _price1CumulativeLast);\\n  }\\n\\n  struct Observation {\\n    uint32 timestamp;\\n    uint112 price0Cumulative;\\n    uint112 price1Cumulative;\\n  }\\n\\n  modifier onlyFeeder() {\\n    require(msg.sender == feeder, \\\"UniswapTWAPOracle: only feeder\\\");\\n    _;\\n  }\\n\\n  Observation[65535] public observations;\\n  uint16 public length;\\n\\n  address immutable feeder;\\n  address public immutable pair;\\n  // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\\n  uint256 constant periodSize = 3600 * 4;\\n  uint256 Q112 = 2**112;\\n  uint256 e10 = 10**18;\\n\\n  // Pre-cache slots for cheaper oracle writes\\n  function cache(uint256 size) external {\\n    uint256 _length = length + size;\\n    for (uint256 i = length; i < _length; i++) observations[i].timestamp = 1;\\n  }\\n\\n  // update the current feed for free\\n  function update() external onlyFeeder returns (bool) {\\n    return _update();\\n  }\\n\\n  function updateable() external view returns (bool) {\\n    Observation memory _point = observations[length - 1];\\n    (, , uint256 timestamp) = IUniswapV2Pair(pair).getReserves();\\n    uint256 timeElapsed = timestamp - _point.timestamp;\\n    return timeElapsed > periodSize;\\n  }\\n\\n  function _update() internal returns (bool) {\\n    Observation memory _point = observations[length - 1];\\n    (, , uint32 timestamp) = IUniswapV2Pair(pair).getReserves();\\n    uint32 timeElapsed = timestamp - _point.timestamp;\\n    if (timeElapsed > periodSize) {\\n      uint112 _price0CumulativeLast = uint112((IUniswapV2Pair(pair).price0CumulativeLast() * e10) / Q112);\\n      uint112 _price1CumulativeLast = uint112((IUniswapV2Pair(pair).price1CumulativeLast() * e10) / Q112);\\n      observations[length++] = Observation(timestamp, _price0CumulativeLast, _price1CumulativeLast);\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  function _computeAmountOut(\\n    uint256 start,\\n    uint256 end,\\n    uint256 elapsed,\\n    uint256 amountIn\\n  ) internal view returns (uint256 amountOut) {\\n    amountOut = (amountIn * (end - start)) / e10 / elapsed;\\n  }\\n\\n  function current(\\n    address tokenIn,\\n    uint256 amountIn,\\n    address tokenOut\\n  ) external view returns (uint256 amountOut, uint256 lastUpdatedAgo) {\\n    (address token0, ) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\\n\\n    Observation memory _observation = observations[length - 1];\\n    uint256 price0Cumulative = (IUniswapV2Pair(pair).price0CumulativeLast() * e10) / Q112;\\n    uint256 price1Cumulative = (IUniswapV2Pair(pair).price1CumulativeLast() * e10) / Q112;\\n    (, , uint256 timestamp) = IUniswapV2Pair(pair).getReserves();\\n\\n    // Handle edge cases where we have no updates, will revert on first reading set\\n    if (timestamp == _observation.timestamp) {\\n      _observation = observations[length - 2];\\n    }\\n\\n    uint256 timeElapsed = timestamp - _observation.timestamp;\\n    timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\\n    if (token0 == tokenIn) {\\n      amountOut = _computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\\n    } else {\\n      amountOut = _computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\\n    }\\n    lastUpdatedAgo = timeElapsed;\\n  }\\n\\n  function quote(\\n    address tokenIn,\\n    uint256 amountIn,\\n    address tokenOut,\\n    uint256 points\\n  ) external view returns (uint256 amountOut, uint256 lastUpdatedAgo) {\\n    (address token0, ) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\\n\\n    uint256 priceAverageCumulative = 0;\\n    uint256 _length = length - 1;\\n    uint256 i = _length - points;\\n    Observation memory currentObservation;\\n    Observation memory nextObservation;\\n\\n    uint256 nextIndex = 0;\\n    if (token0 == tokenIn) {\\n      for (; i < _length; i++) {\\n        nextIndex = i + 1;\\n        currentObservation = observations[i];\\n        nextObservation = observations[nextIndex];\\n        priceAverageCumulative += _computeAmountOut(\\n          currentObservation.price0Cumulative,\\n          nextObservation.price0Cumulative,\\n          nextObservation.timestamp - currentObservation.timestamp,\\n          amountIn\\n        );\\n      }\\n    } else {\\n      for (; i < _length; i++) {\\n        nextIndex = i + 1;\\n        currentObservation = observations[i];\\n        nextObservation = observations[nextIndex];\\n        priceAverageCumulative += _computeAmountOut(\\n          currentObservation.price1Cumulative,\\n          nextObservation.price1Cumulative,\\n          nextObservation.timestamp - currentObservation.timestamp,\\n          amountIn\\n        );\\n      }\\n    }\\n    amountOut = priceAverageCumulative / points;\\n\\n    (, , uint256 timestamp) = IUniswapV2Pair(pair).getReserves();\\n    lastUpdatedAgo = timestamp - nextObservation.timestamp;\\n  }\\n\\n  function sample(\\n    address tokenIn,\\n    uint256 amountIn,\\n    address tokenOut,\\n    uint256 points,\\n    uint256 window\\n  ) external view returns (uint256[] memory prices, uint256 lastUpdatedAgo) {\\n    (address token0, ) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\\n    prices = new uint256[](points);\\n\\n    if (token0 == tokenIn) {\\n      {\\n        uint256 _length = length - 1;\\n        uint256 i = _length - (points * window);\\n        uint256 _index = 0;\\n        Observation memory nextObservation;\\n        for (; i < _length; i += window) {\\n          Observation memory currentObservation;\\n          currentObservation = observations[i];\\n          nextObservation = observations[i + window];\\n          prices[_index] = _computeAmountOut(\\n            currentObservation.price0Cumulative,\\n            nextObservation.price0Cumulative,\\n            nextObservation.timestamp - currentObservation.timestamp,\\n            amountIn\\n          );\\n          _index = _index + 1;\\n        }\\n\\n        (, , uint256 timestamp) = IUniswapV2Pair(pair).getReserves();\\n        lastUpdatedAgo = timestamp - nextObservation.timestamp;\\n      }\\n    } else {\\n      {\\n        uint256 _length = length - 1;\\n        uint256 i = _length - (points * window);\\n        uint256 _index = 0;\\n        Observation memory nextObservation;\\n        for (; i < _length; i += window) {\\n          Observation memory currentObservation;\\n          currentObservation = observations[i];\\n          nextObservation = observations[i + window];\\n          prices[_index] = _computeAmountOut(\\n            currentObservation.price1Cumulative,\\n            nextObservation.price1Cumulative,\\n            nextObservation.timestamp - currentObservation.timestamp,\\n            amountIn\\n          );\\n          _index = _index + 1;\\n        }\\n\\n        (, , uint256 timestamp) = IUniswapV2Pair(pair).getReserves();\\n        lastUpdatedAgo = timestamp - nextObservation.timestamp;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\ninterface IUniswapV2Pair {\\n  function totalSupply() external view returns (uint256);\\n\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function getReserves()\\n    external\\n    view\\n    returns (\\n      uint112 reserve0,\\n      uint112 reserve1,\\n      uint32 blockTimestampLast\\n    );\\n\\n  function price0CumulativeLast() external view returns (uint256);\\n\\n  function price1CumulativeLast() external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"cache\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"current\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdatedAgo\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"length\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"observations\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"price0Cumulative\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"price1Cumulative\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdatedAgo\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"window\",\"type\":\"uint256\"}],\"name\":\"sample\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdatedAgo\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"update\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"UniswapTWAPOracle","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"00000000000000000000000011e91bb6d1334585aa37d8f4fde3932c7960b938000000000000000000000000ed6c2f053af48cba6cbc0958124671376f01a903","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}