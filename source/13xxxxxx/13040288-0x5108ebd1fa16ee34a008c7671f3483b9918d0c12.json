{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CudlFinanceV3.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\n// Interface for our erc20 token\\ninterface IToken {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address tokenOwner)\\n        external\\n        view\\n        returns (uint256 balance);\\n\\n    function allowance(address tokenOwner, address spender)\\n        external\\n        view\\n        returns (uint256 remaining);\\n\\n    function transfer(address to, uint256 tokens)\\n        external\\n        returns (bool success);\\n\\n    function approve(address spender, uint256 tokens)\\n        external\\n        returns (bool success);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokens\\n    ) external returns (bool success);\\n\\n    function mint(address to, uint256 amount) external;\\n\\n    function burn(uint256 amount) external;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\\ncontract CudlFinanceV3 is\\n    Initializable,\\n    ERC721HolderUpgradeable,\\n    OwnableUpgradeable\\n{\\n    address public mooncats;\\n    address public PONDERWARE;\\n    address public MUSE_DAO;\\n    address public MUSE_DEVS;\\n\\n    uint256 public gas; // if gas higher then this you can't kill\\n    uint256 public lastGas; //here we record last gas paid, to keep track of chain gas. If gas is high, no pets can die.\\n\\n    IToken public token;\\n\\n    struct Pet {\\n        address nft;\\n        uint256 id;\\n    }\\n\\n    mapping(address => bool) public supportedNfts;\\n    mapping(uint256 => Pet) public petDetails;\\n\\n    // mining tokens\\n    mapping(uint256 => uint256) public lastTimeMined;\\n\\n    // Pet properties\\n    mapping(uint256 => uint256) public timeUntilStarving;\\n    mapping(uint256 => uint256) public petScore;\\n    mapping(uint256 => bool) public petDead;\\n    mapping(uint256 => uint256) public timePetBorn;\\n\\n    // items/benefits for the PET could be anything in the future.\\n    mapping(uint256 => uint256) public itemPrice;\\n    mapping(uint256 => uint256) public itemPoints;\\n    mapping(uint256 => string) public itemName;\\n    mapping(uint256 => uint256) public itemTimeExtension;\\n\\n    mapping(uint256 => mapping(address => address)) public careTaker;\\n\\n    mapping(address => mapping(uint256 => bool)) public isNftInTheGame; //keeps track if nft already played\\n    mapping(address => mapping(uint256 => uint256)) public nftToId; //keeps track if nft already played\\n\\n    uint256 public feesEarned;\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n    CountersUpgradeable.Counter private _tokenIds;\\n    CountersUpgradeable.Counter private _itemIds;\\n\\n    event Mined(uint256 nftId, uint256 reward, address recipient);\\n    event BuyAccessory(\\n        uint256 nftId,\\n        uint256 itemId,\\n        uint256 amount,\\n        uint256 itemTimeExtension,\\n        address buyer\\n    );\\n    event Fatalize(uint256 opponentId, uint256 nftId, address killer);\\n    event NewPlayer(\\n        address nftAddress,\\n        uint256 nftId,\\n        uint256 playerId,\\n        address owner\\n    );\\n    event Bonk(\\n        uint256 attacker,\\n        uint256 victim,\\n        uint256 winner,\\n        uint256 reward\\n    );\\n\\n    // Rewards algorithm\\n\\n    uint256 public la;\\n    uint256 public lb;\\n    uint256 public ra;\\n    uint256 public rb;\\n\\n    address public lastBonker;\\n\\n    // NEW STORE v2\\n\\n    mapping(uint256 => uint256) public spent;\\n    mapping(address => uint256) public balance;\\n    mapping(address => bool) public isOperator;\\n\\n    constructor() {}\\n\\n    modifier isAllowed(uint256 _id) {\\n        Pet memory _pet = petDetails[_id];\\n        address ownerOf = IERC721Upgradeable(_pet.nft).ownerOf(_pet.id);\\n        require(\\n            ownerOf == msg.sender || careTaker[_id][ownerOf] == msg.sender,\\n            \\\"!owner\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(\\n            isOperator[msg.sender],\\n            \\\"Roles: caller does not have the OPERATOR role\\\"\\n        );\\n        _;\\n    }\\n\\n    // GAME ACTIONS\\n\\n    function depositCudl(uint256 amount) external {\\n        balance[msg.sender] += amount;\\n        // burn real cul\\n        token.burnFrom(msg.sender, amount);\\n    }\\n\\n    //this withdraws all your eanrings\\n    function claimRewards(uint256[] memory petIds) public {\\n        lastGas = tx.gasprice;\\n        uint256 petId;\\n        uint256 amount;\\n        for (uint256 i = 0; i < petIds.length; i++) {\\n            petId = petIds[i];\\n\\n            require(isPetOwner(petId, msg.sender), \\\"!owner\\\");\\n            // This enforces helping kills/broadcast txs as you won't mine with any pet unless you kill your deads\\n            require(isPetSafe(petId), \\\"Your pet is starving, you can't mine\\\");\\n\\n            if (lastTimeMined[petId] == 0) {\\n                lastTimeMined[petId] = block.timestamp;\\n            }\\n            uint256 earning = getEarnings(petId);\\n            amount += earning;\\n\\n            // TODO check\\n            spent[petId] = 0;\\n\\n            lastTimeMined[petId] = block.timestamp;\\n            emit Mined(petId, earning, msg.sender);\\n        }\\n\\n        amount += balance[msg.sender];\\n        balance[msg.sender] = 0;\\n\\n        if (amount > 0) token.mint(msg.sender, amount);\\n    }\\n\\n    function buyAccesory(uint256 nftId, uint256 itemId)\\n        public\\n        isAllowed(nftId)\\n    {\\n        require(!petDead[nftId], \\\"ded pet\\\");\\n\\n        uint256 amount = itemPrice[itemId];\\n        require(amount > 0, \\\"item does not exist\\\");\\n\\n        // recalculate time until starving\\n        timeUntilStarving[nftId] = block.timestamp + itemTimeExtension[itemId];\\n        petScore[nftId] += itemPoints[itemId];\\n\\n        if (getEarnings(nftId) + balance[msg.sender] >= amount) {\\n            spent[nftId] += amount;\\n        } else {\\n            token.burnFrom(msg.sender, amount);\\n        }\\n\\n        feesEarned += amount / 10;\\n\\n        emit BuyAccessory(\\n            nftId,\\n            itemId,\\n            amount,\\n            itemTimeExtension[itemId],\\n            msg.sender\\n        );\\n    }\\n\\n    function feedMultiple(uint256[] calldata ids, uint256[] calldata itemIds)\\n        external\\n    {\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            buyAccesory(ids[i], itemIds[i]);\\n        }\\n    }\\n\\n    //TOOD DECIDE FATALITY\\n    function fatality(uint256 _deadId, uint256 _tokenId) external {\\n        require(\\n            !isPetSafe(_deadId) &&\\n                tx.gasprice <= gas && //inspired by NFT GAS by 0Xmons\\n                petDead[_deadId] == false,\\n            \\\"The PET has to be starved or gas below ${gas} to claim his points\\\"\\n        );\\n\\n        petScore[_tokenId] =\\n            petScore[_tokenId] +\\n            (((petScore[_deadId] * (20)) / (100)));\\n\\n        petScore[_deadId] = 0;\\n\\n        petDead[_deadId] = true;\\n        emit Fatalize(_deadId, _tokenId, msg.sender);\\n    }\\n\\n    function getCareTaker(uint256 _tokenId, address _owner)\\n        public\\n        view\\n        returns (address)\\n    {\\n        return (careTaker[_tokenId][_owner]);\\n    }\\n\\n    function setCareTaker(\\n        uint256 _tokenId,\\n        address _careTaker,\\n        bool clearCareTaker\\n    ) external isAllowed(_tokenId) {\\n        if (clearCareTaker) {\\n            delete careTaker[_tokenId][msg.sender];\\n        } else {\\n            careTaker[_tokenId][msg.sender] = _careTaker;\\n        }\\n    }\\n\\n    // requires approval\\n    function giveLife(address nft, uint256 _id) external {\\n        require(IERC721Upgradeable(nft).ownerOf(_id) == msg.sender, \\\"!OWNER\\\");\\n        require(\\n            !isNftInTheGame[nft][_id],\\n            \\\"this nft was already registered can't again\\\"\\n        );\\n        require(supportedNfts[nft], \\\"!forbidden\\\");\\n\\n        // burn 6 cudl to join\\n        token.burnFrom(msg.sender, 6 * 1 ether);\\n\\n        uint256 newId = _tokenIds.current();\\n        // set the pet struct\\n        petDetails[newId] = Pet(nft, _id);\\n\\n        nftToId[nft][_id] = newId;\\n\\n        isNftInTheGame[nft][_id] = true;\\n\\n        timeUntilStarving[newId] = block.timestamp + 3 days; //start with 3 days of life.\\n        timePetBorn[newId] = block.timestamp;\\n\\n        emit NewPlayer(nft, _id, newId, msg.sender);\\n\\n        _tokenIds.increment();\\n    }\\n\\n    // BAZAAR\\n\\n    function burnScore(uint256 petId, uint256 amount) external onlyOperator {\\n        require(!petDead[petId]);\\n\\n        petScore[petId] -= amount;\\n    }\\n\\n    function addScore(uint256 petId, uint256 amount) external onlyOperator {\\n        require(!petDead[petId]);\\n        petScore[petId] += amount;\\n    }\\n\\n    function spend(uint256 petId, uint256 amount) external onlyOperator {\\n        spent[petId] -= amount;\\n    }\\n\\n    function gibCudl(uint256 petId, uint256 amount) external onlyOperator {\\n        spent[petId] += amount;\\n    }\\n\\n    function addTOD(uint256 petId, uint256 duration) external onlyOperator {\\n        require(!petDead[petId]);\\n        timeUntilStarving[petId] = block.timestamp + duration;\\n    }\\n\\n    function isPetOwner(uint256 petId, address user)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        Pet memory _pet = petDetails[petId];\\n        address ownerOf = IERC721Upgradeable(_pet.nft).ownerOf(_pet.id);\\n        return (ownerOf == user || careTaker[petId][ownerOf] == user);\\n    }\\n\\n    // GETTERS\\n\\n    function getEarnings(uint256 petId) public view returns (uint256) {\\n        uint256 amount = (((block.timestamp - lastTimeMined[petId]) / 1 days) *\\n            getRewards(petId)) - spent[petId];\\n\\n        return amount;\\n    }\\n\\n    function getPendingBalance(uint256[] memory petIds, address user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 total;\\n        for (uint256 i = 0; i < petIds.length; i++) {\\n            total += getEarnings(petIds[i]);\\n        }\\n\\n        return total + balance[user];\\n    }\\n\\n    // check that pet didn't starve\\n    function isPetSafe(uint256 _nftId) public view returns (bool) {\\n        uint256 _timeUntilStarving = timeUntilStarving[_nftId];\\n        if (\\n            (_timeUntilStarving != 0 &&\\n                _timeUntilStarving >= block.timestamp) || lastGas >= gas\\n        ) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    // GETTERS\\n\\n    function getPetInfo(uint256 _nftId)\\n        public\\n        view\\n        returns (\\n            uint256 _pet,\\n            bool _isStarving,\\n            uint256 _score,\\n            uint256 _level,\\n            uint256 _expectedReward,\\n            uint256 _timeUntilStarving,\\n            uint256 _lastTimeMined,\\n            uint256 _timepetBorn,\\n            address _owner,\\n            address _token,\\n            uint256 _tokenId,\\n            bool _isAlive\\n        )\\n    {\\n        Pet memory thisPet = petDetails[_nftId];\\n\\n        _pet = _nftId;\\n        _isStarving = !this.isPetSafe(_nftId);\\n        _score = petScore[_nftId];\\n        _level = level(_nftId);\\n        _expectedReward = getRewards(_nftId);\\n        _timeUntilStarving = timeUntilStarving[_nftId];\\n        _lastTimeMined = lastTimeMined[_nftId];\\n        _timepetBorn = timePetBorn[_nftId];\\n        _owner = IERC721Upgradeable(thisPet.nft).ownerOf(thisPet.id);\\n        _token = petDetails[_nftId].nft;\\n        _tokenId = petDetails[_nftId].id;\\n        _isAlive = !petDead[_nftId];\\n    }\\n\\n    // get the level the pet is on to calculate the token reward\\n    function getRewards(uint256 tokenId) public view returns (uint256) {\\n        // This is the formula to get token rewards R(level)=(level)*6/7+6\\n        uint256 _level = level(tokenId);\\n        if (_level == 1) {\\n            return 6 ether;\\n        }\\n        _level = (_level * 1 ether * ra) / rb;\\n        return (_level + 5 ether);\\n    }\\n\\n    // get the level the pet is on to calculate points\\n    function level(uint256 tokenId) public view returns (uint256) {\\n        // This is the formula L(x) = 2 * sqrt(x * 2)\\n        uint256 _score = petScore[tokenId] / 100;\\n        if (_score == 0) {\\n            return 1;\\n        }\\n        uint256 _level = sqrtu(_score * la);\\n        return (_level * lb);\\n    }\\n\\n    // ADMIN\\n\\n    function editCurves(\\n        uint256 _la,\\n        uint256 _lb,\\n        uint256 _ra,\\n        uint256 _rb\\n    ) external onlyOwner {\\n        la = _la;\\n        lb = _lb;\\n        ra = _ra;\\n        rb = _rb;\\n    }\\n\\n    // edit specific item in case token goes up in value and the price for items gets to expensive for normal users.\\n    function editItem(\\n        uint256 _id,\\n        uint256 _price,\\n        uint256 _points,\\n        string calldata _name,\\n        uint256 _timeExtension\\n    ) external onlyOwner {\\n        itemPrice[_id] = _price;\\n        itemPoints[_id] = _points;\\n        itemName[_id] = _name;\\n        itemTimeExtension[_id] = _timeExtension;\\n    }\\n\\n    // to support more projects\\n    function setSupported(address _nft, bool isSupported) public onlyOwner {\\n        supportedNfts[_nft] = isSupported;\\n    }\\n\\n    function setGas(uint256 _gas) public onlyOwner {\\n        gas = _gas;\\n    }\\n\\n    function addOperator(address _address, bool _isAllowed) public onlyOwner {\\n        isOperator[_address] = _isAllowed;\\n    }\\n\\n    // add items/accessories\\n    function createItem(\\n        string calldata name,\\n        uint256 price,\\n        uint256 points,\\n        uint256 timeExtension\\n    ) external onlyOwner {\\n        _itemIds.increment();\\n        uint256 newItemId = _itemIds.current();\\n        itemName[newItemId] = name;\\n        itemPrice[newItemId] = price;\\n        itemPoints[newItemId] = points;\\n        itemTimeExtension[newItemId] = timeExtension;\\n    }\\n\\n    function changeEarners(address _newAddress) public {\\n        require(\\n            msg.sender == MUSE_DEVS || msg.sender == PONDERWARE,\\n            \\\"!forbidden\\\"\\n        );\\n        if (msg.sender == MUSE_DEVS) {\\n            MUSE_DEVS = _newAddress;\\n        } else if (msg.sender == PONDERWARE) {\\n            PONDERWARE = _newAddress;\\n        }\\n    }\\n\\n    // anyone can call this\\n    function claimEarnings() public {\\n        token.mint(address(this), feesEarned);\\n        feesEarned = 0;\\n\\n        uint256 bal = token.balanceOf(address(this));\\n        token.transfer(PONDERWARE, bal / 3);\\n        token.transfer(MUSE_DAO, bal / 3);\\n        token.transfer(MUSE_DEVS, bal / 3);\\n    }\\n\\n    function randomNumber(uint256 seed, uint256 max)\\n        public\\n        view\\n        returns (uint256 _randomNumber)\\n    {\\n        uint256 n = 0;\\n        unchecked {\\n            for (uint256 i = 0; i < 5; i++) {\\n                n += uint256(\\n                    keccak256(\\n                        abi.encodePacked(blockhash(block.number - i - 1), seed)\\n                    )\\n                );\\n            }\\n        }\\n        return (n) % max;\\n    }\\n\\n    function sqrtu(uint256 x) private pure returns (uint128) {\\n        if (x == 0) return 0;\\n        else {\\n            uint256 xx = x;\\n            uint256 r = 1;\\n            if (xx >= 0x100000000000000000000000000000000) {\\n                xx >>= 128;\\n                r <<= 64;\\n            }\\n            if (xx >= 0x10000000000000000) {\\n                xx >>= 64;\\n                r <<= 32;\\n            }\\n            if (xx >= 0x100000000) {\\n                xx >>= 32;\\n                r <<= 16;\\n            }\\n            if (xx >= 0x10000) {\\n                xx >>= 16;\\n                r <<= 8;\\n            }\\n            if (xx >= 0x100) {\\n                xx >>= 8;\\n                r <<= 4;\\n            }\\n            if (xx >= 0x10) {\\n                xx >>= 4;\\n                r <<= 2;\\n            }\\n            if (xx >= 0x8) {\\n                r <<= 1;\\n            }\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1;\\n            r = (r + x / r) >> 1; // Seven iterations should be enough\\n            uint256 r1 = x / r;\\n            return uint128(r < r1 ? r : r1);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary CountersUpgradeable {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\\n    function __ERC721Holder_init() internal initializer {\\n        __ERC721Holder_init_unchained();\\n    }\\n\\n    function __ERC721Holder_init_unchained() internal initializer {\\n    }\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"attacker\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"victim\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winner\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Bonk\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"itemTimeExtension\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"BuyAccessory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"opponentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"killer\",\"type\":\"address\"}],\"name\":\"Fatalize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Mined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"playerId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NewPlayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MUSE_DAO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MUSE_DEVS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PONDERWARE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isAllowed\",\"type\":\"bool\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"petId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addScore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"petId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"addTOD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"petId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnScore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"buyAccesory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"careTaker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"changeEarners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"petIds\",\"type\":\"uint256[]\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeExtension\",\"type\":\"uint256\"}],\"name\":\"createItem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositCudl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_la\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lb\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ra\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rb\",\"type\":\"uint256\"}],\"name\":\"editCurves\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_points\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_timeExtension\",\"type\":\"uint256\"}],\"name\":\"editItem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_deadId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"fatality\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"}],\"name\":\"feedMultiple\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getCareTaker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"petId\",\"type\":\"uint256\"}],\"name\":\"getEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"petIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getPendingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"getPetInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_pet\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isStarving\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_score\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expectedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeUntilStarving\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lastTimeMined\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timepetBorn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isAlive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"petId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"gibCudl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"giveLife\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isNftInTheGame\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"petId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isPetOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"isPetSafe\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"itemName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"itemPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"itemPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"itemTimeExtension\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"la\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBonker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastTimeMined\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lb\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"level\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mooncats\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftToId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"petDead\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"petDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"petScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ra\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"randomNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_randomNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rb\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_careTaker\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"clearCareTaker\",\"type\":\"bool\"}],\"name\":\"setCareTaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gas\",\"type\":\"uint256\"}],\"name\":\"setGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSupported\",\"type\":\"bool\"}],\"name\":\"setSupported\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"petId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"spend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"spent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supportedNfts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"timePetBorn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"timeUntilStarving\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CudlFinanceV3","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}