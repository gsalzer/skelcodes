{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/metapriest/code/my_code/dotvote/contracts/contracts/SafeMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\nlibrary SafeMathLib {\\n  function times(uint a, uint b) public pure returns (uint) {\\n    uint c = a * b;\\n    require(a == 0 || c / a == b, 'Overflow detected');\\n    return c;\\n  }\\n\\n  function minus(uint a, uint b) public pure returns (uint) {\\n    require(b <= a, 'Underflow detected');\\n    return a - b;\\n  }\\n\\n  function plus(uint a, uint b) public pure returns (uint) {\\n    uint c = a + b;\\n    require(c>=a && c>=b, 'Overflow detected');\\n    return c;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"/home/metapriest/code/my_code/dotvote/contracts/contracts/Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\nimport \\\"./SafeMathLib.sol\\\";\\n\\n\\ncontract Token {\\n    using SafeMathLib for uint;\\n\\n    mapping (address => uint) balances;\\n    mapping (address => mapping (address => uint)) allowed;\\n    mapping (uint => FrozenTokens) public frozenTokensMap;\\n\\n    event Transfer(address indexed sender, address indexed receiver, uint value);\\n    event Approval(address approver, address spender, uint value);\\n    event TokensFrozen(address indexed freezer, uint amount, uint id, uint lengthFreezeDays);\\n    event TokensUnfrozen(address indexed unfreezer, uint amount, uint id);\\n    event TokensBurned(address burner, uint amount);\\n    event TokensMinted(address recipient, uint amount);\\n    event BankUpdated(address oldBank, address newBank);\\n\\n    uint8 constant public decimals = 18;\\n    string constant public symbol = \\\"FVT\\\";\\n    string constant public name = \\\"Finance.Vote Token\\\";\\n    uint public totalSupply;\\n    uint numFrozenStructs;\\n    address public bank;\\n\\n    struct FrozenTokens {\\n        uint id;\\n        uint dateFrozen;\\n        uint lengthFreezeDays;\\n        uint amount;\\n        bool frozen;\\n        address owner;\\n    }\\n\\n    // simple initialization, giving complete token supply to one address\\n    constructor(address _bank) {\\n        bank = _bank;\\n        require(bank != address(0), 'Must initialize with nonzero address');\\n        uint totalInitialBalance = 1e9 * 1 ether;\\n//        uint totalInitialBalance = 0;\\n        balances[bank] = totalInitialBalance;\\n        totalSupply = totalInitialBalance;\\n        emit Transfer(address(0), bank, totalInitialBalance);\\n    }\\n\\n    modifier bankOnly() {\\n        require (msg.sender == bank, 'Only bank address may call this');\\n        _;\\n    }\\n\\n    function setBank(address newBank) public bankOnly {\\n        address oldBank = bank;\\n        bank = newBank;\\n        emit BankUpdated(oldBank, newBank);\\n    }\\n\\n    // freeze tokens for a certain number of days\\n    function freeze(uint amount, uint freezeDays) public {\\n        require(amount > 0, 'Cannot freeze 0 tokens');\\n        // move tokens into this contract's address from sender\\n        balances[msg.sender] = balances[msg.sender].minus(amount);\\n        balances[address(this)] = balances[address(this)].plus(amount);\\n        numFrozenStructs = numFrozenStructs.plus(1);\\n        frozenTokensMap[numFrozenStructs] = FrozenTokens(numFrozenStructs, block.timestamp, freezeDays, amount, true, msg.sender);\\n        emit Transfer(msg.sender, address(this), amount);\\n        emit TokensFrozen(msg.sender, amount, numFrozenStructs, freezeDays);\\n    }\\n\\n    // unfreeze frozen tokens\\n    function unFreeze(uint id) public {\\n        FrozenTokens storage f = frozenTokensMap[id];\\n        require(f.dateFrozen + (f.lengthFreezeDays * 1 days) < block.timestamp, 'May not unfreeze until freeze time is up');\\n        require(f.frozen, 'Can only unfreeze frozen tokens');\\n        f.frozen = false;\\n        // move tokens back into owner's address from this contract's address\\n        balances[f.owner] = balances[f.owner].plus(f.amount);\\n        balances[address(this)] = balances[address(this)].minus(f.amount);\\n        emit Transfer(address(this), msg.sender, f.amount);\\n        emit TokensUnfrozen(f.owner, f.amount, id);\\n    }\\n\\n    // burn tokens, taking them out of supply\\n    function burn(uint amount) public {\\n        balances[msg.sender] = balances[msg.sender].minus(amount);\\n        totalSupply = totalSupply.minus(amount);\\n        emit Transfer(msg.sender, address(0), amount);\\n        emit TokensBurned(msg.sender, amount);\\n    }\\n\\n    function mint(address recipient, uint amount) public bankOnly {\\n        uint totalAmount = amount * 1 ether;\\n        balances[recipient] = balances[recipient].plus(totalAmount);\\n        totalSupply = totalSupply.plus(totalAmount);\\n        emit Transfer(address(0), recipient, totalAmount);\\n        emit TokensMinted(recipient, totalAmount);\\n    }\\n\\n    // burn tokens for someone else, subject to approval\\n    function burnFor(address burned, uint amount) public {\\n        uint currentAllowance = allowed[burned][msg.sender];\\n\\n        // deduct\\n        balances[burned] = balances[burned].minus(amount);\\n\\n        // adjust allowance\\n        allowed[burned][msg.sender] = currentAllowance.minus(amount);\\n\\n        totalSupply = totalSupply.minus(amount);\\n\\n        emit Transfer(burned, address(0), amount);\\n        emit TokensBurned(burned, amount);\\n    }\\n\\n    // transfer tokens\\n    function transfer(address to, uint value) public returns (bool success)\\n    {\\n        if (to == address(0)) {\\n            burn(value);\\n        } else {\\n            // deduct\\n            balances[msg.sender] = balances[msg.sender].minus(value);\\n            // add\\n            balances[to] = balances[to].plus(value);\\n\\n            emit Transfer(msg.sender, to, value);\\n        }\\n        return true;\\n    }\\n\\n    // transfer someone else's tokens, subject to approval\\n    function transferFrom(address from, address to, uint value) public returns (bool success)\\n    {\\n        if (to == address(0)) {\\n            burnFor(from, value);\\n        } else {\\n            uint currentAllowance = allowed[from][msg.sender];\\n\\n            // deduct\\n            balances[from] = balances[from].minus(value);\\n\\n            // add\\n            balances[to] = balances[to].plus(value);\\n\\n            // adjust allowance\\n            allowed[from][msg.sender] = currentAllowance.minus(value);\\n\\n            emit Transfer(from, to, value);\\n        }\\n        return true;\\n    }\\n\\n    // retrieve the balance of address\\n    function balanceOf(address owner) public view returns (uint balance) {\\n        return balances[owner];\\n    }\\n\\n    // approve another address to transfer a specific amount of tokens\\n    function approve(address spender, uint value) public returns (bool success) {\\n        allowed[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    // incrementally increase approval, see https://github.com/ethereum/EIPs/issues/738\\n    function increaseApproval(address spender, uint value) public returns (bool success) {\\n        allowed[msg.sender][spender] = allowed[msg.sender][spender].plus(value);\\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    // incrementally decrease approval, see https://github.com/ethereum/EIPs/issues/738\\n    function decreaseApproval(address spender, uint decreaseValue) public returns (bool success) {\\n        uint oldValue = allowed[msg.sender][spender];\\n        // allow decreasing too much, to prevent griefing via front-running\\n        if (decreaseValue >= oldValue) {\\n            allowed[msg.sender][spender] = 0;\\n        } else {\\n            allowed[msg.sender][spender] = oldValue.minus(decreaseValue);\\n        }\\n        emit Approval(msg.sender, spender, allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    // retrieve allowance for a given owner, spender pair of addresses\\n    function allowance(address owner, address spender) public view returns (uint remaining) {\\n        return allowed[owner][spender];\\n    }\\n\\n    function numCoinsFrozen() public view returns (uint) {\\n        return balances[address(this)];\\n    }}\\n\"\r\n    },\r\n    \"/home/metapriest/code/my_code/dotvote/contracts/contracts/yield/LiquidityFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.7.4;\\n\\nimport \\\"../SafeMathLib.sol\\\";\\nimport \\\"../Token.sol\\\";\\n\\n// This contract is inspired by the harberger tax idea, it rewards people with FVT for burning their liquidity provider\\n// tokens.\\ncontract LiquidityFactory {\\n    using SafeMathLib for uint;\\n\\n    // this represents a single recipient of token rewards on a fixed schedule that does not depend on deposit or burn rate\\n    // it specifies an id (key to a map below) an marker for the last time it was updated, a deposit (of LP tokens) and a\\n    // burn rate of those LP tokens per block, and finally, the owner of the slot, who will receive the rewards\\n    struct Slot {\\n        uint id;\\n        uint lastUpdatedBlock;\\n        uint vacatedBlock;\\n        uint depositWei;\\n        uint burnRateWei;\\n        address owner;\\n    }\\n\\n    // rewardToken: the token that the rewards are made in\\n    // liquidityToken: the liquidity provider (LP) token\\n    // taxAddress: address to which taxes are sent\\n    struct Pool {\\n        uint id;\\n        Token liquidityToken;\\n        address taxAddress;\\n        address poolOwner;\\n        bool paused;\\n        uint pausedBlock;\\n        uint unpausedBlock;\\n        uint pausedStakers;\\n        uint maxStakers;\\n        uint numStakers;\\n        uint numSynced; // only used while paused\\n        uint minimumDepositWei;\\n        uint maximumDepositWei;\\n        uint minimumBurnRateWeiPerBlock;\\n        mapping (uint => Slot) slots;\\n    }\\n\\n    struct Metadata {\\n        bytes32 name;\\n        bytes32 ipfsHash;\\n    }\\n\\n    struct Pulse {\\n        Token rewardToken1;\\n        Token rewardToken2;\\n        uint pulseStartBlock;\\n        uint pulseWavelengthBlocks;\\n        uint pulseAmplitudeWei;\\n        uint pulseIntegral;\\n        uint pulseConstant;\\n        uint reward2WeiPerBlock;\\n    }\\n\\n    struct PoolStats {\\n        uint totalStakedWei;\\n        uint totalRewardsWei;\\n        uint totalBurnedWei;\\n        uint depositDecayWeiPerBlock; // decay only applies to vacated slots\\n        uint burnRateDecayWeiPerBlock; // decay only applies to vacated slots\\n        mapping (address => uint) totalStakedWeiFor;\\n        mapping (address => uint) totalRewardsWeiFor;\\n        mapping (address => uint) totalBurnedWeiFor;\\n        mapping (uint => uint) rewards1WeiForSession;\\n    }\\n\\n    uint public numPools;\\n    mapping (uint => Pool) public pools;\\n    mapping (uint => Metadata) public metadatas;\\n    mapping (uint => PoolStats) public poolStats;\\n    mapping (uint => Pulse) public pulses;\\n\\n    // privileged key that can change key parameters, will change to dao later\\n    address public management;\\n\\n    event SlotChangedHands(uint indexed poolId, address indexed newOwner, address indexed previousOwner, uint slotId, uint depositWei, uint burnRateWei, uint rewards1WeiForSession);\\n    event PoolAdded(uint indexed poolId, bytes32 indexed name, address indexed depositToken);\\n\\n    modifier managementOnly() {\\n        require (msg.sender == management, 'Only management may call this');\\n        _;\\n    }\\n\\n    modifier poolOwnerOnly(uint poolId) {\\n        Pool storage pool = pools[poolId];\\n        require (msg.sender == pool.poolOwner, 'Only pool owner may call this');\\n        _;\\n    }\\n\\n    modifier initializedPoolOnly(uint poolId) {\\n        Pool storage pool = pools[poolId];\\n        require(pool.id == poolId && poolId > 0, 'Uninitialized pool');\\n        _;\\n    }\\n\\n    modifier pausedAndSynced(uint poolId) {\\n        Pool storage pool = pools[poolId];\\n        require (pool.paused, 'Must be paused');\\n        require (pool.numSynced == pool.pausedStakers, 'Must sync all users');\\n        _;\\n    }\\n\\n    constructor(address mgmt) {\\n        management = mgmt;\\n    }\\n\\n    function addPool(\\n        address rewardToken1Addr,\\n        address rewardToken2Addr,\\n        address liquidityTokenAddr,\\n        address taxAddr,\\n        address poolOwner,\\n        uint rewardPerBlock2Wei,\\n        uint pulseStartDelayBlocks,\\n        uint pulseLengthBlocks,\\n        uint pulseAmplitudeWei,\\n        uint mxStkrs,\\n        uint minBurnRateWei,\\n        uint minDepositWei,\\n        uint maxDepositWei,\\n        bytes32 ipfsHash,\\n        bytes32 name) managementOnly external {\\n        numPools = numPools.plus(1);\\n        {\\n            Pool storage pool = pools[numPools];\\n            pool.id = numPools;\\n            pool.liquidityToken = Token(liquidityTokenAddr);\\n            pool.taxAddress = taxAddr;\\n            pool.poolOwner = poolOwner;\\n            pool.maxStakers = mxStkrs;\\n            pool.minimumDepositWei = minDepositWei;\\n            pool.maximumDepositWei = maxDepositWei;\\n            pool.minimumBurnRateWeiPerBlock = minBurnRateWei;\\n        }\\n        {\\n            Metadata storage metadata = metadatas[numPools];\\n            metadata.ipfsHash = ipfsHash;\\n            metadata.name = name;\\n        }\\n        {\\n            Pulse storage pulse = pulses[numPools];\\n            pulse.rewardToken1 = Token(rewardToken1Addr);\\n            pulse.rewardToken2 = Token(rewardToken2Addr);\\n            pulse.pulseStartBlock = block.number + pulseStartDelayBlocks;\\n            pulse.pulseWavelengthBlocks = pulseLengthBlocks;\\n            pulse.pulseAmplitudeWei = pulseAmplitudeWei;\\n            pulse.pulseConstant = pulseAmplitudeWei / pulseLengthBlocks.times(pulseLengthBlocks);\\n            pulse.pulseIntegral = pulseSum(pulse.pulseConstant, pulse.pulseWavelengthBlocks);\\n            pulse.reward2WeiPerBlock = rewardPerBlock2Wei;\\n        }\\n        emit PoolAdded(numPools, name, liquidityTokenAddr);\\n    }\\n\\n    function getRewards(uint poolId, uint slotId) public view returns (uint, uint) {\\n        Slot storage slot = pools[poolId].slots[slotId];\\n\\n        // unoccupied slots have no rewards\\n        if (slot.owner == address(0)) {\\n            return (0, 0);\\n        }\\n\\n        return (getRewards1(poolId, slotId), getRewards2(poolId, slotId));\\n    }\\n\\n    function getRewards2(uint poolId, uint slotId) internal view returns (uint) {\\n        Pulse storage pulse = pulses[poolId];\\n\\n        (uint referenceBlock1, uint referenceBlock2) = getReferenceBlocks(poolId, slotId);\\n        // rewards2 is linear with time, probably very small amount as advertising\\n        uint rewards2 = referenceBlock2.minus(referenceBlock1).times(pulse.reward2WeiPerBlock);\\n        return rewards2;\\n    }\\n\\n    // compute the undistributed rewards for a slot\\n    function getRewards1(uint poolId, uint slotId) internal view initializedPoolOnly(poolId) returns (uint) {\\n\\n        (uint referenceBlock1, uint referenceBlock2) = getReferenceBlocks(poolId, slotId);\\n\\n        // three parts, incomplete beginning, incomplete end and complete middle\\n        Pulse storage pulse = pulses[poolId];\\n        uint rewards1;\\n\\n        // complete middle\\n        // trim off overhang on both ends\\n        uint startPhase = referenceBlock1.minus(pulse.pulseStartBlock) % pulse.pulseWavelengthBlocks;\\n        uint startOverhang = pulse.pulseWavelengthBlocks.minus(startPhase);\\n\\n        uint blocksDiffTotal = referenceBlock2.minus(referenceBlock1);\\n\\n        uint endPhase = referenceBlock2.minus(pulse.pulseStartBlock) % pulse.pulseWavelengthBlocks;\\n        uint endingBlocks = pulse.pulseWavelengthBlocks.minus(endPhase);\\n        uint leftoverSum = pulseSum(pulse.pulseConstant, endingBlocks);\\n        // if we haven't made it to phase 0 yet\\n        if (blocksDiffTotal < startOverhang) {\\n            uint startSum = pulseSum(pulse.pulseConstant, startOverhang);\\n            rewards1 = startSum.minus(leftoverSum);\\n        } else {\\n            uint blocksDiff = blocksDiffTotal.minus(endPhase).minus(startOverhang);\\n            uint wavelengths = blocksDiff / pulse.pulseWavelengthBlocks;\\n            rewards1 = wavelengths.times(pulse.pulseIntegral);\\n\\n            // incomplete beginning of reward cycle, end of pulse\\n            if (startPhase > 0) {\\n                rewards1 = rewards1.plus(pulseSum(pulse.pulseConstant, startOverhang));\\n            }\\n\\n            // incomplete ending of reward cycle, beginning of pulse\\n            if (endPhase > 0) {\\n                rewards1 = rewards1.plus(pulse.pulseIntegral.minus(leftoverSum));\\n            }\\n        }\\n\\n        return rewards1;\\n    }\\n\\n    // compute the unapplied burn to the deposit\\n    function getBurn(uint poolId, uint slotId) public view initializedPoolOnly(poolId) returns (uint) {\\n        Slot storage slot = pools[poolId].slots[slotId];\\n        (uint referenceBlock1, uint referenceBlock2) = getReferenceBlocks(poolId, slotId);\\n        uint burn = slot.burnRateWei.times(referenceBlock2.minus(referenceBlock1));\\n        if (burn > slot.depositWei) {\\n            burn = slot.depositWei;\\n        }\\n        return burn;\\n    }\\n\\n    // this must be idempotent, it syncs both the rewards and the deposit burn atomically, and updates lastUpdatedBlock\\n    function updateSlot(uint poolId, uint slotId) public initializedPoolOnly(poolId) {\\n        Pool storage pool = pools[poolId];\\n        PoolStats storage stats = poolStats[poolId];\\n        Slot storage slot = pool.slots[slotId];\\n        require(slot.owner != address(0), 'Unoccupied slot');\\n\\n        // prevent multiple updates on same slot while paused\\n        if (pool.paused) {\\n            // these two requires prevent weird double updates that might make numSynced too high\\n            // it also means that if someone updates you while paused you cannot withdraw...\\n            require(block.number > pool.pausedBlock, 'Do not call this in the same block that you paused');\\n            require(slot.lastUpdatedBlock <= pool.pausedBlock, 'If pool is paused, can only update slot once');\\n            require(msg.sender == pool.poolOwner || msg.sender == slot.owner, 'If pool is paused, only pool owner or slot owner may call this');\\n            pool.numSynced = pool.numSynced.plus(1);\\n        }\\n\\n        Pulse storage pulse = pulses[poolId];\\n        (uint rewards1, uint rewards2) = getRewards(poolId, slotId);\\n\\n        // burn and rewards always have to update together, since they both depend on lastUpdatedBlock\\n        uint burn = getBurn(poolId, slotId);\\n\\n        // update this first to make burn and reward zero in the case of re-entrance\\n        // this must happen after getting rewards and burn since they depend on this var\\n        slot.lastUpdatedBlock = block.number;\\n\\n        if (rewards1 > 0) {\\n            // bookkeeping\\n            stats.totalRewardsWei = stats.totalRewardsWei.plus(rewards1);\\n            stats.totalRewardsWeiFor[slot.owner] = stats.totalRewardsWeiFor[slot.owner].plus(rewards1);\\n            stats.rewards1WeiForSession[slotId] = stats.rewards1WeiForSession[slotId].plus(rewards1);\\n\\n            // transfer the rewards\\n            pulse.rewardToken1.transfer(slot.owner, rewards1);\\n            pulse.rewardToken2.transfer(slot.owner, rewards2);\\n        }\\n\\n        if (burn > 0) {\\n            // adjust deposit first\\n            slot.depositWei = slot.depositWei.minus(burn);\\n\\n            // bookkeeping\\n            stats.totalBurnedWei = stats.totalBurnedWei.plus(burn);\\n            stats.totalBurnedWeiFor[slot.owner] = stats.totalBurnedWeiFor[slot.owner].plus(burn);\\n\\n            // pay the tax!\\n            pool.liquidityToken.transfer(pool.taxAddress, burn);\\n        }\\n    }\\n\\n    // most important function for users, allows them to start receiving rewards\\n    function claimSlot(uint poolId, uint slotId, uint newBurnRate, uint newDeposit) external {\\n        Pool storage pool = pools[poolId];\\n        PoolStats storage stats = poolStats[poolId];\\n        require(slotId > 0, 'Slot id must be positive');\\n        require(slotId <= pool.maxStakers, 'Slot id out of range');\\n        require(newBurnRate >= pool.minimumBurnRateWeiPerBlock, 'Burn rate must meet or exceed minimum');\\n        require(newDeposit >= pool.minimumDepositWei, 'Deposit must meet or exceed minimum');\\n        require(newDeposit <= pool.maximumDepositWei, 'Deposit must not exceed maximum');\\n        require(pool.paused == false, 'Must be unpaused');\\n        require(pool.id == poolId && poolId > 0, 'Uninitialized pool');\\n\\n        Slot storage slot = pool.slots[slotId];\\n\\n        // count the stakers\\n        if (slot.owner == address(0)) {\\n            // assign id since this may be the first time\\n            slot.id = slotId;\\n\\n            // set last updated block, this happens in updateSlot but that's the other branch\\n            slot.lastUpdatedBlock = block.number;\\n\\n            // check that we meet-or-exceed the linearly-decayed deposit and burn rates\\n            (uint depositMin, uint burnRateMin) = getClaimMinimums(poolId, slotId);\\n            bool betterDeal = newBurnRate >= burnRateMin && newDeposit >= depositMin;\\n            require(betterDeal, 'You must meet or exceed the current burn rate and deposit');\\n\\n            // increment counter\\n            pool.numStakers = pool.numStakers.plus(1);\\n\\n        } else {\\n            updateSlot(poolId, slotId);\\n\\n            //  this must go after updateSlot to sync the deposit variable\\n            bool betterDeal = newBurnRate > slot.burnRateWei && (newDeposit > slot.depositWei || newDeposit == pool.maximumDepositWei);\\n            require(betterDeal || slot.depositWei == 0, 'You must outbid the current owner');\\n\\n            // bookkeeping\\n            stats.totalStakedWei = stats.totalStakedWei.minus(slot.depositWei);\\n            stats.totalStakedWeiFor[slot.owner] = stats.totalStakedWeiFor[slot.owner].minus(slot.depositWei);\\n\\n            // this is probably not necessary, but we do it to be tidy\\n            slot.vacatedBlock = 0;\\n\\n            // if there's any deposit left,\\n            if (slot.depositWei > 0) {\\n                pool.liquidityToken.transfer(slot.owner, slot.depositWei);\\n            }\\n        }\\n\\n        emit SlotChangedHands(poolId, msg.sender, slot.owner, slotId, newDeposit, newBurnRate, stats.rewards1WeiForSession[slotId]);\\n        stats.rewards1WeiForSession[slotId] = 0;\\n\\n        // set new owner, burn rate and deposit\\n        slot.owner = msg.sender;\\n        slot.burnRateWei = newBurnRate;\\n        slot.depositWei = newDeposit;\\n\\n        // bookkeeping\\n        stats.totalStakedWei = stats.totalStakedWei.plus(newDeposit);\\n        stats.totalStakedWeiFor[msg.sender] = stats.totalStakedWeiFor[msg.sender].plus(newDeposit);\\n\\n        // transfer the tokens!\\n        if (newDeposit > 0) {\\n            pool.liquidityToken.transferFrom(msg.sender, address(this), newDeposit);\\n        }\\n    }\\n\\n    // separates user from slot, if either voluntary or delinquent\\n    function withdrawFromSlot(uint poolId, uint slotId) external initializedPoolOnly(poolId) {\\n        Pool storage pool = pools[poolId];\\n\\n        PoolStats storage stats = poolStats[poolId];\\n        Slot storage slot = pool.slots[slotId];\\n\\n        // prevent double-withdrawals\\n        require(slot.owner != address(0), 'Slot unoccupied');\\n\\n        // sync deposit variable (this increments numSynced)\\n        updateSlot(poolId, slotId);\\n\\n        // anyone can withdraw delinquents, but non-delinquents can only be withdrawn by themselves\\n        bool withdrawable = slot.owner == msg.sender || slot.depositWei == 0;\\n        require(withdrawable, 'Only owner can call this unless user is delinquent');\\n\\n        // must do this before rewards1WeiForSession gets zeroed out\\n        emit SlotChangedHands(poolId, address(0), slot.owner, slotId, 0, 0, stats.rewards1WeiForSession[slotId]);\\n        stats.rewards1WeiForSession[slotId] = 0;\\n\\n        // decrement the number of stakers\\n        pool.numStakers = pool.numStakers.minus(1);\\n\\n        // record what block we vacated in to compute linear decay\\n        slot.vacatedBlock = block.number;\\n\\n        // zero out owner, closing re-entrance gate\\n        slot.owner = address(0);\\n\\n        // don't set deposit or burn rate to 0 so we can compute linear decay\\n\\n        // if there's any deposit left,\\n        if (slot.depositWei > 0) {\\n            pool.liquidityToken.transfer(slot.owner, slot.depositWei);\\n        }\\n    }\\n\\n    // ======================== PAUSE =============================\\n\\n    function pausePool(uint poolId) external poolOwnerOnly(poolId) initializedPoolOnly(poolId) {\\n        Pool storage pool = pools[poolId];\\n        require(pool.paused == false, 'Already paused');\\n        pool.paused = true;\\n        pool.pausedBlock = block.number;\\n        pool.pausedStakers = pool.numStakers;\\n        pool.unpausedBlock = 0;\\n    }\\n\\n    function unpausePool(uint poolId) external poolOwnerOnly(poolId) pausedAndSynced(poolId) {\\n        Pool storage pool = pools[poolId];\\n        pool.paused = false;\\n        pool.pausedBlock = 0;\\n        pool.numSynced = 0;\\n        pool.pausedStakers = 0;\\n        pool.unpausedBlock = block.number;\\n    }\\n\\n    // ======================== GETTERS =============================\\n\\n    function getClaimMinimums(uint poolId, uint slotId) public view returns (uint, uint) {\\n        Slot memory slot = pools[poolId].slots[slotId];\\n        if (slot.owner != address(0)) {\\n            return (slot.depositWei, slot.burnRateWei);\\n        } else {\\n            PoolStats storage stats = poolStats[poolId];\\n            uint blocksDiff = block.number.minus(slot.vacatedBlock);\\n            uint depositDecay = blocksDiff.times(stats.depositDecayWeiPerBlock);\\n            if (depositDecay > slot.depositWei) {\\n                depositDecay = slot.depositWei;\\n            }\\n\\n            uint burnRateDecay = blocksDiff.times(stats.burnRateDecayWeiPerBlock);\\n            if (burnRateDecay > slot.burnRateWei) {\\n                burnRateDecay = slot.burnRateWei;\\n            }\\n\\n            return (slot.depositWei.minus(depositDecay), slot.burnRateWei.minus(burnRateDecay));\\n        }\\n    }\\n\\n    function getSlot(uint poolId, uint slotId) external view returns (uint, uint, uint, uint, uint, address) {\\n        Slot memory slot = pools[poolId].slots[slotId];\\n        PoolStats storage stats = poolStats[poolId];\\n        return (slot.lastUpdatedBlock, slot.depositWei, slot.burnRateWei, stats.rewards1WeiForSession[slotId], slot.vacatedBlock, slot.owner);\\n    }\\n\\n    function getUserStats(uint poolId, address user) external view returns (uint, uint, uint) {\\n        PoolStats storage stats = poolStats[poolId];\\n        return (stats.totalStakedWeiFor[user], stats.totalRewardsWeiFor[user], stats.totalBurnedWeiFor[user]);\\n    }\\n\\n    function getReferenceBlocks(uint poolId, uint slotId) internal view returns (uint, uint) {\\n        Pool storage pool = pools[poolId];\\n        Slot memory slot = pool.slots[slotId];\\n\\n        uint referenceBlock1 = slot.lastUpdatedBlock;\\n        uint referenceBlock2 = block.number;\\n        if (pool.paused) {\\n            referenceBlock2 = pool.pausedBlock;\\n        } else if (slot.lastUpdatedBlock < pool.unpausedBlock) {\\n            referenceBlock1 = pool.unpausedBlock;\\n        }\\n\\n        return (referenceBlock1, referenceBlock2);\\n    }\\n\\n    // compute the sum of the rewards per pulse\\n    function pulseSum(uint coeff, uint wavelength) public pure returns (uint) {\\n        // sum of squares formula\\n        return coeff.times(wavelength.times(wavelength.plus(1))).times(wavelength.times(2).plus(1)) / 6;\\n    }\\n\\n    // ======================== SETTERS =============================\\n\\n    function setMaxStakers(uint poolId, uint newMaxStakers) external poolOwnerOnly(poolId)  {\\n        Pool storage pool = pools[poolId];\\n        pool.maxStakers = newMaxStakers;\\n    }\\n\\n    // change the minimum deposit to acquire a slot\\n    function setMinDeposit(uint poolId, uint newMinDeposit) external poolOwnerOnly(poolId)  {\\n        Pool storage pool = pools[poolId];\\n        pool.minimumDepositWei = newMinDeposit;\\n    }\\n\\n    // change the maximum deposit\\n    function setMaxDeposit(uint poolId, uint newMaxDeposit) external poolOwnerOnly(poolId)  {\\n        Pool storage pool = pools[poolId];\\n        pool.maximumDepositWei = newMaxDeposit;\\n    }\\n\\n    // change the minimum burn rate to acquire a slot\\n    function setMinBurnRate(uint poolId, uint newMinBurnRate) external poolOwnerOnly(poolId)  {\\n        Pool storage pool = pools[poolId];\\n        pool.minimumBurnRateWeiPerBlock = newMinBurnRate;\\n    }\\n\\n    // change the length of a pulse, should be done with care, probably should update all slots simultaneously\\n    function setPulseWavelength(uint poolId, uint newWavelength) external poolOwnerOnly(poolId)  {\\n        Pulse storage pulse = pulses[poolId];\\n        pulse.pulseWavelengthBlocks = newWavelength;\\n        pulse.pulseConstant = pulse.pulseAmplitudeWei / pulse.pulseWavelengthBlocks.times(pulse.pulseWavelengthBlocks);\\n        pulse.pulseIntegral = pulseSum(pulse.pulseConstant, newWavelength);\\n    }\\n\\n    // change the maximum height of the reward curve\\n    function setPulseAmplitude(uint poolId, uint newAmplitude) external poolOwnerOnly(poolId) pausedAndSynced(poolId) {\\n        Pulse storage pulse = pulses[poolId];\\n        pulse.pulseAmplitudeWei = newAmplitude;\\n        pulse.pulseConstant = pulse.pulseAmplitudeWei / pulse.pulseWavelengthBlocks.times(pulse.pulseWavelengthBlocks);\\n        pulse.pulseIntegral = pulseSum(pulse.pulseConstant, pulse.pulseWavelengthBlocks);\\n    }\\n\\n    // only management can reset management key\\n    function setManagement(address newMgmt) managementOnly external {\\n        management = newMgmt;\\n    }\\n\\n    // only management can change tax address\\n    function setTaxAddress(uint poolId, address newTaxAddress) managementOnly external {\\n        Pool storage pool = pools[poolId];\\n        pool.taxAddress = newTaxAddress;\\n    }\\n\\n    function setReward2PerBlock(uint poolId, uint newReward) managementOnly external {\\n        Pulse storage pulse = pulses[poolId];\\n        pulse.reward2WeiPerBlock = newReward;\\n    }\\n\\n    // only pool owner can change pool owner key\\n    function setPoolOwner(uint poolId, address newOwner) external poolOwnerOnly(poolId)  {\\n        Pool storage pool = pools[poolId];\\n        pool.poolOwner = newOwner;\\n    }\\n\\n    function setDecays(uint poolId, uint burnRateDecayWeiPerBlock, uint depositDecayWeiPerBlock) external poolOwnerOnly(poolId) initializedPoolOnly(poolId)  {\\n        PoolStats storage stats = poolStats[poolId];\\n        stats.burnRateDecayWeiPerBlock = burnRateDecayWeiPerBlock;\\n        stats.depositDecayWeiPerBlock = depositDecayWeiPerBlock;\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"/home/metapriest/code/my_code/dotvote/contracts/contracts/SafeMathLib.sol\": {\r\n        \"SafeMathLib\": \"0x82d7630c5EB722557De6D76575C9a7b8DE718500\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"mgmt\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositToken\",\"type\":\"address\"}],\"name\":\"PoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositWei\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burnRateWei\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewards1WeiForSession\",\"type\":\"uint256\"}],\"name\":\"SlotChangedHands\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardToken1Addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken2Addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityTokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taxAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock2Wei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pulseStartDelayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pulseLengthBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pulseAmplitudeWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mxStkrs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBurnRateWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDepositWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDepositWei\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newBurnRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newDeposit\",\"type\":\"uint256\"}],\"name\":\"claimSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"getBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"getClaimMinimums\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"getSlot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"management\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"metadatas\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"ipfsHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"pausePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStakedWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardsWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBurnedWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDecayWeiPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnRateDecayWeiPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"contract Token\",\"name\":\"liquidityToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taxAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"pausedBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unpausedBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pausedStakers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numStakers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numSynced\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumDepositWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumDepositWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumBurnRateWeiPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coeff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wavelength\",\"type\":\"uint256\"}],\"name\":\"pulseSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pulses\",\"outputs\":[{\"internalType\":\"contract Token\",\"name\":\"rewardToken1\",\"type\":\"address\"},{\"internalType\":\"contract Token\",\"name\":\"rewardToken2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pulseStartBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pulseWavelengthBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pulseAmplitudeWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pulseIntegral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pulseConstant\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward2WeiPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnRateDecayWeiPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDecayWeiPerBlock\",\"type\":\"uint256\"}],\"name\":\"setDecays\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMgmt\",\"type\":\"address\"}],\"name\":\"setManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxDeposit\",\"type\":\"uint256\"}],\"name\":\"setMaxDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxStakers\",\"type\":\"uint256\"}],\"name\":\"setMaxStakers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMinBurnRate\",\"type\":\"uint256\"}],\"name\":\"setMinBurnRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMinDeposit\",\"type\":\"uint256\"}],\"name\":\"setMinDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setPoolOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newAmplitude\",\"type\":\"uint256\"}],\"name\":\"setPulseAmplitude\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newWavelength\",\"type\":\"uint256\"}],\"name\":\"setPulseWavelength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newReward\",\"type\":\"uint256\"}],\"name\":\"setReward2PerBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newTaxAddress\",\"type\":\"address\"}],\"name\":\"setTaxAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"unpausePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"updateSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slotId\",\"type\":\"uint256\"}],\"name\":\"withdrawFromSlot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LiquidityFactory","CompilerVersion":"v0.7.4+commit.3f05b770","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000288fe43139741f91a8cbb6f4add83811c794851b","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}