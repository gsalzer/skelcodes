{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/cory/Code/pan/scammer-contracts/contracts/Metadata.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n/**\\n* Metadata contract is upgradeable and returns metadata about Token\\n*/\\n\\nimport \\\"./helpers/strings.sol\\\";\\n\\ncontract Metadata {\\n    using strings for *;\\n\\n    string private baseUrl;\\n\\n    constructor(string memory _baseUrl) public {\\n        baseUrl = _baseUrl;\\n    }\\n\\n    function tokenURI(uint _tokenId) public view returns (string memory _infoUrl) {\\n        string memory basePath = \\\"/v1/metadata/\\\";\\n        string memory base = baseUrl.toSlice().concat(basePath.toSlice());\\n        string memory id = uint2str(_tokenId);\\n        return base.toSlice().concat(id.toSlice());\\n    }\\n\\n    function contractURI() public view returns (string memory) {\\n        string memory path = \\\"/v1/metadata\\\";\\n        return baseUrl.toSlice().concat(path.toSlice());\\n    }\\n\\n    function uint2str(uint i) internal pure returns (string memory) {\\n        if (i == 0) return \\\"0\\\";\\n        uint j = i;\\n        uint length;\\n        while (j != 0) {\\n            length++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(length);\\n        uint k = length - 1;\\n        while (i != 0) {\\n            uint _uint = 48 + i % 10;\\n            bstr[k--] = toBytes(_uint)[31];\\n            i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n    function toBytes(uint256 x) public pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly { mstore(add(b, 32), x) }\\n    }\\n}\"\r\n    },\r\n    \"/Users/cory/Code/pan/scammer-contracts/contracts/Scammer.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/ownership/Ownable.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/access/Roles.sol\\\";\\nimport \\\"./Metadata.sol\\\";\\n\\n/**\\n// ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! !\\n//    \\n//    OOOOOO    OOOOOOO   OOOOOO   OOOOOOOOOO   OOOOOOOOOO   OOOOOOOO  OOOOOOO \\n//   OOOOOOO   OOOOOOOO  OOOOOOOO  OOOOOOOOOOO  OOOOOOOOOOO  OOOOOOOO  OOOOOOOO\\n//   !OO       !OO       OO!  OOO  OO! OO! OO!  OO! OO! OO!  OO!       OO!  OOO\\n//   !O!       !O!       !O!  O!O  !O! !O! !O!  !O! !O! !O!  !O!       !O!  O!O\\n//   !!OO!!    !O!       O!O!O!O!  O!! !!O O!O  O!! !!O O!O  O!!!:!    O!O!!O! \\n//    !!O!!!   !!!       !!!O!!!!  !O!   ! !O!  !O!   ! !O!  !!!!!:    !!O!O!  \\n//        !:!  :!!       !!:  !!!  !!:     !!:  !!:     !!:  !!:       !!: :!! \\n//       !:!   :!:       :!:  !:!  :!:     :!:  :!:     :!:  :!:       :!:  !:!\\n//   :::: ::    ::: :::  ::   :::  :::     ::   :::     ::    :: ::::  ::   :::\\n//   :: : :     :: :: :   :   : :   :      :     :      :    : :: ::    :   : :\\n//\\n// .. SCAMMER.MARKET .. 2021\\n// .. AMNESIA SCANNER .. PWR .. WURMHUMUSFABRIK MARIPOSA\\n//\\n// : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : : :\\n**/\\n\\ncontract Scammer is ERC721Full, Ownable {\\n    using Roles for Roles.Role;\\n    Roles.Role private _admins;\\n    uint8 admins;\\n\\n    address public metadata;\\n    address public controller;\\n\\n    modifier onlyAdminOrController() {\\n        require((_admins.has(msg.sender) || msg.sender == controller), \\\"DOES_NOT_HAVE_ADMIN_OR_CONTROLLER_ROLE\\\");\\n        _;\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(_admins.has(msg.sender), \\\"DOES_NOT_HAVE_ADMIN_ROLE\\\");\\n        _;\\n    }\\n    \\n    /**\\n    * @dev Checks msg.sender can transfer a token, by being owner, approved, operator or controller\\n    * @param _tokenId uint256 ID of the token to validate\\n    */\\n    modifier canTransfer(uint256 _tokenId) {\\n        require(_isApprovedOrOwner(msg.sender, _tokenId) || msg.sender == controller);\\n        _;\\n    }\\n\\n    constructor(string memory name, string memory symbol, address _metadata) public ERC721Full(name, symbol) {\\n        metadata = _metadata;\\n        _admins.add(msg.sender);\\n        admins += 1;\\n    }\\n\\n    function exists(uint256 tokenId) external view returns (bool) {\\n        return _exists(tokenId);\\n    }\\n    \\n    function mint(address recepient, uint256 tokenId) public onlyAdminOrController {\\n        _mint(recepient, tokenId);\\n    }\\n    function burn(uint256 tokenId) public onlyAdminOrController {\\n        _burn(ownerOf(tokenId), tokenId);\\n    }\\n    function updateMetadata(address _metadata) public onlyAdminOrController {\\n        metadata = _metadata;\\n    }\\n    function updateController(address _controller) public onlyAdminOrController {\\n        controller = _controller;\\n    }\\n\\n    function addAdmin(address _admin) public onlyOwner {\\n        _admins.add(_admin);\\n        admins += 1;\\n    }\\n    function removeAdmin(address _admin) public onlyOwner {\\n        require(admins > 1, \\\"CANT_REMOVE_LAST_ADMIN\\\");\\n        _admins.remove(_admin);\\n        admins -= 1;\\n    }\\n\\n    function tokenURI(uint _tokenId) external view returns (string memory _infoUrl) {\\n        return Metadata(metadata).tokenURI(_tokenId);\\n    }\\n\\n    function contractURI() external view returns (string memory _infoUrl) {\\n        return Metadata(metadata).contractURI();\\n    }\\n\\n    /**\\n    * @dev Moves Eth to a certain address for use in the ScammerController\\n    * @param _to The address to receive the Eth.\\n    * @param _amount The amount of Eth to be transferred.\\n    */\\n    function moveEth(address payable _to, uint256 _amount) public onlyAdminOrController {\\n        require(_amount <= address(this).balance);\\n        _to.transfer(_amount);\\n    }\\n    /**\\n    * @dev Moves Token to a certain address for use in the ScammerController\\n    * @param _to The address to receive the Token.\\n    * @param _amount The amount of Token to be transferred.\\n    * @param _token The address of the Token to be transferred.\\n    */\\n    function moveToken(address _to, uint256 _amount, address _token) public onlyAdminOrController returns (bool) {\\n        require(_amount <= IERC20(_token).balanceOf(address(this)));\\n        return IERC20(_token).transfer(_to, _amount);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/Users/cory/Code/pan/scammer-contracts/contracts/ScammerController.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * The ScammerController is an upgradeable endpoint for controlling Scammer.sol\\n */\\n\\nimport \\\"./Scammer.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/math/SafeMath.sol\\\";\\nimport \\\"openzeppelin-solidity/contracts/ownership/Ownable.sol\\\";\\n\\ncontract ScammerController is Ownable {\\n\\n    event newCollection(uint256 collectionId, uint256 editions, uint256 price, bool paused);\\n    event updatedCollection(uint256 collectionId, uint256 editions, uint256 price, CollectionMode mode);\\n    event editionBought(uint256 collectionId, uint256 editionId, uint256 tokenId, address recipient, uint256 paid, uint256 artistReceived, uint256 adminReceived);\\n\\n    using SafeMath for uint256;\\n\\n    uint256 constant MAX_EDITIONS = 1000000;\\n    uint256 public latestCollectionId;\\n\\n    mapping (address => uint) public vouchers;\\n\\n    enum CollectionMode { PAUSED, VOUCHER_ONLY_MODE, UNPAUSED }\\n\\n    mapping (uint256 => Collection) public collections;\\n    struct Collection {\\n        bool exists;\\n        CollectionMode mode;\\n        bool voucherOnlyMode;\\n        uint256 editions;\\n        uint256 price;\\n    }\\n\\n    uint256 public adminSplit = 20;\\n\\n    address payable public adminWallet;\\n    address payable public artistWallet;\\n    bool public paused;\\n    Scammer public scammer;\\n\\n    modifier notPaused() {\\n        require(!paused, \\\"Must not be paused\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        Scammer _scammer,\\n        address payable _adminWallet,\\n        address payable _artistWallet,\\n        address[] memory voucherRecipients\\n    ) public {\\n        scammer = _scammer;\\n        adminWallet = _adminWallet;\\n        artistWallet = _artistWallet;\\n\\n        for (uint i = 0; i < voucherRecipients.length; i++) {\\n            uint numVouchers = vouchers[voucherRecipients[i]].add(1);\\n            vouchers[voucherRecipients[i]] = numVouchers;\\n        }\\n    }\\n\\n    function addCollection(uint256 editions, uint256 price, bool _paused) public onlyOwner {\\n        require(editions < MAX_EDITIONS, \\\"MAX_EDITIONS_EXCEEDED\\\");\\n\\n        latestCollectionId += 1;\\n\\n        collections[latestCollectionId].exists = true;\\n        collections[latestCollectionId].editions = editions;\\n        collections[latestCollectionId].price = price;\\n        if (_paused) {\\n            collections[latestCollectionId].mode = CollectionMode.PAUSED;\\n        } else {\\n            collections[latestCollectionId].mode = CollectionMode.UNPAUSED;\\n        }\\n        emit newCollection(latestCollectionId, editions, price, _paused);\\n    }\\n\\n    function getAllTokenIds() external view returns (uint256[] memory) {\\n        uint totalSupply = scammer.totalSupply();\\n\\n        uint256[] memory tokenIds = new uint256[](totalSupply);\\n\\n        for (uint i = 0; i < totalSupply; i++) {\\n            tokenIds[i] = scammer.tokenByIndex(i);\\n        }\\n\\n        return tokenIds;\\n    }\\n\\n    function setVoucherOnlyMode(uint256 collectionId) public onlyOwner {\\n        require(collections[collectionId].exists, \\\"COLLECTION_DOES_NOT_EXIST\\\");\\n        collections[collectionId].mode = CollectionMode.VOUCHER_ONLY_MODE;\\n        emit updatedCollection(collectionId, collections[collectionId].editions, collections[collectionId].price, collections[collectionId].mode);\\n    }\\n\\n    function updateCollectionPaused(uint256 collectionId, bool _paused) public onlyOwner {\\n        require(collections[collectionId].exists, \\\"COLLECTION_DOES_NOT_EXIST\\\");\\n        if (_paused) {\\n            collections[collectionId].mode = CollectionMode.PAUSED;\\n        } else {\\n            collections[collectionId].mode = CollectionMode.UNPAUSED;\\n        }\\n        emit updatedCollection(collectionId, collections[collectionId].editions, collections[collectionId].price, collections[collectionId].mode);\\n    }\\n\\n    function updateCollectionEditions(uint256 collectionId, uint256 _editions) public onlyOwner {\\n        require(collections[collectionId].exists, \\\"COLLECTION_DOES_NOT_EXIST\\\");\\n        require(collections[collectionId].editions < _editions, \\\"EDITIONS_MUST_INCREASE\\\");\\n        collections[collectionId].editions = _editions;\\n        emit updatedCollection(collectionId, collections[collectionId].editions, collections[collectionId].price, collections[collectionId].mode);\\n    }\\n\\n    function updateCollectionPrice(uint256 collectionId, uint256 _price) public onlyOwner {\\n        require(collections[collectionId].exists, \\\"COLLECTION_DOES_NOT_EXIST\\\");\\n        collections[collectionId].price = _price;\\n        emit updatedCollection(collectionId, collections[collectionId].editions, collections[collectionId].price, collections[collectionId].mode);\\n    }\\n\\n    function redeem(address recipient, uint256 tokenId) public notPaused returns (bool) {\\n        uint256 collectionId = tokenId.div(MAX_EDITIONS);\\n        uint256 editionId = tokenId.mod(MAX_EDITIONS);\\n\\n        require(collections[collectionId].mode == CollectionMode.UNPAUSED || collections[collectionId].mode == CollectionMode.VOUCHER_ONLY_MODE, \\\"REDEEM_NOT_ENABLED\\\");\\n        require(collections[collectionId].exists, \\\"INVALID_TOKEN_ID\\\");\\n        require(editionId < collections[collectionId].editions, \\\"INVALID_TOKEN_ID\\\");\\n        require(vouchers[msg.sender] > 0 , \\\"USER_HAS_NO_VOUCHERS\\\");\\n\\n        scammer.mint(recipient, tokenId);\\n\\n        uint numVouchers = vouchers[msg.sender].sub(1);\\n        vouchers[msg.sender] = numVouchers;\\n        \\n        emit editionBought(collectionId, editionId, tokenId, recipient,  0, 0, 0);\\n    }\\n\\n    function buy(address recipient, uint256 tokenId) public payable notPaused returns (bool) {\\n        uint256 collectionId = tokenId.div(MAX_EDITIONS);\\n        uint256 editionId = tokenId.mod(MAX_EDITIONS);\\n\\n        require(collections[collectionId].mode == CollectionMode.UNPAUSED, \\\"BUY_NOT_ENABLED\\\");\\n        require(collections[collectionId].exists, \\\"INVALID_TOKEN_ID\\\");\\n        require(editionId < collections[collectionId].editions, \\\"INVALID_TOKEN_ID\\\");\\n        require(msg.value == collections[collectionId].price , \\\"DID_NOT_SEND_PRICE\\\");\\n\\n        scammer.mint(recipient, tokenId);\\n        \\n        uint256 adminReceives = msg.value.mul(adminSplit).div(100);\\n        uint256 artistReceives = msg.value.sub(adminReceives);\\n\\n        adminWallet.transfer(adminReceives);\\n        artistWallet.transfer(artistReceives);\\n\\n        emit editionBought(collectionId, editionId, tokenId, recipient,  collections[collectionId].price, artistReceives, adminReceives);\\n    }\\n\\n    function mintVoucher(address recipient) public onlyOwner {\\n        uint numVouchers = vouchers[recipient].add(1);\\n        vouchers[recipient] = numVouchers;\\n    }\\n\\n    function updateNumVouchers(address recipient, uint numVouchers) public onlyOwner {\\n        vouchers[recipient] = numVouchers;\\n    }\\n\\n    function burnAllVouchers(address recipient) public onlyOwner {\\n        vouchers[recipient] = 0;\\n    }\\n\\n    function numVouchers(address recipient) external view returns (uint) {\\n        return vouchers[recipient];\\n    }\\n\\n    function updateAdminSplit(uint256 _adminSplit) public onlyOwner {\\n        require(_adminSplit <= 100, \\\"SPLIT_MUST_BE_LTE_100\\\");\\n        adminSplit = _adminSplit;\\n    }\\n\\n    function updateAdminWallet(address payable _adminWallet) public onlyOwner {\\n        adminWallet = _adminWallet;\\n    }\\n\\n    function updateArtistWallet(address payable _artistWallet) public onlyOwner {\\n        artistWallet = _artistWallet;\\n    }\\n\\n    function updatePaused(bool _paused) public onlyOwner {\\n        paused = _paused;\\n    }\\n}\"\r\n    },\r\n    \"/Users/cory/Code/pan/scammer-contracts/contracts/helpers/strings.sol\": {\r\n      \"content\": \"/*\\n * @title String & slice utility library for Solidity contracts.\\n * @author Nick Johnson <arachnid@notdot.net>\\n */\\n\\npragma solidity ^0.5.0;\\n\\nlibrary strings {\\n    struct slice {\\n        uint _len;\\n        uint _ptr;\\n    }\\n\\n    function memcpy(uint dest, uint src, uint len) private pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire string.\\n     * @param self The string to make a slice from.\\n     * @return A newly allocated slice containing the entire string.\\n     */\\n    function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns a newly allocated string containing the concatenation of\\n     *      `self` and `other`.\\n     * @param self The first slice to concatenate.\\n     * @param other The second slice to concatenate.\\n     * @return The concatenation of the two strings.\\n     */\\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\\n        string memory ret = new string(self._len + other._len);\\n        uint retptr;\\n        assembly {\\n            retptr := add(ret, 32)\\n        }\\n        memcpy(retptr, self._ptr, self._len);\\n        memcpy(retptr + self._len, other._ptr, other._len);\\n        return ret;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/access/Roles.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address => bool) bearer;\\n    }\\n\\n    /**\\n     * @dev give an account access to this role\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(account != address(0));\\n        require(!has(role, account));\\n\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev remove an account's access to this role\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(account != address(0));\\n        require(has(role, account));\\n\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev check if an account has this role\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0));\\n        return role.bearer[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title ERC165\\n * @author Matt Condon (@shrugs)\\n * @dev Implements ERC165 using a lookup table.\\n */\\ncontract ERC165 is IERC165 {\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n    /**\\n     * 0x01ffc9a7 ===\\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\\n     */\\n\\n    /**\\n     * @dev a mapping of interface id to whether or not it's supported\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    /**\\n     * @dev A contract implementing SupportsInterfaceWithLookup\\n     * implement ERC165 itself\\n     */\\n    constructor () internal {\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev implement supportsInterface(bytes4) using a lookup table\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev internal method for registering an interface\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal {\\n        require(interfaceId != 0xffffffff);\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title IERC165\\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\\n */\\ninterface IERC165 {\\n    /**\\n     * @notice Query if a contract implements an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @dev Interface identification is specified in ERC-165. This function\\n     * uses less than 30,000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title SafeMath\\n * @dev Unsigned math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    /**\\n    * @dev Multiplies two unsigned integers, reverts on overflow.\\n    */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\\n    */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two unsigned integers, reverts on overflow.\\n    */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    constructor () internal {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == _owner;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to relinquish control of the contract.\\n     * @notice Renouncing to ownership will leave the contract without an owner.\\n     * It will not be possible to call the functions with the `onlyOwner`\\n     * modifier anymore.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0));\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721 is ERC165, IERC721 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from token ID to owner\\n    mapping (uint256 => address) private _tokenOwner;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to number of owned token\\n    mapping (address => uint256) private _ownedTokensCount;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n    /*\\n     * 0x80ac58cd ===\\n     *     bytes4(keccak256('balanceOf(address)')) ^\\n     *     bytes4(keccak256('ownerOf(uint256)')) ^\\n     *     bytes4(keccak256('approve(address,uint256)')) ^\\n     *     bytes4(keccak256('getApproved(uint256)')) ^\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\\n     */\\n\\n    constructor () public {\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address\\n     * @param owner address to query the balance of\\n     * @return uint256 representing the amount owned by the passed address\\n     */\\n    function balanceOf(address owner) public view returns (uint256) {\\n        require(owner != address(0));\\n        return _ownedTokensCount[owner];\\n    }\\n\\n    /**\\n     * @dev Gets the owner of the specified token ID\\n     * @param tokenId uint256 ID of the token to query the owner of\\n     * @return owner address currently marked as the owner of the given token ID\\n     */\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\n        address owner = _tokenOwner[tokenId];\\n        require(owner != address(0));\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev Approves another address to transfer the given token ID\\n     * The zero address indicates there is no approved address.\\n     * There can only be one approved address per token at a given time.\\n     * Can only be called by the token owner or an approved operator.\\n     * @param to address to be approved for the given token ID\\n     * @param tokenId uint256 ID of the token to be approved\\n     */\\n    function approve(address to, uint256 tokenId) public {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner);\\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\\n\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Gets the approved address for a token ID, or zero if no address set\\n     * Reverts if the token ID does not exist.\\n     * @param tokenId uint256 ID of the token to query the approval of\\n     * @return address currently approved for the given token ID\\n     */\\n    function getApproved(uint256 tokenId) public view returns (address) {\\n        require(_exists(tokenId));\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev Sets or unsets the approval of a given operator\\n     * An operator is allowed to transfer all tokens of the sender on their behalf\\n     * @param to operator address to set the approval\\n     * @param approved representing the status of the approval to be set\\n     */\\n    function setApprovalForAll(address to, bool approved) public {\\n        require(to != msg.sender);\\n        _operatorApprovals[msg.sender][to] = approved;\\n        emit ApprovalForAll(msg.sender, to, approved);\\n    }\\n\\n    /**\\n     * @dev Tells whether an operator is approved by a given owner\\n     * @param owner owner address which you want to query the approval of\\n     * @param operator operator address which you want to query the approval of\\n     * @return bool whether the given operator is approved by the given owner\\n     */\\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Transfers the ownership of a given token ID to another address\\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\\n     * Requires the msg sender to be the owner, approved, or operator\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n    */\\n    function transferFrom(address from, address to, uint256 tokenId) public {\\n        require(_isApprovedOrOwner(msg.sender, tokenId));\\n\\n        _transferFrom(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Safely transfers the ownership of a given token ID to another address\\n     * If the target address is a contract, it must implement `onERC721Received`,\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     *\\n     * Requires the msg sender to be the owner, approved, or operator\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n    */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Safely transfers the ownership of a given token ID to another address\\n     * If the target address is a contract, it must implement `onERC721Received`,\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * Requires the msg sender to be the owner, approved, or operator\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes data to send along with a safe transfer check\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\\n        transferFrom(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data));\\n    }\\n\\n    /**\\n     * @dev Returns whether the specified token exists\\n     * @param tokenId uint256 ID of the token to query the existence of\\n     * @return whether the token exists\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        address owner = _tokenOwner[tokenId];\\n        return owner != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether the given spender can transfer a given token ID\\n     * @param spender address of the spender to query\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @return bool whether the msg.sender is approved for the given token ID,\\n     *    is an operator of the owner, or is the owner of the token\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Internal function to mint a new token\\n     * Reverts if the given token ID already exists\\n     * @param to The address that will own the minted token\\n     * @param tokenId uint256 ID of the token to be minted\\n     */\\n    function _mint(address to, uint256 tokenId) internal {\\n        require(to != address(0));\\n        require(!_exists(tokenId));\\n\\n        _tokenOwner[tokenId] = to;\\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn a specific token\\n     * Reverts if the token does not exist\\n     * Deprecated, use _burn(uint256) instead.\\n     * @param owner owner of the token to burn\\n     * @param tokenId uint256 ID of the token being burned\\n     */\\n    function _burn(address owner, uint256 tokenId) internal {\\n        require(ownerOf(tokenId) == owner);\\n\\n        _clearApproval(tokenId);\\n\\n        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);\\n        _tokenOwner[tokenId] = address(0);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn a specific token\\n     * Reverts if the token does not exist\\n     * @param tokenId uint256 ID of the token being burned\\n     */\\n    function _burn(uint256 tokenId) internal {\\n        _burn(ownerOf(tokenId), tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ownership of a given token ID to another address.\\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n    */\\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\\n        require(ownerOf(tokenId) == from);\\n        require(to != address(0));\\n\\n        _clearApproval(tokenId);\\n\\n        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\\n        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\\n\\n        _tokenOwner[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke `onERC721Received` on a target address\\n     * The call is not executed if the target address is not a contract\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        internal returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n\\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    /**\\n     * @dev Private function to clear current approval of a given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function _clearApproval(uint256 tokenId) private {\\n        if (_tokenApprovals[tokenId] != address(0)) {\\n            _tokenApprovals[tokenId] = address(0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC721/ERC721Enumerable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC721Enumerable.sol\\\";\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address => uint256[]) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 => uint256) private _allTokensIndex;\\n\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n    /**\\n     * 0x780e9d63 ===\\n     *     bytes4(keccak256('totalSupply()')) ^\\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\\n     *     bytes4(keccak256('tokenByIndex(uint256)'))\\n     */\\n\\n    /**\\n     * @dev Constructor function\\n     */\\n    constructor () public {\\n        // register the supported interface to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    /**\\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner\\n     * @param owner address owning the tokens list to be accessed\\n     * @param index uint256 representing the index to be accessed of the requested tokens list\\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\\n        require(index < balanceOf(owner));\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev Gets the total amount of tokens stored by the contract\\n     * @return uint256 representing the total amount of tokens\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev Gets the token ID at a given index of all the tokens in this contract\\n     * Reverts if the index is greater or equal to the total number of tokens\\n     * @param index uint256 representing the index to be accessed of the tokens list\\n     * @return uint256 token ID at the given index of the tokens list\\n     */\\n    function tokenByIndex(uint256 index) public view returns (uint256) {\\n        require(index < totalSupply());\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ownership of a given token ID to another address.\\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n    */\\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\\n        super._transferFrom(from, to, tokenId);\\n\\n        _removeTokenFromOwnerEnumeration(from, tokenId);\\n\\n        _addTokenToOwnerEnumeration(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to mint a new token\\n     * Reverts if the given token ID already exists\\n     * @param to address the beneficiary that will own the minted token\\n     * @param tokenId uint256 ID of the token to be minted\\n     */\\n    function _mint(address to, uint256 tokenId) internal {\\n        super._mint(to, tokenId);\\n\\n        _addTokenToOwnerEnumeration(to, tokenId);\\n\\n        _addTokenToAllTokensEnumeration(tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn a specific token\\n     * Reverts if the token does not exist\\n     * Deprecated, use _burn(uint256) instead\\n     * @param owner owner of the token to burn\\n     * @param tokenId uint256 ID of the token being burned\\n     */\\n    function _burn(address owner, uint256 tokenId) internal {\\n        super._burn(owner, tokenId);\\n\\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\\n        _ownedTokensIndex[tokenId] = 0;\\n\\n        _removeTokenFromAllTokensEnumeration(tokenId);\\n    }\\n\\n    /**\\n     * @dev Gets the list of token IDs of the requested owner\\n     * @param owner address owning the tokens\\n     * @return uint256[] List of token IDs owned by the requested address\\n     */\\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\\n        return _ownedTokens[owner];\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\\n        _ownedTokens[to].push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        _ownedTokens[from].length--;\\n\\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occcupied by\\n        // lasTokenId, or just over the end of the array if the token was the last one).\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        _allTokens.length--;\\n        _allTokensIndex[tokenId] = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./ERC721Enumerable.sol\\\";\\nimport \\\"./ERC721Metadata.sol\\\";\\n\\n/**\\n * @title Full ERC721 Token\\n * This implementation includes all the required and some optional functionality of the ERC721 standard\\n * Moreover, it includes approve all functionality using operator terminology\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\n\\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Optional mapping for token URIs\\n    mapping(uint256 => string) private _tokenURIs;\\n\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n    /**\\n     * 0x5b5e139f ===\\n     *     bytes4(keccak256('name()')) ^\\n     *     bytes4(keccak256('symbol()')) ^\\n     *     bytes4(keccak256('tokenURI(uint256)'))\\n     */\\n\\n    /**\\n     * @dev Constructor function\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n    }\\n\\n    /**\\n     * @dev Gets the token name\\n     * @return string representing the token name\\n     */\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Gets the token symbol\\n     * @return string representing the token symbol\\n     */\\n    function symbol() external view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns an URI for a given token ID\\n     * Throws if the token ID does not exist. May return an empty string.\\n     * @param tokenId uint256 ID of the token to query\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\\n        require(_exists(tokenId));\\n        return _tokenURIs[tokenId];\\n    }\\n\\n    /**\\n     * @dev Internal function to set the token URI for a given token\\n     * Reverts if the token ID does not exist\\n     * @param tokenId uint256 ID of the token to set its URI\\n     * @param uri string URI to assign\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\\n        require(_exists(tokenId));\\n        _tokenURIs[tokenId] = uri;\\n    }\\n\\n    /**\\n     * @dev Internal function to burn a specific token\\n     * Reverts if the token does not exist\\n     * Deprecated, use _burn(uint256) instead\\n     * @param owner owner of the token to burn\\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\\n     */\\n    function _burn(address owner, uint256 tokenId) internal {\\n        super._burn(owner, tokenId);\\n\\n        // Clear metadata (if any)\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic interface\\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function balanceOf(address owner) public view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) public view returns (address owner);\\n\\n    function approve(address to, uint256 tokenId) public;\\n    function getApproved(uint256 tokenId) public view returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) public;\\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public;\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract IERC721Enumerable is IERC721 {\\n    function totalSupply() public view returns (uint256);\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\\n\\n    function tokenByIndex(uint256 index) public view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\\n */\\ncontract IERC721Metadata is IERC721 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ncontract IERC721Receiver {\\n    /**\\n     * @notice Handle the receipt of an NFT\\n     * @dev The ERC721 smart contract calls this function on the recipient\\n     * after a `safeTransfer`. This function MUST return the function selector,\\n     * otherwise the caller will revert the transaction. The selector to be\\n     * returned can be obtained as `this.onERC721Received.selector`. This\\n     * function MAY throw to revert and reject the transfer.\\n     * Note: the ERC721 contract address is always the message sender.\\n     * @param operator The address which called `safeTransferFrom` function\\n     * @param from The address which previously owned the token\\n     * @param tokenId The NFT identifier which is being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\\n    public returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * Utility library of inline functions on addresses\\n */\\nlibrary Address {\\n    /**\\n     * Returns whether the target address is a contract\\n     * @dev This function will return false if invoked during the constructor of a contract,\\n     * as the code is not actually created until after the constructor finishes.\\n     * @param account address of the account to check\\n     * @return whether the target address is a contract\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // XXX Currently there is no better way to check if there is a contract in an address\\n        // than to check the size of the code at that address.\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\n        // for more details about how this works.\\n        // TODO Check this again before the Serenity release, because all addresses will be\\n        // contracts then.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Scammer\",\"name\":\"_scammer\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_adminWallet\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_artistWallet\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"voucherRecipients\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"editionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"artistReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adminReceived\",\"type\":\"uint256\"}],\"name\":\"editionBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"editions\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"newCollection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"editions\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum ScammerController.CollectionMode\",\"name\":\"mode\",\"type\":\"uint8\"}],\"name\":\"updatedCollection\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"editions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"addCollection\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminSplit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"artistWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"burnAllVouchers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collections\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"enum ScammerController.CollectionMode\",\"name\":\"mode\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"voucherOnlyMode\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"editions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllTokenIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestCollectionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"mintVoucher\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"numVouchers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scammer\",\"outputs\":[{\"internalType\":\"contract Scammer\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"}],\"name\":\"setVoucherOnlyMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_adminSplit\",\"type\":\"uint256\"}],\"name\":\"updateAdminSplit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_adminWallet\",\"type\":\"address\"}],\"name\":\"updateAdminWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_artistWallet\",\"type\":\"address\"}],\"name\":\"updateArtistWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_editions\",\"type\":\"uint256\"}],\"name\":\"updateCollectionEditions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"updateCollectionPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"updateCollectionPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"numVouchers\",\"type\":\"uint256\"}],\"name\":\"updateNumVouchers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"updatePaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vouchers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ScammerController","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000004e2a87743368484ed798033e8fdc7cae442064b80000000000000000000000008f6de19720b64800382124c41556ec4580ff42340000000000000000000000007742dbd51e98d1809a9cd749ab71af61e899c4420000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000004d00000000000000000000000017814c3522b1f3caffd3c7ed8df2ccc43b6884c3000000000000000000000000a9666519481f7ad7f2aec85f388b67a0c36414480000000000000000000000004fa03d85cc4cb5c931dcaf7329f6cc565633fd830000000000000000000000005fdbdf4c584b63ca98204c12fc864af416e469f0000000000000000000000000d3ca53890efa9c8739dfc34c697c5d8c9f5506cf000000000000000000000000fdf850332fba850be4ac53c7b6fc2a50a9b43c3d00000000000000000000000099c0e6a8393cbbd4e128b67e20eb1740fa114a2c00000000000000000000000032802f989b4348a51dd0e61d23b78be1a0543469000000000000000000000000a63e731d40f98ac470da55c55ad5a6d0452f16a1000000000000000000000000b1f6c97f4d2feba6b128f7b6d364e1ed1dca0b9900000000000000000000000027c6c1e95e5e4cc5d14b0d08e8b7fbecd954921a000000000000000000000000f143e0ad14a0276bed8730903cf0235c0b84adf5000000000000000000000000f46986dc775e81309ffb0337d7a216da0d0a3ca40000000000000000000000009011eb570d1be09ea4d10f38c119dcdf29725c41000000000000000000000000e125148be4f9ee615292110ca8c74502a1c57c6e0000000000000000000000004e08f778f45199d87f9b27187283fe95539b24db0000000000000000000000006954b9d1bc0ce4f2b8405513925f373ea11d2db2000000000000000000000000f1708bccf4ce044699ea2ecafc2ff0c5139bdbc3000000000000000000000000e9079e6f7b8ce291dd0fe13d1748abc6324f5a190000000000000000000000001d77168207917cbff6bcb5c655856cf0627001460000000000000000000000002cd776864672ded424f78bc6eb8114b518f1a286000000000000000000000000fc6923544831fbae10f97883dd8b986cf7f4b69300000000000000000000000074a0141d8b3f307c47e80722f03484aa92e19dc5000000000000000000000000da18e1537622802ec576d99a8e3913914653bd6f000000000000000000000000fa398d672936dcf428116f687244034961545d91000000000000000000000000fa398d672936dcf428116f687244034961545d910000000000000000000000003d1cf4a306c6ed3510c1699ab1d20106a14fb3ad00000000000000000000000000812076e9460d60e7f9af956cbda17ac64eeaa200000000000000000000000003ba73cb14d3f1c9228070343277681d4891a462000000000000000000000000042bbf027947c95c21f2f8cdf102f2da62f5a0aa000000000000000000000000165baf1c7dd632ac74c9ec7d7a9f54225a3f9c0100000000000000000000000018ee317e1a42cb29d2f658cf7c7738fde8ed7d100000000000000000000000001b69d4d159b6350d28c10754f834644639fdfa5c0000000000000000000000002230cb6207a7511572f81a41ad1a97e94689f57d00000000000000000000000025ef32c02bca66f4c89f44eb7543e785ea820792000000000000000000000000291496345f729ff53dab5ebe27a1b66dbc5f9ac700000000000000000000000029cccd91af3c6d2035a8b78ee60a7bcf3cc5bb3a0000000000000000000000002b165c49b1173c9f1b04461e94f0c3854896e99c0000000000000000000000002b214353d6c3bd8495c98fa293f5d5b4778f8d420000000000000000000000002e2ebecf70d927af53ee238e9fde4ae14417684800000000000000000000000032272be8efa647f7f90041309a463d56cbb222f8000000000000000000000000323f6993b3ee53b50f68927b1b226e0deb5fc112000000000000000000000000398b5ea43ef4240f4b23bece774d5a96515c5b400000000000000000000000003be931173c67945f3e4cbc2ca77d7b097c88d93a00000000000000000000000041f9609f10338e9b3b864b29356b35c2562e48ba0000000000000000000000004439a5c29f47dac09b8161e8879bc8496a41ce3700000000000000000000000047223ccfc1a631b9aa3f3a2dac010fa667e8c38e0000000000000000000000005445deb3b5481c25b59e702e03dd364e7d7961df0000000000000000000000006aa3280d882ef231bdad716f88f988a9bc86fb610000000000000000000000006cd9ac1a31e801b6c296109a96f8a9a87dd5fff70000000000000000000000007145ef486c1a9faafc5463208fc54a1086138f950000000000000000000000007d00801d259ddf5e19b137eae57f5266e613ec5a0000000000000000000000007e7f21c794180642bcee85e18812d0535800d00d0000000000000000000000008033562521fedecdcc05487303522375597f90940000000000000000000000008278889ab6de3f45ad46b51d428fbe9f228d0d740000000000000000000000008a7629a88fae5b49e1b256f606982e7d9b73d3680000000000000000000000008ced5dbba2741923ca88e57d977bb92e031a4fe40000000000000000000000008f459520afff7cbcf6b7837713470261efc1020f00000000000000000000000090c75ff794ddafbfa480674045c558d16946cc71000000000000000000000000a86a2a1051a70175c8464629b43e1870149d596b000000000000000000000000b47494b3d487b82b78af230c8460a12272389755000000000000000000000000b99a5a473045064b498da9a2792001f59ea02f76000000000000000000000000bbac1171e2adf3643b4c7f24b5b71551b1a42826000000000000000000000000be5837b0a6ebd3a4ea573deb783749addef42891000000000000000000000000c30448cb36f7c1c3cc7a8e6f99cfab6d4dbbee75000000000000000000000000c7cec60d2a01ea5bbedc20dfab9245b4bdf2ea01000000000000000000000000cc4511f6e3f96ba30c39b08648d0b244e9af814b000000000000000000000000d07e75cfb15b212c7dd26523723f88900b1337fe000000000000000000000000d1423c903eb129777822f587e2d812a07ed58f66000000000000000000000000d41a79f0c0e5eccd14e13d01398de6ae706ac023000000000000000000000000d7b2ca42190ba389131a53ec700247d501829f85000000000000000000000000db06829b4e0148327c863041a9f1e86c241bc80c000000000000000000000000debc0d58526d6c0db42032b43e2341a4458d6594000000000000000000000000ebf313d3fcf59b205eb43daf59ae3be8455dc47d000000000000000000000000f3368140d6107e6e3f8edb8ef9004558806817230000000000000000000000006853c0124fadb77a37763bb9b821b54670b55dd4000000000000000000000000e05f4385170de8fa66d75d7aead74e9705966d21","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}