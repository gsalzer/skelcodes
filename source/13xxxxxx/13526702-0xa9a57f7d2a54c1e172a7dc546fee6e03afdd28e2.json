{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/KetherSortition.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\\\";\\n\\ninterface IKetherHomepage {\\n  function ads(uint _idx) external view returns (address,uint,uint,uint,uint,string memory,string memory,string memory,bool,bool);\\n  function getAdsLength() view external returns (uint);\\n}\\n\\ninterface IERC721 {\\n  function ownerOf(uint256) external view returns (address);\\n  function balanceOf(address) external view returns (uint256);\\n  function tokenOfOwnerByIndex(address, uint256) external view returns (uint256);\\n}\\n\\ninterface IERC20 {\\n  function balanceOf(address account) external view returns (uint256);\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n}\\n\\nlibrary Errors {\\n  string constant MustOwnToken = \\\"must own token\\\";\\n  string constant OnlyMagistrate = \\\"only active magistrate can do this\\\";\\n  string constant MustHaveEntropy = \\\"waiting for entropy\\\";\\n  string constant MustHaveNominations = \\\"must have nominations\\\";\\n  string constant AlreadyStarted = \\\"election already started\\\";\\n  string constant NotExecuted = \\\"election not executed\\\";\\n  string constant TermNotExpired = \\\"term not expired\\\";\\n  string constant NotEnoughLink = \\\"not enough LINK\\\";\\n  string constant NotNominated = \\\"token is not nominated\\\";\\n}\\n\\ncontract KetherSortition is Ownable, VRFConsumerBase {\\n  event Nominated(\\n      uint256 indexed termNumber,\\n      address nominator,\\n      uint256 pixels\\n  );\\n\\n  event ElectionExecuting(\\n    uint256 indexed termNumber\\n  );\\n\\n  event ElectionCompleted(\\n    uint256 indexed termNumber,\\n    uint256 magistrateToken,\\n    address currentTokenOwner\\n  );\\n\\n  event StepDown(\\n    uint256 indexed termNumber,\\n    uint256 magistrateToken,\\n    address currentTokenOwner\\n  );\\n\\n  event ReceivedPayment(\\n    uint256 indexed termNumber,\\n    uint256 value\\n  );\\n\\n  struct Nomination{\\n    uint256 termNumber;\\n    uint256 nominatedToken;\\n  }\\n  uint256 constant PIXELS_PER_CELL = 100;\\n\\n  /// @notice tokenId of an NFT whose owner controls the royalties purse for this term.\\n  uint256 public magistrateToken;\\n  /// @notice length of magistrate term\\n  uint256 public termDuration;\\n  /// @notice minimum time period for new nominations (e.g. if a magistrate steps down)\\n  uint256 public minElectionDuration;\\n  /// @notice timestamp of start of current term\\n  uint256 public termStarted;\\n  /// @notice timestamp of end of current term\\n  uint256 public termExpires;\\n  /// @notice current term\\n  uint256 public termNumber = 0;\\n\\n  IERC721 ketherNFTContract;\\n  IKetherHomepage ketherContract;\\n\\n  /// @dev tokenIDs nominated in the current term\\n  uint256[] public nominatedTokens;\\n  /// @dev count of pixels nominated in the current term\\n  uint256 public nominatedPixels = 0;\\n  mapping(uint256 => Nomination) nominations; // mapping of tokenId => {termNumber, nominatedToken}\\n\\n  /// @dev provided by Chainlink\\n  uint256 public electionEntropy;\\n\\n  // nominating -[term expired & startElection() calls]> waitingForEntropy -[Chainlink calls into fulfillrandomness()]> gotEntropy -[completeElection()] -> nominating\\n  enum StateMachine { NOMINATING, WAITING_FOR_ENTROPY, GOT_ENTROPY }\\n  StateMachine public state = StateMachine.NOMINATING;\\n\\n  // Chainlink values\\n  bytes32 private s_keyHash;\\n  uint256 private s_fee;\\n\\n  constructor(address _ketherNFTContract, address _ketherContract, address vrfCoordinator, address link, bytes32 keyHash, uint256 fee, uint256 _termDuration, uint256 _minElectionDuration ) VRFConsumerBase(vrfCoordinator, link) {\\n    s_keyHash = keyHash;\\n    s_fee = fee;\\n\\n    ketherNFTContract = IERC721(_ketherNFTContract);\\n    ketherContract = IKetherHomepage(_ketherContract);\\n\\n    termDuration = _termDuration;\\n    minElectionDuration = _minElectionDuration;\\n    termExpires = block.timestamp + _termDuration;\\n  }\\n\\n  receive() external payable {\\n    emit ReceivedPayment(termNumber, msg.value);\\n  }\\n\\n  // Internal helpers:\\n\\n  /**\\n   * @notice Only callable by Chainlink VRF, async triggered via startElection().\\n   */\\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\\n    require(state == StateMachine.WAITING_FOR_ENTROPY, Errors.NotExecuted);\\n    electionEntropy = randomness;\\n    state = StateMachine.GOT_ENTROPY;\\n  }\\n\\n  /// @dev _nominate does not check token ownership, must already be checked.\\n  /// @param _ownedTokenId Token to nominate from\\n  /// @param _nominateTokenId Token to nominate to.\\n  function _nominate(uint256 _ownedTokenId, uint256 _nominateTokenId) internal returns (uint256 pixels) {\\n    // Only push the ad and update pixel count if it's not been nominated before\\n    if (!isNominated(_ownedTokenId)) {\\n      pixels += getAdPixels(_ownedTokenId);\\n      nominatedTokens.push(_ownedTokenId);\\n    }\\n\\n    nominations[_ownedTokenId] = Nomination(termNumber + 1, _nominateTokenId);\\n\\n    return pixels;\\n  }\\n\\n  /// @dev _nominate does not check token ownership, must already be checked.\\n  /// @param _nominateSelf if true each token nominates itself\\n  /// @param _nominateTokenId if nominateSelf is false, token to nominate to. Must be a NFT-wrapped token\\n  function _nominateAll(bool _nominateSelf, uint256 _nominateTokenId) internal returns (uint256) {\\n    require(state == StateMachine.NOMINATING, Errors.AlreadyStarted);\\n    address sender = _msgSender();\\n    require(ketherNFTContract.balanceOf(sender) > 0, Errors.MustOwnToken);\\n    // This checks that the _nominateTokenId is minted, will revert otherwise\\n    require(_nominateSelf || ketherNFTContract.ownerOf(_nominateTokenId) != address(0));\\n\\n\\n    uint256 pixels = 0;\\n    for (uint256 i = 0; i < ketherNFTContract.balanceOf(sender); i++) {\\n      uint256 idx = ketherNFTContract.tokenOfOwnerByIndex(sender, i);\\n      if (_nominateSelf) {\\n        pixels += _nominate(idx, idx);\\n      } else {\\n        pixels += _nominate(idx, _nominateTokenId);\\n      }\\n    }\\n\\n    nominatedPixels += pixels;\\n\\n    // Note this is emitted in the helper while `nominate` emits the event in the public function\\n    emit Nominated(termNumber+1, sender, pixels);\\n    return pixels;\\n  }\\n\\n\\n  // Views:\\n\\n  function getMagistrate() public view returns (address) {\\n    return getAdOwner(magistrateToken);\\n  }\\n\\n  function getAdOwner(uint256 _idx) public view returns (address) {\\n    return ketherNFTContract.ownerOf(_idx);\\n  }\\n\\n  function getAdPixels(uint256 _idx) public view returns (uint256) {\\n    (,,,uint width,uint height,,,,,) = ketherContract.ads(_idx);\\n    return width * height * PIXELS_PER_CELL;\\n  }\\n\\n  function isNominated(uint256 _idx) public view returns (bool) {\\n    return nominations[_idx].termNumber > termNumber;\\n  }\\n\\n  function getNominatedToken(uint256 _idx) public view returns (uint256) {\\n    require(isNominated(_idx), Errors.NotNominated);\\n\\n    return nominations[_idx].nominatedToken;\\n  }\\n\\n  function getNextMagistrateToken() public view returns (uint256) {\\n    require(state == StateMachine.GOT_ENTROPY, Errors.MustHaveEntropy);\\n    require(nominatedTokens.length > 0, Errors.MustHaveNominations);\\n\\n    uint256 pixelChosen = electionEntropy % nominatedPixels;\\n    uint256 curPixel = 0;\\n\\n    for(uint256 i = 0; i < nominatedTokens.length; i++) {\\n      uint256 idx = nominatedTokens[i];\\n      curPixel += getAdPixels(idx);\\n      if (curPixel > pixelChosen) {\\n        return getNominatedToken(idx);\\n      }\\n    }\\n    return 0;\\n  }\\n\\n  // External interface:\\n\\n  /**\\n   * @notice Nominate tokens held by the sender as candidates for magistrate in the next term.\\n   *      Nominations of tokens are independent of their owner.\\n   * @param _ownedTokenId Token to nominate from\\n   * @param _nominateTokenId tokenId to count nominations towards. Must be an NFT-wrapped token.\\n   * @return Number of nominated pixels.\\n   *\\n   * Emits {Nominated} event.\\n   */\\n  function nominate(uint256 _ownedTokenId, uint256 _nominateTokenId) external returns (uint256) {\\n    require(state == StateMachine.NOMINATING, Errors.AlreadyStarted);\\n    address sender = _msgSender();\\n    require(ketherNFTContract.ownerOf(_ownedTokenId) == sender, Errors.MustOwnToken);\\n    // This checks that the _nominateTokenId is minted, will revert otherwise\\n    require(ketherNFTContract.ownerOf(_nominateTokenId) != address(0));\\n    uint256 pixels = _nominate(_ownedTokenId, _nominateTokenId);\\n\\n    // Note this is emitted in the public function while `_nominateAll` emits the event in the helper\\n    emit Nominated(termNumber+1, sender, pixels);\\n\\n    return pixels;\\n  }\\n\\n  /**\\n   * @notice Nominate tokens held by the sender as candidates towards a specific `_nominateTokenId` as magistrate in the next term\\n   * @param _nominateTokenId tokenId to count nominations towards. Must be an NFT-wrapped token.\\n   * @return Number of nominated pixels.\\n   *\\n   * Emits {Nominated} event.\\n   */\\n  function nominateAll(uint256 _nominateTokenId) public returns (uint256) {\\n    return _nominateAll(false, _nominateTokenId);\\n  }\\n\\n  /**\\n   * @notice Nominate tokens held by the sender as candidates towards a specific `_nominateTokenId` as magistrate in the next term\\n   * @return Number of nominated pixels.\\n   *\\n   * Emits {Nominated} event.\\n   */\\n  function nominateSelf() public returns (uint256) {\\n    return _nominateAll(true, 0);\\n  }\\n\\n  /**\\n   * @notice Stop accepting nominations, start election.\\n   *\\n   * Emits {ElectionExecuting} event.\\n   */\\n  function startElection() external {\\n    require(state == StateMachine.NOMINATING, Errors.AlreadyStarted);\\n    require(nominatedTokens.length > 0, Errors.MustHaveNominations);\\n    require(termExpires <= block.timestamp, Errors.TermNotExpired);\\n    require(LINK.balanceOf(address(this)) >= s_fee, Errors.NotEnoughLink);\\n\\n    state = StateMachine.WAITING_FOR_ENTROPY;\\n    requestRandomness(s_keyHash, s_fee);\\n\\n    emit ElectionExecuting(termNumber);\\n  }\\n\\n  /**\\n   * @notice Assign new magistrate and open up for nominations for next election.\\n   *\\n   * Emits {ElectionCompleted} event.\\n   */\\n  function completeElection() external {\\n    require(state == StateMachine.GOT_ENTROPY, Errors.MustHaveEntropy);\\n    magistrateToken = getNextMagistrateToken();\\n\\n    termNumber += 1;\\n    termStarted = block.timestamp;\\n    termExpires = termStarted + termDuration;\\n\\n    delete nominatedTokens;\\n    nominatedPixels = 0;\\n    state = StateMachine.NOMINATING;\\n\\n    emit ElectionCompleted(termNumber, magistrateToken, getMagistrate());\\n  }\\n\\n\\n  // Only magistrate:\\n\\n  /// @notice Transfer balance controlled by magistrate.\\n  /// @notice Magistrate has exclusive rights to withdraw until the end of term.\\n  /// @notice Remaining balance after the next election is rolled over to the next magistrate.\\n  function withdraw(address payable to) public {\\n    require(_msgSender() == getMagistrate(), Errors.OnlyMagistrate);\\n    // TODO: Someday, would it be fun if this required having a >2 LINK balance to\\n    // withdraw? If we wanna be super cute, could automagically buy LINK from\\n    // the proceeds before transferring the remaining balance.\\n\\n    to.transfer(address(this).balance);\\n  }\\n\\n  /// @notice Cut the term short, leaving enough time for new nominations.\\n  /// Emits {StepDown} event.\\n  function stepDown() public {\\n    require(_msgSender() == getMagistrate(), Errors.OnlyMagistrate);\\n\\n    uint256 timeRemaining = termExpires - block.timestamp;\\n    if (timeRemaining > minElectionDuration) {\\n      termExpires = block.timestamp + minElectionDuration;\\n    }\\n\\n    emit StepDown(termNumber, magistrateToken, _msgSender());\\n  }\\n\\n  // Only owner (admin helpers):\\n\\n  /**\\n   * @notice Withdraw ERC20 tokens, primarily for rescuing remaining LINK once the experiment is over.\\n   */\\n  function adminWithdrawToken(IERC20 token, address to) external onlyOwner {\\n    token.transfer(to, token.balanceOf(address(this)));\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\n\\nimport \\\"./VRFRequestIDBase.sol\\\";\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\\n * @dev want to generate randomness from.\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomness method.\\n *\\n * @dev The randomness argument to fulfillRandomness is the actual random value\\n * @dev generated from your seed.\\n *\\n * @dev The requestId argument is generated from the keyHash and the seed by\\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\\n * @dev requests open, you can use the requestId to track which seed is\\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\\n * @dev details. (See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.)\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ. (Which is critical to making unpredictable randomness! See the\\n * @dev next section.)\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\\n * @dev block in which the request is made, user-provided seeds have no impact\\n * @dev on its economic security properties. They are only included for API\\n * @dev compatability with previous versions of this contract.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request.\\n */\\nabstract contract VRFConsumerBase is VRFRequestIDBase {\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomness the VRF output\\n   */\\n  function fulfillRandomness(\\n    bytes32 requestId,\\n    uint256 randomness\\n  )\\n    internal\\n    virtual;\\n\\n  /**\\n   * @dev In order to keep backwards compatibility we have kept the user\\n   * seed field around. We remove the use of it because given that the blockhash\\n   * enters later, it overrides whatever randomness the used seed provides.\\n   * Given that it adds no security, and can easily lead to misunderstandings,\\n   * we have removed it from usage and can now provide a simpler API.\\n   */\\n  uint256 constant private USER_SEED_PLACEHOLDER = 0;\\n\\n  /**\\n   * @notice requestRandomness initiates a request for VRF output given _seed\\n   *\\n   * @dev The fulfillRandomness method receives the output, once it's provided\\n   * @dev by the Oracle, and verified by the vrfCoordinator.\\n   *\\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\\n   * @dev the _fee must exceed the fee specified during registration of the\\n   * @dev _keyHash.\\n   *\\n   * @dev The _seed parameter is vestigial, and is kept only for API\\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\\n   * @dev your own randomness, here, but it's not necessary because the VRF\\n   * @dev oracle will mix the hash of the block containing your request into the\\n   * @dev VRF seed it ultimately uses.\\n   *\\n   * @param _keyHash ID of public key against which randomness is generated\\n   * @param _fee The amount of LINK to send with the request\\n   *\\n   * @return requestId unique ID for this request\\n   *\\n   * @dev The returned requestId can be used to distinguish responses to\\n   * @dev concurrent requests. It is passed as the first argument to\\n   * @dev fulfillRandomness.\\n   */\\n  function requestRandomness(\\n    bytes32 _keyHash,\\n    uint256 _fee\\n  )\\n    internal\\n    returns (\\n      bytes32 requestId\\n    )\\n  {\\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\\n    // the hash of the block containing this request to obtain the seed/input\\n    // which is finally passed to the VRF cryptographic machinery.\\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\\n    // nonces[_keyHash] must stay in sync with\\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\\n    // This provides protection against the user repeating their input seed,\\n    // which would result in a predictable/duplicate output, if multiple such\\n    // requests appeared in the same block.\\n    nonces[_keyHash] = nonces[_keyHash] + 1;\\n    return makeRequestId(_keyHash, vRFSeed);\\n  }\\n\\n  LinkTokenInterface immutable internal LINK;\\n  address immutable private vrfCoordinator;\\n\\n  // Nonces for each VRF key from which randomness has been requested.\\n  //\\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   * @param _link address of LINK token contract\\n   *\\n   * @dev https://docs.chain.link/docs/link-token-contracts\\n   */\\n  constructor(\\n    address _vrfCoordinator,\\n    address _link\\n  ) {\\n    vrfCoordinator = _vrfCoordinator;\\n    LINK = LinkTokenInterface(_link);\\n  }\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomness(\\n    bytes32 requestId,\\n    uint256 randomness\\n  )\\n    external\\n  {\\n    require(msg.sender == vrfCoordinator, \\\"Only VRFCoordinator can fulfill\\\");\\n    fulfillRandomness(requestId, randomness);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n\\n  function allowance(\\n    address owner,\\n    address spender\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 remaining\\n    );\\n\\n  function approve(\\n    address spender,\\n    uint256 value\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function balanceOf(\\n    address owner\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 balance\\n    );\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8 decimalPlaces\\n    );\\n\\n  function decreaseApproval(\\n    address spender,\\n    uint256 addedValue\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function increaseApproval(\\n    address spender,\\n    uint256 subtractedValue\\n  ) external;\\n\\n  function name()\\n    external\\n    view\\n    returns (\\n      string memory tokenName\\n    );\\n\\n  function symbol()\\n    external\\n    view\\n    returns (\\n      string memory tokenSymbol\\n    );\\n\\n  function totalSupply()\\n    external\\n    view\\n    returns (\\n      uint256 totalTokensIssued\\n    );\\n\\n  function transfer(\\n    address to,\\n    uint256 value\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract VRFRequestIDBase {\\n\\n  /**\\n   * @notice returns the seed which is actually input to the VRF coordinator\\n   *\\n   * @dev To prevent repetition of VRF output due to repetition of the\\n   * @dev user-supplied seed, that seed is combined in a hash with the\\n   * @dev user-specific nonce, and the address of the consuming contract. The\\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\\n   * @dev the final seed, but the nonce does protect against repetition in\\n   * @dev requests which are included in a single block.\\n   *\\n   * @param _userSeed VRF seed input provided by user\\n   * @param _requester Address of the requesting contract\\n   * @param _nonce User-specific nonce at the time of the request\\n   */\\n  function makeVRFInputSeed(\\n    bytes32 _keyHash,\\n    uint256 _userSeed,\\n    address _requester,\\n    uint256 _nonce\\n  )\\n    internal\\n    pure\\n    returns (\\n      uint256\\n    )\\n  {\\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\n  }\\n\\n  /**\\n   * @notice Returns the id for this request\\n   * @param _keyHash The serviceAgreement ID to be used for this request\\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\\n   * @return The id for this request\\n   *\\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\\n   * @dev contract, but the one generated by makeVRFInputSeed\\n   */\\n  function makeRequestId(\\n    bytes32 _keyHash,\\n    uint256 _vRFInputSeed\\n  )\\n    internal\\n    pure\\n    returns (\\n      bytes32\\n    )\\n  {\\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\n  }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": false\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ketherNFTContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ketherContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vrfCoordinator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"link\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_termDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minElectionDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"termNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"magistrateToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currentTokenOwner\",\"type\":\"address\"}],\"name\":\"ElectionCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"termNumber\",\"type\":\"uint256\"}],\"name\":\"ElectionExecuting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"termNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nominator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pixels\",\"type\":\"uint256\"}],\"name\":\"Nominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"termNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReceivedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"termNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"magistrateToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currentTokenOwner\",\"type\":\"address\"}],\"name\":\"StepDown\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"adminWithdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"completeElection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"electionEntropy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"getAdOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"getAdPixels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMagistrate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextMagistrateToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"getNominatedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"isNominated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"magistrateToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minElectionDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ownedTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nominateTokenId\",\"type\":\"uint256\"}],\"name\":\"nominate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nominateTokenId\",\"type\":\"uint256\"}],\"name\":\"nominateAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominateSelf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedPixels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nominatedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startElection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"internalType\":\"enum KetherSortition.StateMachine\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stepDown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"termDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"termExpires\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"termNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"termStarted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"KetherSortition","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007bb952ab78b28a62b1525aca54a71e7aa6177645000000000000000000000000b5fe93ccfec708145d6278b0c71ce60aa75ef925000000000000000000000000f0d54349addcf704f77ae15b96510dea15cb7952000000000000000000000000514910771af9ca656af840dff83e8264ecf986caaa77729d3466ca35ae8d28b3bbac7cc36a5031efdc430821c02bc31a238af4450000000000000000000000000000000000000000000000001bc16d674ec800000000000000000000000000000000000000000000000000000000000000375f00000000000000000000000000000000000000000000000000000000000003f480","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}