{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/sapphire/SapphirePassportScores.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.5.16;\\npragma experimental ABIEncoderV2;\\nimport \\\"@openzeppelin/contracts/cryptography/MerkleProof.sol\\\";\\n\\nimport {Adminable} from \\\"../lib/Adminable.sol\\\";\\nimport {SafeMath} from \\\"../lib/SafeMath.sol\\\";\\nimport {Initializable} from \\\"../lib/Initializable.sol\\\";\\nimport {SapphireTypes} from \\\"./SapphireTypes.sol\\\";\\nimport {ISapphirePassportScores} from \\\"./ISapphirePassportScores.sol\\\";\\n\\ncontract SapphirePassportScores is ISapphirePassportScores, Adminable, Initializable {\\n\\n    /* ========== Libraries ========== */\\n\\n    using SafeMath for uint256;\\n\\n    /* ========== Events ========== */\\n\\n    event MerkleRootUpdated(\\n        address indexed updater,\\n        bytes32 merkleRoot,\\n        uint256 updatedAt\\n    );\\n\\n    event PauseStatusUpdated(bool value);\\n\\n    event DelayDurationUpdated(\\n        address indexed account,\\n        uint256 value\\n    );\\n\\n    event PauseOperatorUpdated(\\n        address pauseOperator\\n    );\\n\\n    event MerkleRootUpdaterUpdated(\\n        address merkleRootUpdater\\n    );\\n\\n    /* ========== Variables ========== */\\n\\n    /**\\n     * @dev Mapping of the epoch to a merkle root and its timestamp\\n     */\\n    mapping (uint256 => SapphireTypes.RootInfo) public rootsHistory;\\n\\n    bool public isPaused;\\n\\n    uint256 public merkleRootDelayDuration;\\n\\n    address public merkleRootUpdater;\\n\\n    address public pauseOperator;\\n\\n    uint256 public currentEpoch;\\n\\n    /* ========== Modifiers ========== */\\n\\n    modifier onlyMerkleRootUpdater() {\\n        require(\\n            merkleRootUpdater == msg.sender,\\n            \\\"SapphirePassportScores: caller is not authorized to update merkle root\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyWhenActive() {\\n        require(\\n            !isPaused,\\n            \\\"SapphirePassportScores: contract is not active\\\"\\n        );\\n        _;\\n    }\\n\\n    /* ========== Init ========== */\\n\\n    function init(\\n        bytes32 _merkleRoot,\\n        address _merkleRootUpdater,\\n        address _pauseOperator\\n    )\\n        public\\n        onlyAdmin\\n        initializer()\\n    {\\n        // Current Merkle root\\n        rootsHistory[currentEpoch] = SapphireTypes.RootInfo(\\n            _merkleRoot,\\n            currentTimestamp()\\n        );\\n\\n        // Upcoming Merkle root\\n        rootsHistory[currentEpoch + 1].merkleRoot = _merkleRoot;\\n\\n        merkleRootUpdater = _merkleRootUpdater;\\n        pauseOperator = _pauseOperator;\\n        isPaused = true;\\n        merkleRootDelayDuration = 86400; // 24 * 60 * 60 sec\\n    }\\n\\n    /* ========== View Functions ========== */\\n\\n    /**\\n     * @dev Returns current block's timestamp\\n     *\\n     * @notice This function is introduced in order to properly test time delays in this contract\\n     */\\n    function currentTimestamp()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return block.timestamp;\\n    }\\n\\n    function lastMerkleRootUpdate()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return rootsHistory[currentEpoch].timestamp;\\n    }\\n\\n    function currentMerkleRoot()\\n        public\\n        view\\n        returns (bytes32)\\n    {\\n        return rootsHistory[currentEpoch].merkleRoot;\\n    }\\n\\n    function upcomingMerkleRoot()\\n        external\\n        view\\n        returns (bytes32)\\n    {\\n        return rootsHistory[currentEpoch + 1].merkleRoot;\\n    }\\n\\n    /* ========== Mutative Functions ========== */\\n\\n    /**\\n     * @dev Update upcoming merkle root\\n     *\\n     * @notice Can be called by:\\n     *      - the admin:\\n     *          1. Check if contract is paused\\n     *          2. Replace upcoming merkle root\\n     *      - merkle root updater:\\n     *          1. Check if contract is active\\n     *          2. Replace current merkle root with upcoming merkle root\\n     *          3. Update upcoming one with passed Merkle root.\\n     *          4. Update the last merkle root update with the current timestamp\\n     *          5. Increment the `currentEpoch`\\n     *\\n     * @param _newRoot New upcoming merkle root\\n     */\\n    function updateMerkleRoot(\\n        bytes32 _newRoot\\n    )\\n        external\\n    {\\n        require(\\n            _newRoot != 0x0000000000000000000000000000000000000000000000000000000000000000,\\n            \\\"SapphirePassportScores: root is empty\\\"\\n        );\\n\\n        if (msg.sender == getAdmin()) {\\n            updateMerkleRootAsAdmin(_newRoot);\\n        } else {\\n            updateMerkleRootAsUpdater(_newRoot);\\n        }\\n        emit MerkleRootUpdated(msg.sender, _newRoot, currentTimestamp());\\n    }\\n\\n    /**\\n     * @notice Verifies the user's score proof against the current Merkle root.\\n     *         Reverts if the proof is invalid.\\n     *\\n     * @param _proof Data required to verify if score is correct for the current merkle root\\n     */\\n    function verify(\\n        SapphireTypes.ScoreProof memory _proof\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return verifyForEpoch(_proof, currentEpoch);\\n    }\\n\\n    /**\\n     * @notice Verifies the user's score proof against the merkle root of the given epoch.\\n     *         Reverts if proof is invalid\\n     *\\n     * @param _proof Data required to verify if score is correct for the current merkle root\\n     * @param _epoch The epoch of the Merkle root to verify the proof against\\n     */\\n    function verifyForEpoch(\\n        SapphireTypes.ScoreProof memory _proof,\\n        uint256 _epoch\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        require(\\n            _epoch <= currentEpoch,\\n            \\\"SapphirePassportScores: cannot verify a proof in the future\\\"\\n        );\\n\\n        require(\\n            _proof.account != address(0),\\n            \\\"SapphirePassportScores: account cannot be address 0\\\"\\n        );\\n\\n        bytes32 node = keccak256(abi.encodePacked(_proof.account, _proof.protocol, _proof.score));\\n\\n        require(\\n            MerkleProof.verify(_proof.merkleProof, rootsHistory[_epoch].merkleRoot, node),\\n            \\\"SapphirePassportScores: invalid proof\\\"\\n        );\\n\\n        // Return true to improve experience when interacting with this contract (ex. Etherscan)\\n        return true;\\n    }\\n\\n     /* ========== Private Functions ========== */\\n\\n    /**\\n     * @dev Merkle root updating strategy for merkle root updater\\n    **/\\n    function updateMerkleRootAsUpdater(\\n        bytes32 _newRoot\\n    )\\n        private\\n        onlyMerkleRootUpdater\\n        onlyWhenActive\\n    {\\n        require(\\n            currentTimestamp() >= merkleRootDelayDuration.add(lastMerkleRootUpdate()),\\n            \\\"SapphirePassportScores: cannot update merkle root before delay period\\\"\\n        );\\n\\n        currentEpoch++;\\n\\n        rootsHistory[currentEpoch].timestamp = currentTimestamp();\\n        rootsHistory[currentEpoch + 1].merkleRoot = _newRoot;\\n    }\\n\\n    /**\\n     * @dev Merkle root updating strategy for the admin\\n    **/\\n    function updateMerkleRootAsAdmin(\\n        bytes32 _newRoot\\n    )\\n        private\\n        onlyAdmin\\n    {\\n        require(\\n            isPaused,\\n            \\\"SapphirePassportScores: only admin can update merkle root if paused\\\"\\n        );\\n\\n        rootsHistory[currentEpoch + 1].merkleRoot = _newRoot;\\n    }\\n\\n    /* ========== Admin Functions ========== */\\n\\n    /**\\n     * @dev Update merkle root delay duration\\n    */\\n    function setMerkleRootDelay(\\n        uint256 _delay\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        require(\\n            _delay > 0,\\n            \\\"SapphirePassportScores: the delay must be greater than 0\\\"\\n        );\\n\\n        require(\\n            _delay != merkleRootDelayDuration,\\n            \\\"SapphirePassportScores: the same delay is already set\\\"\\n        );\\n\\n        merkleRootDelayDuration = _delay;\\n        emit DelayDurationUpdated(msg.sender, _delay);\\n    }\\n\\n    /**\\n     * @dev Pause or unpause contract, which cause the merkle root updater\\n     *      to not be able to update the merkle root\\n     */\\n    function setPause(\\n        bool _value\\n    )\\n        external\\n    {\\n        require(\\n            msg.sender == pauseOperator,\\n            \\\"SapphirePassportScores: caller is not the pause operator\\\"\\n        );\\n\\n        require(\\n            _value != isPaused,\\n            \\\"SapphirePassportScores: cannot set the same pause value\\\"\\n        );\\n\\n        isPaused = _value;\\n        emit PauseStatusUpdated(_value);\\n    }\\n\\n    /**\\n     * @dev Sets the merkle root updater\\n    */\\n    function setMerkleRootUpdater(\\n        address _merkleRootUpdater\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        require(\\n            _merkleRootUpdater != merkleRootUpdater,\\n            \\\"SapphirePassportScores: cannot set the same merkle root updater\\\"\\n        );\\n\\n        merkleRootUpdater = _merkleRootUpdater;\\n        emit MerkleRootUpdaterUpdated(merkleRootUpdater);\\n    }\\n\\n    /**\\n     * @dev Sets the pause operator\\n    */\\n    function setPauseOperator(\\n        address _pauseOperator\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        require(\\n            _pauseOperator != pauseOperator,\\n            \\\"SapphirePassportScores: cannot set the same pause operator\\\"\\n        );\\n\\n        pauseOperator = _pauseOperator;\\n        emit PauseOperatorUpdated(pauseOperator);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Adminable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport { Storage } from \\\"./Storage.sol\\\";\\n\\n/**\\n * @title Adminable\\n * @author dYdX\\n *\\n * @dev EIP-1967 Proxy Admin contract.\\n */\\ncontract Adminable {\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     *  This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    bytes32 internal constant ADMIN_SLOT =\\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n    * @dev Modifier to check whether the `msg.sender` is the admin.\\n    *  If it is, it will run the function. Otherwise, it will revert.\\n    */\\n    modifier onlyAdmin() {\\n        require(\\n            msg.sender == getAdmin(),\\n            \\\"Adminable: caller is not admin\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @return The EIP-1967 proxy admin\\n     */\\n    function getAdmin()\\n        public\\n        view\\n        returns (address)\\n    {\\n        return address(uint160(uint256(Storage.load(ADMIN_SLOT))));\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"\\npragma solidity ^0.5.16;\\n\\nlibrary SafeMath {\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.5.16;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * Taken from OpenZeppelin\\n */\\ncontract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/sapphire/SapphireTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nlibrary SapphireTypes {\\n\\n    struct ScoreProof {\\n        address account;\\n        bytes32 protocol;\\n        uint256 score;\\n        bytes32[] merkleProof;\\n    }\\n\\n    struct Vault {\\n        uint256 collateralAmount;\\n        uint256 borrowedAmount;\\n    }\\n\\n    struct RootInfo {\\n        bytes32 merkleRoot;\\n        uint256 timestamp;\\n    }\\n\\n    enum Operation {\\n        Deposit,\\n        Withdraw,\\n        Borrow,\\n        Repay,\\n        Liquidate\\n    }\\n\\n    struct Action {\\n        uint256 amount;\\n        Operation operation;\\n        address userToLiquidate;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/sapphire/ISapphirePassportScores.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {SapphireTypes} from \\\"./SapphireTypes.sol\\\";\\n\\ninterface ISapphirePassportScores {\\n    function updateMerkleRoot(bytes32 newRoot) external;\\n\\n    function setMerkleRootUpdater(address merkleRootUpdater) external;\\n\\n    /**\\n     * Reverts if proof is invalid\\n     */\\n    function verify(SapphireTypes.ScoreProof calldata proof) external view returns(bool);\\n\\n    function setMerkleRootDelay(uint256 delay) external;\\n\\n    function setPause(bool status) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nlibrary Storage {\\n\\n    /**\\n     * @dev Performs an SLOAD and returns the data in the slot.\\n     */\\n    function load(\\n        bytes32 slot\\n    )\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        bytes32 result;\\n        /* solium-disable-next-line security/no-inline-assembly */\\n        assembly {\\n            result := sload(slot)\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Performs an SSTORE to save the value to the slot.\\n     */\\n    function store(\\n        bytes32 slot,\\n        bytes32 value\\n    )\\n        internal\\n    {\\n        /* solium-disable-next-line security/no-inline-assembly */\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DelayDurationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"name\":\"MerkleRootUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"merkleRootUpdater\",\"type\":\"address\"}],\"name\":\"MerkleRootUpdaterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pauseOperator\",\"type\":\"address\"}],\"name\":\"PauseOperatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"PauseStatusUpdated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_merkleRootUpdater\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pauseOperator\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastMerkleRootUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"merkleRootDelayDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"merkleRootUpdater\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pauseOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rootsHistory\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"setMerkleRootDelay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_merkleRootUpdater\",\"type\":\"address\"}],\"name\":\"setMerkleRootUpdater\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pauseOperator\",\"type\":\"address\"}],\"name\":\"setPauseOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upcomingMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_newRoot\",\"type\":\"bytes32\"}],\"name\":\"updateMerkleRoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"protocol\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct SapphireTypes.ScoreProof\",\"name\":\"_proof\",\"type\":\"tuple\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"protocol\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct SapphireTypes.ScoreProof\",\"name\":\"_proof\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"verifyForEpoch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SapphirePassportScores","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}