{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/IMultisigControl.sol\r\n\r\n//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.8;\r\n\r\n/// @title MultisigControl Interface\r\n/// @author Vega Protocol\r\n/// @notice Implementations of this interface are used by the Vega network to control smart contracts without the need for Vega to have any Ethereum of its own.\r\n/// @notice To do this, the Vega validators sign a MultisigControl order to construct a signature bundle. Any interested party can then take that signature bundle and pay the gas to run the command on Ethereum\r\nabstract contract IMultisigControl {\r\n\r\n    /***************************EVENTS****************************/\r\n    event SignerAdded(address new_signer, uint256 nonce);\r\n    event SignerRemoved(address old_signer, uint256 nonce);\r\n    event ThresholdSet(uint16 new_threshold, uint256 nonce);\r\n\r\n    /**************************FUNCTIONS*********************/\r\n    /// @notice Sets threshold of signatures that must be met before function is executed.\r\n    /// @param new_threshold New threshold value\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @notice Ethereum has no decimals, threshold is % * 10 so 50% == 500 100% == 1000\r\n    /// @notice signatures are OK if they are >= threshold count of total valid signers\r\n    /// @dev MUST emit ThresholdSet event\r\n    function set_threshold(uint16 new_threshold, uint nonce, bytes calldata signatures) public virtual;\r\n\r\n    /// @notice Adds new valid signer and adjusts signer count.\r\n    /// @param new_signer New signer address\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev MUST emit 'SignerAdded' event\r\n    function add_signer(address new_signer, uint nonce, bytes calldata signatures) public virtual;\r\n\r\n    /// @notice Removes currently valid signer and adjusts signer count.\r\n    /// @param old_signer Address of signer to be removed.\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev MUST emit 'SignerRemoved' event\r\n    function remove_signer(address old_signer, uint nonce, bytes calldata signatures) public virtual;\r\n\r\n    /// @notice Verifies a signature bundle and returns true only if the threshold of valid signers is met,\r\n    /// @notice this is a function that any function controlled by Vega MUST call to be securely controlled by the Vega network\r\n    /// @notice message to hash to sign follows this pattern:\r\n    /// @notice abi.encode( abi.encode(param1, param2, param3, ... , nonce, function_name_string), validating_contract_or_submitter_address);\r\n    /// @notice Note that validating_contract_or_submitter_address is the the submitting party. If on MultisigControl contract itself, it's the submitting ETH address\r\n    /// @notice if function on bridge that then calls Multisig, then it's the address of that contract\r\n    /// @notice Note also the embedded encoding, this is required to verify what function/contract the function call goes to\r\n    /// @return MUST return true if valid signatures are over the threshold\r\n    function verify_signatures(bytes calldata signatures, bytes memory message, uint nonce) public virtual returns(bool);\r\n\r\n    /**********************VIEWS*********************/\r\n    /// @return Number of valid signers\r\n    function get_valid_signer_count() public virtual view returns(uint8);\r\n\r\n    /// @return Current threshold\r\n    function get_current_threshold() public virtual view returns(uint16);\r\n\r\n    /// @param signer_address target potential signer address\r\n    /// @return true if address provided is valid signer\r\n    function is_valid_signer(address signer_address) public virtual view returns(bool);\r\n\r\n    /// @param nonce Nonce to lookup\r\n    /// @return true if nonce has been used\r\n    function is_nonce_used(uint nonce) public virtual view returns(bool);\r\n}\r\n\r\n/**\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\r\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\r\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................DDD\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\r\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\r\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/\r\n\r\n// File: contracts/MultisigControl.sol\r\n\r\n\r\n/// @title MultisigControl\r\n/// @author Vega Protocol\r\n/// @notice This contract enables validators, through a multisignature process, to run functions on contracts by consensus\r\ncontract MultisigControl is IMultisigControl {\r\n    constructor () {\r\n        // set initial threshold to 50%\r\n        threshold = 500;\r\n        signers[msg.sender] = true;\r\n        signer_count++;\r\n        emit SignerAdded(msg.sender, 0);\r\n    }\r\n\r\n    uint16 threshold;\r\n    uint8 signer_count;\r\n    mapping(address => bool) signers;\r\n    mapping(uint => bool) used_nonces;\r\n    mapping(bytes32 => mapping(address => bool)) has_signed;\r\n    \r\n    /**************************FUNCTIONS*********************/\r\n    /// @notice Sets threshold of signatures that must be met before function is executed.\r\n    /// @param new_threshold New threshold value\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @notice Ethereum has no decimals, threshold is % * 10 so 50% == 500 100% == 1000\r\n    /// @notice signatures are OK if they are >= threshold count of total valid signers\r\n    /// @dev Emits ThresholdSet event\r\n    function set_threshold(uint16 new_threshold, uint256 nonce, bytes calldata signatures) public override{\r\n        require(new_threshold <= 1000 && new_threshold > 0, \"new threshold outside range\");\r\n        bytes memory message = abi.encode(new_threshold, nonce, \"set_threshold\");\r\n        require(verify_signatures(signatures, message, nonce), \"bad signatures\");\r\n        threshold = new_threshold;\r\n        emit ThresholdSet(new_threshold, nonce);\r\n    }\r\n\r\n    /// @notice Adds new valid signer and adjusts signer count.\r\n    /// @param new_signer New signer address\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev Emits 'SignerAdded' event\r\n    function add_signer(address new_signer, uint256 nonce, bytes calldata signatures) public override{\r\n        bytes memory message = abi.encode(new_signer, nonce, \"add_signer\");\r\n        require(!signers[new_signer], \"signer already exists\");\r\n        require(verify_signatures(signatures, message, nonce), \"bad signatures\");\r\n        signers[new_signer] = true;\r\n        signer_count++;\r\n        emit SignerAdded(new_signer, nonce);\r\n    }\r\n\r\n    /// @notice Removes currently valid signer and adjusts signer count.\r\n    /// @param old_signer Address of signer to be removed.\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev Emits 'SignerRemoved' event\r\n    function remove_signer(address old_signer, uint256 nonce, bytes calldata signatures) public override {\r\n        bytes memory message = abi.encode(old_signer, nonce, \"remove_signer\");\r\n        require(signers[old_signer], \"signer doesn't exist\");\r\n        require(verify_signatures(signatures, message, nonce), \"bad signatures\");\r\n        signers[old_signer] = false;\r\n        signer_count--;\r\n        emit SignerRemoved(old_signer, nonce);\r\n    }\r\n\r\n    /// @notice Verifies a signature bundle and returns true only if the threshold of valid signers is met,\r\n    /// @notice this is a function that any function controlled by Vega MUST call to be securely controlled by the Vega network\r\n    /// @notice message to hash to sign follows this pattern:\r\n    /// @notice abi.encode( abi.encode(param1, param2, param3, ... , nonce, function_name_string), validating_contract_or_submitter_address);\r\n    /// @notice Note that validating_contract_or_submitter_address is the submitting party. If on MultisigControl contract itself, it's the submitting ETH address\r\n    /// @notice if function on bridge that then calls Multisig, then it's the address of that contract\r\n    /// @notice Note also the embedded encoding, this is required to verify what function/contract the function call goes to\r\n    /// @return Returns true if valid signatures are over the threshold\r\n    function verify_signatures(bytes calldata signatures, bytes memory message, uint256 nonce) public override returns(bool) {\r\n        require(signatures.length % 65 == 0, \"bad sig length\");\r\n        require(!used_nonces[nonce], \"nonce already used\");\r\n        uint8 sig_count = 0;\r\n\r\n        bytes32 message_hash = keccak256(abi.encode(message, msg.sender));\r\n\r\n        for(uint256 msg_idx = 0; msg_idx < signatures.length; msg_idx+= 65){\r\n            //recover address from that msg\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n            assembly {\r\n\r\n            // first 32 bytes, after the length prefix\r\n                r := calldataload(add(signatures.offset,msg_idx))\r\n            // second 32 bytes\r\n                s := calldataload(add(add(signatures.offset,msg_idx), 32))\r\n            // final byte (first byte of the next 32 bytes)\r\n                v := byte(0, calldataload(add(add(signatures.offset,msg_idx), 64)))\r\n            }\r\n            // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n            // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n            // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\r\n            // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n            //\r\n            // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n            // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n            // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n            // these malleable signatures as well.\r\n            require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Mallable signature error\");\r\n            if (v < 27) v += 27;\r\n\r\n            address recovered_address = ecrecover(message_hash, v, r, s);\r\n\r\n            if(signers[recovered_address] && !has_signed[message_hash][recovered_address]){\r\n                has_signed[message_hash][recovered_address] = true;\r\n                sig_count++;\r\n            }\r\n        }\r\n        used_nonces[nonce] = true;\r\n        return ((uint256(sig_count) * 1000) / (uint256(signer_count))) > threshold;\r\n    }\r\n\r\n    /// @return Number of valid signers\r\n    function get_valid_signer_count() public override view returns(uint8){\r\n        return signer_count;\r\n    }\r\n\r\n    /// @return Current threshold\r\n    function get_current_threshold() public override view returns(uint16) {\r\n        return threshold;\r\n    }\r\n\r\n    /// @param signer_address target potential signer address\r\n    /// @return true if address provided is valid signer\r\n    function is_valid_signer(address signer_address) public override view returns(bool){\r\n        return signers[signer_address];\r\n    }\r\n\r\n    /// @param nonce Nonce to lookup\r\n    /// @return true if nonce has been used\r\n    function is_nonce_used(uint256 nonce) public override view returns(bool){\r\n        return used_nonces[nonce];\r\n    }\r\n}\r\n\r\n/**\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\r\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\r\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................DDD\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\r\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\r\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"new_signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"SignerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"old_signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"SignerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"new_threshold\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"ThresholdSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"add_signer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_current_threshold\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_valid_signer_count\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"is_nonce_used\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer_address\",\"type\":\"address\"}],\"name\":\"is_valid_signer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"old_signer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"remove_signer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"new_threshold\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"set_threshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"verify_signatures\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MultisigControl","CompilerVersion":"v0.8.8+commit.dddeac2f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://fb9265433efee6e553a6ea1fa62168c751c6afcb346f6c8347f5063fc369ece0"}]}