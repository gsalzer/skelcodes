{"status":"1","message":"OK","result":[{"SourceCode":"{\"byn.sol\":{\"content\":\"/**\\r\\n *Submitted for verification at Etherscan.io on 2021-04-13\\r\\n*/\\r\\n\\r\\npragma solidity ^0.5.17;\\r\\n\\r\\nlibrary SafeMath\\r\\n{\\r\\n\\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n\\t\\tc = a + b;\\r\\n\\t\\trequire(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\t}\\r\\n\\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n\\t\\trequire(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n\\t\\tc = a - b;\\r\\n\\t}\\r\\n\\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n\\t\\tc = a * b;\\r\\n\\t\\trequire(a == 0 || c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\t}\\r\\n\\tfunction div(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n\\t\\trequire(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\r\\n\\t\\tc = a / b;\\r\\n\\t}\\r\\n}\\r\\n\\r\\ncontract Variable\\r\\n{\\r\\n  string public name;\\r\\n  string public symbol;\\r\\n  uint256 public decimals;\\r\\n  uint256 public totalSupply;\\r\\n  address public owner;\\r\\n\\r\\n  uint256 internal _decimals;\\r\\n  bool internal transferLock;\\r\\n  \\r\\n  mapping (address =\\u003e bool) public allowedAddress;\\r\\n  mapping (address =\\u003e bool) public blockedAddress;\\r\\n\\r\\n  mapping (address =\\u003e uint256) public balanceOf;\\r\\n  \\r\\n  mapping (address =\\u003e bool) public lockTimeAddress;\\r\\n  mapping (address =\\u003e uint8) public lockCountMonth;\\r\\n  mapping (address =\\u003e uint256) public lockPermitBalance;\\r\\n  mapping (address =\\u003e uint256[]) public lockTime;\\r\\n  mapping (address =\\u003e uint8[]) public lockPercent;\\r\\n  mapping (address =\\u003e bool[]) public lockCheck;\\r\\n  mapping (address =\\u003e uint256[]) public lockBalance;\\r\\n  \\r\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) internal allowed;\\r\\n\\r\\n  constructor() public\\r\\n  {\\r\\n    name = \\\"Beyond Finance\\\";\\r\\n    symbol = \\\"BYN\\\";\\r\\n    decimals = 18;\\r\\n    _decimals = 10 ** uint256(decimals);\\r\\n    totalSupply = _decimals * 100000000;\\r\\n    transferLock = true;\\r\\n    owner =  msg.sender;\\r\\n    balanceOf[owner] = totalSupply;\\r\\n    allowedAddress[owner] = true;\\r\\n  }\\r\\n}\\r\\n\\r\\ncontract Modifiers is Variable\\r\\n{\\r\\n  modifier isOwner\\r\\n  {\\r\\n    assert(owner == msg.sender);\\r\\n    _;\\r\\n  }\\r\\n}\\r\\n\\r\\ncontract Event\\r\\n{\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event TokenBurn(address indexed from, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ncontract manageAddress is Variable, Modifiers, Event\\r\\n{\\r\\n  using SafeMath for uint256;\\r\\n  function add_allowedAddress(address _address) public isOwner\\r\\n  {\\r\\n    allowedAddress[_address] = true;\\r\\n  }\\r\\n  function delete_allowedAddress(address _address) public isOwner\\r\\n  {\\r\\n    require(_address != owner,\\\"Not owner\\\");\\r\\n    allowedAddress[_address] = false;\\r\\n  }\\r\\n  function add_blockedAddress(address _address) public isOwner\\r\\n  {\\r\\n    require(_address != owner,\\\"Not owner\\\");\\r\\n    blockedAddress[_address] = true;\\r\\n  }\\r\\n  function delete_blockedAddress(address _address) public isOwner\\r\\n  {\\r\\n    blockedAddress[_address] = false;\\r\\n  }\\r\\n  function add_timeAddress(address _address, uint8 total_month) public isOwner\\r\\n  {\\r\\n    if(lockTimeAddress[_address] == true)\\r\\n    {\\r\\n        revert(\\\"Already set address\\\");\\r\\n    }\\r\\n    if(total_month \\u003c 2 \\u0026\\u0026 lockCountMonth[_address] \\u003e 0)\\r\\n    {\\r\\n        revert(\\\"Period want to set is short\\\");\\r\\n    }\\r\\n    lockCountMonth[_address] = total_month;\\r\\n    lockTime[_address] = new uint256[](total_month);\\r\\n    lockPercent[_address] = new uint8[](total_month);\\r\\n    lockCheck[_address] = new bool[](total_month);\\r\\n    lockBalance[_address] = new uint256[](total_month);\\r\\n  }\\r\\n  function delete_timeAddress(address _address) public isOwner\\r\\n  {\\r\\n    lockTimeAddress[_address] = false;\\r\\n    lockPermitBalance[_address] = 0;\\r\\n    for(uint8 i = 0; i \\u003c lockCountMonth[_address]; i++)\\r\\n    {\\r\\n        delete lockTime[_address][i];\\r\\n        delete lockPercent[_address][i];\\r\\n        delete lockCheck[_address][i];\\r\\n        delete lockBalance[_address][i];\\r\\n    }\\r\\n    lockCountMonth[_address] = 0;\\r\\n  }\\r\\n  function add_timeAddressMonth(address _address,uint256 _time,uint8 idx, uint8 _percent) public isOwner\\r\\n  {\\r\\n    if(now \\u003e _time)\\r\\n    {\\r\\n        revert(\\\"Must greater than current time\\\");\\r\\n    }\\r\\n    if(idx \\u003e= lockCountMonth[_address])\\r\\n    {\\r\\n        revert(\\\"Invalid Setup Period\\\");\\r\\n    }\\r\\n    if(idx != 0 \\u0026\\u0026 lockTime[_address][idx - 1] \\u003e= _time)\\r\\n    {\\r\\n        revert(\\\"Must greater than previous time\\\");\\r\\n    }\\r\\n\\r\\n    lockPercent[_address][idx] = _percent;\\r\\n    lockTime[_address][idx] = _time;\\r\\n  }\\r\\n  function add_timeAddressApply(address _address, uint256 lock_balance) public isOwner\\r\\n  {\\r\\n    if(balanceOf[_address] \\u003e= lock_balance \\u0026\\u0026 lock_balance \\u003e 0)\\r\\n    {\\r\\n        uint8 sum = lockPercent[_address][0];\\r\\n\\r\\n        lockPermitBalance[_address] = 0;\\r\\n        for(uint8 i = 0; i \\u003c lockCountMonth[_address]; i++)\\r\\n        {\\r\\n            lockBalance[_address][i] = (lock_balance.mul(lockPercent[_address][i])).div(100);\\r\\n            if(i \\u003e 0)\\r\\n            {\\r\\n                sum += lockPercent[_address][i];\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        if(sum != 100)\\r\\n        {\\r\\n            revert(\\\"Invalid percentage\\\");\\r\\n        }\\r\\n        lockTimeAddress[_address] = true;\\r\\n    }\\r\\n    else\\r\\n    {\\r\\n        revert(\\\"Invalid balance\\\");\\r\\n    }\\r\\n    \\r\\n  }\\r\\n  function refresh_lockPermitBalance(address _address) public \\r\\n  {\\r\\n    if(lockTimeAddress[_address] == false)\\r\\n    {\\r\\n        revert(\\\"Address without Lock\\\");  \\r\\n    }\\r\\n    for(uint8 i = 0; i \\u003c lockCountMonth[msg.sender]; i++)\\r\\n    {\\r\\n        if(now \\u003e= lockTime[_address][i] \\u0026\\u0026 lockCheck[_address][i] == false)\\r\\n        {\\r\\n            lockPermitBalance[_address] += lockBalance[_address][i];\\r\\n            lockCheck[_address][i] = true;\\r\\n            if(lockCountMonth[_address] - 1 == i)\\r\\n            {\\r\\n                delete_timeAddress(_address);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n  }\\r\\n}\\r\\ncontract Admin is Variable, Modifiers, Event\\r\\n{\\r\\n  using SafeMath for uint256;\\r\\n  \\r\\n  function admin_tokenBurn(uint256 _value) public isOwner returns(bool success)\\r\\n  {\\r\\n    require(balanceOf[msg.sender] \\u003e= _value, \\\"Invalid balance\\\");\\r\\n    balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\\r\\n    totalSupply = totalSupply.sub(_value);\\r\\n    emit TokenBurn(msg.sender, _value);\\r\\n    return true;\\r\\n  }\\r\\n}\\r\\ncontract Get is Variable, Modifiers\\r\\n{\\r\\n  function get_transferLock() public view returns(bool)\\r\\n  {\\r\\n    return transferLock;\\r\\n  }\\r\\n}\\r\\n\\r\\ncontract Set is Variable, Modifiers, Event\\r\\n{\\r\\n  function setTransferLock(bool _transferLock) public isOwner returns(bool success)\\r\\n  {\\r\\n    transferLock = _transferLock;\\r\\n    return true;\\r\\n  }\\r\\n}\\r\\n\\r\\ncontract BYN is Variable, Event, Get, Set, Admin, manageAddress\\r\\n{\\r\\n  function() external payable \\r\\n  {\\r\\n    revert();\\r\\n  }\\r\\n  function allowance(address tokenOwner, address spender) public view returns (uint256 remaining) \\r\\n  {\\r\\n    return allowed[tokenOwner][spender];\\r\\n  }\\r\\n  function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) \\r\\n  {\\r\\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\\r\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\r\\n    return true;\\r\\n  }\\r\\n  function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool)\\r\\n  {\\r\\n    uint256 oldValue = allowed[msg.sender][_spender];\\r\\n    if (_subtractedValue \\u003e oldValue) \\r\\n    {\\r\\n        allowed[msg.sender][_spender] = 0;\\r\\n    } \\r\\n    else\\r\\n    {\\r\\n        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\r\\n    }\\r\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\r\\n    return true;\\r\\n  }\\r\\n  function approve(address _spender, uint256 _value) public returns (bool)\\r\\n  {\\r\\n    allowed[msg.sender][_spender] = _value;\\r\\n    emit Approval(msg.sender, _spender, _value);\\r\\n    return true;\\r\\n  }\\r\\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) \\r\\n  {\\r\\n    require(allowedAddress[_from] || transferLock == false, \\\"Transfer lock : true\\\");\\r\\n    require(!blockedAddress[_from] \\u0026\\u0026 !blockedAddress[_to] \\u0026\\u0026 !blockedAddress[msg.sender], \\\"Blocked address\\\");\\r\\n    require(balanceOf[_from] \\u003e= _value \\u0026\\u0026 (balanceOf[_to].add(_value)) \\u003e= balanceOf[_to], \\\"Invalid balance\\\");\\r\\n    require(lockTimeAddress[_to] == false, \\\"Lock address : to\\\");\\r\\n    require(_value \\u003c= allowed[_from][msg.sender], \\\"Invalid balance : allowed\\\");\\r\\n\\r\\n    if(lockTimeAddress[_from])\\r\\n    {\\r\\n        lockPermitBalance[_from] = lockPermitBalance[_from].sub(_value);\\r\\n    }\\r\\n\\r\\n    balanceOf[_from] = balanceOf[_from].sub(_value);\\r\\n    balanceOf[_to] = balanceOf[_to].add(_value);\\r\\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\r\\n    emit Transfer(_from, _to, _value);\\r\\n\\r\\n    return true;\\r\\n\\r\\n  }\\r\\n  \\r\\n  function transfer(address _to, uint256 _value) public returns (bool)  \\r\\n  {\\r\\n    require(allowedAddress[msg.sender] || transferLock == false, \\\"Transfer lock : true\\\");\\r\\n    require(!blockedAddress[msg.sender] \\u0026\\u0026 !blockedAddress[_to], \\\"Blocked address\\\");\\r\\n    require(balanceOf[msg.sender] \\u003e= _value \\u0026\\u0026 (balanceOf[_to].add(_value)) \\u003e= balanceOf[_to], \\\"Invalid balance\\\");\\r\\n    require(lockTimeAddress[_to] == false, \\\"Lock address : to\\\");\\r\\n\\r\\n    if(lockTimeAddress[msg.sender])\\r\\n    {\\r\\n        lockPermitBalance[msg.sender] = lockPermitBalance[msg.sender].sub(_value);\\r\\n    }\\r\\n\\r\\n    balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\\r\\n    balanceOf[_to] = balanceOf[_to].add(_value);\\r\\n    emit Transfer(msg.sender, _to, _value);\\r\\n        \\r\\n    return true;\\r\\n  }\\r\\n}\"},\"mymongstaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.5.17;\\r\\npragma experimental ABIEncoderV2;\\r\\nimport \\u0027./byn.sol\\u0027;\\r\\nimport \\u0027./Ownable.sol\\u0027;\\r\\n\\r\\ncontract MyMongStaking is Ownable {\\r\\n    using SafeMath for uint256;\\r\\n    uint256 public _decimals;\\r\\n    uint256 public _packageCount;\\r\\n    uint256 public earlyFeePercentage;\\r\\n    uint256 public totalStackingAmount;\\r\\n\\r\\n    mapping(uint256 =\\u003e PackageStaking) private packages;\\r\\n\\r\\n    mapping(address =\\u003e StakingInfo) private stakingInfo;\\r\\n\\r\\n    BYN public bynToken;\\r\\n\\r\\n    event Deposit(address a, uint256 amount, uint256 idPackage);\\r\\n    event Withdraw(address a, uint256 amountDeposit, uint256 amountReceive, uint256 idPackage);\\r\\n    event Claim(address a, uint256 amountClaim, uint256 timeClaim);\\r\\n\\r\\n    struct PackageStaking {\\r\\n        uint256 duration;\\r\\n        uint256 dapr;\\r\\n        bool active;\\r\\n    }\\r\\n\\r\\n    struct StakingInfo {\\r\\n        uint256 amountDeposit;\\r\\n        uint256 registerTime;\\r\\n        uint256 lastTimeClaim;\\r\\n        uint256 expireTime;\\r\\n        uint256 packageId;\\r\\n        uint256 lastTimeUnstake;\\r\\n        bool isUnstake;\\r\\n    }\\r\\n\\r\\n    constructor(BYN _bynToken, uint8 decimals_ , uint256 earlyFeePercentage_) public {\\r\\n        bynToken = _bynToken;\\r\\n        _decimals = decimals_;\\r\\n        _packageCount = 0;\\r\\n        earlyFeePercentage = earlyFeePercentage_;\\r\\n        addPackage(15,862867233567544,true);\\r\\n        addPackage(30,1288510593391520,true);\\r\\n        addPackage(60,1887078676226620,true);\\r\\n        addPackage(120,2502530802063640,true);\\r\\n    }\\r\\n\\r\\n    function changeEarlyFeePercentage(uint256 percent)  onlyOwner public {\\r\\n        earlyFeePercentage = percent;\\r\\n    }\\r\\n\\r\\n    function packageInfo(uint256 idPackage) public view returns (PackageStaking memory) {\\r\\n        return packages[idPackage];        \\r\\n    }\\r\\n\\r\\n    function listPackage() public view returns (PackageStaking[] memory ) {\\r\\n        PackageStaking[] memory data = new PackageStaking[](_packageCount);\\r\\n        for(uint i=0; i\\u003c_packageCount;i++){\\r\\n            data[i]=(packages[i]);\\r\\n        }\\r\\n\\r\\n        return data;\\r\\n    }\\r\\n\\r\\n\\r\\n    function addPackage(uint256 duration, uint256 percentage, bool active) onlyOwner public {\\r\\n        packages[_packageCount++]= PackageStaking(duration.mul(3600), percentage, active);\\r\\n    }\\r\\n\\r\\n    function deactivePackage(uint256 idPackage) onlyOwner public {\\r\\n        require(idPackage\\u003c _packageCount);\\r\\n        require(packages[idPackage].active== true,\\\"no need deactive\\\");\\r\\n        packages[idPackage].active= false;        \\r\\n    }\\r\\n\\r\\n    function deposit(uint256 amount, uint256 packageId) public {\\r\\n        require(!_doStaking(msg.sender),\\\"Cannot restaking \\\");\\r\\n        require(packageId \\u003c _packageCount \\u0026\\u0026 packages[packageId].duration \\u003e0 || packages[packageId].active == true, \\\"Can\\u0027t find package or packages is off\\\" );\\r\\n        require(amount\\u003e0,\\\"amount invalid\\\");\\r\\n        require(bynToken.balanceOf(msg.sender) \\u003e= amount, \\\"you account not have money\\\");\\r\\n        bynToken.transferFrom(msg.sender, address(this), amount);\\r\\n        uint256 currentTime=block.timestamp;\\r\\n        stakingInfo[msg.sender] = StakingInfo(amount, currentTime, currentTime, currentTime+packages[packageId].duration, packageId, currentTime+packages[packageId].duration, false);\\r\\n        totalStackingAmount= totalStackingAmount.add(amount);\\r\\n        emit Deposit(msg.sender, amount, packageId);\\r\\n    }\\r\\n\\r\\n    function withdraw() public {\\r\\n        require(_doStaking(msg.sender),\\\"You not staking\\\");\\r\\n        require(stakingInfo[msg.sender].lastTimeUnstake \\u003e 0, \\\"You need to unstake instead\\\");\\r\\n        require((stakingInfo[msg.sender].lastTimeUnstake + 600) \\u003c= block.timestamp, \\\"Cannot withdraw before 5 days after unstaked\\\" );\\r\\n        (uint256 amountReward, , ) = _calculatorClaim(msg.sender);\\r\\n        uint256 total=0;\\r\\n        if(block.timestamp \\u003e= stakingInfo[msg.sender].expireTime){\\r\\n            total = amountReward.add(stakingInfo[msg.sender].amountDeposit);\\r\\n            require(bynToken.balanceOf(address(this)) \\u003e= total, \\\"Smartcontract not enough money\\\");\\r\\n            bynToken.transfer(msg.sender, total);\\r\\n        }else{\\r\\n            total = amountReward.add(stakingInfo[msg.sender].amountDeposit);\\r\\n            total= total.sub(amountReward.mul(earlyFeePercentage).div(10**_decimals));\\r\\n            require(bynToken.balanceOf(address(this)) \\u003e= total, \\\"Smartcontract not enough money\\\");\\r\\n            bynToken.transfer(msg.sender, total);\\r\\n        }\\r\\n        totalStackingAmount=totalStackingAmount.sub(stakingInfo[msg.sender].amountDeposit);\\r\\n        emit Withdraw(msg.sender, stakingInfo[msg.sender].amountDeposit, total, stakingInfo[msg.sender].packageId);\\r\\n        _clear(msg.sender);\\r\\n    }\\r\\n\\r\\n    function unstake() public {\\r\\n        require(stakingInfo[msg.sender].isUnstake == false, \\\"You can not unstake\\\");\\r\\n        stakingInfo[msg.sender].lastTimeUnstake = block.timestamp;\\r\\n        stakingInfo[msg.sender].isUnstake = true;\\r\\n    }\\r\\n\\r\\n    function _clear(address a) internal {\\r\\n        stakingInfo[a].amountDeposit = 0;\\r\\n        stakingInfo[a].registerTime = 0;\\r\\n        stakingInfo[a].lastTimeClaim = 0;\\r\\n        stakingInfo[a].packageId = 0;\\r\\n        stakingInfo[a].expireTime = 0;\\r\\n        stakingInfo[a].lastTimeUnstake = 0;\\r\\n        stakingInfo[a].isUnstake = false;\\r\\n    }\\r\\n\\r\\n    function ownerWithdrawAll() onlyOwner public {\\r\\n        bynToken.transfer(owner(), bynToken.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function _calculatorClaim(address a) internal view returns (uint256 amountReward, uint256 totalDivideReward,uint256 timeDivide){\\r\\n        StakingInfo memory info = stakingInfo[a];\\r\\n        timeDivide = 3600; \\r\\n        if( info.registerTime == 0 || info.amountDeposit ==0) return (0,0, timeDivide);\\r\\n        PackageStaking memory pack = packages[info.packageId];\\r\\n\\r\\n        uint256 currentTimeReward;\\r\\n        if(block.timestamp \\u003e= info.expireTime) {\\r\\n            currentTimeReward = info.expireTime;\\r\\n        } else {\\r\\n            currentTimeReward = block.timestamp \\u003e= info.lastTimeUnstake ? info.lastTimeUnstake: block.timestamp;\\r\\n        }\\r\\n        \\r\\n        \\r\\n        if(currentTimeReward.sub(info.lastTimeClaim)\\u003e=timeDivide){\\r\\n            totalDivideReward = currentTimeReward.sub(info.lastTimeClaim).div(timeDivide);\\r\\n            uint256 amount =info.amountDeposit ;\\r\\n            for(uint i=0;i\\u003ctotalDivideReward;i++ ){\\r\\n                amount = amount.add(amount.mul(pack.dapr).div(10**_decimals));\\r\\n            }\\r\\n            amount = amount.sub(info.amountDeposit);\\r\\n            return (amount, totalDivideReward, timeDivide);\\r\\n        }else{\\r\\n            return (0,0, timeDivide);\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    function stakingInfoOf(address a) public view  returns (uint256 amountDeposit,\\r\\n        uint256 registerTime,\\r\\n        uint256 lastTimeClaim,\\r\\n        uint256 expireTime,\\r\\n        uint256 packageId,\\r\\n        uint256 nextTimeClaim,\\r\\n        uint256 lastTimeUnstake,\\r\\n        bool isUnstake){\\r\\n        StakingInfo memory info = stakingInfo[a];        \\r\\n        return( info.amountDeposit,\\r\\n            info.registerTime,\\r\\n            info.lastTimeClaim,\\r\\n            info.expireTime,\\r\\n            info.packageId,\\r\\n            info.lastTimeClaim.add(86400),\\r\\n            info.lastTimeUnstake,\\r\\n            info.isUnstake\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function calculatorClaim(address a) public view  returns (uint256 amountReward,uint256 totalDivideReward,uint256 timeDivide) {\\r\\n        return _calculatorClaim(a);\\r\\n    }\\r\\n\\r\\n    function _doStaking(address a) internal view returns (bool doStaking) {\\r\\n        StakingInfo memory info = stakingInfo[a];        \\r\\n        return  info.amountDeposit!=0  ;\\r\\n    }\\r\\n\\r\\n    function doStakingOf(address a) public view returns (bool doStaking) {\\r\\n        return _doStaking(a);\\r\\n    }\\r\\n\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n \\r\\npragma solidity ^0.5.17;\\r\\n \\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\ncontract Context {\\r\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n    // an instance of this contract, which should be used via inheritance.\\r\\n    constructor () internal { }\\r\\n    // solhint-disable-previous-line no-empty-blocks\\r\\n \\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n \\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n \\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n \\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n \\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () internal {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Returns true if the caller is the current owner.\\r\\n     */\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return _msgSender() == _owner;\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n    \\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n    */\\r\\n \\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract BYN\",\"name\":\"_bynToken\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"earlyFeePercentage_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountClaim\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeClaim\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idPackage\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountReceive\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idPackage\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"_decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_packageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"addPackage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bynToken\",\"outputs\":[{\"internalType\":\"contract BYN\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"calculatorClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDivideReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeDivide\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"changeEarlyFeePercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idPackage\",\"type\":\"uint256\"}],\"name\":\"deactivePackage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"doStakingOf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"doStaking\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"earlyFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"listPackage\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dapr\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct MyMongStaking.PackageStaking[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerWithdrawAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idPackage\",\"type\":\"uint256\"}],\"name\":\"packageInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dapr\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct MyMongStaking.PackageStaking\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"stakingInfoOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"registerTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTimeClaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextTimeClaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTimeUnstake\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnstake\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStackingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MyMongStaking","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004bb3205bf648b7f59ef90dee0f1b62f6116bc7ca0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000058d15e176280000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://1eb102b19844861a1f2746547582a9b7109771347ced69bb04eb230e389cd6e5"}]}