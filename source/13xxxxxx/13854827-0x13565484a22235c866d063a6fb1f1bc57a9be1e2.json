{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/v0/libraries/Calculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.4;\\n\\nlibrary Calculator {\\n    /**\\n     * Represents the return value of the `calcTokens` method.\\n     *\\n     * The fields:\\n     * - `tokensAmount`: the amount of tokens that may be bought for the given\\n     *   amount of USD at the given token supply;\\n     * - `maintainerBonusTokensAmount`: the amount of maintainer bonus tokens\\n     *   to be minted when selling the `tokensAmount` at the given token supply;\\n     * - `bountyBonusTokensAmount`: the amount of bounty bonus tokens to be\\n     *   minted when selling the `tokensAmount` at the given token supply;\\n     * - `nextNodeId`: the adjusted value for the supply node pointer\\n     *   immediately after `tokensAmount`, `maintainerBonusTokensAmount`\\n     *   and `bountyBonusTokensAmount` are minted;\\n     * - `nextPricePerToken`: the price per token (in USD) immediately after\\n     *   `tokensAmount`, `maintainerBonusTokensAmount` and\\n     *   `bountyBonusTokensAmount` are minted.\\n     */\\n    struct Result {\\n        uint256 tokensAmount;\\n        uint256 maintainerBonusTokensAmount;\\n        uint256 bountyBonusTokensAmount;\\n        uint8 nextNodeId;\\n        uint256 nextPricePerToken;\\n    }\\n\\n    /**\\n     * @dev internal state used by token calculations loop\\n     */\\n    // solhint-disable-next-line contract-name-camelcase\\n    struct _LoopState {\\n        uint256 prev;\\n        uint256 curr;\\n        uint256 next;\\n    }\\n\\n    /**\\n     * Must be in sync with contract's decimals() implementation\\n     */\\n    uint8 public constant DECIMALS = 18;\\n\\n    /**\\n     * The price per token threshold above which a maintainer bonus tokens are\\n     * additionally minted on every sold chunk of tokens in an amount equal\\n     * to 1/10 of the chunk sold.\\n     */\\n    uint256 public constant MAINTAINER_BONUS_PRICE_THRESHOLD =\\n        10 * 10**DECIMALS;\\n\\n    /**\\n     * The price per token threshold above which a bounty bonus tokens are\\n     * additionally minted on every sold chunk of tokens in an amount equal\\n     * to 1/10 of the chunk sold.\\n     */\\n    uint256 public constant BOUNTY_BONUS_PRICE_THRESHOLD = 20 * 10**DECIMALS;\\n\\n    /**\\n     * Adjusts the pointer value so it points to `supplyLUT` segment\\n     * corresponding to the token `supply`\\n     */\\n    function adjustNodeId(\\n        uint8 nodeId,\\n        uint256 supply,\\n        uint256[] storage supplyLUT\\n    ) public view returns (uint8) {\\n        if (supply < supplyLUT[nodeId + 1]) {\\n            if (supply < supplyLUT[nodeId]) {\\n                // decrease\\n                while (true) {\\n                    nodeId -= 1;\\n                    if (supply >= supplyLUT[nodeId]) {\\n                        return nodeId;\\n                    }\\n                }\\n            }\\n        } else {\\n            // increase\\n            while (true) {\\n                nodeId += 1;\\n                if (supply < supplyLUT[nodeId + 1]) {\\n                    return nodeId;\\n                }\\n            }\\n        }\\n\\n        return nodeId;\\n    }\\n\\n    /**\\n     * Determines the number of tokens that can be bought for the given\\n     * `usdAmount` at the specified `supply` according to the\\n     * price per token growth function represented by reference points from the\\n     * provided supply and price lookup tables (LUTs); additionally,\\n     * determines the number of maintainer and bounty bonus tokens to be minted.\\n     *\\n     * The tokens are sold in chunks, each chunk is defined by the distance\\n     * between two supply nodes in the `supplyLUT`; the price of a partial\\n     * chunk (the final chunk of each purchase) is determined using linear\\n     * approximation. See `LUTsLoader` for values stored in these LUTs.\\n     *\\n     * Maintainer and bounty bonus tokens are started to being calculated\\n     * after the current price per token surpasses the `MAINTAINER_BONUS_PRICE_THRESHOLD`\\n     * and `BOUNTY_BONUS_PRICE_THRESHOLD` thresholds respectively if not\\n     * suppressed by `suppressMaintainerBonus` and/or `suppressBountyBonus`\\n     * flags respectively. The amount of bonus tokens to be minted is being\\n     * added on each chunk rather than on each purchase to ensure\\n     * the price per token grows gradually even during the large atomic purchases.\\n     *\\n     * See `Result` struct for retval reference.\\n     *\\n     * @param usdAmount the amount of USD to spend\\n     * @param supply the current token supply\\n     * @param nodeId the adjusted pointer to the `supplyLUT` segment which corresponds to the current `supply`\\n     * @param suppressMaintainerBonus the flag to suppress maintainer bonus tokens calculations (regardless of the current price per token)\\n     * @param suppressBountyBonus the flag to suppress bounty bonus tokens calculations (regardless of the current price per token)\\n     * @param supplyLUT the LUT containing a supply growth scale\\n     * @param priceLUT the LUT containing price per token for each element of the `supplyLUT`\\n     */\\n    // solhint-disable-next-line function-max-lines\\n    function calcTokens(\\n        uint256 usdAmount,\\n        uint256 supply,\\n        uint8 nodeId,\\n        bool suppressMaintainerBonus,\\n        bool suppressBountyBonus,\\n        uint256[] storage supplyLUT,\\n        uint256[] storage priceLUT\\n    ) public view returns (Result memory r) {\\n        require(\\n            supply >= supplyLUT[nodeId] && supply < supplyLUT[nodeId + 1],\\n            \\\"nodeId is out of sync\\\"\\n        );\\n\\n        r.nextNodeId = nodeId;\\n\\n        // values are calculated on every loop\\n        _LoopState memory supplyNode = _LoopState(0, supply, 0);\\n        _LoopState memory priceNode = _LoopState(0, 0, 0);\\n\\n        while (true) {\\n            supplyNode.prev = supplyLUT[r.nextNodeId];\\n            supplyNode.next = supplyLUT[r.nextNodeId + 1];\\n\\n            priceNode.prev = priceLUT[r.nextNodeId];\\n            priceNode.next = priceLUT[r.nextNodeId + 1];\\n\\n            // current price is determined using linear approximation\\n            priceNode.curr = _approxPricePerToken(supplyNode, priceNode);\\n\\n            // take less than the beginning of the next node\\n            uint256 usdAmountMaxed = usdAmount * 10**DECIMALS;\\n            uint256 tokensByIteration;\\n\\n            // this branch is for the case when the remaining usdAmount is not\\n            // enough to buy out the next segment completely (this is the last)\\n            if (\\n                supplyNode.next - supplyNode.curr >\\n                (2 * usdAmountMaxed) / (priceNode.next + priceNode.curr)\\n            ) {\\n                // adjust supply, as the segment is partially bought\\n                _LoopState memory adjustedSupplyNode = _LoopState(\\n                    supplyNode.prev,\\n                    supplyNode.curr +\\n                        usdAmountMaxed /\\n                        (priceNode.next + priceNode.curr),\\n                    supplyNode.next\\n                );\\n\\n                tokensByIteration =\\n                    usdAmountMaxed /\\n                    _approxPricePerToken(adjustedSupplyNode, priceNode);\\n\\n                r.tokensAmount += tokensByIteration;\\n                supplyNode.curr += tokensByIteration;\\n\\n                // since this branch is partial, no more USD left\\n                usdAmount = 0;\\n            }\\n            // this branch is for the case when the whole segment is bought out\\n            else {\\n                tokensByIteration = supplyNode.next - supplyNode.curr;\\n\\n                r.tokensAmount += tokensByIteration;\\n                supplyNode.curr = supplyNode.next;\\n                r.nextNodeId += 1;\\n\\n                usdAmount -=\\n                    (tokensByIteration *\\n                        ((priceNode.curr + priceNode.next) / 2)) /\\n                    10**DECIMALS;\\n            }\\n\\n            // calc bonus tokens for this loop\\n            if (\\n                false == suppressMaintainerBonus &&\\n                priceNode.curr >= MAINTAINER_BONUS_PRICE_THRESHOLD\\n            ) {\\n                r.maintainerBonusTokensAmount += tokensByIteration / 10;\\n                supplyNode.curr += tokensByIteration / 10;\\n            }\\n\\n            if (\\n                false == suppressBountyBonus &&\\n                priceNode.curr >= BOUNTY_BONUS_PRICE_THRESHOLD\\n            ) {\\n                r.bountyBonusTokensAmount += tokensByIteration / 10;\\n                supplyNode.curr += tokensByIteration / 10;\\n            }\\n\\n            // nodeId may change after calculated bonuses issued\\n            r.nextNodeId = adjustNodeId(\\n                r.nextNodeId,\\n                supplyNode.curr,\\n                supplyLUT\\n            );\\n\\n            if (usdAmount == 0) break;\\n        }\\n\\n        // adjust the current price per token for the caller code\\n        r.nextPricePerToken = _approxPricePerToken(supplyNode, priceNode);\\n    }\\n\\n    /**\\n     * Linearly approximates the price per token between two nodes\\n     */\\n    function _approxPricePerToken(\\n        _LoopState memory supplyNode,\\n        _LoopState memory priceNode\\n    ) private pure returns (uint256) {\\n        return\\n            ((supplyNode.curr - supplyNode.prev) *\\n                (priceNode.next - priceNode.prev)) /\\n            (supplyNode.next - supplyNode.prev) +\\n            priceNode.prev;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"evmVersion\": \"berlin\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"BOUNTY_BONUS_PRICE_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAINTAINER_BONUS_PRICE_THRESHOLD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Calculator","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}