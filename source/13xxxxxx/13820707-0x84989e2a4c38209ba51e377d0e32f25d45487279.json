{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"SeedSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// 84 71 32 64 84 104 101 71 104 111 115 116 68 101 118 \\n// ASCII\\n\\npragma solidity ^0.8.0;\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ncontract SwapContract is Ownable {\\n    using SafeMath for uint256;\\n\\n    IERC20 public tokenOutput;\\n\\n    struct TokenInputInfo {\\n        address addr;\\n        uint256 rateInput;\\n        uint256 rateOutput;\\n    }\\n    mapping (uint256 => TokenInputInfo) public tokenInput;\\n\\n    struct VipVesting {\\n        uint256 totalBalance;\\n        uint256 totalClaimed;\\n        uint256 start;\\n        uint256 end;\\n        uint256 releasePercentWhenStart;\\n        uint256 releasePercentEachMonth;\\n        uint256 claimedCheckPoint;\\n\\n        // To calculate Reward\\n        uint256 rewardTokenDebt;\\n        uint256 rewardEthDebt;\\n    }\\n    mapping (address => VipVesting) public vestingList;\\n    mapping (address => bool) public isBlacklistWallet;\\n\\n    uint256 public totalTokenForSwapping;\\n    uint256 public totalTokenForSeed;\\n    uint256 public totalTokenForPublic;\\n\\n    uint256 public soldAmountSeed        = 0;\\n    uint256 public soldAmountPublic      = 0;\\n    uint256 public soldTotal             = 0;\\n\\n    uint256 public TYPE_SEED = 1;\\n    uint256 public TYPE_PUBLIC = 2;\\n\\n    uint256 public MONTH = 30 days;\\n\\n    bool public swapEnabled;\\n\\n    constructor() {}    \\n    \\n    function startSwap(address outputToken) public onlyOwner{\\n        require(swapEnabled == false, \\\"Swap already started\\\");\\n        tokenOutput = IERC20(outputToken);\\n        swapEnabled = true;\\n    }\\n\\n    function stopSwap() public onlyOwner {\\n        swapEnabled = false;\\n    }\\n\\n    function addInputTokenForSwap(uint256 _id, address _inputToken, uint256 _inputRate, uint256 _outputRate)public onlyOwner{\\n        require(_id < 3);\\n        tokenInput[_id].addr = _inputToken;\\n        tokenInput[_id].rateInput = _inputRate;\\n        tokenInput[_id].rateOutput = _outputRate;\\n    }\\n\\n    receive() external payable {\\n    }\\n\\n    function setBlacklistWallet(address account, bool blacklisted) external onlyOwner {\\n        isBlacklistWallet[account] = blacklisted;\\n    }\\n\\n    function addOutputTokenForSwap(uint256 amount) public onlyOwner{    \\n        tokenOutput.transferFrom(msg.sender, address(this), amount);\\n        totalTokenForSwapping = totalTokenForSwapping.add(amount);\\n    }\\n\\n    function ownerWithdrawToken(address tokenAddress, uint256 amount) public onlyOwner{    \\n        if(tokenAddress == address(tokenOutput)){\\n            require(amount < totalTokenForSwapping.sub(soldTotal), \\\"You're trying withdraw an amount that exceed availabe balance\\\");\\n            totalTokenForSwapping = totalTokenForSwapping.sub(amount);\\n        }\\n        IERC20(tokenAddress).transfer(msg.sender, amount);\\n    }\\n\\n    function getClaimableInVesting(address account) public view returns (uint256){\\n        VipVesting memory vestPlan = vestingList[account];\\n\\n        //Already withdraw all\\n        if(vestPlan.totalClaimed == vestPlan.totalBalance){\\n            return 0;\\n        }\\n\\n        //No infor\\n        if(vestPlan.start == 0 || vestPlan.end == 0 || vestPlan.totalBalance == 0){\\n            return 0;\\n        }\\n        \\n        uint256 currentTime = block.timestamp;\\n        if(currentTime >= vestPlan.end){\\n            return vestPlan.totalBalance.sub(vestPlan.totalClaimed);\\n        }else {\\n            uint256 currentCheckPoint = (currentTime - vestPlan.start) / MONTH;\\n            if(currentCheckPoint > vestPlan.claimedCheckPoint){\\n                uint256 claimable =  ((currentCheckPoint - vestPlan.claimedCheckPoint)* vestPlan.releasePercentEachMonth * vestPlan.totalBalance) / 10000;\\n                return claimable;\\n            }else\\n                return 0;\\n        }\\n    }\\n\\n    function balanceRemainingInVesting(address account) public view returns(uint256){\\n        VipVesting memory vestPlan = vestingList[account];\\n        return vestPlan.totalBalance -  vestPlan.totalClaimed;\\n    }\\n\\n    function withDrawFromVesting() public {\\n        VipVesting storage vestPlan = vestingList[msg.sender];\\n\\n        uint256 claimableAmount = getClaimableInVesting(msg.sender);\\n        require(claimableAmount > 0, \\\"There isn't token in vesting that claimable at the moment\\\");\\n\\n        uint256 currentTime = block.timestamp;\\n        if(currentTime > vestPlan.end){\\n            currentTime = vestPlan.end;\\n        }\\n        \\n        vestPlan.claimedCheckPoint = (currentTime - vestPlan.start) / MONTH;\\n        vestPlan.totalClaimed = vestPlan.totalClaimed.add(claimableAmount);\\n\\n        tokenOutput.transfer(msg.sender, claimableAmount);\\n    }\\n\\n    function deposite(uint256 inputTokenId, uint256 inputAmount, uint256 buyType) public payable {\\n        require(inputTokenId < 3, \\\"Invalid input token ID\\\");\\n        require(isBlacklistWallet[msg.sender] == false, \\\"You're in blacklist\\\");\\n        require(swapEnabled, \\\"Swap is not available\\\");\\n\\n        IERC20 inputToken = IERC20(tokenInput[inputTokenId].addr);\\n\\n        uint256 numOutputToken = inputAmount.mul(tokenInput[inputTokenId].rateOutput).mul(10**tokenOutput.decimals()).div(tokenInput[inputTokenId].rateInput);\\n        if(buyType == TYPE_SEED)\\n            numOutputToken = numOutputToken.mul(3);\\n     \\n        require(numOutputToken < totalTokenForSwapping.sub(soldTotal), \\\"Exceed avaialble token\\\");\\n\\n        inputToken.transferFrom(msg.sender, address(this), inputAmount.mul(10**inputToken.decimals()));\\n        soldTotal = soldTotal.add(numOutputToken);\\n        addingVestToken(msg.sender, numOutputToken, buyType);\\n    }\\n\\n    function addingVestToken(address account, uint256 amount, uint256 vType) private {\\n        VipVesting storage vestPlan = vestingList[account];\\n        if(vType == TYPE_SEED){\\n            soldAmountSeed = soldAmountSeed.add(amount);\\n            vestPlan.releasePercentWhenStart = 833; // 8.33%\\n            vestPlan.releasePercentEachMonth = 833; // 8.33%\\n        }else{\\n            soldAmountPublic = soldAmountPublic.add(amount);\\n            tokenOutput.transfer(account, amount);\\n            return;\\n        }\\n\\n        vestPlan.totalBalance = vestPlan.totalBalance.add(amount);\\n        vestPlan.start = vestPlan.start == 0 ? block.timestamp : vestPlan.start;\\n        vestPlan.end = vestPlan.end == 0 ? block.timestamp + ((10000 - vestPlan.releasePercentWhenStart)/vestPlan.releasePercentEachMonth) * MONTH : vestPlan.end;\\n\\n        uint256 claimNow = (amount * vestPlan.releasePercentWhenStart)/10000;\\n        vestPlan.totalClaimed = vestPlan.totalClaimed.add(claimNow);\\n\\n        tokenOutput.transfer(account, claimNow);\\n    }\\n\\n    /*REWARD FOR VESTING*/\\n    address public rewardToken;\\n    uint256 public amountTokenForReward;\\n    uint256 public amountEthForReward;\\n\\n    uint256 public totalRewardEthDistributed;\\n    uint256 public totalRewardTokenDistributed;\\n\\n    uint256 public rewardTokenPerSecond;\\n    uint256 public rewardEthPerSecond;\\n\\n    // Accrued token per share\\n    uint256 public accTokenPerShare;    \\n    // Accrued EHT per share\\n    uint256 public accEthPerShare;\\n    // The block number of the last pool update\\n    uint256 public lastRewardTime;\\n    // The precision factor\\n    uint256 public PRECISION_FACTOR = 10**12;\\n\\n    bool public enableRewardSystem;\\n\\n    function startRewardSystem(address _rewardToken) public onlyOwner{\\n        enableRewardSystem = true;\\n        rewardToken = _rewardToken;\\n        rewardTokenPerSecond = 0.05 ether;   // 0.65 token/block\\n        rewardEthPerSecond = 0.000004 ether; // 10 eth/month\\n        \\n        lastRewardTime = block.timestamp;\\n    }\\n\\n    function setNewRewardToken(address _rewardToken)public onlyOwner{\\n        rewardToken = _rewardToken;\\n    }\\n\\n    function setRewardTokenPerSecond(uint256 _rewardTokenPerSecond) public onlyOwner{\\n        rewardTokenPerSecond = _rewardTokenPerSecond;\\n    }\\n\\n    function setRewardEthPerSecond(uint256 _rewardEthPerSecond) public onlyOwner{\\n        rewardEthPerSecond = _rewardEthPerSecond;\\n    }\\n\\n    function addTokenForReward(uint256 amount) public {\\n        IERC20(rewardToken).transferFrom(msg.sender, address(this), amount);\\n        amountTokenForReward = amountTokenForReward.add(amount);\\n    }\\n\\n    function addEthForReward() payable public {\\n        amountEthForReward = amountEthForReward.add(msg.value);\\n    }\\n\\n     \\n    /*\\n     * Harvest reward\\n     */\\n    function harvest() public {\\n        _updatePool();\\n        VipVesting storage user = vestingList[msg.sender];\\n\\n        if (user.totalBalance > 0) {\\n            uint256 pendingToken = user.totalBalance.mul(accTokenPerShare).div(PRECISION_FACTOR).sub(user.rewardTokenDebt);\\n            uint256 pendingEth = user.totalBalance.mul(accEthPerShare).div(PRECISION_FACTOR).sub(user.rewardEthDebt);\\n            if (pendingToken > 0) {\\n                IERC20(rewardToken).transfer( address(msg.sender), pendingToken);\\n            }\\n            if (pendingEth > 0) {\\n                payable(msg.sender).transfer(pendingEth);\\n            }\\n        }\\n        user.rewardTokenDebt = user.totalBalance.mul(accTokenPerShare).div(PRECISION_FACTOR);\\n        user.rewardEthDebt = user.totalBalance.mul(accEthPerShare).div(PRECISION_FACTOR);\\n    }\\n\\n    /*\\n     * @notice View function to see pending reward on frontend.\\n     * @param _user: user address\\n     * @return Pending reward for a given user\\n     */\\n    function pendingReward(address _user) external view returns (uint256, uint256) {\\n        VipVesting storage user = vestingList[_user];\\n        uint256 pendingToken;\\n        uint256 pendingEth;\\n        \\n        if(enableRewardSystem ==  false){\\n            return (0, 0);\\n        }\\n\\n        if (block.timestamp > lastRewardTime && soldAmountSeed != 0) {\\n            uint256 multiplier = _getMultiplier(lastRewardTime, block.timestamp);\\n\\n            uint256 tokenReward = multiplier.mul(rewardTokenPerSecond);\\n            if(tokenReward > amountTokenForReward){\\n                tokenReward = amountTokenForReward;\\n            }\\n            uint256 adjustedTokenPerShare = accTokenPerShare.add(tokenReward.mul(PRECISION_FACTOR).div(soldAmountSeed));\\n\\n            uint256 ethReward = multiplier.mul(rewardEthPerSecond);\\n            if(ethReward > amountEthForReward){\\n                ethReward = amountEthForReward;\\n            }\\n            uint256 adjustedEthPerShare = accEthPerShare.add(ethReward.mul(PRECISION_FACTOR).div(soldAmountSeed));\\n\\n            pendingToken =  user.totalBalance.mul(adjustedTokenPerShare).div(PRECISION_FACTOR).sub(user.rewardTokenDebt);\\n            pendingEth =  user.totalBalance.mul(adjustedEthPerShare).div(PRECISION_FACTOR).sub(user.rewardEthDebt);\\n        } else {\\n            pendingToken = user.totalBalance.mul(accTokenPerShare).div(PRECISION_FACTOR).sub(user.rewardTokenDebt);\\n            pendingEth = user.totalBalance.mul(accEthPerShare).div(PRECISION_FACTOR).sub(user.rewardEthDebt);\\n        }\\n\\n        return (pendingToken, pendingEth);\\n    }\\n\\n\\n    /*\\n     * @notice Update reward variables of the given pool to be up-to-date.\\n     */\\n    function _updatePool() internal {\\n        if (block.timestamp <= lastRewardTime) {\\n            return;\\n        }\\n\\n        if (enableRewardSystem == false || soldAmountSeed == 0) {\\n            lastRewardTime = block.timestamp;\\n            return;\\n        }\\n\\n        uint256 multiplier = _getMultiplier(lastRewardTime, block.timestamp);\\n\\n        uint256 tokenReward = multiplier.mul(rewardTokenPerSecond);\\n        if(tokenReward > amountTokenForReward){\\n            tokenReward = amountTokenForReward;\\n        }\\n        accTokenPerShare = accTokenPerShare.add(tokenReward.mul(PRECISION_FACTOR).div(soldAmountSeed));\\n        amountTokenForReward = amountTokenForReward.sub(tokenReward);\\n        totalRewardTokenDistributed = totalRewardTokenDistributed.add(tokenReward);\\n\\n\\n        uint256 ethReward = multiplier.mul(rewardEthPerSecond);\\n        if(ethReward > amountEthForReward){\\n            ethReward = amountEthForReward;\\n        }\\n        accEthPerShare = accEthPerShare.add(ethReward.mul(PRECISION_FACTOR).div(soldAmountSeed));\\n        amountEthForReward = amountEthForReward.sub(ethReward);\\n        totalRewardEthDistributed = totalRewardEthDistributed.add(ethReward);\\n\\n        lastRewardTime = block.timestamp;\\n    }\\n\\n    /*\\n     * @notice Return reward multiplier over the given _from to _to block.\\n     * @param _from: block to start\\n     * @param _to: block to finish\\n     */\\n    function _getMultiplier(uint256 _from, uint256 _to) internal pure returns (uint256) {\\n            return _to.sub(_from);\\n    }\\n\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MONTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRECISION_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TYPE_PUBLIC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TYPE_SEED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accEthPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accTokenPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addEthForReward\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_inputRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_outputRate\",\"type\":\"uint256\"}],\"name\":\"addInputTokenForSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addOutputTokenForSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addTokenForReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountEthForReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountTokenForReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceRemainingInVesting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyType\",\"type\":\"uint256\"}],\"name\":\"deposite\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableRewardSystem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getClaimableInVesting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlacklistWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRewardTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ownerWithdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardEthPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTokenPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"blacklisted\",\"type\":\"bool\"}],\"name\":\"setBlacklistWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"name\":\"setNewRewardToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardEthPerSecond\",\"type\":\"uint256\"}],\"name\":\"setRewardEthPerSecond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardTokenPerSecond\",\"type\":\"uint256\"}],\"name\":\"setRewardTokenPerSecond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"soldAmountPublic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"soldAmountSeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"soldTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"name\":\"startRewardSystem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"}],\"name\":\"startSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenInput\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rateInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rateOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenOutput\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardEthDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardTokenDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenForPublic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenForSeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenForSwapping\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vestingList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasePercentWhenStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasePercentEachMonth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedCheckPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardTokenDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardEthDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withDrawFromVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SwapContract","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}