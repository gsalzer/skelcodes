{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PremiaBondingCurveDeprecation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IPremiaBondingCurveUpgrade} from \\\"./interface/IPremiaBondingCurveUpgrade.sol\\\";\\nimport {IERC20} from \\\"@solidstate/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@solidstate/contracts/utils/SafeERC20.sol\\\";\\n\\ncontract PremiaBondingCurveDeprecation is IPremiaBondingCurveUpgrade {\\n    using SafeERC20 for IERC20;\\n\\n    address internal immutable PREMIA;\\n    address internal immutable TIMELOCK;\\n    address internal immutable TREASURY;\\n\\n    constructor(\\n        address _premia,\\n        address _timelock,\\n        address _treasury\\n    ) {\\n        PREMIA = _premia;\\n        TIMELOCK = _timelock;\\n        TREASURY = _treasury;\\n    }\\n\\n    function initialize(\\n        uint256 _premiaBalance,\\n        uint256,\\n        uint256\\n    ) external payable override {\\n        // Send PREMIA to timelocked contract\\n        IERC20(PREMIA).safeTransfer(TIMELOCK, _premiaBalance);\\n\\n        if (msg.value > 0) {\\n            // Send with data to avoid multisig contract to reject transfer\\n            (bool sent, ) = payable(TREASURY).call{value: msg.value}(\\\"0x1\\\");\\n            require(sent, \\\"ETH transfer failed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IPremiaBondingCurveUpgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPremiaBondingCurveUpgrade {\\r\\n    function initialize(\\r\\n        uint256 _premiaBalance,\\r\\n        uint256 _ethBalance,\\r\\n        uint256 _soldAmount\\r\\n    ) external payable;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20Internal} from './IERC20Internal.sol';\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 is IERC20Internal {\\n  /**\\n   * @notice query the total minted token supply\\n   * @return token supply\\n   */\\n  function totalSupply () external view returns (uint256);\\n\\n  /**\\n   * @notice query the token balance of given account\\n   * @param account address to query\\n   * @return token balance\\n   */\\n  function balanceOf (\\n    address account\\n  ) external view returns (uint256);\\n\\n  /**\\n   * @notice query the allowance granted from given holder to given spender\\n   * @param holder approver of allowance\\n   * @param spender recipient of allowance\\n   * @return token allowance\\n   */\\n  function allowance (\\n    address holder,\\n    address spender\\n  ) external view returns (uint256);\\n\\n  /**\\n   * @notice grant approval to spender to spend tokens\\n   * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\\n   * @param spender recipient of allowance\\n   * @param amount quantity of tokens approved for spending\\n   * @return success status (always true; otherwise function should revert)\\n   */\\n  function approve (\\n    address spender,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @notice transfer tokens to given recipient\\n   * @param recipient beneficiary of token transfer\\n   * @param amount quantity of tokens to transfer\\n   * @return success status (always true; otherwise function should revert)\\n   */\\n  function transfer (\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @notice transfer tokens to given recipient on behalf of given holder\\n   * @param holder holder of tokens prior to transfer\\n   * @param recipient beneficiary of token transfer\\n   * @param amount quantity of tokens to transfer\\n   * @return success status (always true; otherwise function should revert)\\n   */\\n  function transferFrom (\\n    address holder,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20} from '../token/ERC20/IERC20.sol';\\nimport {AddressUtils} from './AddressUtils.sol';\\n\\n/**\\n * @title Safe ERC20 interaction library\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary SafeERC20 {\\n    using AddressUtils for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev safeApprove (like approve) should only be called when setting an initial allowance or when resetting it to zero; otherwise prefer safeIncreaseAllowance and safeDecreaseAllowance\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @notice send transaction data and check validity of return value, if present\\n     * @param token ERC20 token interface\\n     * @param data transaction data\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) {\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial ERC20 interface needed by internal functions\\n */\\ninterface IERC20Internal {\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary AddressUtils {\\n  function toString (address account) internal pure returns (string memory) {\\n    bytes32 value = bytes32(uint256(uint160(account)));\\n    bytes memory alphabet = '0123456789abcdef';\\n    bytes memory chars = new bytes(42);\\n\\n    chars[0] = '0';\\n    chars[1] = 'x';\\n\\n    for (uint256 i = 0; i < 20; i++) {\\n      chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\\n      chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\\n    }\\n\\n    return string(chars);\\n  }\\n\\n  function isContract (address account) internal view returns (bool) {\\n    uint size;\\n    assembly { size := extcodesize(account) }\\n    return size > 0;\\n  }\\n\\n  function sendValue (address payable account, uint amount) internal {\\n    (bool success, ) = account.call{ value: amount }('');\\n    require(success, 'AddressUtils: failed to send value');\\n  }\\n\\n  function functionCall (address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCall(target, data, 'AddressUtils: failed low-level call');\\n  }\\n\\n  function functionCall (address target, bytes memory data, string memory error) internal returns (bytes memory) {\\n    return _functionCallWithValue(target, data, 0, error);\\n  }\\n\\n  function functionCallWithValue (address target, bytes memory data, uint value) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, 'AddressUtils: failed low-level call with value');\\n  }\\n\\n  function functionCallWithValue (address target, bytes memory data, uint value, string memory error) internal returns (bytes memory) {\\n    require(address(this).balance >= value, 'AddressUtils: insufficient balance for call');\\n    return _functionCallWithValue(target, data, value, error);\\n  }\\n\\n  function _functionCallWithValue (address target, bytes memory data, uint value, string memory error) private returns (bytes memory) {\\n    require(isContract(target), 'AddressUtils: function call to non-contract');\\n\\n    (bool success, bytes memory returnData) = target.call{ value: value }(data);\\n\\n    if (success) {\\n      return returnData;\\n    } else if (returnData.length > 0) {\\n      assembly {\\n        let returnData_size := mload(returnData)\\n        revert(add(32, returnData), returnData_size)\\n      }\\n    } else {\\n      revert(error);\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_premia\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_timelock\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_premiaBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"PremiaBondingCurveDeprecation","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006399c842dd2be3de30bf99bc7d1bbf6fa3650e70000000000000000000000000e43147daa592c3f88402c6e2b932db9d97bc1c7f000000000000000000000000c22fae86443aeed038a4ed887bba8f5035fd12f0","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}