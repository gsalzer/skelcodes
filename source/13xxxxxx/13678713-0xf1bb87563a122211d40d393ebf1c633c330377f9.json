{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/staking/PremiaStakingProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {ProxyUpgradeableOwnable} from \\\"../ProxyUpgradeableOwnable.sol\\\";\\r\\nimport {ERC20MetadataStorage} from \\\"@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol\\\";\\r\\n\\r\\nimport {PremiaStakingStorage} from \\\"./PremiaStakingStorage.sol\\\";\\r\\n\\r\\ncontract PremiaStakingProxy is ProxyUpgradeableOwnable {\\r\\n    using ERC20MetadataStorage for ERC20MetadataStorage.Layout;\\r\\n\\r\\n    constructor(address implementation)\\r\\n        ProxyUpgradeableOwnable(implementation)\\r\\n    {\\r\\n        ERC20MetadataStorage.Layout storage l = ERC20MetadataStorage.layout();\\r\\n        l.setName(\\\"Staked Premia\\\");\\r\\n        l.setSymbol(\\\"xPREMIA\\\");\\r\\n        l.setDecimals(18);\\r\\n\\r\\n        PremiaStakingStorage.layout().withdrawalDelay = 10 days;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/ProxyUpgradeableOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {Proxy} from \\\"@solidstate/contracts/proxy/Proxy.sol\\\";\\r\\nimport {SafeOwnable, OwnableStorage} from \\\"@solidstate/contracts/access/SafeOwnable.sol\\\";\\r\\nimport {ProxyUpgradeableOwnableStorage} from \\\"./ProxyUpgradeableOwnableStorage.sol\\\";\\r\\n\\r\\ncontract ProxyUpgradeableOwnable is Proxy, SafeOwnable {\\r\\n    using ProxyUpgradeableOwnableStorage for ProxyUpgradeableOwnableStorage.Layout;\\r\\n    using OwnableStorage for OwnableStorage.Layout;\\r\\n\\r\\n    constructor(address implementation) {\\r\\n        OwnableStorage.layout().setOwner(msg.sender);\\r\\n        ProxyUpgradeableOwnableStorage.layout().implementation = implementation;\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc Proxy\\r\\n     */\\r\\n    function _getImplementation() internal view override returns (address) {\\r\\n        return ProxyUpgradeableOwnableStorage.layout().implementation;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice get address of implementation contract\\r\\n     * @return implementation address\\r\\n     */\\r\\n    function getImplementation() external view returns (address) {\\r\\n        return _getImplementation();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice set address of implementation contract\\r\\n     * @param implementation address of the new implementation\\r\\n     */\\r\\n    function setImplementation(address implementation) external onlyOwner {\\r\\n        ProxyUpgradeableOwnableStorage.layout().implementation = implementation;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ERC20MetadataStorage {\\n    struct Layout {\\n        string name;\\n        string symbol;\\n        uint8 decimals;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC20Metadata');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function setName(Layout storage l, string memory name) internal {\\n        l.name = name;\\n    }\\n\\n    function setSymbol(Layout storage l, string memory symbol) internal {\\n        l.symbol = symbol;\\n    }\\n\\n    function setDecimals(Layout storage l, uint8 decimals) internal {\\n        l.decimals = decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/PremiaStakingStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary PremiaStakingStorage {\\r\\n    bytes32 internal constant STORAGE_SLOT =\\r\\n        keccak256(\\\"premia.contracts.staking.PremiaStaking\\\");\\r\\n\\r\\n    struct Withdrawal {\\r\\n        uint256 amount; // Premia amount\\r\\n        uint256 startDate; // Will unlock at startDate + withdrawalDelay\\r\\n    }\\r\\n\\r\\n    struct Layout {\\r\\n        uint256 pendingWithdrawal;\\r\\n        uint256 withdrawalDelay;\\r\\n        mapping(address => Withdrawal) withdrawals;\\r\\n    }\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { AddressUtils } from '../utils/AddressUtils.sol';\\n\\n/**\\n * @title Base proxy contract\\n */\\nabstract contract Proxy {\\n    using AddressUtils for address;\\n\\n    /**\\n     * @notice delegate all calls to implementation contract\\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\\n     * @dev memory location in use by assembly may be unsafe in other contexts\\n     */\\n    fallback() external payable virtual {\\n        address implementation = _getImplementation();\\n\\n        require(\\n            implementation.isContract(),\\n            'Proxy: implementation must be contract'\\n        );\\n\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(\\n                gas(),\\n                implementation,\\n                0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice get logic implementation address\\n     * @return implementation address\\n     */\\n    function _getImplementation() internal virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/SafeOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { Ownable, OwnableStorage } from './Ownable.sol';\\nimport { SafeOwnableInternal } from './SafeOwnableInternal.sol';\\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\\n\\n/**\\n * @title Ownership access control based on ERC173 with ownership transfer safety check\\n */\\nabstract contract SafeOwnable is Ownable, SafeOwnableInternal {\\n    using OwnableStorage for OwnableStorage.Layout;\\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\\n\\n    function nomineeOwner() public view virtual returns (address) {\\n        return SafeOwnableStorage.layout().nomineeOwner;\\n    }\\n\\n    /**\\n     * @inheritdoc Ownable\\n     * @dev ownership transfer must be accepted by beneficiary before transfer is complete\\n     */\\n    function transferOwnership(address account)\\n        public\\n        virtual\\n        override\\n        onlyOwner\\n    {\\n        SafeOwnableStorage.layout().setNomineeOwner(account);\\n    }\\n\\n    /**\\n     * @notice accept transfer of contract ownership\\n     */\\n    function acceptOwnership() public virtual onlyNomineeOwner {\\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\\n        emit OwnershipTransferred(l.owner, msg.sender);\\n        l.setOwner(msg.sender);\\n        SafeOwnableStorage.layout().setNomineeOwner(address(0));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ProxyUpgradeableOwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary ProxyUpgradeableOwnableStorage {\\r\\n    bytes32 internal constant STORAGE_SLOT =\\r\\n        keccak256(\\\"premia.contracts.storage.ProxyUpgradeableOwnable\\\");\\r\\n\\r\\n    struct Layout {\\r\\n        address implementation;\\r\\n    }\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary AddressUtils {\\n    function toString(address account) internal pure returns (string memory) {\\n        bytes32 value = bytes32(uint256(uint160(account)));\\n        bytes memory alphabet = '0123456789abcdef';\\n        bytes memory chars = new bytes(42);\\n\\n        chars[0] = '0';\\n        chars[1] = 'x';\\n\\n        for (uint256 i = 0; i < 20; i++) {\\n            chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\\n            chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\\n        }\\n\\n        return string(chars);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        require(success, 'AddressUtils: failed to send value');\\n    }\\n\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            'AddressUtils: insufficient balance for call'\\n        );\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        require(\\n            isContract(target),\\n            'AddressUtils: function call to non-contract'\\n        );\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC173 } from './IERC173.sol';\\nimport { OwnableInternal } from './OwnableInternal.sol';\\nimport { OwnableStorage } from './OwnableStorage.sol';\\n\\n/**\\n * @title Ownership access control based on ERC173\\n */\\nabstract contract Ownable is IERC173, OwnableInternal {\\n    using OwnableStorage for OwnableStorage.Layout;\\n\\n    /**\\n     * @inheritdoc IERC173\\n     */\\n    function owner() public view virtual override returns (address) {\\n        return OwnableStorage.layout().owner;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC173\\n     */\\n    function transferOwnership(address account)\\n        public\\n        virtual\\n        override\\n        onlyOwner\\n    {\\n        OwnableStorage.layout().setOwner(account);\\n        emit OwnershipTransferred(msg.sender, account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/SafeOwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\\n\\nabstract contract SafeOwnableInternal {\\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\\n\\n    modifier onlyNomineeOwner() {\\n        require(\\n            msg.sender == SafeOwnableStorage.layout().nomineeOwner,\\n            'SafeOwnable: sender must be nominee owner'\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/SafeOwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary SafeOwnableStorage {\\n    struct Layout {\\n        address nomineeOwner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.SafeOwnable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function setNomineeOwner(Layout storage l, address nomineeOwner) internal {\\n        l.nomineeOwner = nomineeOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Contract ownership standard interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-173\\n */\\ninterface IERC173 {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @notice get the ERC173 contract owner\\n     * @return conract owner\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice transfer contract ownership to new account\\n     * @param account address of new owner\\n     */\\n    function transferOwnership(address account) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/OwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { OwnableStorage } from './OwnableStorage.sol';\\n\\nabstract contract OwnableInternal {\\n    using OwnableStorage for OwnableStorage.Layout;\\n\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == OwnableStorage.layout().owner,\\n            'Ownable: sender must be owner'\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/OwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary OwnableStorage {\\n    struct Layout {\\n        address owner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Ownable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function setOwner(Layout storage l, address owner) internal {\\n        l.owner = owner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nomineeOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"PremiaStakingProxy","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005068219091050be4efec7c392ad68f0560c722d9","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}