{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NMWD/SWDMarketPlace.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"./owned.sol\\\";\\nimport \\\"./StopTheWarOnDrugs.sol\\\";\\nimport \\\"./context.sol\\\";\\nimport \\\"./address-utils.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\n\\ncontract SWDMarketPlace is \\nOwned, \\nContext, \\nInitializable{\\n\\n    using AddressUtils for address;\\n\\n    string constant INVALID_ADDRESS = \\\"0501\\\";\\n    string constant CONTRACT_ADDRESS_NOT_SETUP = \\\"0502\\\";\\n    string constant NOT_APPROVED= \\\"0503\\\";\\n    string constant NOT_VALID_NFT = \\\"0504\\\";\\n    string constant NOT_FOR_SALE = \\\"0505\\\";\\n    string constant NOT_EHOUGH_ETHER = \\\"0506\\\";\\n    string constant NEGATIVE_VALUE = \\\"0507\\\";\\n    string constant NO_CHANGES_INTENDED = \\\"0508\\\";\\n    string constant NOT_NFT_OWNER = \\\"0509\\\";\\n    string constant INSUFICIENT_BALANCE = \\\"0510\\\";\\n    string constant STILL_OWN_NFT_CONTRACT = \\\"0511\\\";\\n    string constant NFT_ALREADY_MINTED = \\\"0512\\\";\\n    string constant PRICE_NOT_SET = \\\"0513\\\";\\n    string constant MINTING_LOCKED = \\\"0514\\\";\\n    \\n\\n    event Sent(address indexed payee, uint amount);\\n    event RoyaltyPaid(address indexed payee, uint amount);\\n    event SecurityWithdrawal(address indexed payee, uint amount);\\n\\n    StopTheWarOnDrugs public TokenContract;\\n\\n    /**\\n    * @dev Mapping from token ID to its pirce.\\n    */\\n    mapping(uint => uint256) internal price;\\n\\n    /**\\n    * @dev Mapping from token ID to royalty address.\\n    */\\n    mapping(uint => address) internal royaltyAddress;\\n\\n    /**\\n    * @dev Mapping from NFT ID to boolean representing\\n    * if it is for sale or not.\\n    */\\n    mapping(uint => bool) internal forSale;\\n\\n    /**\\n    * @dev contract balance\\n    */\\n    uint internal contractBalance;\\n\\n    /**\\n    * @dev reentrancy safe and control for minting method\\n    */\\n    bool internal mintLock;\\n\\n\\n    /**\\n    * @dev Contract Constructor/Initializer\\n    */\\n    function initialize() public initializer { \\n        isOwned();\\n    }\\n\\n    /**\\n    * @dev update the address of the NFTs\\n    * @param nmwdAddress address of NoMoreWarOnDrugs tokens \\n    */\\n    function updateNMWDcontract(address nmwdAddress) external onlyOwner{\\n        require(nmwdAddress != address(0) && nmwdAddress != address(this),INVALID_ADDRESS);\\n        require(address(TokenContract) != nmwdAddress,NO_CHANGES_INTENDED);\\n        TokenContract = StopTheWarOnDrugs(nmwdAddress);\\n    }\\n\\n    /**\\n    * @dev transfers ownership of the NFT contract to the owner of \\n    * the marketplace contract. Only if the marketplace owns the NFT\\n    */\\n    function getBackOwnership() external onlyOwner{\\n        require(address(TokenContract) != address(0),CONTRACT_ADDRESS_NOT_SETUP);\\n        TokenContract.transferOwnership(address(owner));\\n    }\\n\\n\\n    /**\\n    * @dev Purchase _tokenId\\n    * @param _tokenId uint token ID (painting number)\\n    */\\n    function purchaseToken(uint _tokenId) external payable  {\\n        require(forSale[_tokenId], NOT_FOR_SALE);\\n        require(_msgSender() != address(0) && _msgSender() != address(this));\\n        require(price[_tokenId] > 0,PRICE_NOT_SET);\\n        require(msg.value >= price[_tokenId]);\\n        require(TokenContract.ownerOf(_tokenId) != address(0), NOT_VALID_NFT);\\n\\n        address tokenSeller = TokenContract.ownerOf(_tokenId);\\n        require(TokenContract.getApproved(_tokenId) == address(this) || \\n                TokenContract.isApprovedForAll(tokenSeller, address(this)), \\n                NOT_APPROVED);\\n\\n        forSale[_tokenId] = false;\\n\\n\\n        // this is the fee of the contract per transaction: 0.8%\\n        uint256 saleFee = (msg.value / 1000) * 8;\\n        contractBalance += saleFee;\\n\\n        //calculating the net amount of the sale\\n        uint netAmount = msg.value - saleFee;\\n\\n        (address royaltyReceiver, uint256 royaltyAmount) = TokenContract.royaltyInfo( _tokenId, netAmount);\\n\\n        //calculating the amount to pay the seller \\n        uint256 toPaySeller = netAmount - royaltyAmount;\\n\\n        //paying the seller and the royalty recepient\\n        (bool successSeller, ) =tokenSeller.call{value: toPaySeller, gas: 120000}(\\\"\\\");\\n        require( successSeller, \\\"Paying seller failed\\\");\\n        (bool successRoyalties, ) =royaltyReceiver.call{value: royaltyAmount, gas: 120000}(\\\"\\\");\\n        require( successRoyalties, \\\"Paying Royalties failed\\\");\\n\\n        //transfer the NFT to the buyer\\n        TokenContract.safeTransferFrom(tokenSeller, _msgSender(), _tokenId);\\n\\n        //notifying the blockchain\\n        emit Sent(tokenSeller, toPaySeller);\\n        emit RoyaltyPaid(royaltyReceiver, royaltyAmount);\\n        \\n    }\\n\\n    /**\\n    * @dev mint an NFT through the market place\\n    * @param _to the address that will receive the freshly minted NFT\\n    * @param _tokenId uint token ID (painting number)\\n    */\\n    function mintThroughPurchase(address _to, uint _tokenId) external payable {\\n        require(price[_tokenId] > 0, PRICE_NOT_SET);\\n        require(msg.value >= price[_tokenId],NOT_EHOUGH_ETHER);\\n        require(_msgSender() != address(0) && _msgSender() != address(this));\\n        //avoid reentrancy. Also mintLocked before launch time.\\n        require(!mintLock,MINTING_LOCKED);\\n        mintLock=true;\\n\\n        //we extract the royalty address from the mapping\\n        address royaltyRecipient = royaltyAddress[_tokenId];\\n        //this is hardcoded 6.0% for all NFTs\\n        uint royaltyValue = 600;\\n\\n        contractBalance += msg.value;\\n\\n        TokenContract.mint(_to, _tokenId, royaltyRecipient, royaltyValue);\\n        \\n        mintLock=false;\\n    }\\n\\n    /**\\n    * @dev send / withdraw _amount to _payee\\n    * @param _payee the address where the funds are going to go\\n    * @param _amount the amount of Ether that will be sent\\n    */\\n    function withdrawFromContract(address _payee, uint _amount) external onlyOwner {\\n        require(_payee != address(0) && _payee != address(this));\\n        require(contractBalance >= _amount, INSUFICIENT_BALANCE);\\n        require(_amount > 0 && _amount <= address(this).balance, NOT_EHOUGH_ETHER);\\n\\n        //we check if somebody has hacked the contract, in which case we send all the funds to \\n        //the owner of the contract\\n        if(contractBalance != address(this).balance){\\n            contractBalance = 0;\\n            payable(owner).transfer(address(this).balance);\\n            emit SecurityWithdrawal(owner, _amount);\\n        }else{\\n            contractBalance -= _amount;\\n            payable(_payee).transfer(_amount);\\n            emit Sent(_payee, _amount);\\n        }\\n    }   \\n\\n    /**\\n    * @dev Updates price for the _tokenId NFT\\n    * @dev Throws if updating price to the same current price, or to negative\\n    * value, or is not the owner of the NFT.\\n    * @param _price the price in wei for the NFT\\n    * @param _tokenId uint token ID (painting number)\\n    */\\n    function setPrice(uint _price, uint _tokenId) external {\\n        require(_price > 0, NEGATIVE_VALUE);\\n        require(_price != price[_tokenId], NO_CHANGES_INTENDED);\\n        //Only owner of NFT can set a price\\n        address _address = TokenContract.ownerOf(_tokenId);\\n        require(_address == _msgSender());\\n        \\n        //finally, we do what we came here for.\\n        price[_tokenId] = _price;\\n    } \\n\\n    /**\\n    * @dev Updates price for the _tokenId NFT before minting\\n    * @dev Throws if updating price to the same current price, or to negative\\n    * value, or if sender is not the owner of the marketplace.\\n    * @param _price the price in wei for the NFT\\n    * @param _tokenId uint token ID (painting number)\\n    * @param _royaltyAddress the address that will receive the royalties.\\n    */\\n    function setPriceForMinting(uint _price, uint _tokenId, address _royaltyAddress) external onlyOwner{\\n        require(_price > 0, NEGATIVE_VALUE);\\n        require(_price != price[_tokenId], NO_CHANGES_INTENDED);\\n        require(_royaltyAddress != address(0) && _royaltyAddress != address(this),INVALID_ADDRESS);\\n        //this makes sure this is only set before minting. It is impossible to change the\\n        //royalty address once it's been minted. The price can then be only reset by the NFT owner.\\n        require( !TokenContract.exists(_tokenId),NFT_ALREADY_MINTED);\\n        \\n        //finally, we do what we came here for.\\n        price[_tokenId] = _price;\\n        royaltyAddress[_tokenId] = _royaltyAddress;\\n    } \\n\\n    /**\\n    * @dev get _tokenId price in wei\\n    * @param _tokenId uint token ID \\n    */\\n    function getPrice(uint _tokenId) external view returns (uint256){\\n        return price[_tokenId];\\n    }    \\n\\n    /**\\n    * @dev get marketplace's balance (weis)\\n    */\\n    function getMarketPlaceBalance() external view returns (uint256){\\n        return contractBalance;\\n    }   \\n\\n    /**\\n    * @dev sets the token with _tokenId a boolean representing if it's for sale or not.\\n    * @param _tokenId uint token ID \\n    * @param _forSale is it or not for sale? (true/false)\\n    */\\n    function setForSale(uint _tokenId, bool _forSale) external returns (bool){\\n        \\n        try TokenContract.ownerOf(_tokenId) returns (address _address) {\\n            require(_address == _msgSender(),NOT_NFT_OWNER);\\n        }catch {\\n           return false;\\n        }\\n        require(_forSale != forSale[_tokenId],NO_CHANGES_INTENDED);\\n        forSale[_tokenId] = _forSale;\\n        return true;\\n    } \\n\\n    /**\\n    * @dev gets the token with _tokenId forSale variable.\\n    * @param _tokenId uint token ID \\n    */\\n    function getForSale(uint _tokenId) external view returns (bool){\\n        return forSale[_tokenId];\\n    } \\n\\n    /**\\n   * @dev Burns an NFT.\\n   * @param _tokenId of the NFT to burn.\\n   */\\n    function burn(uint256 _tokenId ) external onlyOwner {\\n        TokenContract.burn( _tokenId);\\n  }\\n    /**\\n   * @dev the receive method to avoid balance incongruence\\n   */\\n  receive() external payable{\\n        contractBalance += msg.value;\\n    }\\n\\n  /**\\n   * @dev locks/unlocks the mint method.\\n   * @param _locked bool value to set.\\n   */\\n    function setMintLock(bool _locked) external onlyOwner {\\n        mintLock=_locked;\\n  }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/NMWD/owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\n\\ncontract Owned {\\n    \\n    /**\\n    * @dev Error constants.\\n    */\\n    string public constant NOT_CURRENT_OWNER = \\\"0101\\\";\\n    string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = \\\"0102\\\";\\n\\n    /**\\n    * @dev Current owner address.\\n    */\\n    address public owner;\\n\\n    /**\\n    * @dev An event which is triggered when the owner is changed.\\n    * @param previousOwner The address of the previous owner.\\n    * @param newOwner The address of the new owner.\\n    */\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    event _msg(address deliveredTo, string msg);\\n\\n    function isOwned() internal {\\n        owner = msg.sender;\\n        emit _msg(owner, \\\"set owner\\\" );\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Not owner\\\");\\n        emit _msg(owner, \\\"passed ownership requirement\\\" );\\n        _;\\n    }\\n\\n    /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param _newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(\\n    address _newOwner\\n  )\\n    public\\n    onlyOwner\\n  {\\n\\n    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\\n    emit OwnershipTransferred(owner, _newOwner);\\n    owner = _newOwner;\\n  }\\n\\n  function getOwner() public view returns (address){\\n    return owner;\\n  }\\n}\"\r\n    },\r\n    \"contracts/NMWD/StopTheWarOnDrugs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\n\\nimport \\\"./nf-token-enumerable.sol\\\";\\nimport \\\"./nf-token-metadata.sol\\\";\\nimport \\\"./owned.sol\\\";\\nimport \\\"./erc2981-per-token-royalties.sol\\\";\\n\\ncontract StopTheWarOnDrugs is NFTokenEnumerable, NFTokenMetadata, \\n///Owned, \\nERC2981PerTokenRoyalties {\\n\\n    /** \\n    * @dev error when an NFT is attempted to be minted after the max\\n    * supply of NFTs has been already reached.\\n    */\\n    string constant MAX_TOKENS_MINTED = \\\"0401\\\";\\n\\n    /** \\n    * @dev error when the message for an NFT is trying to be set afet\\n    * it has been already set.\\n    */\\n    string constant MESSAGE_ALREADY_SET = \\\"0402\\\";\\n\\n    /** \\n    * @dev The message doesn't comply with the size restrictions\\n    */\\n    string constant NOT_VALID_MSG = \\\"0403\\\";\\n\\n    /** \\n    * @dev Can't pass 0 as value for the argument\\n    */\\n    string constant ZERO_VALUE = \\\"0404\\\";\\n\\n    /** \\n    * @dev The maximum amount of NFTs that can be minted in this collection\\n    */\\n    uint16 constant MAX_TOKENS = 904;\\n\\n    /** \\n    * @dev Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    * which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    */\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    /**\\n    * @dev Mapping from NFT ID to message.\\n    */\\n    mapping (uint256 => string) private idToMsg;\\n\\n\\n    constructor(string memory _name, string memory _symbol){\\n        isOwned();\\n        nftName = _name;\\n        nftSymbol = _symbol;\\n    }\\n\\n    /**\\n    * @dev Mints a new NFT.\\n    * @notice an approveForAll is given to the owner of the contract.\\n    * This is due to the fact that the marketplae of this project will \\n    * own this contract. Therefore, the NFTs will be transactable in \\n    * the marketplace by default without any extra step from the user.\\n    * @param _to The address that will own the minted NFT.\\n    * @param _tokenId of the NFT to be minted by the msg.sender.\\n    * @param royaltyRecipient the address that will be entitled for the royalties.\\n    * @param royaltyValue the percentage (from 0 - 10000) of the royalties\\n    * @notice royaltyValue is amplified 100 times to be able to write a percentage\\n    * with 2 decimals of precision. Therefore, 1 => 0.01%; 100 => 1%; 10000 => 100%\\n    * @notice the URI is build from the tokenId since it is the SHA2-256 of the\\n    * URI content in IPFS.\\n    */\\n    function mint(address _to, uint256 _tokenId, \\n                  address royaltyRecipient, uint256 royaltyValue) \\n      external onlyOwner \\n      {\\n        _mint(_to, _tokenId);\\n        //uri setup\\n        string memory _uri = getURI(_tokenId);\\n        idToUri[_tokenId] = _uri;\\n        //royalties setup\\n         if (royaltyValue > 0) {\\n            _setTokenRoyalty(_tokenId, royaltyRecipient, royaltyValue);\\n        }\\n        //approve marketplace\\n        if(!ownerToOperators[_to][owner]){\\n           ownerToOperators[_to][owner] = true;\\n         }\\n    }\\n\\n    /**\\n    * @dev Mints a new NFT.\\n    * @param _to The address that will own the minted NFT.\\n    * @param _tokenId of the NFT to be minted by the msg.sender.\\n    */\\n    function _mint( address _to, uint256 _tokenId ) internal override (NFTokenEnumerable, NFToken){\\n        require( tokens.length < MAX_TOKENS, MAX_TOKENS_MINTED );\\n        super._mint(_to, _tokenId);\\n        \\n    }\\n\\n\\n    /**\\n   * @dev Assignes a new NFT to an address.\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @param _to Address to wich we want to add the NFT.\\n   * @param _tokenId Which NFT we want to add.\\n   */\\n  function _addNFToken(  address _to, uint256 _tokenId ) internal override  (NFTokenEnumerable, NFToken){\\n    super._addNFToken(_to, _tokenId);\\n  }\\n\\n  function addNFToken(address _to, uint256 _tokenId) internal {\\n        _addNFToken(_to, _tokenId);\\n    }\\n\\n    /**\\n   * @dev Burns a NFT.\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * burn function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\\n   * NFT.\\n   * @param _tokenId ID of the NFT to be burned.\\n   */\\n  function _burn( uint256 _tokenId ) internal override (NFTokenEnumerable, NFTokenMetadata) {\\n    super._burn(_tokenId);\\n  }\\n\\n  function burn(uint256 _tokenId ) public onlyOwner {\\n      //clearing the uri\\n      idToUri[_tokenId] = \\\"\\\";\\n      //clearing the royalties\\n      _setTokenRoyalty(_tokenId, address(0), 0);\\n      //burning the token for good\\n      _burn( _tokenId);\\n  }\\n\\n  /**\\n   * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\\n   * extension to remove double storage(gas optimization) of owner nft count.\\n   * @param _owner Address for whom to query the count.\\n   * @return Number of _owner NFTs.\\n   */\\n  function _getOwnerNFTCount(  address _owner  ) internal override(NFTokenEnumerable, NFToken) view returns (uint256) {\\n    return super._getOwnerNFTCount(_owner);\\n  }\\n\\n  function getOwnerNFTCount(  address _owner  ) public view returns (uint256) {\\n    return _getOwnerNFTCount(_owner);\\n  }\\n\\n/**\\n   * @dev Removes a NFT from an address.\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @param _from Address from wich we want to remove the NFT.\\n   * @param _tokenId Which NFT we want to remove.\\n   */\\n  function _removeNFToken(\\n    address _from,\\n    uint256 _tokenId\\n  )\\n    internal\\n    override (NFTokenEnumerable, NFToken) \\n  {\\n      super._removeNFToken(_from, _tokenId);\\n  }\\n\\n  function removeNFToken(address _from, uint256 _tokenId) internal {\\n      _removeNFToken(_from, _tokenId);\\n  }\\n\\n\\n  /**\\n   * @dev A custom message given for the first NFT buyer.\\n   * @param _tokenId Id for which we want the message.\\n   * @return Message of _tokenId.\\n   */\\n  function tokenMessage(\\n    uint256 _tokenId\\n  )\\n    external\\n    view\\n    validNFToken(_tokenId)\\n    returns (string memory)\\n  {\\n    return idToMsg[_tokenId];\\n  }\\n\\n  /**\\n   * @dev Sets a custom message for the NFT with _tokenId.\\n   * @notice only the owner of the NFT can do this. Not even approved or \\n   * operators can execute this function.\\n   * @param _tokenId Id for which we want the message.\\n   * @param _msg the custom message.\\n   */\\n  function setTokenMessage(\\n    uint256 _tokenId,\\n    string memory _msg\\n  )\\n    external\\n    validNFToken(_tokenId)\\n  { \\n    address tokenOwner = idToOwner[_tokenId];\\n    require(_msgSender() == tokenOwner, NOT_OWNER);\\n    require(bytes(idToMsg[_tokenId]).length == 0, MESSAGE_ALREADY_SET);\\n    bool valid_msg = validateMsg(_msg);\\n    require(valid_msg, NOT_VALID_MSG);\\n    idToMsg[_tokenId] = _msg;\\n  }\\n\\n  /**\\n     * @dev Check if the message string has a valid length\\n     * @param _msg the custom message.\\n     */\\n    function validateMsg(string memory _msg) public pure returns (bool){\\n        bytes memory b = bytes(_msg);\\n        if(b.length < 1) return false;\\n        if(b.length > 300) return false; // Cannot be longer than 300 characters\\n        return true;\\n    }\\n\\n /**\\n   * @dev returns the list of NFTs owned by certain address.\\n   * @param _address Id for which we want the message.\\n   */\\n  function getNFTsByAddress(\\n    address _address\\n  )\\n    view external returns (uint256[] memory)\\n  { \\n    return ownerToIds[_address];\\n  }\\n\\n  /**\\n    * @dev Builds and return the URL string from the tokenId.\\n    * @notice the tokenId is the SHA2-256 of the URI content in IPFS.\\n    * This ensures the complete authenticity of the token minted. The URL is\\n    * therefore an IPFS URL which follows the pattern: \\n    * ipfs://<CID>\\n    * And the CID can be constructed as follows:\\n    * CID = F01701220<ID>  \\n    * F signals that the CID is in hexadecimal format. 01 means CIDv1. 70 signals   \\n    * dag-pg link-data coding used. 12 references the hashing algorith SHA2-256.\\n    * 20 is the length in bytes of the hash. In decimal, 32 bytes as specified\\n    * in the SHA2-256 protocol. Finally, <ID> is the tokenId (the hash).\\n    * @param _tokenId of the NFT (the SHA2-256 of the URI content).\\n    */\\n  function getURI(uint _tokenId) internal pure returns(string memory){\\n        string memory _hex = uintToHexStr(_tokenId);\\n        string memory prefix = \\\"ipfs://F01701220\\\";\\n        string memory result = string(abi.encodePacked(prefix,_hex ));\\n        return result;\\n    }\\n\\n    /**\\n    * @dev Converts a uint into a hex string of 64 characters. Throws if 0 is passed.\\n    * @notice that the returned string doesn't prepend the usual \\\"0x\\\".\\n    * @param _uint number to convert to string.\\n    */\\n  function uintToHexStr(uint _uint) internal pure returns (string memory) {\\n        require(_uint != 0, ZERO_VALUE);\\n        bytes memory byteStr = new bytes(64);\\n        for (uint j = 0; j < 64 ;j++){\\n            uint curr = (_uint & 15); //mask that allows us to filter only the last 4 bits (last character)\\n            byteStr[63-j] = curr > 9 ? bytes1( uint8(55) + uint8(curr) ) :\\n                                        bytes1( uint8(48) + uint8(curr) ); // 55 = 65 - 10\\n            _uint = _uint >> 4;   \\n        }\\n        return string(byteStr);\\n      }\\n\\n    /**\\n    * @dev Destroys the contract\\n    * @notice that, due to the danger that the call of this contract poses, it is required\\n    * to pass a specific integer value to effectively call this method.\\n    * @param security_value number to pass security restriction (192837).\\n    */\\n      function seflDestruct(uint security_value) external onlyOwner { \\n        require(security_value == 192837); //this is just to make sure that this method was not called by accident\\n        selfdestruct(payable(owner)); \\n      }\\n\\n    /**\\n    * @dev returns boolean representing the existance of an NFT\\n    * @param _tokenId of the NFT to look up.\\n    */\\n      function exists(uint _tokenId) external view returns (bool) { \\n        if( idToOwner[_tokenId] == address(0)){\\n          return false;\\n        }else{\\n          return true;\\n        }\\n      }\\n\\n\\n} \\n\\n\\n\"\r\n    },\r\n    \"contracts/NMWD/context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\"\r\n    },\r\n    \"contracts/NMWD/address-utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\n/**\\n * @dev Utility library of inline functions on addresses.\\n * @notice Based on:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\\n * Requires EIP-1052.\\n */\\nlibrary AddressUtils\\n{\\n\\n  /**\\n   * @dev Returns whether the target address is a contract.\\n   * @param _addr Address to check.\\n   * @return addressCheck True if _addr is a contract, false if not.\\n   */\\n  function isContract(\\n    address _addr\\n  )\\n    internal\\n    view\\n    returns (bool addressCheck)\\n  {\\n    // This method relies in extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\\n    addressCheck = (codehash != 0x0 && codehash != accountHash);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/NMWD/nf-token-enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport \\\"./nf-token.sol\\\";\\nimport \\\"./erc721-enumerable.sol\\\";\\n\\n/**\\n * @dev Optional enumeration implementation for ERC-721 non-fungible token standard.\\n */\\ncontract NFTokenEnumerable is NFToken, ERC721Enumerable {\\n\\n  /**\\n   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\\n   * Based on 0xcert framework error codes.\\n   */\\n  string constant INVALID_INDEX = \\\"0201\\\";\\n  \\n\\n  /**\\n   * @dev Array of all NFT IDs.\\n   */\\n  uint256[] internal tokens;\\n\\n  /**\\n   * @dev Mapping from token ID to its index in global tokens array.\\n   */\\n  mapping(uint256 => uint256) internal idToIndex;\\n\\n  /**\\n   * @dev Mapping from owner to list of owned NFT IDs.\\n   */\\n  mapping(address => uint256[]) internal ownerToIds;\\n\\n  /**\\n   * @dev Mapping from NFT ID to its index in the owner tokens list.\\n   */\\n  mapping(uint256 => uint256) internal idToOwnerIndex;\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor()\\n  {\\n    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\\n  }\\n\\n  /**\\n   * @dev Returns the count of all existing NFTokens.\\n   * @return Total supply of NFTs.\\n   */\\n  function totalSupply()\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    return tokens.length;\\n  }\\n\\n  /**\\n   * @dev Returns NFT ID by its index.\\n   * @param _index A counter less than `totalSupply()`.\\n   * @return Token id.\\n   */\\n  function tokenByIndex(\\n    uint256 _index\\n  )\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    require(_index < tokens.length, INVALID_INDEX);\\n    return tokens[_index];\\n  }\\n\\n  /**\\n   * @dev returns the n-th NFT ID from a list of owner's tokens.\\n   * @param _owner Token owner's address.\\n   * @param _index Index number representing n-th token in owner's list of tokens.\\n   * @return Token id.\\n   */\\n  function tokenOfOwnerByIndex(\\n    address _owner,\\n    uint256 _index\\n  )\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    require(_index < ownerToIds[_owner].length, INVALID_INDEX);\\n    return ownerToIds[_owner][_index];\\n  }\\n\\n  /**\\n   * @dev Mints a new NFT.\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * mint function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation.\\n   * @param _to The address that will own the minted NFT.\\n   * @param _tokenId of the NFT to be minted by the msg.sender.\\n   */\\n  function _mint(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n    override\\n    virtual\\n  {\\n    super._mint(_to, _tokenId);\\n    tokens.push(_tokenId);\\n    idToIndex[_tokenId] = tokens.length - 1;\\n  }\\n\\n  /**\\n   * @dev Burns a NFT.\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * burn function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\\n   * NFT.\\n   * @param _tokenId ID of the NFT to be burned.\\n   */\\n  function _burn(\\n    uint256 _tokenId\\n  )\\n    internal\\n    override\\n    virtual\\n  {\\n    super._burn(_tokenId);\\n\\n    uint256 tokenIndex = idToIndex[_tokenId];\\n    uint256 lastTokenIndex = tokens.length - 1;\\n    uint256 lastToken = tokens[lastTokenIndex];\\n\\n    tokens[tokenIndex] = lastToken;\\n\\n    tokens.pop();\\n    // This wastes gas if you are burning the last token but saves a little gas if you are not.\\n    idToIndex[lastToken] = tokenIndex;\\n    idToIndex[_tokenId] = 0;\\n  }\\n\\n  /**\\n   * @dev Removes a NFT from an address.\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @param _from Address from wich we want to remove the NFT.\\n   * @param _tokenId Which NFT we want to remove.\\n   */\\n  function _removeNFToken(\\n    address _from,\\n    uint256 _tokenId\\n  )\\n    internal\\n    override\\n    virtual\\n  {\\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\\n    delete idToOwner[_tokenId];\\n\\n    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\\n    uint256 lastTokenIndex = ownerToIds[_from].length - 1;\\n\\n    if (lastTokenIndex != tokenToRemoveIndex)\\n    {\\n      uint256 lastToken = ownerToIds[_from][lastTokenIndex];\\n      ownerToIds[_from][tokenToRemoveIndex] = lastToken;\\n      idToOwnerIndex[lastToken] = tokenToRemoveIndex;\\n    }\\n\\n    ownerToIds[_from].pop();\\n  }\\n\\n  /**\\n   * @dev Assignes a new NFT to an address.\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @param _to Address to wich we want to add the NFT.\\n   * @param _tokenId Which NFT we want to add.\\n   */\\n  function _addNFToken(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n    override\\n    virtual\\n  {\\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\\n    idToOwner[_tokenId] = _to;\\n\\n    ownerToIds[_to].push(_tokenId);\\n    idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;\\n  }\\n\\n  /**\\n   * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\\n   * extension to remove double storage(gas optimization) of owner nft count.\\n   * @param _owner Address for whom to query the count.\\n   * @return Number of _owner NFTs.\\n   */\\n  function _getOwnerNFTCount(\\n    address _owner\\n  )\\n    internal\\n    override\\n    virtual\\n    view\\n    returns (uint256)\\n  {\\n    return ownerToIds[_owner].length;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/NMWD/nf-token-metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport \\\"./nf-token.sol\\\";\\nimport \\\"./erc721-metadata.sol\\\";\\n\\n/**\\n * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\\n */\\ncontract NFTokenMetadata is\\n  NFToken,\\n  ERC721Metadata\\n{\\n\\n  /**\\n   * @dev A descriptive name for a collection of NFTs.\\n   */\\n  string internal nftName;\\n\\n  /**\\n   * @dev An abbreviated name for NFTokens.\\n   */\\n  string internal nftSymbol;\\n\\n  /**\\n   * @dev Mapping from NFT ID to metadata uri.\\n   */\\n  mapping (uint256 => string) internal idToUri;\\n\\n  /**\\n   * @dev Contract constructor.\\n   * @notice When implementing this contract don't forget to set nftName and nftSymbol.\\n   */\\n  constructor()\\n  {\\n    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\\n  }\\n\\n  /**\\n   * @dev Returns a descriptive name for a collection of NFTokens.\\n   * @return _name Representing name.\\n   */\\n  function name()\\n    external\\n    override\\n    view\\n    returns (string memory _name)\\n  {\\n    _name = nftName;\\n  }\\n\\n  /**\\n   * @dev Returns an abbreviated name for NFTokens.\\n   * @return _symbol Representing symbol.\\n   */\\n  function symbol()\\n    external\\n    override\\n    view\\n    returns (string memory _symbol)\\n  {\\n    _symbol = nftSymbol;\\n  }\\n\\n  /**\\n   * @dev A distinct URI (RFC 3986) for a given NFT.\\n   * @param _tokenId Id for which we want uri.\\n   * @return URI of _tokenId.\\n   */\\n  function tokenURI(\\n    uint256 _tokenId\\n  )\\n    external\\n    override\\n    view\\n    validNFToken(_tokenId)\\n    returns (string memory)\\n  {\\n    return idToUri[_tokenId];\\n  }\\n\\n  /**\\n   * @dev Burns a NFT.\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * burn function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\\n   * NFT.\\n   * @param _tokenId ID of the NFT to be burned.\\n   */\\n  function _burn(\\n    uint256 _tokenId\\n  )\\n    internal\\n    override\\n    virtual\\n  {\\n    super._burn(_tokenId);\\n\\n    if (bytes(idToUri[_tokenId]).length != 0)\\n    {\\n      delete idToUri[_tokenId];\\n    }\\n  }\\n\\n  /**\\n   * @dev Set a distinct URI (RFC 3986) for a given NFT ID.\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation.\\n   * @param _tokenId Id for which we want URI.\\n   * @param _uri String representing RFC 3986 URI.\\n   */\\n  function _setTokenUri(\\n    uint256 _tokenId,\\n    string memory _uri\\n  )\\n    internal\\n    validNFToken(_tokenId)\\n  {\\n    idToUri[_tokenId] = _uri;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/NMWD/erc2981-per-token-royalties.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport './ierc2981-royalties.sol';\\nimport \\\"./supports-interface.sol\\\";\\n\\n/// @dev This is a contract used to add ERC2981 support to ERC721 and 1155\\ncontract ERC2981PerTokenRoyalties is IERC2981Royalties, SupportsInterface {\\n\\n    /**\\n    * @dev This is where the info about the royalty resides\\n    * @dev recipient is the address where the royalties should be sent to.\\n    * @dev value is the percentage of the sale value that will be sent as royalty.\\n    * @notice \\\"value\\\" will be expressed as an unsigned integer between 0 and 1000. \\n    * This means that 10000 = 100%, and 1 = 0.01%\\n    */\\n    struct Royalty {\\n        address recipient;\\n        uint256 value;\\n    }\\n\\n    /**\\n    * @dev the data structure where the NFT id points to the Royalty struct with the\\n    * corresponding royalty info.\\n    */\\n    mapping(uint256 => Royalty) internal idToRoyalties;\\n\\n    constructor(){\\n        supportedInterfaces[0x2a55205a] = true; // ERC2981\\n    }\\n\\n    /** \\n    * @dev Sets token royalties\\n    * @param id the token id fir which we register the royalties\\n    * @param recipient recipient of the royalties\\n    * @param value percentage (using 2 decimals - 10000 = 100, 0 = 0)\\n    */\\n    function _setTokenRoyalty(\\n        uint256 id,\\n        address recipient,\\n        uint256 value\\n    ) internal {\\n        require(value <= 10000, 'ERC2981Royalties: Too high');\\n\\n        idToRoyalties[id] = Royalty(recipient, value);\\n    }\\n\\n    /// @inheritdoc\\tIERC2981Royalties\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\\n        external\\n        view\\n        override\\n        returns (address receiver, uint256 royaltyAmount)\\n    {\\n        Royalty memory royalty = idToRoyalties[_tokenId];\\n        return (royalty.recipient, (_salePrice * royalty.value) / 10000);\\n    }\\n}\"\r\n    },\r\n    \"contracts/NMWD/nf-token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport \\\"./erc721.sol\\\";\\nimport \\\"./erc721-token-receiver.sol\\\";\\nimport \\\"./supports-interface.sol\\\";\\nimport \\\"./address-utils.sol\\\";\\nimport \\\"./context.sol\\\";\\nimport \\\"./owned.sol\\\";\\n\\n/**\\n * @dev Implementation of ERC-721 non-fungible token standard.\\n */\\ncontract NFToken is\\n  ERC721,\\n  Context,\\n  SupportsInterface,\\n  Owned\\n{\\n  using AddressUtils for address;\\n\\n  /**\\n   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\\n   * Based on 0xcert framework error codes.\\n   */\\n  string constant ZERO_ADDRESS = \\\"0301\\\";\\n  string constant NOT_VALID_NFT = \\\"0302\\\";\\n  string constant NOT_OWNER_OR_OPERATOR = \\\"0303\\\";\\n  string constant NOT_OWNER_APPROVED_OR_OPERATOR = \\\"0304\\\";\\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \\\"0305\\\";\\n  string constant NFT_ALREADY_EXISTS = \\\"0306\\\";\\n  string constant NOT_OWNER = \\\"0307\\\";\\n  string constant IS_OWNER = \\\"0308\\\";\\n\\n  /**\\n   * @dev Magic value of a smart contract that can recieve NFT.\\n   * Equal to: bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\")).\\n   */\\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\\n\\n  /**\\n   * @dev A mapping from NFT ID to the address that owns it.\\n   */\\n  mapping (uint256 => address) internal idToOwner;\\n\\n  /**\\n   * @dev Mapping from NFT ID to approved address.\\n   */\\n  mapping (uint256 => address) internal idToApproval;\\n\\n   /**\\n   * @dev Mapping from owner address to count of his tokens.\\n   */\\n  mapping (address => uint256) private ownerToNFTokenCount;\\n\\n  /**\\n   * @dev Mapping from owner address to mapping of operator addresses.\\n   */\\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\\n\\n  /**\\n   * @dev Guarantees that the_msgSender() is an owner or operator of the given NFT.\\n   * @param _tokenId ID of the NFT to validate.\\n   */\\n  modifier canOperate(\\n    uint256 _tokenId\\n  )\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    require(\\n      tokenOwner ==_msgSender() || ownerToOperators[tokenOwner][msg.sender],\\n      NOT_OWNER_OR_OPERATOR\\n    );\\n    _;\\n  }\\n\\n  /**\\n   * @dev Guarantees that the_msgSender() is allowed to transfer NFT.\\n   * @param _tokenId ID of the NFT to transfer.\\n   */\\n  modifier canTransfer(\\n    uint256 _tokenId\\n  )\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    require(\\n      tokenOwner ==_msgSender()\\n      || idToApproval[_tokenId] ==_msgSender()\\n      || ownerToOperators[tokenOwner][msg.sender],\\n      NOT_OWNER_APPROVED_OR_OPERATOR\\n    );\\n    _;\\n  }\\n\\n  /**\\n   * @dev Guarantees that _tokenId is a valid Token.\\n   * @param _tokenId ID of the NFT to validate.\\n   */\\n  modifier validNFToken(\\n    uint256 _tokenId\\n  )\\n  {\\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\\n    _;\\n  }\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor()\\n  {\\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\\n  }\\n\\n  /**\\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\\n   * be changed to payable.\\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls\\n   * `onERC721Received` on `_to` and throws if the return value is not\\n   * `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   * @param _data Additional data with no specified format, sent in call to `_to`.\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes calldata _data\\n  )\\n    external\\n    override\\n  {\\n    _safeTransferFrom(_from, _to, _tokenId, _data);\\n  }\\n\\n  /**\\n   * @dev Transfers the ownership of an NFT from one address to another address. This function can\\n   * be changed to payable.\\n   * @notice This works identically to the other function with an extra data parameter, except this\\n   * function just sets data to \\\"\\\"\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    external\\n    override\\n  {\\n    _safeTransferFrom(_from, _to, _tokenId, \\\"\\\");\\n  }\\n\\n  /**\\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\\n   * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\\n   * they maybe be permanently lost.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   */\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    external\\n    override\\n    canTransfer(_tokenId)\\n    validNFToken(_tokenId)\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    require(tokenOwner == _from, NOT_OWNER);\\n    require(_to != address(0), ZERO_ADDRESS);\\n\\n    _transfer(_to, _tokenId);\\n  }\\n\\n  /**\\n   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\\n   * the current NFT owner, or an authorized operator of the current owner.\\n   * @param _approved Address to be approved for the given NFT ID.\\n   * @param _tokenId ID of the token to be approved.\\n   */\\n  function approve(\\n    address _approved,\\n    uint256 _tokenId\\n  )\\n    external\\n    override\\n    canOperate(_tokenId)\\n    validNFToken(_tokenId)\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    require(_approved != tokenOwner, IS_OWNER);\\n\\n    idToApproval[_tokenId] = _approved;\\n    emit Approval(tokenOwner, _approved, _tokenId);\\n  }\\n\\n  /**\\n   * @dev Enables or disables approval for a third party (\\\"operator\\\") to manage all of\\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\\n   * @notice This works even if sender doesn't own any tokens at the time.\\n   * @param _operator Address to add to the set of authorized operators.\\n   * @param _approved True if the operators is approved, false to revoke approval.\\n   */\\n  function setApprovalForAll(\\n    address _operator,\\n    bool _approved\\n  )\\n    external\\n    override\\n  {\\n    ownerToOperators[msg.sender][_operator] = _approved;\\n    emit ApprovalForAll(msg.sender, _operator, _approved);\\n  }\\n\\n  /**\\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\\n   * considered invalid, and this function throws for queries about the zero address.\\n   * @param _owner Address for whom to query the balance.\\n   * @return Balance of _owner.\\n   */\\n  function balanceOf(\\n    address _owner\\n  )\\n    external\\n    override\\n    view\\n    returns (uint256)\\n  {\\n    require(_owner != address(0), ZERO_ADDRESS);\\n    return _getOwnerNFTCount(_owner);\\n  }\\n\\n  /**\\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\\n   * invalid, and queries about them do throw.\\n   * @param _tokenId The identifier for an NFT.\\n   * @return _owner Address of _tokenId owner.\\n   */\\n  function ownerOf(\\n    uint256 _tokenId\\n  )\\n    external\\n    override\\n    view\\n    returns (address _owner)\\n  {\\n    _owner = idToOwner[_tokenId];\\n    require(_owner != address(0), NOT_VALID_NFT);\\n  }\\n\\n  /**\\n   * @dev Get the approved address for a single NFT.\\n   * @notice Throws if `_tokenId` is not a valid NFT.\\n   * @param _tokenId ID of the NFT to query the approval of.\\n   * @return Address that _tokenId is approved for.\\n   */\\n  function getApproved(\\n    uint256 _tokenId\\n  )\\n    external\\n    override\\n    view\\n    validNFToken(_tokenId)\\n    returns (address)\\n  {\\n    return idToApproval[_tokenId];\\n  }\\n\\n  /**\\n   * @dev Checks if `_operator` is an approved operator for `_owner`.\\n   * @param _owner The address that owns the NFTs.\\n   * @param _operator The address that acts on behalf of the owner.\\n   * @return True if approved for all, false otherwise.\\n   */\\n  function isApprovedForAll(\\n    address _owner,\\n    address _operator\\n  )\\n    external\\n    override\\n    view\\n    returns (bool)\\n  {\\n    return ownerToOperators[_owner][_operator];\\n  }\\n\\n  /**\\n   * @dev Actually preforms the transfer.\\n   * @notice Does NO checks.\\n   * @param _to Address of a new owner.\\n   * @param _tokenId The NFT that is being transferred.\\n   */\\n  function _transfer(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n  {\\n    address from = idToOwner[_tokenId];\\n    _clearApproval(_tokenId);\\n\\n    _removeNFToken(from, _tokenId);\\n    _addNFToken(_to, _tokenId);\\n\\n    //Native marketplace (owner) will always be an authorized operator.\\n        if(!ownerToOperators[_to][owner]){\\n           ownerToOperators[_to][owner] = true;\\n         }\\n\\n    emit Transfer(from, _to, _tokenId);\\n  }\\n\\n  /**\\n   * @dev Mints a new NFT.\\n   * @notice This is an internal function which should be called from user-implemented external\\n   * mint function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation.\\n   * @param _to The address that will own the minted NFT.\\n   * @param _tokenId of the NFT to be minted by the_msgSender().\\n   */\\n  function _mint(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n    virtual\\n  {\\n    require(_to != address(0), ZERO_ADDRESS);\\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\\n\\n    _addNFToken(_to, _tokenId);\\n\\n    if (_to.isContract())\\n    {\\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), _tokenId, \\\"\\\");\\n      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\\n    }\\n\\n    emit Transfer(address(0), _to, _tokenId);\\n  }\\n\\n  /**\\n   * @dev Burns a NFT.\\n   * @notice This is an internal function which should be called from user-implemented external burn\\n   * function. Its purpose is to show and properly initialize data structures when using this\\n   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\\n   * NFT.\\n   * @param _tokenId ID of the NFT to be burned.\\n   */\\n  function _burn(\\n    uint256 _tokenId\\n  )\\n    internal\\n    virtual\\n    validNFToken(_tokenId)\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    _clearApproval(_tokenId);\\n    _removeNFToken(tokenOwner, _tokenId);\\n    emit Transfer(tokenOwner, address(0), _tokenId);\\n  }\\n\\n  /**\\n   * @dev Removes a NFT from owner.\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @param _from Address from wich we want to remove the NFT.\\n   * @param _tokenId Which NFT we want to remove.\\n   */\\n  function _removeNFToken(\\n    address _from,\\n    uint256 _tokenId\\n  )\\n    internal\\n    virtual\\n  {\\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\\n    ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\\n    delete idToOwner[_tokenId];\\n  }\\n\\n  /**\\n   * @dev Assignes a new NFT to owner.\\n   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\\n   * @param _to Address to wich we want to add the NFT.\\n   * @param _tokenId Which NFT we want to add.\\n   */\\n  function _addNFToken(\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    internal\\n    virtual\\n  {\\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\\n\\n    idToOwner[_tokenId] = _to;\\n    ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to] + 1;\\n  }\\n\\n  /**\\n   * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\\n   * extension to remove double storage (gas optimization) of owner nft count.\\n   * @param _owner Address for whom to query the count.\\n   * @return Number of _owner NFTs.\\n   */\\n  function _getOwnerNFTCount(\\n    address _owner\\n  )\\n    internal\\n    virtual\\n    view\\n    returns (uint256)\\n  {\\n    return ownerToNFTokenCount[_owner];\\n  }\\n\\n  /**\\n   * @dev Actually perform the safeTransferFrom.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   * @param _data Additional data with no specified format, sent in call to `_to`.\\n   */\\n  function _safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes memory _data\\n  )\\n    private\\n    canTransfer(_tokenId)\\n    validNFToken(_tokenId)\\n  {\\n    address tokenOwner = idToOwner[_tokenId];\\n    require(tokenOwner == _from, NOT_OWNER);\\n    require(_to != address(0), ZERO_ADDRESS);\\n\\n    _transfer(_to, _tokenId);\\n\\n    if (_to.isContract())\\n    {\\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\\n      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\\n    }\\n  }\\n\\n  /**\\n   * @dev Clears the current approval of a given NFT ID.\\n   * @param _tokenId ID of the NFT to be transferred.\\n   */\\n  function _clearApproval(\\n    uint256 _tokenId\\n  )\\n    private\\n  {\\n    if (idToApproval[_tokenId] != address(0))\\n    {\\n      delete idToApproval[_tokenId];\\n    }\\n  }\\n\\n  \\n\\n}\\n\"\r\n    },\r\n    \"contracts/NMWD/erc721-enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\n/**\\n * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\n */\\ninterface ERC721Enumerable\\n{\\n\\n  /**\\n   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\\n   * assigned and queryable owner not equal to the zero address.\\n   * @return Total supply of NFTs.\\n   */\\n  function totalSupply()\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\\n   * @param _index A counter less than `totalSupply()`.\\n   * @return Token id.\\n   */\\n  function tokenByIndex(\\n    uint256 _index\\n  )\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\\n   * not specified. It throws if `_index` >= `balanceOf(_owner)` or if `_owner` is the zero address,\\n   * representing invalid NFTs.\\n   * @param _owner An address where we are interested in NFTs owned by them.\\n   * @param _index A counter less than `balanceOf(_owner)`.\\n   * @return Token id.\\n   */\\n  function tokenOfOwnerByIndex(\\n    address _owner,\\n    uint256 _index\\n  )\\n    external\\n    view\\n    returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/NMWD/erc721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\n/**\\n * @dev ERC-721 non-fungible token standard.\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\n */\\ninterface ERC721\\n{\\n\\n  /**\\n   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\\n   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\\n   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\\n   * transfer, the approved address for that NFT (if any) is reset to none.\\n   */\\n  event Transfer(\\n    address indexed _from,\\n    address indexed _to,\\n    uint256 indexed _tokenId\\n  );\\n\\n  /**\\n   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\\n   * address indicates there is no approved address. When a Transfer event emits, this also\\n   * indicates that the approved address for that NFT (if any) is reset to none.\\n   */\\n  event Approval(\\n    address indexed _owner,\\n    address indexed _approved,\\n    uint256 indexed _tokenId\\n  );\\n\\n  /**\\n   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\\n   * all NFTs of the owner.\\n   */\\n  event ApprovalForAll(\\n    address indexed _owner,\\n    address indexed _operator,\\n    bool _approved\\n  );\\n\\n  /**\\n   * @dev Transfers the ownership of an NFT from one address to another address.\\n   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\\n   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\\n   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\\n   * function checks if `_to` is a smart contract (code size > 0). If so, it calls\\n   * `onERC721Received` on `_to` and throws if the return value is not\\n   * `bytes4(keccak256(\\\"onERC721Received(address,uint256,bytes)\\\"))`.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   * @param _data Additional data with no specified format, sent in call to `_to`.\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId,\\n    bytes calldata _data\\n  )\\n    external;\\n\\n  /**\\n   * @dev Transfers the ownership of an NFT from one address to another address.\\n   * @notice This works identically to the other function with an extra data parameter, except this\\n   * function just sets data to \\\"\\\"\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   */\\n  function safeTransferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    external;\\n\\n  /**\\n   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\\n   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\\n   * address. Throws if `_tokenId` is not a valid NFT.\\n   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\\n   * they mayb be permanently lost.\\n   * @param _from The current owner of the NFT.\\n   * @param _to The new owner.\\n   * @param _tokenId The NFT to transfer.\\n   */\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _tokenId\\n  )\\n    external;\\n\\n  /**\\n   * @dev Set or reaffirm the approved address for an NFT.\\n   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\\n   * the current NFT owner, or an authorized operator of the current owner.\\n   * @param _approved The new approved NFT controller.\\n   * @param _tokenId The NFT to approve.\\n   */\\n  function approve(\\n    address _approved,\\n    uint256 _tokenId\\n  )\\n    external;\\n\\n  /**\\n   * @dev Enables or disables approval for a third party (\\\"operator\\\") to manage all of\\n   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\\n   * @notice The contract MUST allow multiple operators per owner.\\n   * @param _operator Address to add to the set of authorized operators.\\n   * @param _approved True if the operators is approved, false to revoke approval.\\n   */\\n  function setApprovalForAll(\\n    address _operator,\\n    bool _approved\\n  )\\n    external;\\n\\n  /**\\n   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\\n   * considered invalid, and this function throws for queries about the zero address.\\n   * @param _owner Address for whom to query the balance.\\n   * @return Balance of _owner.\\n   */\\n  function balanceOf(\\n    address _owner\\n  )\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\\n   * invalid, and queries about them do throw.\\n   * @param _tokenId The identifier for an NFT.\\n   * @return Address of _tokenId owner.\\n   */\\n  function ownerOf(\\n    uint256 _tokenId\\n  )\\n    external\\n    view\\n    returns (address);\\n\\n  /**\\n   * @dev Get the approved address for a single NFT.\\n   * @notice Throws if `_tokenId` is not a valid NFT.\\n   * @param _tokenId The NFT to find the approved address for.\\n   * @return Address that _tokenId is approved for.\\n   */\\n  function getApproved(\\n    uint256 _tokenId\\n  )\\n    external\\n    view\\n    returns (address);\\n\\n  /**\\n   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\\n   * @param _owner The address that owns the NFTs.\\n   * @param _operator The address that acts on behalf of the owner.\\n   * @return True if approved for all, false otherwise.\\n   */\\n  function isApprovedForAll(\\n    address _owner,\\n    address _operator\\n  )\\n    external\\n    view\\n    returns (bool);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/NMWD/erc721-token-receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\n/**\\n * @dev ERC-721 interface for accepting safe transfers.\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\n */\\ninterface ERC721TokenReceiver\\n{\\n\\n  /**\\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\\n   * of other than the magic value MUST result in the transaction being reverted.\\n   * Returns `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))` unless throwing.\\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\\n   * MUST implement the wallet interface if it will accept safe transfers.\\n   * @param _operator The address which called `safeTransferFrom` function.\\n   * @param _from The address which previously owned the token.\\n   * @param _tokenId The NFT identifier which is being transferred.\\n   * @param _data Additional data with no specified format.\\n   * @return Returns `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n   */\\n  function onERC721Received(\\n    address _operator,\\n    address _from,\\n    uint256 _tokenId,\\n    bytes calldata _data\\n  )\\n    external\\n    returns(bytes4);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/NMWD/supports-interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport \\\"./erc165.sol\\\";\\n\\n/**\\n * @dev Implementation of standard for detect smart contract interfaces.\\n */\\ncontract SupportsInterface is\\n  ERC165\\n{\\n\\n  /**\\n   * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.\\n   */\\n  mapping(bytes4 => bool) internal supportedInterfaces;\\n\\n  /**\\n   * @dev Contract constructor.\\n   */\\n  constructor()\\n  {\\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\\n  }\\n\\n  /**\\n   * @dev Function to check which interfaces are suported by this contract.\\n   * @param _interfaceID Id of the interface.\\n   * @return True if _interfaceID is supported, false otherwise.\\n   */\\n  function supportsInterface(\\n    bytes4 _interfaceID\\n  )\\n    external\\n    override\\n    view\\n    returns (bool)\\n  {\\n    return supportedInterfaces[_interfaceID];\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/NMWD/erc165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\n/**\\n * @dev A standard for detecting smart contract interfaces. \\n * See: https://eips.ethereum.org/EIPS/eip-165.\\n */\\ninterface ERC165\\n{\\n\\n  /**\\n   * @dev Checks if the smart contract includes a specific interface.\\n   * This function uses less than 30,000 gas.\\n   * @param _interfaceID The interface identifier, as specified in ERC-165.\\n   * @return True if _interfaceID is supported, false otherwise.\\n   */\\n  function supportsInterface(\\n    bytes4 _interfaceID\\n  )\\n    external\\n    view\\n    returns (bool);\\n    \\n}\\n\"\r\n    },\r\n    \"contracts/NMWD/erc721-metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\n/**\\n * @dev Optional metadata extension for ERC-721 non-fungible token standard.\\n * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\\n */\\ninterface ERC721Metadata\\n{\\n\\n  /**\\n   * @dev Returns a descriptive name for a collection of NFTs in this contract.\\n   * @return _name Representing name.\\n   */\\n  function name()\\n    external\\n    view\\n    returns (string memory _name);\\n\\n  /**\\n   * @dev Returns a abbreviated name for a collection of NFTs in this contract.\\n   * @return _symbol Representing symbol.\\n   */\\n  function symbol()\\n    external\\n    view\\n    returns (string memory _symbol);\\n\\n  /**\\n   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\\n   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\\n   * that conforms to the \\\"ERC721 Metadata JSON Schema\\\".\\n   * @return URI of _tokenId.\\n   */\\n  function tokenURI(uint256 _tokenId)\\n    external\\n    view\\n    returns (string memory);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/NMWD/ierc2981-royalties.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title IERC2981Royalties\\n/// @dev Interface for the ERC2981 - Token Royalty standard\\ninterface IERC2981Royalties {\\n    /// @notice Called with the sale price to determine how much royalty\\n    //          is owed and to whom.\\n    /// @param _tokenId - the NFT asset queried for royalty information\\n    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId\\n    /// @return receiver - address of who should be sent the royalty payment\\n    /// @return royaltyAmount - the royalty payment amount for value sale price\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RoyaltyPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SecurityWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Sent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"deliveredTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"msg\",\"type\":\"string\"}],\"name\":\"_msg\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CANNOT_TRANSFER_TO_ZERO_ADDRESS\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NOT_CURRENT_OWNER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TokenContract\",\"outputs\":[{\"internalType\":\"contract StopTheWarOnDrugs\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBackOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getForSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarketPlaceBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"mintThroughPurchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"purchaseToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_forSale\",\"type\":\"bool\"}],\"name\":\"setForSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_locked\",\"type\":\"bool\"}],\"name\":\"setMintLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_royaltyAddress\",\"type\":\"address\"}],\"name\":\"setPriceForMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nmwdAddress\",\"type\":\"address\"}],\"name\":\"updateNMWDcontract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_payee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SWDMarketPlace","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}