{"status":"1","message":"OK","result":[{"SourceCode":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.1;\r\n\r\n/// @title MultisigControl Interface\r\n/// @author Vega Protocol\r\n/// @notice Implementations of this interface are used by the Vega network to control smart contracts without the need for Vega to have any Ethereum of its own.\r\n/// @notice To do this, the Vega validators sign a MultisigControl order to construct a signature bundle. Any interested party can then take that signature bundle and pay the gas to run the command on Ethereum\r\nabstract contract IMultisigControl {\r\n\r\n    /***************************EVENTS****************************/\r\n    event SignerAdded(address new_signer);\r\n    event SignerRemoved(address old_signer);\r\n    event ThresholdSet(uint16 new_threshold);\r\n\r\n    /**************************FUNCTIONS*********************/\r\n    /// @notice Sets threshold of signatures that must be met before function is executed.\r\n    /// @param new_threshold New threshold value\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @notice Ethereum has no decimals, threshold is % * 10 so 50% == 500 100% == 1000\r\n    /// @notice signatures are OK if they are >= threshold count of total valid signers\r\n    /// @dev MUST emit ThresholdSet event\r\n    function set_threshold(uint16 new_threshold, uint nonce, bytes memory signatures) public virtual;\r\n\r\n    /// @notice Adds new valid signer and adjusts signer count.\r\n    /// @param new_signer New signer address\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev MUST emit 'SignerAdded' event\r\n    function add_signer(address new_signer, uint nonce, bytes memory signatures) public virtual;\r\n\r\n    /// @notice Removes currently valid signer and adjusts signer count.\r\n    /// @param old_signer Address of signer to be removed.\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @dev MUST emit 'SignerRemoved' event\r\n    function remove_signer(address old_signer, uint nonce, bytes memory signatures) public virtual;\r\n\r\n    /// @notice Verifies a signature bundle and returns true only if the threshold of valid signers is met,\r\n    /// @notice this is a function that any function controlled by Vega MUST call to be securely controlled by the Vega network\r\n    /// @notice message to hash to sign follows this pattern:\r\n    /// @notice abi.encode( abi.encode(param1, param2, param3, ... , nonce, function_name_string), validating_contract_or_submitter_address);\r\n    /// @notice Note that validating_contract_or_submitter_address is the the submitting party. If on MultisigControl contract itself, it's the submitting ETH address\r\n    /// @notice if function on bridge that then calls Multisig, then it's the address of that contract\r\n    /// @notice Note also the embedded encoding, this is required to verify what function/contract the function call goes to\r\n    /// @return MUST return true if valid signatures are over the threshold\r\n    function verify_signatures(bytes memory signatures, bytes memory message, uint nonce) public virtual returns(bool);\r\n\r\n    /**********************VIEWS*********************/\r\n    /// @return Number of valid signers\r\n    function get_valid_signer_count() public virtual view returns(uint8);\r\n\r\n    /// @return Current threshold\r\n    function get_current_threshold() public virtual view returns(uint16);\r\n\r\n    /// @param signer_address target potential signer address\r\n    /// @return true if address provided is valid signer\r\n    function is_valid_signer(address signer_address) public virtual view returns(bool);\r\n\r\n    /// @param nonce Nonce to lookup\r\n    /// @return true if nonce has been used\r\n    function is_nonce_used(uint nonce) public virtual view returns(bool);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/// @title ERC20 Asset Pool\r\n/// @author Vega Protocol\r\n/// @notice This contract is the target for all deposits to the ERC20 Bridge via ERC20_Bridge_Logic\r\ncontract ERC20_Asset_Pool {\r\n\r\n    event Multisig_Control_Set(address indexed new_address);\r\n    event Bridge_Address_Set(address indexed new_address);\r\n\r\n    /// @return Current MultisigControl contract address\r\n    address public multisig_control_address;\r\n\r\n    /// @return Current ERC20_Bridge_Logic contract address\r\n    address public erc20_bridge_address;\r\n\r\n    /// @param multisig_control The initial MultisigControl contract address\r\n    /// @notice Emits Multisig_Control_Set event\r\n    constructor(address multisig_control) {\r\n        multisig_control_address = multisig_control;\r\n        emit Multisig_Control_Set(multisig_control);\r\n    }\r\n\r\n    /// @param new_address The new MultisigControl contract address.\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed set_multisig_control order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @notice Emits Multisig_Control_Set event\r\n    function set_multisig_control(address new_address, uint256 nonce, bytes memory signatures) public {\r\n        bytes memory message = abi.encode(new_address, nonce, 'set_multisig_control');\r\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\r\n        multisig_control_address = new_address;\r\n        emit Multisig_Control_Set(new_address);\r\n    }\r\n\r\n    /// @param new_address The new ERC20_Bridge_Logic contract address.\r\n    /// @param nonce Vega-assigned single-use number that provides replay attack protection\r\n    /// @param signatures Vega-supplied signature bundle of a validator-signed set_bridge_address order\r\n    /// @notice See MultisigControl for more about signatures\r\n    /// @notice Emits Bridge_Address_Set event\r\n    function set_bridge_address(address new_address, uint256 nonce, bytes memory signatures) public {\r\n        bytes memory message = abi.encode(new_address, nonce, 'set_bridge_address');\r\n        require(IMultisigControl(multisig_control_address).verify_signatures(signatures, message, nonce), \"bad signatures\");\r\n        erc20_bridge_address = new_address;\r\n        emit Bridge_Address_Set(new_address);\r\n    }\r\n\r\n    /// @notice This function can only be run by the current \"multisig_control_address\" and, if available, will send the target tokens to the target\r\n    /// @param token_address Contract address of the ERC20 token to be withdrawn\r\n    /// @param target Target Ethereum address that the ERC20 tokens will be sent to\r\n    /// @param amount Amount of ERC20 tokens to withdraw\r\n    /// @dev amount is in whatever the lowest decimal value the ERC20 token has. For instance, an 18 decimal ERC20 token, 1 \"amount\" == 0.000000000000000001\r\n    /// @return true if transfer was successful.\r\n    function withdraw(address token_address, address target, uint256 amount) public returns(bool) {\r\n        require(msg.sender == erc20_bridge_address, \"msg.sender not authorized bridge\");\r\n        require(IERC20(token_address).transfer(target, amount), \"token transfer failed\");\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMWEMMMMMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMLOVEMMMMMMMMMMMMMMMMMMMMMM...............MMMMMMMMMMMMM\r\nMMMMMMMMMMHIXELMMMMMMMMMMMM....................MMMMMNNMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMM....................MMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMM88=........................+MMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMM....................MMMMM...MMMMMMMMMMMMMMM\r\nMMMMMMMMMMMM.........................MM+..MMM....+MMMMMMMMMM\r\nMMMMMMMMMNMM...................... ..MM?..MMM.. .+MMMMMMMMMM\r\nMMMMNDDMM+........................+MM........MM..+MMMMMMMMMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................MMM\r\nMMMMZ.............................+MM....................DDD\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMZ.............................+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM..............................MMZ....ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM............................MM.......ZMMMMMMMMMMMMMMMMMMMM\r\nMM......................ZMMMMM.......MMMMMMMMMMMMMMMMMMMMMMM\r\nMM............... ......ZMMMMM.... ..MMMMMMMMMMMMMMMMMMMMMMM\r\nMM...............MMMMM88~.........+MM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......$DDDDDDD.......$DDDDD..DDNMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMM.......ZMMMMMMM.......ZMMMMM..MMMMM..ZMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMM+.......MMMMM88NMMMMM..MMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"multisig_control\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"new_address\",\"type\":\"address\"}],\"name\":\"Bridge_Address_Set\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"new_address\",\"type\":\"address\"}],\"name\":\"Multisig_Control_Set\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"erc20_bridge_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multisig_control_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"set_bridge_address\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"set_multisig_control\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC20_Asset_Pool","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009d0707c91c67d598808834b4881348684e92e11e","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e5000f2af5f8179da456edc62e2da6f9984da23f825d84b206e057b7753c83f9"}]}