{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ProfanityLib.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"./StringUtils.sol\\\";\\n\\nlibrary ProfanityLib {\\n    using strings for *;\\n\\n    uint private constant one_count = 28;\\n    uint private constant two_count = 48;\\n    uint private constant three_count = 147;\\n    uint private constant four_count = 26;\\n    uint private constant color_count = 13;\\n\\n    string private constant one = \\\"shit, you're a|eat shit, you|fuck, what a|oh no, a|my partner is a|my mom is a|I'd fuck that|fuck off, you|wow, what a|baby, you're a|hey, look at the|I love my|omg u|dad, I'm a|my husband is a|mom, I'm a|ngmi, you|gm, you|shit, i'm a|my dad is a|I'm a|what a|my neighbor is a|you're a|I'm married to a|ygmi, you|my wife is a|you|i spy a\\\";\\n    string private constant two = \\\"bastardized|fancy fucking|failed|big black|kinky|rim jobbing|snowballing|sodomizing|leg spreading|cum guzzling|taint licking|wet dreaming|leaking|tea bagging|throbbing|god damn|slutty|weak ass|fucking|motherfucking|bullshitting|hot ass|nasty|naked|sexy|skanky|two bit|skanky ass|slippery|slimy|well lubed|skeezy|selfish|half assed|tight ass|lazy ass|lazy fucking|crazy ass|paper handed|diamond handed|punk ass|cheap fucking|sopping wet|dripping wet|fucking irrelevant|uneducated|dumb ass|scat munching|pindicked\\\";\\n    string private constant three = \\\"titty fucker|pussy eater|cockmuncher|shit eater|fistfucker|pegger|ass clown|fudge packer|fat ass|fuck|dickhead|shit face|wanker|douche|tit fucker|cum shot|jizz slurper|buttplug|blowjob|prickhead|squirter|vibrator|bunny fucker|deep throater|whore|face fucker|jackoff|bitch|bum fuck|pussy pounder|cock|cock cowboy|cum guzzler|cockface|dildo|sodomizer|cum fest|ass kisser|ass hole|virgin breaker|cum bubble|fingerfucker|swallower|ass blaster|sloppy slut|dick for brains|nutsack|cherry popper|crack whore|cyberfucker|numbnuts|shit stain|limp dick|snatch|cum jockey|prick|ass bagger|asshole|drip dick|donkeyribber|shit fuck|dripping cunt|sperm bag|ball licker|skin flute|soaking cunt|clit|cock sucker|cunt sucker|felcher|dripping snatch|ass muncher|orgasm|cunt|slut|fannyfucker|son of a bitch|skank|jizz face|sex slave|shit dick|dumb bitch|spready puss|bumble fuck|cock block|fat fuck|pin dick|milf|shit fucker|dilf|snowballer|fuckhead|lesbian|butthole|ass puppy|sex kitten|knob|shit can|knob jocky|ass licker|whiskey dick|boner|dick|cumshot|ass fucker|stupid fuck|anus|loose slut|ass monkey|ass hat|bastard|pussy|rimjaw|ass packer|cuntlicker|juicy snatch|dipshit|dog fucker|shithouse|pig fucker|ass jockey|ass munch|ballbag|sperm hearder|cock smoker|nobhead|ass fuck|foreskin slurper|pussy licker|dripping slut|cockhead|ballsack|cum queen|butt fucker|giant cock|carpet muncher|ass man|jerk off|scrotum|motherfucker|shit head|fist fucker|ass pirate|ass cowboy|buttmunch|breast man|cock tease|dumb fuck\\\";\\n    string private constant four = \\\"suck a dick|balls|up the ass|suck my ass|fuck em|gn, assclowns|gm shitfucks|fuck me|gm fuckers, wgmi|what a shitty nft|fucking hell|suck my titties|fuck yea... wgmi|fucking nfts|fuck you|suck me|fucking jpegs|suck my dick|eat my ass|fuck off|eat shit|fuck|titties|gm fuckheads|tits|gm assholes, wagmi|shit|jizz|ass\\\";\\n    string private constant colors = \\\"#FF0000;#FFFFFF|#ff008d;#fdff00;#00ecff;#00abff;#00ff38|#264653;#2a9d8f;#e9c46a;#f4a261;#e76f51|#1a535c;#4ecdc4;#f7fff7;#ff6b6b;#ffe66d|#FFFFFF;#000000|#EF476F;#FFD166;#FFD166;#118AB2;#073B4C|#eeeeee;#e4eaec;#ecf4f2;#e3e5e5;#ccd8d7;#EF476F|#8dbd05;#00a1ae;#5e36cc;#fe318e;#ff7540|#d00000;#ffba08;#3f88c5;#032b43;#136f63|#FF0000;#149414|#eeeeee;#CCCCCC;#999999;#666666;#333333|#ef476f;#ffd166;#06d6a0;#118ab2;#073b4c|#f72585;#7209b7;#3a0ca3;#4361ee;#4cc9f0|#FE7C00;#FFD832;#00B4AB\\\";\\n    \\n    function random(uint max, uint seed, uint tokenId) public pure returns (uint) {\\n        // not really random, but since we can provide variations of the user's N as seeds it will do.\\n        uint randomHash = uint(keccak256(abi.encode(seed, tokenId)));\\n        return randomHash % max;\\n    }\\n\\n    function getStringToken(string memory input, uint256 index) private pure returns (string memory) {\\n        // we need to slice up delimitted strings, because storing them all in a string array on contract is\\n        // cost prohibitive, whereas storing within a string is far cheaper.\\n        strings.slice memory s = input.toSlice();\\n        strings.slice memory delim = \\\"|\\\".toSlice();\\n\\n        // just iterate and throw away anything up until our target index.\\n        for (uint i = 0; i <= index; i++) {\\n            if (i == index) {\\n                return s.split(delim).toString();\\n            } else {\\n                s.split(delim);\\n            }\\n        }\\n\\n        return \\\"\\\";\\n    }\\n\\n    function getWords(uint seedOne, uint seedTwo, uint seedThree, uint seedFour, uint tokenId) public pure returns (string memory, string memory, string memory, string memory) {\\n        return (\\n            getStringToken(one, random(one_count, seedOne, tokenId)),\\n            getStringToken(two, random(two_count, seedTwo, tokenId)),\\n            getStringToken(three, random(three_count, seedThree, tokenId)),\\n            getStringToken(string(abi.encodePacked(three, \\\"|\\\", four)), random(three_count + four_count, seedFour, tokenId))\\n        );\\n    }\\n\\n    function getColorScheme(uint seed, uint tokenId) public pure returns (string memory) {\\n        return getStringToken(colors, random(color_count, seed, tokenId));\\n    }\\n\\n    function getFontFace() public pure returns (string memory) {\\n        return '@font-face {font-family: \\\"Early GameBoy\\\";src: url(data:application/font-woff;base64,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);}';\\n    }\\n}\"\r\n    },\r\n    \"contracts/StringUtils.sol\": {\r\n      \"content\": \"/*\\n * @title String & slice utility library for Solidity contracts.\\n * @author Nick Johnson <arachnid@notdot.net>\\n *\\n * @dev Functionality in this library is largely implemented using an\\n *      abstraction called a 'slice'. A slice represents a part of a string -\\n *      anything from the entire string to a single character, or even no\\n *      characters at all (a 0-length slice). Since a slice only has to specify\\n *      an offset and a length, copying and manipulating slices is a lot less\\n *      expensive than copying and manipulating the strings they reference.\\n *\\n *      To further reduce gas costs, most functions on slice that need to return\\n *      a slice modify the original one instead of allocating a new one; for\\n *      instance, `s.split(\\\".\\\")` will return the text up to the first '.',\\n *      modifying s to only contain the remainder of the string after the '.'.\\n *      In situations where you do not want to modify the original slice, you\\n *      can make a copy first with `.copy()`, for example:\\n *      `s.copy().split(\\\".\\\")`. Try and avoid using this idiom in loops; since\\n *      Solidity has no memory management, it will result in allocating many\\n *      short-lived slices that are later discarded.\\n *\\n *      Functions that return two slices come in two versions: a non-allocating\\n *      version that takes the second slice as an argument, modifying it in\\n *      place, and an allocating version that allocates and returns the second\\n *      slice; see `nextRune` for example.\\n *\\n *      Functions that have to copy string data will return strings rather than\\n *      slices; these can be cast back to slices for further processing if\\n *      required.\\n *\\n *      For convenience, some functions are provided with non-modifying\\n *      variants that create a new slice and return both; for instance,\\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\\n *      corresponding to the left and right parts of the string.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nlibrary strings {\\n    struct slice {\\n        uint _len;\\n        uint _ptr;\\n    }\\n\\n    function memcpy(uint dest, uint src, uint leng) private pure {\\n        // Copy word-length chunks while possible\\n        for(; leng >= 32; leng -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint mask = 256 ** (32 - leng) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire string.\\n     * @param self The string to make a slice from.\\n     * @return A newly allocated slice containing the entire string.\\n     */\\n    function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns the length of a null-terminated bytes32 string.\\n     * @param self The value to find the length of.\\n     * @return The length of the string, from 0 to 32.\\n     */\\n    function len(bytes32 self) internal pure returns (uint) {\\n        uint ret;\\n        if (self == 0)\\n            return 0;\\n        if (uint(self) & 0xffffffffffffffffffffffffffffffff == 0) {\\n            ret += 16;\\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\\n        }\\n        if (uint(self) & 0xffffffffffffffff == 0) {\\n            ret += 8;\\n            self = bytes32(uint(self) / 0x10000000000000000);\\n        }\\n        if (uint(self) & 0xffffffff == 0) {\\n            ret += 4;\\n            self = bytes32(uint(self) / 0x100000000);\\n        }\\n        if (uint(self) & 0xffff == 0) {\\n            ret += 2;\\n            self = bytes32(uint(self) / 0x10000);\\n        }\\n        if (uint(self) & 0xff == 0) {\\n            ret += 1;\\n        }\\n        return 32 - ret;\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\\n     *      null-terminated utf-8 string.\\n     * @param self The bytes32 value to convert to a slice.\\n     * @return A new slice containing the value of the input argument up to the\\n     *         first null.\\n     */\\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\\n        // Allocate space for `self` in memory, copy it there, and point ret at it\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(0x40, add(ptr, 0x20))\\n            mstore(ptr, self)\\n            mstore(add(ret, 0x20), ptr)\\n        }\\n        ret._len = len(self);\\n    }\\n\\n    /*\\n     * @dev Returns a new slice containing the same data as the current slice.\\n     * @param self The slice to copy.\\n     * @return A new slice containing the same data as `self`.\\n     */\\n    function copy(slice memory self) internal pure returns (slice memory) {\\n        return slice(self._len, self._ptr);\\n    }\\n\\n    /*\\n     * @dev Copies a slice to a new string.\\n     * @param self The slice to copy.\\n     * @return A newly allocated string containing the slice's text.\\n     */\\n    function toString(slice memory self) internal pure returns (string memory) {\\n        string memory ret = new string(self._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        memcpy(retptr, self._ptr, self._len);\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Returns the length in runes of the slice. Note that this operation\\n     *      takes time proportional to the length of the slice; avoid using it\\n     *      in loops, and call `slice.empty()` if you only need to know whether\\n     *      the slice is empty or not.\\n     * @param self The slice to operate on.\\n     * @return The length of the slice in runes.\\n     */\\n    function len(slice memory self) internal pure returns (uint l) {\\n        // Starting at ptr-31 means the LSB will be the byte we care about\\n        uint ptr = self._ptr - 31;\\n        uint end = ptr + self._len;\\n        for (l = 0; ptr < end; l++) {\\n            uint8 b;\\n            assembly { b := and(mload(ptr), 0xFF) }\\n            if (b < 0x80) {\\n                ptr += 1;\\n            } else if(b < 0xE0) {\\n                ptr += 2;\\n            } else if(b < 0xF0) {\\n                ptr += 3;\\n            } else if(b < 0xF8) {\\n                ptr += 4;\\n            } else if(b < 0xFC) {\\n                ptr += 5;\\n            } else {\\n                ptr += 6;\\n            }\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns true if the slice is empty (has a length of 0).\\n     * @param self The slice to operate on.\\n     * @return True if the slice is empty, False otherwise.\\n     */\\n    function empty(slice memory self) internal pure returns (bool) {\\n        return self._len == 0;\\n    }\\n\\n    /*\\n     * @dev Returns a positive number if `other` comes lexicographically after\\n     *      `self`, a negative number if it comes before, or zero if the\\n     *      contents of the two slices are equal. Comparison is done per-rune,\\n     *      on unicode codepoints.\\n     * @param self The first slice to compare.\\n     * @param other The second slice to compare.\\n     * @return The result of the comparison.\\n     */\\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\\n        uint shortest = self._len;\\n        if (other._len < self._len)\\n            shortest = other._len;\\n\\n        uint selfptr = self._ptr;\\n        uint otherptr = other._ptr;\\n        for (uint idx = 0; idx < shortest; idx += 32) {\\n            uint a;\\n            uint b;\\n            assembly {\\n                a := mload(selfptr)\\n                b := mload(otherptr)\\n            }\\n            if (a != b) {\\n                // Mask out irrelevant bytes and check again\\n                uint256 mask = type(uint256).max; // 0xffff...\\n                if(shortest < 32) {\\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\\n                }\\n                unchecked {\\n                    uint256 diff = (a & mask) - (b & mask);\\n                    if (diff != 0)\\n                        return int(diff);\\n                }\\n            }\\n            selfptr += 32;\\n            otherptr += 32;\\n        }\\n        return int(self._len) - int(other._len);\\n    }\\n\\n    /*\\n     * @dev Returns true if the two slices contain the same text.\\n     * @param self The first slice to compare.\\n     * @param self The second slice to compare.\\n     * @return True if the slices are equal, false otherwise.\\n     */\\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\\n        return compare(self, other) == 0;\\n    }\\n\\n    /*\\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\\n     *      slice to point to the next rune and returning `self`.\\n     * @param self The slice to operate on.\\n     * @param rune The slice that will contain the first rune.\\n     * @return `rune`.\\n     */\\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\\n        rune._ptr = self._ptr;\\n\\n        if (self._len == 0) {\\n            rune._len = 0;\\n            return rune;\\n        }\\n\\n        uint l;\\n        uint b;\\n        // Load the first byte of the rune into the LSBs of b\\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\\n        if (b < 0x80) {\\n            l = 1;\\n        } else if(b < 0xE0) {\\n            l = 2;\\n        } else if(b < 0xF0) {\\n            l = 3;\\n        } else {\\n            l = 4;\\n        }\\n\\n        // Check for truncated codepoints\\n        if (l > self._len) {\\n            rune._len = self._len;\\n            self._ptr += self._len;\\n            self._len = 0;\\n            return rune;\\n        }\\n\\n        self._ptr += l;\\n        self._len -= l;\\n        rune._len = l;\\n        return rune;\\n    }\\n\\n    /*\\n     * @dev Returns the first rune in the slice, advancing the slice to point\\n     *      to the next rune.\\n     * @param self The slice to operate on.\\n     * @return A slice containing only the first rune from `self`.\\n     */\\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\\n        nextRune(self, ret);\\n    }\\n\\n    /*\\n     * @dev Returns the number of the first codepoint in the slice.\\n     * @param self The slice to operate on.\\n     * @return The number of the first codepoint in the slice.\\n     */\\n    function ord(slice memory self) internal pure returns (uint ret) {\\n        if (self._len == 0) {\\n            return 0;\\n        }\\n\\n        uint word;\\n        uint length;\\n        uint divisor = 2 ** 248;\\n\\n        // Load the rune into the MSBs of b\\n        assembly { word:= mload(mload(add(self, 32))) }\\n        uint b = word / divisor;\\n        if (b < 0x80) {\\n            ret = b;\\n            length = 1;\\n        } else if(b < 0xE0) {\\n            ret = b & 0x1F;\\n            length = 2;\\n        } else if(b < 0xF0) {\\n            ret = b & 0x0F;\\n            length = 3;\\n        } else {\\n            ret = b & 0x07;\\n            length = 4;\\n        }\\n\\n        // Check for truncated codepoints\\n        if (length > self._len) {\\n            return 0;\\n        }\\n\\n        for (uint i = 1; i < length; i++) {\\n            divisor = divisor / 256;\\n            b = (word / divisor) & 0xFF;\\n            if (b & 0xC0 != 0x80) {\\n                // Invalid UTF-8 sequence\\n                return 0;\\n            }\\n            ret = (ret * 64) | (b & 0x3F);\\n        }\\n\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Returns the keccak-256 hash of the slice.\\n     * @param self The slice to hash.\\n     * @return The hash of the slice.\\n     */\\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\\n        assembly {\\n            ret := keccak256(mload(add(self, 32)), mload(self))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns true if `self` starts with `needle`.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return True if the slice starts with the provided text, false otherwise.\\n     */\\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\\n        if (self._len < needle._len) {\\n            return false;\\n        }\\n\\n        if (self._ptr == needle._ptr) {\\n            return true;\\n        }\\n\\n        bool equal;\\n        assembly {\\n            let length := mload(needle)\\n            let selfptr := mload(add(self, 0x20))\\n            let needleptr := mload(add(needle, 0x20))\\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n        }\\n        return equal;\\n    }\\n\\n    /*\\n     * @dev If `self` starts with `needle`, `needle` is removed from the\\n     *      beginning of `self`. Otherwise, `self` is unmodified.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return `self`\\n     */\\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        if (self._len < needle._len) {\\n            return self;\\n        }\\n\\n        bool equal = true;\\n        if (self._ptr != needle._ptr) {\\n            assembly {\\n                let length := mload(needle)\\n                let selfptr := mload(add(self, 0x20))\\n                let needleptr := mload(add(needle, 0x20))\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n            }\\n        }\\n\\n        if (equal) {\\n            self._len -= needle._len;\\n            self._ptr += needle._len;\\n        }\\n\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Returns true if the slice ends with `needle`.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return True if the slice starts with the provided text, false otherwise.\\n     */\\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\\n        if (self._len < needle._len) {\\n            return false;\\n        }\\n\\n        uint selfptr = self._ptr + self._len - needle._len;\\n\\n        if (selfptr == needle._ptr) {\\n            return true;\\n        }\\n\\n        bool equal;\\n        assembly {\\n            let length := mload(needle)\\n            let needleptr := mload(add(needle, 0x20))\\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n        }\\n\\n        return equal;\\n    }\\n\\n    /*\\n     * @dev If `self` ends with `needle`, `needle` is removed from the\\n     *      end of `self`. Otherwise, `self` is unmodified.\\n     * @param self The slice to operate on.\\n     * @param needle The slice to search for.\\n     * @return `self`\\n     */\\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        if (self._len < needle._len) {\\n            return self;\\n        }\\n\\n        uint selfptr = self._ptr + self._len - needle._len;\\n        bool equal = true;\\n        if (selfptr != needle._ptr) {\\n            assembly {\\n                let length := mload(needle)\\n                let needleptr := mload(add(needle, 0x20))\\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\\n            }\\n        }\\n\\n        if (equal) {\\n            self._len -= needle._len;\\n        }\\n\\n        return self;\\n    }\\n\\n    // Returns the memory address of the first byte of the first occurrence of\\n    // `needle` in `self`, or the first byte after `self` if not found.\\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\n        uint ptr = selfptr;\\n        uint idx;\\n\\n        if (needlelen <= selflen) {\\n            if (needlelen <= 32) {\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\n\\n                bytes32 needledata;\\n                assembly { needledata := and(mload(needleptr), mask) }\\n\\n                uint end = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly { ptrdata := and(mload(ptr), mask) }\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr >= end)\\n                        return selfptr + selflen;\\n                    ptr++;\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\n                }\\n                return ptr;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly { hash := keccak256(needleptr, needlelen) }\\n\\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\\n                    bytes32 testHash;\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\n                    if (hash == testHash)\\n                        return ptr;\\n                    ptr += 1;\\n                }\\n            }\\n        }\\n        return selfptr + selflen;\\n    }\\n\\n    // Returns the memory address of the first byte after the last occurrence of\\n    // `needle` in `self`, or the address of `self` if not found.\\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\\n        uint ptr;\\n\\n        if (needlelen <= selflen) {\\n            if (needlelen <= 32) {\\n                bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\\n\\n                bytes32 needledata;\\n                assembly { needledata := and(mload(needleptr), mask) }\\n\\n                ptr = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly { ptrdata := and(mload(ptr), mask) }\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr <= selfptr)\\n                        return selfptr;\\n                    ptr--;\\n                    assembly { ptrdata := and(mload(ptr), mask) }\\n                }\\n                return ptr + needlelen;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly { hash := keccak256(needleptr, needlelen) }\\n                ptr = selfptr + (selflen - needlelen);\\n                while (ptr >= selfptr) {\\n                    bytes32 testHash;\\n                    assembly { testHash := keccak256(ptr, needlelen) }\\n                    if (hash == testHash)\\n                        return ptr + needlelen;\\n                    ptr -= 1;\\n                }\\n            }\\n        }\\n        return selfptr;\\n    }\\n\\n    /*\\n     * @dev Modifies `self` to contain everything from the first occurrence of\\n     *      `needle` to the end of the slice. `self` is set to the empty slice\\n     *      if `needle` is not found.\\n     * @param self The slice to search and modify.\\n     * @param needle The text to search for.\\n     * @return `self`.\\n     */\\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        self._len -= ptr - self._ptr;\\n        self._ptr = ptr;\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Modifies `self` to contain the part of the string from the start of\\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\\n     *      is not found, `self` is set to the empty slice.\\n     * @param self The slice to search and modify.\\n     * @param needle The text to search for.\\n     * @return `self`.\\n     */\\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        self._len = ptr - self._ptr;\\n        return self;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and `token` to everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and `token` is set to the entirety of `self`.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @param token An output parameter to which the first token is written.\\n     * @return `token`.\\n     */\\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = self._ptr;\\n        token._len = ptr - self._ptr;\\n        if (ptr == self._ptr + self._len) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n            self._ptr = ptr + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and returning everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and the entirety of `self` is returned.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @return The part of `self` up to the first occurrence of `delim`.\\n     */\\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\\n        split(self, needle, token);\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything before the last\\n     *      occurrence of `needle`, and `token` to everything after it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and `token` is set to the entirety of `self`.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @param token An output parameter to which the first token is written.\\n     * @return `token`.\\n     */\\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = ptr;\\n        token._len = self._len - (ptr - self._ptr);\\n        if (ptr == self._ptr) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything before the last\\n     *      occurrence of `needle`, and returning everything after it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and the entirety of `self` is returned.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @return The part of `self` after the last occurrence of `delim`.\\n     */\\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\\n        rsplit(self, needle, token);\\n    }\\n\\n    /*\\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\\n     * @param self The slice to search.\\n     * @param needle The text to search for in `self`.\\n     * @return The number of occurrences of `needle` found in `self`.\\n     */\\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\\n        while (ptr <= self._ptr + self._len) {\\n            cnt++;\\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns True if `self` contains `needle`.\\n     * @param self The slice to search.\\n     * @param needle The text to search for in `self`.\\n     * @return True if `needle` is found in `self`, false otherwise.\\n     */\\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\\n    }\\n\\n    /*\\n     * @dev Returns a newly allocated string containing the concatenation of\\n     *      `self` and `other`.\\n     * @param self The first slice to concatenate.\\n     * @param other The second slice to concatenate.\\n     * @return The concatenation of the two strings.\\n     */\\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\\n        string memory ret = new string(self._len + other._len);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n        memcpy(retptr, self._ptr, self._len);\\n        memcpy(retptr + self._len, other._ptr, other._len);\\n        return ret;\\n    }\\n\\n    /*\\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\\n     *      newly allocated string.\\n     * @param self The delimiter to use.\\n     * @param parts A list of slices to join.\\n     * @return A newly allocated string containing all the slices in `parts`,\\n     *         joined with `self`.\\n     */\\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\\n        if (parts.length == 0)\\n            return \\\"\\\";\\n\\n        uint length = self._len * (parts.length - 1);\\n        for(uint i = 0; i < parts.length; i++)\\n            length += parts[i]._len;\\n\\n        string memory ret = new string(length);\\n        uint retptr;\\n        assembly { retptr := add(ret, 32) }\\n\\n        for(uint i = 0; i < parts.length; i++) {\\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\\n            retptr += parts[i]._len;\\n            if (i < parts.length - 1) {\\n                memcpy(retptr, self._ptr, self._len);\\n                retptr += self._len;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getColorScheme\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFontFace\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seedOne\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seedTwo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seedThree\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seedFour\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getWords\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"random\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"ProfanityLib","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}