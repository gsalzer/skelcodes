{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.8.4;\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\ninterface IERC721Metadata {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string memory _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string memory _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\ninterface IERC721Enumerable {\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\nabstract contract Initializable {\r\n//@openzeppelin/upgrades/contracts/Initializable.sol\r\n\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address internal owner_;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  \r\n    modifier onlyOwner() {\r\n        require(owner_ == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return owner_;\r\n    }\r\n  \r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0), \"ERC721: new owner is the zero address\");\r\n        emit OwnershipTransferred(owner(), _newOwner);\r\n        owner_ = _newOwner;\r\n    }\r\n}\r\n\r\ncontract ERC721Token is Ownable, IERC165, IERC721, IERC721Metadata, IERC721Enumerable, Initializable {\r\n    string private name_;\r\n    string private symbol_;\r\n    mapping(uint256 => address) private owners_;\r\n    mapping(address => uint256) private balances_;\r\n    mapping(uint256 => address) private tokenApprovals_;\r\n    mapping(address => mapping (address => bool)) private operatorApprovals_;\r\n    mapping(uint256 => string) private tokenURIs_;\r\n    mapping(address => mapping(uint256 => uint256)) private ownedTokens_; // Mapping from owner to list of owned token IDs\r\n    mapping(uint256 => uint256) private ownedTokensIndex_; // Mapping from token ID to index of the owner tokens list\r\n    uint256[] private allTokens_; // Array with all token ids, used for enumeration\r\n    mapping(uint256 => uint256) private allTokensIndex_; // Mapping from token id to position in the allTokens array\r\n    \r\n    constructor() initializer {}\r\n\r\n    function initialize(string memory _name, string memory _symbol, address _owner) public initializer {\r\n        require(_owner != address(0), \"ERC721: owner cannot be zero address\");\r\n        name_ = _name;\r\n        symbol_ = _symbol;\r\n        owner_ = _owner;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    function name() external view virtual override returns (string memory) {\r\n        return name_;\r\n    }\r\n    \r\n    function symbol() external view virtual override returns (string memory) {\r\n        return symbol_;\r\n    }\r\n    \r\n    function tokenURI(uint256 _tokenId) external view virtual override returns (string memory) {\r\n        require(_exists(_tokenId), \"ERC721: URI query for nonexistent token\");\r\n        return tokenURIs_[_tokenId];\r\n    }\r\n    \r\n    function balanceOf(address _account) public view virtual override returns (uint256) {\r\n        return balances_[_account];\r\n    }\r\n    \r\n    function ownerOf(uint256 _tokenId) public view virtual override returns (address) {\r\n        address owner = owners_[_tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n        return owner;\r\n    }\r\n    \r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external payable virtual override {\r\n        _safeTransfer(_from, _to, _tokenId, _data);\r\n    }\r\n    \r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable virtual override {\r\n        _safeTransfer(_from, _to, _tokenId, \"\");\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), _tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n    \r\n    function approve(address _approved, uint256 _tokenId) external payable virtual override {\r\n        address owner = ownerOf(_tokenId);\r\n\r\n        require(_approved != owner, \"ERC721: approval to current owner\");\r\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not owner nor approved for all\");\r\n\r\n        _approve(_approved, _tokenId);\r\n    }\r\n    \r\n    function setApprovalForAll(address _operator, bool _approved) external virtual override {\r\n        require(_operator != _msgSender(), \"ERC721: approve to caller\");\r\n\r\n        operatorApprovals_[_msgSender()][_operator] = _approved;\r\n        emit ApprovalForAll(_msgSender(), _operator, _approved);\r\n    }\r\n    \r\n    function getApproved(uint256 _tokenId) public view virtual override returns (address) {\r\n        require(_exists(_tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n        return tokenApprovals_[_tokenId];\r\n    }\r\n    \r\n    function isApprovedForAll(address _owner, address _operator) public view virtual override returns (bool) {\r\n        return operatorApprovals_[_owner][_operator];\r\n    }\r\n    \r\n    function supportsInterface(bytes4 _interfaceId) external view virtual override returns (bool) {\r\n        return _interfaceId == type(IERC165).interfaceId\r\n            || _interfaceId == type(IERC721).interfaceId\r\n            || _interfaceId == type(IERC721Metadata).interfaceId\r\n            || _interfaceId == type(IERC721Enumerable).interfaceId;\r\n    }\r\n    \r\n    function mintTo(address _recipient, uint256 _tokenId, string calldata _tokenUri) external onlyOwner returns (bool) {\r\n        _safeMint(_recipient, _tokenId);\r\n        _setTokenURI(_tokenId, _tokenUri);\r\n        return true;\r\n    }\r\n\r\n    function burn(uint256 _tokenId) external onlyOwner returns (bool) {\r\n        address owner = ownerOf(_tokenId);\r\n\r\n        _beforeTokenTransfer(owner, address(0), _tokenId);\r\n\r\n        // Clear approvals\r\n        _approve(address(0), _tokenId);\r\n        \r\n        if (bytes(tokenURIs_[_tokenId]).length != 0) {\r\n            delete tokenURIs_[_tokenId];\r\n        }\r\n\r\n        balances_[owner] -= 1;\r\n        delete owners_[_tokenId];\r\n\r\n        emit Transfer(owner, address(0), _tokenId);\r\n        return true;\r\n    }\r\n    \r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) public view virtual override returns (uint256) {\r\n        require(_index < balanceOf(_owner), \"ERC721Enumerable: owner index out of bounds\");\r\n        return ownedTokens_[_owner][_index];\r\n    }\r\n    \r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return allTokens_.length;\r\n    }\r\n    \r\n    function tokenByIndex(uint256 _index) public view virtual override returns (uint256) {\r\n        require(_index < totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n        return allTokens_[_index];\r\n    }\r\n\r\n    function _exists(uint256 _tokenId) internal view virtual returns (bool) {\r\n        return owners_[_tokenId] != address(0);\r\n    }\r\n    \r\n    function _isApprovedOrOwner(address _spender, uint256 _tokenId) internal view virtual returns (bool) {\r\n        require(_exists(_tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ownerOf(_tokenId);\r\n        return (_spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender));\r\n    }\r\n        \r\n    function _safeMint(address _to, uint256 _tokenId) internal virtual {\r\n        _safeMint(_to, _tokenId, \"\");\r\n    }\r\n\r\n    function _safeMint(address _to, uint256 _tokenId, bytes memory _data) internal virtual {\r\n        _mint(_to, _tokenId);\r\n        require(_checkOnERC721Received(address(0), _to, _tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n    \r\n    function _mint(address _to, uint256 _tokenId) internal virtual {\r\n        require(_to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(_tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(address(0), _to, _tokenId);\r\n\r\n        balances_[_to] += 1;\r\n        owners_[_tokenId] = _to;\r\n\r\n        emit Transfer(address(0), _to, _tokenId);\r\n    }\r\n    \r\n    function _setTokenURI(uint256 _tokenId, string memory _tokenURI) internal virtual {\r\n        require(_exists(_tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\r\n        tokenURIs_[_tokenId] = _tokenURI;\r\n    }\r\n    \r\n    function _safeTransfer(address _from, address _to, uint256 _tokenId, bytes memory _data) internal virtual {\r\n        require(_isApprovedOrOwner(_msgSender(), _tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _transfer(_from, _to, _tokenId);\r\n        require(_checkOnERC721Received(_from, _to, _tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    function _checkOnERC721Received(address _from, address _to, uint256 _tokenId, bytes memory _data) internal returns (bool) {\r\n        if (_isContract(_to)) {\r\n            try IERC721Receiver(_to).onERC721Received(_msgSender(), _from, _tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver(_to).onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal virtual {\r\n        require(ownerOf(_tokenId) == _from, \"ERC721: transfer of token that is not own\");\r\n        require(_to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(_from, _to, _tokenId);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), _tokenId);\r\n\r\n        balances_[_from] -= 1;\r\n        balances_[_to] += 1;\r\n        owners_[_tokenId] = _to;\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _approve(address _to, uint256 _tokenId) internal virtual {\r\n        tokenApprovals_[_tokenId] = _to;\r\n        emit Approval(ownerOf(_tokenId), _to, _tokenId);\r\n    }\r\n    \r\n    function _isContract(address _addr) private view returns (bool) {\r\n        uint size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size > 0;\r\n    }\r\n    \r\n    function _beforeTokenTransfer(address _from, address _to, uint256 _tokenId) internal virtual {\r\n        if (_from == address(0)) {\r\n            _addTokenToAllTokensEnumeration(_tokenId);\r\n        } else if (_from != _to) {\r\n            _removeTokenFromOwnerEnumeration(_from, _tokenId);\r\n        }\r\n        if (_to == address(0)) {\r\n            _removeTokenFromAllTokensEnumeration(_tokenId);\r\n        } else if (_to != _from) {\r\n            _addTokenToOwnerEnumeration(_to, _tokenId);\r\n        }\r\n    }\r\n\r\n    function _addTokenToOwnerEnumeration(address _to, uint256 _tokenId) private {\r\n        uint256 length = balanceOf(_to);\r\n        ownedTokens_[_to][length] = _tokenId;\r\n        ownedTokensIndex_[_tokenId] = length;\r\n    }\r\n\r\n    function _addTokenToAllTokensEnumeration(uint256 _tokenId) private {\r\n        allTokensIndex_[_tokenId] = allTokens_.length;\r\n        allTokens_.push(_tokenId);\r\n    }\r\n\r\n    function _removeTokenFromOwnerEnumeration(address _from, uint256 _tokenId) private {\r\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = balanceOf(_from) - 1;\r\n        uint256 tokenIndex = ownedTokensIndex_[_tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = ownedTokens_[_from][lastTokenIndex];\r\n\r\n            ownedTokens_[_from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            ownedTokensIndex_[lastTokenId] = tokenIndex; // Update the moved token's index\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete ownedTokensIndex_[_tokenId];\r\n        delete ownedTokens_[_from][lastTokenIndex];\r\n    }\r\n\r\n    function _removeTokenFromAllTokensEnumeration(uint256 _tokenId) private {\r\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot (swap and pop).\r\n\r\n        uint256 lastTokenIndex = allTokens_.length - 1;\r\n        uint256 tokenIndex = allTokensIndex_[_tokenId];\r\n\r\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n        uint256 lastTokenId = allTokens_[lastTokenIndex];\r\n\r\n        allTokens_[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n        allTokensIndex_[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete allTokensIndex_[_tokenId];\r\n        allTokens_.pop();\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_tokenUri\",\"type\":\"string\"}],\"name\":\"mintTo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC721Token","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://63f83b528a5a67da15181af0c9f42a405cf0cd5d665cfb4f4045d4b32bbc088e"}]}