{"status":"1","message":"OK","result":[{"SourceCode":"// File: ErrorReporter.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\ncontract ErrorReporter {\r\n    /**\r\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\r\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\r\n     */\r\n    event Failure(uint256 error, uint256 info, uint256 detail);\r\n\r\n    enum Error {\r\n        NO_ERROR,\r\n        OPAQUE_ERROR, // To be used when reporting errors from upgradeable contracts; the opaque code should be given as `detail` in the `Failure` event\r\n        UNAUTHORIZED,\r\n        INTEGER_OVERFLOW,\r\n        INTEGER_UNDERFLOW,\r\n        DIVISION_BY_ZERO,\r\n        BAD_INPUT,\r\n        TOKEN_INSUFFICIENT_ALLOWANCE,\r\n        TOKEN_INSUFFICIENT_BALANCE,\r\n        TOKEN_TRANSFER_FAILED,\r\n        MARKET_NOT_SUPPORTED,\r\n        SUPPLY_RATE_CALCULATION_FAILED,\r\n        BORROW_RATE_CALCULATION_FAILED,\r\n        TOKEN_INSUFFICIENT_CASH,\r\n        TOKEN_TRANSFER_OUT_FAILED,\r\n        INSUFFICIENT_LIQUIDITY,\r\n        INSUFFICIENT_BALANCE,\r\n        INVALID_COLLATERAL_RATIO,\r\n        MISSING_ASSET_PRICE,\r\n        EQUITY_INSUFFICIENT_BALANCE,\r\n        INVALID_CLOSE_AMOUNT_REQUESTED,\r\n        ASSET_NOT_PRICED,\r\n        INVALID_LIQUIDATION_DISCOUNT,\r\n        INVALID_COMBINED_RISK_PARAMETERS,\r\n        ZERO_ORACLE_ADDRESS,\r\n        CONTRACT_PAUSED,\r\n        KYC_ADMIN_CHECK_FAILED,\r\n        KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\r\n        KYC_CUSTOMER_VERIFICATION_CHECK_FAILED,\r\n        LIQUIDATOR_CHECK_FAILED,\r\n        LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\r\n        SET_WETH_ADDRESS_ADMIN_CHECK_FAILED,\r\n        WETH_ADDRESS_NOT_SET_ERROR,\r\n        ETHER_AMOUNT_MISMATCH_ERROR\r\n    }\r\n\r\n    /**\r\n     * Note: FailureInfo (but not Error) is kept in alphabetical order\r\n     *       This is because FailureInfo grows significantly faster, and\r\n     *       the order of Error has some meaning, while the order of FailureInfo\r\n     *       is entirely arbitrary.\r\n     */\r\n    enum FailureInfo {\r\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\r\n        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\r\n        BORROW_ACCOUNT_SHORTFALL_PRESENT,\r\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\r\n        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\r\n        BORROW_CONTRACT_PAUSED,\r\n        BORROW_MARKET_NOT_SUPPORTED,\r\n        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\r\n        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\r\n        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\r\n        BORROW_TRANSFER_OUT_FAILED,\r\n        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\r\n        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\r\n        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\r\n        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\r\n        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\r\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\r\n        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\r\n        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\r\n        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\r\n        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\r\n        LIQUIDATE_CONTRACT_PAUSED,\r\n        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\r\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\r\n        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\r\n        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\r\n        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\r\n        LIQUIDATE_FETCH_ASSET_PRICE_FAILED,\r\n        LIQUIDATE_TRANSFER_IN_FAILED,\r\n        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\r\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_CONTRACT_PAUSED,\r\n        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\r\n        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\r\n        REPAY_BORROW_TRANSFER_IN_FAILED,\r\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\r\n        SET_ASSET_PRICE_CHECK_ORACLE,\r\n        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\r\n        SET_ORACLE_OWNER_CHECK,\r\n        SET_ORIGINATION_FEE_OWNER_CHECK,\r\n        SET_PAUSED_OWNER_CHECK,\r\n        SET_PENDING_ADMIN_OWNER_CHECK,\r\n        SET_RISK_PARAMETERS_OWNER_CHECK,\r\n        SET_RISK_PARAMETERS_VALIDATION,\r\n        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        SUPPLY_CONTRACT_PAUSED,\r\n        SUPPLY_MARKET_NOT_SUPPORTED,\r\n        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\r\n        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        SUPPLY_TRANSFER_IN_FAILED,\r\n        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\r\n        SUPPORT_MARKET_FETCH_PRICE_FAILED,\r\n        SUPPORT_MARKET_OWNER_CHECK,\r\n        SUPPORT_MARKET_PRICE_CHECK,\r\n        SUSPEND_MARKET_OWNER_CHECK,\r\n        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\r\n        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\r\n        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\r\n        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\r\n        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\r\n        WITHDRAW_CAPACITY_CALCULATION_FAILED,\r\n        WITHDRAW_CONTRACT_PAUSED,\r\n        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\r\n        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\r\n        WITHDRAW_TRANSFER_OUT_FAILED,\r\n        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE,\r\n        KYC_ADMIN_CHECK_FAILED,\r\n        KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\r\n        KYC_CUSTOMER_VERIFICATION_CHECK_FAILED,\r\n        LIQUIDATOR_CHECK_FAILED,\r\n        LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\r\n        SET_WETH_ADDRESS_ADMIN_CHECK_FAILED,\r\n        WETH_ADDRESS_NOT_SET_ERROR,\r\n        SEND_ETHER_ADMIN_CHECK_FAILED,\r\n        ETHER_AMOUNT_MISMATCH_ERROR\r\n    }\r\n\r\n    /**\r\n     * @dev use this when reporting a known error from the Alkemi Earn Verified or a non-upgradeable collaborator\r\n     */\r\n    function fail(Error err, FailureInfo info) internal returns (uint256) {\r\n        emit Failure(uint256(err), uint256(info), 0);\r\n\r\n        return uint256(err);\r\n    }\r\n\r\n    /**\r\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\r\n     */\r\n    function failOpaque(FailureInfo info, uint256 opaqueError)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        emit Failure(uint256(Error.OPAQUE_ERROR), uint256(info), opaqueError);\r\n\r\n        return uint256(Error.OPAQUE_ERROR);\r\n    }\r\n}\r\n// File: CarefulMath.sol\r\n\r\n// Cloned from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol -> Commit id: 24a0bc2\r\n// and added custom functions related to Alkemi\r\npragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title Careful Math\r\n * @notice Derived from OpenZeppelin's SafeMath library\r\n *         https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol\r\n */\r\ncontract CarefulMath is ErrorReporter {\r\n    /**\r\n     * @dev Multiplies two numbers, returns an error on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (Error, uint256) {\r\n        if (a == 0) {\r\n            return (Error.NO_ERROR, 0);\r\n        }\r\n\r\n        uint256 c = a * b;\r\n\r\n        if (c / a != b) {\r\n            return (Error.INTEGER_OVERFLOW, 0);\r\n        } else {\r\n            return (Error.NO_ERROR, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (Error, uint256) {\r\n        if (b == 0) {\r\n            return (Error.DIVISION_BY_ZERO, 0);\r\n        }\r\n\r\n        return (Error.NO_ERROR, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (Error, uint256) {\r\n        if (b <= a) {\r\n            return (Error.NO_ERROR, a - b);\r\n        } else {\r\n            return (Error.INTEGER_UNDERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, returns an error on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (Error, uint256) {\r\n        uint256 c = a + b;\r\n\r\n        if (c >= a) {\r\n            return (Error.NO_ERROR, c);\r\n        } else {\r\n            return (Error.INTEGER_OVERFLOW, 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev add a and b and then subtract c\r\n     */\r\n    function addThenSub(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 c\r\n    ) internal pure returns (Error, uint256) {\r\n        (Error err0, uint256 sum) = add(a, b);\r\n\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, 0);\r\n        }\r\n\r\n        return sub(sum, c);\r\n    }\r\n}\r\n\r\n// File: Exponential.sol\r\n\r\n// Cloned from https://github.com/compound-finance/compound-money-market/blob/master/contracts/Exponential.sol -> Commit id: 241541a\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\ncontract Exponential is ErrorReporter, CarefulMath {\r\n    // Per https://solidity.readthedocs.io/en/latest/contracts.html#constant-state-variables\r\n    // the optimizer MAY replace the expression 10**18 with its calculated value.\r\n    uint256 constant expScale = 10**18;\r\n\r\n    uint256 constant halfExpScale = expScale / 2;\r\n\r\n    struct Exp {\r\n        uint256 mantissa;\r\n    }\r\n\r\n    uint256 constant mantissaOne = 10**18;\r\n    // Though unused, the below variable cannot be deleted as it will hinder upgradeability\r\n    // Will be cleared during the next compiler version upgrade\r\n    uint256 constant mantissaOneTenth = 10**17;\r\n\r\n    /**\r\n     * @dev Creates an exponential from numerator and denominator values.\r\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\r\n     *            or if `denom` is zero.\r\n     */\r\n    function getExp(uint256 num, uint256 denom)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error err0, uint256 scaledNumerator) = mul(num, expScale);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (Error err1, uint256 rational) = div(scaledNumerator, denom);\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: rational}));\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two exponentials, returning a new exponential.\r\n     */\r\n    function addExp(Exp memory a, Exp memory b)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error error, uint256 result) = add(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two exponentials, returning a new exponential.\r\n     */\r\n    function subExp(Exp memory a, Exp memory b)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error error, uint256 result) = sub(a.mantissa, b.mantissa);\r\n\r\n        return (error, Exp({mantissa: result}));\r\n    }\r\n\r\n    /**\r\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function mulScalar(Exp memory a, uint256 scalar)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error err0, uint256 scaledMantissa) = mul(a.mantissa, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: scaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Divide an Exp by a scalar, returning a new Exp.\r\n     */\r\n    function divScalar(Exp memory a, uint256 scalar)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error err0, uint256 descaledMantissa) = div(a.mantissa, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: descaledMantissa}));\r\n    }\r\n\r\n    /**\r\n     * @dev Divide a scalar by an Exp, returning a new Exp.\r\n     */\r\n    function divScalarByExp(uint256 scalar, Exp divisor)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        /*\r\n            We are doing this as:\r\n            getExp(mul(expScale, scalar), divisor.mantissa)\r\n\r\n            How it works:\r\n            Exp = a / b;\r\n            Scalar = s;\r\n            `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\r\n        */\r\n        (Error err0, uint256 numerator) = mul(expScale, scalar);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n        return getExp(numerator, divisor.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two exponentials, returning a new exponential.\r\n     */\r\n    function mulExp(Exp memory a, Exp memory b)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        (Error err0, uint256 doubleScaledProduct) = mul(a.mantissa, b.mantissa);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}));\r\n        }\r\n\r\n        // We add half the scale before dividing so that we get rounding instead of truncation.\r\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\r\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\r\n        (Error err1, uint256 doubleScaledProductWithHalfScale) = add(\r\n            halfExpScale,\r\n            doubleScaledProduct\r\n        );\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (err1, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (Error err2, uint256 product) = div(\r\n            doubleScaledProductWithHalfScale,\r\n            expScale\r\n        );\r\n        // The only error `div` can return is Error.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\r\n        assert(err2 == Error.NO_ERROR);\r\n\r\n        return (Error.NO_ERROR, Exp({mantissa: product}));\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two exponentials, returning a new exponential.\r\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\r\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\r\n     */\r\n    function divExp(Exp memory a, Exp memory b)\r\n        internal\r\n        pure\r\n        returns (Error, Exp memory)\r\n    {\r\n        return getExp(a.mantissa, b.mantissa);\r\n    }\r\n\r\n    /**\r\n     * @dev Truncates the given exp to a whole number value.\r\n     *      For example, truncate(Exp{mantissa: 15 * (10**18)}) = 15\r\n     */\r\n    function truncate(Exp memory exp) internal pure returns (uint256) {\r\n        // Note: We are not using careful math here as we're performing a division that cannot fail\r\n        return exp.mantissa / expScale;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is less than second Exp.\r\n     */\r\n    function lessThanExp(Exp memory left, Exp memory right)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return left.mantissa < right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if left Exp <= right Exp.\r\n     */\r\n    function lessThanOrEqualExp(Exp memory left, Exp memory right)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return left.mantissa <= right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if first Exp is greater than second Exp.\r\n     */\r\n    function greaterThanExp(Exp memory left, Exp memory right)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        return left.mantissa > right.mantissa;\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if Exp is exactly zero\r\n     */\r\n    function isZeroExp(Exp memory value) internal pure returns (bool) {\r\n        return value.mantissa == 0;\r\n    }\r\n}\r\n// File: AlkemiRateModel.sol\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title  Earn Interest Rate Model\r\n * @author ShiftForex\r\n * @notice See Model here\r\n */\r\n\r\ncontract AlkemiRateModel is Exponential {\r\n    // Assuming avg. block time of 13.3 seconds; can be updated using changeBlocksPerYear() by the admin\r\n    uint256 public blocksPerYear = 2371128;\r\n\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    string public contractName;\r\n\r\n    uint8 private hundred = 100;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"non-owner\");\r\n        _;\r\n    }\r\n\r\n    enum IRError {\r\n        NO_ERROR,\r\n        FAILED_TO_ADD_CASH_PLUS_BORROWS,\r\n        FAILED_TO_GET_EXP,\r\n        FAILED_TO_MUL_PRODUCT_TIMES_BORROW_RATE\r\n    }\r\n\r\n    event OwnerUpdate(address indexed owner, address indexed newOwner);\r\n\r\n    event blocksPerYearUpdated(\r\n        uint256 oldBlocksPerYear,\r\n        uint256 newBlocksPerYear\r\n    );\r\n\r\n    Exp internal SpreadLow;\r\n    Exp internal BreakPointLow;\r\n    Exp internal ReserveLow;\r\n    Exp internal ReserveMid;\r\n    Exp internal SpreadMid;\r\n    Exp internal BreakPointHigh;\r\n    Exp internal ReserveHigh;\r\n    Exp internal SpreadHigh;\r\n\r\n    Exp internal MinRateActual;\r\n    Exp internal HealthyMinURActual;\r\n    Exp internal HealthyMinRateActual;\r\n    Exp internal MaxRateActual;\r\n    Exp internal HealthyMaxURActual;\r\n    Exp internal HealthyMaxRateActual;\r\n\r\n    constructor(\r\n        string memory _contractName,\r\n        uint256 MinRate,\r\n        uint256 HealthyMinUR,\r\n        uint256 HealthyMinRate,\r\n        uint256 HealthyMaxUR,\r\n        uint256 HealthyMaxRate,\r\n        uint256 MaxRate\r\n    ) public {\r\n        // Remember to enter percentage times 100. ex., if it is 2.50%, enter 250\r\n        // Checks for reasonable interest rate parameters\r\n        require(MinRate < MaxRate, \"Min Rate should be lesser than Max Rate\");\r\n        require(\r\n            HealthyMinUR < HealthyMaxUR,\r\n            \"HealthyMinUR should be lesser than HealthyMaxUR\"\r\n        );\r\n        require(\r\n            HealthyMinRate < HealthyMaxRate,\r\n            \"HealthyMinRate should be lesser than HealthyMaxRate\"\r\n        );\r\n        owner = msg.sender;\r\n        changeRates(\r\n            _contractName,\r\n            MinRate,\r\n            HealthyMinUR,\r\n            HealthyMinRate,\r\n            HealthyMaxUR,\r\n            HealthyMaxRate,\r\n            MaxRate\r\n        );\r\n    }\r\n\r\n    function changeRates(\r\n        string memory _contractName,\r\n        uint256 MinRate,\r\n        uint256 HealthyMinUR,\r\n        uint256 HealthyMinRate,\r\n        uint256 HealthyMaxUR,\r\n        uint256 HealthyMaxRate,\r\n        uint256 MaxRate\r\n    ) public onlyOwner {\r\n        // Remember to enter percentage times 100. ex., if it is 2.50%, enter 250 as solidity does not recognize floating point numbers\r\n        // Checks for reasonable interest rate parameters\r\n        require(MinRate < MaxRate, \"Min Rate should be lesser than Max Rate\");\r\n        require(\r\n            HealthyMinUR < HealthyMaxUR,\r\n            \"HealthyMinUR should be lesser than HealthyMaxUR\"\r\n        );\r\n        require(\r\n            HealthyMinRate < HealthyMaxRate,\r\n            \"HealthyMinRate should be lesser than HealthyMaxRate\"\r\n        );\r\n        contractName = _contractName;\r\n        Exp memory temp1;\r\n        Exp memory temp2;\r\n        Exp memory HundredMantissa;\r\n        Error err;\r\n\r\n        (err, HundredMantissa) = getExp(hundred, 1);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n\r\n        // Rates are divided by 1e2 to scale down inputs to actual values\r\n        // Inputs are expressed in percentage times 1e2, so we need to scale it down again by 1e2\r\n        // Resulting values like MinRateActual etc., are represented in 1e20 scale\r\n        // The return values for getSupplyRate() and getBorrowRate() functions are divided by 1e2 at the end to bring it down to 1e18 scale\r\n        (err, MinRateActual) = getExp(MinRate, hundred);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n        (err, HealthyMinURActual) = getExp(HealthyMinUR, hundred);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n        (err, HealthyMinRateActual) = getExp(HealthyMinRate, hundred);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n        (err, MaxRateActual) = getExp(MaxRate, hundred);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n        (err, HealthyMaxURActual) = getExp(HealthyMaxUR, hundred);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n        (err, HealthyMaxRateActual) = getExp(HealthyMaxRate, hundred);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n\r\n        SpreadLow = MinRateActual;\r\n        BreakPointLow = HealthyMinURActual;\r\n        BreakPointHigh = HealthyMaxURActual;\r\n\r\n        // ReserveLow = (HealthyMinRate-SpreadLow)/BreakPointLow;\r\n        (err, temp1) = subExp(HealthyMinRateActual, SpreadLow);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n        (err, ReserveLow) = divExp(temp1, BreakPointLow);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n\r\n        // ReserveMid = (HealthyMaxRate-HealthyMinRate)/(HealthyMaxUR-HealthyMinUR);\r\n        (err, temp1) = subExp(HealthyMaxRateActual, HealthyMinRateActual);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n        (err, temp2) = subExp(HealthyMaxURActual, HealthyMinURActual);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n        (err, ReserveMid) = divExp(temp1, temp2);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n\r\n        // SpreadMid = HealthyMinRate - (ReserveMid * BreakPointLow);\r\n        (err, temp1) = mulExp(ReserveMid, BreakPointLow);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n        (err, SpreadMid) = subExp(HealthyMinRateActual, temp1);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n        require(\r\n            SpreadMid.mantissa >= 0,\r\n            \"Spread Mid cannot be a negative number\"\r\n        );\r\n        // ReserveHigh = (MaxRate - HealthyMaxRate) / (100 - HealthyMaxUR);\r\n        (err, temp1) = subExp(MaxRateActual, HealthyMaxRateActual);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n        (err, temp2) = subExp(HundredMantissa, HealthyMaxURActual);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n        (err, ReserveHigh) = divExp(temp1, temp2);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n\r\n        // SpreadHigh = (ReserveHigh * BreakPointHigh) - HealthyMaxRate;\r\n        (err, temp2) = mulExp(ReserveHigh, BreakPointHigh);\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n        (err, SpreadHigh) = subExp(temp2, HealthyMaxRateActual);\r\n        require(\r\n            SpreadHigh.mantissa >= 0,\r\n            \"Spread High cannot be a negative number\"\r\n        );\r\n        require(err == Error.NO_ERROR, \"Integer Underflow / Overflow\"); // To check for Integer overflow and underflow errors from Exponential.sol\r\n    }\r\n\r\n    function changeBlocksPerYear(uint256 _blocksPerYear) external onlyOwner {\r\n        uint256 oldBlocksPerYear = blocksPerYear;\r\n        blocksPerYear = _blocksPerYear;\r\n        emit blocksPerYearUpdated(oldBlocksPerYear, _blocksPerYear);\r\n    }\r\n\r\n    function transferOwnership(address newOwner_) external onlyOwner {\r\n        require(newOwner_ != owner, \"TransferOwnership: the same owner.\");\r\n        newOwner = newOwner_;\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        require(\r\n            msg.sender == newOwner,\r\n            \"AcceptOwnership: only new owner do this.\"\r\n        );\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0x0);\r\n    }\r\n\r\n    /*\r\n     * @dev Calculates the utilization rate (borrows / (cash + borrows)) as an Exp in 1e18 scale\r\n     */\r\n    function getUtilizationRate(uint256 cash, uint256 borrows)\r\n        internal\r\n        view\r\n        returns (IRError, Exp memory)\r\n    {\r\n        if (borrows == 0) {\r\n            // Utilization rate is zero when there's no borrows\r\n            return (IRError.NO_ERROR, Exp({mantissa: 0}));\r\n        }\r\n\r\n        (Error err0, uint256 cashPlusBorrows) = add(cash, borrows);\r\n        if (err0 != Error.NO_ERROR) {\r\n            return (\r\n                IRError.FAILED_TO_ADD_CASH_PLUS_BORROWS,\r\n                Exp({mantissa: 0})\r\n            );\r\n        }\r\n\r\n        (Error err1, Exp memory utilizationRate) = getExp(\r\n            borrows,\r\n            cashPlusBorrows\r\n        );\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (IRError.FAILED_TO_GET_EXP, Exp({mantissa: 0}));\r\n        }\r\n        (err1, utilizationRate) = mulScalar(utilizationRate, hundred);\r\n        if (err1 != Error.NO_ERROR) {\r\n            return (IRError.FAILED_TO_GET_EXP, Exp({mantissa: 0}));\r\n        }\r\n\r\n        return (IRError.NO_ERROR, utilizationRate);\r\n    }\r\n\r\n    /*\r\n     * @dev Calculates the utilization and borrow rates for use by get{Supply,Borrow}Rate functions\r\n     * Both Utilization Rate and Borrow Rate are returned in 1e18 scale\r\n     */\r\n    function getUtilizationAndAnnualBorrowRate(uint256 cash, uint256 borrows)\r\n        internal\r\n        view\r\n        returns (\r\n            IRError,\r\n            Exp memory,\r\n            Exp memory\r\n        )\r\n    {\r\n        (IRError err0, Exp memory utilizationRate) = getUtilizationRate(\r\n            cash,\r\n            borrows\r\n        );\r\n        if (err0 != IRError.NO_ERROR) {\r\n            return (err0, Exp({mantissa: 0}), Exp({mantissa: 0}));\r\n        }\r\n\r\n        /**\r\n         *  Borrow Rate\r\n         *  0 < UR < 20% :      SpreadLow + UR * ReserveLow\r\n         *  20% <= UR <= 80% :  SpreadMid + UR * ReserveMid\r\n         *  80% < UR :          UR * ReserveHigh - SpreadHigh\r\n         */\r\n\r\n        Error err;\r\n\r\n        uint256 annualBorrowRateScaled;\r\n        Exp memory tempScaled;\r\n        Exp memory tempScaled2;\r\n\r\n        if (utilizationRate.mantissa < BreakPointLow.mantissa) {\r\n            (err, tempScaled) = mulExp(utilizationRate, ReserveLow);\r\n            require(err == Error.NO_ERROR);\r\n            (err, tempScaled2) = addExp(tempScaled, SpreadLow);\r\n            annualBorrowRateScaled = tempScaled2.mantissa;\r\n            require(err == Error.NO_ERROR);\r\n        } else if (utilizationRate.mantissa > BreakPointHigh.mantissa) {\r\n            (err, tempScaled) = mulExp(utilizationRate, ReserveHigh);\r\n            require(err == Error.NO_ERROR);\r\n            // Integer Underflow is handled in sub() function under CarefulMath\r\n            (err, tempScaled2) = subExp(tempScaled, SpreadHigh);\r\n            annualBorrowRateScaled = tempScaled2.mantissa;\r\n            require(err == Error.NO_ERROR);\r\n        } else if (\r\n            utilizationRate.mantissa >= BreakPointLow.mantissa &&\r\n            utilizationRate.mantissa <= BreakPointHigh.mantissa\r\n        ) {\r\n            (err, tempScaled) = mulExp(utilizationRate, ReserveMid);\r\n            require(err == Error.NO_ERROR);\r\n            (err, tempScaled2) = addExp(tempScaled, SpreadMid);\r\n            annualBorrowRateScaled = tempScaled2.mantissa;\r\n            require(err == Error.NO_ERROR);\r\n        }\r\n\r\n        return (\r\n            IRError.NO_ERROR,\r\n            utilizationRate,\r\n            Exp({mantissa: annualBorrowRateScaled})\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current supply interest rate based on the given asset, total cash and total borrows\r\n     * @dev The return value should be scaled by 1e18, thus a return value of\r\n     *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\r\n     * @param _asset The asset to get the interest rate of\r\n     * @param cash The total cash of the asset in the market\r\n     * @param borrows The total borrows of the asset in the market\r\n     * @return Success or failure and the supply interest rate per block scaled by 1e18\r\n     */\r\n    function getSupplyRate(\r\n        address _asset,\r\n        uint256 cash,\r\n        uint256 borrows\r\n    ) public view returns (uint256, uint256) {\r\n        _asset; // pragma ignore unused argument\r\n        (\r\n            IRError err0,\r\n            Exp memory utilizationRate0,\r\n            Exp memory annualBorrowRate\r\n        ) = getUtilizationAndAnnualBorrowRate(cash, borrows);\r\n        if (err0 != IRError.NO_ERROR) {\r\n            return (uint256(err0), 0);\r\n        }\r\n\r\n        /**\r\n         *  Supply Rate\r\n         *  = BorrowRate * utilizationRate * (1 - SpreadLow)\r\n         */\r\n        Exp memory temp1;\r\n        Error err1;\r\n        Exp memory oneMinusSpreadBasisPoints;\r\n        (err1, temp1) = getExp(hundred, 1);\r\n        require(err1 == Error.NO_ERROR);\r\n        (err1, oneMinusSpreadBasisPoints) = subExp(temp1, SpreadLow);\r\n\r\n        // mulScalar only overflows when product is greater than or equal to 2^256.\r\n        // utilization rate's mantissa is a number between [0e18,1e18]. That means that\r\n        // utilizationRate1 is a value between [0e18,8.5e21]. This is strictly less than 2^256.\r\n        require(err1 == Error.NO_ERROR);\r\n\r\n        // Next multiply this product times the borrow rate\r\n        // Borrow rate should be divided by 1e2 to get product at 1e18 scale\r\n        (err1, temp1) = mulExp(\r\n            utilizationRate0,\r\n            Exp({mantissa: annualBorrowRate.mantissa / hundred})\r\n        );\r\n        // If the product of the mantissas for mulExp are both less than 2^256,\r\n        // then this operation will never fail.\r\n        // We know that borrow rate is in the interval [0, 2.25e17] from above.\r\n        // We know that utilizationRate1 is in the interval [0, 9e21] from directly above.\r\n        // As such, the multiplication is in the interval of [0, 2.025e39]. This is strictly\r\n        // less than 2^256 (which is about 10e77).\r\n        require(err1 == Error.NO_ERROR);\r\n\r\n        // oneMinusSpreadBasisPoints i.e.,(1 - SpreadLow) should be divided by 1e2 to get product at 1e18 scale\r\n        (err1, temp1) = mulExp(\r\n            temp1,\r\n            Exp({mantissa: oneMinusSpreadBasisPoints.mantissa / hundred})\r\n        );\r\n        require(err1 == Error.NO_ERROR);\r\n\r\n        // And then divide down by the spread's denominator (basis points divisor)\r\n        // as well as by blocks per year.\r\n        (Error err4, Exp memory supplyRate) = divScalar(temp1, blocksPerYear); // basis points * blocks per year\r\n        // divScalar only fails when divisor is zero. This is clearly not the case.\r\n        require(err4 == Error.NO_ERROR);\r\n\r\n        // Note: supplyRate.mantissa is the rate scaled 1e20 ex., 23%\r\n        // Note: we then divide by 1e2 to scale it down to the expected 1e18 scale, which matches the expected result ex., 0.2300\r\n        return (uint256(IRError.NO_ERROR), supplyRate.mantissa / hundred);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current borrow interest rate based on the given asset, total cash and total borrows\r\n     * @dev The return value should be scaled by 1e18, thus a return value of\r\n     *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\r\n     * @param asset The asset to get the interest rate of\r\n     * @param cash The total cash of the asset in the market\r\n     * @param borrows The total borrows of the asset in the market\r\n     * @return Success or failure and the borrow interest rate per block scaled by 1e18\r\n     */\r\n    function getBorrowRate(\r\n        address asset,\r\n        uint256 cash,\r\n        uint256 borrows\r\n    ) public view returns (uint256, uint256) {\r\n        asset; // pragma ignore unused argument\r\n\r\n        (\r\n            IRError err0,\r\n            ,\r\n            Exp memory annualBorrowRate\r\n        ) = getUtilizationAndAnnualBorrowRate(cash, borrows);\r\n        if (err0 != IRError.NO_ERROR) {\r\n            return (uint256(err0), 0);\r\n        }\r\n\r\n        // And then divide down by blocks per year.\r\n        (Error err1, Exp memory borrowRate) = divScalar(\r\n            annualBorrowRate,\r\n            blocksPerYear\r\n        ); // basis points * blocks per year\r\n        // divScalar only fails when divisor is zero. This is clearly not the case.\r\n        require(err1 == Error.NO_ERROR);\r\n\r\n        // Note: borrowRate.mantissa is the rate scaled 1e20 ex., 23%\r\n        // Note: we then divide by 1e2 to scale it down to the expected 1e18 scale, which matches the expected result ex., 0.2300\r\n        return (uint256(IRError.NO_ERROR), borrowRate.mantissa / hundred);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_contractName\",\"type\":\"string\"},{\"name\":\"MinRate\",\"type\":\"uint256\"},{\"name\":\"HealthyMinUR\",\"type\":\"uint256\"},{\"name\":\"HealthyMinRate\",\"type\":\"uint256\"},{\"name\":\"HealthyMaxUR\",\"type\":\"uint256\"},{\"name\":\"HealthyMaxRate\",\"type\":\"uint256\"},{\"name\":\"MaxRate\",\"type\":\"uint256\"}],\"name\":\"changeRates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_asset\",\"type\":\"address\"},{\"name\":\"cash\",\"type\":\"uint256\"},{\"name\":\"borrows\",\"type\":\"uint256\"}],\"name\":\"getSupplyRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksPerYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blocksPerYear\",\"type\":\"uint256\"}],\"name\":\"changeBlocksPerYear\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"cash\",\"type\":\"uint256\"},{\"name\":\"borrows\",\"type\":\"uint256\"}],\"name\":\"getBorrowRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_contractName\",\"type\":\"string\"},{\"name\":\"MinRate\",\"type\":\"uint256\"},{\"name\":\"HealthyMinUR\",\"type\":\"uint256\"},{\"name\":\"HealthyMinRate\",\"type\":\"uint256\"},{\"name\":\"HealthyMaxUR\",\"type\":\"uint256\"},{\"name\":\"HealthyMaxRate\",\"type\":\"uint256\"},{\"name\":\"MaxRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldBlocksPerYear\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newBlocksPerYear\",\"type\":\"uint256\"}],\"name\":\"blocksPerYearUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"error\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"info\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"detail\",\"type\":\"uint256\"}],\"name\":\"Failure\",\"type\":\"event\"}]","ContractName":"AlkemiRateModel","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000c800000000000000000000000000000000000000000000000000000000000000fa0000000000000000000000000000000000000000000000000000000000001f400000000000000000000000000000000000000000000000000000000000000bb80000000000000000000000000000000000000000000000000000000000001388000000000000000000000000000000000000000000000000000000000000000e4254432052617465204d6f64656c000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"bzzr://f59b571d34c441490c8dbfc17872fe2b99f5ddf734e60e432d5a86fce838c2a3"}]}