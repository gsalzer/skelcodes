{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.12\r\n# @author bulbozaur <alexandrtarelkin92@gmail.com>\r\n# @notice A manager contract for the Balancer Merkle Rewards contract.\r\n\r\n# @license MIT\r\n\r\n\r\ninterface ERC20:\r\n    def allowance(arg0: address, arg1: address) -> uint256: view\r\n    def balanceOf(arg0: address) -> uint256: view\r\n    def approve(_spender: address, _value: uint256) -> bool: nonpayable\r\n    def transfer(_to: address, _value: uint256) -> bool: nonpayable\r\n\r\n\r\ninterface IRewardsContract:\r\n    def seedAllocations(_week: uint256, _merkleRoot: bytes32, _totalAllocation: uint256): nonpayable\r\n\r\n\r\nevent OwnerChanged:\r\n    new_owner: address\r\n\r\n\r\nevent AllocatorChanged:\r\n    new_allocator: address\r\n\r\n\r\nevent Allocation:\r\n    amount: uint256\r\n\r\n\r\nevent RewardsLimitChanged:\r\n    new_limit: uint256\r\n\r\n\r\nevent ERC20TokenRecovered:\r\n    token: address\r\n    amount: uint256\r\n    recipient: address\r\n\r\n\r\nevent Paused:\r\n    actor: address\r\n\r\n\r\nevent Unpaused:\r\n    actor: address\r\n\r\n\r\nevent AllocationsLimitChanged:\r\n    new_limit: uint256\r\n\r\n\r\nowner: public(address)\r\nallocator: public(address)\r\n\r\nrewards_contract: constant(address) = 0x884226c9f7b7205f607922E0431419276a64CF8f\r\nrewards_token: constant(address) = 0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32\r\n\r\nallocations_limit: public(uint256)\r\nrewards_limit_per_period: public(uint256)\r\nrewards_period_duration: constant(uint256) = 604800  # 3600 * 24 * 7\r\nlast_accounted_period_date: public(uint256)\r\n\r\nis_paused: public(bool)\r\n\r\n\r\n@external\r\ndef __init__(\r\n    _owner: address,\r\n    _allocator: address,\r\n    _start_date: uint256\r\n):\r\n    self.owner = _owner\r\n    self.allocator = _allocator\r\n\r\n    self.allocations_limit = 0\r\n    self.is_paused = False\r\n\r\n    self.rewards_limit_per_period = 25000 * 10**18\r\n    self.last_accounted_period_date = _start_date - rewards_period_duration\r\n\r\n    log OwnerChanged(self.owner)\r\n    log AllocatorChanged(self.allocator)\r\n\r\n\r\n@internal\r\n@view\r\ndef _periods_since_last_update(_end_date: uint256) -> uint256:\r\n    return (_end_date - self.last_accounted_period_date) / rewards_period_duration\r\n\r\n\r\n@internal\r\n@view\r\ndef _available_allocations() -> uint256:\r\n    if self.is_paused == True:\r\n        return self.allocations_limit\r\n\r\n    unaccounted_periods: uint256 = self._periods_since_last_update(block.timestamp)\r\n    return self.allocations_limit + unaccounted_periods * self.rewards_limit_per_period\r\n\r\n\r\n@external\r\n@view\r\ndef available_allocations() -> uint256:\r\n    \"\"\"\r\n    @notice \r\n        Returns current allocations limit for Merkle Rewards contract \r\n        as sum of merkle contract accounted limit\r\n        and calculated allocations amount for unaccounted period \r\n        since last allocations limit update\r\n    \"\"\"\r\n    return self._available_allocations()\r\n\r\n\r\n@internal\r\ndef _update_last_accounted_period_date():\r\n    \"\"\"\r\n    @notice \r\n        Updates last_accounted_period_date to timestamp of current period\r\n    \"\"\"\r\n    periods: uint256 = self._periods_since_last_update(block.timestamp)\r\n    self.last_accounted_period_date = self.last_accounted_period_date + rewards_period_duration * periods\r\n\r\n\r\n@internal\r\ndef _change_allocations_limit(_new_allocations_limit: uint256):\r\n    \"\"\"\r\n    @notice Changes the allocations limit for Merkle Rewadrds contact. \r\n    \"\"\"\r\n    self.allocations_limit = _new_allocations_limit\r\n\r\n    # Reseting unaccounted allocations allowance\r\n    self._update_last_accounted_period_date()\r\n    \r\n    log AllocationsLimitChanged(_new_allocations_limit)\r\n\r\n\r\n@internal\r\ndef _update_allocations_limit():\r\n    \"\"\"\r\n    @notice Updates allowance based on current calculated allocations limit\r\n    \"\"\"\r\n    new_allocations_limit: uint256 = self._available_allocations()\r\n    self._change_allocations_limit(new_allocations_limit)\r\n\r\n\r\n@external\r\ndef change_allocations_limit(_new_allocations_limit: uint256):\r\n    \"\"\"\r\n    @notice Changes the allocations limit for Merkle Rewadrds contact. Can only be called by owner.\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"manager: not permitted\"\r\n    self._change_allocations_limit(_new_allocations_limit)\r\n\r\n\r\n@external\r\ndef seed_allocations(_week: uint256, _merkle_root: bytes32, _amount: uint256):\r\n    \"\"\"\r\n    @notice\r\n        Wraps seedAllocations(_week: uint256, _merkle_root: bytes32, _amount: uint256)\r\n        of Merkle rewards contract with amount limited by available_allocations()\r\n    \"\"\"\r\n    assert msg.sender == self.allocator, \"manager: not permitted\"\r\n    assert self.is_paused == False, \"manager: contract is paused\"\r\n\r\n    self._update_allocations_limit()\r\n\r\n    assert ERC20(rewards_token).balanceOf(self) >= _amount, \"manager: reward token balance is low\"\r\n    assert self.allocations_limit >= _amount, \"manager: not enought amount approved\"\r\n\r\n    self.allocations_limit -= _amount\r\n\r\n    ERC20(rewards_token).approve(rewards_contract, _amount)\r\n\r\n    IRewardsContract(rewards_contract).seedAllocations(_week, _merkle_root, _amount)\r\n\r\n    log Allocation(_amount)\r\n\r\n\r\n@external\r\ndef change_rewards_limit(_new_limit: uint256):\r\n    \"\"\"\r\n    @notice \r\n        Updates all finished periods since last allowance update\r\n        and changes the amount of available allocations increasing\r\n        per reward period.\r\n        Can only be called by the current owner.\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"manager: not permitted\"\r\n\r\n    self._update_allocations_limit()\r\n    self.rewards_limit_per_period = _new_limit\r\n    \r\n    log RewardsLimitChanged(self.rewards_limit_per_period)\r\n\r\n\r\n@external\r\ndef pause():\r\n    \"\"\"\r\n    @notice\r\n        Pause allocations increasing and rejects seedAllocations calling\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"manager: not permitted\"\r\n    \r\n    self._update_allocations_limit()\r\n    self.is_paused = True\r\n\r\n    log Paused(msg.sender)\r\n\r\n\r\n@external\r\ndef unpause():\r\n    \"\"\"\r\n    @notice\r\n        Unpause allocations increasing and allows seedAllocations calling\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"manager: not permitted\"\r\n    \r\n    self._update_last_accounted_period_date()\r\n    self.is_paused = False\r\n\r\n    log Unpaused(msg.sender)\r\n\r\n\r\n@internal\r\n@view\r\ndef _out_of_funding_date() -> uint256:\r\n    \"\"\"\r\n    @notice \r\n        Expected date of the manager to run out of funds at the current rate. \r\n        All the allocated funds would be allowed for spending by Merkle Reward contract.\r\n    \"\"\"\r\n    rewards_balance: uint256 = ERC20(rewards_token).balanceOf(self)\r\n    accounted_allocations_limit: uint256 = self.allocations_limit\r\n\r\n    # Handling accounted_allocations_limit and rewards_balance diff underflow exception\r\n    if (rewards_balance < accounted_allocations_limit):\r\n        unaccounted_periods: uint256 = (accounted_allocations_limit - rewards_balance) / self.rewards_limit_per_period\r\n        # incrementing unaccounted periods count to get the end of last period instead of the begining\r\n        unaccounted_periods += 1\r\n        return self.last_accounted_period_date - unaccounted_periods * rewards_period_duration\r\n    \r\n    unaccounted_periods: uint256 = (rewards_balance - accounted_allocations_limit) / self.rewards_limit_per_period\r\n    # incrementing unaccounted periods count to get the end of last period instead of the begining\r\n    unaccounted_periods += 1\r\n    return self.last_accounted_period_date + unaccounted_periods * rewards_period_duration\r\n\r\n\r\n@external\r\n@view\r\ndef out_of_funding_date() -> uint256:\r\n    return self._out_of_funding_date()\r\n\r\n\r\n@external\r\n@view\r\ndef periodFinish() -> uint256:\r\n    return self._out_of_funding_date()\r\n\r\n\r\n@external\r\ndef transfer_ownership(_to: address):\r\n    \"\"\"\r\n    @notice Changes the contract owner. Can only be called by the current owner.\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"manager: not permitted\"\r\n    self.owner = _to\r\n    log OwnerChanged(self.owner)\r\n\r\n\r\n@external\r\ndef change_allocator(_new_allocator: address):\r\n    \"\"\"\r\n    @notice Changes the allocator. Can only be called by the current owner.\r\n    \"\"\"\r\n    assert msg.sender == self.owner, \"manager: not permitted\"\r\n    self.allocator = _new_allocator\r\n    log AllocatorChanged(self.allocator)\r\n\r\n\r\n@external\r\ndef recover_erc20(_token: address, _amount: uint256):\r\n    \"\"\"\r\n    @notice\r\n        Transfers specified amount of the given ERC20 token from self\r\n        to the owner. Can only be called by the owner.\r\n    \"\"\"\r\n    owner: address = self.owner\r\n    assert msg.sender == owner, \"manager: not permitted\"\r\n\r\n    if ERC20(_token).balanceOf(self) >= _amount:\r\n        assert ERC20(_token).transfer(owner, _amount), \"manager: token transfer failed\"\r\n        log ERC20TokenRecovered(_token, _amount, owner)","ABI":"[{\"name\":\"OwnerChanged\",\"inputs\":[{\"name\":\"new_owner\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AllocatorChanged\",\"inputs\":[{\"name\":\"new_allocator\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Allocation\",\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RewardsLimitChanged\",\"inputs\":[{\"name\":\"new_limit\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ERC20TokenRecovered\",\"inputs\":[{\"name\":\"token\",\"type\":\"address\",\"indexed\":false},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"recipient\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Paused\",\"inputs\":[{\"name\":\"actor\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Unpaused\",\"inputs\":[{\"name\":\"actor\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AllocationsLimitChanged\",\"inputs\":[{\"name\":\"new_limit\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_allocator\",\"type\":\"address\"},{\"name\":\"_start_date\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"available_allocations\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":15165},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"change_allocations_limit\",\"inputs\":[{\"name\":\"_new_allocations_limit\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":126029},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"seed_allocations\",\"inputs\":[{\"name\":\"_week\",\"type\":\"uint256\"},{\"name\":\"_merkle_root\",\"type\":\"bytes32\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":332463},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"change_rewards_limit\",\"inputs\":[{\"name\":\"_new_limit\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":318030},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"pause\",\"inputs\":[],\"outputs\":[],\"gas\":315956},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"unpause\",\"inputs\":[],\"outputs\":[],\"gas\":67346},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"out_of_funding_date\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":15980},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"periodFinish\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":16010},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer_ownership\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41258},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"change_allocator\",\"inputs\":[{\"name\":\"_new_allocator\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41288},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"recover_erc20\",\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":10386},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2718},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allocator\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2748},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allocations_limit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2778},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rewards_limit_per_period\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2808},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_accounted_period_date\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2838},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_paused\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":2868}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.12","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"0000000000000000000000003e40d73eb977dc6a537af587d48316fee66e9c8c000000000000000000000000adda10ac6195d272543c6ed3a4a0d7fdd25aa4fa000000000000000000000000000000000000000000000000000000006119aa80","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}