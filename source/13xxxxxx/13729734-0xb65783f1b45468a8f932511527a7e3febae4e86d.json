{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Decorator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\nimport {IGorfDecorator} from './IGorfDecorator.sol';\\r\\nimport {IGorfDescriptor} from './IGorfDescriptor.sol';\\r\\nimport {IGorfSeeder} from './IGorfSeeder.sol';\\r\\nimport {MultiPartRLEToSVG} from './MultiPartRLEToSVG.sol';\\r\\nimport {Base64} from 'base64-sol/base64.sol';\\r\\nimport {Ownable} from '@openzeppelin/contracts/access/Ownable.sol';\\r\\n\\r\\ncontract Decorator is IGorfDecorator, Ownable {\\r\\n    IGorfDescriptor public descriptor;\\r\\n\\r\\n    // Noun Backgrounds\\r\\n    string[] public backgroundMapping;\\r\\n\\r\\n    // Noun Bodies\\r\\n    string[] public bodyMapping;\\r\\n\\r\\n    // Noun Accessories\\r\\n    string[] public accessoryMapping;\\r\\n\\r\\n    // Noun Heads\\r\\n    string[] public headMapping;\\r\\n\\r\\n    // Noun Glasses\\r\\n    string[] public glassesMapping;\\r\\n\\r\\n    // Noun Color Palettes (Index => Hex Colors)\\r\\n    mapping(uint8 => string[]) public palettes;\\r\\n\\r\\n    constructor() {\\r\\n        descriptor = IGorfDescriptor(0x0Cfdb3Ba1694c2bb2CFACB0339ad7b1Ae5932B63);\\r\\n    }\\r\\n\\r\\n    function addManyBackgroundsToMap(string[] calldata _backgrounds) external onlyOwner {\\r\\n        for (uint256 i = 0; i < _backgrounds.length; i++) {\\r\\n            _addBackgroundToMap(_backgrounds[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addManyBodiesToMap(string[] calldata _bodies) external onlyOwner {\\r\\n        for (uint256 i = 0; i < _bodies.length; i++) {\\r\\n            _addBodyToMap(_bodies[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addManyAccessoriesToMap(string[] calldata _accessories) external onlyOwner {\\r\\n        for (uint256 i = 0; i < _accessories.length; i++) {\\r\\n            _addAccessoryToMap(_accessories[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addManyHeadsToMap(string[] calldata _heads) external onlyOwner {\\r\\n        for (uint256 i = 0; i < _heads.length; i++) {\\r\\n            _addHeadToMap(_heads[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addManyGlassesToMap(string[] calldata _glasses) external onlyOwner {\\r\\n        for (uint256 i = 0; i < _glasses.length; i++) {\\r\\n            _addGlassesToMap(_glasses[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Given a name, description, and seed, construct a base64 encoded data URI.\\r\\n     */\\r\\n    function genericDataURI(string memory name, string memory description, IGorfSeeder.Seed memory seed) public view override returns (string memory) {\\r\\n        MultiPartRLEToSVG.SVGParams memory params = MultiPartRLEToSVG.SVGParams({\\r\\n            parts: _getPartsForSeed(seed),\\r\\n            background: descriptor.backgrounds(seed.background)\\r\\n        });\\r\\n\\r\\n        string memory image = Base64.encode(bytes(MultiPartRLEToSVG.generateSVG(params, palettes)));\\r\\n        string memory attributes = _generateAttributes(seed);\\r\\n\\r\\n        // prettier-ignore\\r\\n        return string(\\r\\n            abi.encodePacked(\\r\\n                'data:application/json;base64,',\\r\\n                Base64.encode(\\r\\n                    bytes(\\r\\n                        abi.encodePacked('{\\\"name\\\":\\\"', name, '\\\", \\\"description\\\":\\\"', description, '\\\", \\\"image\\\": \\\"', 'data:image/svg+xml;base64,', image, '\\\", \\\"attributes\\\": [', attributes, ']}')\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _generateAttributes(IGorfSeeder.Seed memory seed) internal view returns (string memory) {\\r\\n        return string(\\r\\n            abi.encodePacked(\\r\\n                '{\\\"trait_type\\\": \\\"Background\\\", \\\"value\\\": \\\"', backgroundMapping[seed.background], '\\\"},',\\r\\n                '{\\\"trait_type\\\": \\\"Body\\\", \\\"value\\\": \\\"', bodyMapping[seed.body], '\\\"},',\\r\\n                '{\\\"trait_type\\\": \\\"Accessory\\\", \\\"value\\\": \\\"', accessoryMapping[seed.accessory], '\\\"},',\\r\\n                '{\\\"trait_type\\\": \\\"Head\\\", \\\"value\\\": \\\"', headMapping[seed.head], '\\\"},',\\r\\n                '{\\\"trait_type\\\": \\\"Glasses\\\", \\\"value\\\": \\\"', glassesMapping[seed.glasses], '\\\"}'\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _addBackgroundToMap(string calldata _background) internal {\\r\\n        backgroundMapping.push(_background);\\r\\n    }\\r\\n\\r\\n    function _addBodyToMap(string calldata _body) internal {\\r\\n        bodyMapping.push(_body);\\r\\n    }\\r\\n\\r\\n    function _addAccessoryToMap(string calldata _accessory) internal {\\r\\n        accessoryMapping.push(_accessory);\\r\\n    }\\r\\n\\r\\n    function _addHeadToMap(string calldata _head) internal {\\r\\n        headMapping.push(_head);\\r\\n    }\\r\\n\\r\\n    function _addGlassesToMap(string calldata _glasses) internal {\\r\\n        glassesMapping.push(_glasses);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add colors to a color palette.\\r\\n     * @dev This function can only be called by the owner.\\r\\n     */\\r\\n    function addManyColorsToPalette(uint8 paletteIndex, string[] calldata newColors) external onlyOwner {\\r\\n        require(palettes[paletteIndex].length + newColors.length <= 256, 'Palettes can only hold 256 colors');\\r\\n        for (uint256 i = 0; i < newColors.length; i++) {\\r\\n            _addColorToPalette(paletteIndex, newColors[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add a single color to a color palette.\\r\\n     * @dev This function can only be called by the owner.\\r\\n     */\\r\\n    function addColorToPalette(uint8 _paletteIndex, string calldata _color) external onlyOwner {\\r\\n        require(palettes[_paletteIndex].length <= 255, 'Palettes can only hold 256 colors');\\r\\n        _addColorToPalette(_paletteIndex, _color);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add a single color to a color palette.\\r\\n     */\\r\\n    function _addColorToPalette(uint8 _paletteIndex, string calldata _color) internal {\\r\\n        palettes[_paletteIndex].push(_color);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get all Noun parts for the passed `seed`.\\r\\n     */\\r\\n    function _getPartsForSeed(IGorfSeeder.Seed memory seed) internal view returns (bytes[] memory) {\\r\\n        bytes[] memory _parts = new bytes[](4);\\r\\n        _parts[0] = descriptor.bodies(seed.body);\\r\\n        _parts[1] = descriptor.accessories(seed.accessory);\\r\\n        _parts[2] = descriptor.heads(seed.head);\\r\\n        _parts[3] = descriptor.glasses(seed.glasses);\\r\\n        return _parts;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/IGorfDecorator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\nimport { IGorfSeeder } from './IGorfSeeder.sol';\\r\\n\\r\\ninterface IGorfDecorator {\\r\\n    function genericDataURI(\\r\\n        string calldata name,\\r\\n        string calldata description,\\r\\n        IGorfSeeder.Seed memory seed\\r\\n    ) external view returns (string memory);\\r\\n}\"\r\n    },\r\n    \"contracts/IGorfDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\nimport { IGorfSeeder } from './IGorfSeeder.sol';\\r\\n\\r\\ninterface IGorfDescriptor {\\r\\n    event PartsLocked();\\r\\n\\r\\n    event DataURIToggled(bool enabled);\\r\\n\\r\\n    event BaseURIUpdated(string baseURI);\\r\\n\\r\\n    function arePartsLocked() external returns (bool);\\r\\n\\r\\n    function isDataURIEnabled() external returns (bool);\\r\\n\\r\\n    function baseURI() external returns (string memory);\\r\\n\\r\\n    function palettes(uint8 paletteIndex, uint256 colorIndex) external view returns (string memory);\\r\\n\\r\\n    function backgrounds(uint256 index) external view returns (string memory);\\r\\n\\r\\n    function bodies(uint256 index) external view returns (bytes memory);\\r\\n\\r\\n    function accessories(uint256 index) external view returns (bytes memory);\\r\\n\\r\\n    function heads(uint256 index) external view returns (bytes memory);\\r\\n\\r\\n    function glasses(uint256 index) external view returns (bytes memory);\\r\\n\\r\\n    function backgroundCount() external view returns (uint256);\\r\\n\\r\\n    function bodyCount() external view returns (uint256);\\r\\n\\r\\n    function accessoryCount() external view returns (uint256);\\r\\n\\r\\n    function headCount() external view returns (uint256);\\r\\n\\r\\n    function glassesCount() external view returns (uint256);\\r\\n\\r\\n    function addManyColorsToPalette(uint8 paletteIndex, string[] calldata newColors) external;\\r\\n\\r\\n    function addManyBackgrounds(string[] calldata backgrounds) external;\\r\\n\\r\\n    function addManyBodies(bytes[] calldata bodies) external;\\r\\n\\r\\n    function addManyAccessories(bytes[] calldata accessories) external;\\r\\n\\r\\n    function addManyHeads(bytes[] calldata heads) external;\\r\\n\\r\\n    function addManyGlasses(bytes[] calldata glasses) external;\\r\\n\\r\\n    function addColorToPalette(uint8 paletteIndex, string calldata color) external;\\r\\n\\r\\n    function addBackground(string calldata background) external;\\r\\n\\r\\n    function addBody(bytes calldata body) external;\\r\\n\\r\\n    function addAccessory(bytes calldata accessory) external;\\r\\n\\r\\n    function addHead(bytes calldata head) external;\\r\\n\\r\\n    function addGlasses(bytes calldata glasses) external;\\r\\n\\r\\n    function lockParts() external;\\r\\n\\r\\n    function toggleDataURIEnabled() external;\\r\\n\\r\\n    function setBaseURI(string calldata baseURI) external;\\r\\n\\r\\n    function tokenURI(uint256 tokenId, IGorfSeeder.Seed memory seed) external view returns (string memory);\\r\\n\\r\\n    function dataURI(uint256 tokenId, IGorfSeeder.Seed memory seed) external view returns (string memory);\\r\\n\\r\\n    function genericDataURI(\\r\\n        string calldata name,\\r\\n        string calldata description,\\r\\n        IGorfSeeder.Seed memory seed\\r\\n    ) external view returns (string memory);\\r\\n\\r\\n    function generateSVGImage(IGorfSeeder.Seed memory seed) external view returns (string memory);\\r\\n}\"\r\n    },\r\n    \"contracts/IGorfSeeder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\nimport { IGorfDescriptor } from './IGorfDescriptor.sol';\\r\\n\\r\\ninterface IGorfSeeder {\\r\\n    struct Seed {\\r\\n        uint48 background;\\r\\n        uint48 body;\\r\\n        uint48 accessory;\\r\\n        uint48 head;\\r\\n        uint48 glasses;\\r\\n    }\\r\\n\\r\\n    function generateSeed(uint256 nounId, IGorfDescriptor descriptor) external view returns (Seed memory);\\r\\n}\"\r\n    },\r\n    \"contracts/MultiPartRLEToSVG.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\nlibrary MultiPartRLEToSVG {\\r\\n    struct SVGParams {\\r\\n        bytes[] parts;\\r\\n        string background;\\r\\n    }\\r\\n\\r\\n    struct ContentBounds {\\r\\n        uint8 top;\\r\\n        uint8 right;\\r\\n        uint8 bottom;\\r\\n        uint8 left;\\r\\n    }\\r\\n\\r\\n    struct Rect {\\r\\n        uint8 length;\\r\\n        uint8 colorIndex;\\r\\n    }\\r\\n\\r\\n    struct DecodedImage {\\r\\n        uint8 paletteIndex;\\r\\n        ContentBounds bounds;\\r\\n        uint256 width;\\r\\n        Rect[] rects;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Given RLE image parts and color palettes, merge to generate a single SVG image.\\r\\n     */\\r\\n    function generateSVG(SVGParams memory params, mapping(uint8 => string[]) storage palettes) internal view returns (string memory svg) {\\r\\n        // prettier-ignore\\r\\n        return string(\\r\\n            abi.encodePacked(\\r\\n                '<svg width=\\\"320\\\" height=\\\"320\\\" viewBox=\\\"0 0 320 320\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" shape-rendering=\\\"crispEdges\\\">',\\r\\n                '<rect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"#', params.background, '\\\" />',\\r\\n                _generateSVGRects(params, palettes),\\r\\n                '</svg>'\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Given RLE image parts and color palettes, generate SVG rects.\\r\\n     */\\r\\n    // prettier-ignore\\r\\n    function _generateSVGRects(SVGParams memory params, mapping(uint8 => string[]) storage palettes) private view returns (string memory svg) {\\r\\n        string[33] memory lookup = [\\r\\n            '0', '10', '20', '30', '40', '50', '60', '70',\\r\\n            '80', '90', '100', '110', '120', '130', '140', '150',\\r\\n            '160', '170', '180', '190', '200', '210', '220', '230',\\r\\n            '240', '250', '260', '270', '280', '290', '300', '310',\\r\\n            '320'\\r\\n        ];\\r\\n\\r\\n        string memory rects;\\r\\n        for (uint8 p = 0; p < params.parts.length; p++) {\\r\\n            DecodedImage memory image = _decodeRLEImage(params.parts[p]);\\r\\n            string[] storage palette = palettes[image.paletteIndex];\\r\\n            uint256 currentX = image.bounds.left;\\r\\n            uint256 currentY = image.bounds.top;\\r\\n            uint256 cursor;\\r\\n            string[16] memory buffer;\\r\\n\\r\\n            string memory part;\\r\\n            for (uint256 i = 0; i < image.rects.length; i++) {\\r\\n                Rect memory rect = image.rects[i];\\r\\n                if (rect.colorIndex != 0) {\\r\\n                    buffer[cursor] = lookup[rect.length];\\r\\n                    buffer[cursor + 1] = lookup[33-currentX-rect.length];\\r\\n                    buffer[cursor + 2] = lookup[currentY];\\r\\n                    buffer[cursor + 3] = palette[rect.colorIndex];\\r\\n\\r\\n                    cursor += 4;\\r\\n\\r\\n                    if (cursor >= 16) {\\r\\n                        part = string(abi.encodePacked(part, _getChunk(cursor, buffer)));\\r\\n                        cursor = 0;\\r\\n                    }\\r\\n                }\\r\\n\\r\\n                currentX += rect.length;\\r\\n                if (currentX - image.bounds.left == image.width) {\\r\\n                    currentX = image.bounds.left;\\r\\n                    currentY++;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            if (cursor != 0) {\\r\\n                part = string(abi.encodePacked(part, _getChunk(cursor, buffer)));\\r\\n            }\\r\\n            rects = string(abi.encodePacked(rects, part));\\r\\n        }\\r\\n        return rects;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return a string that consists of all ellipse in the provided `buffer`.\\r\\n     */\\r\\n    // prettier-ignore\\r\\n    function _getChunk(uint256 cursor, string[16] memory buffer) private pure returns (string memory) {\\r\\n        string memory chunk;\\r\\n        for (uint256 i = 0; i < cursor; i += 4) {\\r\\n            chunk = string(\\r\\n                abi.encodePacked(\\r\\n                    chunk,\\r\\n                    '<rect width=\\\"', buffer[i], '\\\" height=\\\"10\\\" x=\\\"', buffer[i + 1], '\\\" y=\\\"', buffer[i + 2], '\\\" fill=\\\"#', buffer[i + 3], '\\\" />'\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n        return chunk;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Decode a single RLE compressed image into a `DecodedImage`.\\r\\n     */\\r\\n    function _decodeRLEImage(bytes memory image) private pure returns (DecodedImage memory) {\\r\\n        uint8 paletteIndex = uint8(image[0]);\\r\\n        ContentBounds memory bounds = ContentBounds({\\r\\n            top : uint8(image[1]),\\r\\n            right : uint8(image[2]),\\r\\n            bottom : uint8(image[3]),\\r\\n            left : uint8(image[4])\\r\\n        });\\r\\n        uint256 width = bounds.right - bounds.left;\\r\\n\\r\\n        uint256 cursor;\\r\\n        Rect[] memory rects = new Rect[]((image.length - 5) / 2);\\r\\n        for (uint256 i = 5; i < image.length; i += 2) {\\r\\n            rects[cursor] = Rect({length : uint8(image[i]), colorIndex : uint8(image[i + 1])});\\r\\n            cursor++;\\r\\n        }\\r\\n        return DecodedImage({paletteIndex : paletteIndex, bounds : bounds, width : width, rects : rects});\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accessoryMapping\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_color\",\"type\":\"string\"}],\"name\":\"addColorToPalette\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_accessories\",\"type\":\"string[]\"}],\"name\":\"addManyAccessoriesToMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_backgrounds\",\"type\":\"string[]\"}],\"name\":\"addManyBackgroundsToMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_bodies\",\"type\":\"string[]\"}],\"name\":\"addManyBodiesToMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"paletteIndex\",\"type\":\"uint8\"},{\"internalType\":\"string[]\",\"name\":\"newColors\",\"type\":\"string[]\"}],\"name\":\"addManyColorsToPalette\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_glasses\",\"type\":\"string[]\"}],\"name\":\"addManyGlassesToMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_heads\",\"type\":\"string[]\"}],\"name\":\"addManyHeadsToMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"backgroundMapping\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bodyMapping\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"descriptor\",\"outputs\":[{\"internalType\":\"contract IGorfDescriptor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"background\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"body\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"accessory\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"head\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"glasses\",\"type\":\"uint48\"}],\"internalType\":\"struct IGorfSeeder.Seed\",\"name\":\"seed\",\"type\":\"tuple\"}],\"name\":\"genericDataURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"glassesMapping\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"headMapping\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"palettes\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Decorator","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}