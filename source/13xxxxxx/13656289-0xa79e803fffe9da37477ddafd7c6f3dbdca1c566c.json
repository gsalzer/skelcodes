{"status":"1","message":"OK","result":[{"SourceCode":"# @version 0.2.16\r\n# @author banteg\r\n# @notice Calculate voting power from productive YFI\r\nfrom vyper.interfaces import ERC20\r\n\r\nstruct VotingBalances:\r\n    wallet: uint256\r\n    vault: uint256\r\n    bancor: uint256\r\n    balancer: uint256\r\n    uniswap: uint256\r\n    sushiswap: uint256\r\n    makerdao: uint256\r\n    unit: uint256\r\n    instadapp: uint256\r\n\r\n# yearn\r\n\r\nyfi: constant(address) = 0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e\r\nregistry: constant(address) = 0x50c1a2eA0a861A967D9d0FFE2AE4012c2E053804\r\n\r\ninterface Registry:\r\n    def numVaults(token: address) -> uint256: view\r\n    def vaults(token: address, n: uint256) -> address: view\r\n\r\ninterface Vault:\r\n    def pricePerShare() -> uint256: view\r\n\r\n\r\n# makerdao\r\n\r\nproxy_registry: constant(address) = 0x4678f0a6958e4D2Bc4F1BAF7Bc52E8F3564f3fE4\r\ncdp_manager: constant(address) = 0x5ef30b9986345249bc32d8928B7ee64DE9435E39\r\nvat: constant(address) = 0x35D1b3F3D7966A1DFe207aa4514C12a259A0492B\r\n\r\nstruct List:\r\n    prev: uint256\r\n    next: uint256\r\n\r\nstruct Urn:\r\n    ink: uint256\r\n    art: uint256\r\n\r\ninterface DSProxyRegistry:\r\n    def proxies(user: address) -> address: view\r\n\r\ninterface DssCdpManager:\r\n    def count(user: address) -> uint256: view\r\n    def first(user: address) -> uint256: view\r\n    def list(cdp: uint256) -> List: view\r\n    def ilks(cdp: uint256) -> bytes32: view\r\n    def urns(cdp: uint256) -> address: view\r\n\r\ninterface Vat:\r\n    def urns(ilk: bytes32, user: address) -> Urn: view\r\n\r\n\r\n# bancor\r\n\r\nbancor: constant(address) = 0xf5FAB5DBD2f3bf675dE4cB76517d4767013cfB55\r\n\r\nstruct ProtectedLiquidity:\r\n    provider: address\r\n    poolToken: address\r\n    reserveToken: address\r\n    poolAmount: uint256\r\n    reserveAmount: uint256\r\n    reserveRateN: uint256\r\n    reserveRateD: uint256\r\n    time: uint256\r\n\r\ninterface Bancor:\r\n    def protectedLiquidityCount(provider: address) -> uint256: view\r\n    def protectedLiquidityId(provider: address, index: uint256) -> uint256: view\r\n    def protectedLiquidity(_id: uint256) -> ProtectedLiquidity: view\r\n\r\n\r\n# sushi\r\n\r\nmasterchef: constant(address) = 0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd\r\nsushiswap: constant(address) = 0x088ee5007C98a9677165D78dD2109AE4a3D04d0C\r\nuniswap: constant(address) = 0x2fDbAdf3C4D5A8666Bc06645B8358ab803996E28\r\n\r\nstruct UserInfo:\r\n    amount: uint256\r\n    rewardDebt: uint256\r\n\r\ninterface MasterChef:\r\n    def userInfo(pid: uint256, user: address) -> UserInfo: view\r\n\r\n\r\n# unit\r\n\r\nunit: constant(address) = 0xb1cFF81b9305166ff1EFc49A129ad2AfCd7BCf19\r\n\r\ninterface Unit:\r\n    def collaterals(token: address, user: address) -> uint256: view\r\n\r\n\r\n# balancer v2\r\n\r\nbalancer_v2: constant(address) = 0xBA12222222228d8Ba445958a75a0704d566BF2C8\r\n\r\nstruct PoolTokenInfo:\r\n    cash: uint256\r\n    managed: uint256\r\n    lastChangeBlock: uint256\r\n    assetManager: address\r\n\r\ninterface BalancerVault:\r\n    def getPool(pool_id: bytes32) -> (address, uint256): view\r\n    def getPoolTokenInfo(pool_id: bytes32, token: address) -> PoolTokenInfo: view\r\n\r\n\r\n# instadapp\r\n\r\ninsta_list: constant(address) = 0x4c8a1BEb8a87765788946D6B19C6C6355194AbEb\r\n\r\nstruct UserLink:\r\n    first: uint256\r\n    last: uint256\r\n    count: uint256\r\n\r\ninterface InstaList:\r\n    def userLink(user: address) -> UserLink: view\r\n\r\n\r\n@view\r\n@internal\r\ndef makerdao_collateral(user: address) -> uint256:\r\n    yfi_a: bytes32 = 0x5946492d41000000000000000000000000000000000000000000000000000000\r\n    proxy: address = DSProxyRegistry(proxy_registry).proxies(user)\r\n    if proxy == ZERO_ADDRESS:\r\n        proxy = user\r\n    cdp: uint256 = DssCdpManager(cdp_manager).first(proxy)\r\n    urn: address = ZERO_ADDRESS\r\n    total: uint256 = 0\r\n    for i in range(100):\r\n        if cdp == 0:\r\n            break\r\n        if DssCdpManager(cdp_manager).ilks(cdp) == yfi_a:\r\n            urn = DssCdpManager(cdp_manager).urns(cdp)\r\n            total += Vat(vat).urns(yfi_a, urn).ink\r\n        cdp = DssCdpManager(cdp_manager).list(cdp).next\r\n    return total\r\n\r\n\r\n@view\r\n@internal\r\ndef lp_balance(pool: address, user: address) -> uint256:\r\n    return ERC20(yfi).balanceOf(pool) * ERC20(pool).balanceOf(user) / ERC20(pool).totalSupply()\r\n\r\n\r\n@view\r\n@internal\r\ndef sushiswap_balance(user: address) -> uint256:\r\n    # yfi balance of slp * slp in masterchef / slp total supply\r\n    staked: uint256 = MasterChef(masterchef).userInfo(11, user).amount + ERC20(sushiswap).balanceOf(user)\r\n    return ERC20(yfi).balanceOf(sushiswap) * staked / ERC20(sushiswap).totalSupply()\r\n\r\n\r\n@view\r\n@internal\r\ndef vault_balance(user: address) -> uint256:\r\n    total: uint256 = 0\r\n    count: uint256 = Registry(registry).numVaults(yfi)\r\n    for i in range(100):\r\n        if i == count:\r\n            break\r\n        vault: address = Registry(registry).vaults(yfi, i)\r\n        total += ERC20(vault).balanceOf(user) * Vault(vault).pricePerShare() / 10 ** 18\r\n    return total\r\n\r\n\r\n@view\r\n@internal\r\ndef yfi_in_bancor(user: address) -> uint256:\r\n    total: uint256 = 0\r\n    id: uint256 = 0\r\n    count: uint256 = Bancor(bancor).protectedLiquidityCount(user)\r\n    liquidity: ProtectedLiquidity = empty(ProtectedLiquidity)\r\n    for i in range(100):\r\n        if i == count:\r\n            break\r\n        id = Bancor(bancor).protectedLiquidityId(user, i)\r\n        liquidity = Bancor(bancor).protectedLiquidity(id)\r\n        if liquidity.reserveToken == yfi:\r\n            total += liquidity.reserveAmount\r\n    return total\r\n\r\n\r\n@view\r\n@internal\r\ndef yfi_in_balancer_v2(user: address) -> uint256:\r\n    pools: bytes32[3] = [\r\n        0x01abc00e86c7e258823b9a055fd62ca6cf61a16300010000000000000000003b,\r\n        0xf2b7794b89ea4fd2abfe66dcb6529a27c03d429e0002000000000000000000b0,\r\n        0x186084ff790c65088ba694df11758fae4943ee9e000200000000000000000013,\r\n    ]\r\n    total: uint256 = 0\r\n    for pool_id in pools:\r\n        pool: address = BalancerVault(balancer_v2).getPool(pool_id)[0]\r\n        cash: uint256 = BalancerVault(balancer_v2).getPoolTokenInfo(pool_id, yfi).cash\r\n        total += cash * ERC20(pool).balanceOf(user) / ERC20(pool).totalSupply()\r\n    return total\r\n\r\n\r\n@view\r\n@internal\r\ndef instadapp_balance(user: address) -> uint256:\r\n    link: UserLink = InstaList(insta_list).userLink(user)\r\n    if link.count == 0:\r\n        return 0\r\n    current: uint256 = link.first\r\n    total: uint256 = 0\r\n    for i in range(100):\r\n        result: Bytes[32] = raw_call(\r\n            insta_list,\r\n            concat(method_id('accountAddr(uint64)'), convert(current, bytes32)),\r\n            max_outsize=32,\r\n            is_static_call=True,\r\n        )\r\n        account: address = convert(convert(result, bytes32), address)\r\n        total += ERC20(yfi).balanceOf(account)\r\n        total += self.makerdao_collateral(account)\r\n        if current == link.last:\r\n            break\r\n        # read next id from linked list\r\n        result_2: Bytes[64] = raw_call(\r\n            insta_list,\r\n            concat(method_id('userList(address,uint64)'), convert(user, bytes32), convert(current, bytes32)),\r\n            max_outsize=64,\r\n            is_static_call=True,\r\n        )\r\n        current = convert(convert(slice(result_2, 32, 32), bytes32), uint256)\r\n    \r\n    return total\r\n\r\n\r\n@view\r\n@internal\r\ndef _voting_balances(user: address) -> VotingBalances:\r\n    return VotingBalances({\r\n        wallet: ERC20(yfi).balanceOf(user),\r\n        vault: self.vault_balance(user),\r\n        bancor: self.yfi_in_bancor(user),\r\n        balancer: self.yfi_in_balancer_v2(user),\r\n        uniswap: self.lp_balance(uniswap, user),\r\n        sushiswap: self.sushiswap_balance(user),\r\n        makerdao: self.makerdao_collateral(user),\r\n        unit: Unit(unit).collaterals(yfi, user),\r\n        instadapp: self.instadapp_balance(user),\r\n    })\r\n\r\n\r\n@view\r\n@external\r\ndef balanceOf(user: address) -> uint256:\r\n    bal: VotingBalances = self._voting_balances(user)\r\n    return (\r\n        bal.wallet\r\n        + bal.vault\r\n        + bal.bancor\r\n        + bal.balancer\r\n        + bal.uniswap\r\n        + bal.sushiswap\r\n        + bal.makerdao\r\n        + bal.unit\r\n        + bal.instadapp\r\n    )\r\n\r\n\r\n@view\r\n@external\r\ndef voting_balances(user: address) -> VotingBalances:\r\n    return self._voting_balances(user)","ABI":"[{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":435579619},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"voting_balances\",\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"wallet\",\"type\":\"uint256\"},{\"name\":\"vault\",\"type\":\"uint256\"},{\"name\":\"bancor\",\"type\":\"uint256\"},{\"name\":\"balancer\",\"type\":\"uint256\"},{\"name\":\"uniswap\",\"type\":\"uint256\"},{\"name\":\"sushiswap\",\"type\":\"uint256\"},{\"name\":\"makerdao\",\"type\":\"uint256\"},{\"name\":\"unit\",\"type\":\"uint256\"},{\"name\":\"instadapp\",\"type\":\"uint256\"}],\"gas\":435578926}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.16","OptimizationUsed":"0","Runs":"0","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}