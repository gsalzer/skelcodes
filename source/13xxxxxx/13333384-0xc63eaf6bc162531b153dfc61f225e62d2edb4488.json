{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DEI/Pools/DEIPoolLibrary.sol\": {\r\n      \"content\": \"// Be name Khoda\\n// Bime Abolfazl\\n\\n// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\ncontract DEIPoolLibrary {\\n\\n    // Constants for various precisions\\n    uint256 private constant PRICE_PRECISION = 1e6;\\n\\n    constructor() {}\\n\\n    // ================ Structs ================\\n    // Needed to lower stack size\\n    struct MintFD_Params {\\n        uint256 deus_price_usd; \\n        uint256 col_price_usd;\\n        uint256 collateral_amount;\\n        uint256 col_ratio;\\n    }\\n\\n    struct BuybackDEUS_Params {\\n        uint256 excess_collateral_dollar_value_d18;\\n        uint256 deus_price_usd;\\n        uint256 col_price_usd;\\n        uint256 DEUS_amount;\\n    }\\n\\n    // ================ Functions ================\\n\\n    function calcMint1t1DEI(uint256 col_price, uint256 collateral_amount_d18) public pure returns (uint256) {\\n        return (collateral_amount_d18 * col_price) / (1e6);\\n    }\\n\\n    function calcMintAlgorithmicDEI(uint256 deus_price_usd, uint256 deus_amount_d18) public pure returns (uint256) {\\n        return (deus_amount_d18 * deus_price_usd) / (1e6);\\n    }\\n\\n    // Must be internal because of the struct\\n    function calcMintFractionalDEI(MintFD_Params memory params) public pure returns (uint256, uint256) {\\n        // Since solidity truncates division, every division operation must be the last operation in the equation to ensure minimum error\\n        // The contract must check the proper ratio was sent to mint DEI. We do this by seeing the minimum mintable DEI based on each amount \\n        uint256 c_dollar_value_d18;\\n        \\n        // Scoping for stack concerns\\n        {    \\n            // USD amounts of the collateral and the DEUS\\n            c_dollar_value_d18 = (params.collateral_amount * params.col_price_usd) / (1e6);\\n\\n        }\\n        uint calculated_deus_dollar_value_d18 = ((c_dollar_value_d18 * (1e6)) / params.col_ratio) - c_dollar_value_d18;\\n\\n        uint calculated_deus_needed = (calculated_deus_dollar_value_d18 * (1e6)) / params.deus_price_usd;\\n\\n        return (\\n            c_dollar_value_d18 + calculated_deus_dollar_value_d18,\\n            calculated_deus_needed\\n        );\\n    }\\n\\n    function calcRedeem1t1DEI(uint256 col_price_usd, uint256 DEI_amount) public pure returns (uint256) {\\n        return (DEI_amount * (1e6)) / col_price_usd;\\n    }\\n\\n    // Must be internal because of the struct\\n    function calcBuyBackDEUS(BuybackDEUS_Params memory params) public pure returns (uint256) {\\n        // If the total collateral value is higher than the amount required at the current collateral ratio then buy back up to the possible DEUS with the desired collateral\\n        require(params.excess_collateral_dollar_value_d18 > 0, \\\"No excess collateral to buy back!\\\");\\n\\n        // Make sure not to take more than is available\\n        uint256 deus_dollar_value_d18 = (params.DEUS_amount * (params.deus_price_usd)) / (1e6);\\n        require(deus_dollar_value_d18 <= params.excess_collateral_dollar_value_d18, \\\"You are trying to buy back more than the excess!\\\");\\n\\n        // Get the equivalent amount of collateral based on the market value of DEUS provided \\n        uint256 collateral_equivalent_d18 = (deus_dollar_value_d18 * (1e6)) / params.col_price_usd;\\n        //collateral_equivalent_d18 = collateral_equivalent_d18.sub((collateral_equivalent_d18.mul(params.buyback_fee)).div(1e6));\\n\\n        return collateral_equivalent_d18;\\n\\n    }\\n\\n\\n    // Returns value of collateral that must increase to reach recollateralization target (if 0 means no recollateralization)\\n    function recollateralizeAmount(uint256 total_supply, uint256 global_collateral_ratio, uint256 global_collat_value) public pure returns (uint256) {\\n        uint256 target_collat_value = (total_supply * global_collateral_ratio) / (1e6); // We want 18 decimals of precision so divide by 1e6; total_supply is 1e18 and global_collateral_ratio is 1e6\\n        // Subtract the current value of collateral from the target value needed, if higher than 0 then system needs to recollateralize\\n        return target_collat_value - global_collat_value; // If recollateralization is not needed, throws a subtraction underflow\\n        // return(recollateralization_left);\\n    }\\n\\n    function calcRecollateralizeDEIInner(\\n        uint256 collateral_amount, \\n        uint256 col_price,\\n        uint256 global_collat_value,\\n        uint256 dei_total_supply,\\n        uint256 global_collateral_ratio\\n    ) public pure returns (uint256, uint256) {\\n        uint256 collat_value_attempted = (collateral_amount * col_price) / (1e6);\\n        uint256 effective_collateral_ratio = (global_collat_value * (1e6)) / dei_total_supply; //returns it in 1e6\\n        uint256 recollat_possible = (global_collateral_ratio * dei_total_supply - (dei_total_supply * effective_collateral_ratio)) / (1e6);\\n\\n        uint256 amount_to_recollat;\\n        if(collat_value_attempted <= recollat_possible){\\n            amount_to_recollat = collat_value_attempted;\\n        } else {\\n            amount_to_recollat = recollat_possible;\\n        }\\n\\n        return ((amount_to_recollat * (1e6)) / col_price, amount_to_recollat);\\n\\n    }\\n\\n}\\n\\n//Dar panah khoda\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"excess_collateral_dollar_value_d18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deus_price_usd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"col_price_usd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DEUS_amount\",\"type\":\"uint256\"}],\"internalType\":\"struct DEIPoolLibrary.BuybackDEUS_Params\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"calcBuyBackDEUS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"col_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral_amount_d18\",\"type\":\"uint256\"}],\"name\":\"calcMint1t1DEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deus_price_usd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deus_amount_d18\",\"type\":\"uint256\"}],\"name\":\"calcMintAlgorithmicDEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deus_price_usd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"col_price_usd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"col_ratio\",\"type\":\"uint256\"}],\"internalType\":\"struct DEIPoolLibrary.MintFD_Params\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"calcMintFractionalDEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateral_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"col_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"global_collat_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dei_total_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"global_collateral_ratio\",\"type\":\"uint256\"}],\"name\":\"calcRecollateralizeDEIInner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"col_price_usd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DEI_amount\",\"type\":\"uint256\"}],\"name\":\"calcRedeem1t1DEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"total_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"global_collateral_ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"global_collat_value\",\"type\":\"uint256\"}],\"name\":\"recollateralizeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"DEIPoolLibrary","CompilerVersion":"v0.8.8+commit.dddeac2f","OptimizationUsed":"1","Runs":"100000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}