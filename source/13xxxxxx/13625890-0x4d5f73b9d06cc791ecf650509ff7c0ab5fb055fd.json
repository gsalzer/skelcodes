{"status":"1","message":"OK","result":[{"SourceCode":"{\"DummyOwnerService.sol\":{\"content\":\"pragma solidity 0.8.3;\\n\\nimport \\\"./ProjectOwnerServiceInterface.sol\\\";\\n\\ncontract DummyOwnerService is ProjectOwnerServiceInterface {\\n\\n    function getProjectOwner(address _address) external override view returns(address) {\\n        return 0xA0b3bDe4f4c86438BEE13673647a9616ffDE0496; // KG address\\n    }\\n    \\n    function getProjectFeeInWei(address _address) external override view returns(uint256) {\\n        return 1000000000000000; // 0,001 eth\\n    }\\n\\n    function isProjectRegistered(address _address) external override view returns(bool) {\\n        return true;\\n    }\\n\\n    function isProjectOwnerService() external override view returns(bool){\\n        return true;\\n    }\\n\\n}\"},\"ERC721.sol\":{\"content\":\"pragma solidity 0.8.3;\\n\\ninterface ERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\\n/// @title ERC-721 Non-Fungible Token Standard\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\\ninterface ERC721 is ERC165  {\\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\\n    ///  may be created and assigned without emitting Transfer. At the time of\\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\n\\n    /// @dev This emits when the approved address for an NFT is changed or\\n    ///  reaffirmed. The zero address indicates there is no approved address.\\n    ///  When a Transfer event emits, this also indicates that the approved\\n    ///  address for that NFT (if any) is reset to none.\\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\n\\n    /// @dev This emits when an operator is enabled or disabled for an owner.\\n    ///  The operator can manage all NFTs of the owner.\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n    /// @notice Count all NFTs assigned to an owner\\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\\n    ///  function throws for queries about the zero address.\\n    /// @param _owner An address for whom to query the balance\\n    /// @return The number of NFTs owned by `_owner`, possibly zero\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    /// @notice Find the owner of an NFT\\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\\n    ///  about them do throw.\\n    /// @param _tokenId The identifier for an NFT\\n    /// @return The address of the owner of the NFT\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\n    ///  checks if `_to` is a smart contract (code size \\u003e 0). If so, it calls\\n    ///  `onERC721Received` on `_to` and throws if the return value is not\\n    ///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    /// @param data Additional data with no specified format, sent in call to `_to`\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external payable;\\n\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\n    /// @dev This works identically to the other function with an extra data parameter,\\n    ///  except this function just sets data to \\\"\\\".\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n    ///  THEY MAY BE PERMANENTLY LOST\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\n    ///  `_tokenId` is not a valid NFT.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n\\n    /// @notice Change or reaffirm the approved address for an NFT\\n    /// @dev The zero address indicates there is no approved address.\\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\n    ///  operator of the current owner.\\n    /// @param _approved The new approved NFT controller\\n    /// @param _tokenId The NFT to approve\\n    function approve(address _approved, uint256 _tokenId) external payable;\\n\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n    ///  all of `msg.sender`\\u0027s assets\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\n    ///  multiple operators per owner.\\n    /// @param _operator Address to add to the set of authorized operators\\n    /// @param _approved True if the operator is approved, false to revoke approval\\n    function setApprovalForAll(address _operator, bool _approved) external;\\n\\n    /// @notice Get the approved address for a single NFT\\n    /// @dev Throws if `_tokenId` is not a valid NFT.\\n    /// @param _tokenId The NFT to find the approved address for\\n    /// @return The approved address for this NFT, or the zero address if there is none\\n    function getApproved(uint256 _tokenId) external view returns (address);\\n\\n    /// @notice Query if an address is an authorized operator for another address\\n    /// @param _owner The address that owns the NFTs\\n    /// @param _operator The address that acts on behalf of the owner\\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n}\"},\"ERC721Map.sol\":{\"content\":\"pragma solidity 0.8.3;\\n\\nimport \\\"./Withdrawable.sol\\\";\\nimport \\\"./ERC721.sol\\\";\\n\\ncontract ERC721Map is Withdrawable {\\n\\n    event ERC721NameSet(address indexed _address, uint256 indexed _tokenId, string _name);\\n    event AddressBanned(address indexed _address);\\n    event AddressUnbanned(address indexed _address);\\n\\n    // All added addresses are ERC721\\n    mapping(address =\\u003e mapping(uint256 =\\u003e string)) contractToMap;\\n\\n    bool public isPaused;\\n\\n    constructor() public {\\n        isPaused = false;\\n    }\\n\\n    // Banned owners \\n    mapping (address =\\u003e bool) public bannedAddresses;\\n\\n    function isBanned(address _address) external view returns(bool){\\n        return bannedAddresses[_address];\\n    }\\n\\n    /**\\n    * Banning the address will make the contract ignore all the records \\n    * that blocked address owns. This blocks NFT owners NOT contract addresses. \\n     */\\n    function ban(address _address) public onlyOwner {\\n        bannedAddresses[_address] = true;\\n        emit AddressBanned(_address);\\n    }\\n\\n    function unban(address _address) public onlyOwner {\\n        bannedAddresses[_address] = false;\\n        emit AddressUnbanned(_address);\\n    }\\n\\n    /**\\n    * When contract is paused it\\u0027s impossible to set a name. We leave a space here to migrate to a new \\n    * contract and block current contract from writting to it while making the read operations \\n    * possible. \\n    */\\n    function setIsPaused(bool _isPaused) public onlyOwner {\\n        isPaused = _isPaused;\\n    }\\n\\n    function _setTokenName(address _address, uint256 _tokenId, string memory _nftName) internal {\\n        ERC721 nft = ERC721(_address);\\n\\n        require(!isPaused);\\n        require(nft.supportsInterface(0x80ac58cd));\\n        require(nft.ownerOf(_tokenId) == msg.sender);\\n\\n        contractToMap[_address][_tokenId] = _nftName;\\n        emit ERC721NameSet(_address, _tokenId, _nftName);\\n    }\\n\\n    function getTokenName(address _address, uint256 _tokenId) external view returns(string memory) {\\n        ERC721 nft = ERC721(_address);\\n        require(nft.supportsInterface(0x80ac58cd));\\n        require(!this.isBanned(nft.ownerOf(_tokenId)));\\n\\n        return contractToMap[_address][_tokenId];\\n    }\\n\\n    /**\\n    * For testing purposes, it\\u0027s not really required. You may test if your contract \\n    * is compatible with our service. \\n    *\\n    * @return true if contract is supported. Throws an exception otherwise. \\n    */\\n    function isContractSupported(address _address) external view returns (bool) {\\n            ERC721 nft = ERC721(_address);\\n\\n            // 0x80ac58cd is ERC721 \\n            return nft.supportsInterface(0x80ac58cd);\\n    }\\n\\n}\"},\"ERC721NameService.sol\":{\"content\":\"pragma solidity 0.8.3;\\n\\nimport \\\"./ERC721Map.sol\\\";\\nimport \\\"./ProjectOwnerServiceInterface.sol\\\";\\n\\ncontract ERC721NameService is ERC721Map {\\n\\n    // Fee in wei for the name service\\n    uint256 public baseFee;\\n\\n    address public ownerServiceAddress;\\n\\n    constructor() public {\\n        baseFee = 0;\\n    }\\n\\n    function setBaseFee(uint256 _fee) public onlyOwner {\\n        baseFee = _fee;\\n    }\\n\\n    function setOwnerService(address _address) public onlyOwner {\\n        if(_address == address(0x0)) {\\n            ownerServiceAddress = address(0x0);\\n            return;\\n        }\\n\\n        ProjectOwnerServiceInterface service = ProjectOwnerServiceInterface(_address);\\n        require(service.isProjectOwnerService());\\n\\n        ownerServiceAddress = _address;\\n    }\\n    \\n    function getProjectFeeInWei(address _address) public view returns(uint256) {\\n        if(ownerServiceAddress != address(0x0)) {\\n            ProjectOwnerServiceInterface ownerService = ProjectOwnerServiceInterface(ownerServiceAddress);\\n            if(ownerService.isProjectRegistered(_address)) {\\n                return ownerService.getProjectFeeInWei(_address);\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    function setTokenName(address _address, uint256 _tokenId, string memory _nftName) public payable {\\n        uint256 projectFee = getProjectFeeInWei(_address);\\n        uint256 totalFee = projectFee + baseFee;\\n        require(msg.value \\u003e= totalFee);\\n        \\n        uint256 ourFee = totalFee - projectFee;\\n\\n        if(projectFee \\u003e 0) {\\n            ProjectOwnerServiceInterface ownerService = ProjectOwnerServiceInterface(ownerServiceAddress);\\n            address projectOwner = ownerService.getProjectOwner(_address);\\n            addPendingWithdrawal(projectOwner, projectFee);\\n        }\\n\\n        addPendingWithdrawal(owner, ourFee);\\n        _setTokenName(_address, _tokenId, _nftName);\\n    }\\n\\n}\"},\"Ownable.sol\":{\"content\":\"pragma solidity 0.8.3;\\n\\n/**\\n * @title Ownable\\n * @dev The Ownable contract has an owner address, and provides basic authorization control\\n * functions, this simplifies the implementation of \\\"user permissions\\\".\\n */\\nabstract contract Ownable {\\n  address public owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n   * account.\\n   */\\n  constructor() {\\n    owner = msg.sender;\\n  }\\n\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(msg.sender == owner);\\n    _;\\n  }\\n\\n\\n  /**\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n   * @param newOwner The address to transfer ownership to.\\n   */\\n  function transferOwnership(address newOwner) public onlyOwner {\\n    require(newOwner != address(0));\\n    emit OwnershipTransferred(owner, newOwner);\\n    owner = newOwner;\\n  }\\n\\n}\\n\"},\"ProjectOwnerServiceInterface.sol\":{\"content\":\"pragma solidity 0.8.3;\\n\\ninterface ProjectOwnerServiceInterface {\\n\\n    function getProjectOwner(address _address) external view returns(address);\\n    \\n    function getProjectFeeInWei(address _address) external view returns(uint256);\\n\\n    function isProjectRegistered(address _address) external view returns(bool);\\n\\n    function isProjectOwnerService() external view returns(bool);\\n\\n}\"},\"Withdrawable.sol\":{\"content\":\"pragma solidity 0.8.3;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract that holds pending withdrawals. Responsible for withdrawals.\\n */\\ncontract Withdrawable is Ownable {\\n\\n    mapping(address =\\u003e uint) private pendingWithdrawals;\\n\\n    event Withdrawal(address indexed receiver, uint amount);\\n    event BalanceChanged(address indexed _address, uint oldBalance, uint newBalance);\\n\\n    /**\\n    * Returns amount of wei that given address is able to withdraw.\\n    */\\n    function getPendingWithdrawal(address _address) public view returns (uint) {\\n        return pendingWithdrawals[_address];\\n    }\\n\\n    /**\\n    * Add pending withdrawal for an address.\\n    */\\n    function addPendingWithdrawal(address _address, uint _amount) internal {\\n        require(_address != address(0x0));\\n\\n        uint oldBalance = pendingWithdrawals[_address];\\n        pendingWithdrawals[_address] += _amount;\\n\\n        emit BalanceChanged(_address, oldBalance, oldBalance + _amount);\\n    }\\n\\n    /**\\n    * Withdraws all pending withdrawals.\\n    */\\n    function withdraw() external {\\n        uint amount = getPendingWithdrawal(msg.sender);\\n        require(amount \\u003e 0);\\n\\n        pendingWithdrawals[msg.sender] = 0;\\n        payable(msg.sender).transfer(amount);\\n\\n        emit Withdrawal(msg.sender, amount);\\n        emit BalanceChanged(msg.sender, amount, 0);\\n    }\\n\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"AddressBanned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"AddressUnbanned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"BalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"ERC721NameSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"ban\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bannedAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getPendingWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getProjectFeeInWei\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isBanned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isContractSupported\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerServiceAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setBaseFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isPaused\",\"type\":\"bool\"}],\"name\":\"setIsPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setOwnerService\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_nftName\",\"type\":\"string\"}],\"name\":\"setTokenName\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"unban\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ERC721NameService","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0db56c2e336e7f3e55281c81ae91ded7bec0177e57289fac53b63c5b6a9dfcae"}]}