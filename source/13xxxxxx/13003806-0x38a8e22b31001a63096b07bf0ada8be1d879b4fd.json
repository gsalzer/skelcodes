{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);\r\n}\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 energy.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n}\r\n\r\nabstract contract ERC20 {\r\n    function totalSupply() public view virtual returns (uint256);\r\n\r\n    function balanceOf(address who) public view virtual returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) public virtual returns (bool);\r\n\r\n    function allowance(address owner, address spender) public view virtual returns (uint256);\r\n\r\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\r\n\r\n    function approve(address spender, uint256 value) public virtual returns (bool);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\nabstract contract ERC721 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    // interface\r\n    function balanceOf(address _owner) public view virtual returns (uint256);\r\n\r\n    function ownerOf(uint256 _tokenId) public view virtual returns (address);\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) virtual public;\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) virtual public;\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) virtual public;\r\n\r\n    function approve(address _approved, uint256 _tokenId) virtual public;\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) virtual public;\r\n\r\n    function getApproved(uint256 _tokenId) public view virtual returns (address);\r\n\r\n    function isApprovedForAll(address _owner, address _operator) public view virtual returns (bool);\r\n}\r\n\r\ncontract AuctionEngineV6 is ERC721TokenReceiver, ERC165 {\r\n    modifier ethAuction(uint256 auctionIndex) {\r\n        require(isETHAuction(auctionIndex), \"auction only use eth\");\r\n        _;\r\n    }\r\n\r\n    modifier erc20Auction(uint256 auctionIndex) {\r\n        require(!isETHAuction(auctionIndex), \"auction only use erc20\");\r\n        _;\r\n    }\r\n\r\n    using SafeMath for uint256;\r\n    event AuctionCreated(uint256 _index, address _creator, address _asset, uint256 _assetID);\r\n    event AuctionBid(uint256 _index, address _bidder, uint256 amount);\r\n    event ClaimTokens(uint256 auctionIndex, address claimer, uint256 amount);\r\n    event ClaimAsset(uint256 auctionIndex, address claimer);\r\n    enum Status {pending, active, finished}\r\n    struct Auction {\r\n        address assetAddress;\r\n        uint256 assetId;\r\n        uint256 startTime;\r\n        uint256 minPrice;\r\n        uint256 endTime;\r\n        uint256 currentBidAmount;\r\n        address currentBidOwner;\r\n        uint256 bidCount;\r\n        uint256 instantBuyPrice;\r\n        bool finished;\r\n        bool isWonBidSent;\r\n        address erc20tokenAddress; //If we prefer to accept erc20 token (like USDT) instead of eth;\r\n        address creator;\r\n        mapping(address => uint) pendingReturns;\r\n    }\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    uint numAuctions;\r\n    //Auction[] private auctions;\r\n    mapping (uint256 => Auction) auctions;\r\n\r\n    function createAuction(\r\n        address _assetAddress,\r\n        uint256 _assetId,\r\n        uint256 _startPrice,\r\n        uint256 _startTime,\r\n        uint256 _duration,\r\n        uint256 _instantBuyPrice,\r\n        address _erc20tokenAddress\r\n    ) public returns (uint256) {\r\n        require(ERC165(_assetAddress).supportsInterface(_INTERFACE_ID_ERC721), \"Not valid ERC721 asset\");\r\n        ERC721 asset = ERC721(_assetAddress);\r\n        asset.safeTransferFrom(msg.sender, address(this), _assetId, \"\");\r\n        if (_startTime == 0) {\r\n            _startTime = block.timestamp;\r\n        }\r\n        require(_startTime >= block.timestamp, \"Start time should be in future\");\r\n        require(_duration > 0, \"Duration should be positive\");\r\n\r\n\tnumAuctions++;\r\n\tAuction storage a = auctions[numAuctions];\r\n        a.assetAddress = _assetAddress;\r\n        a.assetId = _assetId;\r\n        a.startTime = _startTime;\r\n        a.endTime = _startTime.add(_duration);\r\n        a.minPrice = _startPrice;\r\n        a.currentBidAmount = 0;\r\n        a.currentBidOwner = msg.sender; //If no one binds, creator will be able to claim back the asset.\r\n        a.bidCount = 0;\r\n        a.instantBuyPrice = _instantBuyPrice;\r\n        a.finished = false;\r\n        a.creator = msg.sender;\r\n        a.isWonBidSent = false;\r\n        a.erc20tokenAddress= _erc20tokenAddress;\r\n        uint256 index = numAuctions;\r\n        emit AuctionCreated(index, msg.sender, _assetAddress, _assetId);\r\n        return index;\r\n    }\r\n\r\n    function isETHAuction(uint256 auctionIndex) public view returns (bool) {\r\n        Auction storage auction = auctions[auctionIndex];\r\n        return auction.erc20tokenAddress == address(0);\r\n    }\r\n\r\n    function bidETH(uint256 auctionIndex) public payable ethAuction(auctionIndex) {\r\n        _bid(auctionIndex, msg.value);\r\n    }\r\n\r\n    function bidERC20(uint256 auctionIndex, uint256 amount) public erc20Auction(auctionIndex) {\r\n        _bid(auctionIndex, amount);\r\n        Auction storage auction = auctions[auctionIndex];\r\n        ERC20 token = ERC20(auction.erc20tokenAddress);\r\n        require(token.transferFrom(msg.sender, address(this), amount));\r\n    }\r\n\r\n    function _bid(uint256 auctionIndex, uint256 amount) internal {\r\n        Auction storage auction = auctions[auctionIndex];\r\n        require(amount >= auction.minPrice, \"Value should be not smaller than start price\");\r\n        require(amount > auction.currentBidAmount, \"Value should be bigger the current bid\");\r\n\r\n        if (auction.currentBidAmount != 0) {\r\n            auction.pendingReturns[auction.currentBidOwner] += auction.currentBidAmount;\r\n        }\r\n        auction.currentBidAmount = amount;\r\n        auction.currentBidOwner = msg.sender;\r\n        auction.bidCount = auction.bidCount.add(1);\r\n        emit AuctionBid(auctionIndex, msg.sender, amount);\r\n    }\r\n\r\n    function getTotalAuctions() public view returns (uint256) {\r\n        return numAuctions;\r\n    }\r\n\r\n    function isActive(uint256 index) public view returns (bool) {\r\n        return getStatus(index) == Status.active;\r\n    }\r\n\r\n    function isFinished(uint256 index) public view returns (bool) {\r\n        return getStatus(index) == Status.finished;\r\n    }\r\n\r\n\r\n    function getStatus(uint256 index) public view returns (Status) {\r\n        Auction storage auction = auctions[index];\r\n        if (auction.finished) {\r\n            return Status.finished;\r\n        }\r\n\r\n        if (block.timestamp < auction.startTime) {\r\n            return Status.pending;\r\n        }\r\n\tif (block.timestamp < auction.endTime) {\r\n            return Status.active;\r\n        }\r\n\treturn Status.finished;\r\n    }\r\n\r\n    function getCurrentBidOwner(uint256 auctionIndex) public view returns (address) {\r\n        return auctions[auctionIndex].currentBidOwner;\r\n    }\r\n\r\n    function getCurrentBidAmount(uint256 auctionIndex) public view returns (uint256) {\r\n        return auctions[auctionIndex].currentBidAmount;\r\n    }\r\n\r\n    function getBidCount(uint256 auctionIndex) public view returns (uint256) {\r\n        return auctions[auctionIndex].bidCount;\r\n    }\r\n\r\n    function getWinner(uint256 auctionIndex) public view returns (address) {\r\n        require(isFinished(auctionIndex));\r\n        return auctions[auctionIndex].currentBidOwner;\r\n    }\r\n\r\n    function claimTokens(uint256 auctionIndex) public {\r\n        Auction storage auction = auctions[auctionIndex];\r\n        uint amount = auction.pendingReturns[msg.sender];\r\n\r\n        require(amount > 0, \"Nothing to claim\");\r\n\r\n        auction.pendingReturns[msg.sender] = 0;\r\n        _sendTo(auctionIndex, amount);\r\n        emit ClaimTokens(auctionIndex, msg.sender, amount);\r\n    }\r\n\r\n    function _sendTo(uint256 auctionIndex, uint256 amount) internal {\r\n        Auction storage auction = auctions[auctionIndex];\r\n        if (isETHAuction(auctionIndex)) {\r\n            payable(msg.sender).transfer(amount);\r\n        } else {\r\n            ERC20 token = ERC20(auction.erc20tokenAddress);\r\n            require(token.transfer(msg.sender, amount));\r\n        }\r\n    }\r\n\r\n    function claimAsset(uint256 auctionIndex) public {\r\n        address winner = getWinner(auctionIndex);\r\n        require(isFinished(auctionIndex), \"auction is not finished yet\");\r\n        require(winner == msg.sender, \"you are not winner\");\r\n\r\n        Auction storage auction = auctions[auctionIndex];\r\n        ERC721 asset = ERC721(auction.assetAddress);\r\n        asset.transferFrom(address(this), winner, auction.assetId);\r\n        emit ClaimAsset(auctionIndex, winner);\r\n    }\r\n\r\n    function claimWonBid(uint256 auctionIndex) public {\r\n        require(isFinished(auctionIndex), \"auction is not finished yet\");\r\n        Auction storage auction = auctions[auctionIndex];\r\n        require(auction.creator == msg.sender, \"not creator of auction\");\r\n        require(!auction.isWonBidSent, \"you already collected a won bid\");\r\n        auction.isWonBidSent = true;\r\n        _sendTo(auctionIndex, auction.currentBidAmount);\r\n    }\r\n\r\n\r\n    function instantBuyAssetWithETH(uint256 auctionIndex) public payable ethAuction(auctionIndex) {\r\n        _instantBuy(auctionIndex, msg.value);\r\n    }\r\n\r\n    function instantBuyAssetWithERC20(uint256 auctionIndex, uint256 amount) public erc20Auction(auctionIndex) {\r\n        _instantBuy(auctionIndex, amount);\r\n        Auction storage auction = auctions[auctionIndex];\r\n        ERC20 token = ERC20(auction.erc20tokenAddress);\r\n        require(token.transferFrom(msg.sender, address(this), amount));\r\n    }\r\n    function _instantBuy(uint256 auctionIndex, uint256 amount) internal {\r\n        Auction storage auction = auctions[auctionIndex];\r\n\r\n        require(isActive(auctionIndex), \"Auction is not active\");\r\n        require(auction.instantBuyPrice > 0, \"Instant price was not set. This can not be bought instantly\");\r\n\r\n        require(amount >= auction.instantBuyPrice);\r\n\r\n        if (auction.currentBidAmount != 0) {\r\n            auction.pendingReturns[auction.currentBidOwner] += auction.currentBidAmount;\r\n        }\r\n\r\n        auction.currentBidAmount = amount;\r\n        auction.currentBidOwner = msg.sender;\r\n        auction.finished = true;\r\n    }\r\n\r\n    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {\r\n\treturn type(ERC721TokenReceiver).interfaceId;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) external pure override returns (bool) {\r\n        return interfaceID == type(ERC165).interfaceId || interfaceID == type(ERC721TokenReceiver).interfaceId;\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AuctionBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_assetID\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"name\":\"ClaimAsset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimTokens\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bidERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"bidETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"claimAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"claimWonBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_assetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_assetId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_instantBuyPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_erc20tokenAddress\",\"type\":\"address\"}],\"name\":\"createAuction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getBidCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getCurrentBidAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getCurrentBidOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getStatus\",\"outputs\":[{\"internalType\":\"enum AuctionEngineV6.Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalAuctions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"getWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"instantBuyAssetWithERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"instantBuyAssetWithETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionIndex\",\"type\":\"uint256\"}],\"name\":\"isETHAuction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"AuctionEngineV6","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://9aacf42ba94dde80eacea8f4548d674f930030b40d87f933189153ea2e99c9bb"}]}