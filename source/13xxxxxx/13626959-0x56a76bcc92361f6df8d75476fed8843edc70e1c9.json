{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/L1/rollup/CanonicalTransactionChain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { AddressAliasHelper } from \\\"../../standards/AddressAliasHelper.sol\\\";\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\n\\n/* Interface Imports */\\nimport { ICanonicalTransactionChain } from \\\"./ICanonicalTransactionChain.sol\\\";\\nimport { IChainStorageContainer } from \\\"./IChainStorageContainer.sol\\\";\\n\\n/**\\n * @title CanonicalTransactionChain\\n * @dev The Canonical Transaction Chain (CTC) contract is an append-only log of transactions\\n * which must be applied to the rollup state. It defines the ordering of rollup transactions by\\n * writing them to the 'CTC:batches' instance of the Chain Storage Container.\\n * The CTC also allows any account to 'enqueue' an L2 transaction, which will require that the\\n * Sequencer will eventually append it to the rollup state.\\n *\\n * Runtime target: EVM\\n */\\ncontract CanonicalTransactionChain is ICanonicalTransactionChain, Lib_AddressResolver {\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    // L2 tx gas-related\\n    uint256 public constant MIN_ROLLUP_TX_GAS = 100000;\\n    uint256 public constant MAX_ROLLUP_TX_SIZE = 50000;\\n\\n    // The approximate cost of calling the enqueue function\\n    uint256 public enqueueGasCost;\\n    // The ratio of the cost of L1 gas to the cost of L2 gas\\n    uint256 public l2GasDiscountDivisor;\\n    // The amount of L2 gas which can be forwarded to L2 without spam prevention via 'gas burn'.\\n    // Calculated as the product of l2GasDiscountDivisor * enqueueGasCost.\\n    // See comments in enqueue() for further detail.\\n    uint256 public enqueueL2GasPrepaid;\\n    //default l2 chain id\\n    uint256 constant public DEFAULT_CHAINID = 1088;\\n\\n    // Encoding-related (all in bytes)\\n    uint256 internal constant BATCH_CONTEXT_SIZE = 16;\\n    uint256 internal constant BATCH_CONTEXT_LENGTH_POS = 12;\\n    uint256 internal constant BATCH_CONTEXT_START_POS = 15;\\n    uint256 internal constant TX_DATA_HEADER_SIZE = 3;\\n    uint256 internal constant BYTES_TILL_TX_DATA = 65;\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    uint256 public maxTransactionGasLimit;\\n\\n    /***************\\n     * Queue State *\\n     ***************/\\n\\n    mapping(uint256=>uint40) private _nextQueueIndex; // index of the first queue element not yet included\\n    mapping(uint256=>Lib_OVMCodec.QueueElement[]) queueElements;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    constructor(\\n        address _libAddressManager,\\n        uint256 _maxTransactionGasLimit,\\n        uint256 _l2GasDiscountDivisor,\\n        uint256 _enqueueGasCost\\n    ) Lib_AddressResolver(_libAddressManager)\\n    {\\n        maxTransactionGasLimit = _maxTransactionGasLimit;\\n        l2GasDiscountDivisor = _l2GasDiscountDivisor;\\n        enqueueGasCost = _enqueueGasCost;\\n        enqueueL2GasPrepaid = _l2GasDiscountDivisor * _enqueueGasCost;\\n    }\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    /**\\n     * Modifier to enforce that, if configured, only the Burn Admin may\\n     * successfully call a method.\\n     */\\n    modifier onlyBurnAdmin() {\\n        require(msg.sender == libAddressManager.owner(), \\\"Only callable by the Burn Admin.\\\");\\n        _;\\n    }\\n\\n    /*******************************\\n     * Authorized Setter Functions *\\n     *******************************/\\n\\n    /**\\n     * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.\\n     * The value of enqueueL2GasPrepaid is immediately updated as well.\\n     */\\n    function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost)\\n        external\\n        onlyBurnAdmin\\n    {\\n        enqueueGasCost = _enqueueGasCost;\\n        l2GasDiscountDivisor = _l2GasDiscountDivisor;\\n        // See the comment in enqueue() for the rationale behind this formula.\\n        enqueueL2GasPrepaid = _l2GasDiscountDivisor * _enqueueGasCost;\\n\\n        emit L2GasParamsUpdated(l2GasDiscountDivisor, enqueueGasCost, enqueueL2GasPrepaid);\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Accesses the batch storage container.\\n     * @return Reference to the batch storage container.\\n     */\\n    function batches() public view returns (IChainStorageContainer) {\\n        return IChainStorageContainer(resolve(\\\"ChainStorageContainer-CTC-batches\\\"));\\n    }\\n\\n    /**\\n     * Accesses the queue storage container.\\n     * @return Reference to the queue storage container.\\n     */\\n    function queue() public view returns (IChainStorageContainer) {\\n        return IChainStorageContainer(resolve(\\\"ChainStorageContainer-CTC-queue\\\"));\\n    }\\n\\n    /**\\n     * Retrieves the total number of elements submitted.\\n     * @return _totalElements Total submitted elements.\\n     */\\n    function getTotalElements() public view returns (uint256 _totalElements) {\\n        (uint40 totalElements, , , ) = _getBatchExtraData();\\n        return uint256(totalElements);\\n    }\\n\\n    /**\\n     * Retrieves the total number of batches submitted.\\n     * @return _totalBatches Total submitted batches.\\n     */\\n    function getTotalBatches() public view returns (uint256 _totalBatches) {\\n        return batches().length();\\n    }\\n\\n    /**\\n     * Returns the index of the next element to be enqueued.\\n     * @return Index for the next queue element.\\n     */\\n    function getNextQueueIndex() public view returns (uint40) {\\n        return _nextQueueIndex[DEFAULT_CHAINID];\\n    }\\n\\n    /**\\n     * Returns the timestamp of the last transaction.\\n     * @return Timestamp for the last transaction.\\n     */\\n    function getLastTimestamp() public view returns (uint40) {\\n        (, , uint40 lastTimestamp, ) = _getBatchExtraData();\\n        return lastTimestamp;\\n    }\\n\\n    /**\\n     * Returns the blocknumber of the last transaction.\\n     * @return Blocknumber for the last transaction.\\n     */\\n    function getLastBlockNumber() public view returns (uint40) {\\n        (, , , uint40 lastBlockNumber) = _getBatchExtraData();\\n        return lastBlockNumber;\\n    }\\n\\n    /**\\n     * Gets the queue element at a particular index.\\n     * @param _index Index of the queue element to access.\\n     * @return _element Queue element at the given index.\\n     */\\n    function getQueueElement(uint256 _index)\\n        public\\n        view\\n        returns (Lib_OVMCodec.QueueElement memory _element)\\n    {\\n        return queueElements[DEFAULT_CHAINID][_index];\\n    }\\n\\n    /**\\n     * Get the number of queue elements which have not yet been included.\\n     * @return Number of pending queue elements.\\n     */\\n    function getNumPendingQueueElements() public view returns (uint40) {\\n        return uint40(queueElements[DEFAULT_CHAINID].length) - _nextQueueIndex[DEFAULT_CHAINID];\\n    }\\n\\n    /**\\n     * Retrieves the length of the queue, including\\n     * both pending and canonical transactions.\\n     * @return Length of the queue.\\n     */\\n    function getQueueLength() public view returns (uint40) {\\n        return uint40(queueElements[DEFAULT_CHAINID].length);\\n    }\\n\\n    /**\\n     * Adds a transaction to the queue.\\n     * @param _target Target L2 contract to send the transaction to.\\n     * @param _gasLimit Gas limit for the enqueued L2 transaction.\\n     * @param _data Transaction data.\\n     */\\n    function enqueue(\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    ) external {\\n        enqueueByChainId(DEFAULT_CHAINID, _target, _gasLimit, _data);\\n    }\\n\\n    /**\\n     * Allows the sequencer to append a batch of transactions.\\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\\n     * .param _contexts Array of batch contexts.\\n     * .param _transactionDataFields Array of raw transaction data.\\n     */\\n    function appendSequencerBatch() external {\\n        uint40 shouldStartAtElement;\\n        uint24 totalElementsToAppend;\\n        uint24 numContexts;\\n        assembly {\\n            shouldStartAtElement := shr(216, calldataload(4))\\n            totalElementsToAppend := shr(232, calldataload(9))\\n            numContexts := shr(232, calldataload(12))\\n        }\\n\\n        require(\\n            shouldStartAtElement == getTotalElements(),\\n            \\\"Actual batch start index does not match expected start index.\\\"\\n        );\\n\\n        require(\\n            msg.sender == resolve(\\\"OVM_Sequencer\\\"),\\n            \\\"Function can only be called by the Sequencer.\\\"\\n        );\\n\\n        uint40 nextTransactionPtr = uint40(\\n            BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts\\n        );\\n\\n        require(msg.data.length >= nextTransactionPtr, \\\"Not enough BatchContexts provided.\\\");\\n\\n        // Counter for number of sequencer transactions appended so far.\\n        uint32 numSequencerTransactions = 0;\\n\\n        // Cache the _nextQueueIndex storage variable to a temporary stack variable.\\n        // This is safe as long as nothing reads or writes to the storage variable\\n        // until it is updated by the temp variable.\\n        uint40 nextQueueIndex = _nextQueueIndex[DEFAULT_CHAINID];\\n\\n        BatchContext memory curContext;\\n        for (uint32 i = 0; i < numContexts; i++) {\\n            BatchContext memory nextContext = _getBatchContext(i);\\n\\n            // Now we can update our current context.\\n            curContext = nextContext;\\n\\n            // Process sequencer transactions first.\\n            numSequencerTransactions += uint32(curContext.numSequencedTransactions);\\n\\n            // Now process any subsequent queue transactions.\\n            nextQueueIndex += uint40(curContext.numSubsequentQueueTransactions);\\n        }\\n\\n        require(\\n            nextQueueIndex <= queueElements[DEFAULT_CHAINID].length,\\n            \\\"Attempted to append more elements than are available in the queue.\\\"\\n        );\\n\\n        // Generate the required metadata that we need to append this batch\\n        uint40 numQueuedTransactions = totalElementsToAppend - numSequencerTransactions;\\n        uint40 blockTimestamp;\\n        uint40 blockNumber;\\n        if (curContext.numSubsequentQueueTransactions == 0) {\\n            // The last element is a sequencer tx, therefore pull timestamp and block number from\\n            // the last context.\\n            blockTimestamp = uint40(curContext.timestamp);\\n            blockNumber = uint40(curContext.blockNumber);\\n        } else {\\n            // The last element is a queue tx, therefore pull timestamp and block number from the\\n            // queue element.\\n            // curContext.numSubsequentQueueTransactions > 0 which means that we've processed at\\n            // least one queue element. We increment nextQueueIndex after processing each queue\\n            // element, so the index of the last element we processed is nextQueueIndex - 1.\\n            Lib_OVMCodec.QueueElement memory lastElement = queueElements[DEFAULT_CHAINID][nextQueueIndex - 1];\\n\\n            blockTimestamp = lastElement.timestamp;\\n            blockNumber = lastElement.blockNumber;\\n        }\\n\\n        // Cache the previous blockhash to ensure all transaction data can be retrieved efficiently.\\n        _appendBatch(\\n            blockhash(block.number - 1),\\n            totalElementsToAppend,\\n            numQueuedTransactions,\\n            blockTimestamp,\\n            blockNumber\\n        );\\n\\n        emit SequencerBatchAppended(\\n            nextQueueIndex - numQueuedTransactions,\\n            numQueuedTransactions,\\n            getTotalElements(),\\n            DEFAULT_CHAINID\\n        );\\n\\n        // Update the _nextQueueIndex storage variable.\\n        _nextQueueIndex[DEFAULT_CHAINID] = nextQueueIndex;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Returns the BatchContext located at a particular index.\\n     * @param _index The index of the BatchContext\\n     * @return The BatchContext at the specified index.\\n     */\\n    function _getBatchContext(uint256 _index) internal pure returns (BatchContext memory) {\\n        uint256 contextPtr = 15 + _index * BATCH_CONTEXT_SIZE;\\n        uint256 numSequencedTransactions;\\n        uint256 numSubsequentQueueTransactions;\\n        uint256 ctxTimestamp;\\n        uint256 ctxBlockNumber;\\n\\n        assembly {\\n            numSequencedTransactions := shr(232, calldataload(contextPtr))\\n            numSubsequentQueueTransactions := shr(232, calldataload(add(contextPtr, 3)))\\n            ctxTimestamp := shr(216, calldataload(add(contextPtr, 6)))\\n            ctxBlockNumber := shr(216, calldataload(add(contextPtr, 11)))\\n        }\\n\\n        return\\n            BatchContext({\\n                numSequencedTransactions: numSequencedTransactions,\\n                numSubsequentQueueTransactions: numSubsequentQueueTransactions,\\n                timestamp: ctxTimestamp,\\n                blockNumber: ctxBlockNumber\\n            });\\n    }\\n\\n    /**\\n     * Parses the batch context from the extra data.\\n     * @return Total number of elements submitted.\\n     * @return Index of the next queue element.\\n     */\\n    function _getBatchExtraData()\\n        internal\\n        view\\n        returns (\\n            uint40,\\n            uint40,\\n            uint40,\\n            uint40\\n        )\\n    {\\n        bytes27 extraData = batches().getGlobalMetadata();\\n\\n        uint40 totalElements;\\n        uint40 nextQueueIndex;\\n        uint40 lastTimestamp;\\n        uint40 lastBlockNumber;\\n\\n        // solhint-disable max-line-length\\n        assembly {\\n            extraData := shr(40, extraData)\\n            totalElements := and(\\n                extraData,\\n                0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF\\n            )\\n            nextQueueIndex := shr(\\n                40,\\n                and(extraData, 0x00000000000000000000000000000000000000000000FFFFFFFFFF0000000000)\\n            )\\n            lastTimestamp := shr(\\n                80,\\n                and(extraData, 0x0000000000000000000000000000000000FFFFFFFFFF00000000000000000000)\\n            )\\n            lastBlockNumber := shr(\\n                120,\\n                and(extraData, 0x000000000000000000000000FFFFFFFFFF000000000000000000000000000000)\\n            )\\n        }\\n        // solhint-enable max-line-length\\n\\n        return (totalElements, nextQueueIndex, lastTimestamp, lastBlockNumber);\\n    }\\n\\n    /**\\n     * Encodes the batch context for the extra data.\\n     * @param _totalElements Total number of elements submitted.\\n     * @param _nextQueueIdx Index of the next queue element.\\n     * @param _timestamp Timestamp for the last batch.\\n     * @param _blockNumber Block number of the last batch.\\n     * @return Encoded batch context.\\n     */\\n    function _makeBatchExtraData(\\n        uint40 _totalElements,\\n        uint40 _nextQueueIdx,\\n        uint40 _timestamp,\\n        uint40 _blockNumber\\n    ) internal pure returns (bytes27) {\\n        bytes27 extraData;\\n        assembly {\\n            extraData := _totalElements\\n            extraData := or(extraData, shl(40, _nextQueueIdx))\\n            extraData := or(extraData, shl(80, _timestamp))\\n            extraData := or(extraData, shl(120, _blockNumber))\\n            extraData := shl(40, extraData)\\n        }\\n\\n        return extraData;\\n    }\\n\\n    /**\\n     * Inserts a batch into the chain of batches.\\n     * @param _transactionRoot Root of the transaction tree for this batch.\\n     * @param _batchSize Number of elements in the batch.\\n     * @param _numQueuedTransactions Number of queue transactions in the batch.\\n     * @param _timestamp The latest batch timestamp.\\n     * @param _blockNumber The latest batch blockNumber.\\n     */\\n    function _appendBatch(\\n        bytes32 _transactionRoot,\\n        uint256 _batchSize,\\n        uint256 _numQueuedTransactions,\\n        uint40 _timestamp,\\n        uint40 _blockNumber\\n    ) internal {\\n        IChainStorageContainer batchesRef = batches();\\n        (uint40 totalElements, uint40 nextQueueIndex, , ) = _getBatchExtraData();\\n\\n        Lib_OVMCodec.ChainBatchHeader memory header = Lib_OVMCodec.ChainBatchHeader({\\n            batchIndex: batchesRef.length(),\\n            batchRoot: _transactionRoot,\\n            batchSize: _batchSize,\\n            prevTotalElements: totalElements,\\n            extraData: hex\\\"\\\"\\n        });\\n\\n        emit TransactionBatchAppended(\\n            DEFAULT_CHAINID,\\n            header.batchIndex,\\n            header.batchRoot,\\n            header.batchSize,\\n            header.prevTotalElements,\\n            header.extraData\\n        );\\n\\n        bytes32 batchHeaderHash = Lib_OVMCodec.hashBatchHeader(header);\\n        bytes27 latestBatchContext = _makeBatchExtraData(\\n            totalElements + uint40(header.batchSize),\\n            nextQueueIndex + uint40(_numQueuedTransactions),\\n            _timestamp,\\n            _blockNumber\\n        );\\n\\n        batchesRef.push(batchHeaderHash, latestBatchContext);\\n    }\\n    \\n    //added chain id for public function\\n\\n    /**\\n     * Retrieves the total number of elements submitted.\\n     * @return _totalElements Total submitted elements.\\n     */\\n    function getTotalElementsByChainId(uint256 _chainId)\\n        override\\n        public\\n        view\\n        returns (\\n            uint256 _totalElements\\n        )\\n    {\\n        (uint40 totalElements,,,) = _getBatchExtraDataByChainId(_chainId);\\n        return uint256(totalElements);\\n    }\\n\\n    /**\\n     * Retrieves the total number of batches submitted.\\n     * @return _totalBatches Total submitted batches.\\n     */\\n    function getTotalBatchesByChainId(uint256 _chainId)\\n        override\\n        public\\n        view\\n        returns (\\n            uint256 _totalBatches\\n        )\\n    {\\n        return batches().lengthByChainId(_chainId);\\n    }\\n\\n    /**\\n     * Returns the index of the next element to be enqueued.\\n     * @return Index for the next queue element.\\n     */\\n    function getNextQueueIndexByChainId(uint256 _chainId)\\n        override\\n        public\\n        view\\n        returns (\\n            uint40\\n        )\\n    {\\n        (,uint40 nextQueueIndex,,) = _getBatchExtraDataByChainId(_chainId);\\n        return nextQueueIndex;\\n    }\\n\\n    /**\\n     * Returns the timestamp of the last transaction.\\n     * @return Timestamp for the last transaction.\\n     */\\n    function getLastTimestampByChainId(uint256 _chainId)\\n        override\\n        public\\n        view\\n        returns (\\n            uint40\\n        )\\n    {\\n        (,,uint40 lastTimestamp,) = _getBatchExtraDataByChainId(_chainId);\\n        return lastTimestamp;\\n    }\\n\\n    /**\\n     * Returns the blocknumber of the last transaction.\\n     * @return Blocknumber for the last transaction.\\n     */\\n    function getLastBlockNumberByChainId(uint256 _chainId)\\n        override\\n        public\\n        view\\n        returns (\\n            uint40\\n        )\\n    {\\n        (,,,uint40 lastBlockNumber) = _getBatchExtraDataByChainId(_chainId);\\n        return lastBlockNumber;\\n    }\\n\\n    /**\\n     * Gets the queue element at a particular index.\\n     * @param _index Index of the queue element to access.\\n     * @return _element Queue element at the given index.\\n     */\\n    function getQueueElementByChainId(\\n        uint256 _chainId,\\n        uint256 _index\\n    )\\n        override\\n        public\\n        view\\n        returns (\\n            Lib_OVMCodec.QueueElement memory _element\\n        )\\n    {\\n        return queueElements[_chainId][_index];\\n    }\\n\\n    /**\\n     * Get the number of queue elements which have not yet been included.\\n     * @return Number of pending queue elements.\\n     */\\n    function getNumPendingQueueElementsByChainId(\\n        uint256 _chainId\\n        )\\n        override\\n        public\\n        view\\n        returns (\\n            uint40\\n        )\\n    {\\n        return uint40(queueElements[_chainId].length) - _nextQueueIndex[_chainId];\\n    }\\n\\n   /**\\n     * Retrieves the length of the queue, including\\n     * both pending and canonical transactions.\\n     * @return Length of the queue.\\n     */\\n    function getQueueLengthByChainId(\\n        uint256 _chainId\\n        )\\n        override\\n        public\\n        view\\n        returns (\\n            uint40\\n        )\\n    {\\n        return uint40(queueElements[_chainId].length);\\n    }\\n\\n    /**\\n     * Adds a transaction to the queue.\\n     * @param _target Target L2 contract to send the transaction to.\\n     * @param _gasLimit Gas limit for the enqueued L2 transaction.\\n     * @param _data Transaction data.\\n     */\\n    function enqueueByChainId(\\n        uint256 _chainId,\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        override\\n        public\\n    {\\n        require(msg.sender == resolve(\\\"Proxy__OVM_L1CrossDomainMessenger\\\"),\\n                \\\"only the cross domain messenger can enqueue\\\");\\n                \\n        require(\\n            _data.length <= MAX_ROLLUP_TX_SIZE,\\n            \\\"Transaction data size exceeds maximum for rollup transaction.\\\"\\n        );\\n\\n        require(\\n            _gasLimit <= maxTransactionGasLimit,\\n            \\\"Transaction gas limit exceeds maximum for rollup transaction.\\\"\\n        );\\n\\n        require(\\n            _gasLimit >= MIN_ROLLUP_TX_GAS,\\n            \\\"Transaction gas limit too low to enqueue.\\\"\\n        );\\n        \\n        // Apply an aliasing unless msg.sender == tx.origin. This prevents an attack in which a\\n        // contract on L1 has the same address as a contract on L2 but doesn't have the same code.\\n        // We can safely ignore this for EOAs because they're guaranteed to have the same \\\"code\\\"\\n        // (i.e. no code at all). This also makes it possible for users to interact with contracts\\n        // on L2 even when the Sequencer is down.\\n        address sender;\\n        if (msg.sender == tx.origin) {\\n            sender = msg.sender;\\n        } else {\\n            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\\n        }\\n\\n        bytes32 transactionHash = keccak256(\\n            abi.encode(\\n                sender,\\n                _target,\\n                _gasLimit,\\n                _data\\n            )\\n        );\\n        \\n        queueElements[_chainId].push(\\n            Lib_OVMCodec.QueueElement({\\n                transactionHash: transactionHash,\\n                timestamp: uint40(block.timestamp),\\n                blockNumber: uint40(block.number)\\n            })\\n        );\\n\\n        // The underlying queue data structure stores 2 elements\\n        // per insertion, so to get the real queue length we need\\n        // to divide by 2 and subtract 1.\\n        uint256 queueIndex = queueElements[_chainId].length - 1;\\n        emit TransactionEnqueued(\\n            _chainId,\\n            sender,\\n            _target,\\n            _gasLimit,\\n            _data,\\n            queueIndex,\\n            block.timestamp\\n        );\\n    }\\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint j = _i;\\n        uint len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint k = len;\\n        while (_i != 0) {\\n            k = k-1;\\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n    /**\\n     * Allows the sequencer to append a batch of transactions.\\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\\n     * .param _contexts Array of batch contexts.\\n     * .param _transactionDataFields Array of raw transaction data.\\n     */\\n    function appendSequencerBatchByChainId()\\n        override\\n        public\\n    {\\n        uint256 _chainId;\\n        uint40 shouldStartAtElement;\\n        uint24 totalElementsToAppend;\\n        uint24 numContexts;\\n        assembly {\\n            _chainId              := calldataload(4)\\n            shouldStartAtElement  := shr(216, calldataload(36))\\n            totalElementsToAppend := shr(232, calldataload(41))\\n            numContexts           := shr(232, calldataload(44))\\n        }\\n\\n        require(\\n            shouldStartAtElement == getTotalElementsByChainId(_chainId),\\n            \\\"Actual batch start index does not match expected start index.\\\"\\n        );\\n        \\n        require(\\n            msg.sender == resolve(string(abi.encodePacked(uint2str(_chainId),\\\"_MVM_Sequencer\\\"))),\\n            \\\"Function can only be called by the Sequencer.\\\"\\n        );\\n\\n        require(\\n            numContexts > 0,\\n            \\\"Must provide at least one batch context.\\\"\\n        );\\n\\n        require(\\n            totalElementsToAppend > 0,\\n            \\\"Must append at least one element.\\\"\\n        );\\n\\n\\n        uint40 nextTransactionPtr = uint40(\\n            BATCH_CONTEXT_START_POS + BATCH_CONTEXT_SIZE * numContexts\\n        );\\n\\n        require(\\n            msg.data.length >= nextTransactionPtr,\\n            \\\"Not enough BatchContexts provided.\\\"\\n        );\\n        \\n        // Cache the _nextQueueIndex storage variable to a temporary stack variable.\\n        // This is safe as long as nothing reads or writes to the storage variable\\n        // until it is updated by the temp variable.\\n        uint40 nextQueueIndex = _nextQueueIndex[_chainId];\\n\\n        // Counter for number of sequencer transactions appended so far.\\n        uint32 numSequencerTransactions = 0;\\n\\n        BatchContext memory curContext;\\n        for (uint32 i = 0; i < numContexts; i++) {\\n            BatchContext memory nextContext = _getBatchContextByChainId(0,_chainId,i);\\n\\n            // Now we can update our current context.\\n            curContext = nextContext;\\n\\t        // Process sequencer transactions first.\\n\\t        numSequencerTransactions += uint32(curContext.numSequencedTransactions);\\n\\t        \\n\\t        // Now process any subsequent queue transactions.\\n            nextQueueIndex += uint40(curContext.numSubsequentQueueTransactions);\\n        }\\n\\n        require(\\n            nextQueueIndex <= queueElements[_chainId].length,\\n            \\\"Attempted to append more elements than are available in the queue.\\\"\\n        );\\n\\n        // Generate the required metadata that we need to append this batch\\n        uint40 numQueuedTransactions = totalElementsToAppend - numSequencerTransactions;\\n        uint40 blockTimestamp;\\n        uint40 blockNumber;\\n        if (curContext.numSubsequentQueueTransactions == 0) {\\n            // The last element is a sequencer tx, therefore pull timestamp and block number from\\n            // the last context.\\n            blockTimestamp = uint40(curContext.timestamp);\\n            blockNumber = uint40(curContext.blockNumber);\\n        } else {\\n            // The last element is a queue tx, therefore pull timestamp and block number from the\\n            // queue element.\\n            // curContext.numSubsequentQueueTransactions > 0 which means that we've processed at\\n            // least one queue element. We increment nextQueueIndex after processing each queue\\n            // element, so the index of the last element we processed is nextQueueIndex - 1.\\n            Lib_OVMCodec.QueueElement memory lastElement = queueElements[_chainId][nextQueueIndex - 1];\\n\\n            blockTimestamp = lastElement.timestamp;\\n            blockNumber = lastElement.blockNumber;\\n        }\\n\\n        // For efficiency reasons getMerkleRoot modifies the `leaves` argument in place\\n        // while calculating the root hash therefore any arguments passed to it must not\\n        // be used again afterwards\\n        _appendBatchByChainId(\\n    \\t    _chainId,\\n            blockhash(block.number - 1),\\n            totalElementsToAppend,\\n            numQueuedTransactions,\\n            blockTimestamp,\\n            blockNumber\\n        );\\n\\n        emit SequencerBatchAppended(\\n            _chainId,\\n            nextQueueIndex - numQueuedTransactions,\\n            numQueuedTransactions,\\n            getTotalElementsByChainId(_chainId)\\n        );\\n        \\n        // Update the _nextQueueIndex storage variable.\\n        _nextQueueIndex[_chainId] = nextQueueIndex;\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Returns the BatchContext located at a particular index.\\n     * @param _index The index of the BatchContext\\n     * @return The BatchContext at the specified index.\\n     */\\n    function _getBatchContextByChainId(\\n        uint256 _ptrStart,\\n        uint256 _chainId,\\n        uint256 _index\\n    )\\n        internal\\n        pure\\n        returns (\\n            BatchContext memory\\n        )\\n    {\\n        uint256 contextPtr = _ptrStart + 32 + 15 + _index * BATCH_CONTEXT_SIZE;\\n        uint256 numSequencedTransactions;\\n        uint256 numSubsequentQueueTransactions;\\n        uint256 ctxTimestamp;\\n        uint256 ctxBlockNumber;\\n\\n        assembly {\\n            numSequencedTransactions       := shr(232, calldataload(contextPtr))\\n            numSubsequentQueueTransactions := shr(232, calldataload(add(contextPtr, 3)))\\n            ctxTimestamp                   := shr(216, calldataload(add(contextPtr, 6)))\\n            ctxBlockNumber                 := shr(216, calldataload(add(contextPtr, 11)))\\n        }\\n\\n        return BatchContext({\\n            numSequencedTransactions: numSequencedTransactions,\\n            numSubsequentQueueTransactions: numSubsequentQueueTransactions,\\n            timestamp: ctxTimestamp,\\n            blockNumber: ctxBlockNumber\\n        });\\n    }\\n\\n    /**\\n     * Parses the batch context from the extra data.\\n     * @return Total number of elements submitted.\\n     * @return Index of the next queue element.\\n     */\\n    function _getBatchExtraDataByChainId(\\n        uint256 _chainId\\n        )\\n        internal\\n        view\\n        returns (\\n            uint40,\\n            uint40,\\n            uint40,\\n            uint40\\n        )\\n    {\\n        bytes27 extraData = batches().getGlobalMetadataByChainId(_chainId);\\n\\n        uint40 totalElements;\\n        uint40 nextQueueIndex;\\n        uint40 lastTimestamp;\\n        uint40 lastBlockNumber;\\n        assembly {\\n            extraData       :=  shr(40, extraData)\\n            totalElements   :=  and(extraData, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)\\n            nextQueueIndex  :=  shr(40, and(extraData, 0x00000000000000000000000000000000000000000000FFFFFFFFFF0000000000))\\n            lastTimestamp   :=  shr(80, and(extraData, 0x0000000000000000000000000000000000FFFFFFFFFF00000000000000000000))\\n            lastBlockNumber :=  shr(120, and(extraData, 0x000000000000000000000000FFFFFFFFFF000000000000000000000000000000))\\n        }\\n\\n        return (\\n            totalElements,\\n            nextQueueIndex,\\n            lastTimestamp,\\n            lastBlockNumber\\n        );\\n    }\\n\\n    /**\\n     * Encodes the batch context for the extra data.\\n     * @param _totalElements Total number of elements submitted.\\n     * @param _nextQueueIdx Index of the next queue element.\\n     * @param _timestamp Timestamp for the last batch.\\n     * @param _blockNumber Block number of the last batch.\\n     * @return Encoded batch context.\\n     */\\n    function _makeBatchExtraDataByChainId(\\n        uint256 _chainId,\\n        uint40 _totalElements,\\n        uint40 _nextQueueIdx,\\n        uint40 _timestamp,\\n        uint40 _blockNumber\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes27\\n        )\\n    {\\n        bytes27 extraData;\\n        assembly {\\n            extraData := _totalElements\\n            extraData := or(extraData, shl(40, _nextQueueIdx))\\n            extraData := or(extraData, shl(80, _timestamp))\\n            extraData := or(extraData, shl(120, _blockNumber))\\n            extraData := shl(40, extraData)\\n        }\\n\\n        return extraData;\\n    }\\n\\n    /**\\n     * Inserts a batch into the chain of batches.\\n     * @param _transactionRoot Root of the transaction tree for this batch.\\n     * @param _batchSize Number of elements in the batch.\\n     * @param _numQueuedTransactions Number of queue transactions in the batch.\\n     * @param _timestamp The latest batch timestamp.\\n     * @param _blockNumber The latest batch blockNumber.\\n     */\\n    function _appendBatchByChainId(\\n        uint256 _chainId,\\n        bytes32 _transactionRoot,\\n        uint256 _batchSize,\\n        uint256 _numQueuedTransactions,\\n        uint40 _timestamp,\\n        uint40 _blockNumber\\n    )\\n        internal\\n    {\\n\\t    IChainStorageContainer batchesRef = batches();\\n        (uint40 totalElements, uint40 nextQueueIndex, , ) = _getBatchExtraDataByChainId(_chainId);\\n\\n        Lib_OVMCodec.ChainBatchHeader memory header = Lib_OVMCodec.ChainBatchHeader({\\n            batchIndex: batchesRef.lengthByChainId(_chainId),\\n            batchRoot: _transactionRoot,\\n            batchSize: _batchSize,\\n            prevTotalElements: totalElements,\\n            extraData: hex\\\"\\\"\\n        });\\n\\n        emit TransactionBatchAppended(\\n            _chainId,\\n            header.batchIndex,\\n            header.batchRoot,\\n            header.batchSize,\\n            header.prevTotalElements,\\n            header.extraData\\n        );\\n\\n        bytes32 batchHeaderHash = Lib_OVMCodec.hashBatchHeader(header);\\n        bytes27 latestBatchContext = _makeBatchExtraDataByChainId(\\n            _chainId,\\n            totalElements + uint40(header.batchSize),\\n            nextQueueIndex + uint40(_numQueuedTransactions),\\n            _timestamp,\\n            _blockNumber\\n        );\\n\\n        batchesRef.pushByChainId(_chainId,batchHeaderHash, latestBatchContext);\\n    }\\n\\n    modifier onlyManager() {\\n        require(\\n            msg.sender == resolve(\\\"MVM_SuperManager\\\"),\\n            \\\"ChainStorageContainer: Function can only be called by the owner.\\\"\\n        );\\n        _;\\n    }\\n\\n    function pushQueueByChainId(\\n        uint256 _chainId,\\n        Lib_OVMCodec.QueueElement calldata _object\\n    )\\n        override\\n        public\\n        onlyManager\\n    {\\n        queueElements[_chainId].push(_object);\\n        emit QueuePushed(msg.sender,_chainId,_object);\\n    }\\n\\n    function setQueueByChainId(\\n        uint256 _chainId,\\n        uint256 _index,\\n        Lib_OVMCodec.QueueElement calldata _object\\n    )\\n        override\\n        public\\n        onlyManager\\n    {\\n        queueElements[_chainId][_index] = _object;\\n        emit QueueSetted(msg.sender,_chainId,_index,_object);\\n    }\\n\\n    function setBatchGlobalMetadataByChainId(\\n        uint256 _chainId,\\n        bytes27 _globalMetadata\\n    )\\n        override\\n        public\\n        onlyManager\\n    {\\n        batches().setGlobalMetadataByChainId(_chainId,_globalMetadata);\\n        emit BatchesGlobalMetadataSet(msg.sender,_chainId,_globalMetadata);\\n    }\\n\\n    function getBatchGlobalMetadataByChainId(uint256 _chainId)\\n        override\\n        public\\n        view\\n        returns (\\n            bytes27\\n        )\\n    {\\n        return batches().getGlobalMetadataByChainId(_chainId);\\n    }\\n\\n    function lengthBatchByChainId(uint256 _chainId)\\n        override\\n        public\\n        view\\n        returns (\\n            uint256\\n        )\\n    {\\n        return batches().lengthByChainId(_chainId);\\n    }\\n\\n    function pushBatchByChainId(\\n        uint256 _chainId,\\n        bytes32 _object,\\n        bytes27 _globalMetadata\\n    )\\n        override\\n        public\\n        onlyManager\\n    {\\n        batches().pushByChainId(_chainId,_object,_globalMetadata);\\n        emit BatchPushed(msg.sender,_chainId,_object,_globalMetadata);\\n    }\\n\\n    function setBatchByChainId(\\n        uint256 _chainId,\\n        uint256 _index,\\n        bytes32 _object\\n    )\\n        override\\n        public\\n        onlyManager\\n    {\\n        batches().setByChainId(_chainId,_index,_object);\\n        emit BatchSetted(msg.sender,_chainId,_index,_object);\\n    }\\n\\n    function getBatchByChainId(\\n        uint256 _chainId,\\n        uint256 _index\\n    )\\n        override\\n        public\\n        view\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return batches().getByChainId(_chainId,_index);\\n    }\\n\\n    function deleteBatchElementsAfterInclusiveByChainId(\\n        uint256 _chainId,\\n        uint256 _index,\\n        bytes27 _globalMetadata\\n    )\\n        override\\n        public\\n        onlyManager\\n    {\\n        batches().deleteElementsAfterInclusiveByChainId(\\n            _chainId,\\n            _index,\\n            _globalMetadata\\n        );\\n        emit BatchElementDeleted(msg.sender,_chainId,_index,_globalMetadata);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/standards/AddressAliasHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/*\\n * Copyright 2019-2021, Offchain Labs, Inc.\\n *\\n * Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n * You may obtain a copy of the License at\\n *\\n *    http://www.apache.org/licenses/LICENSE-2.0\\n *\\n * Unless required by applicable law or agreed to in writing, software\\n * distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n * See the License for the specific language governing permissions and\\n * limitations under the License.\\n */\\n\\npragma solidity ^0.8.7;\\n\\nlibrary AddressAliasHelper {\\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\\n\\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\\n    /// the inbox to the msg.sender viewed in the L2\\n    /// @param l1Address the address in the L1 that triggered the tx to L2\\n    /// @return l2Address L2 address as viewed in msg.sender\\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\\n        unchecked {\\n            l2Address = address(uint160(l1Address) + offset);\\n        }\\n    }\\n\\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n    /// address in the L1 that submitted a tx to the inbox\\n    /// @param l2Address L2 address as viewed in msg.sender\\n    /// @return l1Address the address in the L1 that triggered the tx to L2\\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\\n        unchecked {\\n            l1Address = address(uint160(l2Address) - offset);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/codec/Lib_OVMCodec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_RLPReader } from \\\"../rlp/Lib_RLPReader.sol\\\";\\nimport { Lib_RLPWriter } from \\\"../rlp/Lib_RLPWriter.sol\\\";\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\nimport { Lib_Bytes32Utils } from \\\"../utils/Lib_Bytes32Utils.sol\\\";\\n\\n/**\\n * @title Lib_OVMCodec\\n */\\nlibrary Lib_OVMCodec {\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum QueueOrigin {\\n        SEQUENCER_QUEUE,\\n        L1TOL2_QUEUE\\n    }\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct EVMAccount {\\n        uint256 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n    }\\n\\n    struct ChainBatchHeader {\\n        uint256 batchIndex;\\n        bytes32 batchRoot;\\n        uint256 batchSize;\\n        uint256 prevTotalElements;\\n        bytes extraData;\\n    }\\n\\n    struct ChainInclusionProof {\\n        uint256 index;\\n        bytes32[] siblings;\\n    }\\n\\n    struct Transaction {\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n        QueueOrigin l1QueueOrigin;\\n        address l1TxOrigin;\\n        address entrypoint;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n\\n    struct TransactionChainElement {\\n        bool isSequenced;\\n        uint256 queueIndex; // QUEUED TX ONLY\\n        uint256 timestamp; // SEQUENCER TX ONLY\\n        uint256 blockNumber; // SEQUENCER TX ONLY\\n        bytes txData; // SEQUENCER TX ONLY\\n    }\\n\\n    struct QueueElement {\\n        bytes32 transactionHash;\\n        uint40 timestamp;\\n        uint40 blockNumber;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Encodes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return Encoded transaction bytes.\\n     */\\n    function encodeTransaction(Transaction memory _transaction)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encodePacked(\\n                _transaction.timestamp,\\n                _transaction.blockNumber,\\n                _transaction.l1QueueOrigin,\\n                _transaction.l1TxOrigin,\\n                _transaction.entrypoint,\\n                _transaction.gasLimit,\\n                _transaction.data\\n            );\\n    }\\n\\n    /**\\n     * Hashes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return Hashed transaction\\n     */\\n    function hashTransaction(Transaction memory _transaction) internal pure returns (bytes32) {\\n        return keccak256(encodeTransaction(_transaction));\\n    }\\n\\n    /**\\n     * @notice Decodes an RLP-encoded account state into a useful struct.\\n     * @param _encoded RLP-encoded account state.\\n     * @return Account state struct.\\n     */\\n    function decodeEVMAccount(bytes memory _encoded) internal pure returns (EVMAccount memory) {\\n        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\\n\\n        return\\n            EVMAccount({\\n                nonce: Lib_RLPReader.readUint256(accountState[0]),\\n                balance: Lib_RLPReader.readUint256(accountState[1]),\\n                storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\\n                codeHash: Lib_RLPReader.readBytes32(accountState[3])\\n            });\\n    }\\n\\n    /**\\n     * Calculates a hash for a given batch header.\\n     * @param _batchHeader Header to hash.\\n     * @return Hash of the header.\\n     */\\n    function hashBatchHeader(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    _batchHeader.batchRoot,\\n                    _batchHeader.batchSize,\\n                    _batchHeader.prevTotalElements,\\n                    _batchHeader.extraData\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/resolver/Lib_AddressResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* Library Imports */\\nimport { Lib_AddressManager } from \\\"./Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title Lib_AddressResolver\\n */\\nabstract contract Lib_AddressResolver {\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    Lib_AddressManager public libAddressManager;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Lib_AddressManager.\\n     */\\n    constructor(address _libAddressManager) {\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n    }\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Resolves the address associated with a given name.\\n     * @param _name Name to resolve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function resolve(string memory _name) public view returns (address) {\\n        return libAddressManager.getAddress(_name);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L1/rollup/ICanonicalTransactionChain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/* Interface Imports */\\nimport { IChainStorageContainer } from \\\"./IChainStorageContainer.sol\\\";\\n\\n/**\\n * @title ICanonicalTransactionChain\\n */\\ninterface ICanonicalTransactionChain {\\n    /**********\\n     * Events *\\n     **********/\\n    event QueueGlobalMetadataSet(\\n        address _sender,\\n        uint256 _chainId,\\n        bytes27 _globalMetadata\\n    );\\n    \\n    event QueuePushed(\\n        address _sender,\\n        uint256 _chainId,\\n        Lib_OVMCodec.QueueElement _object\\n    );\\n\\n    event QueueSetted(\\n        address _sender,\\n        uint256 _chainId,\\n        uint256 _index,\\n        Lib_OVMCodec.QueueElement _object\\n    );\\n\\n    event QueueElementDeleted(\\n        address _sender,\\n        uint256 _chainId,\\n        uint256 _index,\\n        bytes27 _globalMetadata\\n    );\\n\\n    event BatchesGlobalMetadataSet(\\n        address _sender,\\n        uint256 _chainId,\\n        bytes27 _globalMetadata\\n    );\\n    \\n    event BatchPushed(\\n        address _sender,\\n        uint256 _chainId,\\n        bytes32 _object,\\n        bytes27 _globalMetadata\\n    );\\n\\n    event BatchSetted(\\n        address _sender,\\n        uint256 _chainId,\\n        uint256 _index,\\n        bytes32 _object\\n    );\\n\\n    event BatchElementDeleted(\\n        address _sender,\\n        uint256 _chainId,\\n        uint256 _index,\\n        bytes27 _globalMetadata\\n    );\\n\\n    event L2GasParamsUpdated(\\n        uint256 l2GasDiscountDivisor,\\n        uint256 enqueueGasCost,\\n        uint256 enqueueL2GasPrepaid\\n    );\\n\\n    event TransactionEnqueued(\\n        uint256 _chainId,\\n        address indexed _l1TxOrigin,\\n        address indexed _target,\\n        uint256 _gasLimit,\\n        bytes _data,\\n        uint256 indexed _queueIndex,\\n        uint256 _timestamp\\n    );\\n\\n    event QueueBatchAppended(\\n        uint256 _chainId,\\n        uint256 _startingQueueIndex,\\n        uint256 _numQueueElements,\\n        uint256 _totalElements\\n    );\\n\\n    event SequencerBatchAppended(\\n        uint256 _chainId,\\n        uint256 _startingQueueIndex,\\n        uint256 _numQueueElements,\\n        uint256 _totalElements\\n    );\\n\\n    event TransactionBatchAppended(\\n        uint256 _chainId,\\n        uint256 indexed _batchIndex,\\n        bytes32 _batchRoot,\\n        uint256 _batchSize,\\n        uint256 _prevTotalElements,\\n        bytes _extraData\\n    );\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct BatchContext {\\n        uint256 numSequencedTransactions;\\n        uint256 numSubsequentQueueTransactions;\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n    }\\n\\n    /*******************************\\n     * Authorized Setter Functions *\\n     *******************************/\\n\\n    /**\\n     * Allows the Burn Admin to update the parameters which determine the amount of gas to burn.\\n     * The value of enqueueL2GasPrepaid is immediately updated as well.\\n     */\\n    function setGasParams(uint256 _l2GasDiscountDivisor, uint256 _enqueueGasCost) external;\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Accesses the batch storage container.\\n     * @return Reference to the batch storage container.\\n     */\\n    function batches() external view returns (IChainStorageContainer);\\n\\n    /**\\n     * Accesses the queue storage container.\\n     * @return Reference to the queue storage container.\\n     */\\n    function queue() external view returns (IChainStorageContainer);\\n\\n    /**\\n     * Retrieves the total number of elements submitted.\\n     * @return _totalElements Total submitted elements.\\n     */\\n    function getTotalElements() external view returns (uint256 _totalElements);\\n\\n    /**\\n     * Retrieves the total number of batches submitted.\\n     * @return _totalBatches Total submitted batches.\\n     */\\n    function getTotalBatches() external view returns (uint256 _totalBatches);\\n\\n    /**\\n     * Returns the index of the next element to be enqueued.\\n     * @return Index for the next queue element.\\n     */\\n    function getNextQueueIndex() external view returns (uint40);\\n\\n    /**\\n     * Gets the queue element at a particular index.\\n     * @param _index Index of the queue element to access.\\n     * @return _element Queue element at the given index.\\n     */\\n    function getQueueElement(uint256 _index)\\n        external\\n        view\\n        returns (Lib_OVMCodec.QueueElement memory _element);\\n\\n    /**\\n     * Returns the timestamp of the last transaction.\\n     * @return Timestamp for the last transaction.\\n     */\\n    function getLastTimestamp() external view returns (uint40);\\n\\n    /**\\n     * Returns the blocknumber of the last transaction.\\n     * @return Blocknumber for the last transaction.\\n     */\\n    function getLastBlockNumber() external view returns (uint40);\\n\\n    /**\\n     * Get the number of queue elements which have not yet been included.\\n     * @return Number of pending queue elements.\\n     */\\n    function getNumPendingQueueElements() external view returns (uint40);\\n\\n    /**\\n     * Retrieves the length of the queue, including\\n     * both pending and canonical transactions.\\n     * @return Length of the queue.\\n     */\\n    function getQueueLength() external view returns (uint40);\\n\\n    /**\\n     * Adds a transaction to the queue.\\n     * @param _target Target contract to send the transaction to.\\n     * @param _gasLimit Gas limit for the given transaction.\\n     * @param _data Transaction data.\\n     */\\n    function enqueue(\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    ) external;\\n\\n    /**\\n     * Allows the sequencer to append a batch of transactions.\\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\\n     * .param _contexts Array of batch contexts.\\n     * .param _transactionDataFields Array of raw transaction data.\\n     */\\n    function appendSequencerBatch(\\n        // uint40 _shouldStartAtElement,\\n        // uint24 _totalElementsToAppend,\\n        // BatchContext[] _contexts,\\n        // bytes[] _transactionDataFields\\n    )\\n        external;\\n        \\n    //added chain id function\\n    \\n    /**\\n     * Retrieves the total number of elements submitted.\\n     * @param _chainId identity for the l2 chain.\\n     * @return _totalElements Total submitted elements.\\n     */\\n    function getTotalElementsByChainId(\\n        uint256 _chainId\\n        )\\n        external\\n        view\\n        returns (\\n            uint256 _totalElements\\n        );\\n\\n    /**\\n     * Retrieves the total number of batches submitted.\\n     * @param _chainId identity for the l2 chain.\\n     * @return _totalBatches Total submitted batches.\\n     */\\n    function getTotalBatchesByChainId(\\n        uint256 _chainId\\n        )\\n        external\\n        view\\n        returns (\\n            uint256 _totalBatches\\n        );\\n\\n    /**\\n     * Returns the index of the next element to be enqueued.\\n     * @param _chainId identity for the l2 chain.\\n     * @return Index for the next queue element.\\n     */\\n    function getNextQueueIndexByChainId(\\n        uint256 _chainId\\n        )\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n    /**\\n     * Gets the queue element at a particular index.\\n     * @param _chainId identity for the l2 chain.\\n     * @param _index Index of the queue element to access.\\n     * @return _element Queue element at the given index.\\n     */\\n    function getQueueElementByChainId(\\n        uint256 _chainId,\\n        uint256 _index\\n    )\\n        external\\n        view\\n        returns (\\n            Lib_OVMCodec.QueueElement memory _element\\n        );\\n\\n    /**\\n     * Returns the timestamp of the last transaction.\\n     * @param _chainId identity for the l2 chain.\\n     * @return Timestamp for the last transaction.\\n     */\\n    function getLastTimestampByChainId(\\n        uint256 _chainId\\n        )\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n    /**\\n     * Returns the blocknumber of the last transaction.\\n     * @param _chainId identity for the l2 chain.\\n     * @return Blocknumber for the last transaction.\\n     */\\n    function getLastBlockNumberByChainId(\\n        uint256 _chainId\\n        )\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n    /**\\n     * Get the number of queue elements which have not yet been included.\\n     * @param _chainId identity for the l2 chain.\\n     * @return Number of pending queue elements.\\n     */\\n    function getNumPendingQueueElementsByChainId(\\n        uint256 _chainId\\n        )\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n    /**\\n     * Retrieves the length of the queue, including\\n     * both pending and canonical transactions.\\n     * @param _chainId identity for the l2 chain.\\n     * @return Length of the queue.\\n     */\\n    function getQueueLengthByChainId(\\n        uint256 _chainId\\n        )\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n\\n    /**\\n     * Adds a transaction to the queue.\\n     * @param _chainId identity for the l2 chain.\\n     * @param _target Target contract to send the transaction to.\\n     * @param _gasLimit Gas limit for the given transaction.\\n     * @param _data Transaction data.\\n     */\\n    function enqueueByChainId(\\n        uint256 _chainId,\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        external;\\n        \\n    /**\\n     * Allows the sequencer to append a batch of transactions.\\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\\n     * .param _chainId identity for the l2 chain.\\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\\n     * .param _contexts Array of batch contexts.\\n     * .param _transactionDataFields Array of raw transaction data.\\n     */\\n    function appendSequencerBatchByChainId(\\n        // uint256 _chainId,\\n        // uint40 _shouldStartAtElement,\\n        // uint24 _totalElementsToAppend,\\n        // BatchContext[] _contexts,\\n        // bytes[] _transactionDataFields\\n    )\\n        external;\\n    \\n    function pushQueueByChainId(\\n        uint256 _chainId,\\n        Lib_OVMCodec.QueueElement calldata _object\\n    )\\n        external;\\n\\n    function setQueueByChainId(\\n        uint256 _chainId,\\n        uint256 _index,\\n        Lib_OVMCodec.QueueElement calldata _object\\n    )\\n        external;\\n\\n    function setBatchGlobalMetadataByChainId(\\n        uint256 _chainId,\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n    \\n    function getBatchGlobalMetadataByChainId(uint256 _chainId)\\n        external\\n        view\\n        returns (\\n            bytes27\\n        );\\n        \\n    function lengthBatchByChainId(uint256 _chainId)\\n        external\\n        view\\n        returns (\\n            uint256\\n        );\\n        \\n    function pushBatchByChainId(\\n        uint256 _chainId,\\n        bytes32 _object,\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n    \\n    function setBatchByChainId(\\n        uint256 _chainId,\\n        uint256 _index,\\n        bytes32 _object\\n    )\\n        external;\\n        \\n    function getBatchByChainId(\\n        uint256 _chainId,\\n        uint256 _index\\n    )\\n        external\\n        view\\n        returns (\\n            bytes32\\n        );\\n        \\n    function deleteBatchElementsAfterInclusiveByChainId(\\n        uint256 _chainId,\\n        uint256 _index,\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n}\\n\"\r\n    },\r\n    \"contracts/L1/rollup/IChainStorageContainer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title IChainStorageContainer\\n */\\ninterface IChainStorageContainer {\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\\n     * 27 bytes to store arbitrary data.\\n     * @param _globalMetadata New global metadata to set.\\n     */\\n    function setGlobalMetadata(bytes27 _globalMetadata) external;\\n\\n    /**\\n     * Retrieves the container's global metadata field.\\n     * @return Container global metadata field.\\n     */\\n    function getGlobalMetadata() external view returns (bytes27);\\n\\n    /**\\n     * Retrieves the number of objects stored in the container.\\n     * @return Number of objects in the container.\\n     */\\n    function length() external view returns (uint256);\\n\\n    /**\\n     * Pushes an object into the container.\\n     * @param _object A 32 byte value to insert into the container.\\n     */\\n    function push(bytes32 _object) external;\\n\\n    /**\\n     * Pushes an object into the container. Function allows setting the global metadata since\\n     * we'll need to touch the \\\"length\\\" storage slot anyway, which also contains the global\\n     * metadata (it's an optimization).\\n     * @param _object A 32 byte value to insert into the container.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function push(bytes32 _object, bytes27 _globalMetadata) external;\\n\\n    /**\\n     * Set an object into the container. Function allows setting the global metadata since\\n     * we'll need to touch the \\\"length\\\" storage slot anyway, which also contains the global\\n     * metadata (it's an optimization).\\n     * @param _index position.\\n     * @param _object A 32 byte value to insert into the container.\\n     */  \\n    function setByChainId(\\n        uint256 _chainId,\\n        uint256 _index,\\n        bytes32 _object\\n    )\\n        external;\\n        \\n    /**\\n     * Retrieves an object from the container.\\n     * @param _index Index of the particular object to access.\\n     * @return 32 byte object value.\\n     */\\n    function get(uint256 _index) external view returns (bytes32);\\n\\n    /**\\n     * Removes all objects after and including a given index.\\n     * @param _index Object index to delete from.\\n     */\\n    function deleteElementsAfterInclusive(uint256 _index) external;\\n\\n    /**\\n     * Removes all objects after and including a given index. Also allows setting the global\\n     * metadata field.\\n     * @param _index Object index to delete from.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function deleteElementsAfterInclusive(uint256 _index, bytes27 _globalMetadata) external;\\n\\n    /**\\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\\n     * 27 bytes to store arbitrary data.\\n     * @param _chainId identity for the l2 chain.\\n     * @param _globalMetadata New global metadata to set.\\n     */\\n    function setGlobalMetadataByChainId(\\n        uint256 _chainId,\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n\\n    /**\\n     * Retrieves the container's global metadata field.\\n     * @param _chainId identity for the l2 chain.\\n     * @return Container global metadata field.\\n     */\\n    function getGlobalMetadataByChainId(\\n        uint256 _chainId\\n        )\\n        external\\n        view\\n        returns (\\n            bytes27\\n        );\\n\\n    /**\\n     * Retrieves the number of objects stored in the container.\\n     * @param _chainId identity for the l2 chain.\\n     * @return Number of objects in the container.\\n     */\\n    function lengthByChainId(\\n        uint256 _chainId\\n        )\\n        external\\n        view\\n        returns (\\n            uint256\\n        );\\n\\n    /**\\n     * Pushes an object into the container.\\n     * @param _chainId identity for the l2 chain.\\n     * @param _object A 32 byte value to insert into the container.\\n     */\\n    function pushByChainId(\\n        uint256 _chainId,\\n        bytes32 _object\\n    )\\n        external;\\n\\n    /**\\n     * Pushes an object into the container. Function allows setting the global metadata since\\n     * we'll need to touch the \\\"length\\\" storage slot anyway, which also contains the global\\n     * metadata (it's an optimization).\\n     * @param _chainId identity for the l2 chain.\\n     * @param _object A 32 byte value to insert into the container.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function pushByChainId(\\n        uint256 _chainId,\\n        bytes32 _object,\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n\\n    /**\\n     * Retrieves an object from the container.\\n     * @param _chainId identity for the l2 chain.\\n     * @param _index Index of the particular object to access.\\n     * @return 32 byte object value.\\n     */\\n    function getByChainId(\\n        uint256 _chainId,\\n        uint256 _index\\n    )\\n        external\\n        view\\n        returns (\\n            bytes32\\n        );\\n\\n    /**\\n     * Removes all objects after and including a given index.\\n     * @param _chainId identity for the l2 chain.\\n     * @param _index Object index to delete from.\\n     */\\n    function deleteElementsAfterInclusiveByChainId(\\n        uint256 _chainId,\\n        uint256 _index\\n    )\\n        external;\\n        \\n    /**\\n     * Removes all objects after and including a given index. Also allows setting the global\\n     * metadata field.\\n     * @param _chainId identity for the l2 chain.\\n     * @param _index Object index to delete from.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function deleteElementsAfterInclusiveByChainId(\\n        uint256 _chainId,\\n        uint256 _index,\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n        \\n}\\n\"\r\n    },\r\n    \"contracts/libraries/rlp/Lib_RLPReader.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_RLPReader\\n * @dev Adapted from \\\"RLPReader\\\" by Hamdi Allam (hamdi.allam97@gmail.com).\\n */\\nlibrary Lib_RLPReader {\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    uint256 internal constant MAX_LIST_LENGTH = 32;\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct RLPItem {\\n        uint256 length;\\n        uint256 ptr;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts bytes to a reference to memory position and length.\\n     * @param _in Input bytes to convert.\\n     * @return Output memory reference.\\n     */\\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        return RLPItem({ length: _in.length, ptr: ptr });\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\\n        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.LIST_ITEM, \\\"Invalid RLP list value.\\\");\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            require(itemCount < MAX_LIST_LENGTH, \\\"Provided RLP list exceeds max list length.\\\");\\n\\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\\n                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })\\n            );\\n\\n            out[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out, itemCount)\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\\n        return readList(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.DATA_ITEM, \\\"Invalid RLP bytes value.\\\");\\n\\n        return _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        return readBytes(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(RLPItem memory _in) internal pure returns (string memory) {\\n        return string(readBytes(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(bytes memory _in) internal pure returns (string memory) {\\n        return readString(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\\n        require(_in.length <= 33, \\\"Invalid RLP bytes32 value.\\\");\\n\\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\\n\\n        require(itemType == RLPItemType.DATA_ITEM, \\\"Invalid RLP bytes32 value.\\\");\\n\\n        uint256 ptr = _in.ptr + itemOffset;\\n        bytes32 out;\\n        assembly {\\n            out := mload(ptr)\\n\\n            // Shift the bytes over to match the item size.\\n            if lt(itemLength, 32) {\\n                out := div(out, exp(256, sub(32, itemLength)))\\n            }\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(bytes memory _in) internal pure returns (bytes32) {\\n        return readBytes32(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(RLPItem memory _in) internal pure returns (uint256) {\\n        return uint256(readBytes32(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(bytes memory _in) internal pure returns (uint256) {\\n        return readUint256(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(RLPItem memory _in) internal pure returns (bool) {\\n        require(_in.length == 1, \\\"Invalid RLP boolean value.\\\");\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 out;\\n        assembly {\\n            out := byte(0, mload(ptr))\\n        }\\n\\n        require(out == 0 || out == 1, \\\"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\\\");\\n\\n        return out != 0;\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(bytes memory _in) internal pure returns (bool) {\\n        return readBool(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(RLPItem memory _in) internal pure returns (address) {\\n        if (_in.length == 1) {\\n            return address(0);\\n        }\\n\\n        require(_in.length == 21, \\\"Invalid RLP address value.\\\");\\n\\n        return address(uint160(readUint256(_in)));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(bytes memory _in) internal pure returns (address) {\\n        return readAddress(toRLPItem(_in));\\n    }\\n\\n    /**\\n     * Reads the raw bytes of an RLP item.\\n     * @param _in RLP item to read.\\n     * @return Raw RLP bytes.\\n     */\\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\\n        return _copy(_in);\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Decodes the length of an RLP item.\\n     * @param _in RLP item to decode.\\n     * @return Offset of the encoded data.\\n     * @return Length of the encoded data.\\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\\n     */\\n    function _decodeLength(RLPItem memory _in)\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            RLPItemType\\n        )\\n    {\\n        require(_in.length > 0, \\\"RLP item cannot be null.\\\");\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            uint256 strLen = prefix - 0x80;\\n\\n            require(_in.length > strLen, \\\"Invalid RLP short string.\\\");\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(_in.length > lenOfStrLen, \\\"Invalid RLP long string length.\\\");\\n\\n            uint256 strLen;\\n            assembly {\\n                // Pick out the string length.\\n                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\\n            }\\n\\n            require(_in.length > lenOfStrLen + strLen, \\\"Invalid RLP long string.\\\");\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(_in.length > listLen, \\\"Invalid RLP short list.\\\");\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(_in.length > lenOfListLen, \\\"Invalid RLP long list length.\\\");\\n\\n            uint256 listLen;\\n            assembly {\\n                // Pick out the list length.\\n                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\\n            }\\n\\n            require(_in.length > lenOfListLen + listLen, \\\"Invalid RLP long list.\\\");\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /**\\n     * Copies the bytes from a memory location.\\n     * @param _src Pointer to the location to read from.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        uint256 _src,\\n        uint256 _offset,\\n        uint256 _length\\n    ) private pure returns (bytes memory) {\\n        bytes memory out = new bytes(_length);\\n        if (out.length == 0) {\\n            return out;\\n        }\\n\\n        uint256 src = _src + _offset;\\n        uint256 dest;\\n        assembly {\\n            dest := add(out, 32)\\n        }\\n\\n        // Copy over as many complete words as we can.\\n        for (uint256 i = 0; i < _length / 32; i++) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += 32;\\n            dest += 32;\\n        }\\n\\n        // Pick out the remaining bytes.\\n        uint256 mask;\\n        unchecked {\\n            mask = 256**(32 - (_length % 32)) - 1;\\n        }\\n\\n        assembly {\\n            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\\n        }\\n        return out;\\n    }\\n\\n    /**\\n     * Copies an RLP item into bytes.\\n     * @param _in RLP item to copy.\\n     * @return Copied bytes.\\n     */\\n    function _copy(RLPItem memory _in) private pure returns (bytes memory) {\\n        return _copy(_in.ptr, 0, _in.length);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/rlp/Lib_RLPWriter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_RLPWriter\\n * @author Bakaoh (with modifications)\\n */\\nlibrary Lib_RLPWriter {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * RLP encodes a byte string.\\n     * @param _in The byte string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * RLP encodes a list of RLP encoded byte byte strings.\\n     * @param _in The list of RLP encoded byte strings.\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * RLP encodes a string.\\n     * @param _in The string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeString(string memory _in) internal pure returns (bytes memory) {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * RLP encodes an address.\\n     * @param _in The address to encode.\\n     * @return The RLP encoded address in bytes.\\n     */\\n    function writeAddress(address _in) internal pure returns (bytes memory) {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a uint.\\n     * @param _in The uint256 to encode.\\n     * @return The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a bool.\\n     * @param _in The bool to encode.\\n     * @return The RLP encoded bool in bytes.\\n     */\\n    function writeBool(bool _in) internal pure returns (bytes memory) {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\\n     * @param _len The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     * @return RLP encoded bytes.\\n     */\\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\\n            for (i = 1; i <= lenLen; i++) {\\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * Encode integer in big endian binary form with no leading zeroes.\\n     * @notice TODO: This should be optimized with assembly to save gas costs.\\n     * @param _x The integer to encode.\\n     * @return RLP encoded bytes.\\n     */\\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * Copies a piece of memory to another location.\\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\\n     * @param _dest Destination location.\\n     * @param _src Source location.\\n     * @param _len Length of memory to copy.\\n     */\\n    function _memcpy(\\n        uint256 _dest,\\n        uint256 _src,\\n        uint256 _len\\n    ) private pure {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask;\\n        unchecked {\\n            mask = 256**(32 - len) - 1;\\n        }\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * Flattens a list of byte strings into one byte string.\\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\\n     * @param _list List of byte strings to flatten.\\n     * @return The flattened byte string.\\n     */\\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly {\\n            flattenedPtr := add(flattened, 0x20)\\n        }\\n\\n        for (i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly {\\n                listPtr := add(item, 0x20)\\n            }\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/utils/Lib_BytesUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_BytesUtils\\n */\\nlibrary Lib_BytesUtils {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\\n        if (_start >= _bytes.length) {\\n            return bytes(\\\"\\\");\\n        }\\n\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {\\n        if (_bytes.length < 32) {\\n            bytes32 ret;\\n            assembly {\\n                ret := mload(add(_bytes, 32))\\n            }\\n            return ret;\\n        }\\n\\n        return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\\n    }\\n\\n    function toUint256(bytes memory _bytes) internal pure returns (uint256) {\\n        return uint256(toBytes32(_bytes));\\n    }\\n\\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n        bytes memory nibbles = new bytes(_bytes.length * 2);\\n\\n        for (uint256 i = 0; i < _bytes.length; i++) {\\n            nibbles[i * 2] = _bytes[i] >> 4;\\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\\n        }\\n\\n        return nibbles;\\n    }\\n\\n    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\\n        bytes memory ret = new bytes(_bytes.length / 2);\\n\\n        for (uint256 i = 0; i < ret.length; i++) {\\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/utils/Lib_Bytes32Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Lib_Byte32Utils\\n */\\nlibrary Lib_Bytes32Utils {\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to \\\"true.\\\"\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as a boolean.\\n     */\\n    function toBool(bytes32 _in) internal pure returns (bool) {\\n        return _in != 0;\\n    }\\n\\n    /**\\n     * Converts a boolean to a bytes32 value.\\n     * @param _in Input boolean value.\\n     * @return Boolean as a bytes32.\\n     */\\n    function fromBool(bool _in) internal pure returns (bytes32) {\\n        return bytes32(uint256(_in ? 1 : 0));\\n    }\\n\\n    /**\\n     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as an address.\\n     */\\n    function toAddress(bytes32 _in) internal pure returns (address) {\\n        return address(uint160(uint256(_in)));\\n    }\\n\\n    /**\\n     * Converts an address to a bytes32.\\n     * @param _in Input address value.\\n     * @return Address as a bytes32.\\n     */\\n    function fromAddress(address _in) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(_in)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/resolver/Lib_AddressManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/* External Imports */\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(string indexed _name, address _newAddress, address _oldAddress);\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    mapping(bytes32 => address) private addresses;\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Changes the address associated with a particular name.\\n     * @param _name String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(string memory _name, address _address) external onlyOwner {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(_name, _address, oldAddress);\\n    }\\n\\n    /**\\n     * Retrieves the address associated with a given name.\\n     * @param _name Name to retrieve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(string memory _name) external view returns (address) {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Computes the hash of a name.\\n     * @param _name Name to compute a hash for.\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_libAddressManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxTransactionGasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_l2GasDiscountDivisor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_enqueueGasCost\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes27\",\"name\":\"_globalMetadata\",\"type\":\"bytes27\"}],\"name\":\"BatchElementDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_object\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes27\",\"name\":\"_globalMetadata\",\"type\":\"bytes27\"}],\"name\":\"BatchPushed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_object\",\"type\":\"bytes32\"}],\"name\":\"BatchSetted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes27\",\"name\":\"_globalMetadata\",\"type\":\"bytes27\"}],\"name\":\"BatchesGlobalMetadataSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"l2GasDiscountDivisor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"enqueueGasCost\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"enqueueL2GasPrepaid\",\"type\":\"uint256\"}],\"name\":\"L2GasParamsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_startingQueueIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_numQueueElements\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalElements\",\"type\":\"uint256\"}],\"name\":\"QueueBatchAppended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes27\",\"name\":\"_globalMetadata\",\"type\":\"bytes27\"}],\"name\":\"QueueElementDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes27\",\"name\":\"_globalMetadata\",\"type\":\"bytes27\"}],\"name\":\"QueueGlobalMetadataSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"blockNumber\",\"type\":\"uint40\"}],\"indexed\":false,\"internalType\":\"struct Lib_OVMCodec.QueueElement\",\"name\":\"_object\",\"type\":\"tuple\"}],\"name\":\"QueuePushed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"blockNumber\",\"type\":\"uint40\"}],\"indexed\":false,\"internalType\":\"struct Lib_OVMCodec.QueueElement\",\"name\":\"_object\",\"type\":\"tuple\"}],\"name\":\"QueueSetted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_startingQueueIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_numQueueElements\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalElements\",\"type\":\"uint256\"}],\"name\":\"SequencerBatchAppended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_batchIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_batchRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_batchSize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prevTotalElements\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"TransactionBatchAppended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_l1TxOrigin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_queueIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"TransactionEnqueued\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_CHAINID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ROLLUP_TX_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_ROLLUP_TX_GAS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"appendSequencerBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"appendSequencerBatchByChainId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batches\",\"outputs\":[{\"internalType\":\"contract IChainStorageContainer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"bytes27\",\"name\":\"_globalMetadata\",\"type\":\"bytes27\"}],\"name\":\"deleteBatchElementsAfterInclusiveByChainId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"enqueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"enqueueByChainId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enqueueGasCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enqueueL2GasPrepaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getBatchByChainId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"getBatchGlobalMetadataByChainId\",\"outputs\":[{\"internalType\":\"bytes27\",\"name\":\"\",\"type\":\"bytes27\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastBlockNumber\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"getLastBlockNumberByChainId\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastTimestamp\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"getLastTimestampByChainId\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextQueueIndex\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"getNextQueueIndexByChainId\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumPendingQueueElements\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"getNumPendingQueueElementsByChainId\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getQueueElement\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"blockNumber\",\"type\":\"uint40\"}],\"internalType\":\"struct Lib_OVMCodec.QueueElement\",\"name\":\"_element\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getQueueElementByChainId\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"blockNumber\",\"type\":\"uint40\"}],\"internalType\":\"struct Lib_OVMCodec.QueueElement\",\"name\":\"_element\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getQueueLength\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"getQueueLengthByChainId\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBatches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalBatches\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"getTotalBatchesByChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalBatches\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalElements\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalElements\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"getTotalElementsByChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalElements\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2GasDiscountDivisor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"lengthBatchByChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"libAddressManager\",\"outputs\":[{\"internalType\":\"contract Lib_AddressManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_object\",\"type\":\"bytes32\"},{\"internalType\":\"bytes27\",\"name\":\"_globalMetadata\",\"type\":\"bytes27\"}],\"name\":\"pushBatchByChainId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"blockNumber\",\"type\":\"uint40\"}],\"internalType\":\"struct Lib_OVMCodec.QueueElement\",\"name\":\"_object\",\"type\":\"tuple\"}],\"name\":\"pushQueueByChainId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queue\",\"outputs\":[{\"internalType\":\"contract IChainStorageContainer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_object\",\"type\":\"bytes32\"}],\"name\":\"setBatchByChainId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes27\",\"name\":\"_globalMetadata\",\"type\":\"bytes27\"}],\"name\":\"setBatchGlobalMetadataByChainId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_l2GasDiscountDivisor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_enqueueGasCost\",\"type\":\"uint256\"}],\"name\":\"setGasParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"blockNumber\",\"type\":\"uint40\"}],\"internalType\":\"struct Lib_OVMCodec.QueueElement\",\"name\":\"_object\",\"type\":\"tuple\"}],\"name\":\"setQueueByChainId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CanonicalTransactionChain","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000918778e825747a892b17c66fe7d24c618262867d000000000000000000000000000000000000000000000000000000004190ab000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000ea60","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}