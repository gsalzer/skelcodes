{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/renderers/LineRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright 2021 David Huber (@cxkoda)\\n// All Rights Reserved\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"./ISvgRenderer.sol\\\";\\nimport \\\"./DynamicBufferAllocator.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\n/**\\n * @notice Implementation of `ISvgRenderer` based on cubic bezier curves.\\n * @dev The following unsafe characters will be % encoded in the resulting svg\\n * because the target use-case will be data-uris.\\n * <    %3C\\n * >    %3E\\n * #    %23\\n * %\\t%25\\n * See also https://codepen.io/tigt/post/optimizing-svgs-in-data-uris\\n * @author David Huber (@cxkoda)\\n */\\ncontract LineRenderer is ISvgRenderer, DynamicBufferAllocator {\\n    uint256 private constant skipBytes = 0x04;\\n\\n    /**\\n     * @dev Implementation of `ISvgRenderer.render` rendering cubic bezier lines.\\n     * Points will determing the l\\n     * The basic idea for assembling the svg is to group line segments with the\\n     * same color and add them to the same path svg element. In the end we will\\n     * therefore have 256 path elements.\\n     */\\n    function render(\\n        AttractorSolution calldata solution,\\n        bytes memory colormap,\\n        uint8 strokeWidth\\n    ) public pure override returns (string memory svg) {\\n        require(colormap.length == 768);\\n\\n        // Allocate buffer which we will later use to build up the svg\\n        {\\n            // 188B svg init/close + 75B per path + ~24B per point\\n            uint256 bufferSize = 188 +\\n                256 *\\n                75 +\\n                (solution.points.length / 4 + 256) *\\n                24;\\n            (, bytes memory _svg) = _allocate(bufferSize);\\n\\n            // Let's use a little trick here and use the allocated bytes buffer\\n            // for strings\\n            assembly {\\n                svg := _svg\\n            }\\n        }\\n\\n        // Preparing some (repeatedly used) svg fragments.\\n        // They cannot be stored in individual variables -> stack too deep\\n        bytes[5] memory collection = [\\n            // 0x00\\n            bytes(\\n                \\\"%3Csvg width='1024' height='1024' viewBox='-4096 -4096 8192 8192' xmlns='http://www.w3.org/2000/svg'%3E%3Crect x='-4096' y='-4096' width='100%25' height='100%25' fill='black'/%3E\\\"\\n            ),\\n            // 0x20\\n            bytes(\\\"%3Cpath d='M \\\"),\\n            // 0x40\\n            abi.encodePacked(\\n                \\\"' stroke-width='\\\",\\n                Strings.toString(strokeWidth),\\n                \\\"' stroke='%23\\\"\\n            ),\\n            // 0x60\\n            bytes(\\\"' fill='transparent'/%3E\\\"),\\n            // 0x80\\n            bytes(\\\"%3C/svg%3E\\\")\\n        ];\\n\\n        // Some handy aliases\\n        bytes memory points = solution.points;\\n        bytes memory tangents = solution.tangents;\\n\\n        assembly {\\n            /**\\n             * @notice Append data to a dynamic buffer.\\n             * See `DynamicBufferAllocator`.\\n             * @dev Adds `data_` at the end of the `buffer_` and increases\\n             * the length of the latter accordingly.\\n             * Warning! Container capacity checks were neglected for performance.\\n             */\\n            function appendBytes(buffer_, data_) {\\n                let length := mload(data_)\\n                for {\\n                    let data := add(data_, 32)\\n                    let dataEnd := add(data, length)\\n                    let buf := add(buffer_, add(mload(buffer_), 32))\\n                } lt(data, dataEnd) {\\n                    data := add(data, 32)\\n                    buf := add(buf, 32)\\n                } {\\n                    // Copy 32B chunks from data to buffer.\\n                    // This may read over data array boundaries and copy invalid\\n                    // bytes, which doesn't matter in the end since we will\\n                    // later set the correct buffer length.\\n                    mstore(buf, mload(data))\\n                }\\n\\n                // Update buffer length\\n                mstore(buffer_, add(mload(buffer_), length))\\n            }\\n\\n            /**\\n             * @notice Append a single byte to a dynamic buffer.\\n             * See `DynamicBufferAllocator`.\\n             * @dev Adds `data_` at the end of the `buffer_` and increases\\n             * the length of the latter by one.\\n             * Warning! Container capacity checks were neglected for performance.\\n             */\\n            function appendByte(buffer_, data) {\\n                let length := mload(buffer_)\\n                let buffer := add(buffer_, add(length, 32))\\n                mstore8(buffer, data)\\n                mstore(buffer_, add(length, 1))\\n            }\\n\\n            /**\\n             * @notice Convert an `int16` to its ASCII `byte` representation\\n             * @dev `value_` is converted and append it to `buffer_`.\\n             * See `DynamicBufferAllocator`.\\n             * Warning! Container capacity checks were neglected for performance.\\n             */\\n            function appendConvertedInt256(buffer_, value_) {\\n                // Init a local 32B buffer for the ascii string.\\n                // This is more than enough for the numbers we are dealing with\\n                let ascii := 0\\n\\n                // A counter for the amount of characters in ascii.\\n                let numCharacters := 0\\n\\n                // Check if `value_` is negative.\\n                let negative := slt(value_, 0)\\n\\n                // If so we need to add a minus sign later and continue with\\n                // the absolute value in the meantime.\\n                if negative {\\n                    // Compute and assign the abs value.\\n                    let tmp := sar(255, value_)\\n                    value_ := sub(xor(value_, tmp), tmp)\\n                }\\n\\n                // We treat `ascii` as byte string, meaning that we will fill it\\n                // from left to right. To build up the ascii string we start go\\n                // from the lowest to the highest decimal place.\\n                for {\\n                    let temp := value_\\n                } gt(temp, 0) {\\n                    // Divide number by 10 until nothing more is left.\\n                    temp := div(temp, 10)\\n                } {\\n                    // Read the following from the inside out.\\n\\n                    // Prepend the new digit to the string\\n                    ascii := or(\\n                        shr(8, ascii),\\n                        // Shift it all the way to the left 256-8\\n                        shl(\\n                            248,\\n                            // Digits start at ascii code 48\\n                            add(48, mod(temp, 10))\\n                        )\\n                    )\\n\\n                    numCharacters := add(numCharacters, 1)\\n                }\\n\\n                // If `value_` was zero, the previous code will do nothing.\\n                // Add zero manually in this case.\\n                if eq(numCharacters, 0) {\\n                    ascii := shl(248, 48)\\n                    numCharacters := 1\\n                }\\n\\n                // If `value_` was negative we need to prepend a minus.\\n                if negative {\\n                    ascii := or(shr(8, ascii), shl(248, 45)) // minus = ascii 45\\n                    numCharacters := add(numCharacters, 1)\\n                }\\n\\n                // Append the `ascii` string to the `buffer_`.\\n                let bufferSize := mload(buffer_)\\n                let bufferStart := add(add(buffer_, 0x20), bufferSize)\\n\\n                mstore(bufferStart, ascii)\\n\\n                // Update length of the `buffer_`.\\n                mstore(buffer_, add(bufferSize, numCharacters))\\n            }\\n\\n            /**\\n             * @notice Converts an RGB color to its HEX string\\n             * @param colormap Array of 256 8-bit RGB colors\\n             * @param idx Position of the color in the array to be converted\\n             * Warning! Container capacity checks were neglected for performance.\\n             */\\n            function appendColor(buffer_, colormap_, idx_) {\\n                // Load the color from the colormap\\n                // and shift to get rid of excess bits\\n                let color := shr(\\n                    232,\\n                    mload(add(add(colormap_, 0x20), mul(3, idx_)))\\n                )\\n\\n                // We will build up the hex string from right to left.\\n                // The final string will always have length 6, we therefore\\n                // already know at which `bufferPos` we have to start.\\n                for {\\n                    let iter := 0\\n                    let bufferPos := add(\\n                        add(buffer_, 0x20),\\n                        add(mload(buffer_), 5)\\n                    )\\n                } lt(iter, 6) {\\n                    iter := add(iter, 1)\\n                    bufferPos := sub(bufferPos, 1)\\n                    color := shr(4, color)\\n                } {\\n                    // In each iteration we convert the last 4 bits of the\\n                    // `color` to ascii hex. For the next iteration, we shift\\n                    // those 4 bits out and start again.\\n\\n                    let lastDigit := and(color, 0xf)\\n\\n                    // Check if the character will be a number (or letter)\\n                    let numeric := lt(lastDigit, 0xa)\\n\\n                    // Set the according character\\n                    if not(numeric) {\\n                        mstore8(bufferPos, add(87, lastDigit))\\n                    }\\n                    if numeric {\\n                        mstore8(bufferPos, add(48, lastDigit))\\n                    }\\n                }\\n\\n                // Update the buffer length.\\n                mstore(buffer_, add(mload(buffer_), 6))\\n            }\\n\\n            /**\\n             * @notice Appends a point and its right tangent (parallel to the\\n             * direction of the curve) to the svg.\\n             * @dev This routine is used only right after opening a new svg\\n             * path element. It will append `<x> <y> C <x+dx> <y+dy>`.\\n             * Warning! Container capacity checks were neglected for performance.\\n             */\\n            function appendPointAndRightTangent(posPoint, posTangent, svg_) {\\n                // Load the point from memory.\\n                let x\\n                let y\\n                {\\n                    // For this we read 256bit and shift away the ones that\\n                    // we don't need.\\n                    let tmp := mload(posPoint)\\n                    x := sar(240, tmp)\\n                    // Invert sign on y, due to svg coordinate layout.\\n                    y := sub(0, sar(240, shl(16, tmp)))\\n                }\\n\\n                appendConvertedInt256(svg_, x)\\n                appendByte(svg_, 32) // space\\n                appendConvertedInt256(svg_, y)\\n\\n                // Load the slopes from memory (same as above).\\n                let dx\\n                let dy\\n                {\\n                    let tmp := mload(posTangent)\\n                    dx := sar(240, tmp)\\n                    dy := sub(0, sar(240, shl(16, tmp)))\\n                }\\n\\n                // Add slopes to the point to get the right tangent\\n                dx := add(x, dx)\\n                dy := add(y, dy)\\n\\n                appendByte(svg_, 67) // C (svg curveto)\\n\\n                appendConvertedInt256(svg_, dx)\\n                appendByte(svg_, 32) // space\\n                appendConvertedInt256(svg_, dy)\\n            }\\n\\n            /**\\n             * @notice Appends a point and its left tangent (anti-parallel to\\n             * the direction of the curve) to the svg.\\n             * @dev This routine is used to add all remaining points to an open\\n             * svg path element. It will append `<x-dx> <y-dy>, <x> <y>`.\\n             * Warning! Container capacity checks were neglected for performance.\\n             */\\n            function appendLeftTangentAndPoint(posPoint, posTangent, svg_) {\\n                // Load the point from memory.\\n                let x\\n                let y\\n                {\\n                    // For this we read 256bit and shift away the ones that\\n                    // we don't need.\\n                    let tmp := mload(posPoint)\\n                    x := sar(240, tmp)\\n                    // Invert sign on y, due to svg coordinate layout.\\n                    y := sub(0, sar(240, shl(16, tmp)))\\n                }\\n\\n                {\\n                    // Load the slopes from memory (same as above).\\n                    let dx\\n                    let dy\\n                    {\\n                        let tmp := mload(posTangent)\\n                        dx := sar(240, tmp)\\n                        dy := sub(0, sar(240, shl(16, tmp)))\\n                    }\\n\\n                    // Add slopes to the point to get the left tangent\\n                    dx := sub(x, dx)\\n                    dy := sub(y, dy)\\n\\n                    appendConvertedInt256(svg_, dx)\\n                    appendByte(svg_, 32) // space\\n                    appendConvertedInt256(svg_, dy)\\n                    appendByte(svg_, 44) // comma\\n                }\\n\\n                appendConvertedInt256(svg_, x)\\n                appendByte(svg_, 32) // space\\n                appendConvertedInt256(svg_, y)\\n            }\\n\\n            // -------------------------\\n            //\\n            //  The actual work.\\n            //\\n            // -------------------------\\n\\n            // Append svg init (<svg ..) to the buffer\\n            appendBytes(svg, mload(collection))\\n\\n            // Compute the amount of points with the same color\\n            let nSameCol := div(mload(points), mul(skipBytes, 256))\\n\\n            // The outer loop iterates over colors (0-255).\\n            for {\\n                let colorIdx := 0\\n                let posPoint := add(points, 0x20)\\n                let posTangent := add(tangents, 0x20)\\n            } lt(colorIdx, 256) {\\n                colorIdx := add(colorIdx, 1)\\n            } {\\n                let iter := 0\\n\\n                appendBytes(svg, mload(add(collection, 0x20))) // Path init\\n                appendPointAndRightTangent(posPoint, posTangent, svg)\\n\\n                iter := add(iter, 1)\\n                posPoint := add(posPoint, skipBytes)\\n                posTangent := add(posTangent, skipBytes)\\n\\n                appendByte(svg, 44) // ,\\n                appendLeftTangentAndPoint(posPoint, posTangent, svg)\\n\\n                // The inner loop iterates over points with the same color\\n                for {\\n\\n                } lt(iter, nSameCol) {\\n\\n                } {\\n                    iter := add(iter, 1)\\n                    posPoint := add(posPoint, skipBytes)\\n                    posTangent := add(posTangent, skipBytes)\\n\\n                    appendByte(svg, 83) // S (svg smooth curveto)\\n                    appendLeftTangentAndPoint(posPoint, posTangent, svg)\\n                }\\n\\n                appendBytes(svg, mload(add(collection, 0x40))) // Path midpart\\n                appendColor(svg, colormap, colorIdx)\\n                appendBytes(svg, mload(add(collection, 0x60))) // Path end\\n            }\\n\\n            appendBytes(svg, mload(add(collection, 0x80))) // Svg end\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/ISvgRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright 2021 David Huber (@cxkoda)\\n// All Rights Reserved\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"../solvers/AttractorSolution.sol\\\";\\n\\n/**\\n * @notice Renders a solution of an attractor simulation as SVG\\n * @author David Huber (@cxkoda)\\n */\\ninterface ISvgRenderer {\\n    /**\\n     * @notice Renders a list of 2D points and tangents as svg\\n     * @param solution List of 16-bit fixed-point points and tangents. \\n     * See `AttractorSolution`.\\n     * @param colormap 256 8-bit RGB colors. Leaving this in memory for easier\\n     * access in assembly later.\\n     * @param markerSize A modifier for marker sizes (e.g. stroke width, \\n     * point size)\\n     * @return The generated svg string. The viewport covers the area \\n     * [-64, 64] x [-64, 64] by convention.\\n     */\\n    function render(\\n        AttractorSolution calldata solution,\\n        bytes memory colormap,\\n        uint8 markerSize\\n    ) external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/renderers/DynamicBufferAllocator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright 2021 David Huber (@cxkoda)\\n// All Rights Reserved\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @notice Allocation of a dynamically resizable byte container.\\n * @author David Huber (@cxkoda)\\n */\\ncontract DynamicBufferAllocator {\\n    /**\\n     * @notice Allocates a byte buffer container with a given max capacity.\\n     * @dev In solidity, the first 32B in dynamic arrays are always reserved\\n     * @dev for the length of the array. This tells consumers for how long they\\n     * @dev have to read the memory. \\n     * @dev Here we allocate a container that contains the memory layout of \\n     * @dev another dynamic array (buffer), whose length we will continuously\\n     * @dev increase as we append data to it.\\n     * @dev This has the advantage that solidity can directly interpret the data\\n     * @dev from the buffer position in memory as a standard array.\\n     * @dev | container length (32B) | buffer length = s (32B) | buffer data (s B) | ... |\\n     */\\n    function _allocate(uint256 capacity)\\n        internal\\n        pure\\n        returns (bytes memory container, bytes memory buffer)\\n    {\\n        assembly {\\n            // Get next-free memory address\\n            container := mload(0x40)\\n\\n            // Allocate memory by setting a new next-free address\\n            {\\n                // Add 2 x 32 bytes in size for the two length fields\\n                let size := add(capacity, 0x40)\\n                let newNextFree := add(container, size)\\n                mstore(0x40, newNextFree)\\n            }\\n\\n            // Set the correct container length\\n            {\\n                let length := add(capacity, 0x40)\\n                mstore(container, length)\\n            }\\n\\n            // The buffer starts at idx 1 in the container (0 is length)\\n            buffer := add(container, 0x20)\\n\\n            // Init content with length 0\\n            mstore(buffer, 0)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/solvers/AttractorSolution.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// Copyright 2021 David Huber (@cxkoda)\\n// All Rights Reserved\\n\\npragma solidity >=0.8.0 <0.9.0;\\n\\n/**\\n * @notice The data struct that will be passed from the solver to the renderer.\\n * @dev `points` and `tangents` both contain pairs of 16-bit fixed-point numbers\\n * with a PRECISION of 6 in row-major order.`dt` is given in the fixed-point\\n * respresentation used by the solvers and corresponds to the time step between \\n * the datapoints.\\n */\\nstruct AttractorSolution {\\n    bytes points;\\n    bytes tangents;\\n    uint256 dt;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"points\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"tangents\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"dt\",\"type\":\"uint256\"}],\"internalType\":\"struct AttractorSolution\",\"name\":\"solution\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"colormap\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"strokeWidth\",\"type\":\"uint8\"}],\"name\":\"render\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"svg\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"LineRenderer","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}