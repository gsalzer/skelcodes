{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n NFT BlockStore \r\n\r\n Made with <3 by InfernalToast \r\n*/\r\n \r\n \r\n interface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n       /// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n       ///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\r\n       interface ERC721 /* is ERC165 */ {\r\n           /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n           ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n           ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n           ///  may be created and assigned without emitting Transfer. At the time of\r\n           ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n           event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n           /// @dev This emits when the approved address for an NFT is changed or\r\n           ///  reaffirmed. The zero address indicates there is no approved address.\r\n           ///  When a Transfer event emits, this also indicates that the approved\r\n           ///  address for that NFT (if any) is reset to none.\r\n           event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n           /// @dev This emits when an operator is enabled or disabled for an owner.\r\n           ///  The operator can manage all NFTs of the owner.\r\n           event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n           /// @notice Count all NFTs assigned to an owner\r\n           /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n           ///  function throws for queries about the zero address.\r\n           /// @param _owner An address for whom to query the balance\r\n           /// @return The number of NFTs owned by `_owner`, possibly zero\r\n           function balanceOf(address _owner) external view returns (uint256);\r\n\r\n           /// @notice Find the owner of an NFT\r\n           /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n           ///  about them do throw.\r\n           /// @param _tokenId The identifier for an NFT\r\n           /// @return The address of the owner of the NFT\r\n           function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n           /// @notice Transfers the ownership of an NFT from one address to another address\r\n           /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n           ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n           ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n           ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n           ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n           ///  `onERC721Received` on `_to` and throws if the return value is not\r\n           ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n           /// @param _from The current owner of the NFT\r\n           /// @param _to The new owner\r\n           /// @param _tokenId The NFT to transfer\r\n           /// @param data Additional data with no specified format, sent in call to `_to`\r\n           function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n\r\n           /// @notice Transfers the ownership of an NFT from one address to another address\r\n           /// @dev This works identically to the other function with an extra data parameter,\r\n           ///  except this function just sets data to \"\"\r\n           /// @param _from The current owner of the NFT\r\n           /// @param _to The new owner\r\n           /// @param _tokenId The NFT to transfer\r\n           function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n           /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n           ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n           ///  THEY MAY BE PERMANENTLY LOST\r\n           /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n           ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n           ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n           ///  `_tokenId` is not a valid NFT.\r\n           /// @param _from The current owner of the NFT\r\n           /// @param _to The new owner\r\n           /// @param _tokenId The NFT to transfer\r\n           function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n           /// @notice Set or reaffirm the approved address for an NFT\r\n           /// @dev The zero address indicates there is no approved address.\r\n           /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n           ///  operator of the current owner.\r\n           /// @param _approved The new approved NFT controller\r\n           /// @param _tokenId The NFT to approve\r\n           function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n           /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n           ///  all of `msg.sender`'s assets.\r\n           /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n           ///  multiple operators per owner.\r\n           /// @param _operator Address to add to the set of authorized operators.\r\n           /// @param _approved True if the operator is approved, false to revoke approval\r\n           function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n           /// @notice Get the approved address for a single NFT\r\n           /// @dev Throws if `_tokenId` is not a valid NFT\r\n           /// @param _tokenId The NFT to find the approved address for\r\n           /// @return The approved address for this NFT, or the zero address if there is none\r\n           function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n           /// @notice Query if an address is an authorized operator for another address\r\n           /// @param _owner The address that owns the NFTs\r\n           /// @param _operator The address that acts on behalf of the owner\r\n           /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n           function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n       }\r\n\r\n       interface ERC165 {\r\n           /// @notice Query if a contract implements an interface\r\n           /// @param interfaceID The interface identifier, as specified in ERC-165\r\n           /// @dev Interface identification is specified in ERC-165. This function\r\n           ///  uses less than 30,000 gas.\r\n           /// @return `true` if the contract implements `interfaceID` and\r\n           ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n           function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n       }\r\n\r\n       interface ERC721TokenReceiver {\r\n           /// @notice Handle the receipt of an NFT\r\n           /// @dev The ERC721 smart contract calls this function on the\r\n           /// recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n           /// of other than the magic value MUST result in the transaction being reverted.\r\n           /// @notice The contract address is always the message sender.\r\n           /// @param _operator The address which called `safeTransferFrom` function\r\n           /// @param _from The address which previously owned the token\r\n           /// @param _tokenId The NFT identifier which is being transferred\r\n           /// @param _data Additional data with no specified format\r\n           /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n           /// unless throwing\r\n           function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n        }\r\n        \r\n        interface ProjectBasedNFT {\r\n            function tokenIdToProjectId(uint256 tokenId) external returns(uint256);\r\n        }\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\n// Owned contract\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n\r\n    address public newOwner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n\r\n    constructor() public {\r\n\r\n        owner = msg.sender;\r\n\r\n    }\r\n\r\n\r\n    modifier onlyOwner {\r\n\r\n        require(msg.sender == owner);\r\n\r\n        _;\r\n\r\n    }\r\n\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n\r\n        newOwner = _newOwner;\r\n\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n\r\n        require(msg.sender == newOwner);\r\n\r\n        emit OwnershipTransferred(owner, newOwner);\r\n\r\n        owner = newOwner;\r\n\r\n        newOwner = address(0);\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes memory sig) internal  pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n/*\r\n\r\n  An NFT exchange for ERC721 tokens \r\n\r\n  Supports offchain sell orders \r\n\r\n  Supports offchain buy orders \r\n \r\n*/\r\n\r\ncontract BlockStore is Owned, ECRecovery  {\r\n \r\n    \r\n  mapping (address => mapping(bytes32 => uint)) public burnedNonces; \r\n    \r\n  \r\n\r\n  mapping(address => uint256) public _fee_pct;\r\n  mapping(address => bool) public _allowedNFTContractAddress;\r\n\r\n  address constant internal NATIVE_ETH = 0x0000000000000000000000000000000000000010;\r\n \r\n  mapping (address => uint256) userSellOrderNonce; \r\n                                         \r\n \r\n  constructor(  ) public { \r\n   \r\n  }\r\n\r\n  function setFee( address projectContract, uint fee_pct ) public onlyOwner { \r\n    require(fee_pct >= 0 && fee_pct <=1000);\r\n\r\n    _fee_pct[projectContract] = fee_pct; \r\n  }\r\n\r\n\r\n\r\n  function setProjectAllowed( address projectContract, bool allow ) public onlyOwner { \r\n    \r\n    _allowedNFTContractAddress[projectContract] = allow; \r\n  }\r\n\r\n\r\n  //Do not allow ETH to enter\r\n  receive() external payable {\r\n    revert();\r\n  }\r\n\r\n  fallback() external payable {\r\n    revert();\r\n  }\r\n\r\n  function getChainID() public view returns (uint256) {\r\n    uint256 id;\r\n    assembly {\r\n        id := chainid()\r\n    }\r\n    return id;\r\n  }\r\n  \r\n  \r\n   \r\n  event nftSale(address sellerAddress, address buyerAddress, address nftContractAddress, uint256 nftTokenId, address currencyTokenAddress, uint256 currencyTokenAmount);\r\n  \r\n  event nonceBurned(address indexed signer, bytes32 nonce);\r\n\r\n  struct OffchainOrder {\r\n   \r\n    address orderCreator;\r\n    bool isSellOrder;  //if false then its a buy order \r\n\r\n    address nftContractAddress;\r\n    uint256 nftTokenId;\r\n\r\n    address currencyTokenAddress; //if 0x10 that means eth \r\n    uint256 currencyTokenAmount;\r\n    \r\n    bytes32 nonce;//only used for sell orders and is random, used by front end to group offchain orders together \r\n    uint256 expires; \r\n  }\r\n \r\n  \r\n     bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n          \"EIP712Domain(string contractName,string version,uint256 chainId,address verifyingContract)\"\r\n      );\r\n\r\n   function getBidDomainTypehash() public pure returns (bytes32) {\r\n      return EIP712DOMAIN_TYPEHASH;\r\n   }\r\n\r\n   function getEIP712DomainHash(string memory contractName, string memory version, uint256 chainId, address verifyingContract) public pure returns (bytes32) {\r\n\r\n      return keccak256(abi.encode(\r\n            EIP712DOMAIN_TYPEHASH,\r\n            keccak256(bytes(contractName)),\r\n            keccak256(bytes(version)),\r\n            chainId,\r\n            verifyingContract\r\n        ));\r\n    }\r\n \r\n\r\n  bytes32 constant ORDER_TYPEHASH = keccak256(  \r\n    \"OffchainOrder(address orderCreator,bool isSellOrder,address nftContractAddress,uint256 nftTokenId,address currencyTokenAddress,uint256 currencyTokenAmount,bytes32 nonce,uint256 expires)\"\r\n  );\r\n\r\n  \r\n\r\n\r\n  function getOrderTypehash()  public pure returns (bytes32) {\r\n      return ORDER_TYPEHASH;\r\n  }\r\n\r\n\r\n  \r\n  function getOrderHash(address orderCreator,bool isSellOrder,address nftContractAddress,uint256 nftTokenId,address currencyTokenAddress, uint256 currencyTokenAmount,bytes32 nonce,uint256 expires) public pure returns (bytes32) {\r\n          return keccak256(abi.encode(\r\n              ORDER_TYPEHASH,\r\n              orderCreator,\r\n              isSellOrder,\r\n              nftContractAddress,\r\n              nftTokenId,\r\n              currencyTokenAddress,\r\n              currencyTokenAmount,\r\n              nonce,\r\n              expires\r\n          ));\r\n      }\r\n\r\n \r\n\r\n  function getOrderTypedDataHash(address orderCreator,bool isSellOrder,address nftContractAddress,uint256 nftTokenId,address currencyTokenAddress, uint256 currencyTokenAmount,bytes32 nonce,uint256 expires) public view returns (bytes32) {\r\n \r\n              bytes32 digest = keccak256(abi.encodePacked(\r\n                  \"\\x19\\x01\",\r\n                  getEIP712DomainHash('BlockStore','1',getChainID(),address(this)),\r\n                  getOrderHash(orderCreator,isSellOrder,nftContractAddress,nftTokenId,currencyTokenAddress,currencyTokenAmount,nonce,expires)\r\n              ));\r\n              return digest;\r\n          }\r\n  \r\n\r\n  //require pre-approval from the buyer in the form of a personal sign of an offchain buy order \r\n  function sellNFTUsingBuyOrder(address buyer, address nftContractAddress, uint256 nftTokenId, address currencyToken, uint256 currencyAmount, bytes32 nonce, uint256 expires, bytes memory buyerSignature) public returns (bool){\r\n\r\n      require(_allowedNFTContractAddress[nftContractAddress],'Project not allowed');\r\n\r\n      //require personalsign from buyer to be submitted by seller  \r\n      bytes32 sigHash = getOrderTypedDataHash(buyer,false,nftContractAddress,nftTokenId,currencyToken,currencyAmount,nonce,expires);\r\n \r\n       \r\n      require(buyer ==  recover(sigHash,buyerSignature) , 'Invalid signature');\r\n         \r\n      \r\n      require(block.number < expires || expires == 0, 'bid expired');\r\n\r\n      require(burnedNonces[buyer][nonce] == 0, 'nonce already burned');\r\n      burnedNonces[buyer][nonce] = 0x1;\r\n       \r\n      \r\n      ERC721(nftContractAddress).safeTransferFrom(msg.sender, buyer, nftTokenId);\r\n      \r\n      _transferCurrencyForSale(buyer,msg.sender,currencyToken,currencyAmount,_fee_pct[nftContractAddress]);\r\n      \r\n      \r\n      emit nftSale(msg.sender, buyer,  nftContractAddress, nftTokenId, currencyToken, currencyAmount);\r\n      emit nonceBurned(buyer, nonce);\r\n\r\n      return true;\r\n  }\r\n\r\n\r\n  function buyNFTUsingSellOrder(address seller, address nftContractAddress, uint256 nftTokenId, address currencyToken, uint256 currencyAmount, bytes32 nonce, uint256 expires, bytes memory sellerSignature) payable public returns (bool){\r\n\r\n      require(_allowedNFTContractAddress[nftContractAddress],'Project not allowed');\r\n\r\n\r\n      //require personalsign from seller to be submitted by buyer  \r\n      bytes32 sigHash = getOrderTypedDataHash(seller,true,nftContractAddress,nftTokenId,currencyToken,currencyAmount,nonce,expires);\r\n\r\n      \r\n       \r\n      require(seller == recover(sigHash,sellerSignature), 'Invalid signature');\r\n       \r\n      \r\n      require(block.number < expires || expires == 0, 'bid expired');\r\n     \r\n      require(burnedNonces[seller][nonce] == 0, 'nonce already burned');\r\n      burnedNonces[seller][nonce] = 0x1;\r\n       \r\n      \r\n      ERC721(nftContractAddress).safeTransferFrom(seller, msg.sender, nftTokenId);\r\n      \r\n      _transferCurrencyForSale(msg.sender,seller,currencyToken,currencyAmount,_fee_pct[nftContractAddress]);\r\n      \r\n      \r\n      emit nftSale(  seller,  msg.sender, nftContractAddress, nftTokenId, currencyToken, currencyAmount);\r\n      emit nonceBurned(seller, nonce);\r\n\r\n      return true;\r\n  }\r\n  \r\n  function _transferCurrencyForSale(address from, address to, address currencyToken, uint256 currencyAmount, uint256 feePct) internal returns (bool){\r\n    uint256 feeAmount = (currencyAmount * feePct)/(10000);\r\n\r\n    if(currencyToken == NATIVE_ETH){  \r\n      require(msg.value == currencyAmount,'incorrect payment value'); \r\n      payable(to).transfer( currencyAmount - (feeAmount) );\r\n      payable(owner).transfer( feeAmount );\r\n    }else{\r\n      require(msg.value == 0,'incorrect payment value'); \r\n      require( IERC20(currencyToken).transferFrom(from, to, currencyAmount - (feeAmount) ), 'unable to pay' );\r\n      require( IERC20(currencyToken).transferFrom(from, owner, feeAmount ), 'unable to pay'  ); \r\n    }\r\n    \r\n    return true;\r\n  } \r\n  \r\n   \r\n  function cancelOffchainOrder(address orderCreator, bool isSellOrder, address nftContractAddress, uint256 nftTokenId, address currencyToken, uint256 currencyAmount, bytes32 nonce, uint256 expires, bytes memory offchainSignature ) public returns (bool){\r\n      bytes32 sigHash = getOrderTypedDataHash(orderCreator,isSellOrder,nftContractAddress,nftTokenId,currencyToken,currencyAmount,nonce,expires);\r\n      address recoveredSignatureSigner = recover(sigHash,offchainSignature);\r\n      \r\n      require(orderCreator == recoveredSignatureSigner, 'Invalid signature');\r\n      require(msg.sender == recoveredSignatureSigner, 'Not signature owner');\r\n\r\n\r\n      require(burnedNonces[orderCreator][nonce] == 0, 'Nonce already burned');\r\n      burnedNonces[orderCreator][nonce] = 0x2;\r\n        \r\n      emit nonceBurned(orderCreator, nonce);\r\n      \r\n      return true;\r\n  }\r\n  \r\n  \r\n  \r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sellerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currencyTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currencyTokenAmount\",\"type\":\"uint256\"}],\"name\":\"nftSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"nonceBurned\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_allowedNFTContractAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_fee_pct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"burnedNonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currencyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"sellerSignature\",\"type\":\"bytes\"}],\"name\":\"buyNFTUsingSellOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"orderCreator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSellOrder\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currencyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"offchainSignature\",\"type\":\"bytes\"}],\"name\":\"cancelOffchainOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBidDomainTypehash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"verifyingContract\",\"type\":\"address\"}],\"name\":\"getEIP712DomainHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"orderCreator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSellOrder\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currencyTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"}],\"name\":\"getOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"orderCreator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSellOrder\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currencyTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"}],\"name\":\"getOrderTypedDataHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOrderTypehash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"currencyToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"buyerSignature\",\"type\":\"bytes\"}],\"name\":\"sellNFTUsingBuyOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"projectContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fee_pct\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"projectContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allow\",\"type\":\"bool\"}],\"name\":\"setProjectAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"BlockStore","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://158c81f9697cca17395f4f8cb4a63acd62936987dff8307fb3bd3c3c751683a2"}]}