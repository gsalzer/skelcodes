{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/VerifierExit.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./KeysWithPlonkSingleVerifier.sol\\\";\\n\\n// Hardcoded constants to avoid accessing store\\ncontract VerifierExit is KeysWithPlonkSingleVerifier {\\n\\n    function initialize(bytes calldata) external {\\n    }\\n\\n    /// @notice VerifierExit contract upgrade. Can be external because Proxy contract intercepts illegal calls of this function.\\n    /// @param upgradeParameters Encoded representation of upgrade parameters\\n    function upgrade(bytes calldata upgradeParameters) external {}\\n\\n    function verifyExitProof(\\n        bytes32 _rootHash,\\n        uint32 _accountId,\\n        address _owner,\\n        uint16 _tokenId,\\n        uint128 _amount,\\n        uint256[] calldata _proof\\n    ) external view returns (bool) {\\n        bytes32 commitment = sha256(abi.encodePacked(_rootHash, _accountId, _owner, _tokenId, _amount));\\n\\n        uint256[] memory inputs = new uint256[](1);\\n        uint256 mask = (~uint256(0)) >> 3;\\n        inputs[0] = uint256(commitment) & mask;\\n        Proof memory proof = deserialize_proof(inputs, _proof);\\n        VerificationKey memory vk = getVkExit();\\n        require(vk.num_inputs == inputs.length);\\n        return verify(proof, vk);\\n    }\\n\\n\\n    function verifyExitNFTProof(\\n        bytes32 _rootHash,\\n        uint64 _tokenId,\\n        uint32 _creatorId,\\n        uint32 _seqId,\\n        bytes32 _uri,\\n        address _owner,\\n        uint256[] calldata _proof\\n    ) external view returns (bool) {\\n        bytes32 commitment = sha256(abi.encodePacked(_rootHash, _tokenId, _creatorId, _seqId, _uri, _owner));\\n\\n        uint256[] memory inputs = new uint256[](1);\\n        uint256 mask = (~uint256(0)) >> 3;\\n        inputs[0] = uint256(commitment) & mask;\\n        Proof memory proof = deserialize_proof(inputs, _proof);\\n        VerificationKey memory vk = getVkNFTExit();\\n        require(vk.num_inputs == inputs.length);\\n        return verify(proof, vk);\\n    }\\n\\n    function concatBytes(bytes memory param1, bytes memory param2) public pure returns (bytes memory) {\\n        bytes memory merged = new bytes(param1.length + param2.length);\\n\\n        uint k = 0;\\n        for (uint i = 0; i < param1.length; i++) {\\n            merged[k] = param1[i];\\n            k++;\\n        }\\n\\n        for (uint i = 0; i < param2.length; i++) {\\n            merged[k] = param2[i];\\n            k++;\\n        }\\n        return merged;\\n    }\\n\\n    function verifyLpExitProof(\\n        bytes calldata _account_data,\\n        bytes calldata _pair_data0,\\n        bytes calldata _pair_data1,\\n        uint256[] calldata _proof\\n    ) external view returns (bool) {\\n        bytes memory _data1 = concatBytes(_account_data, _pair_data0);\\n        bytes memory _data2 = concatBytes(_data1, _pair_data1);\\n        bytes32 commitment = sha256(_data2);\\n\\n        uint256[] memory inputs = new uint256[](1);\\n        uint256 mask = (~uint256(0)) >> 3;\\n        inputs[0] = uint256(commitment) & mask;\\n        Proof memory proof = deserialize_proof(inputs, _proof);\\n        VerificationKey memory vk = getVkLpExit();\\n        require(vk.num_inputs == inputs.length);\\n        return verify(proof, vk);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/KeysWithPlonkSingleVerifier.sol\": {\r\n      \"content\": \"\\npragma solidity >=0.5.0 <0.7.0;\\n\\nimport \\\"./PlonkSingleCore.sol\\\";\\n\\n// Hardcoded constants to avoid accessing store\\ncontract KeysWithPlonkSingleVerifier is SingleVerifierWithDeserialize {\\n\\n    function isBlockSizeSupportedInternal(uint32 _size) internal pure returns (bool) {\\n        if (_size == uint32(12)) { return true; }\\n        else if (_size == uint32(36)) { return true; }\\n        else if (_size == uint32(78)) { return true; }\\n        else if (_size == uint32(156)) { return true; }\\n        else if (_size == uint32(318)) { return true; }\\n        else { return false; }\\n    }\\n\\n    \\n    function getVkExit() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 262144;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x0f60c8fe0414cb9379b2d39267945f6bd60d06a05216231b26a9fcf88ddbfebe);\\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\\n            0x135a8971e309397099f1c5c0b9c2a141e83b888ff0504ba8c9a7c13b8c66873f,\\n            0x0eed3feed06aa8e4d3493aefd4c6f9a6c337e20b7e2f20d22b08b3b4129f8efc\\n        );\\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\\n            0x0b97dc8947583759347e13c8f2abdccf1004e13f771fe9c46155af71d336de2e,\\n            0x1d39ffdb681fca7ce01b775e9aaaf5d8b71d9b7602ac00c60bbde91dca816dec\\n        );\\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\\n            0x04b4d20919f8c66794a986ad27a0e4e820fb7a1bf863048017a59b1f7b3030f6,\\n            0x2da162d6902e64de2d4f6178f090bf9db7fbb9199d1640d5eab9c0a26869524f\\n        );\\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\\n            0x242d28e776c833130fb04fb097c1c166c4293018e64947c46086f1bea2184732,\\n            0x277463020cda47c42366610a37cde00ef3a32b44906e1adee02fcd66bbe44a75\\n        );\\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\\n            0x24d289d00964c5501b4a32521df5685264fb490a4549e794f998f18f169f3195,\\n            0x14307765ce1383efab72009df36fd97d28b94c9c1fce57a64697e5633d8d4e0d\\n        );\\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\\n            0x0c3697df5aef9952def7b12d29447e9ae12fe6580f0e00399237bee51a5fa0e0,\\n            0x2b120b7d414a0843aa2e9e606bcec5ff8eb3c38d8b73479de42fc8901bb626e6\\n        );\\n\\n        // we only have access to value of the d(x) witness polynomial on the next\\n        // trace step, so we only need one element here and deal with it in other places\\n        // by having this in mind\\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x0e09a50a8e0635250a3a200dab94a1a51de811b179f61df2d4683e59fd1774ee,\\n            0x251732ea6c2951b7b54f2dbc349b14db2b63def8d132f86499d2e43edc21ad51\\n        );\\n\\n         vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x1889e41a3cebf0b097ec6cef8849e66480c344c422ed9a2e4d63fe75155af0d0,\\n            0x0ed098f479a2f229cd47f645517737f512612915010cb576398cd4ec7c803baf\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x141171280664b7aea2c65ddb87f28391cab60913a74f4255b3dd4295d162a02c,\\n            0x033c1cc5f1e58a035eb5f3951e79cc90e9fccf3c82781c2553b1d49694a18991\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x0fc9a25cc839ef11afab0a9f320cf2b7346054f566135611bb25b6cec46205b3,\\n            0x16ea53198b77ab1e469d166b36d89d9fd88b3c356958cdf377a534d73f47a9a3\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x2040345b5f92cc70a9607cf5fc28e5be26f673852450488d4e65f70890649b45,\\n            0x2c0e0bf512b4aa690449b589513e2b34cbc5e748a4217947331e0350c73be310\\n        );\\n\\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n             0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n             0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkLpExit() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 524288;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x0cf1526aaafac6bacbb67d11a4077806b123f767e4b0883d14cc0193568fc082);\\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\\n            0x26aafba448a6c22abfa5286eef01b17a6bffaacf20a8a0fca1a59035c8e45ddd,\\n            0x160835d2c20ea81f2f4c2c7f1644e30ae41b2541588a27552c08c190d5b32af8\\n        );\\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\\n            0x20954e6cd2ad660dd9723263311b03986d6f8993ebfeb67a60a46608b35701fe,\\n            0x059ce6f6469bb72b8758473f86e86a959c4b9f74193d931dd172883c641a25c7\\n        );\\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\\n            0x26245ff891a4328caa0da951efba1b5b3cc13136cd315ac7c8794053e47a4315,\\n            0x1681b7685491b5f8fb470a21a326bc91bd75178d411ead030aefcddd9b51bd06\\n        );\\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\\n            0x2857e4543592da2693e7e97477f186736c4a0a325bd9477bbd996819dc0ca4ce,\\n            0x0ffe00e34dd8592675469bb7a92b1e78e7c9e4ace22343605fb3a48dd4f15970\\n        );\\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\\n            0x0180059910e776f202efcb1b96d72ab597e811caef2a9af5d8b42fc79949d913,\\n            0x1a43d65fba7b7340f6cb120a31ad0a1d5a26e0a1151398d9a80d6930e623be21\\n        );\\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\\n            0x007b755d547d62eaf1375f3efe8a62ef52ed1b40ef2ec0943ab9a1de7198f274,\\n            0x28f96cb876dc97aada23aa73d202682e3f29a29126d5711df0747234660cd83d\\n        );\\n\\n        // we only have access to value of the d(x) witness polynomial on the next\\n        // trace step, so we only need one element here and deal with it in other places\\n        // by having this in mind\\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x00dfc41dc088a145be5a6978121abea7dffaef90012b9d6f1b577e957a28dd24,\\n            0x2ef1b64e6b0afe751b5531869a17dd9d5c90d734880de7fed3d3ae74a01d989a\\n        );\\n\\n         vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x1d69be00b5e7d9d2af9d10da25eda41333effe6b9435caefe07ddae096d30ddf,\\n            0x162137b0ead7f1be6f448f36db186c5bee0e44f19a926e88b53f7760b64e9dbd\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x179c8e2df764ec8a2a5f5dbd37ffdde057178b6c10ef04bbb3331a7843934331,\\n            0x1a71e27ade54b801c811bd10d93c2b9e6c80bfea3d808487cf375f50e065e896\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x2fc48aa7bcba72e922843e8732398afe655368a3aedca1f204b0e1bd9ddbf981,\\n            0x2f6adc4261e3dd2fc80affdb39de386de5c38aa0066a8560f76dff220341071a\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x2a096bb764588fb3f422291918e33c1d8d9f5a8ef6c9cf41d288a5ddea0cf26a,\\n            0x1e2ab7435be44f4101b1af83f76d5b621f4ecdd9d673a4b019ffb41072413f9b\\n        );\\n\\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n             0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n             0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n    function getVkNFTExit() internal pure returns(VerificationKey memory vk) {\\n        vk.domain_size = 262144;\\n        vk.num_inputs = 1;\\n        vk.omega = PairingsBn254.new_fr(0x0f60c8fe0414cb9379b2d39267945f6bd60d06a05216231b26a9fcf88ddbfebe);\\n        vk.selector_commitments[0] = PairingsBn254.new_g1(\\n            0x27ad08e12b6087f6fe0d7e1d8d8f14f53e92aaabf05e4f7d1051b0fbe3db046d,\\n            0x11f1f49ccf9f433366c3dc71fe9efa794678b87cbb2b07deea0cfbb7093e5369\\n        );\\n        vk.selector_commitments[1] = PairingsBn254.new_g1(\\n            0x1ee701b0be61332b7de5d4260ad352a3f50a8e51ac4a761f6ab5077c8dffab51,\\n            0x21451115294a50d06c5c442e9a61b04699fd8f296e70ef00e78a5908ef541444\\n        );\\n        vk.selector_commitments[2] = PairingsBn254.new_g1(\\n            0x1eccd5e119cc4a7bc8d274e0d8f61a054ee38694796790dacd22a098642bf2bc,\\n            0x10bb95ce678a633560f0a704001e4c148aff47b7aee0856bfec735fb13884e02\\n        );\\n        vk.selector_commitments[3] = PairingsBn254.new_g1(\\n            0x013fa8820794811964f35f04adb7600a9a3c76c9960b9cbb162b8324e09a14f5,\\n            0x0c110889cdf3554c95c7876f3e9d64804b3f0a6effa2baaf8bcb4ca847e5ed1d\\n        );\\n        vk.selector_commitments[4] = PairingsBn254.new_g1(\\n            0x1d5d922608eb262a5b05dc872b81238a352ba3521a1e847b06606d0937c7a34c,\\n            0x291cd60f7f242bd5e1075f99ed70583f40460758aa58c8cd418cb5b6929e8c12\\n        );\\n        vk.selector_commitments[5] = PairingsBn254.new_g1(\\n            0x2bc438c9650f27fd6b4125e098c5d87f874cfd29efad4a3e4ecae04e23b05009,\\n            0x283af270ef1c1c897e85b844536745dbf4d744f2e0fe8dc113143b5209a60baa\\n        );\\n\\n        // we only have access to value of the d(x) witness polynomial on the next\\n        // trace step, so we only need one element here and deal with it in other places\\n        // by having this in mind\\n        vk.next_step_selector_commitments[0] = PairingsBn254.new_g1(\\n            0x16f50151d8dccdd5e06a29eee62a9f614d534c542640bee31e9e9a3f2b708a83,\\n            0x120854cacf85957ca9777576bda620a21312769ab9596c7c64dc742156839882\\n        );\\n\\n         vk.permutation_commitments[0] = PairingsBn254.new_g1(\\n            0x27d2cd3c7a778fed777f6410fca3a65521282818e187e901827b1e666281d38b,\\n            0x1f5484c3976cadaea11704759c33ecfffe4900b696febcffb397ec15324c484a\\n        );\\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\\n            0x26a13c2a6968f979cfc4ef24b965487c5f22f2dfc5e9008942fa32bbb72f7b3c,\\n            0x2bbb803702a9e0c0d4e3a078e2ffa2c525165f940a551555efbdd8876cc3f06e\\n        );\\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\\n            0x17210a663b894d0d08db4ba0f2da65bf67b5e4c94317d03e0eb6077b11e849ef,\\n            0x2c98fb45631bd244290296ce55afc885e0e3cc96b506037183338141e97fdf61\\n        );\\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\\n            0x1ef739c21d81d82ecb30445c5c6e775597aed256ee615b84c71dff243c81dd9e,\\n            0x072138b9876fc2f52d29b5cf35478fe4091f384c034fa59ab4b29deb69e98281\\n        );\\n\\n        vk.permutation_non_residues[0] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000005\\n        );\\n        vk.permutation_non_residues[1] = PairingsBn254.new_fr(\\n            0x0000000000000000000000000000000000000000000000000000000000000007\\n        );\\n        vk.permutation_non_residues[2] = PairingsBn254.new_fr(\\n            0x000000000000000000000000000000000000000000000000000000000000000a\\n        );\\n\\n        vk.g2_x = PairingsBn254.new_g2(\\n            [0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\\n             0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0],\\n            [0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\\n             0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55]\\n        );\\n    }\\n    \\n\\n}\\n\"\r\n    },\r\n    \"contracts/PlonkSingleCore.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.7.0;\\n\\nimport \\\"./PlonkCoreLib.sol\\\";\\n\\ncontract Plonk4SingleVerifierWithAccessToDNext {\\n    using PairingsBn254 for PairingsBn254.G1Point;\\n    using PairingsBn254 for PairingsBn254.G2Point;\\n    using PairingsBn254 for PairingsBn254.Fr;\\n\\n    using TranscriptLibrary for TranscriptLibrary.Transcript;\\n\\n    uint256 constant STATE_WIDTH = 4;\\n    uint256 constant ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP = 1;\\n\\n    struct VerificationKey {\\n        uint256 domain_size;\\n        uint256 num_inputs;\\n        PairingsBn254.Fr omega;\\n        PairingsBn254.G1Point[STATE_WIDTH+2] selector_commitments; // STATE_WIDTH for witness + multiplication + constant\\n        PairingsBn254.G1Point[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP] next_step_selector_commitments;\\n        PairingsBn254.G1Point[STATE_WIDTH] permutation_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH-1] permutation_non_residues;\\n        PairingsBn254.G2Point g2_x;\\n    }\\n\\n    struct Proof {\\n        uint256[] input_values;\\n        PairingsBn254.G1Point[STATE_WIDTH] wire_commitments;\\n        PairingsBn254.G1Point grand_product_commitment;\\n        PairingsBn254.G1Point[STATE_WIDTH] quotient_poly_commitments;\\n        PairingsBn254.Fr[STATE_WIDTH] wire_values_at_z;\\n        PairingsBn254.Fr[ACCESSIBLE_STATE_POLYS_ON_NEXT_STEP] wire_values_at_z_omega;\\n        PairingsBn254.Fr grand_product_at_z_omega;\\n        PairingsBn254.Fr quotient_polynomial_at_z;\\n        PairingsBn254.Fr linearization_polynomial_at_z;\\n        PairingsBn254.Fr[STATE_WIDTH-1] permutation_polynomials_at_z;\\n\\n        PairingsBn254.G1Point opening_at_z_proof;\\n        PairingsBn254.G1Point opening_at_z_omega_proof;\\n    }\\n\\n    struct PartialVerifierState {\\n        PairingsBn254.Fr alpha;\\n        PairingsBn254.Fr beta;\\n        PairingsBn254.Fr gamma;\\n        PairingsBn254.Fr v;\\n        PairingsBn254.Fr u;\\n        PairingsBn254.Fr z;\\n        PairingsBn254.Fr[] cached_lagrange_evals;\\n    }\\n\\n    function evaluate_lagrange_poly_out_of_domain(\\n        uint256 poly_num,\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory omega,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr memory res) {\\n        require(poly_num < domain_size);\\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\\n        res = at.pow(domain_size);\\n        res.sub_assign(one);\\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\\n        res.mul_assign(omega_power);\\n\\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\\n        den.sub_assign(omega_power);\\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\\n\\n        den = den.inverse();\\n\\n        res.mul_assign(den);\\n    }\\n\\n    function evaluate_vanishing(\\n        uint256 domain_size,\\n        PairingsBn254.Fr memory at\\n    ) internal view returns (PairingsBn254.Fr memory res) {\\n        res = at.pow(domain_size);\\n        res.sub_assign(PairingsBn254.new_fr(1));\\n    }\\n\\n    function verify_at_z(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        PairingsBn254.Fr memory lhs = evaluate_vanishing(vk.domain_size, state.z);\\n        require(lhs.value != 0); // we can not check a polynomial relationship if point `z` is in the domain\\n        lhs.mul_assign(proof.quotient_polynomial_at_z);\\n\\n        PairingsBn254.Fr memory quotient_challenge = PairingsBn254.new_fr(1);\\n        PairingsBn254.Fr memory rhs = PairingsBn254.copy(proof.linearization_polynomial_at_z);\\n\\n        // public inputs\\n        PairingsBn254.Fr memory tmp = PairingsBn254.new_fr(0);\\n        for (uint256 i = 0; i < proof.input_values.length; i++) {\\n            tmp.assign(state.cached_lagrange_evals[i]);\\n            tmp.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\\n            rhs.add_assign(tmp);\\n        }\\n\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        PairingsBn254.Fr memory z_part = PairingsBn254.copy(proof.grand_product_at_z_omega);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp.mul_assign(state.beta);\\n            tmp.add_assign(state.gamma);\\n            tmp.add_assign(proof.wire_values_at_z[i]);\\n\\n            z_part.mul_assign(tmp);\\n        }\\n\\n        tmp.assign(state.gamma);\\n        // we need a wire value of the last polynomial in enumeration\\n        tmp.add_assign(proof.wire_values_at_z[STATE_WIDTH - 1]);\\n\\n        z_part.mul_assign(tmp);\\n        z_part.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(z_part);\\n\\n        quotient_challenge.mul_assign(state.alpha);\\n\\n        tmp.assign(state.cached_lagrange_evals[0]);\\n        tmp.mul_assign(quotient_challenge);\\n\\n        rhs.sub_assign(tmp);\\n\\n        return lhs.value == rhs.value;\\n    }\\n\\n    function reconstruct_d(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (PairingsBn254.G1Point memory res) {\\n        // we compute what power of v is used as a delinearization factor in batch opening of\\n        // commitments. Let's label W(x) = 1 / (x - z) *\\n        // [\\n        // t_0(x) + z^n * t_1(x) + z^2n * t_2(x) + z^3n * t_3(x) - t(z)\\n        // + v (r(x) - r(z))\\n        // + v^{2..5} * (witness(x) - witness(z))\\n        // + v^(6..8) * (permutation(x) - permutation(z))\\n        // ]\\n        // W'(x) = 1 / (x - z*omega) *\\n        // [\\n        // + v^9 (z(x) - z(z*omega)) <- we need this power\\n        // + v^10 * (d(x) - d(z*omega))\\n        // ]\\n        //\\n        // we pay a little for a few arithmetic operations to not introduce another constant\\n        uint256 power_for_z_omega_opening = 1 + 1 + STATE_WIDTH + STATE_WIDTH - 1;\\n        res = PairingsBn254.copy_g1(vk.selector_commitments[STATE_WIDTH + 1]);\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(0);\\n\\n        // addition gates\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            tmp_g1 = vk.selector_commitments[i].point_mul(proof.wire_values_at_z[i]);\\n            res.point_add_assign(tmp_g1);\\n        }\\n\\n        // multiplication gate\\n        tmp_fr.assign(proof.wire_values_at_z[0]);\\n        tmp_fr.mul_assign(proof.wire_values_at_z[1]);\\n        tmp_g1 = vk.selector_commitments[STATE_WIDTH].point_mul(tmp_fr);\\n        res.point_add_assign(tmp_g1);\\n\\n        // d_next\\n        tmp_g1 = vk.next_step_selector_commitments[0].point_mul(proof.wire_values_at_z_omega[0]);\\n        res.point_add_assign(tmp_g1);\\n\\n        // z * non_res * beta + gamma + a\\n        PairingsBn254.Fr memory grand_product_part_at_z = PairingsBn254.copy(state.z);\\n        grand_product_part_at_z.mul_assign(state.beta);\\n        grand_product_part_at_z.add_assign(proof.wire_values_at_z[0]);\\n        grand_product_part_at_z.add_assign(state.gamma);\\n        for (uint256 i = 0; i < vk.permutation_non_residues.length; i++) {\\n            tmp_fr.assign(state.z);\\n            tmp_fr.mul_assign(vk.permutation_non_residues[i]);\\n            tmp_fr.mul_assign(state.beta);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i+1]);\\n\\n            grand_product_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        grand_product_part_at_z.mul_assign(state.alpha);\\n\\n        tmp_fr.assign(state.cached_lagrange_evals[0]);\\n        tmp_fr.mul_assign(state.alpha);\\n        tmp_fr.mul_assign(state.alpha);\\n\\n        grand_product_part_at_z.add_assign(tmp_fr);\\n\\n        PairingsBn254.Fr memory grand_product_part_at_z_omega = state.v.pow(power_for_z_omega_opening);\\n        grand_product_part_at_z_omega.mul_assign(state.u);\\n\\n        PairingsBn254.Fr memory last_permutation_part_at_z = PairingsBn254.new_fr(1);\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            tmp_fr.assign(state.beta);\\n            tmp_fr.mul_assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.add_assign(state.gamma);\\n            tmp_fr.add_assign(proof.wire_values_at_z[i]);\\n\\n            last_permutation_part_at_z.mul_assign(tmp_fr);\\n        }\\n\\n        last_permutation_part_at_z.mul_assign(state.beta);\\n        last_permutation_part_at_z.mul_assign(proof.grand_product_at_z_omega);\\n        last_permutation_part_at_z.mul_assign(state.alpha);\\n\\n        // add to the linearization\\n        tmp_g1 = proof.grand_product_commitment.point_mul(grand_product_part_at_z);\\n        tmp_g1.point_sub_assign(vk.permutation_commitments[STATE_WIDTH - 1].point_mul(last_permutation_part_at_z));\\n\\n        res.point_add_assign(tmp_g1);\\n        res.point_mul_assign(state.v);\\n\\n        res.point_add_assign(proof.grand_product_commitment.point_mul(grand_product_part_at_z_omega));\\n    }\\n\\n    function verify_commitments(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        PairingsBn254.G1Point memory d = reconstruct_d(state, proof, vk);\\n\\n        PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\\n\\n        PairingsBn254.G1Point memory tmp_g1 = PairingsBn254.P1();\\n\\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.G1Point memory commitment_aggregation = PairingsBn254.copy_g1(proof.quotient_poly_commitments[0]);\\n        PairingsBn254.Fr memory tmp_fr = PairingsBn254.new_fr(1);\\n        for (uint i = 1; i < proof.quotient_poly_commitments.length; i++) {\\n            tmp_fr.mul_assign(z_in_domain_size);\\n            tmp_g1 = proof.quotient_poly_commitments[i].point_mul(tmp_fr);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n        commitment_aggregation.point_add_assign(d);\\n\\n        for (uint i = 0; i < proof.wire_commitments.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = proof.wire_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        for (uint i = 0; i < vk.permutation_commitments.length - 1; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n            tmp_g1 = vk.permutation_commitments[i].point_mul(aggregation_challenge);\\n            commitment_aggregation.point_add_assign(tmp_g1);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        tmp_g1 = proof.wire_commitments[STATE_WIDTH - 1].point_mul(tmp_fr);\\n        commitment_aggregation.point_add_assign(tmp_g1);\\n\\n        // collect opening values\\n        aggregation_challenge = PairingsBn254.new_fr(1);\\n\\n        PairingsBn254.Fr memory aggregated_value = PairingsBn254.copy(proof.quotient_polynomial_at_z);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.linearization_polynomial_at_z);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        for (uint i = 0; i < proof.wire_values_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.wire_values_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        for (uint i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            aggregation_challenge.mul_assign(state.v);\\n\\n            tmp_fr.assign(proof.permutation_polynomials_at_z[i]);\\n            tmp_fr.mul_assign(aggregation_challenge);\\n            aggregated_value.add_assign(tmp_fr);\\n        }\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.grand_product_at_z_omega);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        aggregation_challenge.mul_assign(state.v);\\n\\n        tmp_fr.assign(proof.wire_values_at_z_omega[0]);\\n        tmp_fr.mul_assign(aggregation_challenge);\\n        tmp_fr.mul_assign(state.u);\\n        aggregated_value.add_assign(tmp_fr);\\n\\n        commitment_aggregation.point_sub_assign(PairingsBn254.P1().point_mul(aggregated_value));\\n\\n        PairingsBn254.G1Point memory pair_with_generator = commitment_aggregation;\\n        pair_with_generator.point_add_assign(proof.opening_at_z_proof.point_mul(state.z));\\n\\n        tmp_fr.assign(state.z);\\n        tmp_fr.mul_assign(vk.omega);\\n        tmp_fr.mul_assign(state.u);\\n        pair_with_generator.point_add_assign(proof.opening_at_z_omega_proof.point_mul(tmp_fr));\\n\\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_at_z_omega_proof.point_mul(state.u);\\n        pair_with_x.point_add_assign(proof.opening_at_z_proof);\\n        pair_with_x.negate();\\n\\n        return PairingsBn254.pairingProd2(pair_with_generator, PairingsBn254.P2(), pair_with_x, vk.g2_x);\\n    }\\n\\n    function verify_initial(\\n        PartialVerifierState memory state,\\n        Proof memory proof,\\n        VerificationKey memory vk\\n    ) internal view returns (bool) {\\n        require(proof.input_values.length == vk.num_inputs);\\n        require(vk.num_inputs == 1);\\n        TranscriptLibrary.Transcript memory transcript = TranscriptLibrary.new_transcript();\\n        for (uint256 i = 0; i < vk.num_inputs; i++) {\\n            transcript.update_with_u256(proof.input_values[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_commitments.length; i++) {\\n            transcript.update_with_g1(proof.wire_commitments[i]);\\n        }\\n\\n        state.beta = transcript.get_challenge();\\n        state.gamma = transcript.get_challenge();\\n\\n        transcript.update_with_g1(proof.grand_product_commitment);\\n        state.alpha = transcript.get_challenge();\\n\\n        for (uint256 i = 0; i < proof.quotient_poly_commitments.length; i++) {\\n            transcript.update_with_g1(proof.quotient_poly_commitments[i]);\\n        }\\n\\n        state.z = transcript.get_challenge();\\n\\n        state.cached_lagrange_evals = new PairingsBn254.Fr[](1);\\n        state.cached_lagrange_evals[0] = evaluate_lagrange_poly_out_of_domain(\\n            0,\\n            vk.domain_size,\\n            vk.omega, state.z\\n        );\\n\\n        bool valid = verify_at_z(state, proof, vk);\\n\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            transcript.update_with_fr(proof.wire_values_at_z_omega[i]);\\n        }\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            transcript.update_with_fr(proof.permutation_polynomials_at_z[i]);\\n        }\\n\\n        transcript.update_with_fr(proof.quotient_polynomial_at_z);\\n        transcript.update_with_fr(proof.linearization_polynomial_at_z);\\n        transcript.update_with_fr(proof.grand_product_at_z_omega);\\n\\n        state.v = transcript.get_challenge();\\n        transcript.update_with_g1(proof.opening_at_z_proof);\\n        transcript.update_with_g1(proof.opening_at_z_omega_proof);\\n        state.u = transcript.get_challenge();\\n\\n        return true;\\n    }\\n\\n    // This verifier is for a PLONK with a state width 4\\n    // and main gate equation\\n    // q_a(X) * a(X) +\\n    // q_b(X) * b(X) +\\n    // q_c(X) * c(X) +\\n    // q_d(X) * d(X) +\\n    // q_m(X) * a(X) * b(X) +\\n    // q_constants(X)+\\n    // q_d_next(X) * d(X*omega)\\n    // where q_{}(X) are selectors a, b, c, d - state (witness) polynomials\\n    // q_d_next(X) \\\"peeks\\\" into the next row of the trace, so it takes\\n    // the same d(X) polynomial, but shifted\\n\\n    function verify(Proof memory proof, VerificationKey memory vk) internal view returns (bool) {\\n        PartialVerifierState memory state;\\n\\n        bool valid = verify_initial(state, proof, vk);\\n\\n        if (valid == false) {\\n            return false;\\n        }\\n\\n        valid = verify_commitments(state, proof, vk);\\n\\n        return valid;\\n    }\\n}\\n\\ncontract SingleVerifierWithDeserialize is Plonk4SingleVerifierWithAccessToDNext {\\n    uint256 constant SERIALIZED_PROOF_LENGTH = 33;\\n\\n    function deserialize_proof(\\n        uint256[] memory public_inputs,\\n        uint256[] memory serialized_proof\\n    ) internal pure returns(Proof memory proof) {\\n        require(serialized_proof.length == SERIALIZED_PROOF_LENGTH);\\n        proof.input_values = new uint256[](public_inputs.length);\\n        for (uint256 i = 0; i < public_inputs.length; i++) {\\n            proof.input_values[i] = public_inputs[i];\\n        }\\n\\n        uint256 j = 0;\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.wire_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j+1]\\n            );\\n\\n            j += 2;\\n        }\\n\\n        proof.grand_product_commitment = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j+1]\\n        );\\n        j += 2;\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.quotient_poly_commitments[i] = PairingsBn254.new_g1_checked(\\n                serialized_proof[j],\\n                serialized_proof[j+1]\\n            );\\n\\n            j += 2;\\n        }\\n\\n        for (uint256 i = 0; i < STATE_WIDTH; i++) {\\n            proof.wire_values_at_z[i] = PairingsBn254.new_fr(\\n                serialized_proof[j]\\n            );\\n\\n            j += 1;\\n        }\\n\\n        for (uint256 i = 0; i < proof.wire_values_at_z_omega.length; i++) {\\n            proof.wire_values_at_z_omega[i] = PairingsBn254.new_fr(\\n                serialized_proof[j]\\n            );\\n\\n            j += 1;\\n        }\\n\\n        proof.grand_product_at_z_omega = PairingsBn254.new_fr(\\n            serialized_proof[j]\\n        );\\n\\n        j += 1;\\n\\n        proof.quotient_polynomial_at_z = PairingsBn254.new_fr(\\n            serialized_proof[j]\\n        );\\n\\n        j += 1;\\n\\n        proof.linearization_polynomial_at_z = PairingsBn254.new_fr(\\n            serialized_proof[j]\\n        );\\n\\n        j += 1;\\n\\n        for (uint256 i = 0; i < proof.permutation_polynomials_at_z.length; i++) {\\n            proof.permutation_polynomials_at_z[i] = PairingsBn254.new_fr(\\n                serialized_proof[j]\\n            );\\n\\n            j += 1;\\n        }\\n\\n        proof.opening_at_z_proof = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j+1]\\n        );\\n        j += 2;\\n\\n        proof.opening_at_z_omega_proof = PairingsBn254.new_g1_checked(\\n            serialized_proof[j],\\n            serialized_proof[j+1]\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PlonkCoreLib.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0 <0.7.0;\\n\\nlibrary PairingsBn254 {\\n    uint256 constant q_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n    uint256 constant bn254_b_coeff = 3;\\n\\n    struct G1Point {\\n        uint256 X;\\n        uint256 Y;\\n    }\\n\\n    struct Fr {\\n        uint256 value;\\n    }\\n\\n    function new_fr(uint256 fr) internal pure returns (Fr memory) {\\n        require(fr < r_mod);\\n        return Fr({value: fr});\\n    }\\n\\n    function copy(Fr memory self) internal pure returns (Fr memory n) {\\n        n.value = self.value;\\n    }\\n\\n    function assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = other.value;\\n    }\\n\\n    function inverse(Fr memory fr) internal view returns (Fr memory) {\\n        require(fr.value != 0);\\n        return pow(fr, r_mod-2);\\n    }\\n\\n    function add_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, other.value, r_mod);\\n    }\\n\\n    function sub_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = addmod(self.value, r_mod - other.value, r_mod);\\n    }\\n\\n    function mul_assign(Fr memory self, Fr memory other) internal pure {\\n        self.value = mulmod(self.value, other.value, r_mod);\\n    }\\n\\n    function pow(Fr memory self, uint256 power) internal view returns (Fr memory) {\\n        uint256[6] memory input = [32, 32, 32, self.value, power, r_mod];\\n        uint256[1] memory result;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)\\n        }\\n        require(success);\\n        return Fr({value: result[0]});\\n    }\\n\\n    // Encoding of field elements is: X[0] * z + X[1]\\n    struct G2Point {\\n        uint[2] X;\\n        uint[2] Y;\\n    }\\n\\n    function P1() internal pure returns (G1Point memory) {\\n        return G1Point(1, 2);\\n    }\\n\\n    function new_g1(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        return G1Point(x, y);\\n    }\\n\\n    function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {\\n        if (x == 0 && y == 0) {\\n            // point of infinity is (0,0)\\n            return G1Point(x, y);\\n        }\\n\\n        // check encoding\\n        require(x < q_mod);\\n        require(y < q_mod);\\n        // check on curve\\n        uint256 lhs = mulmod(y, y, q_mod); // y^2\\n        uint256 rhs = mulmod(x, x, q_mod); // x^2\\n        rhs = mulmod(rhs, x, q_mod); // x^3\\n        rhs = addmod(rhs, bn254_b_coeff, q_mod); // x^3 + b\\n        require(lhs == rhs);\\n\\n        return G1Point(x, y);\\n    }\\n\\n    function new_g2(uint256[2] memory x, uint256[2] memory y) internal pure returns (G2Point memory) {\\n        return G2Point(x, y);\\n    }\\n\\n    function copy_g1(G1Point memory self) internal pure returns (G1Point memory result) {\\n        result.X = self.X;\\n        result.Y = self.Y;\\n    }\\n\\n    function P2() internal pure returns (G2Point memory) {\\n        // for some reason ethereum expects to have c1*v + c0 form\\n\\n        return G2Point(\\n            [0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n            0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed],\\n            [0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n            0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa]\\n        );\\n    }\\n\\n    function negate(G1Point memory self) internal pure {\\n        // The prime q in the base field F_q for G1\\n        if (self.Y == 0) {\\n            require(self.X == 0);\\n            return;\\n        }\\n\\n        self.Y = q_mod - self.Y;\\n    }\\n\\n    function point_add(G1Point memory p1, G1Point memory p2)\\n    internal view returns (G1Point memory r)\\n    {\\n        point_add_into_dest(p1, p2, r);\\n        return r;\\n    }\\n\\n    function point_add_assign(G1Point memory p1, G1Point memory p2)\\n    internal view\\n    {\\n        point_add_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_add_into_dest(G1Point memory p1, G1Point memory p2, G1Point memory dest)\\n    internal view\\n    {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we add zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we add into zero, and we add non-zero point\\n            dest.X = p2.X;\\n            dest.Y = p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = p2.Y;\\n\\n            bool success = false;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_sub_assign(G1Point memory p1, G1Point memory p2)\\n    internal view\\n    {\\n        point_sub_into_dest(p1, p2, p1);\\n    }\\n\\n    function point_sub_into_dest(G1Point memory p1, G1Point memory p2, G1Point memory dest)\\n    internal view\\n    {\\n        if (p2.X == 0 && p2.Y == 0) {\\n            // we subtracted zero, nothing happens\\n            dest.X = p1.X;\\n            dest.Y = p1.Y;\\n            return;\\n        } else if (p1.X == 0 && p1.Y == 0) {\\n            // we subtract from zero, and we subtract non-zero point\\n            dest.X = p2.X;\\n            dest.Y = q_mod - p2.Y;\\n            return;\\n        } else {\\n            uint256[4] memory input;\\n\\n            input[0] = p1.X;\\n            input[1] = p1.Y;\\n            input[2] = p2.X;\\n            input[3] = q_mod - p2.Y;\\n\\n            bool success = false;\\n            assembly {\\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\\n            }\\n            require(success);\\n        }\\n    }\\n\\n    function point_mul(G1Point memory p, Fr memory s)\\n    internal view returns (G1Point memory r)\\n    {\\n        point_mul_into_dest(p, s, r);\\n        return r;\\n    }\\n\\n    function point_mul_assign(G1Point memory p, Fr memory s)\\n    internal view\\n    {\\n        point_mul_into_dest(p, s, p);\\n    }\\n\\n    function point_mul_into_dest(G1Point memory p, Fr memory s, G1Point memory dest)\\n    internal view\\n    {\\n        uint[3] memory input;\\n        input[0] = p.X;\\n        input[1] = p.Y;\\n        input[2] = s.value;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 7, input, 0x60, dest, 0x40)\\n        }\\n        require(success);\\n    }\\n\\n    function pairing(G1Point[] memory p1, G2Point[] memory p2)\\n    internal view returns (bool)\\n    {\\n        require(p1.length == p2.length);\\n        uint elements = p1.length;\\n        uint inputSize = elements * 6;\\n        uint[] memory input = new uint[](inputSize);\\n        for (uint i = 0; i < elements; i++)\\n        {\\n            input[i * 6 + 0] = p1[i].X;\\n            input[i * 6 + 1] = p1[i].Y;\\n            input[i * 6 + 2] = p2[i].X[0];\\n            input[i * 6 + 3] = p2[i].X[1];\\n            input[i * 6 + 4] = p2[i].Y[0];\\n            input[i * 6 + 5] = p2[i].Y[1];\\n        }\\n        uint[1] memory out;\\n        bool success;\\n        assembly {\\n            success := staticcall(gas(), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\\n        }\\n        require(success);\\n        return out[0] != 0;\\n    }\\n\\n    /// Convenience method for a pairing check for two pairs.\\n    function pairingProd2(G1Point memory a1, G2Point memory a2, G1Point memory b1, G2Point memory b2)\\n    internal view returns (bool)\\n    {\\n        G1Point[] memory p1 = new G1Point[](2);\\n        G2Point[] memory p2 = new G2Point[](2);\\n        p1[0] = a1;\\n        p1[1] = b1;\\n        p2[0] = a2;\\n        p2[1] = b2;\\n        return pairing(p1, p2);\\n    }\\n}\\n\\nlibrary TranscriptLibrary {\\n    // flip                    0xe000000000000000000000000000000000000000000000000000000000000000;\\n    uint256 constant FR_MASK = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    uint32 constant DST_0 = 0;\\n    uint32 constant DST_1 = 1;\\n    uint32 constant DST_CHALLENGE = 2;\\n\\n    struct Transcript {\\n        bytes32 state_0;\\n        bytes32 state_1;\\n        uint32 challenge_counter;\\n    }\\n\\n    function new_transcript() internal pure returns (Transcript memory t) {\\n        t.state_0 = bytes32(0);\\n        t.state_1 = bytes32(0);\\n        t.challenge_counter = 0;\\n    }\\n\\n    function update_with_u256(Transcript memory self, uint256 value) internal pure {\\n        bytes32 old_state_0 = self.state_0;\\n        self.state_0 = keccak256(abi.encodePacked(DST_0, old_state_0, self.state_1, value));\\n        self.state_1 = keccak256(abi.encodePacked(DST_1, old_state_0, self.state_1, value));\\n    }\\n\\n    function update_with_fr(Transcript memory self, PairingsBn254.Fr memory value) internal pure {\\n        update_with_u256(self, value.value);\\n    }\\n\\n    function update_with_g1(Transcript memory self, PairingsBn254.G1Point memory p) internal pure {\\n        update_with_u256(self, p.X);\\n        update_with_u256(self, p.Y);\\n    }\\n\\n    function get_challenge(Transcript memory self) internal pure returns(PairingsBn254.Fr memory challenge) {\\n        bytes32 query = keccak256(abi.encodePacked(DST_CHALLENGE, self.state_0, self.state_1, self.challenge_counter));\\n        self.challenge_counter += 1;\\n        challenge = PairingsBn254.Fr({value: uint256(query) & FR_MASK});\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"param1\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"param2\",\"type\":\"bytes\"}],\"name\":\"concatBytes\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"upgradeParameters\",\"type\":\"bytes\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_rootHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_tokenId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"_creatorId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_seqId\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_uri\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_proof\",\"type\":\"uint256[]\"}],\"name\":\"verifyExitNFTProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_rootHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_accountId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"uint256[]\",\"name\":\"_proof\",\"type\":\"uint256[]\"}],\"name\":\"verifyExitProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_account_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_pair_data0\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_pair_data1\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"_proof\",\"type\":\"uint256[]\"}],\"name\":\"verifyLpExitProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VerifierExit","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}