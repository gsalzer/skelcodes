{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/modules/capital/MCR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../../abstract/MasterAware.sol\\\";\\nimport \\\"../../interfaces/IMCR.sol\\\";\\nimport \\\"../../interfaces/INXMToken.sol\\\";\\nimport \\\"../../interfaces/IPool.sol\\\";\\nimport \\\"../../interfaces/IPriceFeedOracle.sol\\\";\\nimport \\\"../../interfaces/IQuotationData.sol\\\";\\nimport \\\"./LegacyMCR.sol\\\";\\n\\ncontract MCR is IMCR, MasterAware {\\n  using SafeMath for uint;\\n\\n  IPool public pool;\\n  IQuotationData public qd;\\n  // sizeof(qd) + 96 = 160 + 96 = 256 (occupies entire slot)\\n  uint96 _unused;\\n\\n  // the following values are expressed in basis points\\n  uint24 public mcrFloorIncrementThreshold = 13000;\\n  uint24 public maxMCRFloorIncrement = 100;\\n  uint24 public maxMCRIncrement = 500;\\n  uint24 public gearingFactor = 48000;\\n  // min update between MCR updates in seconds\\n  uint24 public minUpdateTime = 3600;\\n  uint112 public mcrFloor;\\n\\n  uint112 public mcr;\\n  uint112 public desiredMCR;\\n  uint32 public lastUpdateTime;\\n\\n  IMCR public previousMCR;\\n\\n  event MCRUpdated(\\n    uint mcr,\\n    uint desiredMCR,\\n    uint mcrFloor,\\n    uint mcrETHWithGear,\\n    uint totalSumAssured\\n  );\\n\\n  uint constant UINT24_MAX = ~uint24(0);\\n  uint constant MAX_MCR_ADJUSTMENT = 100;\\n  uint constant BASIS_PRECISION = 10000;\\n\\n  constructor (address masterAddress) public {\\n    changeMasterAddress(masterAddress);\\n\\n    if (masterAddress != address(0)) {\\n      previousMCR = IMCR(master.getLatestAddress(\\\"MC\\\"));\\n    }\\n  }\\n\\n  /**\\n   * @dev Iupgradable Interface to update dependent contract address\\n   */\\n  function changeDependentContractAddress() public {\\n    qd = IQuotationData(master.getLatestAddress(\\\"QD\\\"));\\n    pool = IPool(master.getLatestAddress(\\\"P1\\\"));\\n    initialize();\\n  }\\n\\n  function initialize() internal {\\n\\n    address currentMCR = master.getLatestAddress(\\\"MC\\\");\\n\\n    if (address(previousMCR) == address(0) || currentMCR != address(this)) {\\n      // already initialized or not ready for initialization\\n      return;\\n    }\\n\\n    mcrFloor = previousMCR.mcrFloor();\\n\\n    mcr = previousMCR.mcr();\\n    desiredMCR = previousMCR.desiredMCR();\\n    lastUpdateTime = previousMCR.lastUpdateTime();\\n    maxMCRFloorIncrement = previousMCR.maxMCRFloorIncrement();\\n\\n    previousMCR = IMCR(address(0));\\n  }\\n\\n  /**\\n   * @dev Gets total sum assured (in ETH).\\n   * @return amount of sum assured\\n   */\\n  function getAllSumAssurance() public view returns (uint) {\\n\\n    IPriceFeedOracle priceFeed = pool.priceFeedOracle();\\n    address daiAddress = priceFeed.daiAddress();\\n\\n    uint ethAmount = qd.getTotalSumAssured(\\\"ETH\\\").mul(1e18);\\n    uint daiAmount = qd.getTotalSumAssured(\\\"DAI\\\").mul(1e18);\\n\\n    uint daiRate = priceFeed.getAssetToEthRate(daiAddress);\\n    uint daiAmountInEth = daiAmount.mul(daiRate).div(1e18);\\n\\n    return ethAmount.add(daiAmountInEth);\\n  }\\n\\n  /*\\n  * @dev trigger an MCR update. Current virtual MCR value is synced to storage, mcrFloor is potentially updated\\n  * and a new desiredMCR value to move towards is set.\\n  *\\n  */\\n  function updateMCR() whenNotPaused public {\\n    _updateMCR(pool.getPoolValueInEth(), false);\\n  }\\n\\n  function updateMCRInternal(uint poolValueInEth, bool forceUpdate) public onlyInternal {\\n    _updateMCR(poolValueInEth, forceUpdate);\\n  }\\n\\n  function _updateMCR(uint poolValueInEth, bool forceUpdate) internal {\\n\\n    // read with 1 SLOAD\\n    uint _mcrFloorIncrementThreshold = mcrFloorIncrementThreshold;\\n    uint _maxMCRFloorIncrement = maxMCRFloorIncrement;\\n    uint _gearingFactor = gearingFactor;\\n    uint _minUpdateTime = minUpdateTime;\\n    uint _mcrFloor =  mcrFloor;\\n\\n    // read with 1 SLOAD\\n    uint112 _mcr = mcr;\\n    uint112 _desiredMCR = desiredMCR;\\n    uint32 _lastUpdateTime = lastUpdateTime;\\n\\n    if (!forceUpdate && _lastUpdateTime + _minUpdateTime > block.timestamp) {\\n      return;\\n    }\\n\\n    if (block.timestamp > _lastUpdateTime && pool.calculateMCRRatio(poolValueInEth, _mcr) >= _mcrFloorIncrementThreshold) {\\n        // MCR floor updates by up to maxMCRFloorIncrement percentage per day whenever the MCR ratio exceeds 1.3\\n        // MCR floor is monotonically increasing.\\n      uint basisPointsAdjustment = min(\\n        _maxMCRFloorIncrement.mul(block.timestamp - _lastUpdateTime).div(1 days),\\n        _maxMCRFloorIncrement\\n      );\\n      uint newMCRFloor = _mcrFloor.mul(basisPointsAdjustment.add(BASIS_PRECISION)).div(BASIS_PRECISION);\\n      require(newMCRFloor <= uint112(~0), 'MCR: newMCRFloor overflow');\\n\\n      mcrFloor = uint112(newMCRFloor);\\n    }\\n\\n    // sync the current virtual MCR value to storage\\n    uint112 newMCR = uint112(getMCR());\\n    if (newMCR != _mcr) {\\n      mcr = newMCR;\\n    }\\n\\n    // the desiredMCR cannot fall below the mcrFloor but may have a higher or lower target value based\\n    // on the changes in the totalSumAssured in the system.\\n    uint totalSumAssured = getAllSumAssurance();\\n    uint gearedMCR = totalSumAssured.mul(BASIS_PRECISION).div(_gearingFactor);\\n    uint112 newDesiredMCR = uint112(max(gearedMCR, mcrFloor));\\n    if (newDesiredMCR != _desiredMCR) {\\n      desiredMCR = newDesiredMCR;\\n    }\\n\\n    lastUpdateTime = uint32(block.timestamp);\\n\\n    emit MCRUpdated(mcr, desiredMCR, mcrFloor, gearedMCR, totalSumAssured);\\n  }\\n\\n  /**\\n   * @dev Calculates the current virtual MCR value. The virtual MCR value moves towards the desiredMCR value away\\n   * from the stored mcr value at constant velocity based on how much time passed from the lastUpdateTime.\\n   * The total change in virtual MCR cannot exceed 1% of stored mcr.\\n   *\\n   * This approach allows for the MCR to change smoothly across time without sudden jumps between values, while\\n   * always progressing towards the desiredMCR goal. The desiredMCR can change subject to the call of _updateMCR\\n   * so the virtual MCR value may change direction and start decreasing instead of increasing or vice-versa.\\n   *\\n   * @return mcr\\n   */\\n  function getMCR() public view returns (uint) {\\n\\n    // read with 1 SLOAD\\n    uint _mcr = mcr;\\n    uint _desiredMCR = desiredMCR;\\n    uint _lastUpdateTime = lastUpdateTime;\\n\\n\\n    if (block.timestamp == _lastUpdateTime) {\\n      return _mcr;\\n    }\\n\\n    uint _maxMCRIncrement = maxMCRIncrement;\\n\\n    uint basisPointsAdjustment = _maxMCRIncrement.mul(block.timestamp - _lastUpdateTime).div(1 days);\\n    basisPointsAdjustment = min(basisPointsAdjustment, MAX_MCR_ADJUSTMENT);\\n\\n    if (_desiredMCR > _mcr) {\\n      return min(_mcr.mul(basisPointsAdjustment.add(BASIS_PRECISION)).div(BASIS_PRECISION), _desiredMCR);\\n    }\\n\\n    // in case desiredMCR <= mcr\\n    return max(_mcr.mul(BASIS_PRECISION - basisPointsAdjustment).div(BASIS_PRECISION), _desiredMCR);\\n  }\\n\\n  function getGearedMCR() external view returns (uint) {\\n    return getAllSumAssurance().mul(BASIS_PRECISION).div(gearingFactor);\\n  }\\n\\n  function min(uint x, uint y) pure internal returns (uint) {\\n    return x < y ? x : y;\\n  }\\n\\n  function max(uint x, uint y) pure internal returns (uint) {\\n    return x > y ? x : y;\\n  }\\n\\n  /**\\n   * @dev Updates Uint Parameters\\n   * @param code parameter code\\n   * @param val new value\\n   */\\n  function updateUintParameters(bytes8 code, uint val) public {\\n    require(master.checkIsAuthToGoverned(msg.sender));\\n    if (code == \\\"DMCT\\\") {\\n\\n      require(val <= UINT24_MAX, \\\"MCR: value too large\\\");\\n      mcrFloorIncrementThreshold = uint24(val);\\n\\n    } else if (code == \\\"DMCI\\\") {\\n\\n      require(val <= UINT24_MAX, \\\"MCR: value too large\\\");\\n      maxMCRFloorIncrement = uint24(val);\\n\\n    } else if (code == \\\"MMIC\\\") {\\n\\n      require(val <= UINT24_MAX, \\\"MCR: value too large\\\");\\n      maxMCRIncrement = uint24(val);\\n\\n    } else if (code == \\\"GEAR\\\") {\\n\\n      require(val <= UINT24_MAX, \\\"MCR: value too large\\\");\\n      gearingFactor = uint24(val);\\n\\n    } else if (code == \\\"MUTI\\\") {\\n\\n      require(val <= UINT24_MAX, \\\"MCR: value too large\\\");\\n      minUpdateTime = uint24(val);\\n\\n    } else {\\n      revert(\\\"Invalid param code\\\");\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see {ERC20Detailed}.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/abstract/MasterAware.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\nimport \\\"../interfaces/INXMMaster.sol\\\";\\n\\ncontract MasterAware {\\n\\n  INXMMaster public master;\\n\\n  modifier onlyMember {\\n    require(master.isMember(msg.sender), \\\"Caller is not a member\\\");\\n    _;\\n  }\\n\\n  modifier onlyInternal {\\n    require(master.isInternal(msg.sender), \\\"Caller is not an internal contract\\\");\\n    _;\\n  }\\n\\n  modifier onlyMaster {\\n    if (address(master) != address(0)) {\\n      require(address(master) == msg.sender, \\\"Not master\\\");\\n    }\\n    _;\\n  }\\n\\n  modifier onlyGovernance {\\n    require(\\n      master.checkIsAuthToGoverned(msg.sender),\\n      \\\"Caller is not authorized to govern\\\"\\n    );\\n    _;\\n  }\\n\\n  modifier whenPaused {\\n    require(master.isPause(), \\\"System is not paused\\\");\\n    _;\\n  }\\n\\n  modifier whenNotPaused {\\n    require(!master.isPause(), \\\"System is paused\\\");\\n    _;\\n  }\\n\\n  function changeDependentContractAddress() external;\\n\\n  function changeMasterAddress(address masterAddress) public onlyMaster {\\n    master = INXMMaster(masterAddress);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMCR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IMCR {\\n\\n  function updateMCRInternal(uint poolValueInEth, bool forceUpdate) external;\\n  function getMCR() external view returns (uint);\\n\\n\\n  function maxMCRFloorIncrement() external view returns (uint24);\\n\\n  function mcrFloor() external view returns (uint112);\\n  function mcr() external view returns (uint112);\\n  function desiredMCR() external view returns (uint112);\\n  function lastUpdateTime() external view returns (uint32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INXMToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface INXMToken {\\n\\n  function burn(uint256 amount) external returns (bool);\\n\\n  function burnFrom(address from, uint256 value) external returns (bool);\\n\\n  function operatorTransfer(address from, uint256 value) external returns (bool);\\n\\n  function mint(address account, uint256 amount) external;\\n\\n  function isLockedForMV(address member) external view returns (uint);\\n\\n  function addToWhiteList(address _member) external returns (bool);\\n\\n  function removeFromWhiteList(address _member) external returns (bool);\\n\\n  function changeOperator(address _newOperator) external returns (bool);\\n\\n  function lockForMemberVote(address _of, uint _days) external;\\n\\n  /**\\n * @dev Returns the amount of tokens in existence.\\n */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\nimport \\\"./IPriceFeedOracle.sol\\\";\\n\\ninterface IPool {\\n  function sellNXM(uint tokenAmount, uint minEthOut) external;\\n\\n  function sellNXMTokens(uint tokenAmount) external returns (bool);\\n\\n  function minPoolEth() external returns (uint);\\n\\n  function transferAssetToSwapOperator(address asset, uint amount) external;\\n\\n  function setAssetDataLastSwapTime(address asset, uint32 lastSwapTime) external;\\n\\n  function getAssetDetails(address _asset) external view returns (\\n    uint112 min,\\n    uint112 max,\\n    uint32 lastAssetSwapTime,\\n    uint maxSlippageRatio\\n  );\\n\\n  function sendClaimPayout (\\n    address asset,\\n    address payable payoutAddress,\\n    uint amount\\n  ) external returns (bool success);\\n\\n  function transferAsset(\\n    address asset,\\n    address payable destination,\\n    uint amount\\n  ) external;\\n\\n  function upgradeCapitalPool(address payable newPoolAddress) external;\\n\\n  function priceFeedOracle() external view returns (IPriceFeedOracle);\\n\\n  function getPoolValueInEth() external view returns (uint);\\n\\n\\n  function transferAssetFrom(address asset, address from, uint amount) external;\\n\\n  function getEthForNXM(uint nxmAmount) external view returns (uint ethAmount);\\n\\n  function calculateEthForNXM(\\n    uint nxmAmount,\\n    uint currentTotalAssetValue,\\n    uint mcrEth\\n  ) external pure returns (uint);\\n\\n  function calculateMCRRatio(uint totalAssetValue, uint mcrEth) external pure returns (uint);\\n\\n  function calculateTokenSpotPrice(uint totalAssetValue, uint mcrEth) external pure returns (uint tokenPrice);\\n\\n  function getTokenPrice(address asset) external view returns (uint tokenPrice);\\n\\n  function getMCRRatio() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceFeedOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IPriceFeedOracle {\\n\\n  function daiAddress() external view returns (address);\\n  function stETH() external view returns (address);\\n  function ETH() external view returns (address);\\n\\n  function getAssetToEthRate(address asset) external view returns (uint);\\n  function getAssetForEth(address asset, uint ethIn) external view returns (uint);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQuotationData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface IQuotationData {\\n\\n  function authQuoteEngine() external view returns (address);\\n  function stlp() external view returns (uint);\\n  function stl() external view returns (uint);\\n  function pm() external view returns (uint);\\n  function minDays() external view returns (uint);\\n  function tokensRetained() external view returns (uint);\\n  function kycAuthAddress() external view returns (address);\\n\\n  function refundEligible(address) external view returns (bool);\\n  function holdedCoverIDStatus(uint) external view returns (uint);\\n  function timestampRepeated(uint) external view returns (bool);\\n\\n  enum HCIDStatus {NA, kycPending, kycPass, kycFailedOrRefunded, kycPassNoCover}\\n  enum CoverStatus {Active, ClaimAccepted, ClaimDenied, CoverExpired, ClaimSubmitted, Requested}\\n\\n  function addInTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external;\\n\\n  function subFromTotalSumAssuredSC(address _add, bytes4 _curr, uint _amount) external;\\n\\n  function subFromTotalSumAssured(bytes4 _curr, uint _amount) external;\\n\\n  function addInTotalSumAssured(bytes4 _curr, uint _amount) external;\\n\\n  function setTimestampRepeated(uint _timestamp) external;\\n\\n  /// @dev Creates a blank new cover.\\n  function addCover(\\n    uint16 _coverPeriod,\\n    uint _sumAssured,\\n    address payable _userAddress,\\n    bytes4 _currencyCode,\\n    address _scAddress,\\n    uint premium,\\n    uint premiumNXM\\n  ) external;\\n\\n\\n  function addHoldCover(\\n    address payable from,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint[] calldata coverDetails,\\n    uint16 coverPeriod\\n  ) external;\\n\\n  function setRefundEligible(address _add, bool status) external;\\n\\n  function setHoldedCoverIDStatus(uint holdedCoverID, uint status) external;\\n\\n  function setKycAuthAddress(address _add) external;\\n\\n  function changeAuthQuoteEngine(address _add) external;\\n\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val);\\n\\n  function getProductDetails()\\n  external\\n  view\\n  returns (\\n    uint _minDays,\\n    uint _pm,\\n    uint _stl,\\n    uint _stlp\\n  );\\n\\n  function getCoverLength() external view returns (uint len);\\n\\n  function getAuthQuoteEngine() external view returns (address _add);\\n\\n  function getTotalSumAssured(bytes4 _curr) external view returns (uint amount);\\n\\n  function getAllCoversOfUser(address _add) external view returns (uint[] memory allCover);\\n\\n  function getUserCoverLength(address _add) external view returns (uint len);\\n\\n  function getCoverStatusNo(uint _cid) external view returns (uint8);\\n\\n  function getCoverPeriod(uint _cid) external view returns (uint32 cp);\\n\\n  function getCoverSumAssured(uint _cid) external view returns (uint sa);\\n\\n  function getCurrencyOfCover(uint _cid) external view returns (bytes4 curr);\\n\\n  function getValidityOfCover(uint _cid) external view returns (uint date);\\n\\n  function getscAddressOfCover(uint _cid) external view returns (uint, address);\\n\\n  function getCoverMemberAddress(uint _cid) external view returns (address payable _add);\\n\\n  function getCoverPremiumNXM(uint _cid) external view returns (uint _premiumNXM);\\n\\n  function getCoverDetailsByCoverID1(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    address _memberAddress,\\n    address _scAddress,\\n    bytes4 _currencyCode,\\n    uint _sumAssured,\\n    uint premiumNXM\\n  );\\n\\n  function getCoverDetailsByCoverID2(\\n    uint _cid\\n  )\\n  external\\n  view\\n  returns (\\n    uint cid,\\n    uint8 status,\\n    uint sumAssured,\\n    uint16 coverPeriod,\\n    uint validUntil\\n  );\\n\\n  function getHoldedCoverDetailsByID1(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address scAddress,\\n    bytes4 coverCurr,\\n    uint16 coverPeriod\\n  );\\n\\n  function getUserHoldedCoverLength(address _add) external view returns (uint);\\n\\n  function getUserHoldedCoverByIndex(address _add, uint index) external view returns (uint);\\n\\n  function getHoldedCoverDetailsByID2(\\n    uint _hcid\\n  )\\n  external\\n  view\\n  returns (\\n    uint hcid,\\n    address payable memberAddress,\\n    uint[] memory coverDetails\\n  );\\n\\n  function getTotalSumAssuredSC(address _add, bytes4 _curr) external view returns (uint amount);\\n\\n  function changeCoverStatusNo(uint _cid, uint8 _stat) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/modules/capital/LegacyMCR.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.5.0;\\n\\ninterface LegacyMCR {\\n  function addMCRData(uint mcrP, uint mcrE, uint vF, bytes4[] calldata curr, uint[] calldata _threeDayAvg, uint64 onlyDate) external;\\n  function addLastMCRData(uint64 date) external;\\n  function changeDependentContractAddress() external;\\n  function getAllSumAssurance() external view returns (uint amount);\\n  function _calVtpAndMCRtp(uint poolBalance) external view returns (uint vtp, uint mcrtp);\\n  function calculateStepTokenPrice(bytes4 curr, uint mcrtp) external view returns (uint tokenPrice);\\n  function calculateTokenPrice(bytes4 curr) external view returns (uint tokenPrice);\\n  function calVtpAndMCRtp() external view returns (uint vtp, uint mcrtp);\\n  function calculateVtpAndMCRtp(uint poolBalance) external view returns (uint vtp, uint mcrtp);\\n  function getThresholdValues(uint vtp, uint vF, uint totalSA, uint minCap) external view returns (uint lowerThreshold, uint upperThreshold);\\n  function getMaxSellTokens() external view returns (uint maxTokens);\\n  function getUintParameters(bytes8 code) external view returns (bytes8 codeVal, uint val);\\n  function updateUintParameters(bytes8 code, uint val) external;\\n\\n  function variableMincap() external view returns (uint);\\n  function dynamicMincapThresholdx100() external view returns (uint);\\n  function dynamicMincapIncrementx100() external view returns (uint);\\n\\n  function getLastMCREther() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INXMMaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.5.0;\\n\\ninterface INXMMaster {\\n\\n  function tokenAddress() external view returns (address);\\n\\n  function owner() external view returns (address);\\n\\n  function masterInitialized() external view returns (bool);\\n\\n  function isInternal(address _add) external view returns (bool);\\n\\n  function isPause() external view returns (bool check);\\n\\n  function isOwner(address _add) external view returns (bool);\\n\\n  function isMember(address _add) external view returns (bool);\\n\\n  function checkIsAuthToGoverned(address _add) external view returns (bool);\\n\\n  function dAppLocker() external view returns (address _add);\\n\\n  function getLatestAddress(bytes2 _contractName) external view returns (address payable contractAddress);\\n\\n  function upgradeMultipleContracts(\\n    bytes2[] calldata _contractCodes,\\n    address payable[] calldata newAddresses\\n  ) external;\\n\\n  function removeContracts(bytes2[] calldata contractCodesToRemove) external;\\n\\n  function addNewInternalContracts(\\n    bytes2[] calldata _contractCodes,\\n    address payable[] calldata newAddresses,\\n    uint[] calldata _types\\n  ) external;\\n\\n  function updateOwnerParameters(bytes8 code, address payable val) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"masterAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mcr\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"desiredMCR\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mcrFloor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mcrETHWithGear\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSumAssured\",\"type\":\"uint256\"}],\"name\":\"MCRUpdated\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeDependentContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"masterAddress\",\"type\":\"address\"}],\"name\":\"changeMasterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"desiredMCR\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gearingFactor\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllSumAssurance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGearedMCR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMCR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"internalType\":\"contract INXMMaster\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxMCRFloorIncrement\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxMCRIncrement\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mcr\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mcrFloor\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mcrFloorIncrementThreshold\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minUpdateTime\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract IPool\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"previousMCR\",\"outputs\":[{\"internalType\":\"contract IMCR\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"qd\",\"outputs\":[{\"internalType\":\"contract IQuotationData\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateMCR\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolValueInEth\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"forceUpdate\",\"type\":\"bool\"}],\"name\":\"updateMCRInternal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"code\",\"type\":\"bytes8\"},{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"updateUintParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MCR","CompilerVersion":"v0.5.17+commit.d19bba13","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000001bfd82675dbcc7762c84019ca518e701c0cd07e","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}