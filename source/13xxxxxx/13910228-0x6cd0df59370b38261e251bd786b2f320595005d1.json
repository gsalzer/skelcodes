{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/migration/MigrationCoordinator.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\n\\n\\nimport \\\"../helpers/Ownable.sol\\\";\\nimport \\\"./Migrator.sol\\\";\\nimport \\\"./interfaces/ILiquidityMigrationV2.sol\\\";\\n\\ninterface ILiquidityMigrationV1 {\\n    function migrate(\\n        address user,\\n        address lp,\\n        address adapter,\\n        address strategy,\\n        uint256 slippage\\n    ) external;\\n\\n    function refund(address user, address lp) external;\\n\\n    function addAdapter(address adapter) external;\\n\\n    function removeAdapter(address adapter) external;\\n\\n    function updateController(address newController) external;\\n\\n    function updateGeneric(address newGeneric) external;\\n\\n    function updateUnlock(uint256 newUnlock) external;\\n\\n    function transferOwnership(address newOwner) external;\\n\\n    function staked(address user, address lp) external view returns (uint256);\\n\\n    function controller() external view returns (address);\\n}\\n\\ncontract MigrationCoordinator is Migrator, Ownable{\\n    ILiquidityMigrationV1 public immutable liquidityMigrationV1;\\n    ILiquidityMigrationV2 public immutable liquidityMigrationV2;\\n    address public immutable migrationAdapter;\\n    address public migrator;\\n\\n    modifier onlyMigrator() {\\n        require(msg.sender == migrator, \\\"Not migrator\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address owner_,\\n        address liquidityMigrationV1_,\\n        address liquidityMigrationV2_,\\n        address migrationAdapter_\\n    ) public {\\n        _setOwner(owner_);\\n        migrator = msg.sender;\\n        liquidityMigrationV1 = ILiquidityMigrationV1(liquidityMigrationV1_);\\n        liquidityMigrationV2 = ILiquidityMigrationV2(liquidityMigrationV2_);\\n        migrationAdapter = migrationAdapter_;\\n    }\\n\\n    function initiateMigration(address[] memory adapters) external onlyMigrator {\\n        // Remove current adapters to prevent further staking\\n        for (uint256 i = 0; i < adapters.length; i++) {\\n            liquidityMigrationV1.removeAdapter(adapters[i]);\\n        }\\n        // Generic receives funds, we want LiquidityMigrationV2 to receive the funds\\n        liquidityMigrationV1.updateGeneric(address(liquidityMigrationV2));\\n        // If controller is not zero address, set to zero address\\n        // Don't want anyone calling migrate until process is complete\\n        if (liquidityMigrationV1.controller() != address(0))\\n          liquidityMigrationV1.updateController(address(0));\\n        // Finally, unlock the migration contract\\n        liquidityMigrationV1.updateUnlock(block.timestamp);\\n    }\\n\\n    function migrateLP(address[] memory users, address lp, address adapter) external onlyMigrator {\\n        // Set controller to allow migration\\n        liquidityMigrationV1.updateController(address(this));\\n        // Set adapter to allow migration\\n        liquidityMigrationV1.addAdapter(migrationAdapter);\\n        // Migrate liquidity for all users passed in array\\n        for (uint256 i = 0; i < users.length; i++) {\\n            address user = users[i];\\n            // Get the staked amount as it gets deleted during migration\\n            uint256 staked = liquidityMigrationV1.staked(user, lp);\\n            // Migrate the LP tokens\\n            liquidityMigrationV1.migrate(user, lp, migrationAdapter, address(this), 0);\\n            // Update the staked amount on the new contract\\n            liquidityMigrationV2.setStake(user, lp, adapter, staked);\\n        }\\n        // Remove controller to prevent further migration\\n        liquidityMigrationV1.updateController(address(0));\\n        // Remove adapter to prevent further staking\\n        liquidityMigrationV1.removeAdapter(migrationAdapter);\\n    }\\n\\n    // Allow users to withdraw from LiquidityMigrationV1\\n    function withdraw(address lp) external {\\n        liquidityMigrationV1.refund(msg.sender, lp);\\n    }\\n\\n    // Refund wrapper since MigrationCoordinator is now owner of LiquidityMigrationV1\\n    function refund(address user, address lp) external onlyOwner {\\n      liquidityMigrationV1.refund(user, lp);\\n    }\\n\\n    function addAdapter(address adapter) external onlyOwner {\\n      liquidityMigrationV1.addAdapter(adapter);\\n    }\\n\\n    function removeAdapter(address adapter) external onlyOwner {\\n      liquidityMigrationV1.removeAdapter(adapter);\\n    }\\n\\n    function updateMigrator(address newMigrator)\\n        external\\n        onlyOwner\\n    {\\n        require(migrator != newMigrator, \\\"Already exists\\\");\\n        migrator = newMigrator;\\n    }\\n\\n    function transferLiquidityMigrationOwnership(address newOwner) external onlyOwner {\\n        liquidityMigrationV1.transferOwnership(newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/helpers/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ecosystem/openzeppelin/utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function _setOwner(address owner_) \\n        internal\\n    {\\n        _owner = owner_;\\n        emit OwnershipTransferred(address(0), owner_);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/migration/Migrator.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\nimport \\\"@enso/contracts/contracts/interfaces/IStrategy.sol\\\";\\nimport \\\"@enso/contracts/contracts/interfaces/IStrategyRouter.sol\\\";\\n\\ncontract Migrator {\\n    function deposit(\\n        IStrategy,\\n        IStrategyRouter,\\n        uint256,\\n        uint256,\\n        bytes memory\\n    ) external {}\\n\\n    function initialized(address) external view returns (bool) {\\n        return true;\\n    }\\n\\n    function transfer(address, uint256) external view returns (bool) {\\n        return true;\\n    }\\n\\n    function balanceOf(address) external view returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/migration/interfaces/ILiquidityMigrationV2.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0 <0.9.0;\\n\\ninterface ILiquidityMigrationV2 {\\n    function setStake(address user, address lp, address adapter, uint256 amount) external;\\n\\n    function migrateAll(address lp, address adapter) external;\\n}\\n\"\r\n    },\r\n    \"contracts/ecosystem/openzeppelin/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: WTFPL\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@enso/contracts/contracts/interfaces/IStrategy.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IStrategyToken.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\nimport \\\"./IWhitelist.sol\\\";\\nimport \\\"../helpers/StrategyTypes.sol\\\";\\n\\ninterface IStrategy is IStrategyToken, StrategyTypes {\\n    function approveToken(\\n        address token,\\n        address account,\\n        uint256 amount\\n    ) external;\\n\\n    function approveDebt(\\n        address token,\\n        address account,\\n        uint256 amount\\n    ) external;\\n\\n    function approveSynths(\\n        address account,\\n        uint256 amount\\n    ) external;\\n\\n    function setStructure(StrategyItem[] memory newItems) external;\\n\\n    function setCollateral(address token) external;\\n\\n    function withdrawAll(uint256 amount) external;\\n\\n    function mint(address account, uint256 amount) external;\\n\\n    function burn(address account, uint256 amount) external returns (uint256);\\n\\n    function delegateSwap(\\n        address adapter,\\n        uint256 amount,\\n        address tokenIn,\\n        address tokenOut\\n    ) external;\\n\\n    function settleSynths() external;\\n\\n    function issueStreamingFee() external;\\n\\n    function updateTokenValue(uint256 total, uint256 supply) external;\\n\\n    function updatePerformanceFee(uint16 fee) external;\\n\\n    function updateRebalanceThreshold(uint16 threshold) external;\\n\\n    function updateTradeData(address item, TradeData memory data) external;\\n\\n    function lock() external;\\n\\n    function unlock() external;\\n\\n    function locked() external view returns (bool);\\n\\n    function items() external view returns (address[] memory);\\n\\n    function synths() external view returns (address[] memory);\\n\\n    function debt() external view returns (address[] memory);\\n\\n    function rebalanceThreshold() external view returns (uint256);\\n\\n    function performanceFee() external view returns (uint256);\\n\\n    function getPercentage(address item) external view returns (int256);\\n\\n    function getTradeData(address item) external view returns (TradeData memory);\\n\\n    function getPerformanceFeeOwed(address account) external view returns (uint256);\\n\\n    function controller() external view returns (address);\\n\\n    function manager() external view returns (address);\\n\\n    function oracle() external view returns (IOracle);\\n\\n    function whitelist() external view returns (IWhitelist);\\n\\n    function supportsSynths() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@enso/contracts/contracts/interfaces/IStrategyRouter.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0 <0.9.0;\\n\\nimport \\\"../interfaces/IStrategyController.sol\\\";\\n\\ninterface IStrategyRouter {\\n    enum RouterCategory {GENERIC, LOOP, SYNTH, BATCH}\\n\\n    function rebalance(address strategy, bytes calldata data) external;\\n\\n    function restructure(address strategy, bytes calldata data) external;\\n\\n    function deposit(address strategy, bytes calldata data) external;\\n\\n    function withdraw(address strategy, bytes calldata) external;\\n\\n    function controller() external view returns (IStrategyController);\\n\\n    function category() external view returns (RouterCategory);\\n}\\n\"\r\n    },\r\n    \"@enso/contracts/contracts/interfaces/IStrategyToken.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0 <0.9.0;\\n\\nimport \\\"./IERC20NonStandard.sol\\\";\\n\\ninterface IStrategyToken is IERC20NonStandard {\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function nonces(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@enso/contracts/contracts/interfaces/IOracle.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./registries/ITokenRegistry.sol\\\";\\nimport \\\"./IStrategy.sol\\\";\\n\\ninterface IOracle {\\n    function weth() external view returns (address);\\n\\n    function susd() external view returns (address);\\n\\n    function tokenRegistry() external view returns (ITokenRegistry);\\n\\n    function estimateStrategy(IStrategy strategy) external view returns (uint256, int256[] memory);\\n\\n    function estimateItem(\\n        uint256 balance,\\n        address token\\n    ) external view returns (int256);\\n}\\n\"\r\n    },\r\n    \"@enso/contracts/contracts/interfaces/IWhitelist.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0 <0.9.0;\\n\\ninterface IWhitelist {\\n    function approve(address account) external;\\n\\n    function revoke(address account) external;\\n\\n    function approved(address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@enso/contracts/contracts/helpers/StrategyTypes.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0 <0.9.0;\\n\\ninterface StrategyTypes {\\n\\n    enum ItemCategory {BASIC, SYNTH, DEBT, RESERVE}\\n    enum EstimatorCategory {\\n      DEFAULT_ORACLE,\\n      CHAINLINK_ORACLE,\\n      UNISWAP_TWAP_ORACLE,\\n      SUSHI_TWAP_ORACLE,\\n      STRATEGY,\\n      BLOCKED,\\n      AAVE_V1,\\n      AAVE_V2,\\n      AAVE_DEBT,\\n      BALANCER,\\n      COMPOUND,\\n      CURVE,\\n      CURVE_GAUGE,\\n      SUSHI_LP,\\n      SUSHI_FARM,\\n      UNISWAP_V2_LP,\\n      UNISWAP_V3_LP,\\n      YEARN_V1,\\n      YEARN_V2\\n    }\\n    enum TimelockCategory {RESTRUCTURE, THRESHOLD, REBALANCE_SLIPPAGE, RESTRUCTURE_SLIPPAGE, TIMELOCK, PERFORMANCE}\\n\\n    struct StrategyItem {\\n        address item;\\n        int256 percentage;\\n        TradeData data;\\n    }\\n\\n    struct TradeData {\\n        address[] adapters;\\n        address[] path;\\n        bytes cache;\\n    }\\n\\n    struct InitialState {\\n        uint32 timelock;\\n        uint16 rebalanceThreshold;\\n        uint16 rebalanceSlippage;\\n        uint16 restructureSlippage;\\n        uint16 performanceFee;\\n        bool social;\\n        bool set;\\n    }\\n\\n    struct StrategyState {\\n        uint32 timelock;\\n        uint16 rebalanceSlippage;\\n        uint16 restructureSlippage;\\n        bool social;\\n        bool set;\\n    }\\n\\n    /**\\n        @notice A time lock requirement for changing the state of this Strategy\\n        @dev WARNING: Only one TimelockCategory can be pending at a time\\n    */\\n    struct Timelock {\\n        TimelockCategory category;\\n        uint256 timestamp;\\n        bytes data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@enso/contracts/contracts/interfaces/IERC20NonStandard.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0 <0.9.0;\\n\\ninterface IERC20NonStandard {\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@enso/contracts/contracts/interfaces/registries/ITokenRegistry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0 <0.9.0;\\n\\nimport \\\"../IEstimator.sol\\\";\\n\\ninterface ITokenRegistry {\\n    function itemCategories(address token) external view returns (uint256);\\n\\n    function estimatorCategories(address token) external view returns (uint256);\\n\\n    function estimators(uint256 categoryIndex) external view returns (IEstimator);\\n\\n    function getEstimator(address token) external view returns (IEstimator);\\n\\n    function addEstimator(uint256 estimatorCategoryIndex, address estimator) external;\\n\\n    function addItem(uint256 itemCategoryIndex, uint256 estimatorCategoryIndex, address token) external;\\n}\\n\"\r\n    },\r\n    \"@enso/contracts/contracts/interfaces/IEstimator.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0 <0.9.0;\\n\\ninterface IEstimator {\\n    function estimateItem(\\n        uint256 balance,\\n        address token\\n    ) external view returns (int256);\\n}\\n\"\r\n    },\r\n    \"@enso/contracts/contracts/interfaces/IStrategyController.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.6.0 <0.9.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IStrategy.sol\\\";\\nimport \\\"./IStrategyRouter.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\nimport \\\"./IWhitelist.sol\\\";\\nimport \\\"../helpers/StrategyTypes.sol\\\";\\n\\ninterface IStrategyController is StrategyTypes {\\n    function setupStrategy(\\n        address manager_,\\n        address strategy_,\\n        InitialState memory state_,\\n        address router_,\\n        bytes memory data_\\n    ) external payable;\\n\\n    function deposit(\\n        IStrategy strategy,\\n        IStrategyRouter router,\\n        uint256 amount,\\n        uint256 slippage,\\n        bytes memory data\\n    ) external payable;\\n\\n    function withdrawETH(\\n        IStrategy strategy,\\n        IStrategyRouter router,\\n        uint256 amount,\\n        uint256 slippage,\\n        bytes memory data\\n    ) external;\\n\\n    function withdrawWETH(\\n        IStrategy strategy,\\n        IStrategyRouter router,\\n        uint256 amount,\\n        uint256 slippage,\\n        bytes memory data\\n    ) external;\\n\\n    function rebalance(\\n        IStrategy strategy,\\n        IStrategyRouter router,\\n        bytes memory data\\n    ) external;\\n\\n    function restructure(\\n        IStrategy strategy,\\n        StrategyItem[] memory strategyItems\\n    ) external;\\n\\n    function finalizeStructure(\\n        IStrategy strategy,\\n        IStrategyRouter router,\\n        bytes memory data\\n    ) external;\\n\\n    function updateValue(\\n        IStrategy strategy,\\n        TimelockCategory category,\\n        uint256 newValue\\n    ) external;\\n\\n    function finalizeValue(address strategy) external;\\n\\n    function openStrategy(IStrategy strategy) external;\\n\\n    function setStrategy(IStrategy strategy) external;\\n\\n    function initialized(address strategy) external view returns (bool);\\n\\n    function strategyState(address strategy) external view returns (StrategyState memory);\\n\\n    function verifyStructure(address strategy, StrategyItem[] memory newItems)\\n        external\\n        view\\n        returns (bool);\\n\\n    function oracle() external view returns (IOracle);\\n\\n    function whitelist() external view returns (IWhitelist);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityMigrationV1_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidityMigrationV2_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"migrationAdapter_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"}],\"name\":\"addAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IStrategy\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"contract IStrategyRouter\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"adapters\",\"type\":\"address[]\"}],\"name\":\"initiateMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityMigrationV1\",\"outputs\":[{\"internalType\":\"contract ILiquidityMigrationV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityMigrationV2\",\"outputs\":[{\"internalType\":\"contract ILiquidityMigrationV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"}],\"name\":\"migrateLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrationAdapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adapter\",\"type\":\"address\"}],\"name\":\"removeAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferLiquidityMigrationOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMigrator\",\"type\":\"address\"}],\"name\":\"updateMigrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MigrationCoordinator","CompilerVersion":"v0.8.2+commit.661d1103","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"000000000000000000000000ee0e85c384f7370ff3eb551e92a71a4afc1b259f0000000000000000000000000092decca5e2f26466289011ad41465763bea4ce0000000000000000000000000c6d898ac945e493d25751ea43be2c8beb881d8c000000000000000000000000af8d0523660a94494c56d5445e7bfe8c61802b59","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}