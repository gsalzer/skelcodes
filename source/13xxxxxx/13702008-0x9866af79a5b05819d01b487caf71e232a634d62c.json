{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/HoneyFarmQueenDeluxe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"../interfaces/BearsDeluxeI.sol\\\";\\nimport \\\"../interfaces/HoneyTokenI.sol\\\";\\nimport \\\"../interfaces/BeesDeluxeI.sol\\\";\\nimport \\\"../interfaces/HoneyHiveDeluxeI.sol\\\";\\n\\ncontract HoneyFarmQueenDeluxe is OwnableUpgradeable, ReentrancyGuardUpgradeable {\\n    uint32 public constant HONEY_BEARS_REWARDS_PER_ROUND = 100; //this is 1\\n\\n    uint32 public constant HONEY_UNSTAKED_BEE_REWARDS_PER_EPOCH = 13; //this is 0.13\\n\\n    uint32 public constant HONEY_STAKED_BEE_REWARDS_PER_EPOCH = 9; //this is 0.09\\n\\n    uint8 public constant MAX_USAGE_PER_HIVE = 3;\\n\\n    uint32 public constant REWARD_FOR_BURNING_BEE = 1200; //this is 12\\n\\n    uint32 public constant BURN_AMOUNT_FOR_STAKING_BEE = 700; //this is 7\\n\\n    uint32 public constant MIN_AMOUNT_FOR_ACTIVATE_BEE = 700; //this is 7\\n\\n    uint32 public constant AMOUNT_TO_KEEP_ACTIVE = 23; //this is 0.23\\n\\n    uint256 public constant MIN_BURN_AMOUNT_FOR_CLAIMING_BEE = 2300; //this is 23\\n\\n    uint256 public constant AMOUNT_FOR_ACTIVATE_HIVE = 6900; //this is 69\\n\\n    // solhint-disable-next-line\\n    uint16 public EPOCHS_BEFORE_INACTIVE_BEE; //number of epochs that a bee can claim honey before becoming inactive\\n\\n    uint16 private lowestBeeId;\\n\\n    //Used to keep track of how many were minted so far because bees can be burnt\\n    uint16 public totalMintedBees;\\n\\n    uint256 public EPOCH_LENGTH;\\n\\n    uint256 public HIVE_CLAIM_EPOCH_LENGTH;\\n\\n    uint256 public STARTING_POINT;\\n\\n    BearsDeluxeI public bears;\\n\\n    HoneyTokenI public honey;\\n\\n    HoneyHiveDeluxeI public hive;\\n\\n    BeesDeluxeI public bees;\\n\\n    Pause public paused;\\n\\n    mapping(uint16 => uint256) private lastRewardOfHoneyPerBears;\\n    mapping(uint16 => uint256) private lastTimeClaimedBeePerHive;\\n    mapping(uint16 => Bee) private idsAndBees;\\n\\n    struct Bee {\\n        uint256 id;\\n        uint8 active;\\n        //used to know how many epochs this bee can claim honey before becoming inactive.\\n        //in case it gets inactive, user must burn honey.\\n        //in case bee is staked, claim counter does not matter\\n        uint16 epochsLeft;\\n        uint8 staked;\\n        uint256 becameInactiveTime;\\n        //last time a bee claimed honey\\n        uint256 lastRewardTime;\\n        //last time a bee was fed (burnt honey to activate)\\n        uint256 lastTimeFed;\\n    }\\n\\n    struct Pause {\\n        uint8 pauseBee;\\n        uint8 pauseHive;\\n        uint8 pauseBears;\\n    }\\n\\n    /***********Events**************/\\n    event HoneyClaimed(address indexed _to, uint256 _amount);\\n    event HoneyHiveClaimed(address indexed _to, uint256 _amount);\\n    event BeeClaimed(address indexed _to, uint256 _amount);\\n    event HiveActivated(address indexed _owner, uint256 indexed _hiveId);\\n    event BeeActivated(address indexed _owner, uint256 indexed _beeId);\\n    event BeeKeptActive(address indexed _owner, uint256 indexed _beeId);\\n    event BeeBurnt(address indexed _owner, uint256 indexed _beeId);\\n    event BeeStaked(address indexed _owner, uint256 indexed _beeId);\\n    event BeeUnstaked(address indexed _owner, uint256 indexed _beeId);\\n    event StartingPointChanged(uint256 startingPoint);\\n    event SetContract(string indexed _contract, address _target);\\n    event EpochChange(string indexed epochType, uint256 _newValue);\\n    event PauseChanged(uint8 _pauseBears, uint8 _pauseHives, uint8 _pauseBees);\\n\\n    function initialize() public initializer {\\n        __Ownable_init();\\n        __ReentrancyGuard_init();\\n        EPOCHS_BEFORE_INACTIVE_BEE = 10; //number of rounds that a bee can claim honey before becoming inactive\\n\\n        // solhint-disable-next-line\\n        // we set it to 2^16 = 65,536 as bees max supply is 20700 so the first id that is generated, will be lower than this\\n        lowestBeeId = type(uint16).max;\\n\\n        EPOCH_LENGTH = 86400; //one day\\n\\n        HIVE_CLAIM_EPOCH_LENGTH = 86400; //one day\\n\\n        STARTING_POINT = 1635005744;\\n    }\\n\\n    /***********External**************/\\n\\n    /**\\n     * @dev claiming honey by owning a bear\\n     */\\n    function claimBearsHoney(uint16[] calldata _bearsIds) external nonReentrant {\\n        require(STARTING_POINT < block.timestamp, \\\"Rewards didn't start\\\");\\n\\n        require(paused.pauseBears == 0, \\\"Paused\\\");\\n\\n        uint256 amount;\\n        for (uint16 i = 0; i < _bearsIds.length; i++) {\\n            uint16 id = _bearsIds[i];\\n\\n            //if not owner of the token then no rewards, usecase when someone tries to get rewards for\\n            //a token that isn't his or when he tries to get the rewards for an old token\\n            if (!bears.exists(id)) continue;\\n            if (bears.ownerOf(id) != msg.sender) continue;\\n\\n            uint256 epochsToReward;\\n            uint256 lastReward = lastRewardOfHoneyPerBears[id];\\n            if (lastReward > 0 && lastReward > STARTING_POINT) {\\n                // solhint-disable-next-line\\n                //we get whole numbers for example if someone claims after 1 round and a half, he should be rewarded for 1 round.\\n                epochsToReward = (block.timestamp - lastReward) / EPOCH_LENGTH;\\n            } else {\\n                // if no rewards claimed so far, then he gets rewards from when the rewards started.\\n                epochsToReward = (block.timestamp - STARTING_POINT) / EPOCH_LENGTH;\\n            }\\n\\n            //accumulating honey to mint\\n            amount += HONEY_BEARS_REWARDS_PER_ROUND * epochsToReward;\\n            lastRewardOfHoneyPerBears[id] = block.timestamp;\\n        }\\n        require(amount > 0, \\\"Nothing to claim\\\");\\n        amount = amount * 1e16;\\n\\n        //can not mint more than maxSupply\\n        if (honey.totalSupply() + amount > honey.maxSupply()) {\\n            amount = (honey.maxSupply() - honey.totalSupply());\\n        }\\n\\n        honey.mint(msg.sender, amount);\\n        emit HoneyClaimed(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @dev claiming honey by owning a bee\\n     */\\n    // solhint-disable-next-line\\n    function claimBeesHoney(uint16[] calldata _beesIds) external nonReentrant {\\n        require(STARTING_POINT < block.timestamp, \\\"Rewards didn't start\\\");\\n\\n        require(paused.pauseBee == 0, \\\"Paused\\\");\\n\\n        uint256 amount = 0;\\n\\n        for (uint16 i = 0; i < _beesIds.length; i++) {\\n            uint16 id = _beesIds[i];\\n\\n            if (!bees.exists(id)) continue;\\n            if (bees.ownerOf(id) != msg.sender) continue;\\n            Bee storage bee = idsAndBees[id];\\n\\n            if (bee.id == 0 || bee.active == 0) continue;\\n\\n            uint256 epochsToReward;\\n            uint256 lastReward = bee.lastRewardTime;\\n\\n            if (lastReward > 0 && lastReward > STARTING_POINT) {\\n                // solhint-disable-next-line\\n                //we get whole numbers for example if someone claims after 1 round and a half, he should be rewarded for 1 round.\\n                epochsToReward = (block.timestamp - lastReward) / EPOCH_LENGTH;\\n            } else {\\n                // if no rewards claimed so far, then he gets rewards from when the rewards started.\\n                epochsToReward = (block.timestamp - STARTING_POINT) / EPOCH_LENGTH;\\n            }\\n\\n            //if bee not staked and someone has unclaimed honey for longer than the claim counter\\n            //then we can give him rewards just for the leftovers epochs.\\n            if (bee.staked == 0 && epochsToReward > bee.epochsLeft) {\\n                bee.active = 0;\\n                bee.becameInactiveTime = block.timestamp;\\n                epochsToReward = bee.epochsLeft;\\n            }\\n\\n            if (bee.staked == 0) {\\n                amount += HONEY_UNSTAKED_BEE_REWARDS_PER_EPOCH * epochsToReward;\\n                bee.epochsLeft -= uint16(epochsToReward);\\n                if (bee.epochsLeft == 0) {\\n                    bee.active = 0;\\n                    bee.becameInactiveTime = block.timestamp;\\n                }\\n            } else {\\n                amount += HONEY_STAKED_BEE_REWARDS_PER_EPOCH * epochsToReward;\\n            }\\n\\n            bee.lastRewardTime = block.timestamp;\\n        }\\n        require(amount > 0, \\\"Nothing to claim\\\");\\n        amount = amount * 1e16;\\n\\n        //can not mint more than maxSupply\\n        if (honey.totalSupply() + amount > honey.maxSupply()) {\\n            amount = (honey.maxSupply() - honey.totalSupply());\\n        }\\n\\n        honey.mint(msg.sender, amount);\\n        emit HoneyClaimed(msg.sender, amount);\\n    }\\n\\n    /**\\n     * @dev mints a Honey Hive by having a bear. You need to be the holder of the bear.\\n     */\\n    function mintHive(uint16 _bearsId) external nonReentrant {\\n        require(paused.pauseHive == 0, \\\"Paused\\\");\\n\\n        require(msg.sender != address(0), \\\"Can not mint to address 0\\\");\\n\\n        hive.mint(msg.sender, _bearsId);\\n        emit HoneyHiveClaimed(msg.sender, _bearsId);\\n    }\\n\\n    /**\\n     * @dev mints a Bee by having a hive. You need to be the holder of the hive.\\n     */\\n    function mintBee(uint16 _hiveId) external nonReentrant {\\n        require(paused.pauseBee == 0, \\\"Paused\\\");\\n\\n        require(msg.sender != address(0), \\\"Can not mint to address 0\\\");\\n\\n        require(hive.ownerOf(_hiveId) == msg.sender, \\\"No Hive owned\\\");\\n\\n        require(honey.balanceOf(msg.sender) >= MIN_BURN_AMOUNT_FOR_CLAIMING_BEE * 1e16, \\\"Not enough Honey\\\");\\n\\n        require(lastTimeClaimedBeePerHive[_hiveId] < block.timestamp - HIVE_CLAIM_EPOCH_LENGTH, \\\"Mint bee cooldown\\\");\\n\\n        uint16 beeId = randBeeId();\\n        require(beeId > 0, \\\"Mint failed\\\");\\n\\n        lastTimeClaimedBeePerHive[_hiveId] = block.timestamp;\\n        idsAndBees[beeId] = Bee(beeId, 1, EPOCHS_BEFORE_INACTIVE_BEE, 0, 0, block.timestamp, 0);\\n        totalMintedBees++;\\n\\n        hive.increaseUsageOfMintingBee(_hiveId);\\n\\n        honey.burn(msg.sender, MIN_BURN_AMOUNT_FOR_CLAIMING_BEE * 1e16);\\n        bees.mint(msg.sender, beeId);\\n\\n        emit BeeClaimed(msg.sender, beeId);\\n    }\\n\\n    /**\\n     * @dev after MAX_USAGE_PER_HIVE, a hive becomes inactive so it needs to be activated so we can mint more Bees\\n     */\\n    function activateHive(uint16 _hiveId) external nonReentrant {\\n        require(paused.pauseHive == 0, \\\"Paused\\\");\\n\\n        require(hive.ownerOf(_hiveId) == msg.sender, \\\"Not your hive\\\");\\n        require(hive.getUsageOfMintingBee(_hiveId) >= MAX_USAGE_PER_HIVE, \\\"Cap not reached\\\");\\n        require(honey.balanceOf(msg.sender) >= AMOUNT_FOR_ACTIVATE_HIVE * 1e16, \\\"Not enough Honey\\\");\\n\\n        honey.burn(msg.sender, AMOUNT_FOR_ACTIVATE_HIVE * 1e16);\\n        hive.resetUsageOfMintingBee(_hiveId);\\n\\n        emit HiveActivated(msg.sender, _hiveId);\\n    }\\n\\n    /**\\n     * @dev Exactly like in real world, bees become hungry for honey so,\\n     * after EPOCHS_BEFORE_INACTIVE_BEE epochs a bee needs\\n     * to be fed to become active again and start collecting Honey\\n     * Corresponds with Revive Bees\\n     */\\n    function activateBees(uint16[] calldata _beesIds) external nonReentrant {\\n        require(paused.pauseBee == 0, \\\"Paused\\\");\\n\\n        uint256 amountOfHoney = 0;\\n        for (uint16 i = 0; i < _beesIds.length; i++) {\\n            uint16 _beeId = _beesIds[i];\\n            Bee storage bee = idsAndBees[_beeId];\\n            if (bee.id == 0) continue;\\n            if (bees.ownerOf(_beeId) != msg.sender) continue;\\n\\n            /**\\n             * when we activate a bee we do the following:\\n             * - we set active = 1 (meaning true)\\n             * - reset epochsLeft to MIN_USAGE_PER_BEE which is the max claiming before it becomes inactive\\n             * - set reward time as now so in case bee is staked, to not claim before this\\n             *   because on staking, we ignore the claim counter\\n             * - we set lastTimeFed for UI\\n             */\\n            amountOfHoney += MIN_AMOUNT_FOR_ACTIVATE_BEE;\\n            bee.active = 1;\\n            bee.epochsLeft = EPOCHS_BEFORE_INACTIVE_BEE;\\n            bee.lastRewardTime = block.timestamp;\\n            bee.lastTimeFed = block.timestamp;\\n            emit BeeActivated(msg.sender, _beeId);\\n        }\\n\\n        require(amountOfHoney > 0, \\\"Nothing to activate\\\");\\n        amountOfHoney = amountOfHoney * 1e16;\\n\\n        require(honey.balanceOf(msg.sender) >= amountOfHoney, \\\"Not enough honey\\\");\\n        honey.burn(msg.sender, amountOfHoney);\\n    }\\n\\n    /**\\n     * @dev If you want your bee to not become inactive and burn more Honey to fed it, you can\\n     * use this function to keep an Active bee, Active. Once this is called,\\n     * Honey will be burnt and bee can claim Honey again for EPOCHS_BEFORE_INACTIVE_BEE.\\n     * Corresponds with Feed Bees\\n     */\\n    function keepBeesActive(uint16[] calldata _beesIds) external nonReentrant {\\n        require(paused.pauseBee == 0, \\\"Paused\\\");\\n\\n        uint256 amountOfHoney = 0;\\n        for (uint16 i = 0; i < _beesIds.length; i++) {\\n            uint16 _beeId = _beesIds[i];\\n            Bee storage bee = idsAndBees[_beeId];\\n            if (bee.id == 0) continue;\\n            if (bees.ownerOf(_beeId) != msg.sender) continue;\\n            //this bee can not be kept active as it is inactive already, need to burn 7 honey\\n            if (bee.active == 0) continue;\\n\\n            amountOfHoney += AMOUNT_TO_KEEP_ACTIVE;\\n            bee.epochsLeft = EPOCHS_BEFORE_INACTIVE_BEE;\\n            bee.lastTimeFed = block.timestamp;\\n            emit BeeKeptActive(msg.sender, _beeId);\\n        }\\n\\n        require(amountOfHoney > 0, \\\"Nothing to keep active\\\");\\n        amountOfHoney = amountOfHoney * 1e16;\\n\\n        require(honey.balanceOf(msg.sender) >= amountOfHoney, \\\"Not enough honey\\\");\\n        honey.burn(msg.sender, amountOfHoney);\\n    }\\n\\n    /**\\n     * @dev In case you got bored of one of your Bee, or it got too old, you can burn it and receive Honey\\n     */\\n    function burnBees(uint16[] calldata _beesIds) external nonReentrant {\\n        require(paused.pauseBee == 0, \\\"Paused\\\");\\n\\n        uint256 amountOfHoney = 0;\\n        for (uint16 i = 0; i < _beesIds.length; i++) {\\n            uint16 _beeId = _beesIds[i];\\n\\n            //in case a bee is burnt from BeesDeluxe contract, should neved happen.\\n            if (bees.ownerOf(_beeId) == address(0)) {\\n                delete idsAndBees[_beeId];\\n                return;\\n            }\\n            if (bees.ownerOf(_beeId) != msg.sender) continue;\\n            delete idsAndBees[_beeId];\\n            amountOfHoney += REWARD_FOR_BURNING_BEE;\\n            bees.burnByQueen(_beeId);\\n            emit BeeBurnt(msg.sender, _beeId);\\n        }\\n        amountOfHoney = amountOfHoney * 1e16;\\n\\n        require(amountOfHoney > 0, \\\"Nothing to burn\\\");\\n        require(honey.totalSupply() + amountOfHoney <= honey.maxSupply(), \\\"Honey cap reached\\\");\\n\\n        honey.mint(msg.sender, amountOfHoney);\\n    }\\n\\n    /**\\n     * @dev In case you are a long term player, you can stake your Bee to avoid the bee being inactivated.\\n     * Of course this comes with a downside, the amount of Honey you can claim, shrinks\\n     * Corresponds with Put Bees to Work\\n     */\\n    function stakeBees(uint16[] calldata _beesIds) external nonReentrant {\\n        require(paused.pauseBee == 0, \\\"Paused\\\");\\n\\n        uint256 amountOfHoney = 0;\\n        for (uint16 i = 0; i < _beesIds.length; i++) {\\n            uint16 _beeId = _beesIds[i];\\n            Bee storage bee = idsAndBees[_beeId];\\n            if (bee.id == 0) continue;\\n            if (bee.active == 0) continue;\\n            if (bee.staked == 1) continue;\\n            if (bees.ownerOf(_beeId) != msg.sender) continue;\\n            amountOfHoney += BURN_AMOUNT_FOR_STAKING_BEE;\\n            bee.staked = 1;\\n            emit BeeStaked(msg.sender, _beeId);\\n        }\\n\\n        require(amountOfHoney > 0, \\\"Nothing to stake\\\");\\n        amountOfHoney = amountOfHoney * 1e16;\\n\\n        require(honey.balanceOf(msg.sender) >= amountOfHoney, \\\"Not enough honey\\\");\\n        if (amountOfHoney > 0) honey.burn(msg.sender, amountOfHoney);\\n    }\\n\\n    /**\\n     * @dev You got enough of your staked bee, you can unstake it to get back to the normal rewards but also\\n     * with the possibility to get inactivated\\n     * Corresponds with Stop Work\\n     */\\n    function unstakeBees(uint16[] calldata _beesIds) external nonReentrant {\\n        require(paused.pauseBee == 0, \\\"Paused\\\");\\n\\n        for (uint16 i = 0; i < _beesIds.length; i++) {\\n            uint16 _beeId = _beesIds[i];\\n            Bee storage bee = idsAndBees[_beeId];\\n            if (bee.id == 0) continue;\\n            if (bee.staked == 0) continue;\\n            if (bees.ownerOf(_beeId) != msg.sender) continue;\\n            bee.staked = 0;\\n            bee.lastTimeFed = block.timestamp;\\n            emit BeeUnstaked(msg.sender, _beeId);\\n        }\\n    }\\n\\n    /***********Internal**************/\\n\\n    // solhint-disable-next-line\\n    function randBeeId() internal returns (uint16 _id) {\\n        uint16 entropy;\\n        uint16 maxSupply = uint16(bees.getMaxSupply());\\n        require(totalMintedBees < maxSupply, \\\"MAX_SUPPLY reached\\\");\\n        while (true) {\\n            uint16 rand = uint16(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            msg.sender,\\n                            block.difficulty,\\n                            block.timestamp,\\n                            block.number,\\n                            totalMintedBees,\\n                            entropy\\n                        )\\n                    )\\n                )\\n            );\\n            _id = rand % maxSupply;\\n            entropy++;\\n            if (_id == 0) _id = maxSupply;\\n\\n            if (idsAndBees[_id].id == 0) {\\n                if (_id < lowestBeeId) lowestBeeId = _id;\\n                return _id;\\n            }\\n            if (entropy > 2) {\\n                bool wentOverOnce;\\n                while (idsAndBees[lowestBeeId].id > 0) {\\n                    lowestBeeId++;\\n                    if (lowestBeeId == maxSupply) {\\n                        if (wentOverOnce) return 0;\\n                        wentOverOnce = true;\\n                        lowestBeeId = 1;\\n                    }\\n                }\\n                _id = lowestBeeId;\\n                return _id;\\n            }\\n        }\\n    }\\n\\n    /***********Views**************/\\n    /**\\n     * @dev Get a time when the Bear was last rewarded with honey\\n     */\\n    function getLastRewardedByBear(uint16 _bearId) external view returns (uint256) {\\n        return lastRewardOfHoneyPerBears[_bearId];\\n    }\\n\\n    /**\\n     * @dev Get a time when the Bee was last rewarded with honey\\n     */\\n    function getLastRewardedByBee(uint16 _beeId) external view returns (uint256) {\\n        return idsAndBees[_beeId].lastRewardTime;\\n    }\\n\\n    /**\\n     * @dev Get the whole state of the bee\\n     */\\n    function getBeeState(uint16 _beeId) external view returns (Bee memory) {\\n        return idsAndBees[_beeId];\\n    }\\n\\n    /**\\n     * @dev Get last time you claimed a bee\\n     */\\n    function getLastTimeBeeClaimed(uint16 _hiveId) external view returns (uint256) {\\n        return lastTimeClaimedBeePerHive[_hiveId];\\n    }\\n\\n    /**\\n     * @dev Get states of multiple Bees\\n     */\\n    function getBeesState(uint16[] calldata _beesIds) external view returns (Bee[] memory beesToReturn) {\\n        beesToReturn = new Bee[](_beesIds.length);\\n        for (uint16 i = 0; i < _beesIds.length; i++) {\\n            beesToReturn[i] = idsAndBees[_beesIds[i]];\\n        }\\n        return beesToReturn;\\n    }\\n\\n    /**\\n     * @dev Get total unclaimed Honey for a holder\\n     */\\n    function getUnclaimedHoneyForBears(address _owner) external view returns (uint256 amount) {\\n        uint256[] memory bearsIds = bears.tokensOfOwner(_owner);\\n        for (uint16 i = 0; i < bearsIds.length; i++) {\\n            uint16 id = uint16(bearsIds[i]);\\n\\n            //if not owner of the token then no rewards, usecase when someone tries to get rewards for\\n            //a token that isn't his or when he tries to get the rewards for an old token\\n            if (!bears.exists(id)) continue;\\n            if (bears.ownerOf(id) != _owner) continue;\\n\\n            uint256 epochsToReward;\\n            uint256 lastReward = lastRewardOfHoneyPerBears[id];\\n            if (lastReward > 0 && lastReward > STARTING_POINT) {\\n                // solhint-disable-next-line\\n                //we get whole numbers for example if someone claims after 1 round and a half, he should be rewarded for 1 round.\\n                epochsToReward = (block.timestamp - lastReward) / EPOCH_LENGTH;\\n            } else {\\n                if (block.timestamp < STARTING_POINT)\\n                    //if the starting point it's in the future then return 0\\n                    epochsToReward = 0;\\n                    // if no rewards claimed so far, then he gets rewards from when the rewards started.\\n                else epochsToReward = (block.timestamp - STARTING_POINT) / EPOCH_LENGTH;\\n            }\\n\\n            //accumulating honey to mint\\n            amount += HONEY_BEARS_REWARDS_PER_ROUND * epochsToReward;\\n        }\\n        amount = amount * 1e16;\\n    }\\n\\n    /**\\n     * @dev Get total unclaimed Honey for a holder\\n     */\\n    // solhint-disable-next-line\\n    function getUnclaimedHoneyForBees(address _owner) external view returns (uint256 amount) {\\n        uint256[] memory beesIds = bees.tokensOfOwner(_owner);\\n        for (uint16 i = 0; i < beesIds.length; i++) {\\n            uint16 id = uint16(beesIds[i]);\\n\\n            if (!bees.exists(id)) continue;\\n            if (bees.ownerOf(id) != _owner) continue;\\n            Bee storage bee = idsAndBees[id];\\n\\n            if (bee.id == 0 || bee.active == 0) continue;\\n\\n            uint256 epochsToReward;\\n            uint256 lastReward = bee.lastRewardTime;\\n\\n            if (lastReward > 0 && lastReward > STARTING_POINT) {\\n                // solhint-disable-next-line\\n                //we get whole numbers for example if someone claims after 1 round and a half, he should be rewarded for 1 round.\\n                epochsToReward = (block.timestamp - lastReward) / EPOCH_LENGTH;\\n            } else {\\n                if (block.timestamp < STARTING_POINT)\\n                    //if the starting point it's in the future then return 0\\n                    epochsToReward = 0;\\n                    // if no rewards claimed so far, then he gets rewards from when the rewards started.\\n                else epochsToReward = (block.timestamp - STARTING_POINT) / EPOCH_LENGTH;\\n            }\\n\\n            //if bee not staked and someone has unclaimed honey before hive becoming inactive\\n            if (bee.staked == 0 && epochsToReward > bee.epochsLeft) {\\n                epochsToReward = bee.epochsLeft;\\n            }\\n\\n            if (bee.staked == 0) {\\n                amount += HONEY_UNSTAKED_BEE_REWARDS_PER_EPOCH * epochsToReward;\\n            } else {\\n                amount += HONEY_STAKED_BEE_REWARDS_PER_EPOCH * epochsToReward;\\n            }\\n        }\\n        amount = amount * 1e16;\\n    }\\n\\n    /***********Settes & Getters**************/\\n\\n    function setBears(address _contract) external onlyOwner {\\n        require(_contract != address(0), \\\"Can not be address 0\\\");\\n        bears = BearsDeluxeI(_contract);\\n        emit SetContract(\\\"BearsDeluxe\\\", _contract);\\n    }\\n\\n    function setHoney(address _contract) external onlyOwner {\\n        require(_contract != address(0), \\\"Can not be address 0\\\");\\n        honey = HoneyTokenI(_contract);\\n        emit SetContract(\\\"HoneyToken\\\", _contract);\\n    }\\n\\n    function setHive(address _contract) external onlyOwner {\\n        require(_contract != address(0), \\\"Can not be address 0\\\");\\n        hive = HoneyHiveDeluxeI(_contract);\\n        emit SetContract(\\\"HoneyHive\\\", _contract);\\n    }\\n\\n    function setBees(address _contract) external onlyOwner {\\n        require(_contract != address(0), \\\"Can not be address 0\\\");\\n        bees = BeesDeluxeI(_contract);\\n        emit SetContract(\\\"BeesDeluxe\\\", _contract);\\n    }\\n\\n    function setInitialStartingPoint(uint256 _startingPoint) external onlyOwner {\\n        STARTING_POINT = _startingPoint;\\n        emit StartingPointChanged(_startingPoint);\\n    }\\n\\n    function getInitialStartingPoint() external view returns (uint256) {\\n        return STARTING_POINT;\\n    }\\n\\n    function setHoneyEpochLength(uint256 _epochLength) external onlyOwner {\\n        EPOCH_LENGTH = _epochLength;\\n        emit EpochChange(\\\"HoneyEpochLength\\\", _epochLength);\\n    }\\n\\n    function setHiveClaimEpochLength(uint256 _epochLength) external onlyOwner {\\n        HIVE_CLAIM_EPOCH_LENGTH = _epochLength;\\n        emit EpochChange(\\\"HiveEpochLength\\\", _epochLength);\\n    }\\n\\n    function setNoOfEpochsBeforeInactiveBee(uint16 _epochs) external onlyOwner {\\n        EPOCHS_BEFORE_INACTIVE_BEE = _epochs;\\n        emit EpochChange(\\\"NoOfEpochBeforeInactiveBee\\\", _epochs);\\n    }\\n\\n    /**\\n     * @dev Sets the activitiy of the Bears/Bee/Hive as paused or not, only use in case of emergency.\\n     * 1 = Paused\\n     * 0 = Active\\n     */\\n    function setPauseState(\\n        uint8 _pauseBears,\\n        uint8 _pauseHives,\\n        uint8 _pauseBees\\n    ) external onlyOwner {\\n        paused.pauseBears = _pauseBears;\\n        paused.pauseHive = _pauseHives;\\n        paused.pauseBee = _pauseBees;\\n        emit PauseChanged(_pauseBears, _pauseHives, _pauseBees);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal initializer {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal initializer {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BearsDeluxeI.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nabstract contract BearsDeluxeI is Ownable, IERC721 {\\n    function mint(address _owner, uint256 _tokenId) external virtual;\\n\\n    function exists(uint256 _tokenId) external view virtual returns (bool);\\n\\n    function getMaxSupply() external virtual returns (uint256);\\n\\n    function tokensOfOwner(address _owner) external view virtual returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/HoneyTokenI.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nabstract contract HoneyTokenI is Ownable, IERC20 {\\n    function mint(address _owner, uint256 _amount) external virtual;\\n    function burn(address _owner, uint256 _amount) external virtual;\\n\\n    function maxSupply() external pure virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BeesDeluxeI.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\nabstract contract BeesDeluxeI is Ownable, IERC721, IERC721Enumerable {\\n    function mint(address _owner, uint256 _tokenId) external virtual;\\n\\n    function exists(uint256 _tokenId) external view virtual returns (bool);\\n\\n    function getMaxSupply() external view virtual returns (uint256);\\n\\n    function tokensOfOwner(address _owner) external view virtual returns (uint256[] memory);\\n\\n    function totalSupply() public view virtual returns (uint256);\\n\\n    function burnByQueen(uint256 _tokenId) external virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/HoneyHiveDeluxeI.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nabstract contract HoneyHiveDeluxeI is Ownable, IERC721 {\\n    function mint(address _owner, uint256 _bearId) external virtual;\\n\\n    function exists(uint256 _tokenId) external view virtual returns (bool);\\n\\n    function getMaxSupply() external virtual returns (uint256);\\n\\n    function increaseUsageOfMintingBee(uint256 _hiveId) external virtual;\\n\\n    function getUsageOfMintingBee(uint256 _hiveId) external view virtual returns (uint8);\\n\\n    function resetUsageOfMintingBee(uint256 _hiveId) external virtual;\\n\\n    function tokensOfOwner(address _owner) external view virtual returns (uint256[] memory);\\n\\n    function totalSupply() public view virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_beeId\",\"type\":\"uint256\"}],\"name\":\"BeeActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_beeId\",\"type\":\"uint256\"}],\"name\":\"BeeBurnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"BeeClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_beeId\",\"type\":\"uint256\"}],\"name\":\"BeeKeptActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_beeId\",\"type\":\"uint256\"}],\"name\":\"BeeStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_beeId\",\"type\":\"uint256\"}],\"name\":\"BeeUnstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"epochType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"EpochChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_hiveId\",\"type\":\"uint256\"}],\"name\":\"HiveActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"HoneyClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"HoneyHiveClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_pauseBears\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_pauseHives\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_pauseBees\",\"type\":\"uint8\"}],\"name\":\"PauseChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"_contract\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"SetContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startingPoint\",\"type\":\"uint256\"}],\"name\":\"StartingPointChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AMOUNT_FOR_ACTIVATE_HIVE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AMOUNT_TO_KEEP_ACTIVE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BURN_AMOUNT_FOR_STAKING_BEE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EPOCHS_BEFORE_INACTIVE_BEE\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EPOCH_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HIVE_CLAIM_EPOCH_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HONEY_BEARS_REWARDS_PER_ROUND\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HONEY_STAKED_BEE_REWARDS_PER_EPOCH\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HONEY_UNSTAKED_BEE_REWARDS_PER_EPOCH\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_USAGE_PER_HIVE\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_AMOUNT_FOR_ACTIVATE_BEE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_BURN_AMOUNT_FOR_CLAIMING_BEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_FOR_BURNING_BEE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STARTING_POINT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_beesIds\",\"type\":\"uint16[]\"}],\"name\":\"activateBees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_hiveId\",\"type\":\"uint16\"}],\"name\":\"activateHive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bears\",\"outputs\":[{\"internalType\":\"contract BearsDeluxeI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bees\",\"outputs\":[{\"internalType\":\"contract BeesDeluxeI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_beesIds\",\"type\":\"uint16[]\"}],\"name\":\"burnBees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_bearsIds\",\"type\":\"uint16[]\"}],\"name\":\"claimBearsHoney\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_beesIds\",\"type\":\"uint16[]\"}],\"name\":\"claimBeesHoney\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_beeId\",\"type\":\"uint16\"}],\"name\":\"getBeeState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"active\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"epochsLeft\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"staked\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"becameInactiveTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTimeFed\",\"type\":\"uint256\"}],\"internalType\":\"struct HoneyFarmQueenDeluxe.Bee\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_beesIds\",\"type\":\"uint16[]\"}],\"name\":\"getBeesState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"active\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"epochsLeft\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"staked\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"becameInactiveTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastTimeFed\",\"type\":\"uint256\"}],\"internalType\":\"struct HoneyFarmQueenDeluxe.Bee[]\",\"name\":\"beesToReturn\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getInitialStartingPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_bearId\",\"type\":\"uint16\"}],\"name\":\"getLastRewardedByBear\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_beeId\",\"type\":\"uint16\"}],\"name\":\"getLastRewardedByBee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_hiveId\",\"type\":\"uint16\"}],\"name\":\"getLastTimeBeeClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getUnclaimedHoneyForBears\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getUnclaimedHoneyForBees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hive\",\"outputs\":[{\"internalType\":\"contract HoneyHiveDeluxeI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"honey\",\"outputs\":[{\"internalType\":\"contract HoneyTokenI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_beesIds\",\"type\":\"uint16[]\"}],\"name\":\"keepBeesActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_hiveId\",\"type\":\"uint16\"}],\"name\":\"mintBee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_bearsId\",\"type\":\"uint16\"}],\"name\":\"mintHive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"pauseBee\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"pauseHive\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"pauseBears\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setBears\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setBees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setHive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epochLength\",\"type\":\"uint256\"}],\"name\":\"setHiveClaimEpochLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"setHoney\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epochLength\",\"type\":\"uint256\"}],\"name\":\"setHoneyEpochLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startingPoint\",\"type\":\"uint256\"}],\"name\":\"setInitialStartingPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_epochs\",\"type\":\"uint16\"}],\"name\":\"setNoOfEpochsBeforeInactiveBee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_pauseBears\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_pauseHives\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_pauseBees\",\"type\":\"uint8\"}],\"name\":\"setPauseState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_beesIds\",\"type\":\"uint16[]\"}],\"name\":\"stakeBees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMintedBees\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_beesIds\",\"type\":\"uint16[]\"}],\"name\":\"unstakeBees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"HoneyFarmQueenDeluxe","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}