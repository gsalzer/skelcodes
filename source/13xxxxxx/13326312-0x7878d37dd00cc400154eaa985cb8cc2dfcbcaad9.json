{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interests/multipliers/AaveMultiplier.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\nimport \\\"./IMultiplierCalculator.sol\\\";\\nimport \\\"./utils/IPalPoolSimplified.sol\\\";\\nimport \\\"./utils/AAVE/IProposalValidator.sol\\\";\\nimport \\\"./utils/AAVE/IAaveGovernanceV2.sol\\\";\\nimport \\\"./utils/AAVE/IGovernanceStrategy.sol\\\";\\nimport \\\"../../utils/SafeMath.sol\\\";\\nimport \\\"../../utils/Admin.sol\\\";\\n\\n/** @title Multiplier Calculator for Aave Governance  */\\n/// @author Paladin\\ncontract AaveMultiplier is IMultiplierCalculator, Admin {\\n    using SafeMath for uint;\\n\\n    // Aave Governance contracts\\n    IProposalValidator public executor;\\n    IAaveGovernanceV2 public governance;\\n    IGovernanceStrategy public strategy;\\n\\n    address[] public pools;\\n\\n    uint256 public activationThreshold;\\n\\n    constructor(\\n        address _governance,\\n        address _executor,\\n        address[] memory _pools\\n    ){\\n        admin = msg.sender;\\n\\n        executor = IProposalValidator(_executor);\\n        governance = IAaveGovernanceV2(_governance);\\n        strategy = IGovernanceStrategy(governance.getGovernanceStrategy());\\n\\n        activationThreshold = 0.75e18;\\n        \\n        for(uint i = 0; i < _pools.length; i++){\\n            pools.push(_pools[i]);\\n        }\\n    }\\n\\n    function getCurrentMultiplier() external override view returns(uint){\\n        uint totalBorrowed = getTotalBorrowedMultiPools();\\n        uint proposalThreshold = executor.getMinimumPropositionPowerNeeded(governance, block.number);\\n\\n        if(totalBorrowed > proposalThreshold.mul(activationThreshold).div(1e18)){\\n            uint quorumAmount = executor.getMinimumVotingPowerNeeded(\\n                strategy.getTotalVotingSupplyAt(block.number)\\n            );\\n\\n            uint leftPart = (totalBorrowed.mul(1e18).div(proposalThreshold.mul(activationThreshold).div(1e18))).sub(1e18);\\n            uint rightPart = quorumAmount.mul(1e18).div(totalBorrowed);\\n\\n            return uint(1e18).add(leftPart.mul(rightPart).div(1e18));\\n        }\\n        //default case\\n        return 1e18;\\n    }\\n\\n\\n    function getTotalBorrowedMultiPools() internal view returns(uint){\\n        uint total = 0;\\n        address[] memory _pools = pools;\\n        for(uint i = 0; i < _pools.length; i++){\\n            total = total.add(IPalPoolSimplified(_pools[i]).totalBorrowed());\\n        }\\n        return total;\\n    }\\n\\n\\n\\n    //Admin functions\\n\\n    function addPool(address _pool) external adminOnly {\\n        pools.push(_pool);\\n    }\\n\\n    function removePool(address _pool) external adminOnly {\\n        address[] memory _pools = pools;\\n        for(uint i; i < _pools.length; i++){\\n            if(_pools[i] == _pool){\\n                uint lastIndex = _pools.length.sub(1);\\n                if(i != lastIndex){\\n                    pools[i] = pools[lastIndex];\\n                }\\n                pools.pop();\\n            }\\n        }\\n    }\\n\\n    function updateGovernance(address newGovernance) external adminOnly {\\n        governance = IAaveGovernanceV2(newGovernance);\\n    }\\n\\n    function updateGovernanceStrategy() external adminOnly {\\n        strategy = IGovernanceStrategy(governance.getGovernanceStrategy());\\n    }\\n\\n\\n    function updateExecutor(address newExecutor) external adminOnly {\\n        executor = IProposalValidator(newExecutor);\\n    }\\n\\n\\n    function updateActivationThreshold(uint newThreshold) external adminOnly {\\n        require(newThreshold >= 0.5e18);\\n        require(newThreshold < 1e18);\\n        activationThreshold = newThreshold;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/interests/multipliers/IMultiplierCalculator.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\n/** @title MultiplierCalculator Interface  */\\n/// @author Paladin\\ninterface IMultiplierCalculator {\\n\\n    function getCurrentMultiplier() external view returns(uint);\\n}\"\r\n    },\r\n    \"contracts/interests/multipliers/utils/IPalPoolSimplified.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\ninterface IPalPoolSimplified {\\n\\n    function totalBorrowed() external view returns(uint);\\n\\n}\"\r\n    },\r\n    \"contracts/interests/multipliers/utils/AAVE/IProposalValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport {IAaveGovernanceV2} from \\\"./IAaveGovernanceV2.sol\\\";\\n\\ninterface IProposalValidator {\\n    /**\\n     * @dev Called to validate a proposal (e.g when creating new proposal in Governance)\\n     * @param governance Governance Contract\\n     * @param user Address of the proposal creator\\n     * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n     * @return boolean, true if can be created\\n     **/\\n    function validateCreatorOfProposal(\\n        IAaveGovernanceV2 governance,\\n        address user,\\n        uint256 blockNumber\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Called to validate the cancellation of a proposal\\n     * @param governance Governance Contract\\n     * @param user Address of the proposal creator\\n     * @param blockNumber Block Number against which to make the test (e.g proposal creation block -1).\\n     * @return boolean, true if can be cancelled\\n     **/\\n    function validateProposalCancellation(\\n        IAaveGovernanceV2 governance,\\n        address user,\\n        uint256 blockNumber\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Returns whether a user has enough Proposition Power to make a proposal.\\n     * @param governance Governance Contract\\n     * @param user Address of the user to be challenged.\\n     * @param blockNumber Block Number against which to make the challenge.\\n     * @return true if user has enough power\\n     **/\\n    function isPropositionPowerEnough(\\n        IAaveGovernanceV2 governance,\\n        address user,\\n        uint256 blockNumber\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the minimum Proposition Power needed to create a proposition.\\n     * @param governance Governance Contract\\n     * @param blockNumber Blocknumber at which to evaluate\\n     * @return minimum Proposition Power needed\\n     **/\\n    function getMinimumPropositionPowerNeeded(\\n        IAaveGovernanceV2 governance,\\n        uint256 blockNumber\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns whether a proposal passed or not\\n     * @param governance Governance Contract\\n     * @param proposalId Id of the proposal to set\\n     * @return true if proposal passed\\n     **/\\n    function isProposalPassed(IAaveGovernanceV2 governance, uint256 proposalId) external view returns (bool);\\n\\n    /**\\n     * @dev Check whether a proposal has reached quorum, ie has enough FOR-voting-power\\n     * Here quorum is not to understand as number of votes reached, but number of for-votes reached\\n     * @param governance Governance Contract\\n     * @param proposalId Id of the proposal to verify\\n     * @return voting power needed for a proposal to pass\\n     **/\\n    function isQuorumValid(IAaveGovernanceV2 governance, uint256 proposalId) external view returns (bool);\\n\\n    /**\\n     * @dev Check whether a proposal has enough extra FOR-votes than AGAINST-votes\\n     * FOR VOTES - AGAINST VOTES > VOTE_DIFFERENTIAL * voting supply\\n     * @param governance Governance Contract\\n     * @param proposalId Id of the proposal to verify\\n     * @return true if enough For-Votes\\n     **/\\n    function isVoteDifferentialValid(\\n        IAaveGovernanceV2 governance,\\n        uint256 proposalId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Calculates the minimum amount of Voting Power needed for a proposal to Pass\\n     * @param votingSupply Total number of oustanding voting tokens\\n     * @return voting power needed for a proposal to pass\\n     **/\\n    function getMinimumVotingPowerNeeded(uint256 votingSupply) external view returns (uint256);\\n\\n    /**\\n     * @dev Get proposition threshold constant value\\n     * @return the proposition threshold value (100 <=> 1%)\\n     **/\\n    // solhint-disable-next-line\\n    function PROPOSITION_THRESHOLD() external view returns (uint256);\\n\\n    /**\\n     * @dev Get voting duration constant value\\n     * @return the voting duration value in seconds\\n     **/\\n    // solhint-disable-next-line\\n    function VOTING_DURATION() external view returns (uint256);\\n\\n    /**\\n     * @dev Get the vote differential threshold constant value\\n     * to compare with % of for votes/total supply - % of against votes/total supply\\n     * @return the vote differential threshold value (100 <=> 1%)\\n     **/\\n    // solhint-disable-next-line\\n    function VOTE_DIFFERENTIAL() external view returns (uint256);\\n\\n    /**\\n     * @dev Get quorum threshold constant value\\n     * to compare with % of for votes/total supply\\n     * @return the quorum threshold value (100 <=> 1%)\\n     **/\\n    // solhint-disable-next-line\\n    function MINIMUM_QUORUM() external view returns (uint256);\\n\\n    /**\\n     * @dev precision helper: 100% = 10000\\n     * @return one hundred percents with our chosen precision\\n     **/\\n    // solhint-disable-next-line\\n    function ONE_HUNDRED_WITH_PRECISION() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interests/multipliers/utils/AAVE/IAaveGovernanceV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport {IExecutorWithTimelock} from \\\"./IExecutorWithTimelock.sol\\\";\\n\\ninterface IAaveGovernanceV2 {\\n    enum ProposalState {\\n        Pending,\\n        Canceled,\\n        Active,\\n        Failed,\\n        Succeeded,\\n        Queued,\\n        Expired,\\n        Executed\\n    }\\n\\n    struct Vote {\\n        bool support;\\n        uint248 votingPower;\\n    }\\n\\n    struct Proposal {\\n        uint256 id;\\n        address creator;\\n        IExecutorWithTimelock executor;\\n        address[] targets;\\n        uint256[] values;\\n        string[] signatures;\\n        bytes[] calldatas;\\n        bool[] withDelegatecalls;\\n        uint256 startBlock;\\n        uint256 endBlock;\\n        uint256 executionTime;\\n        uint256 forVotes;\\n        uint256 againstVotes;\\n        bool executed;\\n        bool canceled;\\n        address strategy;\\n        bytes32 ipfsHash;\\n        mapping(address => Vote) votes;\\n    }\\n\\n    struct ProposalWithoutVotes {\\n        uint256 id;\\n        address creator;\\n        IExecutorWithTimelock executor;\\n        address[] targets;\\n        uint256[] values;\\n        string[] signatures;\\n        bytes[] calldatas;\\n        bool[] withDelegatecalls;\\n        uint256 startBlock;\\n        uint256 endBlock;\\n        uint256 executionTime;\\n        uint256 forVotes;\\n        uint256 againstVotes;\\n        bool executed;\\n        bool canceled;\\n        address strategy;\\n        bytes32 ipfsHash;\\n    }\\n\\n    /**\\n     * @dev emitted when a new proposal is created\\n     * @param id Id of the proposal\\n     * @param creator address of the creator\\n     * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n     * @param targets list of contracts called by proposal's associated transactions\\n     * @param values list of value in wei for each propoposal's associated transaction\\n     * @param signatures list of function signatures (can be empty) to be used when created the callData\\n     * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\\n     * @param withDelegatecalls boolean, true = transaction delegatecalls the taget, else calls the target\\n     * @param startBlock block number when vote starts\\n     * @param endBlock block number when vote ends\\n     * @param strategy address of the governanceStrategy contract\\n     * @param ipfsHash IPFS hash of the proposal\\n     **/\\n    event ProposalCreated(\\n        uint256 id,\\n        address indexed creator,\\n        IExecutorWithTimelock indexed executor,\\n        address[] targets,\\n        uint256[] values,\\n        string[] signatures,\\n        bytes[] calldatas,\\n        bool[] withDelegatecalls,\\n        uint256 startBlock,\\n        uint256 endBlock,\\n        address strategy,\\n        bytes32 ipfsHash\\n    );\\n\\n    /**\\n     * @dev emitted when a proposal is canceled\\n     * @param id Id of the proposal\\n     **/\\n    event ProposalCanceled(uint256 id);\\n\\n    /**\\n     * @dev emitted when a proposal is queued\\n     * @param id Id of the proposal\\n     * @param executionTime time when proposal underlying transactions can be executed\\n     * @param initiatorQueueing address of the initiator of the queuing transaction\\n     **/\\n    event ProposalQueued(\\n        uint256 id,\\n        uint256 executionTime,\\n        address indexed initiatorQueueing\\n    );\\n    /**\\n     * @dev emitted when a proposal is executed\\n     * @param id Id of the proposal\\n     * @param initiatorExecution address of the initiator of the execution transaction\\n     **/\\n    event ProposalExecuted(uint256 id, address indexed initiatorExecution);\\n    /**\\n     * @dev emitted when a vote is registered\\n     * @param id Id of the proposal\\n     * @param voter address of the voter\\n     * @param support boolean, true = vote for, false = vote against\\n     * @param votingPower Power of the voter/vote\\n     **/\\n    event VoteEmitted(\\n        uint256 id,\\n        address indexed voter,\\n        bool support,\\n        uint256 votingPower\\n    );\\n\\n    event GovernanceStrategyChanged(\\n        address indexed newStrategy,\\n        address indexed initiatorChange\\n    );\\n\\n    event VotingDelayChanged(\\n        uint256 newVotingDelay,\\n        address indexed initiatorChange\\n    );\\n\\n    event ExecutorAuthorized(address executor);\\n\\n    event ExecutorUnauthorized(address executor);\\n\\n    /**\\n     * @dev Creates a Proposal (needs Proposition Power of creator > Threshold)\\n     * @param executor The ExecutorWithTimelock contract that will execute the proposal\\n     * @param targets list of contracts called by proposal's associated transactions\\n     * @param values list of value in wei for each propoposal's associated transaction\\n     * @param signatures list of function signatures (can be empty) to be used when created the callData\\n     * @param calldatas list of calldatas: if associated signature empty, calldata ready, else calldata is arguments\\n     * @param withDelegatecalls if true, transaction delegatecalls the taget, else calls the target\\n     * @param ipfsHash IPFS hash of the proposal\\n     **/\\n    function create(\\n        IExecutorWithTimelock executor,\\n        address[] memory targets,\\n        uint256[] memory values,\\n        string[] memory signatures,\\n        bytes[] memory calldatas,\\n        bool[] memory withDelegatecalls,\\n        bytes32 ipfsHash\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Cancels a Proposal,\\n     * either at anytime by guardian\\n     * or when proposal is Pending/Active and threshold no longer reached\\n     * @param proposalId id of the proposal\\n     **/\\n    function cancel(uint256 proposalId) external;\\n\\n    /**\\n     * @dev Queue the proposal (If Proposal Succeeded)\\n     * @param proposalId id of the proposal to queue\\n     **/\\n    function queue(uint256 proposalId) external;\\n\\n    /**\\n     * @dev Execute the proposal (If Proposal Queued)\\n     * @param proposalId id of the proposal to execute\\n     **/\\n    function execute(uint256 proposalId) external payable;\\n\\n    /**\\n     * @dev Function allowing msg.sender to vote for/against a proposal\\n     * @param proposalId id of the proposal\\n     * @param support boolean, true = vote for, false = vote against\\n     **/\\n    function submitVote(uint256 proposalId, bool support) external;\\n\\n    /**\\n     * @dev Function to register the vote of user that has voted offchain via signature\\n     * @param proposalId id of the proposal\\n     * @param support boolean, true = vote for, false = vote against\\n     * @param v v part of the voter signature\\n     * @param r r part of the voter signature\\n     * @param s s part of the voter signature\\n     **/\\n    function submitVoteBySignature(\\n        uint256 proposalId,\\n        bool support,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Set new GovernanceStrategy\\n     * Note: owner should be a timelocked executor, so needs to make a proposal\\n     * @param governanceStrategy new Address of the GovernanceStrategy contract\\n     **/\\n    function setGovernanceStrategy(address governanceStrategy) external;\\n\\n    /**\\n     * @dev Set new Voting Delay (delay before a newly created proposal can be voted on)\\n     * Note: owner should be a timelocked executor, so needs to make a proposal\\n     * @param votingDelay new voting delay in seconds\\n     **/\\n    function setVotingDelay(uint256 votingDelay) external;\\n\\n    /**\\n     * @dev Add new addresses to the list of authorized executors\\n     * @param executors list of new addresses to be authorized executors\\n     **/\\n    function authorizeExecutors(address[] memory executors) external;\\n\\n    /**\\n     * @dev Remove addresses to the list of authorized executors\\n     * @param executors list of addresses to be removed as authorized executors\\n     **/\\n    function unauthorizeExecutors(address[] memory executors) external;\\n\\n    /**\\n     * @dev Let the guardian abdicate from its priviledged rights\\n     **/\\n    function __abdicate() external;\\n\\n    /**\\n     * @dev Getter of the current GovernanceStrategy address\\n     * @return The address of the current GovernanceStrategy contracts\\n     **/\\n    function getGovernanceStrategy() external view returns (address);\\n\\n    /**\\n     * @dev Getter of the current Voting Delay (delay before a created proposal can be voted on)\\n     * Different from the voting duration\\n     * @return The voting delay in seconds\\n     **/\\n    function getVotingDelay() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns whether an address is an authorized executor\\n     * @param executor address to evaluate as authorized executor\\n     * @return true if authorized\\n     **/\\n    function isExecutorAuthorized(address executor) external view returns (bool);\\n\\n    /**\\n     * @dev Getter the address of the guardian, that can mainly cancel proposals\\n     * @return The address of the guardian\\n     **/\\n    function getGuardian() external view returns (address);\\n\\n    /**\\n     * @dev Getter of the proposal count (the current number of proposals ever created)\\n     * @return the proposal count\\n     **/\\n    function getProposalsCount() external view returns (uint256);\\n\\n    /**\\n     * @dev Getter of a proposal by id\\n     * @param proposalId id of the proposal to get\\n     * @return the proposal as ProposalWithoutVotes memory object\\n     **/\\n    function getProposalById(uint256 proposalId) external view returns (ProposalWithoutVotes memory);\\n\\n    /**\\n     * @dev Getter of the Vote of a voter about a proposal\\n     * Note: Vote is a struct: ({bool support, uint248 votingPower})\\n     * @param proposalId id of the proposal\\n     * @param voter address of the voter\\n     * @return The associated Vote memory object\\n     **/\\n    function getVoteOnProposal(uint256 proposalId, address voter) external view returns (Vote memory);\\n\\n    /**\\n     * @dev Get the current state of a proposal\\n     * @param proposalId id of the proposal\\n     * @return The current state if the proposal\\n     **/\\n    function getProposalState(uint256 proposalId) external view returns (ProposalState);\\n}\\n\"\r\n    },\r\n    \"contracts/interests/multipliers/utils/AAVE/IGovernanceStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\ninterface IGovernanceStrategy {\\n    /**\\n     * @dev Returns the Proposition Power of a user at a specific block number.\\n     * @param user Address of the user.\\n     * @param blockNumber Blocknumber at which to fetch Proposition Power\\n     * @return Power number\\n     **/\\n    function getPropositionPowerAt(address user, uint256 blockNumber) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total supply of Outstanding Proposition Tokens\\n     * @param blockNumber Blocknumber at which to evaluate\\n     * @return total supply at blockNumber\\n     **/\\n    function getTotalPropositionSupplyAt(uint256 blockNumber) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the total supply of Outstanding Voting Tokens\\n     * @param blockNumber Blocknumber at which to evaluate\\n     * @return total supply at blockNumber\\n     **/\\n    function getTotalVotingSupplyAt(uint256 blockNumber) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the Vote Power of a user at a specific block number.\\n     * @param user Address of the user.\\n     * @param blockNumber Blocknumber at which to fetch Vote Power\\n     * @return Vote number\\n     **/\\n    function getVotingPowerAt(address user, uint256 blockNumber) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/Admin.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\n\\n/** @title Admin contract  */\\n/// @author Paladin\\ncontract Admin {\\n\\n    /** @notice (Admin) Event when the contract admin is updated */\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    /** @dev Admin address for this contract */\\n    address payable internal admin;\\n    \\n    modifier adminOnly() {\\n        //allows only the admin of this contract to call the function\\n        require(msg.sender == admin, '1');\\n        _;\\n    }\\n\\n        /**\\n    * @notice Set a new Admin\\n    * @dev Changes the address for the admin parameter\\n    * @param _newAdmin address of the new Controller Admin\\n    */\\n    function setNewAdmin(address payable _newAdmin) external adminOnly {\\n        address _oldAdmin = admin;\\n        admin = _newAdmin;\\n\\n        emit NewAdmin(_oldAdmin, _newAdmin);\\n    }\\n}\"\r\n    },\r\n    \"contracts/interests/multipliers/utils/AAVE/IExecutorWithTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n\\nimport {IAaveGovernanceV2} from \\\"./IAaveGovernanceV2.sol\\\";\\n\\ninterface IExecutorWithTimelock {\\n    /**\\n     * @dev emitted when a new pending admin is set\\n     * @param newPendingAdmin address of the new pending admin\\n     **/\\n    event NewPendingAdmin(address newPendingAdmin);\\n\\n    /**\\n     * @dev emitted when a new admin is set\\n     * @param newAdmin address of the new admin\\n     **/\\n    event NewAdmin(address newAdmin);\\n\\n    /**\\n     * @dev emitted when a new delay (between queueing and execution) is set\\n     * @param delay new delay\\n     **/\\n    event NewDelay(uint256 delay);\\n\\n    /**\\n     * @dev emitted when a new (trans)action is Queued.\\n     * @param actionHash hash of the action\\n     * @param target address of the targeted contract\\n     * @param value wei value of the transaction\\n     * @param signature function signature of the transaction\\n     * @param data function arguments of the transaction or callData if signature empty\\n     * @param executionTime time at which to execute the transaction\\n     * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n     **/\\n    event QueuedAction(\\n        bytes32 actionHash,\\n        address indexed target,\\n        uint256 value,\\n        string signature,\\n        bytes data,\\n        uint256 executionTime,\\n        bool withDelegatecall\\n    );\\n\\n    /**\\n     * @dev emitted when an action is Cancelled\\n     * @param actionHash hash of the action\\n     * @param target address of the targeted contract\\n     * @param value wei value of the transaction\\n     * @param signature function signature of the transaction\\n     * @param data function arguments of the transaction or callData if signature empty\\n     * @param executionTime time at which to execute the transaction\\n     * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n     **/\\n    event CancelledAction(\\n        bytes32 actionHash,\\n        address indexed target,\\n        uint256 value,\\n        string signature,\\n        bytes data,\\n        uint256 executionTime,\\n        bool withDelegatecall\\n    );\\n\\n    /**\\n     * @dev emitted when an action is Cancelled\\n     * @param actionHash hash of the action\\n     * @param target address of the targeted contract\\n     * @param value wei value of the transaction\\n     * @param signature function signature of the transaction\\n     * @param data function arguments of the transaction or callData if signature empty\\n     * @param executionTime time at which to execute the transaction\\n     * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n     * @param resultData the actual callData used on the target\\n     **/\\n    event ExecutedAction(\\n        bytes32 actionHash,\\n        address indexed target,\\n        uint256 value,\\n        string signature,\\n        bytes data,\\n        uint256 executionTime,\\n        bool withDelegatecall,\\n        bytes resultData\\n    );\\n\\n    /**\\n     * @dev Getter of the current admin address (should be governance)\\n     * @return The address of the current admin\\n     **/\\n    function getAdmin() external view returns (address);\\n\\n    /**\\n     * @dev Getter of the current pending admin address\\n     * @return The address of the pending admin\\n     **/\\n    function getPendingAdmin() external view returns (address);\\n\\n    /**\\n     * @dev Getter of the delay between queuing and execution\\n     * @return The delay in seconds\\n     **/\\n    function getDelay() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns whether an action (via actionHash) is queued\\n     * @param actionHash hash of the action to be checked\\n     * keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\\n     * @return true if underlying action of actionHash is queued\\n     **/\\n    function isActionQueued(bytes32 actionHash) external view returns (bool);\\n\\n    /**\\n     * @dev Checks whether a proposal is over its grace period\\n     * @param governance Governance contract\\n     * @param proposalId Id of the proposal against which to test\\n     * @return true of proposal is over grace period\\n     **/\\n    function isProposalOverGracePeriod(\\n        IAaveGovernanceV2 governance,\\n        uint256 proposalId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Getter of grace period constant\\n     * @return grace period in seconds\\n     **/\\n    function GRACE_PERIOD() external view returns (uint256);\\n\\n    /**\\n     * @dev Getter of minimum delay constant\\n     * @return minimum delay in seconds\\n     **/\\n    function MINIMUM_DELAY() external view returns (uint256);\\n\\n    /**\\n     * @dev Getter of maximum delay constant\\n     * @return maximum delay in seconds\\n     **/\\n    function MAXIMUM_DELAY() external view returns (uint256);\\n\\n    /**\\n     * @dev Function, called by Governance, that queue a transaction, returns action hash\\n     * @param target smart contract target\\n     * @param value wei value of the transaction\\n     * @param signature function signature of the transaction\\n     * @param data function arguments of the transaction or callData if signature empty\\n     * @param executionTime time at which to execute the transaction\\n     * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n     **/\\n    function queueTransaction(\\n        address target,\\n        uint256 value,\\n        string memory signature,\\n        bytes memory data,\\n        uint256 executionTime,\\n        bool withDelegatecall\\n    ) external returns (bytes32);\\n\\n    /**\\n     * @dev Function, called by Governance, that cancels a transaction, returns the callData executed\\n     * @param target smart contract target\\n     * @param value wei value of the transaction\\n     * @param signature function signature of the transaction\\n     * @param data function arguments of the transaction or callData if signature empty\\n     * @param executionTime time at which to execute the transaction\\n     * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n     **/\\n    function executeTransaction(\\n        address target,\\n        uint256 value,\\n        string memory signature,\\n        bytes memory data,\\n        uint256 executionTime,\\n        bool withDelegatecall\\n    ) external payable returns (bytes memory);\\n\\n    /**\\n     * @dev Function, called by Governance, that cancels a transaction, returns action hash\\n     * @param target smart contract target\\n     * @param value wei value of the transaction\\n     * @param signature function signature of the transaction\\n     * @param data function arguments of the transaction or callData if signature empty\\n     * @param executionTime time at which to execute the transaction\\n     * @param withDelegatecall boolean, true = transaction delegatecalls the target, else calls the target\\n     **/\\n    function cancelTransaction(\\n        address target,\\n        uint256 value,\\n        string memory signature,\\n        bytes memory data,\\n        uint256 executionTime,\\n        bool withDelegatecall\\n    ) external returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 25000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_pools\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activationThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executor\",\"outputs\":[{\"internalType\":\"contract IProposalValidator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"contract IAaveGovernanceV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"removePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setNewAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategy\",\"outputs\":[{\"internalType\":\"contract IGovernanceStrategy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newThreshold\",\"type\":\"uint256\"}],\"name\":\"updateActivationThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newExecutor\",\"type\":\"address\"}],\"name\":\"updateExecutor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"updateGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateGovernanceStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AaveMultiplier","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"25000","ConstructorArguments":"000000000000000000000000ec568fffba86c094cf06b22134b23074dfe2252c000000000000000000000000ee56e2b3d491590b5b31738cc34d5232f378a8d500000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000002000000000000000000000000414b947b37ee7e716ab11c72979f6d002417233e000000000000000000000000cdc3dd86c99b58749de0f697dfc1abe4be22216d","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}