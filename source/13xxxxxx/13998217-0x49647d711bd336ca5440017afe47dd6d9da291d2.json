{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/v2/TestRoyaltiesRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"@rarible/royalties/contracts/IRoyaltiesProvider.sol\\\";\\nimport \\\"@rarible/royalties/contracts/LibRoyaltiesV2.sol\\\";\\nimport \\\"@rarible/royalties/contracts/LibRoyaltiesV1.sol\\\";\\nimport \\\"@rarible/royalties/contracts/impl/RoyaltiesV1Impl.sol\\\";\\nimport \\\"@rarible/royalties/contracts/impl/RoyaltiesV2Impl.sol\\\";\\nimport \\\"@rarible/royalties/contracts/LibRoyalties2981.sol\\\";\\nimport \\\"@rarible/royalties/contracts/IERC2981.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol\\\";\\n\\ncontract TestRoyaltiesRegistry is IRoyaltiesProvider {\\n\\n\\tstruct RoyaltiesSet {\\n\\t\\tbool initialized;\\n\\t\\tLibPart.Part[] royalties;\\n\\t}\\n\\n\\tmapping(bytes32 => RoyaltiesSet) public royaltiesByTokenAndTokenId;\\n\\tmapping(address => RoyaltiesSet) public royaltiesByToken;\\n\\n\\tfunction setRoyaltiesByToken(address token, LibPart.Part[] memory royalties) external {\\n\\t\\tuint sumRoyalties = 0;\\n\\t\\tfor (uint i = 0; i < royalties.length; i++) {\\n\\t\\t\\trequire(royalties[i].account != address(0x0), \\\"RoyaltiesByToken recipient should be present\\\");\\n\\t\\t\\trequire(royalties[i].value != 0, \\\"Fee value for RoyaltiesByToken should be > 0\\\");\\n\\t\\t\\troyaltiesByToken[token].royalties.push(royalties[i]);\\n\\t\\t\\tsumRoyalties += royalties[i].value;\\n\\t\\t}\\n\\t\\trequire(sumRoyalties < 10000, \\\"Set by token royalties sum more, than 100%\\\");\\n\\t\\troyaltiesByToken[token].initialized = true;\\n\\t}\\n\\n\\tfunction setRoyaltiesByTokenAndTokenId(address token, uint tokenId, LibPart.Part[] memory royalties) external {\\n\\t\\tsetRoyaltiesCacheByTokenAndTokenId(token, tokenId, royalties);\\n\\t}\\n\\n\\tfunction getRoyalties(address token, uint tokenId) view override external returns (LibPart.Part[] memory) {\\n\\t\\tRoyaltiesSet memory royaltiesSet = royaltiesByTokenAndTokenId[keccak256(abi.encode(token, tokenId))];\\n\\t\\tif (royaltiesSet.initialized) {\\n\\t\\t\\treturn royaltiesSet.royalties;\\n\\t\\t}\\n\\t\\troyaltiesSet = royaltiesByToken[token];\\n\\t\\tif (royaltiesSet.initialized) {\\n\\t\\t\\treturn royaltiesSet.royalties;\\n\\t\\t} else if (IERC165Upgradeable(token).supportsInterface(LibRoyalties2981._INTERFACE_ID_ROYALTIES)) {\\n\\t\\t\\tIERC2981 v2981 = IERC2981(token);\\n\\t\\t\\ttry v2981.royaltyInfo(tokenId, LibRoyalties2981._WEIGHT_VALUE) returns (address receiver, uint256 royaltyAmount) {\\n\\t\\t\\t\\treturn LibRoyalties2981.calculateRoyalties(receiver, royaltyAmount);\\n\\t\\t\\t} catch {}\\n\\t\\t}\\n\\t\\treturn royaltiesSet.royalties;\\n\\t}\\n\\n\\tfunction setRoyaltiesCacheByTokenAndTokenId(address token, uint tokenId, LibPart.Part[] memory royalties) internal {\\n\\t\\tuint sumRoyalties = 0;\\n\\t\\tbytes32 key = keccak256(abi.encode(token, tokenId));\\n\\t\\tfor (uint i = 0; i < royalties.length; i++) {\\n\\t\\t\\trequire(royalties[i].account != address(0x0), \\\"RoyaltiesByTokenAndTokenId recipient should be present\\\");\\n\\t\\t\\trequire(royalties[i].value != 0, \\\"Fee value for RoyaltiesByTokenAndTokenId should be > 0\\\");\\n\\t\\t\\troyaltiesByTokenAndTokenId[key].royalties.push(royalties[i]);\\n\\t\\t\\tsumRoyalties += royalties[i].value;\\n\\t\\t}\\n\\t\\trequire(sumRoyalties < 10000, \\\"Set by token and tokenId royalties sum more, than 100%\\\");\\n\\t\\troyaltiesByTokenAndTokenId[key].initialized = true;\\n\\t}\\n\\n\\tuint256[46] private __gap;\\n}\\n\"\r\n    },\r\n    \"@rarible/royalties/contracts/IRoyaltiesProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./LibPart.sol\\\";\\n\\ninterface IRoyaltiesProvider {\\n    function getRoyalties(address token, uint tokenId) external returns (LibPart.Part[] memory);\\n}\\n\"\r\n    },\r\n    \"@rarible/royalties/contracts/LibRoyaltiesV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nlibrary LibRoyaltiesV2 {\\n    /*\\n     * bytes4(keccak256('getRaribleV2Royalties(uint256)')) == 0xcad96cca\\n     */\\n    bytes4 constant _INTERFACE_ID_ROYALTIES = 0xcad96cca;\\n}\\n\"\r\n    },\r\n    \"@rarible/royalties/contracts/LibRoyaltiesV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nlibrary LibRoyaltiesV1 {\\n    /*\\n     * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f\\n     * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\\n     *\\n     * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584\\n     */\\n    bytes4 constant _INTERFACE_ID_FEES = 0xb7799584;\\n}\\n\"\r\n    },\r\n    \"@rarible/royalties/contracts/impl/RoyaltiesV1Impl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./AbstractRoyalties.sol\\\";\\nimport \\\"../RoyaltiesV1.sol\\\";\\n\\ncontract RoyaltiesV1Impl is AbstractRoyalties, RoyaltiesV1 {\\n\\n    function getFeeRecipients(uint256 id) public override view returns (address payable[] memory) {\\n        LibPart.Part[] memory _royalties = royalties[id];\\n        address payable[] memory result = new address payable[](_royalties.length);\\n        for (uint i = 0; i < _royalties.length; i++) {\\n            result[i] = address(uint160(_royalties[i].account));\\n        }\\n        return result;\\n    }\\n\\n    function getFeeBps(uint256 id) public override view returns (uint[] memory) {\\n        LibPart.Part[] memory _royalties = royalties[id];\\n        uint[] memory result = new uint[](_royalties.length);\\n        for (uint i = 0; i < _royalties.length; i++) {\\n            result[i] = _royalties[i].value;\\n        }\\n        return result;\\n    }\\n\\n    function _onRoyaltiesSet(uint256 id, LibPart.Part[] memory _royalties) override internal {\\n        address[] memory recipients = new address[](_royalties.length);\\n        uint[] memory bps = new uint[](_royalties.length);\\n        for (uint i = 0; i < _royalties.length; i++) {\\n            recipients[i] = _royalties[i].account;\\n            bps[i] = _royalties[i].value;\\n        }\\n        emit SecondarySaleFees(id, recipients, bps);\\n    }\\n}\\n\"\r\n    },\r\n    \"@rarible/royalties/contracts/impl/RoyaltiesV2Impl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./AbstractRoyalties.sol\\\";\\nimport \\\"../RoyaltiesV2.sol\\\";\\n\\ncontract RoyaltiesV2Impl is AbstractRoyalties, RoyaltiesV2 {\\n\\n    function getRaribleV2Royalties(uint256 id) override external view returns (LibPart.Part[] memory) {\\n        return royalties[id];\\n    }\\n\\n    function _onRoyaltiesSet(uint256 id, LibPart.Part[] memory _royalties) override internal {\\n        emit RoyaltiesSet(id, _royalties);\\n    }\\n}\\n\"\r\n    },\r\n    \"@rarible/royalties/contracts/LibRoyalties2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./LibPart.sol\\\";\\n\\nlibrary LibRoyalties2981 {\\n    /*\\n     * https://eips.ethereum.org/EIPS/eip-2981: bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\\n     */\\n    bytes4 constant _INTERFACE_ID_ROYALTIES = 0x2a55205a;\\n    uint96 constant _WEIGHT_VALUE = 1000000;\\n\\n    /*Method for converting amount to percent and forming LibPart*/\\n    function calculateRoyalties(address to, uint256 amount) internal view returns (LibPart.Part[] memory) {\\n        LibPart.Part[] memory result;\\n        if (amount == 0) {\\n            return result;\\n        }\\n        uint256 percent = (amount * 100 / _WEIGHT_VALUE) * 100;\\n        require(percent < 10000, \\\"Royalties 2981, than 100%\\\");\\n        result = new LibPart.Part[](1);\\n        result[0].account = payable(to);\\n        result[0].value = uint96(percent);\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@rarible/royalties/contracts/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\nimport \\\"./LibPart.sol\\\";\\n///\\n/// @dev Interface for the NFT Royalty Standard\\n///\\n//interface IERC2981 is IERC165 {\\ninterface IERC2981 {\\n    /// ERC165 bytes to add to interface array - set in parent contract\\n    /// implementing this standard\\n    ///\\n    /// bytes4(keccak256(\\\"royaltyInfo(uint256,uint256)\\\")) == 0x2a55205a\\n    /// bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\\n    /// _registerInterface(_INTERFACE_ID_ERC2981);\\n\\n    /// @notice Called with the sale price to determine how much royalty\\n    //          is owed and to whom.\\n    /// @param _tokenId - the NFT asset queried for royalty information\\n    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId\\n    /// @return receiver - address of who should be sent the royalty payment\\n    /// @return royaltyAmount - the royalty payment amount for _salePrice\\n    function royaltyInfo(\\n        uint256 _tokenId,\\n        uint256 _salePrice\\n    ) external view returns (\\n        address receiver,\\n        uint256 royaltyAmount\\n    );\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@rarible/royalties/contracts/LibPart.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nlibrary LibPart {\\n    bytes32 public constant TYPE_HASH = keccak256(\\\"Part(address account,uint96 value)\\\");\\n\\n    struct Part {\\n        address payable account;\\n        uint96 value;\\n    }\\n\\n    function hash(Part memory part) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(TYPE_HASH, part.account, part.value));\\n    }\\n}\\n\"\r\n    },\r\n    \"@rarible/royalties/contracts/impl/AbstractRoyalties.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../LibPart.sol\\\";\\n\\nabstract contract AbstractRoyalties {\\n    mapping (uint256 => LibPart.Part[]) internal royalties;\\n\\n    function _saveRoyalties(uint256 id, LibPart.Part[] memory _royalties) internal {\\n        uint256 totalValue;\\n        for (uint i = 0; i < _royalties.length; i++) {\\n            require(_royalties[i].account != address(0x0), \\\"Recipient should be present\\\");\\n            require(_royalties[i].value != 0, \\\"Royalty value should be positive\\\");\\n            totalValue += _royalties[i].value;\\n            royalties[id].push(_royalties[i]);\\n        }\\n        require(totalValue < 10000, \\\"Royalty total value should be < 10000\\\");\\n        _onRoyaltiesSet(id, _royalties);\\n    }\\n\\n    function _updateAccount(uint256 _id, address _from, address _to) internal {\\n        uint length = royalties[_id].length;\\n        for(uint i = 0; i < length; i++) {\\n            if (royalties[_id][i].account == _from) {\\n                royalties[_id][i].account = address(uint160(_to));\\n            }\\n        }\\n    }\\n\\n    function _onRoyaltiesSet(uint256 id, LibPart.Part[] memory _royalties) virtual internal;\\n}\\n\"\r\n    },\r\n    \"@rarible/royalties/contracts/RoyaltiesV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\ninterface RoyaltiesV1 {\\n    event SecondarySaleFees(uint256 tokenId, address[] recipients, uint[] bps);\\n\\n    function getFeeRecipients(uint256 id) external view returns (address payable[] memory);\\n    function getFeeBps(uint256 id) external view returns (uint[] memory);\\n}\\n\"\r\n    },\r\n    \"@rarible/royalties/contracts/RoyaltiesV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"./LibPart.sol\\\";\\n\\ninterface RoyaltiesV2 {\\n    event RoyaltiesSet(uint256 tokenId, LibPart.Part[] royalties);\\n\\n    function getRaribleV2Royalties(uint256 id) external view returns (LibPart.Part[] memory);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRoyalties\",\"outputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"}],\"internalType\":\"struct LibPart.Part[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"royaltiesByToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"royaltiesByTokenAndTokenId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"}],\"internalType\":\"struct LibPart.Part[]\",\"name\":\"royalties\",\"type\":\"tuple[]\"}],\"name\":\"setRoyaltiesByToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"}],\"internalType\":\"struct LibPart.Part[]\",\"name\":\"royalties\",\"type\":\"tuple[]\"}],\"name\":\"setRoyaltiesByTokenAndTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TestRoyaltiesRegistry","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}