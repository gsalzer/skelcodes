{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 99999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@mochifi/cssr/contracts/interfaces/ICSSRRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@mochifi/library/contracts/Float.sol\\\";\\n\\ninterface ICSSRRouter {\\n    function update(address _asset, bytes memory _data)\\n        external\\n        returns (float memory);\\n\\n    function getPrice(address _asset) external view returns (float memory);\\n\\n    function getLiquidity(address _asset) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@mochifi/library/contracts/CheapERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary CheapERC20 {\\n    function cheapTransfer(IERC20 asset, address to, uint value) internal {\\n        (bool success, bytes memory data) = address(asset).call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Mochi Vault: TRANSFER_FAILED');\\n    }\\n    \\n    function cheapTransferFrom(IERC20 asset, address from, address to, uint value) internal {\\n        (bool success, bytes memory data) = address(asset).call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'Mochi Vault: TRANSFER_FROM_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"@mochifi/library/contracts/Float.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nstruct float {\\n    uint256 numerator;\\n    uint256 denominator;\\n}\\n\\nlibrary Float {\\n    function multiply(uint256 a, float memory f) internal pure returns(uint256) {\\n        require(f.denominator != 0, \\\"div 0\\\");\\n        return a * f.numerator / f.denominator;\\n    }\\n\\n    function inverse(float memory f) internal pure returns(float memory) {\\n        require(f.numerator != 0 && f.denominator != 0, \\\"div 0\\\");\\n        return float({\\n            numerator: f.denominator,\\n            denominator: f.numerator\\n        });\\n    }\\n\\n    function divide(uint256 a, float memory f) internal pure returns(uint256) {\\n        require(f.denominator != 0, \\\"div 0\\\");\\n        return a * f.denominator / f.numerator;\\n    }\\n\\n    function add(float memory a, float memory b) internal pure returns(float memory res) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        res = float({\\n            numerator : a.numerator*b.denominator + a.denominator*b.numerator,\\n            denominator : a.denominator*b.denominator\\n        });\\n        if(res.numerator > 2**128 && res.denominator > 2**128){\\n            res.numerator = res.numerator / 2**64;\\n            res.denominator = res.denominator / 2**64;\\n        }\\n    }\\n    \\n    function sub(float memory a, float memory b) internal pure returns(float memory res) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        res = float({\\n            numerator : a.numerator*b.denominator - b.numerator*a.denominator,\\n            denominator : a.denominator*b.denominator\\n        });\\n        if(res.numerator > 2**128 && res.denominator > 2**128){\\n            res.numerator = res.numerator / 2**64;\\n            res.denominator = res.denominator / 2**64;\\n        }\\n    }\\n\\n    function mul(float memory a, float memory b) internal pure returns(float memory res) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        res = float({\\n            numerator : a.numerator * b.numerator,\\n            denominator : a.denominator * b.denominator\\n        });\\n        if(res.numerator > 2**128 && res.denominator > 2**128){\\n            res.numerator = res.numerator / 2**64;\\n            res.denominator = res.denominator / 2**64;\\n        }\\n    }\\n\\n    function gt(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator > a.denominator * b.numerator;\\n    }\\n\\n    function lt(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator < a.denominator * b.numerator;\\n    }\\n\\n    function gte(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator >= a.denominator * b.numerator;\\n    }\\n\\n    function lte(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator <= a.denominator * b.numerator;\\n    }\\n\\n    function equals(float memory a, float memory b) internal pure returns(bool) {\\n        require(a.denominator != 0 && b.denominator != 0, \\\"div 0\\\");\\n        return a.numerator * b.denominator == b.numerator * a.denominator;\\n    }\\n}\\n\"\r\n    },\r\n    \"@mochifi/vmochi/contracts/interfaces/IVMochi.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface IVMochi {\\n    function locked(address _user) external view returns(int128, uint256);\\n    function depositFor(address _user, uint256 _amount) external;\\n    function balanceOf(address _user) external view returns(uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiscountProfile.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@mochifi/library/contracts/Float.sol\\\";\\n\\ninterface IDiscountProfile {\\n    function discount(address _user) external view returns (float memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC3156FlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC3156FlashBorrower {\\n    /**\\n     * @dev Receive a flash loan.\\n     * @param initiator The initiator of the loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param fee The additional amount of tokens to repay.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return The keccak256 hash of \\\"ERC3156FlashBorrower.onFlashLoan\\\"\\n     */\\n    function onFlashLoan(\\n        address initiator,\\n        address token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC3156FlashLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC3156FlashBorrower.sol\\\";\\n\\ninterface IERC3156FlashLender {\\n    /**\\n     * @dev The amount of currency available to be lent.\\n     * @param token The loan currency.\\n     * @return The amount of `token` that can be borrowed.\\n     */\\n    function maxFlashLoan(address token) external view returns (uint256);\\n\\n    /**\\n     * @dev The fee to be charged for a given loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\\n     */\\n    function flashFee(address token, uint256 amount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Initiate a flash loan.\\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     */\\n    function flashLoan(\\n        IERC3156FlashBorrower receiver,\\n        address token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface IFeePool {\\n    function updateReserve() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILiquidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface ILiquidator {\\n    event Triggered(uint256 _auctionId, uint256 _price);\\n    event Settled(uint256 _auctionId, uint256 _price);\\n\\n    function triggerLiquidation(\\n        address _asset,\\n        uint256 _nftId,\\n        bytes calldata _data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface IMinter {\\n    function pause() external;\\n    function unpause() external;\\n    function mint(address _to, uint256 _amount) external;\\n\\n    function hasPermission(address _user) external view returns (bool);\\n\\n    function isVault(address _vault) external view returns(bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMochi.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IMochi is IERC20 {}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMochiEngine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@mochifi/vmochi/contracts/interfaces/IVMochi.sol\\\";\\nimport \\\"@mochifi/cssr/contracts/interfaces/ICSSRRouter.sol\\\";\\nimport \\\"./IMochiProfile.sol\\\";\\nimport \\\"./IDiscountProfile.sol\\\";\\nimport \\\"./IMochiVault.sol\\\";\\nimport \\\"./IFeePool.sol\\\";\\nimport \\\"./IReferralFeePool.sol\\\";\\nimport \\\"./ILiquidator.sol\\\";\\nimport \\\"./IUSDM.sol\\\";\\nimport \\\"./IMochi.sol\\\";\\nimport \\\"./IMinter.sol\\\";\\nimport \\\"./IMochiNFT.sol\\\";\\nimport \\\"./IMochiVaultFactory.sol\\\";\\n\\ninterface IMochiEngine {\\n    function mochi() external view returns (IMochi);\\n\\n    function vMochi() external view returns (IVMochi);\\n\\n    function usdm() external view returns (IUSDM);\\n\\n    function cssr() external view returns (ICSSRRouter);\\n\\n    function governance() external view returns (address);\\n\\n    function treasury() external view returns (address);\\n\\n    function operationWallet() external view returns (address);\\n\\n    function mochiProfile() external view returns (IMochiProfile);\\n\\n    function discountProfile() external view returns (IDiscountProfile);\\n\\n    function feePool() external view returns (IFeePool);\\n\\n    function referralFeePool() external view returns (IReferralFeePool);\\n\\n    function liquidator() external view returns (ILiquidator);\\n\\n    function minter() external view returns (IMinter);\\n\\n    function nft() external view returns (IMochiNFT);\\n\\n    function vaultFactory() external view returns (IMochiVaultFactory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMochiNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\ninterface IMochiNFT is IERC721Enumerable {\\n    struct MochiInfo {\\n        address asset;\\n    }\\n\\n    function asset(uint256 _id) external view returns (address);\\n\\n    function mint(address _asset, address _owner) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMochiProfile.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@mochifi/library/contracts/Float.sol\\\";\\n\\nenum AssetClass {\\n    Invalid,\\n    Stable,\\n    Alpha,\\n    Gamma,\\n    Delta,\\n    Zeta,\\n    Sigma,\\n    Revoked\\n}\\n\\ninterface IMochiProfile {\\n    function assetClass(address _asset) external view returns (AssetClass);\\n\\n    function liquidityRequirement() external view returns (uint256);\\n\\n    function minimumDebt() external view returns (uint256);\\n\\n    function changeAssetClass(\\n        address[] calldata _asset,\\n        AssetClass[] calldata _class\\n    ) external;\\n\\n    function changeLiquidityRequirement(uint256 _requirement) external;\\n\\n    function changeMinimumDebt(uint256 _debt) external;\\n\\n    function calculateFeeIndex(\\n        address _asset,\\n        uint256 _currentIndex,\\n        uint256 _lastAccrued\\n    ) external view returns (uint256);\\n\\n    function creditCap(address _asset) external view returns (uint256);\\n\\n    function delay() external view returns (uint256);\\n\\n    function liquidationFactor(address _asset)\\n        external\\n        view\\n        returns (float memory);\\n\\n    function maxCollateralFactor(address _asset)\\n        external\\n        view\\n        returns (float memory);\\n\\n    /**\\n     @dev Returns a float point number used to get stability fee of token\\n    */\\n    function stabilityFee(address _asset) external view returns (float memory);\\n\\n    function liquidationFee(address _asset)\\n        external\\n        view\\n        returns (float memory);\\n\\n    function keeperFee(address _asset) external view returns (float memory);\\n\\n    function utilizationRatio(address _asset)\\n        external\\n        view\\n        returns (float memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMochiVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nstruct Detail {\\n    Status status;\\n    uint256 collateral;\\n    uint256 debt;\\n    uint256 debtIndex;\\n    address referrer;\\n}\\n\\nenum Status {\\n    Invalid, // not minted\\n    Idle, // debt = 0, collateral = 0\\n    Collateralized, // debt = 0, collateral > 0\\n    Active, // debt > 0, collateral > 0\\n    Liquidated\\n}\\n\\ninterface IMochiVault {\\n    event Pause();\\n    event Unpause();\\n    function liveDebtIndex() external view returns (uint256);\\n\\n    function details(uint256 _nftId)\\n        external\\n        view\\n        returns (\\n            Status,\\n            uint256 collateral,\\n            uint256 debt,\\n            uint256 debtIndex,\\n            address referrer\\n        );\\n\\n\\n    function pause() external;\\n\\n    function unpause() external; \\n\\n    function status(uint256 _nftId) external view returns (Status);\\n\\n    function asset() external view returns (IERC20);\\n\\n    function deposits() external view returns (uint256);\\n\\n    function debts() external view returns (uint256);\\n\\n    function claimable() external view returns (int256);\\n\\n    function currentDebt(uint256 _nftId) external view returns (uint256);\\n\\n    function initialize(address _asset) external;\\n\\n    function deposit(uint256 _nftId, uint256 _amount) external;\\n\\n    function withdraw(\\n        uint256 _nftId,\\n        uint256 _amount,\\n        bytes memory _data\\n    ) external;\\n\\n    function borrow(\\n        uint256 _nftId,\\n        uint256 _amount,\\n        bytes memory _data\\n    ) external;\\n\\n    function repay(uint256 _nftId, uint256 _amount) external;\\n\\n    function liquidate(\\n        uint256 _nftId,\\n        uint256 _collateral,\\n        uint256 _usdm,\\n        bytes calldata _data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMochiVaultFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IMochiVault.sol\\\";\\n\\ninterface IMochiVaultFactory {\\n    function updateTemplate(address _template) external;\\n\\n    function deployVault(address _asset) external returns (IMochiVault);\\n\\n    function getVault(address _asset) external view returns (IMochiVault);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReferralFeePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface IReferralFeePool {\\n    function addReward(address _recipient) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUSDM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IERC3156FlashLender.sol\\\";\\n\\ninterface IUSDM is IERC20, IERC3156FlashLender {\\n    function mint(address _recipient, uint256 _amount) external;\\n\\n    function burn(uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/vault/MochiVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"@mochifi/library/contracts/CheapERC20.sol\\\";\\nimport \\\"../interfaces/IERC3156FlashLender.sol\\\";\\nimport \\\"../interfaces/IMochiVault.sol\\\";\\nimport \\\"../interfaces/IMochiEngine.sol\\\";\\nimport \\\"../interfaces/IUSDM.sol\\\";\\n\\ncontract MochiVault is Initializable, IMochiVault {\\n    using Float for uint256;\\n    using CheapERC20 for IERC20;\\n\\n    /// immutable variables\\n    IMochiEngine public immutable engine;\\n    address public immutable pauser;\\n    IERC20 public override asset;\\n\\n    /// for accruing debt\\n    uint256 public debtIndex;\\n    uint256 public lastAccrued;\\n\\n    /// storage variables\\n    uint256 public override deposits;\\n    uint256 public override debts;\\n    int256 public override claimable;\\n\\n    ///Mochi waits until the stability fees hit 1% and then starts calculating debt after that.\\n    ///E.g. If the stability fees are 10% for a year\\n    ///Mochi will wait 36.5 days (the time period required for the pre-minted 1%)\\n\\n    mapping(uint256 => Detail) public override details;\\n    mapping(uint256 => uint256) public lastDeposit;\\n\\n    // mutex for reentrancy gaurd\\n    bool public mutex;\\n\\n    // boolean for pausing the vault\\n    bool public paused;\\n\\n    modifier updateDebt(uint256 _id) {\\n        accrueDebt(_id);\\n        _;\\n    }\\n\\n    modifier wait(uint256 _id) {\\n        require(\\n            lastDeposit[_id] + engine.mochiProfile().delay() <= block.timestamp,\\n            \\\"!wait\\\"\\n        );\\n        accrueDebt(_id);\\n        _;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(!paused, \\\"paused\\\");\\n        _;\\n    }\\n\\n    modifier reentrancyGuard() {\\n        require(!mutex, \\\"!reentrant\\\");\\n        mutex = true;\\n        _;\\n        mutex = false;\\n    }\\n\\n    // Adding the initializer modifier to the constructor ensures that noone\\n    // can call initialize on the implementation contract.\\n    constructor(address _engine, address _pauser) initializer {\\n        require(_engine != address(0), \\\"engine cannot be zero address\\\");\\n        engine = IMochiEngine(_engine);\\n        pauser = _pauser;\\n    }\\n\\n    function initialize(address _asset) external override initializer {\\n        asset = IERC20(_asset);\\n        debtIndex = 1e18;\\n        lastAccrued = block.timestamp;\\n    }\\n\\n    function pause() external override {\\n        require(msg.sender == pauser, \\\"!pauser\\\");\\n        paused = true;\\n        emit Pause();\\n    }\\n\\n    function unpause() external override {\\n        require(msg.sender == pauser, \\\"!pauser\\\");\\n        paused = false;\\n        emit Unpause();\\n    }\\n\\n    function liveDebtIndex() public view override returns (uint256 index) {\\n        return\\n            engine.mochiProfile().calculateFeeIndex(\\n                address(asset),\\n                debtIndex,\\n                lastAccrued\\n            );\\n    }\\n\\n    function status(uint256 _id) external view override returns (Status) {\\n        return details[_id].status;\\n    }\\n\\n    function currentDebt(uint256 _id) external view override returns (uint256) {\\n        Detail memory detail = details[_id];\\n        return _currentDebt(detail);\\n    }\\n\\n    function _currentDebt(Detail memory _detail)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        require(_detail.status != Status.Invalid, \\\"invalid\\\");\\n        uint256 newIndex = liveDebtIndex();\\n        return (_detail.debt * newIndex) / _detail.debtIndex;\\n    }\\n\\n    function accrueDebt(uint256 _id) public {\\n        // global debt for vault\\n        // first, increase gloabal debt;\\n        uint256 currentIndex = liveDebtIndex();\\n        uint256 increased = (debts * currentIndex) / debtIndex - debts;\\n        debts += increased;\\n        claimable += SafeCast.toInt256(increased);\\n        // update global debtIndex\\n        debtIndex = currentIndex;\\n        lastAccrued = block.timestamp;\\n        // individual debt\\n        Detail memory detail = details[_id];\\n        if (_id != type(uint256).max && detail.debtIndex < debtIndex) {\\n            require(detail.status != Status.Invalid, \\\"invalid\\\");\\n            if (detail.debt != 0) {\\n                uint256 increasedDebt = (detail.debt * debtIndex) /\\n                    detail.debtIndex -\\n                    detail.debt;\\n                uint256 discountedDebt = increasedDebt.multiply(\\n                    engine.discountProfile().discount(engine.nft().ownerOf(_id))\\n                );\\n                debts -= discountedDebt;\\n                claimable -= SafeCast.toInt256(discountedDebt);\\n                detail.debt += (increasedDebt - discountedDebt);\\n            }\\n            detail.debtIndex = debtIndex;\\n            details[_id] = detail;\\n        }\\n    }\\n\\n    function increase(\\n        uint256 _id,\\n        uint256 _deposits,\\n        uint256 _borrows,\\n        address _referrer,\\n        bytes memory _data\\n    ) external {\\n        if (_id == type(uint256).max) {\\n            // mint if _id is -1\\n            _id = mint(msg.sender, _referrer);\\n        }\\n        if (_deposits > 0) {\\n            deposit(_id, _deposits);\\n        }\\n        if (_borrows > 0) {\\n            borrow(_id, _borrows, _data);\\n        }\\n    }\\n\\n    function decrease(\\n        uint256 _id,\\n        uint256 _withdraws,\\n        uint256 _repays,\\n        bytes memory _data\\n    ) external {\\n        if (_repays > 0) {\\n            repay(_id, _repays);\\n        }\\n        if (_withdraws > 0) {\\n            withdraw(_id, _withdraws, _data);\\n        }\\n    }\\n\\n    function mint(address _recipient, address _referrer)\\n        public\\n        returns (uint256 id)\\n    {\\n        id = engine.nft().mint(address(asset), _recipient);\\n        details[id] = Detail({\\n            status:Status.Idle,\\n            collateral:0,\\n            debt:0,\\n            debtIndex:liveDebtIndex(),\\n            referrer:_referrer\\n        });\\n    }\\n\\n    /// anyone can deposit collateral to given id\\n    /// it will even allow depositing to liquidated vault so becareful when depositing\\n    function deposit(uint256 _id, uint256 _amount)\\n        public\\n        override\\n        updateDebt(_id)\\n        reentrancyGuard\\n    {\\n        require(_amount > 0, \\\"amount 0\\\");\\n        require(engine.nft().asset(_id) == address(asset), \\\"!asset\\\");\\n        Detail memory detail = details[_id];\\n        require(\\n            detail.status == Status.Idle ||\\n                detail.status == Status.Collateralized ||\\n                detail.status == Status.Active,\\n            \\\"!depositable\\\"\\n        );\\n        lastDeposit[_id] = block.timestamp;\\n        deposits += _amount;\\n        detail.collateral += _amount;\\n        if (detail.status == Status.Idle) {\\n            detail.status = Status.Collateralized;\\n        }\\n        details[_id] = detail;\\n        asset.cheapTransferFrom(msg.sender, address(this), _amount);\\n    }\\n\\n    /// should only be able to withdraw if status is not liquidatable\\n    function withdraw(\\n        uint256 _id,\\n        uint256 _amount,\\n        bytes memory _data\\n    )   public\\n        override\\n        wait(_id)\\n        reentrancyGuard \\n        whenNotPaused\\n    {\\n        IMochiNFT nft = engine.nft();\\n        require(nft.ownerOf(_id) == msg.sender, \\\"!approved\\\");\\n        require(nft.asset(_id) == address(asset), \\\"!asset\\\");\\n        // update prior to interaction\\n        float memory price = engine.cssr().update(address(asset), _data);\\n        Detail memory detail = details[_id];\\n        require(\\n            !_liquidatable(detail.collateral - _amount, price, detail.debt),\\n            \\\"!healthy\\\"\\n        );\\n        float memory cf = engine.mochiProfile().maxCollateralFactor(\\n            address(asset)\\n        );\\n        uint256 maxMinted = (detail.collateral - _amount).multiply(cf).multiply(\\n            price\\n        );\\n        require(detail.debt <= maxMinted, \\\">cf\\\");\\n        deposits -= _amount;\\n        detail.collateral -= _amount;\\n        if (detail.collateral == 0) {\\n            detail.status = Status.Idle;\\n        }\\n        details[_id] = detail;\\n        asset.cheapTransfer(msg.sender, _amount);\\n    }\\n\\n    function borrow(\\n        uint256 _id,\\n        uint256 _amount,\\n        bytes memory _data\\n    )   public\\n        override\\n        updateDebt(_id)\\n        whenNotPaused\\n    {\\n        IMochiNFT nft = engine.nft();\\n        IMochiProfile mochiProfile = engine.mochiProfile();\\n        Detail memory detail = details[_id];\\n        // update prior to interaction\\n        float memory price = engine.cssr().update(address(asset), _data);\\n        float memory cf = mochiProfile.maxCollateralFactor(\\n            address(asset)\\n        );\\n        uint256 maxMinted = detail.collateral.multiply(cf).multiply(\\n            price\\n        );\\n        require(nft.ownerOf(_id) == msg.sender, \\\"!approved\\\");\\n        require(nft.asset(_id) == address(asset), \\\"!asset\\\");\\n        if(detail.debt + _amount > maxMinted) {\\n            _amount = maxMinted - detail.debt;\\n        }\\n        uint256 cap = mochiProfile.creditCap(address(asset));\\n        if(cap < debts + _amount) {\\n            _amount = cap - debts;\\n        }\\n        uint256 increasingDebt = (_amount * 1005) / 1000;\\n        uint256 totalDebt = detail.debt + increasingDebt;\\n        require(detail.debt + _amount >= mochiProfile.minimumDebt(), \\\"<minimum\\\");\\n        require(\\n            !_liquidatable(detail.collateral, price, totalDebt),\\n            \\\"!healthy\\\"\\n        );\\n        mintFeeToPool(increasingDebt - _amount, detail.referrer);\\n        detail.debt = totalDebt;\\n        detail.status = Status.Active;\\n        debts += increasingDebt;\\n        details[_id] = detail;\\n        engine.minter().mint(msg.sender, _amount);\\n    }\\n\\n    /// someone sends usdm to this address and repays the debt\\n    /// will payback the leftover usdm\\n    function repay(uint256 _id, uint256 _amount)\\n        public\\n        override\\n        updateDebt(_id)\\n    {\\n        Detail memory detail = details[_id];\\n        if (_amount > detail.debt) {\\n            _amount = detail.debt;\\n        }\\n        require(_amount > 0, \\\"zero\\\");\\n        if (debts < _amount) {\\n            // safe gaurd to some underflows\\n            debts = 0;\\n        } else {\\n            debts -= _amount;\\n        }\\n        detail.debt -= _amount;\\n        if (detail.debt == 0) {\\n            detail.status = Status.Collateralized;\\n        }\\n        details[_id] = detail;\\n        IUSDM usdm = engine.usdm();\\n        usdm.transferFrom(msg.sender, address(this), _amount);\\n        usdm.burn(_amount);\\n    }\\n\\n    function liquidate(\\n        uint256 _id,\\n        uint256 _collateral,\\n        uint256 _usdm,\\n        bytes calldata _data\\n    ) external override updateDebt(_id) reentrancyGuard {\\n        Detail storage detail = details[_id];\\n        require(msg.sender == address(engine.liquidator()), \\\"!liquidator\\\");\\n        require(engine.nft().asset(_id) == address(asset), \\\"!asset\\\");\\n        float memory price = engine.cssr().update(address(asset), _data);\\n        require(\\n            _liquidatable(detail.collateral, price, _currentDebt(detail)),\\n            \\\"healthy\\\"\\n        );\\n\\n        debts -= _usdm;\\n\\n        detail.collateral -= _collateral;\\n        detail.debt -= _usdm;\\n        asset.cheapTransfer(msg.sender, _collateral);\\n    }\\n\\n    /// @dev returns if status is liquidatable with given `_collateral` amount and `_debt` amount\\n    /// @notice should return false if _collateral * liquidationLimit < _debt\\n    function _liquidatable(\\n        uint256 _collateral,\\n        float memory _price,\\n        uint256 _debt\\n    ) internal view returns (bool) {\\n        float memory lf = engine.mochiProfile().liquidationFactor(\\n            address(asset)\\n        );\\n        // when debt is lower than liquidation value, it can be liquidated\\n        return _collateral.multiply(lf) < _debt.divide(_price);\\n    }\\n\\n    function liquidatable(uint256 _id) external view returns (bool) {\\n        float memory price = engine.cssr().getPrice(address(asset));\\n        Detail memory detail = details[_id];\\n        return _liquidatable(detail.collateral, price, _currentDebt(detail));\\n    }\\n\\n    function claim() external updateDebt(type(uint256).max) {\\n        require(claimable > 0, \\\"!claimable\\\");\\n        // reserving 25% to prevent potential risks\\n        uint256 toClaim = (SafeCast.toUint256(claimable) * 75) / 100;\\n        mintFeeToPool(toClaim, address(0));\\n    }\\n\\n    /**\\n     *@dev\\n     */\\n    function mintFeeToPool(uint256 _amount, address _referrer) internal {\\n        claimable -= SafeCast.toInt256(_amount);\\n        if (address(0) != _referrer) {\\n            engine.minter().mint(address(engine.referralFeePool()), _amount);\\n            engine.referralFeePool().addReward(_referrer);\\n        } else {\\n            engine.minter().mint(address(engine.treasury()), _amount);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_engine\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pauser\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"accrueDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"currentDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdraws\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_repays\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"decrease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"details\",\"outputs\":[{\"internalType\":\"enum Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"engine\",\"outputs\":[{\"internalType\":\"contract IMochiEngine\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_borrows\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"increase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"liquidatable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_usdm\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"liquidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liveDebtIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mutex\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"status\",\"outputs\":[{\"internalType\":\"enum Status\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MochiVault","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"99999","ConstructorArguments":"000000000000000000000000860e47e6d6f4a6bcaaddfc7f17f772d2ab55be2f0000000000000000000000005f362c05ef7f631d99e81e72cec917e86ca02cf8","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}