{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Allowlist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\nimport \\\"./libraries/Strings.sol\\\";\\nimport \\\"./libraries/Introspection.sol\\\";\\n\\n/*******************************************************\\n *                      Interfaces\\n *******************************************************/\\ninterface IAllowlistFactory {\\n  function protocolOwnerAddressByOriginName(string memory originName)\\n    external\\n    view\\n    returns (address ownerAddress);\\n}\\n\\n/*******************************************************\\n *                      Core Logic\\n *******************************************************/\\ncontract Allowlist {\\n  /**\\n   * methodName: Name of the method to validate (ie. \\\"approve\\\")\\n   * paramTypes: Param types of the method to validate (ie. [\\\"address\\\", \\\"uint256\\\"])\\n   * requirements: Array of requirements, where a requirement is as follows:\\n   *    Element 0: Requirement type (ie. \\\"target\\\" or \\\"param\\\")\\n   *    Element 1: Method name of validation method (ie. \\\"isVaultToken\\\")\\n   *    Element 2: Index of param to test as a string. Only applicable where requirement type is \\\"param\\\" (ie. \\\"0\\\")\\n   */\\n  struct Condition {\\n    string methodName;\\n    string[] paramTypes;\\n    string[][] requirements;\\n    address implementationAddress;\\n  }\\n\\n  Condition[] public conditions; // Array of conditions per protocol (managed by protocol owner)\\n  string public protocolOriginName; // Domain name of protocol (ie. \\\"yearn.finance\\\")\\n  address public rootAllowlistAddress; // Address of root allowlist (parent/factory)\\n\\n  /**\\n   * Initialize the contract (this will only be called by proxy)\\n   */\\n  function initialize(string memory _protocolOriginName) public {\\n    require(\\n      rootAllowlistAddress == address(0),\\n      \\\"Contract is already initialized\\\"\\n    );\\n    rootAllowlistAddress = msg.sender;\\n    protocolOriginName = _protocolOriginName;\\n  }\\n\\n  /*******************************************************\\n   *                     Owner logic\\n   *******************************************************/\\n  modifier onlyOwner() {\\n    require(\\n      msg.sender == ownerAddress() || msg.sender == address(0),\\n      \\\"Caller is not the protocol owner\\\"\\n    );\\n    _;\\n  }\\n\\n  function ownerAddress() public view returns (address protcolOwnerAddress) {\\n    protcolOwnerAddress = IAllowlistFactory(rootAllowlistAddress)\\n      .protocolOwnerAddressByOriginName(protocolOriginName);\\n  }\\n\\n  /*******************************************************\\n   *                   Condition CRUD Logic\\n   *******************************************************/\\n  function addCondition(Condition memory condition) public onlyOwner {\\n    validateCondition(condition);\\n    conditions.push(condition);\\n  }\\n\\n  function addConditions(Condition[] memory _conditions) public onlyOwner {\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx < _conditions.length;\\n      conditionIdx++\\n    ) {\\n      Condition memory condition = _conditions[conditionIdx];\\n      addCondition(condition);\\n    }\\n  }\\n\\n  function addConditionWithoutValidation(Condition memory condition)\\n    public\\n    onlyOwner\\n  {\\n    conditions.push(condition);\\n  }\\n\\n  function addConditionsWithoutValidation(Condition[] memory _conditions)\\n    public\\n    onlyOwner\\n  {\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx < _conditions.length;\\n      conditionIdx++\\n    ) {\\n      Condition memory condition = _conditions[conditionIdx];\\n      addCondition(condition);\\n    }\\n  }\\n\\n  function deleteCondition(uint256 conditionIdx) public onlyOwner {\\n    Condition memory lastCondition = conditions[conditions.length - 1];\\n    conditions[conditionIdx] = lastCondition;\\n    conditions.pop();\\n  }\\n\\n  function deleteAllConditions() public onlyOwner {\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx < conditions.length;\\n      conditionIdx++\\n    ) {\\n      conditions.pop();\\n    }\\n  }\\n\\n  function updateCondition(uint256 conditionIdx, Condition memory condition)\\n    public\\n    onlyOwner\\n  {\\n    deleteCondition(conditionIdx);\\n    addCondition(condition);\\n  }\\n\\n  function conditionsList() public view returns (Condition[] memory test) {\\n    Condition[] memory _conditions = new Condition[](conditions.length);\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx < conditions.length;\\n      conditionIdx++\\n    ) {\\n      _conditions[conditionIdx] = conditions[conditionIdx];\\n    }\\n    return _conditions;\\n  }\\n\\n  function conditionsLength() public view returns (uint256) {\\n    return conditions.length;\\n  }\\n\\n  /*******************************************************\\n   *                Condition Validation Logic\\n   *******************************************************/\\n  function validateCondition(Condition memory condition) public view {\\n    string[][] memory requirements = condition.requirements;\\n\\n    for (\\n      uint256 requirementIdx;\\n      requirementIdx < requirements.length;\\n      requirementIdx++\\n    ) {\\n      string[] memory requirement = requirements[requirementIdx];\\n      string memory requirementType = requirement[0];\\n      string memory requirementValidationMethod = requirement[1];\\n      string memory methodSignature;\\n      string memory paramType;\\n      bool requirementTypeIsTarget = Strings.stringsEqual(\\n        requirementType,\\n        \\\"target\\\"\\n      );\\n      bool requirementTypeIsParam = Strings.stringsEqual(\\n        requirementType,\\n        \\\"param\\\"\\n      );\\n      if (requirementTypeIsTarget) {\\n        require(\\n          requirement.length == 2,\\n          \\\"Requirement length must be equal to 2\\\"\\n        );\\n        methodSignature = string(\\n          abi.encodePacked(requirementValidationMethod, \\\"(address)\\\")\\n        );\\n      } else if (requirementTypeIsParam) {\\n        require(\\n          requirement.length == 3,\\n          \\\"Requirement length must be equal to 3\\\"\\n        );\\n        uint256 paramIdx = Strings.atoi(requirement[2], 10);\\n        require(\\n          paramIdx <= condition.paramTypes.length - 1,\\n          \\\"Requirement parameter index is out of range\\\"\\n        );\\n        paramType = condition.paramTypes[paramIdx];\\n        methodSignature = string(\\n          abi.encodePacked(requirementValidationMethod, \\\"(\\\", paramType, \\\")\\\")\\n        );\\n      } else {\\n        revert(\\\"Unsupported requirement type\\\");\\n      }\\n\\n      address implementationAddress = condition.implementationAddress;\\n      require(\\n        implementationAddress != address(0),\\n        \\\"Implementation address is not set\\\"\\n      );\\n\\n      bool implementsInterface = Introspection.implementsMethodSignature(\\n        implementationAddress,\\n        methodSignature\\n      );\\n      require(\\n        implementsInterface == true,\\n        \\\"Implementation does not implement method selector\\\"\\n      );\\n    }\\n  }\\n\\n  function validateConditions() public view {\\n    for (\\n      uint256 conditionIdx;\\n      conditionIdx < conditions.length;\\n      conditionIdx++\\n    ) {\\n      Condition memory condition = conditions[conditionIdx];\\n      validateCondition(condition);\\n    }\\n  }\\n\\n  function implementationValid() public view returns (bool) {\\n    (bool success, ) = address(this).staticcall(\\n      abi.encodeWithSignature(\\\"validateConditions()\\\")\\n    );\\n    return success;\\n  }\\n}\\n\"\r\n    },\r\n    \"libraries/Introspection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nlibrary Introspection {\\n  // function implementsMethodNameAndParamTypes(string memory methodName, string[])\\n  function implementsMethodSignature(address _address, string memory _signature)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    bytes4 _selector = bytes4(keccak256(bytes(_signature)));\\n    uint256 contractSize;\\n    assembly {\\n      contractSize := extcodesize(_address)\\n    }\\n    bytes memory code = new bytes(contractSize);\\n    assembly {\\n      extcodecopy(_address, add(code, 0x20), 0, contractSize)\\n    }\\n    uint256 ptr = 0;\\n    while (ptr < contractSize) {\\n      // PUSH4 0x000000 (selector)\\n      if (code[ptr] == 0x63) {\\n        bytes memory selectorBytes = new bytes(64);\\n        selectorBytes[0] = code[ptr + 1];\\n        selectorBytes[1] = code[ptr + 2];\\n        selectorBytes[2] = code[ptr + 3];\\n        selectorBytes[3] = code[ptr + 4];\\n        bytes4 selector = abi.decode(selectorBytes, (bytes4));\\n        if (selector == _selector) {\\n          return true;\\n        }\\n      }\\n      ptr++;\\n    }\\n    return false;\\n  }\\n\\n  function implementsInterface(address _address, string[] memory _interface)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    for (uint256 methodIdx = 0; methodIdx < _interface.length; methodIdx++) {\\n      string memory method = _interface[methodIdx];\\n      bool methodIsImplemented = implementsMethodSignature(_address, method);\\n      if (!methodIsImplemented) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n}\\n\"\r\n    },\r\n    \"libraries/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nlibrary Strings {\\n  /**\\n   * @notice Search for a needle in a haystack\\n   * @param haystack The string to search\\n   * @param needle The string to search for\\n   */\\n  function stringStartsWith(string memory haystack, string memory needle)\\n    public\\n    pure\\n    returns (bool)\\n  {\\n    return indexOfStringInString(needle, haystack) == 0;\\n  }\\n\\n  /**\\n   * @notice Case insensitive string search\\n   * @param needle The string to search for\\n   * @param haystack The string to search\\n   * @return Returns -1 if no match is found, otherwise returns the index of the match\\n   */\\n  function indexOfStringInString(string memory needle, string memory haystack)\\n    public\\n    pure\\n    returns (int256)\\n  {\\n    bytes memory _needle = bytes(needle);\\n    bytes memory _haystack = bytes(haystack);\\n    if (_haystack.length < _needle.length) {\\n      return -1;\\n    }\\n    bool _match;\\n    for (uint256 haystackIdx; haystackIdx < _haystack.length; haystackIdx++) {\\n      for (uint256 needleIdx; needleIdx < _needle.length; needleIdx++) {\\n        uint8 needleChar = uint8(_needle[needleIdx]);\\n        if (haystackIdx + needleIdx >= _haystack.length) {\\n          return -1;\\n        }\\n        uint8 haystackChar = uint8(_haystack[haystackIdx + needleIdx]);\\n        if (needleChar == haystackChar) {\\n          _match = true;\\n          if (needleIdx == _needle.length - 1) {\\n            return int256(haystackIdx);\\n          }\\n        } else {\\n          _match = false;\\n          break;\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n\\n  /**\\n   * @notice Check to see if two strings are exactly equal\\n   */\\n  function stringsEqual(string memory input1, string memory input2)\\n    public\\n    pure\\n    returns (bool)\\n  {\\n    uint256 input1Length = bytes(input1).length;\\n    uint256 input2Length = bytes(input2).length;\\n    uint256 maxLength;\\n    if (input1Length > input2Length) {\\n      maxLength = input1Length;\\n    } else {\\n      maxLength = input2Length;\\n    }\\n    uint256 numberOfRowsToCompare = (maxLength / 32) + 1;\\n    bytes32 input1Bytes32;\\n    bytes32 input2Bytes32;\\n    for (uint256 rowIdx; rowIdx < numberOfRowsToCompare; rowIdx++) {\\n      uint256 offset = 0x20 * (rowIdx + 1);\\n      assembly {\\n        input1Bytes32 := mload(add(input1, offset))\\n        input2Bytes32 := mload(add(input2, offset))\\n      }\\n      if (input1Bytes32 != input2Bytes32) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  function atoi(string memory a, uint8 base) public pure returns (uint256 i) {\\n    require(base == 2 || base == 8 || base == 10 || base == 16);\\n    bytes memory buf = bytes(a);\\n    for (uint256 p = 0; p < buf.length; p++) {\\n      uint8 digit = uint8(buf[p]) - 0x30;\\n      if (digit > 10) {\\n        digit -= 7;\\n      }\\n      require(digit < base);\\n      i *= base;\\n      i += digit;\\n    }\\n    return i;\\n  }\\n\\n  function itoa(uint256 i, uint8 base) public pure returns (string memory a) {\\n    require(base == 2 || base == 8 || base == 10 || base == 16);\\n    if (i == 0) {\\n      return \\\"0\\\";\\n    }\\n    bytes memory buf = new bytes(256);\\n    uint256 p = 0;\\n    while (i > 0) {\\n      uint8 digit = uint8(i % base);\\n      uint8 ascii = digit + 0x30;\\n      if (digit > 9) {\\n        ascii += 7;\\n      }\\n      buf[p++] = bytes1(ascii);\\n      i /= base;\\n    }\\n    uint256 length = p;\\n    for (p = 0; p < length / 2; p++) {\\n      buf[p] ^= buf[length - 1 - p];\\n      buf[length - 1 - p] ^= buf[p];\\n      buf[p] ^= buf[length - 1 - p];\\n    }\\n    return string(buf);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"a\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"base\",\"type\":\"uint8\"}],\"name\":\"atoi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"needle\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"haystack\",\"type\":\"string\"}],\"name\":\"indexOfStringInString\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"base\",\"type\":\"uint8\"}],\"name\":\"itoa\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"a\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"haystack\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"needle\",\"type\":\"string\"}],\"name\":\"stringStartsWith\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"input1\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"input2\",\"type\":\"string\"}],\"name\":\"stringsEqual\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"Strings","CompilerVersion":"v0.8.11+commit.d7f03943","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}