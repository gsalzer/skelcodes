{"status":"1","message":"OK","result":[{"SourceCode":"// File: https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router01.sol\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n// File: https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol\r\n\r\npragma solidity >=0.6.2;\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n// File: 4_deploy-defarm/Optimiser/SafeMath.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a, 'SafeMath:INVALID_ADD');\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a, 'SafeMath:OVERFLOW_SUB');\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(uint a, uint b, uint decimal) internal pure returns (uint) {\r\n        uint dc = 10**decimal;\r\n        uint c0 = a * b;\r\n        require(a == 0 || c0 / a == b, \"SafeMath: multiple overflow\");\r\n        uint c1 = c0 + (dc / 2);\r\n        require(c1 >= c0, \"SafeMath: multiple overflow\");\r\n        uint c2 = c1 / dc;\r\n        return c2;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, uint decimal) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: division by zero\");\r\n        uint dc = 10**decimal;\r\n        uint c0 = a * dc;\r\n        require(a == 0 || c0 / a == dc, \"SafeMath: division internal\");\r\n        uint c1 = c0 + (b / 2);\r\n        require(c1 >= c0, \"SafeMath: division internal\");\r\n        uint c2 = c1 / b;\r\n        return c2;\r\n    }\r\n}\r\n\r\n// File: 4_deploy-defarm/Optimiser/TransferHelper.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::safeApprove: approve failed'\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::safeTransfer: transfer failed'\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            'TransferHelper::transferFrom: transferFrom failed'\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\r\n    }\r\n}\r\n\r\n// File: 4_deploy-defarm/Optimiser/UniformRandomNumber.sol\r\n\r\n/**\r\nCopyright 2019 PoolTogether LLC\r\n\r\nThis file is part of PoolTogether.\r\n\r\nPoolTogether is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation under version 3 of the License.\r\n\r\nPoolTogether is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with PoolTogether.  If not, see <https://www.gnu.org/licenses/>.\r\n*/\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @author Brendan Asselstine\r\n * @notice A library that uses entropy to select a random number within a bound.  Compensates for modulo bias.\r\n * @dev Thanks to https://medium.com/hownetworks/dont-waste-cycles-with-modulo-bias-35b6fdafcf94\r\n */\r\nlibrary UniformRandomNumber {\r\n  /// @notice Select a random number without modulo bias using a random seed and upper bound\r\n  /// @param _entropy The seed for randomness\r\n  /// @param _upperBound The upper bound of the desired number\r\n  /// @return A random number less than the _upperBound\r\n  function uniform(uint256 _entropy, uint256 _upperBound) internal pure returns (uint256) {\r\n    require(_upperBound > 0, \"UniformRand/min-bound\");\r\n    uint256 min = -_upperBound % _upperBound;\r\n    uint256 random = _entropy;\r\n    while (true) {\r\n      if (random >= min) {\r\n        break;\r\n      }\r\n      random = uint256(keccak256(abi.encodePacked(random)));\r\n    }\r\n    return random % _upperBound;\r\n  }\r\n}\r\n\r\n\r\n// File: 4_deploy-defarm/Optimiser/SortitionSumTreeFactory.sol\r\n\r\npragma solidity ^0.6.12;\r\n\r\n/**\r\n *  @reviewers: [@clesaege, @unknownunknown1, @ferittuncer]\r\n *  @auditors: []\r\n *  @bounties: [<14 days 10 ETH max payout>]\r\n *  @deployments: []\r\n */\r\n\r\n/**\r\n *  @title SortitionSumTreeFactory\r\n *  @author Enrique Piqueras - <epiquerass@gmail.com>\r\n *  @dev A factory of trees that keep track of staked values for sortition.\r\n */\r\nlibrary SortitionSumTreeFactory {\r\n    /* Structs */\r\n\r\n    struct SortitionSumTree {\r\n        uint K; // The maximum number of childs per node.\r\n        // We use this to keep track of vacant positions in the tree after removing a leaf. This is for keeping the tree as balanced as possible without spending gas on moving nodes around.\r\n        uint[] stack;\r\n        uint[] nodes;\r\n        // Two-way mapping of IDs to node indexes. Note that node index 0 is reserved for the root node, and means the ID does not have a node.\r\n        mapping(bytes32 => uint) IDsToNodeIndexes;\r\n        mapping(uint => bytes32) nodeIndexesToIDs;\r\n    }\r\n\r\n    /* Storage */\r\n\r\n    struct SortitionSumTrees {\r\n        mapping(bytes32 => SortitionSumTree) sortitionSumTrees;\r\n    }\r\n\r\n    /* internal */\r\n\r\n    /**\r\n     *  @dev Create a sortition sum tree at the specified key.\r\n     *  @param _key The key of the new tree.\r\n     *  @param _K The number of children each node in the tree should have.\r\n     */\r\n    function createTree(SortitionSumTrees storage self, bytes32 _key, uint _K) internal {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        require(tree.K == 0, \"Tree already exists.\");\r\n        require(_K > 1, \"K must be greater than one.\");\r\n        tree.K = _K;\r\n        tree.stack = new uint[](0);\r\n        tree.nodes = new uint[](0);\r\n        tree.nodes.push(0);\r\n    }\r\n\r\n    /**\r\n     *  @dev Set a value of a tree.\r\n     *  @param _key The key of the tree.\r\n     *  @param _value The new value.\r\n     *  @param _ID The ID of the value.\r\n     *  `O(log_k(n))` where\r\n     *  `k` is the maximum number of childs per node in the tree,\r\n     *   and `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function set(SortitionSumTrees storage self, bytes32 _key, uint _value, bytes32 _ID) internal {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\r\n\r\n        if (treeIndex == 0) { // No existing node.\r\n            if (_value != 0) { // Non zero value.\r\n                // Append.\r\n                // Add node.\r\n                if (tree.stack.length == 0) { // No vacant spots.\r\n                    // Get the index and append the value.\r\n                    treeIndex = tree.nodes.length;\r\n                    tree.nodes.push(_value);\r\n\r\n                    // Potentially append a new node and make the parent a sum node.\r\n                    if (treeIndex != 1 && (treeIndex - 1) % tree.K == 0) { // Is first child.\r\n                        uint parentIndex = treeIndex / tree.K;\r\n                        bytes32 parentID = tree.nodeIndexesToIDs[parentIndex];\r\n                        uint newIndex = treeIndex + 1;\r\n                        tree.nodes.push(tree.nodes[parentIndex]);\r\n                        delete tree.nodeIndexesToIDs[parentIndex];\r\n                        tree.IDsToNodeIndexes[parentID] = newIndex;\r\n                        tree.nodeIndexesToIDs[newIndex] = parentID;\r\n                    }\r\n                } else { // Some vacant spot.\r\n                    // Pop the stack and append the value.\r\n                    treeIndex = tree.stack[tree.stack.length - 1];\r\n                    tree.stack.pop();\r\n                    tree.nodes[treeIndex] = _value;\r\n                }\r\n\r\n                // Add label.\r\n                tree.IDsToNodeIndexes[_ID] = treeIndex;\r\n                tree.nodeIndexesToIDs[treeIndex] = _ID;\r\n\r\n                updateParents(self, _key, treeIndex, true, _value);\r\n            }\r\n        } else { // Existing node.\r\n            if (_value == 0) { // Zero value.\r\n                // Remove.\r\n                // Remember value and set to 0.\r\n                uint value = tree.nodes[treeIndex];\r\n                tree.nodes[treeIndex] = 0;\r\n\r\n                // Push to stack.\r\n                tree.stack.push(treeIndex);\r\n\r\n                // Clear label.\r\n                delete tree.IDsToNodeIndexes[_ID];\r\n                delete tree.nodeIndexesToIDs[treeIndex];\r\n\r\n                updateParents(self, _key, treeIndex, false, value);\r\n            } else if (_value != tree.nodes[treeIndex]) { // New, non zero value.\r\n                // Set.\r\n                bool plusOrMinus = tree.nodes[treeIndex] <= _value;\r\n                uint plusOrMinusValue = plusOrMinus ? _value - tree.nodes[treeIndex] : tree.nodes[treeIndex] - _value;\r\n                tree.nodes[treeIndex] = _value;\r\n\r\n                updateParents(self, _key, treeIndex, plusOrMinus, plusOrMinusValue);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* internal Views */\r\n\r\n    /**\r\n     *  @dev Query the leaves of a tree. Note that if `startIndex == 0`, the tree is empty and the root node will be returned.\r\n     *  @param _key The key of the tree to get the leaves from.\r\n     *  @param _cursor The pagination cursor.\r\n     *  @param _count The number of items to return.\r\n     *  @return startIndex The index at which leaves start\r\n     *  @return values The values of the returned leaves\r\n     *  @return hasMore Whether there are more for pagination.\r\n     *  `O(n)` where\r\n     *  `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function queryLeafs(\r\n        SortitionSumTrees storage self,\r\n        bytes32 _key,\r\n        uint _cursor,\r\n        uint _count\r\n    ) internal view returns(uint startIndex, uint[] memory values, bool hasMore) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n\r\n        // Find the start index.\r\n        for (uint i = 0; i < tree.nodes.length; i++) {\r\n            if ((tree.K * i) + 1 >= tree.nodes.length) {\r\n                startIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Get the values.\r\n        uint loopStartIndex = startIndex + _cursor;\r\n        values = new uint[](loopStartIndex + _count > tree.nodes.length ? tree.nodes.length - loopStartIndex : _count);\r\n        uint valuesIndex = 0;\r\n        for (uint j = loopStartIndex; j < tree.nodes.length; j++) {\r\n            if (valuesIndex < _count) {\r\n                values[valuesIndex] = tree.nodes[j];\r\n                valuesIndex++;\r\n            } else {\r\n                hasMore = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @dev Draw an ID from a tree using a number. Note that this function reverts if the sum of all values in the tree is 0.\r\n     *  @param _key The key of the tree.\r\n     *  @param _drawnNumber The drawn number.\r\n     *  @return ID The drawn ID.\r\n     *  `O(k * log_k(n))` where\r\n     *  `k` is the maximum number of childs per node in the tree,\r\n     *   and `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function draw(SortitionSumTrees storage self, bytes32 _key, uint _drawnNumber) internal view returns(bytes32 ID) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        uint treeIndex = 0;\r\n        uint currentDrawnNumber = _drawnNumber % tree.nodes[0];\r\n\r\n        while ((tree.K * treeIndex) + 1 < tree.nodes.length)  // While it still has children.\r\n            for (uint i = 1; i <= tree.K; i++) { // Loop over children.\r\n                uint nodeIndex = (tree.K * treeIndex) + i;\r\n                uint nodeValue = tree.nodes[nodeIndex];\r\n\r\n                if (currentDrawnNumber >= nodeValue) currentDrawnNumber -= nodeValue; // Go to the next child.\r\n                else { // Pick this child.\r\n                    treeIndex = nodeIndex;\r\n                    break;\r\n                }\r\n            }\r\n        \r\n        ID = tree.nodeIndexesToIDs[treeIndex];\r\n    }\r\n\r\n    /** @dev Gets a specified ID's associated value.\r\n     *  @param _key The key of the tree.\r\n     *  @param _ID The ID of the value.\r\n     *  @return value The associated value.\r\n     */\r\n    function stakeOf(SortitionSumTrees storage self, bytes32 _key, bytes32 _ID) internal view returns(uint value) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        uint treeIndex = tree.IDsToNodeIndexes[_ID];\r\n\r\n        if (treeIndex == 0) value = 0;\r\n        else value = tree.nodes[treeIndex];\r\n    }\r\n\r\n    function total(SortitionSumTrees storage self, bytes32 _key) internal view returns (uint) {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n        if (tree.nodes.length == 0) {\r\n            return 0;\r\n        } else {\r\n            return tree.nodes[0];\r\n        }\r\n    }\r\n\r\n    /* Private */\r\n\r\n    /**\r\n     *  @dev Update all the parents of a node.\r\n     *  @param _key The key of the tree to update.\r\n     *  @param _treeIndex The index of the node to start from.\r\n     *  @param _plusOrMinus Wether to add (true) or substract (false).\r\n     *  @param _value The value to add or substract.\r\n     *  `O(log_k(n))` where\r\n     *  `k` is the maximum number of childs per node in the tree,\r\n     *   and `n` is the maximum number of nodes ever appended.\r\n     */\r\n    function updateParents(SortitionSumTrees storage self, bytes32 _key, uint _treeIndex, bool _plusOrMinus, uint _value) private {\r\n        SortitionSumTree storage tree = self.sortitionSumTrees[_key];\r\n\r\n        uint parentIndex = _treeIndex;\r\n        while (parentIndex != 0) {\r\n            parentIndex = (parentIndex - 1) / tree.K;\r\n            tree.nodes[parentIndex] = _plusOrMinus ? tree.nodes[parentIndex] + _value : tree.nodes[parentIndex] - _value;\r\n        }\r\n    }\r\n}\r\n// File: 4_deploy-defarm/Optimiser/Optimiser.sol\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Optimiser {\r\n    using SafeMath for uint;\r\n    using SortitionSumTreeFactory for SortitionSumTreeFactory.SortitionSumTrees;\r\n\r\n    struct PoolInfo {\r\n        uint total_weightage;\r\n        uint rate_reward;\r\n    }\r\n    \r\n    struct SessionInfo {\r\n        uint total_reward;\r\n        uint start_timestamp;\r\n        uint end_timestamp;\r\n        bool can_claim;      // upon session ended, enable user to claim reward\r\n        bool deposit_paused; // access control\r\n        bool claim_paused;   // access control\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint purchase_counter;\r\n    }\r\n\r\n    struct UserSessionInfo {\r\n        uint tvl;\r\n        uint num_of_ticket;\r\n        uint first_deposit_timestamp;\r\n        uint penalty_until_timestamp;\r\n        bool has_purchased; // once purchased in the session, always is true\r\n        bool has_claimed;   // reward only can claim once\r\n    }\r\n    \r\n    struct UserPoolInfo {\r\n        uint weightage;\r\n        uint num_of_ticket;\r\n        bool claimed;\r\n    }\r\n\r\n    // mapping (session ID => session info)\r\n    mapping(uint => SessionInfo) private session;\r\n    \r\n    // mapping (session ID => pool category => pool information)\r\n    mapping(uint => mapping(uint => PoolInfo)) private pool;\r\n    \r\n    // mapping (user address => session ID => pool category => user purchased information)\r\n    mapping(address => mapping(uint => mapping(uint => UserPoolInfo))) private user_pool;\r\n    \r\n    // mapping (user address => session ID => user info by session)\r\n    mapping(address => mapping(uint => UserSessionInfo)) private user_session;\r\n    \r\n    // mapping (user address => user personal info)\r\n    mapping(address => UserInfo) private user_info;\r\n\r\n    // mapping (pool category ID => rate reward) master lookup\r\n    mapping(uint => uint) public pool_reward_list;\r\n    \r\n    // mapping (pool category ID => chances of user enter the pool) lookup\r\n    mapping(uint => uint) public pool_chances;\r\n    \r\n    mapping(address => bool) public access_permission;\r\n    \r\n    bool    private initialized;\r\n    bool    public stop_next_session; // toggle for session will auto continue or not\r\n    bool    public swap_payment;      // payment will swap to DEX and burn\r\n\r\n    address public  owner;          // owner who deploy the contract\r\n    address public  tube;           // TUBE2 token contract\r\n    address public  tube_chief;     // TUBE Chief contract\r\n    address public  dev;            // development address\r\n    address public  utility;        // other usage purpose\r\n    address public  buyback;        // upon user hit penalty, transfer for buyback\r\n    address public  uniswap_router; // dex router address\r\n    address public  signer;         // website validation\r\n\r\n    uint    private  preseed;            // RNG seed\r\n    uint    public  session_id;          // current session ID\r\n    uint    public  session_minute;      // session duration\r\n    uint    public  category_size;       // current pool category size\r\n    uint    public  eth_per_ticket;      // how many ETH to buy 1 ticket\r\n    uint    public  rate_buyback;        // fund distribution for buyback TUBE\r\n    uint    public  rate_dev;            // fund distrubtion for dev team\r\n    uint    public  rate_penalty;        // claim penalty rate\r\n    uint    public  penalty_base_minute; // claim penalty basis duration\r\n    uint    public  DECIMAL;             // ether unit decimal\r\n    uint    public  PER_UNIT;            // ether unit\r\n    uint[]  public  multiplier_list;     // multiplier list\r\n    \r\n    uint256 constant private MAX_TREE_LEAVES = 5;\r\n    bytes32 constant private TREE_KEY        = keccak256(\"JACKPOT\");\r\n    \r\n    SortitionSumTreeFactory.SortitionSumTrees private sortitionSumTrees;\r\n\r\n    event PurchaseTicket(uint session_id, uint multiplier_rate, uint pool_index, uint eth_per_ticket, uint tvl, uint weightage, uint timestamp, address buyer);\r\n    event Claim(uint session_id, uint claimable, uint actual_claimable, uint penalty_amount, uint timestamp, address buyer);\r\n    event CompletePot(uint conclude_session, uint reward_amount, uint timestamp);\r\n    event UpdateMultiplierList(uint[] multiplier_list);\r\n    event UpdatePenaltySetting(uint rate_penalty, uint penalty_base_minute);\r\n    event UpdateContracts(address tube, address tube_chief, address buyback, address dev, address utility, address uniswap_router, address signer);\r\n    event UpdateRewardBySessionId(uint session_id, uint amount);\r\n    event UpdateRewardPermission(address _address, bool status);\r\n    event UpdateAccessPermission(address _address, bool status);\r\n    event UpdatePoolCategory(uint new_max_category, uint[] reward_rates, uint[] chance_rates);\r\n    event UpdateSessionEndTimestamp(uint end_timestamp);\r\n    event UpdateStopNextSession(bool status);\r\n    event UpdateSwapPayment(bool status);\r\n    event UpdateSessionMinute(uint minute);\r\n    event UpdatePaymentRateDistribution(uint rate_buyback, uint rate_dev);\r\n    event UpdateToggleBySession(uint session_id, bool deposit_paused, bool claim_paused);\r\n    event UpdateEthPerTicket(uint eth_per_ticket);\r\n    event TransferOwner(address old_owner, address new_owner);\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier hasAccessPermission {\r\n        require(access_permission[msg.sender], \"no access permission\");\r\n        _;\r\n    }\r\n\r\n    /*\r\n    * init function after contract deployment\r\n    */\r\n    function initialize() public {\r\n        require(!initialized, \"Contract instance has already been initialized\");\r\n        initialized = true;\r\n        \r\n        sortitionSumTrees.createTree(TREE_KEY, MAX_TREE_LEAVES);\r\n        \r\n        owner = msg.sender;\r\n        \r\n        // constant value\r\n        DECIMAL  = 18;\r\n        PER_UNIT = 1000000000000000000;\r\n        \r\n        // multipliers (1.5, 3, 6, 9)\r\n        multiplier_list.push(1500000000000000000);\r\n        multiplier_list.push(3000000000000000000);\r\n        multiplier_list.push(6000000000000000000);\r\n        multiplier_list.push(9000000000000000000);\r\n        \r\n        // reward distribution: P1[0] 33%, P2[1] 33%, P3[2] 33%\r\n        // chances enter pool : P1[0] 50%, P2[1] 30%, P3[2] 20%\r\n        category_size = 3;\r\n        pool_reward_list[0] = 333333333333333333;\r\n        pool_reward_list[1] = 333333333333333333;\r\n        pool_reward_list[2] = 333333333333333333;\r\n        _updatePoolChances(0, 500000000000000000);\r\n        _updatePoolChances(1, 300000000000000000);\r\n        _updatePoolChances(2, 200000000000000000);\r\n\r\n        // per session duration 7 day\r\n        session_minute = 10080;\r\n        session_id     = 2;\r\n        \r\n        // ticket price (0.2 ETH)\r\n        eth_per_ticket = 200000000000000000;\r\n        \r\n        // payment received distribution (remaining 10% will for utility)\r\n        rate_buyback = 700000000000000000;\r\n        rate_dev     = 200000000000000000;\r\n        \r\n        // penalty setting (30%, base lock up to 30 day)\r\n        rate_penalty        = 300000000000000000;\r\n        penalty_base_minute = 43200;\r\n        \r\n        // contract linking\r\n        tube           = 0xdA86006036540822e0cd2861dBd2fD7FF9CAA0e8;\r\n        tube_chief     = 0x5fe65B1172E148d1Ac4F44fFc4777c2D4731ee8f;\r\n        dev            = 0xAd451FBEaee85D370ca953D2020bb0480c2Cfc45;\r\n        buyback        = 0x702b11a838429Edca4Ea0e80c596501F1a4F4c28;\r\n        utility        = 0x4679025788c92187d44BdA852e9fF97229e3109b;\r\n        uniswap_router = 0x37D7f26405103C9Bc9D8F9352Cf32C5b655CBe02;\r\n        signer         = 0xd916731C0063E0c8D93552bE0a021c9Ae15ff183;\r\n\r\n        // permission\r\n        access_permission[msg.sender] = true;\r\n    }\r\n\r\n    /*\r\n    * user purchase ticket and join current session jackpot\r\n    * @params tvl - input from front end with signature validation \r\n    */\r\n    function purchaseTicket(uint _tvl, uint counter, bytes memory signature) public payable {\r\n        require(!session[session_id].deposit_paused, \"deposit paused\");\r\n        require(session[session_id].end_timestamp > block.timestamp, \"jackpot ended\");\r\n        require(msg.value == eth_per_ticket, \"invalid payment\");\r\n        require(counter > user_info[msg.sender].purchase_counter, 'EXPIRED COUNTER'); // prevent replay attack\r\n        require(_verifySign(signer, msg.sender, _tvl, counter, signature), \"invalid signature\");\r\n\r\n        // replace user purchase counter number\r\n        user_info[msg.sender].purchase_counter = counter;\r\n        \r\n        // uniform lowest bound number is 0\r\n        // result format is in array index so max upper bound number need to minus 1\r\n        uint mul_index  = UniformRandomNumber.uniform(_rngSeed(), multiplier_list.length);\r\n        uint pool_index = _pickPoolIndex();\r\n        \r\n        // tvl should source from maximizer pool. (LP staked value * weightage)\r\n        uint actual_weightage = _tvl.mul(multiplier_list[mul_index], DECIMAL);\r\n        \r\n        pool[session_id][pool_index].total_weightage                = pool[session_id][pool_index].total_weightage.add(actual_weightage);\r\n        user_pool[msg.sender][session_id][pool_index].weightage     = user_pool[msg.sender][session_id][pool_index].weightage.add(actual_weightage);\r\n        user_pool[msg.sender][session_id][pool_index].num_of_ticket = user_pool[msg.sender][session_id][pool_index].num_of_ticket.add(1);\r\n        user_session[msg.sender][session_id].tvl                    = user_session[msg.sender][session_id].tvl.add(_tvl);\r\n        user_session[msg.sender][session_id].num_of_ticket          = user_session[msg.sender][session_id].num_of_ticket.add(1);\r\n        user_session[msg.sender][session_id].has_purchased          = true;\r\n        \r\n        if (swap_payment) {\r\n            _paymentDistributionDex(msg.value);\r\n        } else {\r\n            _paymentDistributionBuyback(msg.value);    \r\n        }\r\n\r\n        // withdrawal penalty set once\r\n        // -> block.timestamp + 30 day + session(end - now)\r\n        if (user_session[msg.sender][session_id].penalty_until_timestamp <= 0) {\r\n            user_session[msg.sender][session_id].first_deposit_timestamp = block.timestamp;\r\n            user_session[msg.sender][session_id].penalty_until_timestamp = session[session_id].end_timestamp.add(penalty_base_minute * 60);\r\n        }\r\n        \r\n        emit PurchaseTicket(session_id, multiplier_list[mul_index], pool_index, eth_per_ticket, _tvl, actual_weightage, block.timestamp, msg.sender);\r\n    }\r\n\r\n    /*\r\n    * user claim reward by session\r\n    */\r\n    function claimReward(uint _session_id) public {\r\n        require(session[_session_id].can_claim, \"claim not enable\");\r\n        require(!session[_session_id].claim_paused, \"claim paused\");\r\n        require(!user_session[msg.sender][_session_id].has_claimed, \"reward claimed\");\r\n\r\n        uint claimable = 0;\r\n        for (uint pcategory = 0; pcategory < category_size; pcategory++) {\r\n            claimable = claimable.add(_userReward(msg.sender, _session_id, pcategory, session[_session_id].total_reward));\r\n        }\r\n        \r\n        uint actual_claimable = _rewardAfterPenalty(msg.sender, claimable, _session_id);\r\n        uint penalty_amount   = claimable.sub(actual_claimable);\r\n\r\n        // gas saving. transfer penalty amount for buyback\r\n        if (claimable != actual_claimable) {\r\n            TransferHelper.safeTransfer(tube, buyback, penalty_amount);    \r\n        }\r\n\r\n        TransferHelper.safeTransfer(tube, msg.sender, actual_claimable);\r\n        user_session[msg.sender][_session_id].has_claimed = true;\r\n        \r\n        emit Claim(_session_id, claimable, actual_claimable, penalty_amount, block.timestamp, msg.sender);\r\n    }\r\n    \r\n    /*\r\n    * get current session ended\r\n    */\r\n    function getCurrentSessionEnded() public view returns(bool) {\r\n        return (session[session_id].end_timestamp <= block.timestamp);\r\n    }\r\n\r\n    /*\r\n    * get user in pool detail via pool category\r\n    */\r\n    function getUserPoolInfo(address _address, uint _session_id, uint _pool_category) public view returns(uint, uint, bool) {\r\n        return (\r\n            user_pool[_address][_session_id][_pool_category].weightage,\r\n            user_pool[_address][_session_id][_pool_category].num_of_ticket,\r\n            user_pool[_address][_session_id][_pool_category].claimed\r\n        );\r\n    }\r\n    \r\n    /*\r\n    * get user information\r\n    */\r\n    function getUserInfo(address _address) public view returns(uint) {\r\n        return (user_info[_address].purchase_counter);\r\n    }\r\n\r\n    /*\r\n    * get user in the session\r\n    */\r\n    function getUserSessionInfo(address _address, uint _session_id) public view returns(uint, uint, bool, bool, uint, uint) {\r\n        return (\r\n            user_session[_address][_session_id].tvl,\r\n            user_session[_address][_session_id].num_of_ticket,\r\n            user_session[_address][_session_id].has_purchased,\r\n            user_session[_address][_session_id].has_claimed,\r\n            user_session[_address][_session_id].first_deposit_timestamp,\r\n            user_session[_address][_session_id].penalty_until_timestamp\r\n        );\r\n    }\r\n\r\n    /*\r\n    * get user has participant on current jackpot session or not\r\n    */\r\n    function getCurrentSessionJoined(address _address) public view returns (bool) {\r\n        return user_session[_address][session_id].has_purchased;\r\n    }\r\n\r\n    /*\r\n    * get pool info\r\n    */\r\n    function getPool(uint _session_id, uint _pool_category) public view returns(uint, uint) {\r\n        return (\r\n            pool[_session_id][_pool_category].total_weightage,\r\n            pool[_session_id][_pool_category].rate_reward    \r\n        );\r\n    }\r\n\r\n    /*\r\n    * get session info\r\n    */\r\n    function getSession(uint _session_id) public view returns(uint, uint, uint, bool, bool, bool) {\r\n       return (\r\n           session[_session_id].total_reward,\r\n           session[_session_id].start_timestamp,\r\n           session[_session_id].end_timestamp,\r\n           session[_session_id].deposit_paused,\r\n           session[_session_id].can_claim,\r\n           session[_session_id].claim_paused\r\n        );\r\n    }\r\n    \r\n    /*\r\n    * get all pool reward by session ID\r\n    */\r\n    function getPoolRewardBySession(uint _session_id) public view returns(uint, uint[] memory) {\r\n        uint reward_tube  = 0;\r\n        if (_session_id == session_id) {\r\n             reward_tube = reward_tube.add(ITubeChief(tube_chief).getJackpotReward());\r\n        }\r\n\r\n        // local reward + pending tube chief reward\r\n        uint reward_atm            = reward_tube.add(session[_session_id].total_reward);\r\n        uint[] memory pool_rewards = new uint[](category_size);\r\n\r\n        for (uint pcategory = 0; pcategory < category_size; pcategory++) {\r\n            pool_rewards[pcategory] = reward_atm.mul(pool[_session_id][pcategory].rate_reward, DECIMAL);\r\n        }\r\n\r\n        return (category_size, pool_rewards);\r\n    }\r\n\r\n    /*\r\n    * get user reward by session ID\r\n    */\r\n    function getUserRewardBySession(address _address, uint _session_id) public view returns (uint, uint) {\r\n        uint reward_atm = session[_session_id].total_reward;\r\n\r\n        if (_session_id == session_id) {\r\n             reward_atm = reward_atm.add(ITubeChief(tube_chief).getJackpotReward());\r\n        }\r\n\r\n        uint claimable = 0;\r\n        for (uint pcategory = 0; pcategory < category_size; pcategory++) {\r\n            claimable = claimable.add(_userReward(_address, _session_id, pcategory, reward_atm));\r\n        }\r\n\r\n        uint max_claimable = claimable;\r\n\r\n        claimable = _rewardAfterPenalty(_address, claimable, _session_id);\r\n\r\n        return (max_claimable, claimable);\r\n    }\r\n\r\n    /*\r\n    * start jackpot new session\r\n    */\r\n    function initPot() public hasAccessPermission {\r\n        _startPot();\r\n    }\r\n\r\n    /*\r\n    * update ticket prcing\r\n    */\r\n    function updateEthPerTicket(uint _eth_per_ticket) public hasAccessPermission {\r\n        eth_per_ticket = _eth_per_ticket;\r\n        emit UpdateEthPerTicket(eth_per_ticket);\r\n    }\r\n    \r\n    /*\r\n    * update jackpot control toggle by session ID\r\n    */\r\n    function updateToggleBySession(uint _session_id, bool _deposit_paused, bool _claim_paused) public hasAccessPermission {\r\n        session[_session_id].deposit_paused = _deposit_paused;\r\n        session[_session_id].claim_paused   = _claim_paused;\r\n        emit UpdateToggleBySession(_session_id, _deposit_paused, _claim_paused);\r\n    }\r\n\r\n    /*\r\n    * update current session end timestamp\r\n    */\r\n    function updateSessionEndTimestamp(uint end_timestamp) public hasAccessPermission {\r\n        session[session_id].end_timestamp = end_timestamp;\r\n        emit UpdateSessionEndTimestamp(end_timestamp);\r\n    }\r\n\r\n    /*\r\n    * resetup pool category size and reward distribution\r\n    * XX update will reflect immediately\r\n    */\r\n    function updateMultiplierList(uint[] memory _multiplier_list) public hasAccessPermission {\r\n       multiplier_list = _multiplier_list;\r\n       emit UpdateMultiplierList(multiplier_list);\r\n    }\r\n\r\n    /*\r\n    * update penatly setting\r\n    */\r\n    function updatePenaltySetting(uint _rate_penalty, uint _penalty_base_minute) public hasAccessPermission {\r\n        rate_penalty        = _rate_penalty;\r\n        penalty_base_minute = _penalty_base_minute;\r\n        emit UpdatePenaltySetting(rate_penalty, penalty_base_minute);\r\n    }\r\n    \r\n    /*\r\n    * update payment rate distribution to each sectors\r\n    * (!) rate utility will auto result in (1 - rate_buyback - rate_dev)\r\n    */\r\n    function updatePaymentRateDistribution(uint _rate_buyback, uint _rate_dev) public hasAccessPermission {\r\n        rate_buyback = _rate_buyback;\r\n        rate_dev     = _rate_dev;\r\n        emit UpdatePaymentRateDistribution(rate_buyback, rate_dev);\r\n    }\r\n\r\n    /*\r\n    * update contract addresses\r\n    */\r\n    function updateContracts(\r\n        address _tube,\r\n        address _tube_chief,\r\n        address _buyback,\r\n        address _dev,\r\n        address _utility,\r\n        address _uniswap_router,\r\n        address _signer\r\n    ) public hasAccessPermission {\r\n        tube           = _tube;\r\n        tube_chief     = _tube_chief;\r\n        buyback        = _buyback;\r\n        dev            = _dev;\r\n        utility        = _utility;\r\n        uniswap_router = _uniswap_router;\r\n        signer         = _signer;\r\n        emit UpdateContracts(tube, tube_chief, buyback, dev, utility, uniswap_router, signer);\r\n    }\r\n\r\n    /*\r\n    * resetup pool category size and reward distribution\r\n    * @param new_max_category - total pool size\r\n    * @param reward_rates     - each pool reward distribution rate\r\n    * @param chance_rates     - change rate of user will enter the pool\r\n    * XX pool reward rate update will reflect on next session\r\n    * XX pool chance rate update will reflect now\r\n    * XX may incur high gas fee\r\n    */\r\n    function updatePoolCategory(uint new_max_category, uint[] memory reward_rates, uint[] memory chance_rates) public hasAccessPermission {\r\n        require(reward_rates.length == category_size, \"invalid input size\");\r\n\r\n        // remove old setting\r\n        for (uint i = 0; i < category_size; i++) {\r\n            delete pool_reward_list[i];\r\n            delete pool_chances[i];\r\n            _updatePoolChances(i, 0);\r\n        }\r\n\r\n        // add new setting\r\n        for (uint i = 0; i < new_max_category; i++) {\r\n            pool_reward_list[i] = reward_rates[i];\r\n            _updatePoolChances(i, chance_rates[i]);\r\n        }\r\n\r\n        category_size = new_max_category;\r\n        \r\n        emit UpdatePoolCategory(new_max_category, reward_rates, chance_rates);\r\n    }\r\n\r\n    /*\r\n    * update stop next session status\r\n    */\r\n    function updateStopNextSession(bool status) public hasAccessPermission {\r\n        stop_next_session = status;\r\n        emit UpdateStopNextSession(status);\r\n    }\r\n    \r\n    /*\r\n    * update jackpot duration\r\n    * XX update reflect on next session\r\n    */\r\n    function updateSessionMinute(uint minute) public hasAccessPermission {\r\n        session_minute = minute;\r\n        emit UpdateSessionMinute(minute);\r\n    }\r\n    \r\n    /*\r\n    * update swap payment method\r\n    */\r\n    function updateSwapPayment(bool status) public hasAccessPermission {\r\n        swap_payment = status;\r\n        emit UpdateSwapPayment(status);\r\n    }\r\n\r\n    /*\r\n    * update access permission\r\n    */\r\n    function updateAccessPermission(address _address, bool status) public onlyOwner {\r\n        access_permission[_address] = status;\r\n        emit UpdateAccessPermission(_address, status);\r\n    }\r\n\r\n    /*\r\n    * conclude current session and start new session\r\n    * - transferJackpot\r\n    * - completePot\r\n    */\r\n    function completePot() public hasAccessPermission {\r\n        require(session[session_id].end_timestamp <= block.timestamp, \"session not end\");\r\n\r\n        /*\r\n        * 1. main contract will transfer TUBE to this contract\r\n        * 2. update the total reward amount for current session\r\n        */\r\n        uint conclude_session = session_id;\r\n        uint reward_amount    = ITubeChief(tube_chief).transferJackpotReward();\r\n\r\n        session[conclude_session].total_reward = session[conclude_session].total_reward.add(reward_amount);\r\n        session[conclude_session].can_claim    = true;\r\n        session_id = session_id.add(1);\r\n        \r\n        if (!stop_next_session) {\r\n            _startPot();\r\n        }\r\n        \r\n        // if pool weightage is empty, transfer pool reward to buyback\r\n        for (uint pcategory = 0; pcategory < category_size; pcategory++) {\r\n            if (pool[conclude_session][pcategory].total_weightage > 0) {\r\n                continue;\r\n            }\r\n            uint amount = session[conclude_session].total_reward.mul(pool[conclude_session][pcategory].rate_reward, DECIMAL);\r\n            TransferHelper.safeTransfer(tube, buyback, amount);\r\n        }\r\n        \r\n        emit CompletePot(conclude_session, reward_amount, block.timestamp);\r\n    }\r\n    \r\n    /*\r\n    * transfer ownership. proceed wisely. only owner executable\r\n    */\r\n    function transferOwner(address new_owner) public onlyOwner {\r\n        emit TransferOwner(owner, new_owner);\r\n        owner = new_owner;\r\n    }\r\n    \r\n    /*\r\n    * emergency collect token from the contract. only owner executable\r\n    */\r\n    function emergencyCollectToken(address token, uint amount) public onlyOwner {\r\n        TransferHelper.safeTransfer(token, owner, amount);\r\n    }\r\n\r\n    /*\r\n    * emergency collect eth from the contract. only owner executable\r\n    */\r\n    function emergencyCollectEth(uint amount) public onlyOwner {\r\n        address payable owner_address = payable(owner);\r\n        TransferHelper.safeTransferETH(owner_address, amount);\r\n    }\r\n\r\n    function _userReward(address _address, uint _session_id, uint _pool_category, uint _total_reward) internal view returns (uint) {\r\n        // (Z / Total Z of all users) x P1 / P2 / P3 TUBE2 = X amount of reward\r\n        uint total_weight = pool[_session_id][_pool_category].total_weightage;\r\n        \r\n        if (total_weight <= 0 || user_pool[_address][_session_id][_pool_category].claimed) {\r\n            return 0;\r\n        }\r\n\r\n        uint user_weight = user_pool[_address][_session_id][_pool_category].weightage;\r\n        uint rate        = pool[_session_id][_pool_category].rate_reward;\r\n\r\n        return user_weight.div(total_weight, DECIMAL).mul(_total_reward, DECIMAL).mul(rate, DECIMAL);\r\n    }\r\n\r\n    function _startPot() internal {\r\n        session[session_id].start_timestamp = block.timestamp;\r\n        session[session_id].end_timestamp   = block.timestamp.add(session_minute * 60);\r\n        \r\n        // init P1, P2, P3\r\n        for (uint i = 0; i < category_size; i++) {\r\n            pool[session_id][i].rate_reward = pool_reward_list[i];\r\n        }\r\n    }\r\n\r\n    function _paymentDistributionDex(uint amount) internal {\r\n        uint buyback_amount = amount.mul(rate_buyback, DECIMAL);\r\n        uint dev_amount     = amount.mul(rate_dev, DECIMAL);\r\n        uint utility_amount = amount.sub(buyback_amount).sub(dev_amount);\r\n        uint tube_swapped   = _swapEthToTUBE(buyback_amount);\r\n        \r\n        TransferHelper.safeTransfer(tube, address(0), tube_swapped);\r\n        TransferHelper.safeTransferETH(dev, dev_amount);\r\n        TransferHelper.safeTransferETH(utility, utility_amount);\r\n    }\r\n    \r\n    function _paymentDistributionBuyback(uint amount) internal {\r\n        /*\r\n        * distribution plan (initial)\r\n        * buyback     - 70% (buyback)\r\n        * masternode  - 20% (dev)\r\n        * leaderboard - 10% (utility)\r\n        */\r\n        uint buyback_amount = amount.mul(rate_buyback, DECIMAL);\r\n        uint dev_amount     = amount.mul(rate_dev, DECIMAL);\r\n        uint utility_amount = amount.sub(buyback_amount).sub(dev_amount);\r\n\r\n        TransferHelper.safeTransferETH(buyback, buyback_amount);\r\n        TransferHelper.safeTransferETH(dev, dev_amount);\r\n        TransferHelper.safeTransferETH(utility, utility_amount);\r\n    }\r\n\r\n    function _rngSeed() internal returns (uint) {\r\n        uint seed = uint256(keccak256(abi.encode(block.number, msg.sender, preseed)));\r\n        preseed   = seed;\r\n        return seed;\r\n    }\r\n\r\n    function _swapEthToTUBE(uint amount) internal returns (uint) {\r\n        require(amount > 0, \"empty swap amount\");\r\n\r\n        TransferHelper.safeApprove(tube, uniswap_router, amount);\r\n        \r\n        address[] memory path = new address[](2);\r\n        path[0] = IUniswapV2Router02(uniswap_router).WETH();\r\n        path[1] = tube;\r\n        \r\n        // lower down the receive expectation to prevent high failure\r\n        uint buffer_rate = 980000000000000000;\r\n        uint deadline    = block.timestamp.add(60);\r\n        uint[] memory amount_out_min = new uint[](2);\r\n\r\n        amount_out_min        = IUniswapV2Router02(uniswap_router).getAmountsOut(amount, path);\r\n        amount_out_min[1]     = amount_out_min[1].mul(buffer_rate, DECIMAL);\r\n        uint[] memory swapped = IUniswapV2Router02(uniswap_router).swapExactETHForTokens{ value: amount }(amount_out_min[1], path, address(this), deadline);\r\n\r\n        return swapped[1];\r\n    }\r\n\r\n    function _rewardAfterPenalty(address _address, uint reward_amount, uint _session_id) internal view returns (uint) {\r\n        /*\r\n        * calculate the reward amount after penalty condition\r\n        *\r\n        * 1. get the withdrawable amount\r\n        * 2. get the withdraw penalty rate\r\n        * 3. get time ratio: (userPenaltyEndTime - now) / (penalty_base_minute * 60)\r\n        * 4. result = [full reward] x [penalty rate] x [time ratio]\r\n        */\r\n        if (user_session[_address][_session_id].penalty_until_timestamp >= block.timestamp) {\r\n           uint end            = user_session[_address][_session_id].penalty_until_timestamp;\r\n           uint diff_now       = end.sub(block.timestamp);\r\n           uint time_ratio     = diff_now.div(penalty_base_minute * 60, DECIMAL);\r\n           uint penalty_amount = reward_amount.mul(rate_penalty, DECIMAL).mul(time_ratio, DECIMAL);\r\n\r\n           reward_amount = reward_amount.sub(penalty_amount);\r\n        }\r\n        return reward_amount;\r\n    }\r\n    \r\n    function _updatePoolChances(uint pool_index, uint chance_rate) internal {\r\n        pool_chances[pool_index] = chance_rate;\r\n        sortitionSumTrees.set(TREE_KEY, chance_rate, bytes32(uint256(pool_index)));\r\n    }\r\n    \r\n    function _pickPoolIndex() internal returns (uint) {\r\n        return uint256(sortitionSumTrees.draw(TREE_KEY, _rngSeed()));\r\n    }\r\n\r\n    /*\r\n    * VerifySignature\r\n    */\r\n    function _getMessageHash(address buyer, uint tvl, uint counter) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(buyer, tvl, counter));\r\n    }\r\n\r\n    function _getEthSignedMessageHash(bytes32 _messageHash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash));\r\n    }\r\n\r\n    function _verifySign(address _signer, address buyer, uint tvl, uint counter, bytes memory signature) internal pure returns (bool) {\r\n        bytes32 messageHash = _getMessageHash(buyer, tvl, counter);\r\n        bytes32 ethSignedMessageHash = _getEthSignedMessageHash(messageHash);\r\n        return _recoverSigner(ethSignedMessageHash, signature) == _signer;\r\n    }\r\n\r\n    function _recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) internal pure returns (address) {\r\n        (bytes32 r, bytes32 s, uint8 v) = _splitSignature(_signature);\r\n        return ecrecover(_ethSignedMessageHash, v, r, s);\r\n    }\r\n\r\n    function _splitSignature(bytes memory sig) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\r\n        require(sig.length == 65, \"invalid signature length\");\r\n\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n    }\r\n}\r\n\r\ninterface ITubeChief {\r\n    function getJackpotReward() external view returns (uint);\r\n    function transferJackpotReward() external returns (uint);\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"session_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimable\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"actual_claimable\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"conclude_session\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"CompletePot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"session_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"multiplier_rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pool_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth_per_ticket\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tvl\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weightage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"PurchaseTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"old_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"TransferOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"UpdateAccessPermission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tube\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tube_chief\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyback\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dev\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"utility\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"uniswap_router\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"UpdateContracts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth_per_ticket\",\"type\":\"uint256\"}],\"name\":\"UpdateEthPerTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"multiplier_list\",\"type\":\"uint256[]\"}],\"name\":\"UpdateMultiplierList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate_buyback\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate_dev\",\"type\":\"uint256\"}],\"name\":\"UpdatePaymentRateDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate_penalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty_base_minute\",\"type\":\"uint256\"}],\"name\":\"UpdatePenaltySetting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"new_max_category\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"reward_rates\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"chance_rates\",\"type\":\"uint256[]\"}],\"name\":\"UpdatePoolCategory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"session_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UpdateRewardBySessionId\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"UpdateRewardPermission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end_timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateSessionEndTimestamp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minute\",\"type\":\"uint256\"}],\"name\":\"UpdateSessionMinute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"UpdateStopNextSession\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"UpdateSwapPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"session_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"deposit_paused\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"claim_paused\",\"type\":\"bool\"}],\"name\":\"UpdateToggleBySession\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DECIMAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PER_UNIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"access_permission\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyback\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"category_size\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_session_id\",\"type\":\"uint256\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"completePot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyCollectEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencyCollectToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eth_per_ticket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentSessionEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getCurrentSessionJoined\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_session_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pool_category\",\"type\":\"uint256\"}],\"name\":\"getPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_session_id\",\"type\":\"uint256\"}],\"name\":\"getPoolRewardBySession\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_session_id\",\"type\":\"uint256\"}],\"name\":\"getSession\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_session_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pool_category\",\"type\":\"uint256\"}],\"name\":\"getUserPoolInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_session_id\",\"type\":\"uint256\"}],\"name\":\"getUserRewardBySession\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_session_id\",\"type\":\"uint256\"}],\"name\":\"getUserSessionInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initPot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"multiplier_list\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penalty_base_minute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pool_chances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pool_reward_list\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tvl\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"purchaseTicket\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate_buyback\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate_dev\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate_penalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"session_id\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"session_minute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stop_next_session\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_payment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"transferOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tube\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tube_chief\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswap_router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"updateAccessPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tube\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tube_chief\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyback\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dev\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_utility\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswap_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"updateContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_eth_per_ticket\",\"type\":\"uint256\"}],\"name\":\"updateEthPerTicket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_multiplier_list\",\"type\":\"uint256[]\"}],\"name\":\"updateMultiplierList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate_buyback\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rate_dev\",\"type\":\"uint256\"}],\"name\":\"updatePaymentRateDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate_penalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_penalty_base_minute\",\"type\":\"uint256\"}],\"name\":\"updatePenaltySetting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"new_max_category\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"reward_rates\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"chance_rates\",\"type\":\"uint256[]\"}],\"name\":\"updatePoolCategory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"end_timestamp\",\"type\":\"uint256\"}],\"name\":\"updateSessionEndTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minute\",\"type\":\"uint256\"}],\"name\":\"updateSessionMinute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"updateStopNextSession\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"updateSwapPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_session_id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_deposit_paused\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_claim_paused\",\"type\":\"bool\"}],\"name\":\"updateToggleBySession\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"utility\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Optimiser","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://4b3e0d7e4188ad84d47cf466b0631c2f608fa5e1cbdd935e008ab63092163f7c"}]}