{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/debt/sapphire/SapphireCreditScore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.5.16;\\npragma experimental ABIEncoderV2;\\nimport \\\"@openzeppelin/contracts/cryptography/MerkleProof.sol\\\";\\n\\nimport {Adminable} from \\\"../../lib/Adminable.sol\\\";\\nimport {SafeMath} from \\\"../../lib/SafeMath.sol\\\";\\nimport {SapphireTypes} from \\\"./SapphireTypes.sol\\\";\\nimport {ISapphireCreditScore} from \\\"./ISapphireCreditScore.sol\\\";\\n\\ncontract SapphireCreditScore is ISapphireCreditScore, Adminable {\\n\\n    /* ========== Libraries ========== */\\n\\n    using SafeMath for uint256;\\n\\n    /* ========== Events ========== */\\n\\n    event MerkleRootUpdated(\\n        address indexed updater,\\n        bytes32 merkleRoot,\\n        uint256 updatedAt\\n    );\\n\\n    event CreditScoreUpdated(\\n        address indexed account,\\n        uint256 score,\\n        uint256 lastUpdated\\n    );\\n\\n    event PauseStatusUpdated(bool value);\\n\\n    event DelayDurationUpdated(\\n        address indexed account,\\n        uint256 value\\n    );\\n\\n    event PauseOperatorUpdated(\\n        address pauseOperator\\n    );\\n\\n    event MerkleRootUpdaterUpdated(\\n        address merkleRootUpdater\\n    );\\n\\n    event DocumentIdUpdated(\\n        string newDocumentId\\n    );\\n\\n    /* ========== Variables ========== */\\n\\n    bool private _initialized;\\n\\n    uint16 public maxScore;\\n\\n    bool public isPaused;\\n\\n    uint256 public lastMerkleRootUpdate;\\n\\n    uint256 public merkleRootDelayDuration;\\n\\n    bytes32 public currentMerkleRoot;\\n\\n    bytes32 public upcomingMerkleRoot;\\n\\n    address public merkleRootUpdater;\\n\\n    address public pauseOperator;\\n\\n    // The document ID of the IPFS document containing the current Merkle Tree\\n    string public documentId;\\n\\n    mapping(address => SapphireTypes.CreditScore) public userScores;\\n\\n    uint256 public currentEpoch;\\n\\n    /* ========== Modifiers ========== */\\n\\n    modifier onlyMerkleRootUpdater() {\\n        require(\\n            merkleRootUpdater == msg.sender,\\n            \\\"SapphireCreditScore: caller is not authorized to update merkle root\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyWhenActive() {\\n        require(\\n            !isPaused,\\n            \\\"SapphireCreditScore: contract is not active\\\"\\n        );\\n        _;\\n    }\\n\\n    /* ========== Init ========== */\\n\\n    function init(\\n        bytes32 _merkleRoot,\\n        address _merkleRootUpdater,\\n        address _pauseOperator,\\n        uint16 _maxScore\\n    )\\n        public\\n        onlyAdmin\\n    {\\n        require(\\n            !_initialized,\\n            \\\"SapphireCreditScore: init already called\\\"\\n        );\\n\\n        require(\\n            _maxScore > 0,\\n            \\\"SapphireCreditScore: max score cannot be zero\\\"\\n        );\\n\\n        currentMerkleRoot = _merkleRoot;\\n        upcomingMerkleRoot = _merkleRoot;\\n        merkleRootUpdater = _merkleRootUpdater;\\n        pauseOperator = _pauseOperator;\\n        lastMerkleRootUpdate = 0;\\n        isPaused = true;\\n        merkleRootDelayDuration = 86400; // 24 * 60 * 60 sec\\n        maxScore = _maxScore;\\n\\n        _initialized = true;\\n    }\\n\\n    /* ========== View Functions ========== */\\n\\n    /**\\n     * @dev Returns current block's timestamp\\n     *\\n     * @notice This function is introduced in order to properly test time delays in this contract\\n     */\\n    function currentTimestamp()\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return block.timestamp;\\n    }\\n\\n    /**\\n     * @dev Return last verified user score\\n     */\\n    function getLastScore(\\n        address _user\\n    )\\n        external\\n        view\\n        returns (uint256, uint16, uint256)\\n    {\\n        SapphireTypes.CreditScore memory userScore = userScores[_user];\\n        return (userScore.score, maxScore, userScore.lastUpdated);\\n    }\\n\\n    /* ========== Mutative Functions ========== */\\n\\n    /**\\n     * @dev Update upcoming merkle root\\n     *\\n     * @notice Can be called by:\\n     *      - the admin:\\n     *          1. Check if contract is paused\\n     *          2. Replace upcoming merkle root\\n     *      - merkle root updater:\\n     *          1. Check if contract is active\\n     *          2. Replace current merkle root with upcoming merkle root\\n     *          3. Update upcoming one with passed Merkle root.\\n     *          4. Update the last merkle root update with the current timestamp\\n     *          5. Increment the `currentEpoch`\\n     *\\n     * @param _newRoot New upcoming merkle root\\n     */\\n    function updateMerkleRoot(\\n        bytes32 _newRoot\\n    )\\n        external\\n    {\\n        require(\\n            _newRoot != 0x0000000000000000000000000000000000000000000000000000000000000000,\\n            \\\"SapphireCreditScore: root is empty\\\"\\n        );\\n\\n        if (msg.sender == getAdmin()) {\\n            updateMerkleRootAsAdmin(_newRoot);\\n        } else {\\n            updateMerkleRootAsUpdater(_newRoot);\\n        }\\n        emit MerkleRootUpdated(msg.sender, _newRoot, currentTimestamp());\\n    }\\n\\n    /**\\n     * @dev Request for verifying user's credit score\\n     *\\n     * @notice If the credit score is verified, this function updates the\\n     *         user's credit score with the verified one and current timestamp\\n     *\\n     * @param _proof Data required to verify if score is correct for current merkle root\\n     */\\n    function verifyAndUpdate(\\n        SapphireTypes.ScoreProof memory _proof\\n    )\\n        public\\n        returns (uint256, uint16)\\n    {\\n        require(\\n            _proof.account != address(0),\\n            \\\"SapphireCreditScore: account cannot be address 0\\\"\\n        );\\n\\n        bytes32 node = keccak256(abi.encodePacked(_proof.account, _proof.score));\\n\\n        require(\\n            MerkleProof.verify(_proof.merkleProof, currentMerkleRoot, node),\\n            \\\"SapphireCreditScore: invalid proof\\\"\\n        );\\n\\n        userScores[_proof.account] = SapphireTypes.CreditScore({\\n            score: _proof.score,\\n            lastUpdated: currentTimestamp()\\n        });\\n        emit CreditScoreUpdated(_proof.account, _proof.score, currentTimestamp());\\n\\n        return (_proof.score, maxScore);\\n    }\\n\\n     /* ========== Private Functions ========== */\\n\\n    /**\\n     * @dev Merkle root updating strategy for merkle root updater\\n    **/\\n    function updateMerkleRootAsUpdater(\\n        bytes32 _newRoot\\n    )\\n        private\\n        onlyMerkleRootUpdater\\n        onlyWhenActive\\n    {\\n        require(\\n            currentTimestamp() >= merkleRootDelayDuration.add(lastMerkleRootUpdate),\\n            \\\"SapphireCreditScore: cannot update merkle root before delay period\\\"\\n        );\\n\\n        currentMerkleRoot = upcomingMerkleRoot;\\n        upcomingMerkleRoot = _newRoot;\\n        currentEpoch++;\\n        lastMerkleRootUpdate = currentTimestamp();\\n    }\\n\\n    /**\\n     * @dev Merkle root updating strategy for the admin\\n    **/\\n    function updateMerkleRootAsAdmin(\\n        bytes32 _newRoot\\n    )\\n        private\\n        onlyAdmin\\n    {\\n        require(\\n            isPaused,\\n            \\\"SapphireCreditScore: only admin can update merkle root if paused\\\"\\n        );\\n\\n        upcomingMerkleRoot = _newRoot;\\n    }\\n\\n    /* ========== Admin Functions ========== */\\n\\n    /**\\n     * @dev Update merkle root delay duration\\n    */\\n    function setMerkleRootDelay(\\n        uint256 _delay\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        require(\\n            _delay > 0,\\n            \\\"SapphireCreditScore: the delay must be greater than 0\\\"\\n        );\\n\\n        require(\\n            _delay != merkleRootDelayDuration,\\n            \\\"SapphireCreditScore: the same delay is already set\\\"\\n        );\\n\\n        merkleRootDelayDuration = _delay;\\n        emit DelayDurationUpdated(msg.sender, _delay);\\n    }\\n\\n    /**\\n     * @dev Pause or unpause contract, which cause the merkle root updater\\n     *      to not be able to update the merkle root\\n     */\\n    function setPause(\\n        bool _value\\n    )\\n        external\\n    {\\n        require(\\n            msg.sender == pauseOperator,\\n            \\\"SapphireCreditScore: caller is not the pause operator\\\"\\n        );\\n\\n        require(\\n            _value != isPaused,\\n            \\\"SapphireCreditScore: cannot set the same pause value\\\"\\n        );\\n\\n        isPaused = _value;\\n        emit PauseStatusUpdated(_value);\\n    }\\n\\n    /**\\n     * @dev Sets the merkle root updater\\n    */\\n    function setMerkleRootUpdater(\\n        address _merkleRootUpdater\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        require(\\n            _merkleRootUpdater != merkleRootUpdater,\\n            \\\"SapphireCreditScore: cannot set the same merkle root updater\\\"\\n        );\\n\\n        merkleRootUpdater = _merkleRootUpdater;\\n        emit MerkleRootUpdaterUpdated(merkleRootUpdater);\\n    }\\n\\n    /**\\n     * @dev Sets the pause operator\\n    */\\n    function setPauseOperator(\\n        address _pauseOperator\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        require(\\n            _pauseOperator != pauseOperator,\\n            \\\"SapphireCreditScore: cannot set the same pause operator\\\"\\n        );\\n\\n        pauseOperator = _pauseOperator;\\n        emit PauseOperatorUpdated(pauseOperator);\\n    }\\n\\n    /**\\n     * @dev Sets the document ID of the IPFS document containing the current Merkle Tree.\\n     */\\n    function setDocumentId(\\n        string memory _documentId\\n    )\\n        public\\n        onlyAdmin\\n    {\\n        documentId = _documentId;\\n\\n        emit DocumentIdUpdated(documentId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Adminable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport { Storage } from \\\"./Storage.sol\\\";\\n\\n/**\\n * @title Adminable\\n * @author dYdX\\n *\\n * @dev EIP-1967 Proxy Admin contract.\\n */\\ncontract Adminable {\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     *  This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    bytes32 internal constant ADMIN_SLOT =\\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n    * @dev Modifier to check whether the `msg.sender` is the admin.\\n    *  If it is, it will run the function. Otherwise, it will revert.\\n    */\\n    modifier onlyAdmin() {\\n        require(\\n            msg.sender == getAdmin(),\\n            \\\"Adminable: caller is not admin\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @return The EIP-1967 proxy admin\\n     */\\n    function getAdmin()\\n        public\\n        view\\n        returns (address)\\n    {\\n        return address(uint160(uint256(Storage.load(ADMIN_SLOT))));\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/SafeMath.sol\": {\r\n      \"content\": \"\\npragma solidity ^0.5.16;\\n\\nlibrary SafeMath {\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        uint256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/debt/sapphire/SapphireTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nlibrary SapphireTypes {\\n\\n    struct ScoreProof {\\n        address account;\\n        uint256 score;\\n        bytes32[] merkleProof;\\n    }\\n\\n    struct CreditScore {\\n        uint256 score;\\n        uint256 lastUpdated;\\n    }\\n\\n    struct Vault {\\n        uint256 collateralAmount;\\n        uint256 borrowedAmount;\\n    }\\n\\n    enum Operation {\\n        Deposit,\\n        Withdraw,\\n        Borrow,\\n        Repay,\\n        Liquidate\\n    }\\n\\n    struct Action {\\n        uint256 amount;\\n        Operation operation;\\n        address userToLiquidate;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/debt/sapphire/ISapphireCreditScore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {SapphireTypes} from \\\"./SapphireTypes.sol\\\";\\n\\ninterface ISapphireCreditScore {\\n    function updateMerkleRoot(bytes32 newRoot) external;\\n\\n    function setMerkleRootUpdater(address merkleRootUpdater) external;\\n\\n    function verifyAndUpdate(SapphireTypes.ScoreProof calldata proof) external returns (uint256, uint16);\\n\\n    function getLastScore(address user) external view returns (uint256, uint16, uint256);\\n\\n    function setMerkleRootDelay(uint256 delay) external;\\n\\n    function setPause(bool status) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nlibrary Storage {\\n\\n    /**\\n     * @dev Performs an SLOAD and returns the data in the slot.\\n     */\\n    function load(\\n        bytes32 slot\\n    )\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        bytes32 result;\\n        /* solium-disable-next-line security/no-inline-assembly */\\n        assembly {\\n            result := sload(slot)\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Performs an SSTORE to save the value to the slot.\\n     */\\n    function store(\\n        bytes32 slot,\\n        bytes32 value\\n    )\\n        internal\\n    {\\n        /* solium-disable-next-line security/no-inline-assembly */\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastUpdated\",\"type\":\"uint256\"}],\"name\":\"CreditScoreUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DelayDurationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newDocumentId\",\"type\":\"string\"}],\"name\":\"DocumentIdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"name\":\"MerkleRootUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"merkleRootUpdater\",\"type\":\"address\"}],\"name\":\"MerkleRootUpdaterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pauseOperator\",\"type\":\"address\"}],\"name\":\"PauseOperatorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"PauseStatusUpdated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"documentId\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getLastScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_merkleRootUpdater\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pauseOperator\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_maxScore\",\"type\":\"uint16\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastMerkleRootUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxScore\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"merkleRootDelayDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"merkleRootUpdater\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pauseOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_documentId\",\"type\":\"string\"}],\"name\":\"setDocumentId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delay\",\"type\":\"uint256\"}],\"name\":\"setMerkleRootDelay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_merkleRootUpdater\",\"type\":\"address\"}],\"name\":\"setMerkleRootUpdater\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pauseOperator\",\"type\":\"address\"}],\"name\":\"setPauseOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upcomingMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_newRoot\",\"type\":\"bytes32\"}],\"name\":\"updateMerkleRoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userScores\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdated\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct SapphireTypes.ScoreProof\",\"name\":\"_proof\",\"type\":\"tuple\"}],\"name\":\"verifyAndUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"SapphireCreditScore","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}