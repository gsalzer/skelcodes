{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/@1001-digital/erc721-extensions/contracts/RandomlyAssignedUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./WithLimitedSupplyUpgradeable.sol\\\";\\nimport \\\"./IRandomlyAssignedUpgradeable.sol\\\";\\nimport \\\"../../../openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\\\";\\n\\n/// @author 1001.digital\\n/// @title Randomly assign tokenIDs from a given set of tokens.\\ncontract RandomlyAssignedUpgradeable is\\n    WithLimitedSupplyUpgradeable,\\n    IRandomlyAssignedUpgradeable,\\n    OwnableUpgradeable\\n{\\n    // Used for random index assignment\\n    mapping(uint256 => uint256) private tokenMatrix;\\n\\n    // The initial token ID\\n    uint256 private startFrom;\\n\\n    // The lastTokenId\\n    uint256 public lastTokenId;\\n\\n    function initialize(uint256 _maxSupply, uint256 _startFrom)\\n        public\\n        initializer\\n    {\\n        __RandomlyAssigned_init(_maxSupply, _startFrom);\\n    }\\n\\n    // @param _maxSupply how many tokens this collection should hold\\n    // @param _startFrom the tokenID with which to start counting\\n    function __RandomlyAssigned_init(uint256 _maxSupply, uint256 _startFrom)\\n        internal\\n        initializer\\n    {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n        __WithLimitedSupply_init_unchained(_maxSupply);\\n        __RandomlyAssigned_init_unchain(_startFrom);\\n    }\\n\\n    function __RandomlyAssigned_init_unchain(uint256 _startFrom)\\n        internal\\n        initializer\\n    {\\n        startFrom = _startFrom;\\n    }\\n\\n    /// Get the next token ID\\n    /// @dev Randomly gets a new token ID and keeps track of the ones that are still available.\\n    /// @return the next token ID\\n    function _nextToken()\\n        internal\\n        override\\n        ensureAvailability\\n        returns (uint256)\\n    {\\n        uint256 maxIndex = maxSupply() - tokenCount();\\n        uint256 random = uint256(\\n            keccak256(\\n                abi.encodePacked(\\n                    msg.sender,\\n                    block.coinbase,\\n                    block.difficulty,\\n                    block.gaslimit,\\n                    block.timestamp\\n                )\\n            )\\n        ) % maxIndex;\\n\\n        uint256 value = 0;\\n        if (tokenMatrix[random] == 0) {\\n            // If this matrix position is empty, set the value to the generated random number.\\n            value = random;\\n        } else {\\n            // Otherwise, use the previously stored number from the matrix.\\n            value = tokenMatrix[random];\\n        }\\n\\n        // If the last available tokenID is still unused...\\n        if (tokenMatrix[maxIndex - 1] == 0) {\\n            // ...store that ID in the current matrix position.\\n            tokenMatrix[random] = maxIndex - 1;\\n        } else {\\n            // ...otherwise copy over the stored number to the current matrix position.\\n            tokenMatrix[random] = tokenMatrix[maxIndex - 1];\\n        }\\n\\n        // Increment counts\\n        super._nextToken();\\n\\n        return value + startFrom;\\n    }\\n\\n    function nextTokenId() public override onlyOwner returns (uint256) {\\n        uint256 tokenId = _nextToken();\\n        lastTokenId = tokenId;\\n        emit TokenIdCreated(tokenId);\\n        return tokenId;\\n    }\\n\\n    function getMaxSupply() public view override returns (uint256) {\\n        return maxSupply();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/@1001-digital/erc721-extensions/contracts/WithLimitedSupplyUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../../openzeppelin-contracts-upgradeable/contracts/utils/CountersUpgradeable.sol\\\";\\nimport \\\"../../../openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\\\";\\n\\n/// @author 1001.digital\\n/// @title A token tracker that limits the token supply and increments token IDs on each new mint.\\nabstract contract WithLimitedSupplyUpgradeable is Initializable {\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n\\n    // Keeps track of how many we have minted\\n    CountersUpgradeable.Counter private _tokenCount;\\n\\n    /// @dev The maximum count of tokens this token tracker will hold.\\n    uint256 private _maxSupply;\\n\\n    // @param maxSupply_ how many tokens this collection should hold\\n    function __WithLimitedSupply_init(uint256 maxSupply_) internal initializer {\\n        __WithLimitedSupply_init_unchained(maxSupply_);\\n    }\\n\\n    function __WithLimitedSupply_init_unchained(uint256 maxSupply_)\\n        internal\\n        initializer\\n    {\\n        _maxSupply = maxSupply_;\\n    }\\n\\n    /// @dev Get the max Supply\\n    /// @return the maximum token count\\n    function maxSupply() internal view returns (uint256) {\\n        return _maxSupply;\\n    }\\n\\n    /// @dev Get the current token count\\n    /// @return the created token count\\n    function tokenCount() public view returns (uint256) {\\n        return _tokenCount.current();\\n    }\\n\\n    /// @dev Check whether tokens are still available\\n    /// @return the available token count\\n    function availableTokenCount() public view returns (uint256) {\\n        return _maxSupply - tokenCount();\\n    }\\n\\n    /// @dev Increment the token count and fetch the latest count\\n    /// @return the next token id\\n    function _nextToken()\\n        internal\\n        virtual\\n        ensureAvailability\\n        returns (uint256)\\n    {\\n        uint256 token = _tokenCount.current();\\n\\n        _tokenCount.increment();\\n\\n        return token;\\n    }\\n\\n    /// @dev Check whether another token is still available\\n    modifier ensureAvailability() {\\n        require(availableTokenCount() > 0, \\\"No more tokens available\\\");\\n        _;\\n    }\\n\\n    /// @param amount Check whether number of tokens are still available\\n    /// @dev Check whether tokens are still available\\n    modifier ensureAvailabilityFor(uint256 amount) {\\n        require(\\n            availableTokenCount() >= amount,\\n            \\\"Requested number of tokens not available\\\"\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/@1001-digital/erc721-extensions/contracts/IRandomlyAssignedUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IRandomlyAssignedUpgradeable {\\n    function nextTokenId() external returns (uint256 tokenId);\\n\\n    function getMaxSupply() external returns (uint256 maxSupply);\\n\\n    event TokenIdCreated(uint256 indexed tokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-contracts-upgradeable/contracts/utils/CountersUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary CountersUpgradeable {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(\\n            _initializing || !_initialized,\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {}\\n\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 150\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TokenIdCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"availableTokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startFrom\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RandomlyAssignedUpgradeable","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"150","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}