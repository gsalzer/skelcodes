{"status":"1","message":"OK","result":[{"SourceCode":"{\"CryptopunksData.sol\":{\"content\":\"/**\\n *Submitted for verification at Etherscan.io on 2021-08-18\\n */\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n *   ____                  _                          _          ____        _\\n *  / ___|_ __ _   _ _ __ | |_ ___  _ __  _   _ _ __ | | _____  |  _ \\\\  __ _| |_ __ _\\n * | |   | \\u0027__| | | | \\u0027_ \\\\| __/ _ \\\\| \\u0027_ \\\\| | | | \\u0027_ \\\\| |/ / __| | | | |/ _` | __/ _` |\\n * | |___| |  | |_| | |_) | || (_) | |_) | |_| | | | |   \\u003c\\\\__ \\\\ | |_| | (_| | || (_| |\\n *  \\\\____|_|   \\\\__, | .__/ \\\\__\\\\___/| .__/ \\\\__,_|_| |_|_|\\\\_\\\\___/ |____/ \\\\__,_|\\\\__\\\\__,_|\\n *             |___/|_|            |_|\\n *\\n * On-chain Cryptopunk images and attributes, by Larva Labs.\\n *\\n * This contract holds the image and attribute data for the Cryptopunks on-chain.\\n * The Cryptopunk images are available as raw RGBA pixels, or in SVG format.\\n * The punk attributes are available as a comma-separated list.\\n * Included in the attribute list is the head type (various color male and female heads,\\n * plus the rare zombie, ape, and alien types).\\n *\\n * This contract was motivated by community members snowfro and 0xdeafbeef, including a proof-of-concept contract created by 0xdeafbeef.\\n * Without their involvement, the project would not have come to fruition.\\n */\\ncontract CryptopunksData {\\n    string internal constant SVG_HEADER =\\n        \\u0027data:image/svg+xml;utf8,\\u003csvg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.2\\\" viewBox=\\\"0 0 24 24\\\"\\u003e\\u0027;\\n    string internal constant SVG_FOOTER = \\\"\\u003c/svg\\u003e\\\";\\n\\n    bytes private palette;\\n    mapping(uint8 =\\u003e bytes) private assets;\\n    mapping(uint8 =\\u003e string) private assetNames;\\n    mapping(uint64 =\\u003e uint32) private composites;\\n    mapping(uint8 =\\u003e bytes) private punks;\\n\\n    address internal deployer;\\n    bool private contractSealed = false;\\n\\n    modifier onlyDeployer() {\\n        require(msg.sender == deployer, \\\"Only deployer.\\\");\\n        _;\\n    }\\n\\n    modifier unsealed() {\\n        require(!contractSealed, \\\"Contract sealed.\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        deployer = msg.sender;\\n    }\\n\\n    function setPalette(bytes memory _palette) external onlyDeployer unsealed {\\n        palette = _palette;\\n    }\\n\\n    function addAsset(\\n        uint8 index,\\n        bytes memory encoding,\\n        string memory name\\n    ) external onlyDeployer unsealed {\\n        assets[index] = encoding;\\n        assetNames[index] = name;\\n    }\\n\\n    function addComposites(\\n        uint64 key1,\\n        uint32 value1,\\n        uint64 key2,\\n        uint32 value2,\\n        uint64 key3,\\n        uint32 value3,\\n        uint64 key4,\\n        uint32 value4\\n    ) external onlyDeployer unsealed {\\n        composites[key1] = value1;\\n        composites[key2] = value2;\\n        composites[key3] = value3;\\n        composites[key4] = value4;\\n    }\\n\\n    function addPunks(uint8 index, bytes memory _punks)\\n        external\\n        onlyDeployer\\n        unsealed\\n    {\\n        punks[index] = _punks;\\n    }\\n\\n    function sealContract() external onlyDeployer unsealed {\\n        contractSealed = true;\\n    }\\n\\n    /**\\n     * The Cryptopunk image for the given index.\\n     * The image is represented in a row-major byte array where each set of 4 bytes is a pixel in RGBA format.\\n     * @param index the punk index, 0 \\u003c= index \\u003c 10000\\n     */\\n    function punkImage(uint16 index) public view returns (bytes memory) {\\n        require(index \\u003e= 0 \\u0026\\u0026 index \\u003c 10000);\\n        bytes memory pixels = new bytes(2304);\\n        for (uint256 j = 0; j \\u003c 8; j++) {\\n            uint8 asset = uint8(\\n                punks[uint8(index / 100)][(index % 100) * 8 + j]\\n            );\\n            if (asset \\u003e 0) {\\n                bytes storage a = assets[asset];\\n                uint256 n = a.length / 3;\\n                for (uint256 i = 0; i \\u003c n; i++) {\\n                    uint256[4] memory v = [\\n                        uint256(uint8(a[i * 3]) \\u0026 0xF0) \\u003e\\u003e 4,\\n                        uint256(uint8(a[i * 3]) \\u0026 0xF),\\n                        uint256(uint8(a[i * 3 + 2]) \\u0026 0xF0) \\u003e\\u003e 4,\\n                        uint256(uint8(a[i * 3 + 2]) \\u0026 0xF)\\n                    ];\\n                    for (uint256 dx = 0; dx \\u003c 2; dx++) {\\n                        for (uint256 dy = 0; dy \\u003c 2; dy++) {\\n                            uint256 p = ((2 * v[1] + dy) *\\n                                24 +\\n                                (2 * v[0] + dx)) * 4;\\n                            if (v[2] \\u0026 (1 \\u003c\\u003c (dx * 2 + dy)) != 0) {\\n                                bytes4 c = composite(\\n                                    a[i * 3 + 1],\\n                                    pixels[p],\\n                                    pixels[p + 1],\\n                                    pixels[p + 2],\\n                                    pixels[p + 3]\\n                                );\\n                                pixels[p] = c[0];\\n                                pixels[p + 1] = c[1];\\n                                pixels[p + 2] = c[2];\\n                                pixels[p + 3] = c[3];\\n                            } else if (v[3] \\u0026 (1 \\u003c\\u003c (dx * 2 + dy)) != 0) {\\n                                pixels[p] = 0;\\n                                pixels[p + 1] = 0;\\n                                pixels[p + 2] = 0;\\n                                pixels[p + 3] = 0xFF;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return pixels;\\n    }\\n\\n    /**\\n     * The Cryptopunk image for the given index, in SVG format.\\n     * In the SVG, each \\\"pixel\\\" is represented as a 1x1 rectangle.\\n     * @param index the punk index, 0 \\u003c= index \\u003c 10000\\n     */\\n    function punkImageSvg(uint16 index)\\n        external\\n        view\\n        returns (string memory svg)\\n    {\\n        bytes memory pixels = punkImage(index);\\n        svg = string(abi.encodePacked(SVG_HEADER));\\n        bytes memory buffer = new bytes(8);\\n        for (uint256 y = 0; y \\u003c 24; y++) {\\n            for (uint256 x = 0; x \\u003c 24; x++) {\\n                uint256 p = (y * 24 + x) * 4;\\n                if (uint8(pixels[p + 3]) \\u003e 0) {\\n                    for (uint256 i = 0; i \\u003c 4; i++) {\\n                        uint8 value = uint8(pixels[p + i]);\\n                        buffer[i * 2 + 1] = _HEX_SYMBOLS[value \\u0026 0xf];\\n                        value \\u003e\\u003e= 4;\\n                        buffer[i * 2] = _HEX_SYMBOLS[value \\u0026 0xf];\\n                    }\\n                    svg = string(\\n                        abi.encodePacked(\\n                            svg,\\n                            \\u0027\\u003crect x=\\\"\\u0027,\\n                            toString(x),\\n                            \\u0027\\\" y=\\\"\\u0027,\\n                            toString(y),\\n                            \\u0027\\\" width=\\\"1\\\" height=\\\"1\\\" shape-rendering=\\\"crispEdges\\\" fill=\\\"#\\u0027,\\n                            string(buffer),\\n                            \\u0027\\\"/\\u003e\\u0027\\n                        )\\n                    );\\n                }\\n            }\\n        }\\n        svg = string(abi.encodePacked(svg, SVG_FOOTER));\\n    }\\n\\n    /**\\n     * The Cryptopunk attributes for the given index.\\n     * The attributes are a comma-separated list in UTF-8 string format.\\n     * The first entry listed is not technically an attribute, but the \\\"head type\\\" of the Cryptopunk.\\n     * @param index the punk index, 0 \\u003c= index \\u003c 10000\\n     */\\n    function punkAttributes(uint16 index)\\n        external\\n        view\\n        returns (string memory text)\\n    {\\n        require(index \\u003e= 0 \\u0026\\u0026 index \\u003c 10000);\\n        uint8 cell = uint8(index / 100);\\n        uint256 offset = (index % 100) * 8;\\n        for (uint256 j = 0; j \\u003c 8; j++) {\\n            uint8 asset = uint8(punks[cell][offset + j]);\\n            if (asset \\u003e 0) {\\n                if (j \\u003e 0) {\\n                    text = string(\\n                        abi.encodePacked(text, \\\", \\\", assetNames[asset])\\n                    );\\n                } else {\\n                    text = assetNames[asset];\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    function composite(\\n        bytes1 index,\\n        bytes1 yr,\\n        bytes1 yg,\\n        bytes1 yb,\\n        bytes1 ya\\n    ) internal view returns (bytes4 rgba) {\\n        uint256 x = uint256(uint8(index)) * 4;\\n        uint8 xAlpha = uint8(palette[x + 3]);\\n        if (xAlpha == 0xFF) {\\n            rgba = bytes4(\\n                uint32(\\n                    (uint256(uint8(palette[x])) \\u003c\\u003c 24) |\\n                        (uint256(uint8(palette[x + 1])) \\u003c\\u003c 16) |\\n                        (uint256(uint8(palette[x + 2])) \\u003c\\u003c 8) |\\n                        xAlpha\\n                )\\n            );\\n        } else {\\n            uint64 key = (uint64(uint8(palette[x])) \\u003c\\u003c 56) |\\n                (uint64(uint8(palette[x + 1])) \\u003c\\u003c 48) |\\n                (uint64(uint8(palette[x + 2])) \\u003c\\u003c 40) |\\n                (uint64(xAlpha) \\u003c\\u003c 32) |\\n                (uint64(uint8(yr)) \\u003c\\u003c 24) |\\n                (uint64(uint8(yg)) \\u003c\\u003c 16) |\\n                (uint64(uint8(yb)) \\u003c\\u003c 8) |\\n                (uint64(uint8(ya)));\\n            rgba = bytes4(composites[key]);\\n        }\\n    }\\n\\n    //// String stuff from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\\n\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"},\"PublicCryptopunksData.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\nimport \\\"./CryptopunksData.sol\\\";\\n\\n/**\\n * Public\\n *   ____                  _                          _          ____        _\\n *  / ___|_ __ _   _ _ __ | |_ ___  _ __  _   _ _ __ | | _____  |  _ \\\\  __ _| |_ __ _\\n * | |   | \\u0027__| | | | \\u0027_ \\\\| __/ _ \\\\| \\u0027_ \\\\| | | | \\u0027_ \\\\| |/ / __| | | | |/ _` | __/ _` |\\n * | |___| |  | |_| | |_) | || (_) | |_) | |_| | | | |   \\u003c\\\\__ \\\\ | |_| | (_| | || (_| |\\n *  \\\\____|_|   \\\\__, | .__/ \\\\__\\\\___/| .__/ \\\\__,_|_| |_|_|\\\\_\\\\___/ |____/ \\\\__,_|\\\\__\\\\__,_|\\n *             |___/|_|            |_|\\n *\\n * On-chain Public Cryptopunk assets.\\n *\\n * This contract holds the public asset data for the Cryptopunks on-chain.\\n */\\ncontract PublicCryptopunksData {\\n    string public constant SVG_HEADER =\\n        \\u0027data:image/svg+xml;utf8,\\u003csvg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.2\\\" viewBox=\\\"0 0 24 24\\\"\\u003e\\u0027;\\n    string public constant SVG_FOOTER = \\\"\\u003c/svg\\u003e\\\";\\n\\n    CryptopunksData public cryptopunksData;\\n    bytes public palette;\\n    mapping(uint8 =\\u003e bytes) public assets;\\n    mapping(uint8 =\\u003e string) public assetNames;\\n    mapping(uint64 =\\u003e uint32) public composites;\\n\\n    address internal deployer;\\n    bool private contractSealed = false;\\n\\n    modifier onlyDeployer() {\\n        require(msg.sender == deployer, \\\"Only deployer.\\\");\\n        _;\\n    }\\n\\n    modifier unsealed() {\\n        require(!contractSealed, \\\"Contract sealed.\\\");\\n        _;\\n    }\\n\\n    constructor(CryptopunksData _cryptopunksData) {\\n        deployer = msg.sender;\\n        cryptopunksData = _cryptopunksData;\\n    }\\n\\n    function setPalette(bytes memory _palette) external onlyDeployer unsealed {\\n        palette = _palette;\\n    }\\n\\n    function addAsset(\\n        uint8 index,\\n        bytes memory encoding,\\n        string memory name\\n    ) external onlyDeployer unsealed {\\n        assets[index] = encoding;\\n        assetNames[index] = name;\\n    }\\n\\n    function addComposites(\\n        uint64 key1,\\n        uint32 value1,\\n        uint64 key2,\\n        uint32 value2,\\n        uint64 key3,\\n        uint32 value3,\\n        uint64 key4,\\n        uint32 value4\\n    ) external onlyDeployer unsealed {\\n        composites[key1] = value1;\\n        composites[key2] = value2;\\n        composites[key3] = value3;\\n        composites[key4] = value4;\\n    }\\n\\n    function sealContract() external onlyDeployer unsealed {\\n        contractSealed = true;\\n    }\\n\\n    function composite(\\n        bytes1 index,\\n        bytes1 yr,\\n        bytes1 yg,\\n        bytes1 yb,\\n        bytes1 ya\\n    ) internal view returns (bytes4 rgba) {\\n        uint256 x = uint256(uint8(index)) * 4;\\n        uint8 xAlpha = uint8(palette[x + 3]);\\n        if (xAlpha == 0xFF) {\\n            rgba = bytes4(\\n                uint32(\\n                    (uint256(uint8(palette[x])) \\u003c\\u003c 24) |\\n                        (uint256(uint8(palette[x + 1])) \\u003c\\u003c 16) |\\n                        (uint256(uint8(palette[x + 2])) \\u003c\\u003c 8) |\\n                        xAlpha\\n                )\\n            );\\n        } else {\\n            uint64 key = (uint64(uint8(palette[x])) \\u003c\\u003c 56) |\\n                (uint64(uint8(palette[x + 1])) \\u003c\\u003c 48) |\\n                (uint64(uint8(palette[x + 2])) \\u003c\\u003c 40) |\\n                (uint64(xAlpha) \\u003c\\u003c 32) |\\n                (uint64(uint8(yr)) \\u003c\\u003c 24) |\\n                (uint64(uint8(yg)) \\u003c\\u003c 16) |\\n                (uint64(uint8(yb)) \\u003c\\u003c 8) |\\n                (uint64(uint8(ya)));\\n            rgba = bytes4(composites[key]);\\n        }\\n    }\\n\\n    function packAssets(uint8[12] calldata assetsArr)\\n        external\\n        pure\\n        returns (uint96)\\n    {\\n        uint96 ret = 0;\\n\\n        for (uint8 i = 0; i \\u003c 12; i++) {\\n            ret = ret | (uint96(assetsArr[i]) \\u003c\\u003c (8 * (11 - i)));\\n        }\\n\\n        return ret;\\n    }\\n\\n    function render(uint96 packed) public view returns (bytes memory) {\\n        uint256 mask = 0xff \\u003c\\u003c 88;\\n        bytes memory pixels = new bytes(2304);\\n        for (uint8 j = 0; j \\u003c 12; j++) {\\n            uint8 assetIndex = uint8(\\n                (packed \\u0026 (mask \\u003e\\u003e (j * 8))) \\u003e\\u003e (8 * (11 - j))\\n            );\\n            if (assetIndex \\u003e 0) {\\n                bytes storage a = assets[assetIndex];\\n                uint256 n = a.length / 3;\\n                for (uint256 i = 0; i \\u003c n; i++) {\\n                    uint256[4] memory v = [\\n                        uint256(uint8(a[i * 3]) \\u0026 0xF0) \\u003e\\u003e 4,\\n                        uint256(uint8(a[i * 3]) \\u0026 0xF),\\n                        uint256(uint8(a[i * 3 + 2]) \\u0026 0xF0) \\u003e\\u003e 4,\\n                        uint256(uint8(a[i * 3 + 2]) \\u0026 0xF)\\n                    ];\\n                    for (uint256 dx = 0; dx \\u003c 2; dx++) {\\n                        for (uint256 dy = 0; dy \\u003c 2; dy++) {\\n                            uint256 p = ((2 * v[1] + dy) *\\n                                24 +\\n                                (2 * v[0] + dx)) * 4;\\n                            if (v[2] \\u0026 (1 \\u003c\\u003c (dx * 2 + dy)) != 0) {\\n                                bytes4 c = composite(\\n                                    a[i * 3 + 1],\\n                                    pixels[p],\\n                                    pixels[p + 1],\\n                                    pixels[p + 2],\\n                                    pixels[p + 3]\\n                                );\\n                                pixels[p] = c[0];\\n                                pixels[p + 1] = c[1];\\n                                pixels[p + 2] = c[2];\\n                                pixels[p + 3] = c[3];\\n                            } else if (v[3] \\u0026 (1 \\u003c\\u003c (dx * 2 + dy)) != 0) {\\n                                pixels[p] = 0;\\n                                pixels[p + 1] = 0;\\n                                pixels[p + 2] = 0;\\n                                pixels[p + 3] = 0xFF;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return pixels;\\n    }\\n\\n    function renderSvg(uint96 packed)\\n        external\\n        view\\n        returns (string memory svg)\\n    {\\n        bytes memory pixels = render(packed);\\n        svg = string(abi.encodePacked(SVG_HEADER));\\n        bytes memory buffer = new bytes(8);\\n        for (uint256 y = 0; y \\u003c 24; y++) {\\n            for (uint256 x = 0; x \\u003c 24; x++) {\\n                uint256 p = (y * 24 + x) * 4;\\n                if (uint8(pixels[p + 3]) \\u003e 0) {\\n                    for (uint256 i = 0; i \\u003c 4; i++) {\\n                        uint8 value = uint8(pixels[p + i]);\\n                        buffer[i * 2 + 1] = _HEX_SYMBOLS[value \\u0026 0xf];\\n                        value \\u003e\\u003e= 4;\\n                        buffer[i * 2] = _HEX_SYMBOLS[value \\u0026 0xf];\\n                    }\\n                    svg = string(\\n                        abi.encodePacked(\\n                            svg,\\n                            \\u0027\\u003crect x=\\\"\\u0027,\\n                            toString(x),\\n                            \\u0027\\\" y=\\\"\\u0027,\\n                            toString(y),\\n                            \\u0027\\\" width=\\\"1\\\" height=\\\"1\\\" shape-rendering=\\\"crispEdges\\\" fill=\\\"#\\u0027,\\n                            string(buffer),\\n                            \\u0027\\\"/\\u003e\\u0027\\n                        )\\n                    );\\n                }\\n            }\\n        }\\n        svg = string(abi.encodePacked(svg, SVG_FOOTER));\\n    }\\n\\n    function getPackedAssetNames(uint96 packed)\\n        external\\n        view\\n        returns (string memory text)\\n    {\\n        uint96 mask = 0xff \\u003c\\u003c 88;\\n        for (uint8 j = 0; j \\u003c 12; j++) {\\n            uint8 asset = uint8((packed \\u0026 (mask \\u003e\\u003e (j * 8))) \\u003e\\u003e (8 * (11 - j)));\\n            if (asset \\u003e 0) {\\n                if (j \\u003e 0) {\\n                    text = string(\\n                        abi.encodePacked(text, \\\", \\\", assetNames[asset])\\n                    );\\n                } else {\\n                    text = assetNames[asset];\\n                }\\n            }\\n        }\\n    }\\n\\n    function isPackedEqualToOriginalPunkIndex(uint96 packed, uint16 punkIndex)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        string memory packedAssetNames = this.getPackedAssetNames(packed);\\n        string memory punkAssetNames = cryptopunksData.punkAttributes(\\n            punkIndex\\n        );\\n\\n        return\\n            keccak256(bytes(packedAssetNames)) ==\\n            keccak256(bytes(punkAssetNames));\\n    }\\n\\n    //// String stuff from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\\n\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract CryptopunksData\",\"name\":\"_cryptopunksData\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"SVG_FOOTER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SVG_HEADER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"encoding\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"addAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"key1\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"value1\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"key2\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"value2\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"key3\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"value3\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"key4\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"value4\",\"type\":\"uint32\"}],\"name\":\"addComposites\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"assetNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"assets\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"composites\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cryptopunksData\",\"outputs\":[{\"internalType\":\"contract CryptopunksData\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"packed\",\"type\":\"uint96\"}],\"name\":\"getPackedAssetNames\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"text\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"packed\",\"type\":\"uint96\"},{\"internalType\":\"uint16\",\"name\":\"punkIndex\",\"type\":\"uint16\"}],\"name\":\"isPackedEqualToOriginalPunkIndex\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[12]\",\"name\":\"assetsArr\",\"type\":\"uint8[12]\"}],\"name\":\"packAssets\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"palette\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"packed\",\"type\":\"uint96\"}],\"name\":\"render\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"packed\",\"type\":\"uint96\"}],\"name\":\"renderSvg\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"svg\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sealContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_palette\",\"type\":\"bytes\"}],\"name\":\"setPalette\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PublicCryptopunksData","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"00000000000000000000000016f5a35647d6f03d5d3da7b35409d65ba03af3b2","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5611e5d18451215f73c42f004fb2796d1a8b4b20235e28b7ca28af43f6952228"}]}