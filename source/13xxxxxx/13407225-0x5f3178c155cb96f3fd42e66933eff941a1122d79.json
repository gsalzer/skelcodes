{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/SafeMath.sol\r\n\r\n/*\r\n\r\n    Copyright 2020 DODO ZOO.\r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MUL_ERROR\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"DIVIDING_ERROR\");\r\n        return a / b;\r\n    }\r\n\r\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 quotient = div(a, b);\r\n        uint256 remainder = a - quotient * b;\r\n        if (remainder > 0) {\r\n            return quotient + 1;\r\n        } else {\r\n            return quotient;\r\n        }\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SUB_ERROR\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = x / 2 + 1;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/NFTPool/intf/IFilterAdmin.sol\r\n\r\n\r\ninterface IFilterAdmin {\r\n    function _OWNER_() external view returns (address);\r\n\r\n    function _CONTROLLER_() external view returns (address);\r\n\r\n    function init(\r\n        address owner,\r\n        uint256 initSupply,\r\n        string memory name,\r\n        string memory symbol,\r\n        uint256 feeRate,\r\n        address controller,\r\n        address maintainer,\r\n        address[] memory filters\r\n    ) external;\r\n\r\n    function mintFragTo(address to, uint256 rawAmount) external returns (uint256 received);\r\n\r\n    function burnFragFrom(address from, uint256 rawAmount) external returns (uint256 paid);\r\n\r\n    function queryMintFee(uint256 rawAmount)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 poolFee,\r\n            uint256 mtFee,\r\n            uint256 afterChargedAmount\r\n        );\r\n\r\n    function queryBurnFee(uint256 rawAmount)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 poolFee,\r\n            uint256 mtFee,\r\n            uint256 afterChargedAmount\r\n        );\r\n}\r\n\r\n// File: contracts/NFTPool/intf/IController.sol\r\n\r\n\r\ninterface IController {\r\n    function getMintFeeRate(address filterAdminAddr) external view returns (uint256);\r\n\r\n    function getBurnFeeRate(address filterAdminAddr) external view returns (uint256);\r\n\r\n    function isEmergencyWithdrawOpen(address filter) external view returns (bool);\r\n}\r\n\r\n// File: contracts/intf/IERC165.sol\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: contracts/intf/IERC721.sol\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: contracts/intf/IERC721Receiver.sol\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: contracts/lib/DecimalMath.sol\r\n\r\n\r\n/**\r\n * @title DecimalMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Functions for fixed point number with 18 decimals\r\n */\r\nlibrary DecimalMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant ONE = 10**18;\r\n    uint256 internal constant ONE2 = 10**36;\r\n\r\n    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d) / (10**18);\r\n    }\r\n\r\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d).divCeil(10**18);\r\n    }\r\n\r\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).div(d);\r\n    }\r\n\r\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).divCeil(d);\r\n    }\r\n\r\n    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).div(target);\r\n    }\r\n\r\n    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).divCeil(target);\r\n    }\r\n\r\n    function powFloor(uint256 target, uint256 e) internal pure returns (uint256) {\r\n        if (e == 0) {\r\n            return 10 ** 18;\r\n        } else if (e == 1) {\r\n            return target;\r\n        } else {\r\n            uint p = powFloor(target, e.div(2));\r\n            p = p.mul(p) / (10**18);\r\n            if (e % 2 == 1) {\r\n                p = p.mul(target) / (10**18);\r\n            }\r\n            return p;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/ReentrancyGuard.sol\r\n\r\n\r\n/**\r\n * @title ReentrancyGuard\r\n * @author DODO Breeder\r\n *\r\n * @notice Protect functions from Reentrancy Attack\r\n */\r\ncontract ReentrancyGuard {\r\n    // https://solidity.readthedocs.io/en/latest/control-structures.html?highlight=zero-state#scoping-and-declarations\r\n    // zero-state of _ENTERED_ is false\r\n    bool private _ENTERED_;\r\n\r\n    modifier preventReentrant() {\r\n        require(!_ENTERED_, \"REENTRANT\");\r\n        _ENTERED_ = true;\r\n        _;\r\n        _ENTERED_ = false;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/InitializableOwnable.sol\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @author DODO Breeder\r\n *\r\n * @notice Ownership related functions\r\n */\r\ncontract InitializableOwnable {\r\n    address public _OWNER_;\r\n    address public _NEW_OWNER_;\r\n    bool internal _INITIALIZED_;\r\n\r\n    // ============ Events ============\r\n\r\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    // ============ Modifiers ============\r\n\r\n    modifier notInitialized() {\r\n        require(!_INITIALIZED_, \"DODO_INITIALIZED\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    // ============ Functions ============\r\n\r\n    function initOwner(address newOwner) public notInitialized {\r\n        _INITIALIZED_ = true;\r\n        _OWNER_ = newOwner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\r\n        _NEW_OWNER_ = newOwner;\r\n    }\r\n\r\n    function claimOwnership() public {\r\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\r\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\r\n        _OWNER_ = _NEW_OWNER_;\r\n        _NEW_OWNER_ = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/NFTPool/impl/BaseFilterV1.sol\r\n\r\n\r\ncontract BaseFilterV1 is InitializableOwnable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n\r\n    //=================== Event ===================\r\n    event NftInOrder(address user, uint256 receiveAmount);\r\n    event TargetOutOrder(address user, uint256 paidAmount);\r\n    event RandomOutOrder(address user, uint256 paidAmount);\r\n\r\n    event ChangeNFTInPrice(uint256 newGsStart, uint256 newCr, bool toggleFlag);\r\n    event ChangeNFTRandomOutPrice(uint256 newGsStart, uint256 newCr, bool toggleFlag);\r\n    event ChangeNFTTargetOutPrice(uint256 newGsStart, uint256 newCr, bool toggleFlag);\r\n    event ChangeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount);\r\n    event ChangeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd);\r\n    event ChangeTokenIdMap(uint256 tokenIds, bool isRegistered);\r\n    event ChangeFilterName(string newFilterName);\r\n\r\n    //=================== Storage ===================\r\n    string public _FILTER_NAME_;\r\n\r\n    address public _NFT_COLLECTION_;\r\n    uint256 public _NFT_ID_START_;\r\n    uint256 public _NFT_ID_END_ = uint256(-1);\r\n\r\n    //tokenId => isRegistered\r\n    mapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\r\n\r\n    //tokenId => amount\r\n    mapping(uint256 => uint256) public _NFT_RESERVE_;\r\n\r\n    uint256[] public _NFT_IDS_;\r\n    //tokenId => index + 1 of _NFT_IDS_\r\n    mapping(uint256 => uint256) public _TOKENID_IDX_;\r\n    uint256 public _TOTAL_NFT_AMOUNT_;\r\n    uint256 public _MAX_NFT_AMOUNT_;\r\n    uint256 public _MIN_NFT_AMOUNT_;\r\n\r\n    // GS -> Geometric sequence\r\n    // CR -> Common Ratio\r\n\r\n    //For Deposit NFT IN to Pool\r\n    uint256 public _GS_START_IN_;\r\n    uint256 public _CR_IN_;\r\n    bool public _NFT_IN_TOGGLE_ = false;\r\n\r\n    //For NFT Random OUT from Pool\r\n    uint256 public _GS_START_RANDOM_OUT_;\r\n    uint256 public _CR_RANDOM_OUT_;\r\n    bool public _NFT_RANDOM_OUT_TOGGLE_ = false;\r\n\r\n    //For NFT Target OUT from Pool\r\n    uint256 public _GS_START_TARGET_OUT_;\r\n    uint256 public _CR_TARGET_OUT_;\r\n    bool public _NFT_TARGET_OUT_TOGGLE_ = false;\r\n\r\n    modifier onlySuperOwner() {\r\n        require(msg.sender == IFilterAdmin(_OWNER_)._OWNER_(), \"ONLY_SUPER_OWNER\");\r\n        _;\r\n    }\r\n\r\n    //==================== Query Prop ==================\r\n\r\n    function isNFTValid(address nftCollectionAddress, uint256 nftId) external view returns (bool) {\r\n        if (nftCollectionAddress == _NFT_COLLECTION_) {\r\n            return isNFTIDValid(nftId);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function isNFTIDValid(uint256 nftId) public view returns (bool) {\r\n        return (nftId >= _NFT_ID_START_ && nftId <= _NFT_ID_END_) || _SPREAD_IDS_REGISTRY_[nftId];\r\n    }\r\n\r\n    function getAvaliableNFTInAmount() public view returns (uint256) {\r\n        if (_MAX_NFT_AMOUNT_ <= _TOTAL_NFT_AMOUNT_) {\r\n            return 0;\r\n        } else {\r\n            return _MAX_NFT_AMOUNT_ - _TOTAL_NFT_AMOUNT_;\r\n        }\r\n    }\r\n\r\n    function getAvaliableNFTOutAmount() public view returns (uint256) {\r\n        if (_TOTAL_NFT_AMOUNT_ <= _MIN_NFT_AMOUNT_) {\r\n            return 0;\r\n        } else {\r\n            return _TOTAL_NFT_AMOUNT_ - _MIN_NFT_AMOUNT_;\r\n        }\r\n    }\r\n\r\n    function getNFTIndexById(uint256 tokenId) public view returns (uint256) {\r\n        require(_TOKENID_IDX_[tokenId] > 0, \"TOKEN_ID_NOT_EXSIT\");\r\n        return _TOKENID_IDX_[tokenId] - 1;\r\n    }\r\n\r\n    //==================== Query Price ==================\r\n\r\n    function queryNFTIn(uint256 NFTInAmount)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 rawReceive, \r\n            uint256 received\r\n        )\r\n    {\r\n        require(NFTInAmount <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\r\n        (rawReceive, received) = _queryNFTIn(_TOTAL_NFT_AMOUNT_,_TOTAL_NFT_AMOUNT_ + NFTInAmount);\r\n    }\r\n\r\n    function _queryNFTIn(uint256 start, uint256 end) internal view returns(uint256 rawReceive, uint256 received) {\r\n        rawReceive = _geometricCalc(\r\n            _GS_START_IN_,\r\n            _CR_IN_,\r\n            start,\r\n            end\r\n        );\r\n        (,, received) = IFilterAdmin(_OWNER_).queryMintFee(rawReceive);\r\n    }\r\n\r\n    function queryNFTTargetOut(uint256 NFTOutAmount)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 rawPay, \r\n            uint256 pay\r\n        )\r\n    {\r\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\r\n        (rawPay, pay) = _queryNFTTargetOut(_TOTAL_NFT_AMOUNT_ - NFTOutAmount, _TOTAL_NFT_AMOUNT_);\r\n    }\r\n\r\n    function _queryNFTTargetOut(uint256 start, uint256 end) internal view returns(uint256 rawPay, uint256 pay) {\r\n        rawPay = _geometricCalc(\r\n            _GS_START_TARGET_OUT_,\r\n            _CR_TARGET_OUT_,\r\n            start,\r\n            end\r\n        );\r\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\r\n    }\r\n\r\n    function queryNFTRandomOut(uint256 NFTOutAmount)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 rawPay, \r\n            uint256 pay\r\n        )\r\n    {\r\n        require(NFTOutAmount <= getAvaliableNFTOutAmount(), \"EXCEED_OUT_AMOUNT\");\r\n        (rawPay, pay) = _queryNFTRandomOut(_TOTAL_NFT_AMOUNT_ - NFTOutAmount, _TOTAL_NFT_AMOUNT_);\r\n    }\r\n\r\n    function _queryNFTRandomOut(uint256 start, uint256 end) internal view returns(uint256 rawPay, uint256 pay) {\r\n        rawPay = _geometricCalc(\r\n            _GS_START_RANDOM_OUT_,\r\n            _CR_RANDOM_OUT_,\r\n            start,\r\n            end\r\n        );\r\n        (,, pay) = IFilterAdmin(_OWNER_).queryBurnFee(rawPay);\r\n    }\r\n\r\n    // ============ Math =============\r\n\r\n    function _geometricCalc(\r\n        uint256 a0,\r\n        uint256 q,\r\n        uint256 start,\r\n        uint256 end\r\n    ) internal view returns (uint256) {\r\n        if (q == DecimalMath.ONE) {\r\n            return end.sub(start).mul(a0);\r\n        } \r\n        //q^n\r\n        uint256 qn = DecimalMath.powFloor(q, end);\r\n        //q^m\r\n        uint256 qm = DecimalMath.powFloor(q, start);\r\n        if (q < DecimalMath.ONE) {\r\n            //Sn=a0*(1 - q^n)/(1-q)\r\n            //Sn-Sm = a0*(q^m - q^n)/(1-q)\r\n            return a0.mul(qm.sub(qn)).div(DecimalMath.ONE.sub(q));\r\n        } else {\r\n            //Sn=a0*(q^n - 1)/(q - 1)\r\n            //Sn-Sm = a0*(q^n - q^m)/(q-1)  \r\n            return a0.mul(qn.sub(qm)).div(q.sub(DecimalMath.ONE));\r\n        }\r\n    }\r\n\r\n    function _getRandomNum() public view returns (uint256 randomNum) {\r\n        randomNum = uint256(\r\n            keccak256(abi.encodePacked(tx.origin, blockhash(block.number - 1), gasleft()))\r\n        );\r\n    }\r\n\r\n    // ================= Ownable ================\r\n\r\n    function changeNFTInPrice(\r\n        uint256 newGsStart,\r\n        uint256 newCr,\r\n        bool toggleFlag\r\n    ) external onlySuperOwner {\r\n        _changeNFTInPrice(newGsStart, newCr, toggleFlag);\r\n    }\r\n\r\n    function _changeNFTInPrice(\r\n        uint256 newGsStart,\r\n        uint256 newCr,\r\n        bool toggleFlag\r\n    ) internal {\r\n        require(newCr != 0, \"CR_INVALID\");\r\n        _GS_START_IN_ = newGsStart;\r\n        _CR_IN_ = newCr;\r\n        _NFT_IN_TOGGLE_ = toggleFlag;\r\n\r\n        emit ChangeNFTInPrice(newGsStart, newCr, toggleFlag);\r\n    }\r\n\r\n    function changeNFTRandomOutPrice(\r\n        uint256 newGsStart,\r\n        uint256 newCr,\r\n        bool toggleFlag\r\n    ) external onlySuperOwner {\r\n        _changeNFTRandomOutPrice(newGsStart, newCr, toggleFlag);\r\n    }\r\n\r\n    function _changeNFTRandomOutPrice(\r\n        uint256 newGsStart,\r\n        uint256 newCr,\r\n        bool toggleFlag\r\n    ) internal {\r\n        require(newCr != 0, \"CR_INVALID\");\r\n        _GS_START_RANDOM_OUT_ = newGsStart;\r\n        _CR_RANDOM_OUT_ = newCr;\r\n        _NFT_RANDOM_OUT_TOGGLE_ = toggleFlag;\r\n\r\n        emit ChangeNFTRandomOutPrice(newGsStart, newCr, toggleFlag);\r\n    }\r\n\r\n    function changeNFTTargetOutPrice(\r\n        uint256 newGsStart,\r\n        uint256 newCr,\r\n        bool toggleFlag\r\n    ) external onlySuperOwner {\r\n        _changeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\r\n    }\r\n\r\n    function _changeNFTTargetOutPrice(\r\n        uint256 newGsStart,\r\n        uint256 newCr,\r\n        bool toggleFlag\r\n    ) internal {\r\n        require(newCr != 0, \"CR_INVALID\");\r\n        _GS_START_TARGET_OUT_ = newGsStart;\r\n        _CR_TARGET_OUT_ = newCr;\r\n        _NFT_TARGET_OUT_TOGGLE_ = toggleFlag;\r\n\r\n        emit ChangeNFTTargetOutPrice(newGsStart, newCr, toggleFlag);\r\n    }\r\n\r\n    function changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount)\r\n        external\r\n        onlySuperOwner\r\n    {\r\n        _changeNFTAmountRange(maxNFTAmount, minNFTAmount);\r\n    }\r\n\r\n    function _changeNFTAmountRange(uint256 maxNFTAmount, uint256 minNFTAmount) internal {\r\n        require(maxNFTAmount >= minNFTAmount, \"AMOUNT_INVALID\");\r\n        _MAX_NFT_AMOUNT_ = maxNFTAmount;\r\n        _MIN_NFT_AMOUNT_ = minNFTAmount;\r\n\r\n        emit ChangeNFTAmountRange(maxNFTAmount, minNFTAmount);\r\n    }\r\n\r\n    function changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) external onlySuperOwner {\r\n        _changeTokenIdRange(nftIdStart, nftIdEnd);\r\n    }\r\n\r\n    function _changeTokenIdRange(uint256 nftIdStart, uint256 nftIdEnd) internal {\r\n        require(nftIdStart <= nftIdEnd, \"TOKEN_RANGE_INVALID\");\r\n\r\n        _NFT_ID_START_ = nftIdStart;\r\n        _NFT_ID_END_ = nftIdEnd;\r\n\r\n        emit ChangeTokenIdRange(nftIdStart, nftIdEnd);\r\n    }\r\n\r\n    function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\r\n        external\r\n        onlySuperOwner\r\n    {\r\n        _changeTokenIdMap(tokenIds, isRegistered);\r\n    }\r\n\r\n    function _changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered) internal {\r\n        require(tokenIds.length == isRegistered.length, \"PARAM_NOT_MATCH\");\r\n\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            _SPREAD_IDS_REGISTRY_[tokenIds[i]] = isRegistered[i];\r\n            emit ChangeTokenIdMap(tokenIds[i], isRegistered[i]);\r\n        }\r\n    }\r\n\r\n    function changeFilterName(string memory newFilterName)\r\n        external\r\n        onlySuperOwner\r\n    {\r\n        _changeFilterName(newFilterName);\r\n    }\r\n\r\n    function _changeFilterName(string memory newFilterName) internal {\r\n        _FILTER_NAME_ = newFilterName;\r\n        emit ChangeFilterName(newFilterName);\r\n    }\r\n\r\n\r\n    function resetFilter(\r\n        string memory filterName,\r\n        bool[] memory toggles,\r\n        uint256[] memory numParams, //0 - startId, 1 - endId, 2 - maxAmount, 3 - minAmount\r\n        uint256[] memory priceRules,\r\n        uint256[] memory spreadIds,\r\n        bool[] memory isRegistered\r\n    ) external onlySuperOwner {\r\n        _changeFilterName(filterName);\r\n        _changeNFTInPrice(priceRules[0], priceRules[1], toggles[0]);\r\n        _changeNFTRandomOutPrice(priceRules[2], priceRules[3], toggles[1]);\r\n        _changeNFTTargetOutPrice(priceRules[4], priceRules[5], toggles[2]);\r\n\r\n        _changeNFTAmountRange(numParams[2], numParams[3]);\r\n        _changeTokenIdRange(numParams[0], numParams[1]);\r\n\r\n        _changeTokenIdMap(spreadIds, isRegistered);\r\n    }\r\n}\r\n\r\n// File: contracts/NFTPool/impl/FilterERC721V1.sol\r\n\r\n\r\ncontract FilterERC721V1 is IERC721Receiver, BaseFilterV1 {\r\n    using SafeMath for uint256;\r\n\r\n    //============== Event =================\r\n    event FilterInit(address filterAdmin, address nftCollection, string name);\r\n    event NftIn(uint256 tokenId);\r\n    event TargetOut(uint256 tokenId);\r\n    event RandomOut(uint256 tokenId);\r\n    event EmergencyWithdraw(address nftContract,uint256 tokenId, address to);\r\n\r\n    function init(\r\n        address filterAdmin,\r\n        address nftCollection,\r\n        bool[] memory toggles,\r\n        string memory filterName,\r\n        uint256[] memory numParams, //0 - startId, 1 - endId, 2 - maxAmount, 3 - minAmount\r\n        uint256[] memory priceRules,\r\n        uint256[] memory spreadIds\r\n    ) external {\r\n        initOwner(filterAdmin);\r\n\r\n        _changeFilterName(filterName);\r\n        _NFT_COLLECTION_ = nftCollection;\r\n        _changeNFTInPrice(priceRules[0], priceRules[1], toggles[0]);\r\n        _changeNFTRandomOutPrice(priceRules[2], priceRules[3], toggles[1]);\r\n        _changeNFTTargetOutPrice(priceRules[4], priceRules[5], toggles[2]);\r\n\r\n        _changeNFTAmountRange(numParams[2], numParams[3]);\r\n\r\n        _changeTokenIdRange(numParams[0], numParams[1]);\r\n        for (uint256 i = 0; i < spreadIds.length; i++) {\r\n            _SPREAD_IDS_REGISTRY_[spreadIds[i]] = true;\r\n            emit ChangeTokenIdMap(spreadIds[i], true);\r\n        }\r\n\r\n        emit FilterInit(filterAdmin, nftCollection, filterName);\r\n    }\r\n\r\n    // ================= Trading ================\r\n\r\n    function ERC721In(uint256[] memory tokenIds, address to)\r\n        external\r\n        preventReentrant\r\n        returns (uint256 received)\r\n    {\r\n        require(tokenIds.length <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\r\n        uint256 originTotalNftAmount = _TOTAL_NFT_AMOUNT_;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            uint256 tokenId = tokenIds[i];\r\n            require(isNFTIDValid(tokenId), \"NFT_ID_NOT_SUPPORT\");\r\n            require(\r\n                _NFT_RESERVE_[tokenId] == 0 &&\r\n                    IERC721(_NFT_COLLECTION_).ownerOf(tokenId) == address(this),\r\n                \"NFT_NOT_SEND\"\r\n            );\r\n            _NFT_IDS_.push(tokenId);\r\n            _TOKENID_IDX_[tokenId] = _NFT_IDS_.length;\r\n            _NFT_RESERVE_[tokenId] = 1;\r\n\r\n            emit NftIn(tokenId);\r\n        }\r\n        _TOTAL_NFT_AMOUNT_ = _NFT_IDS_.length;\r\n        (uint256 rawReceive, ) = _queryNFTIn(originTotalNftAmount, originTotalNftAmount + tokenIds.length);\r\n        received = IFilterAdmin(_OWNER_).mintFragTo(to, rawReceive);\r\n\r\n        emit NftInOrder(to, received);\r\n    }\r\n\r\n    function ERC721TargetOut(uint256[] memory tokenIds, address to, uint256 maxBurnAmount)\r\n        external\r\n        preventReentrant\r\n        returns (uint256 paid)\r\n    {\r\n        (uint256 rawPay, ) = queryNFTTargetOut(tokenIds.length);\r\n        paid = IFilterAdmin(_OWNER_).burnFragFrom(msg.sender, rawPay);\r\n        require(paid <= maxBurnAmount, \"BURN_AMOUNT_EXCEED\");\r\n\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            _transferOutERC721(to, tokenIds[i]);\r\n\r\n            emit TargetOut(tokenIds[i]);\r\n        }\r\n        _TOTAL_NFT_AMOUNT_ = _NFT_IDS_.length;\r\n\r\n        emit TargetOutOrder(msg.sender, paid);\r\n    }\r\n\r\n    function ERC721RandomOut(uint256 amount, address to, uint256 maxBurnAmount)\r\n        external\r\n        preventReentrant\r\n        returns (uint256 paid)\r\n    {\r\n        (uint256 rawPay, ) = queryNFTRandomOut(amount);\r\n        paid = IFilterAdmin(_OWNER_).burnFragFrom(msg.sender, rawPay);\r\n        require(paid <= maxBurnAmount, \"BURN_AMOUNT_EXCEED\");\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            uint256 index = _getRandomNum() % _NFT_IDS_.length;\r\n            uint256 tokenId = _NFT_IDS_[index];\r\n            _transferOutERC721(to, tokenId);\r\n            emit RandomOut(tokenId);\r\n        }\r\n        _TOTAL_NFT_AMOUNT_ = _NFT_IDS_.length;\r\n\r\n        emit RandomOutOrder(msg.sender, paid);\r\n    }\r\n\r\n    // ============ Transfer =============\r\n\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) external override returns (bytes4) {\r\n        return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n\r\n    function _transferOutERC721(address to, uint256 tokenId) internal {\r\n        require(_TOKENID_IDX_[tokenId] > 0, \"TOKENID_NOT_EXIST\");\r\n        uint256 index = _TOKENID_IDX_[tokenId] - 1;\r\n        require(index < _NFT_IDS_.length, \"INDEX_INVALID\");\r\n        IERC721(_NFT_COLLECTION_).safeTransferFrom(address(this), to, tokenId);\r\n        if(index != _NFT_IDS_.length - 1) {\r\n            uint256 lastTokenId = _NFT_IDS_[_NFT_IDS_.length - 1];\r\n            _NFT_IDS_[index] = lastTokenId;\r\n            _TOKENID_IDX_[lastTokenId] = index + 1;\r\n        }\r\n        _NFT_IDS_.pop();\r\n        _NFT_RESERVE_[tokenId] = 0;\r\n        _TOKENID_IDX_[tokenId] = 0;\r\n    }\r\n\r\n    function emergencyWithdraw(\r\n        address[] memory nftContract,\r\n        uint256[] memory tokenIds,\r\n        address to\r\n    ) external onlySuperOwner {\r\n        require(nftContract.length == tokenIds.length, \"PARAM_INVALID\");\r\n        address controller = IFilterAdmin(_OWNER_)._CONTROLLER_();\r\n        require(\r\n            IController(controller).isEmergencyWithdrawOpen(address(this)),\r\n            \"EMERGENCY_WITHDRAW_NOT_OPEN\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < nftContract.length; i++) {\r\n            uint256 tokenId = tokenIds[i];\r\n            if (_NFT_RESERVE_[tokenId] > 0 && nftContract[i] == _NFT_COLLECTION_) {\r\n                uint256 index = getNFTIndexById(tokenId);\r\n                if(index != _NFT_IDS_.length - 1) {\r\n                    uint256 lastTokenId = _NFT_IDS_[_NFT_IDS_.length - 1];\r\n                    _NFT_IDS_[index] = lastTokenId;\r\n                    _TOKENID_IDX_[lastTokenId] = index + 1;\r\n                }\r\n                _NFT_IDS_.pop();\r\n                _NFT_RESERVE_[tokenId] = 0;\r\n                _TOKENID_IDX_[tokenId] = 0;\r\n            }\r\n            IERC721(nftContract[i]).safeTransferFrom(address(this), to, tokenIds[i]);\r\n            emit EmergencyWithdraw(nftContract[i],tokenIds[i],to);\r\n        }\r\n        _TOTAL_NFT_AMOUNT_ = _NFT_IDS_.length;\r\n    }\r\n\r\n    // ============ Support ============\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\r\n        return interfaceId == type(IERC721Receiver).interfaceId;\r\n    }\r\n\r\n    function version() external pure virtual returns (string memory) {\r\n        return \"FILTER_1_ERC721 1.0.0\";\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newFilterName\",\"type\":\"string\"}],\"name\":\"ChangeFilterName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxNFTAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minNFTAmount\",\"type\":\"uint256\"}],\"name\":\"ChangeNFTAmountRange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newGsStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCr\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"toggleFlag\",\"type\":\"bool\"}],\"name\":\"ChangeNFTInPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newGsStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCr\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"toggleFlag\",\"type\":\"bool\"}],\"name\":\"ChangeNFTRandomOutPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newGsStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCr\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"toggleFlag\",\"type\":\"bool\"}],\"name\":\"ChangeNFTTargetOutPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenIds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isRegistered\",\"type\":\"bool\"}],\"name\":\"ChangeTokenIdMap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftIdStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftIdEnd\",\"type\":\"uint256\"}],\"name\":\"ChangeTokenIdRange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"filterAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftCollection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"FilterInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NftIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receiveAmount\",\"type\":\"uint256\"}],\"name\":\"NftInOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferPrepared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"RandomOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"}],\"name\":\"RandomOutOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TargetOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"}],\"name\":\"TargetOutOrder\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ERC721In\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxBurnAmount\",\"type\":\"uint256\"}],\"name\":\"ERC721RandomOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxBurnAmount\",\"type\":\"uint256\"}],\"name\":\"ERC721TargetOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"paid\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_CR_IN_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_CR_RANDOM_OUT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_CR_TARGET_OUT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_FILTER_NAME_\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_GS_START_IN_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_GS_START_RANDOM_OUT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_GS_START_TARGET_OUT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MAX_NFT_AMOUNT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MIN_NFT_AMOUNT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NEW_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NFT_COLLECTION_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_NFT_IDS_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NFT_ID_END_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NFT_ID_START_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NFT_IN_TOGGLE_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NFT_RANDOM_OUT_TOGGLE_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_NFT_RESERVE_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_NFT_TARGET_OUT_TOGGLE_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_SPREAD_IDS_REGISTRY_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_TOKENID_IDX_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_TOTAL_NFT_AMOUNT_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getRandomNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"randomNum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newFilterName\",\"type\":\"string\"}],\"name\":\"changeFilterName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxNFTAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minNFTAmount\",\"type\":\"uint256\"}],\"name\":\"changeNFTAmountRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGsStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newCr\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"toggleFlag\",\"type\":\"bool\"}],\"name\":\"changeNFTInPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGsStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newCr\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"toggleFlag\",\"type\":\"bool\"}],\"name\":\"changeNFTRandomOutPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newGsStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newCr\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"toggleFlag\",\"type\":\"bool\"}],\"name\":\"changeNFTTargetOutPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"isRegistered\",\"type\":\"bool[]\"}],\"name\":\"changeTokenIdMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftIdStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftIdEnd\",\"type\":\"uint256\"}],\"name\":\"changeTokenIdRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"nftContract\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvaliableNFTInAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvaliableNFTOutAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getNFTIndexById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"filterAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftCollection\",\"type\":\"address\"},{\"internalType\":\"bool[]\",\"name\":\"toggles\",\"type\":\"bool[]\"},{\"internalType\":\"string\",\"name\":\"filterName\",\"type\":\"string\"},{\"internalType\":\"uint256[]\",\"name\":\"numParams\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"priceRules\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"spreadIds\",\"type\":\"uint256[]\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"initOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"isNFTIDValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftCollectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"isNFTValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"NFTInAmount\",\"type\":\"uint256\"}],\"name\":\"queryNFTIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rawReceive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"NFTOutAmount\",\"type\":\"uint256\"}],\"name\":\"queryNFTRandomOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rawPay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pay\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"NFTOutAmount\",\"type\":\"uint256\"}],\"name\":\"queryNFTTargetOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rawPay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pay\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"filterName\",\"type\":\"string\"},{\"internalType\":\"bool[]\",\"name\":\"toggles\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"numParams\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"priceRules\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"spreadIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"isRegistered\",\"type\":\"bool[]\"}],\"name\":\"resetFilter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"FilterERC721V1","CompilerVersion":"v0.6.9+commit.3e3065ac","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://e76c783f016f720ac851b1b0413f647e6a5aeb73946214c2e72097db2f91bde2"}]}