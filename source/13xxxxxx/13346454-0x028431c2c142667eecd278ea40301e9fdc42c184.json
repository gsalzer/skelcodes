{"status":"1","message":"OK","result":[{"SourceCode":"{\"Creator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e0.8.0 \\u003c0.9.0;\\n\\nimport \\\"./Forwarder.sol\\\";\\n\\ncontract Creator {\\n\\n    event Created(bytes32 salt, address indexed forwarder);\\n\\n    function deploy(address payable destination, bytes32 salt) public returns (address) {\\n        Forwarder a = new Forwarder{salt: salt}(destination);\\n        emit Created(salt, address(a));\\n        return address(a);\\n    }\\n\\n}\"},\"Forwarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e0.8.0 \\u003c0.9.0;\\n\\ncontract Forwarder {\\n\\n    address payable immutable public destinationAddress;\\n    event Created(bytes32 salt, address indexed forwarder);\\n    event Forwarded(address addr, uint256 quantity);\\n\\n    constructor(address payable destination) {\\n        destinationAddress = destination;\\n        destination.transfer(address(this).balance);\\n        emit Forwarded(address(this), address(this).balance);\\n    }\\n\\n    // EIP-1167\\n    function derivate(bytes32 salt) external returns (address result) {\\n        bytes20 targetBytes = bytes20(address(this));\\n        assembly {\\n            let bs := mload(0x40)\\n            mstore(bs, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(bs, 0x14), targetBytes)\\n            mstore(add(bs, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n\\n            let encoded_data := add(0x20, bs) // load initialization code.\\n            let encoded_size := mload(bs)     // load the init code\\u0027s length.\\n\\n            result := create2(0, bs, 0x37, salt)\\n        }\\n\\n        emit Created(salt, result);\\n    }\\n\\n    // Auto forward all incoming ethers\\n    receive() external payable {\\n        flush();\\n    }\\n\\n    // Manually require to forward ethers when the forwarder has been derivated after assets have been received on the contract address\\n    function flush() public {\\n        // destinationAddress.transfer(address(this).balance);\\n        destinationAddress.call{value: address(this).balance}(\\\"\\\");\\n        emit Forwarded(address(this), address(this).balance);\\n    }\\n\\n    // Forward ERC20 tokens from a given contract address\\n    function flushTokens(address tokenContractAddress) public {\\n        ERC20Interface instance = ERC20Interface(tokenContractAddress);\\n        uint256 forwarderBalance = instance.balanceOf(address(this));\\n        if (forwarderBalance == 0) {\\n            return;\\n        }\\n\\n        instance.transfer(destinationAddress, forwarderBalance);\\n        emit Forwarded(tokenContractAddress, forwarderBalance);\\n    }\\n\\n    // Forward only a given quantity of ERC20 tokens from a the provided contract address \\n    function flushTokensQuantity(address tokenContractAddress, uint256 quantity) public {\\n        ERC20Interface instance = ERC20Interface(tokenContractAddress);\\n        instance.transfer(destinationAddress, quantity);\\n        emit Forwarded(tokenContractAddress, quantity);\\n    }\\n\\n    // Forward all ethers present on this contract and all ERC20 tokens from a given contract address\\n    function flushTokensAndBalance(address tokenContractAddress) public {\\n        flush();\\n        flushTokens(tokenContractAddress);\\n    }\\n\\n    function requireCall(address dest, bytes memory data) public returns (bool, bytes memory) {\\n        require(msg.sender == destinationAddress);\\n        return dest.call(data);\\n    }\\n}\\n\\ninterface ERC20Interface {\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n}\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"Created\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Creator","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0decb3e16d285a993ed53d21891e755cd4e78a477f3519d4ae769fdf29578014"}]}