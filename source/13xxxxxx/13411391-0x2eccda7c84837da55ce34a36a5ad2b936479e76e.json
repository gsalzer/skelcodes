{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"MoonCatResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\r\\n\\r\\npragma solidity 0.8.1;\\r\\n\\r\\ninterface IMoonCatAcclimator {\\r\\n    function getApproved(uint256 tokenId) external view returns (address);\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n    function ownerOf(uint256 tokenId) external view returns (address);\\r\\n    function balanceOf(address _owner) external view returns (uint256);\\r\\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IMoonCatRescue {\\r\\n    function rescueOrder(uint256 tokenId) external view returns (bytes5);\\r\\n    function catOwners(bytes5 catId) external view returns (address);\\r\\n}\\r\\n\\r\\ninterface IReverseResolver {\\r\\n    function claim(address owner) external returns (bytes32);\\r\\n}\\r\\n\\r\\ninterface IRegistry {\\r\\n    function setSubnodeRecord(bytes32 node, bytes32 label, address owner, address resolver, uint64 ttl) external;\\r\\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\\r\\n    function setTTL(bytes32 node, uint64 ttl) external;\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n    function owner(bytes32 node) external view returns (address);\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n}\\r\\ninterface IERC721 {\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title MoonCatResolver\\r\\n * @notice ENS Resolver for MoonCat subdomains\\r\\n * @dev Auto-updates to point to the owner of that specific MoonCat\\r\\n */\\r\\ncontract MoonCatResolver {\\r\\n\\r\\n    /* External Contracts */\\r\\n    IMoonCatAcclimator MCA = IMoonCatAcclimator(0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69);\\r\\n    IMoonCatRescue MCR = IMoonCatRescue(0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6);\\r\\n\\r\\n\\r\\n    /* State */\\r\\n    mapping(bytes32 => uint256) internal NamehashMapping; // ENS namehash => Rescue ID of MoonCat\\r\\n    mapping(uint256 => mapping(uint256 => bytes)) internal MultichainMapping; // Rescue ID of MoonCat => Multichain ID => value\\r\\n    mapping(uint256 => mapping(string => string)) internal TextKeyMapping; // Rescue ID of MoonCat => text record key => value\\r\\n    mapping(uint256 => bytes) internal ContentsMapping; // Rescue ID of MoonCat => content hash\\r\\n    mapping(uint256 => address) internal lastAnnouncedAddress; // Rescue ID of MoonCat => address that was last emitted in an AddrChanged Event\\r\\n\\r\\n    address payable public owner;\\r\\n    bytes32 immutable public rootHash;\\r\\n    string public ENSDomain; // Reference for the ENS domain this contract resolves\\r\\n    string public avatarBaseURI = \\\"eip155:1/erc721:0xc3f733ca98e0dad0386979eb96fb1722a1a05e69/\\\";\\r\\n    uint64 public defaultTTL = 86400;\\r\\n\\r\\n    // For string-matching on a specific text key\\r\\n    uint256 constant internal avatarKeyLength = 6;\\r\\n    bytes32 constant internal avatarKeyHash = keccak256(\\\"avatar\\\");\\r\\n\\r\\n    /* Events */\\r\\n    event AddrChanged(bytes32 indexed node, address a);\\r\\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\\r\\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\\r\\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\\r\\n\\r\\n    /* Modifiers */\\r\\n    modifier onlyOwner () {\\r\\n        require(msg.sender == owner, \\\"Only Owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyMoonCatOwner (uint256 rescueOrder) {\\r\\n        require(MCR.catOwners(MCR.rescueOrder(rescueOrder)) == address(MCA), \\\"Not Acclimated\\\");\\r\\n        require(msg.sender == MCA.ownerOf(rescueOrder), \\\"Not MoonCat's owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Deploy resolver contract.\\r\\n     */\\r\\n    constructor(bytes32 _rootHash, string memory _ENSDomain){\\r\\n        owner = payable(msg.sender);\\r\\n        rootHash = _rootHash;\\r\\n        ENSDomain = _ENSDomain;\\r\\n        // https://docs.ens.domains/contract-api-reference/reverseregistrar#claim-address\\r\\n        IReverseResolver(0x084b1c3C81545d370f3634392De611CaaBFf8148)\\r\\n            .claim(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allow current `owner` to transfer ownership to another address\\r\\n     */\\r\\n    function transferOwnership (address payable newOwner) public onlyOwner {\\r\\n        owner = newOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Update the \\\"avatar\\\" value that gets set by default.\\r\\n     */\\r\\n    function setAvatarBaseUrl(string calldata url) public onlyOwner {\\r\\n        avatarBaseURI = url;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Update the default TTL value.\\r\\n     */\\r\\n    function setDefaultTTL(uint64 newTTL) public onlyOwner {\\r\\n        defaultTTL = newTTL;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Pass ownership of a subnode of the contract's root hash to the owner.\\r\\n     */\\r\\n    function giveControl(bytes32 nodeId) public onlyOwner {\\r\\n        IRegistry(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e).setSubnodeOwner(rootHash, nodeId, owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Rescue ERC20 assets sent directly to this contract.\\r\\n     */\\r\\n    function withdrawForeignERC20(address tokenContract) public onlyOwner {\\r\\n        IERC20 token = IERC20(tokenContract);\\r\\n        token.transfer(owner, token.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Rescue ERC721 assets sent directly to this contract.\\r\\n     */\\r\\n    function withdrawForeignERC721(address tokenContract, uint256 tokenId) public onlyOwner {\\r\\n        IERC721(tokenContract).safeTransferFrom(address(this), owner, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev ERC165 support for ENS resolver interface\\r\\n     * https://docs.ens.domains/contract-developer-guide/writing-a-resolver\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\\r\\n        return interfaceID == 0x01ffc9a7 // supportsInterface call itself\\r\\n            || interfaceID == 0x3b3b57de // EIP137: ENS resolver\\r\\n            || interfaceID == 0xf1cb7e06 // EIP2304: Multichain addresses\\r\\n            || interfaceID == 0x59d1d43c // EIP634: ENS text records\\r\\n            || interfaceID == 0xbc1c58d1 // EIP1577: contenthash\\r\\n        ;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev For a given ENS Node ID, return the Ethereum address it points to.\\r\\n     * EIP137 core functionality\\r\\n     */\\r\\n    function addr(bytes32 nodeID) public view returns (address) {\\r\\n        uint256 rescueOrder = getRescueOrderFromNodeId(nodeID);\\r\\n        address actualOwner = MCA.ownerOf(rescueOrder);\\r\\n        if (\\r\\n            MCR.catOwners(MCR.rescueOrder(rescueOrder)) != address(MCA) ||\\r\\n            actualOwner != lastAnnouncedAddress[rescueOrder]\\r\\n        ) {\\r\\n            return address(0); // Not Acclimated/Announced; return zero (per spec)\\r\\n        } else {\\r\\n            return lastAnnouncedAddress[rescueOrder];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev For a given ENS Node ID, return an address on a different blockchain it points to.\\r\\n     * EIP2304 functionality\\r\\n     */\\r\\n    function addr(bytes32 nodeID, uint256 coinType) public view returns (bytes memory) {\\r\\n        uint256 rescueOrder = getRescueOrderFromNodeId(nodeID);\\r\\n        if (MCR.catOwners(MCR.rescueOrder(rescueOrder)) != address(MCA)) {\\r\\n            return bytes(''); // Not Acclimated; return zero (per spec)\\r\\n        }\\r\\n        if (coinType == 60) {\\r\\n            // Ethereum address\\r\\n            return abi.encodePacked(addr(nodeID));\\r\\n        } else {\\r\\n            return MultichainMapping[rescueOrder][coinType];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev For a given ENS Node ID, set it to point to an address on a different blockchain.\\r\\n     * EIP2304 functionality\\r\\n     */\\r\\n    function setAddr(bytes32 nodeID, uint256 coinType, bytes calldata newAddr) public {\\r\\n        uint256 rescueOrder = getRescueOrderFromNodeId(nodeID);\\r\\n        setAddr(rescueOrder, coinType, newAddr);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev For a given MoonCat rescue order, set the subdomains associated with it to point to an address on a different blockchain.\\r\\n     */\\r\\n    function setAddr(uint256 rescueOrder, uint256 coinType, bytes calldata newAddr) public onlyMoonCatOwner(rescueOrder) {\\r\\n        if (coinType == 60) {\\r\\n            // Ethereum address\\r\\n            announceMoonCat(rescueOrder);\\r\\n            return;\\r\\n        }\\r\\n        emit AddressChanged(getSubdomainNameHash(uint2str(rescueOrder)), coinType, newAddr);\\r\\n        emit AddressChanged(getSubdomainNameHash(bytes5ToHexString(MCR.rescueOrder(rescueOrder))), coinType, newAddr);\\r\\n        MultichainMapping[rescueOrder][coinType] = newAddr;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev For a given ENS Node ID, return the value associated with a given text key.\\r\\n     * If the key is \\\"avatar\\\", and the matching value is not explicitly set, a url pointing to the MoonCat's image is returned\\r\\n     * EIP634 functionality\\r\\n     */\\r\\n    function text(bytes32 nodeID, string calldata key) public view returns (string memory) {\\r\\n        uint256 rescueOrder = getRescueOrderFromNodeId(nodeID);\\r\\n\\r\\n        string memory value = TextKeyMapping[rescueOrder][key];\\r\\n        if (bytes(value).length > 0) {\\r\\n            // This value has been set explicitly; return that\\r\\n            return value;\\r\\n        }\\r\\n\\r\\n        // Check if there's a default value for this key\\r\\n        bytes memory keyBytes = bytes(key);\\r\\n        if (keyBytes.length == avatarKeyLength && keccak256(keyBytes) == avatarKeyHash){\\r\\n            // Avatar default\\r\\n            return string(abi.encodePacked(avatarBaseURI,  uint2str(rescueOrder)));\\r\\n        }\\r\\n\\r\\n        // No default; just return the empty string\\r\\n        return value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Update a text record for a specific subdomain.\\r\\n     * EIP634 functionality\\r\\n     */\\r\\n    function setText(bytes32 nodeID, string calldata key, string calldata value) public {\\r\\n        uint256 rescueOrder = getRescueOrderFromNodeId(nodeID);\\r\\n        setText(rescueOrder, key, value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Update a text record for subdomains owned by a specific MoonCat rescue order.\\r\\n     */\\r\\n    function setText(uint256 rescueOrder, string calldata key, string calldata value) public onlyMoonCatOwner(rescueOrder) {\\r\\n        bytes memory keyBytes = bytes(key);\\r\\n        bytes32 orderHash = getSubdomainNameHash(uint2str(rescueOrder));\\r\\n        bytes32 hexHash = getSubdomainNameHash(bytes5ToHexString(MCR.rescueOrder(rescueOrder)));\\r\\n\\r\\n        if (bytes(value).length == 0 && keyBytes.length == avatarKeyLength && keccak256(keyBytes) == avatarKeyHash){\\r\\n            // Avatar default\\r\\n            string memory avatarRecordValue = string(abi.encodePacked(avatarBaseURI,  uint2str(rescueOrder)));\\r\\n            emit TextChanged(orderHash, key, avatarRecordValue);\\r\\n            emit TextChanged(hexHash, key, avatarRecordValue);\\r\\n        } else {\\r\\n            emit TextChanged(orderHash, key, value);\\r\\n            emit TextChanged(hexHash, key, value);\\r\\n        }\\r\\n        TextKeyMapping[rescueOrder][key] = value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Get the \\\"content hash\\\" of a given subdomain.\\r\\n     * EIP1577 functionality\\r\\n     */\\r\\n    function contenthash(bytes32 nodeID) public view returns (bytes memory) {\\r\\n        uint256 rescueOrder = getRescueOrderFromNodeId(nodeID);\\r\\n        return ContentsMapping[rescueOrder];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Update the \\\"content hash\\\" of a given subdomain.\\r\\n     * EIP1577 functionality\\r\\n     */\\r\\n    function setContenthash(bytes32 nodeID, bytes calldata hash) public {\\r\\n        uint256 rescueOrder = getRescueOrderFromNodeId(nodeID);\\r\\n        setContenthash(rescueOrder, hash);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Update the \\\"content hash\\\" of a given MoonCat's subdomains.\\r\\n     */\\r\\n    function setContenthash(uint256 rescueOrder, bytes calldata hash) public onlyMoonCatOwner(rescueOrder) {\\r\\n        emit ContenthashChanged(getSubdomainNameHash(uint2str(rescueOrder)), hash);\\r\\n        emit ContenthashChanged(getSubdomainNameHash(bytes5ToHexString(MCR.rescueOrder(rescueOrder))), hash);\\r\\n        ContentsMapping[rescueOrder] = hash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set the TTL for a given MoonCat's subdomains.\\r\\n     */\\r\\n    function setTTL(uint rescueOrder, uint64 newTTL) public onlyMoonCatOwner(rescueOrder) {\\r\\n        IRegistry registry = IRegistry(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\\r\\n        registry.setTTL(getSubdomainNameHash(uint2str(rescueOrder)), newTTL);\\r\\n        registry.setTTL(getSubdomainNameHash(bytes5ToHexString(MCR.rescueOrder(rescueOrder))), newTTL);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allow calling multiple functions on this contract in one transaction.\\r\\n     */\\r\\n    function multicall(bytes[] calldata data) external returns(bytes[] memory results) {\\r\\n        results = new bytes[](data.length);\\r\\n        for (uint i = 0; i < data.length; i++) {\\r\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\r\\n            require(success);\\r\\n            results[i] = result;\\r\\n        }\\r\\n        return results;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Reverse lookup for ENS Node ID, to determine the MoonCat rescue order of the MoonCat associated with it.\\r\\n     */\\r\\n    function getRescueOrderFromNodeId(bytes32 nodeID) public view returns (uint256) {\\r\\n        uint256 rescueOrder = NamehashMapping[nodeID];\\r\\n        if (rescueOrder == 0) {\\r\\n            // Are we actually dealing with MoonCat #0?\\r\\n            require(\\r\\n                nodeID == 0x8bde039a2a7841d31e0561fad9d5cfdfd4394902507c72856cf5950eaf9e7d5a // 0.ismymooncat.eth\\r\\n                || nodeID == 0x1002474938c26fb23080c33c3db026c584b30ec6e7d3edf4717f3e01e627da26, // 0x00d658d50b.ismymooncat.eth\\r\\n                \\\"Unknown Node ID\\\"\\r\\n            );\\r\\n        }\\r\\n        return rescueOrder;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Calculate the \\\"namehash\\\" of a specific domain, using the ENS standard algorithm.\\r\\n     * The namehash of 'ismymooncat.eth' is 0x204665c32985055ed5daf374d6166861ba8892a3b0849d798c919fffe38a1a15\\r\\n     * The namehash of 'foo.ismymooncat.eth' is keccak256(0x204665c32985055ed5daf374d6166861ba8892a3b0849d798c919fffe38a1a15, keccak256('foo'))\\r\\n     */\\r\\n    function getSubdomainNameHash(string memory subdomain) public view returns (bytes32) {\\r\\n        return keccak256(abi.encodePacked(rootHash, keccak256(abi.encodePacked(subdomain))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Cache a single MoonCat's (identified by Rescue Order) subdomain hashes.\\r\\n     */\\r\\n    function mapMoonCat(uint256 rescueOrder) public {\\r\\n        string memory orderSubdomain = uint2str(rescueOrder);\\r\\n        string memory hexSubdomain = bytes5ToHexString(MCR.rescueOrder(rescueOrder));\\r\\n\\r\\n        bytes32 orderHash = getSubdomainNameHash(orderSubdomain);\\r\\n        bytes32 hexHash = getSubdomainNameHash(hexSubdomain);\\r\\n\\r\\n        if (uint256(NamehashMapping[orderHash]) != 0) {\\r\\n            // Already Mapped\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        NamehashMapping[orderHash] = rescueOrder;\\r\\n        NamehashMapping[hexHash] = rescueOrder;\\r\\n\\r\\n        if(MCR.catOwners(MCR.rescueOrder(rescueOrder)) != address(MCA)) {\\r\\n            // MoonCat is not Acclimated\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        IRegistry registry = IRegistry(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\\r\\n        registry.setSubnodeRecord(rootHash, keccak256(bytes(orderSubdomain)), address(this), address(this), defaultTTL);\\r\\n        registry.setSubnodeRecord(rootHash, keccak256(bytes(hexSubdomain)), address(this), address(this), defaultTTL);\\r\\n\\r\\n        address moonCatOwner = MCA.ownerOf(rescueOrder);\\r\\n        lastAnnouncedAddress[rescueOrder] = moonCatOwner;\\r\\n        emit AddrChanged(orderHash, moonCatOwner);\\r\\n        emit AddrChanged(hexHash, moonCatOwner);\\r\\n        emit AddressChanged(orderHash, 60, abi.encodePacked(moonCatOwner));\\r\\n        emit AddressChanged(hexHash, 60, abi.encodePacked(moonCatOwner));\\r\\n\\r\\n        string memory avatarRecordValue = string(abi.encodePacked(avatarBaseURI,  uint2str(rescueOrder)));\\r\\n        emit TextChanged(orderHash, \\\"avatar\\\", avatarRecordValue);\\r\\n        emit TextChanged(hexHash, \\\"avatar\\\", avatarRecordValue);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Announce a single MoonCat's (identified by Rescue Order) assigned address.\\r\\n     */\\r\\n    function announceMoonCat(uint256 rescueOrder) public {\\r\\n        require(MCR.catOwners(MCR.rescueOrder(rescueOrder)) == address(MCA), \\\"Not Acclimated\\\");\\r\\n        address moonCatOwner = MCA.ownerOf(rescueOrder);\\r\\n\\r\\n        lastAnnouncedAddress[rescueOrder] = moonCatOwner;\\r\\n        bytes32 orderHash = getSubdomainNameHash(uint2str(rescueOrder));\\r\\n        bytes32 hexHash = getSubdomainNameHash(bytes5ToHexString(MCR.rescueOrder(rescueOrder)));\\r\\n\\r\\n        emit AddrChanged(orderHash, moonCatOwner);\\r\\n        emit AddrChanged(hexHash, moonCatOwner);\\r\\n        emit AddressChanged(orderHash, 60, abi.encodePacked(moonCatOwner));\\r\\n        emit AddressChanged(hexHash, 60, abi.encodePacked(moonCatOwner));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Has an AddrChanged event been emitted for the current owner of a MoonCat (identified by Rescue Order)?\\r\\n     */\\r\\n    function needsAnnouncing(uint256 rescueOrder) public view returns (bool) {\\r\\n        require(MCR.catOwners(MCR.rescueOrder(rescueOrder)) == address(MCA), \\\"Not Acclimated\\\");\\r\\n        return lastAnnouncedAddress[rescueOrder] != MCA.ownerOf(rescueOrder);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Convenience function to iterate through all MoonCats owned by an address to check if they need announcing.\\r\\n     */\\r\\n    function needsAnnouncing(address moonCatOwner) public view returns (uint256[] memory) {\\r\\n        uint256 balance = MCA.balanceOf(moonCatOwner);\\r\\n        uint256 announceCount = 0;\\r\\n        uint256[] memory tempRescueOrders = new uint256[](balance);\\r\\n        for (uint256 i = 0; i < balance; i++) {\\r\\n            uint256 rescueOrder = MCA.tokenOfOwnerByIndex(moonCatOwner, i);\\r\\n            if (lastAnnouncedAddress[rescueOrder] != moonCatOwner){\\r\\n                tempRescueOrders[announceCount] = rescueOrder;\\r\\n                announceCount++;\\r\\n            }\\r\\n        }\\r\\n        uint256[] memory rescueOrders = new uint256[](announceCount);\\r\\n        for (uint256 i = 0; i < announceCount; i++){\\r\\n            rescueOrders[i] = tempRescueOrders[i];\\r\\n        }\\r\\n        return rescueOrders;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Convenience function to iterate through all MoonCats owned by sender to check if they need announcing.\\r\\n     */\\r\\n    function needsAnnouncing() public view returns (uint256[] memory) {\\r\\n        return needsAnnouncing(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Set a manual list of MoonCats (identified by Rescue Order) to announce or cache their subdomain hashes.\\r\\n     */\\r\\n    function mapMoonCats(uint256[] memory rescueOrders) public {\\r\\n        for (uint256 i = 0; i < rescueOrders.length; i++) {\\r\\n            address lastAnnounced = lastAnnouncedAddress[rescueOrders[i]];\\r\\n            if (lastAnnounced == address(0)){\\r\\n                mapMoonCat(rescueOrders[i]);\\r\\n            } else if (lastAnnounced != MCA.ownerOf(rescueOrders[i])){\\r\\n                announceMoonCat(rescueOrders[i]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Convenience function to iterate through all MoonCats owned by an address and announce or cache their subdomain hashes.\\r\\n     */\\r\\n    function mapMoonCats(address moonCatOwner) public {\\r\\n        for (uint256 i = 0; i < MCA.balanceOf(moonCatOwner); i++) {\\r\\n            uint256 rescueOrder = MCA.tokenOfOwnerByIndex(moonCatOwner, i);\\r\\n            address lastAnnounced = lastAnnouncedAddress[rescueOrder];\\r\\n            if (lastAnnounced == address(0)){\\r\\n                mapMoonCat(rescueOrder);\\r\\n            } else if (lastAnnounced != moonCatOwner){\\r\\n                announceMoonCat(rescueOrder);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Convenience function to iterate through all MoonCats owned by the sender and announce or cache their subdomain hashes.\\r\\n     */\\r\\n    function mapMoonCats() public {\\r\\n        mapMoonCats(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Utility function to convert a bytes5 variable into a hexadecimal string.\\r\\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\\r\\n     */\\r\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n    function bytes5ToHexString(bytes5 x) internal pure returns (string memory) {\\r\\n        uint256 length = 5;\\r\\n        uint256 value = uint256(uint40(x));\\r\\n\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\r\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\r\\n            value >>= 4;\\r\\n        }\\r\\n        //require(value == 0, \\\"Strings: hex length insufficient\\\");\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Utility function to convert a uint256 variable into a decimal string.\\r\\n     */\\r\\n    function uint2str(uint value) internal pure returns (string memory) {\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        while (value != 0) {\\r\\n            digits -= 1;\\r\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\r\\n            value /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_rootHash\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"_ENSDomain\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"AddrChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"newAddress\",\"type\":\"bytes\"}],\"name\":\"AddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"ContenthashChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"indexedKey\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"TextChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ENSDomain\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"}],\"name\":\"addr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"}],\"name\":\"addr\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"}],\"name\":\"announceMoonCat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avatarBaseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"}],\"name\":\"contenthash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultTTL\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"}],\"name\":\"getRescueOrderFromNodeId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"subdomain\",\"type\":\"string\"}],\"name\":\"getSubdomainNameHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"giveControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"}],\"name\":\"mapMoonCat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"moonCatOwner\",\"type\":\"address\"}],\"name\":\"mapMoonCats\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mapMoonCats\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"rescueOrders\",\"type\":\"uint256[]\"}],\"name\":\"mapMoonCats\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"}],\"name\":\"needsAnnouncing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"moonCatOwner\",\"type\":\"address\"}],\"name\":\"needsAnnouncing\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"needsAnnouncing\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rootHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"newAddr\",\"type\":\"bytes\"}],\"name\":\"setAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"newAddr\",\"type\":\"bytes\"}],\"name\":\"setAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"url\",\"type\":\"string\"}],\"name\":\"setAvatarBaseUrl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"setContenthash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"setContenthash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"newTTL\",\"type\":\"uint64\"}],\"name\":\"setDefaultTTL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"newTTL\",\"type\":\"uint64\"}],\"name\":\"setTTL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"setText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rescueOrder\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"setText\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeID\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"text\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"withdrawForeignERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawForeignERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MoonCatResolver","CompilerVersion":"v0.8.1+commit.df193b15","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"204665c32985055ed5daf374d6166861ba8892a3b0849d798c919fffe38a1a150000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000f69736d796d6f6f6e6361742e6574680000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://0d67f9217296547c0d726e0b9b4f8e390b4aae070734eb9eb5e0139e8f7ea4e8"}]}