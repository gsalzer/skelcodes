{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/OwnerBalance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\nimport './Governed.sol';\\nimport './OwnerBalanceContributor.sol';\\n\\n/**\\n * @title Tracks owner's share of the funds in various Macabris contracts\\n */\\ncontract OwnerBalance is Governed {\\n\\n    address public owner;\\n\\n    // All three contracts, that contribute to the owner's balance\\n    OwnerBalanceContributor public release;\\n    OwnerBalanceContributor public bank;\\n    OwnerBalanceContributor public market;\\n\\n    /**\\n     * @param governanceAddress Address of the Governance contract\\n     *\\n     * Requirements:\\n     * - Governance contract must be deployed at the given address\\n     */\\n    constructor(address governanceAddress) Governed(governanceAddress) {}\\n\\n    /**\\n     * @dev Sets the release contract address\\n     * @param releaseAddress Address of the Release contract\\n     *\\n     * Requirements:\\n     * - the caller must have the bootstrap permission\\n     */\\n    function setReleaseAddress(address releaseAddress) external canBootstrap(msg.sender) {\\n        release = OwnerBalanceContributor(releaseAddress);\\n    }\\n\\n    /**\\n     * @dev Sets Bank contract address\\n     * @param bankAddress Address of the Bank contract\\n     *\\n     * Requirements:\\n     * - the caller must have the bootstrap permission\\n     */\\n    function setBankAddress(address bankAddress) external canBootstrap(msg.sender) {\\n        bank = OwnerBalanceContributor(bankAddress);\\n    }\\n\\n    /**\\n     * @dev Sets the market contract address\\n     * @param marketAddress Address of the Market contract\\n     *\\n     * Requirements:\\n     * - the caller must have the bootstrap permission\\n     */\\n    function setMarketAddress(address marketAddress) external canBootstrap(msg.sender) {\\n        market = OwnerBalanceContributor(marketAddress);\\n    }\\n\\n    /**\\n     * @dev Sets owner address where the funds will be sent during withdrawal\\n     * @param _owner Owner's address\\n     *\\n     * Requirements:\\n     * - sender must have canSetOwnerAddress permission\\n     * - address must not be 0\\n     */\\n    function setOwner(address _owner) external canSetOwnerAddress(msg.sender) {\\n        require(_owner != address(0), \\\"Empty owner address is not allowed!\\\");\\n        owner = _owner;\\n    }\\n\\n    /**\\n     * @dev Returns total available balance in all contributing contracts\\n     * @return Balance in wei\\n     */\\n    function getBalance() external view returns (uint) {\\n        uint balance;\\n\\n        balance += release.ownerBalanceDeposits();\\n        balance += bank.ownerBalanceDeposits();\\n        balance += market.ownerBalanceDeposits();\\n\\n        return balance;\\n    }\\n\\n    /**\\n     * @dev Withdraws available balance to the owner address\\n     *\\n     * Requirements:\\n     * - owner address must be set\\n     * - sender must have canTriggerOwnerWithdraw permission\\n     */\\n    function withdraw() external canTriggerOwnerWithdraw(msg.sender) {\\n        require(owner != address(0), \\\"Owner address is not set\\\");\\n\\n        release.withdrawOwnerBalanceDeposits(owner);\\n        bank.withdrawOwnerBalanceDeposits(owner);\\n        market.withdrawOwnerBalanceDeposits(owner);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/OwnerBalanceContributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\nimport './OwnerBalance.sol';\\n\\n/**\\n * @title Allows allocating portion of the contract's funds to the owner balance\\n */\\nabstract contract OwnerBalanceContributor {\\n\\n    // OwnerBalance contract address\\n    address public immutable ownerBalanceAddress;\\n\\n    uint public ownerBalanceDeposits;\\n\\n    /**\\n     * @param _ownerBalanceAddress Address of the OwnerBalance contract\\n     */\\n    constructor (address _ownerBalanceAddress) {\\n        ownerBalanceAddress = _ownerBalanceAddress;\\n    }\\n\\n    /**\\n     * @dev Assigns given amount of contract funds to the owner's balance\\n     * @param amount Amount in wei\\n     */\\n    function _transferToOwnerBalance(uint amount) internal {\\n        ownerBalanceDeposits += amount;\\n    }\\n\\n    /**\\n     * @dev Allows OwnerBalance contract to withdraw deposits\\n     * @param ownerAddress Owner address to send funds to\\n     *\\n     * Requirements:\\n     * - caller must be the OwnerBalance contract\\n     */\\n    function withdrawOwnerBalanceDeposits(address ownerAddress) external {\\n        require(msg.sender == ownerBalanceAddress, 'Caller must be the OwnerBalance contract');\\n        uint currentBalance = ownerBalanceDeposits;\\n        ownerBalanceDeposits = 0;\\n        payable(ownerAddress).transfer(currentBalance);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/Governed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\nimport './Governance.sol';\\n\\n/**\\n * @title Provides permission check modifiers for child contracts\\n */\\nabstract contract Governed {\\n\\n    // Governance contract\\n    Governance public immutable governance;\\n\\n    /**\\n     * @param governanceAddress Address of the Governance contract\\n     *\\n     * Requirements:\\n     * - Governance contract must be deployed at the given address\\n     */\\n    constructor (address governanceAddress) {\\n        governance = Governance(governanceAddress);\\n    }\\n\\n    /**\\n     * @dev Throws if given address that doesn't have ManagesDeaths permission\\n     * @param subject Address to check permissions for, usually msg.sender\\n     */\\n    modifier canManageDeaths(address subject) {\\n        require(\\n            governance.hasPermission(subject, Governance.Actions.ManageDeaths),\\n            \\\"Governance: subject is not allowed to manage deaths\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if given address that doesn't have Configure permission\\n     * @param subject Address to check permissions for, usually msg.sender\\n     */\\n    modifier canConfigure(address subject) {\\n        require(\\n            governance.hasPermission(subject, Governance.Actions.Configure),\\n            \\\"Governance: subject is not allowed to configure contracts\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if given address that doesn't have Bootstrap permission\\n     * @param subject Address to check permissions for, usually msg.sender\\n     */\\n    modifier canBootstrap(address subject) {\\n        require(\\n            governance.hasPermission(subject, Governance.Actions.Bootstrap),\\n            \\\"Governance: subject is not allowed to bootstrap\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if given address that doesn't have SetOwnerAddress permission\\n     * @param subject Address to check permissions for, usually msg.sender\\n     */\\n    modifier canSetOwnerAddress(address subject) {\\n        require(\\n            governance.hasPermission(subject, Governance.Actions.SetOwnerAddress),\\n            \\\"Governance: subject is not allowed to set owner address\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if given address that doesn't have TriggerOwnerWithdraw permission\\n     * @param subject Address to check permissions for, usually msg.sender\\n     */\\n    modifier canTriggerOwnerWithdraw(address subject) {\\n        require(\\n            governance.hasPermission(subject, Governance.Actions.TriggerOwnerWithdraw),\\n            \\\"Governance: subject is not allowed to trigger owner withdraw\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Throws if given address that doesn't have StopPayouyts permission\\n     * @param subject Address to check permissions for, usually msg.sender\\n     */\\n    modifier canStopPayouts(address subject) {\\n        require(\\n            governance.hasPermission(subject, Governance.Actions.StopPayouts),\\n            \\\"Governance: subject is not allowed to stop payouts\\\"\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/Governance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\n/**\\n * @title Manages address permissions to act on Macabris contracts\\n */\\ncontract Governance {\\n\\n    enum Actions { Vote, Configure, SetOwnerAddress, TriggerOwnerWithdraw, ManageDeaths, StopPayouts, Bootstrap }\\n\\n    // Stores permissions of an address\\n    struct Permissions {\\n        bool canVote;\\n        bool canConfigure;\\n        bool canSetOwnerAddress;\\n        bool canTriggerOwnerWithdraw;\\n        bool canManageDeaths;\\n        bool canStopPayouts;\\n\\n        // Special permission that can't be voted in and only the deploying address receives\\n        bool canBootstrap;\\n    }\\n\\n    // A call for vote to change address permissions\\n    struct CallForVote {\\n\\n        // Address that will be assigned the permissions if the vote passes\\n        address subject;\\n\\n        // Permissions to be assigned if the vote passes\\n        Permissions permissions;\\n\\n        // Total number of votes for and against the permission change\\n        uint128 yeas;\\n        uint128 nays;\\n    }\\n\\n    // A vote in a call for vote\\n    struct Vote {\\n        uint64 callForVoteIndex;\\n        bool yeaOrNay;\\n    }\\n\\n    // Permissions of addresses\\n    mapping(address => Permissions) private permissions;\\n\\n    // List of calls for a vote: callForVoteIndex => CallForVote, callForVoteIndex starts from 1\\n    mapping(uint => CallForVote) private callsForVote;\\n\\n    // Last registered call for vote of every address: address => callForVoteIndex\\n    mapping(address => uint64) private lastRegisteredCallForVote;\\n\\n    // Votes of every address: address => Vote\\n    mapping(address => Vote) private votes;\\n\\n    uint64 public resolvedCallsForVote;\\n    uint64 public totalCallsForVote;\\n    uint64 public totalVoters;\\n\\n    /**\\n     * @dev Emitted when a new call for vote is registered\\n     * @param callForVoteIndex Index of the call for vote (1-based)\\n     * @param subject Subject address to change permissions to if vote passes\\n     * @param canVote Allow subject address to vote\\n     * @param canConfigure Allow subject address to configure prices, fees and base URI\\n     * @param canSetOwnerAddress Allows subject to change owner withdraw address\\n     * @param canTriggerOwnerWithdraw Allow subject address to trigger withdraw from owner's balance\\n     * @param canManageDeaths Allow subject to set tokens as dead or alive\\n     * @param canStopPayouts Allow subject to stop the bank payout schedule early\\n     */\\n    event CallForVoteRegistered(\\n        uint64 indexed callForVoteIndex,\\n        address indexed caller,\\n        address indexed subject,\\n        bool canVote,\\n        bool canConfigure,\\n        bool canSetOwnerAddress,\\n        bool canTriggerOwnerWithdraw,\\n        bool canManageDeaths,\\n        bool canStopPayouts\\n    );\\n\\n    /**\\n     * @dev Emitted when a call for vote is resolved\\n     * @param callForVoteIndex Index of the call for vote (1-based)\\n     * @param yeas Total yeas for the call after the vote\\n     * @param nays Total nays for the call after the vote\\n     */\\n    event CallForVoteResolved(\\n        uint64 indexed callForVoteIndex,\\n        uint128 yeas,\\n        uint128 nays\\n    );\\n\\n    /**\\n     * @dev Emitted when a vote is casted\\n     * @param callForVoteIndex Index of the call for vote (1-based)\\n     * @param voter Voter address\\n     * @param yeaOrNay Vote, true if yea, false if nay\\n     * @param totalVoters Total addresses with vote permission at the time of event\\n     * @param yeas Total yeas for the call after the vote\\n     * @param nays Total nays for the call after the vote\\n     */\\n    event VoteCasted(\\n        uint64 indexed callForVoteIndex,\\n        address indexed voter,\\n        bool yeaOrNay,\\n        uint64 totalVoters,\\n        uint128 yeas,\\n        uint128 nays\\n    );\\n\\n    /**\\n     * @dev Inits the contract and gives the deployer address all permissions\\n     */\\n    constructor() {\\n        _setPermissions(msg.sender, Permissions({\\n            canVote: true,\\n            canConfigure: true,\\n            canSetOwnerAddress: true,\\n            canTriggerOwnerWithdraw: true,\\n            canManageDeaths: true,\\n            canStopPayouts: true,\\n            canBootstrap: true\\n        }));\\n    }\\n\\n    /**\\n     * @dev Checks if the given address has permission to perform given action\\n     * @param subject Address to check\\n     * @param action Action to check permissions against\\n     * @return True if given address has permission to perform given action\\n     */\\n    function hasPermission(address subject, Actions action) public view returns (bool) {\\n        if (action == Actions.ManageDeaths) {\\n            return permissions[subject].canManageDeaths;\\n        }\\n\\n        if (action == Actions.Vote) {\\n            return permissions[subject].canVote;\\n        }\\n\\n        if (action == Actions.SetOwnerAddress) {\\n            return permissions[subject].canSetOwnerAddress;\\n        }\\n\\n        if (action == Actions.TriggerOwnerWithdraw) {\\n            return permissions[subject].canTriggerOwnerWithdraw;\\n        }\\n\\n        if (action == Actions.Configure) {\\n            return permissions[subject].canConfigure;\\n        }\\n\\n        if (action == Actions.StopPayouts) {\\n            return permissions[subject].canStopPayouts;\\n        }\\n\\n        if (action == Actions.Bootstrap) {\\n            return permissions[subject].canBootstrap;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * Sets permissions for a given address\\n     * @param subject Subject address to set permissions to\\n     * @param _permissions Permissions\\n     */\\n    function _setPermissions(address subject, Permissions memory _permissions) private {\\n\\n        // Tracks count of total voting addresses to be able to calculate majority\\n        if (permissions[subject].canVote != _permissions.canVote) {\\n            if (_permissions.canVote) {\\n                totalVoters += 1;\\n            } else {\\n                totalVoters -= 1;\\n\\n                // Cleaning up voting-related state for the address\\n                delete votes[subject];\\n                delete lastRegisteredCallForVote[subject];\\n            }\\n        }\\n\\n        permissions[subject] = _permissions;\\n    }\\n\\n    /**\\n     * @dev Registers a new call for vote to change address permissions\\n     * @param subject Subject address to change permissions to if vote passes\\n     * @param canVote Allow subject address to vote\\n     * @param canConfigure Allow subject address to configure prices, fees and base URI\\n     * @param canSetOwnerAddress Allows subject to change owner withdraw address\\n     * @param canTriggerOwnerWithdraw Allow subject address to trigger withdraw from owner's balance\\n     * @param canManageDeaths Allow subject to set tokens as dead or alive\\n     * @param canStopPayouts Allow subject to stop the bank payout schedule early\\n     *\\n     * Requirements:\\n     * - the caller must have the vote permission\\n     * - the caller shouldn't have any unresolved calls for vote\\n     */\\n    function callForVote(\\n        address subject,\\n        bool canVote,\\n        bool canConfigure,\\n        bool canSetOwnerAddress,\\n        bool canTriggerOwnerWithdraw,\\n        bool canManageDeaths,\\n        bool canStopPayouts\\n    ) external {\\n        require(\\n            hasPermission(msg.sender, Actions.Vote),\\n            \\\"Only addresses with vote permission can register a call for vote\\\"\\n        );\\n\\n        // If the sender has previously created a call for vote that hasn't been resolved yet,\\n        // a second call for vote can't be registered. Prevents a denial of service attack, where\\n        // a minority of voters could flood the call for vote queue.\\n        require(\\n            lastRegisteredCallForVote[msg.sender] <= resolvedCallsForVote,\\n            \\\"Only one active call for vote per address is allowed\\\"\\n        );\\n\\n        totalCallsForVote++;\\n\\n        lastRegisteredCallForVote[msg.sender] = totalCallsForVote;\\n\\n        callsForVote[totalCallsForVote] = CallForVote({\\n            subject: subject,\\n            permissions: Permissions({\\n                canVote: canVote,\\n                canConfigure: canConfigure,\\n                canSetOwnerAddress: canSetOwnerAddress,\\n                canTriggerOwnerWithdraw: canTriggerOwnerWithdraw,\\n                canManageDeaths: canManageDeaths,\\n                canStopPayouts: canStopPayouts,\\n                canBootstrap: false\\n            }),\\n            yeas: 0,\\n            nays: 0\\n        });\\n\\n        emit CallForVoteRegistered(\\n            totalCallsForVote,\\n            msg.sender,\\n            subject,\\n            canVote,\\n            canConfigure,\\n            canSetOwnerAddress,\\n            canTriggerOwnerWithdraw,\\n            canManageDeaths,\\n            canStopPayouts\\n        );\\n    }\\n\\n    /**\\n     * @dev Registers a vote\\n     * @param callForVoteIndex Call for vote index\\n     * @param yeaOrNay True to vote yea, false to vote nay\\n     *\\n     * Requirements:\\n     * - unresolved call for vote must exist\\n     * - call for vote index must match the current active call for vote\\n     * - the caller must have the vote permission\\n     */\\n    function vote(uint64 callForVoteIndex, bool yeaOrNay) external {\\n        require(hasUnresolvedCallForVote(), \\\"No unresolved call for vote exists\\\");\\n        require(\\n            callForVoteIndex == _getCurrenCallForVoteIndex(),\\n            \\\"Call for vote does not exist or is not active\\\"\\n        );\\n        require(\\n            hasPermission(msg.sender, Actions.Vote),\\n            \\\"Sender address does not have vote permission\\\"\\n        );\\n\\n        uint128 yeas = callsForVote[callForVoteIndex].yeas;\\n        uint128 nays = callsForVote[callForVoteIndex].nays;\\n\\n        // If the voter has already voted in this call for vote, undo the last vote\\n        if (votes[msg.sender].callForVoteIndex == callForVoteIndex) {\\n            if (votes[msg.sender].yeaOrNay) {\\n                yeas -= 1;\\n            } else {\\n                nays -= 1;\\n            }\\n        }\\n\\n        if (yeaOrNay) {\\n            yeas += 1;\\n        } else {\\n            nays += 1;\\n        }\\n\\n        emit VoteCasted(callForVoteIndex, msg.sender, yeaOrNay, totalVoters, yeas, nays);\\n\\n        if (yeas == (totalVoters / 2 + 1) || nays == (totalVoters - totalVoters / 2)) {\\n\\n            if (yeas > nays) {\\n                _setPermissions(\\n                    callsForVote[callForVoteIndex].subject,\\n                    callsForVote[callForVoteIndex].permissions\\n                );\\n            }\\n\\n            resolvedCallsForVote += 1;\\n\\n            // Cleaning up what we can\\n            delete callsForVote[callForVoteIndex];\\n            delete votes[msg.sender];\\n\\n            emit CallForVoteResolved(callForVoteIndex, yeas, nays);\\n\\n            return;\\n        }\\n\\n        votes[msg.sender] = Vote({\\n            callForVoteIndex: callForVoteIndex,\\n            yeaOrNay: yeaOrNay\\n        });\\n\\n        callsForVote[callForVoteIndex].yeas = yeas;\\n        callsForVote[callForVoteIndex].nays = nays;\\n    }\\n\\n    /**\\n     * @dev Returns information about the current unresolved call for vote\\n     * @return callForVoteIndex Call for vote index (1-based)\\n     * @return yeas Total yea votes\\n     * @return nays Total nay votes\\n     *\\n     * Requirements:\\n     * - Unresolved call for vote must exist\\n     */\\n    function getCurrentCallForVote() public view returns (\\n        uint64 callForVoteIndex,\\n        uint128 yeas,\\n        uint128 nays\\n    ) {\\n        require(hasUnresolvedCallForVote(), \\\"No unresolved call for vote exists\\\");\\n        uint64 index = _getCurrenCallForVoteIndex();\\n        return (index, callsForVote[index].yeas, callsForVote[index].nays);\\n    }\\n\\n    /**\\n     * @dev Checks if there is an unresolved call for vote\\n     * @return True if an unresolved call for vote exists\\n     */\\n    function hasUnresolvedCallForVote() public view returns (bool) {\\n        return totalCallsForVote > resolvedCallsForVote;\\n    }\\n\\n    /**\\n     * @dev Returns current call for vote index\\n     * @return Call for vote index (1-based)\\n     *\\n     * Doesn't check if an unresolved call for vote exists, hasUnresolvedCallForVote should be used\\n     * before using the index that this method returns.\\n     */\\n    function _getCurrenCallForVoteIndex() private view returns (uint64) {\\n        return resolvedCallsForVote + 1;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governanceAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"bank\",\"outputs\":[{\"internalType\":\"contract OwnerBalanceContributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"contract Governance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"market\",\"outputs\":[{\"internalType\":\"contract OwnerBalanceContributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"release\",\"outputs\":[{\"internalType\":\"contract OwnerBalanceContributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bankAddress\",\"type\":\"address\"}],\"name\":\"setBankAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketAddress\",\"type\":\"address\"}],\"name\":\"setMarketAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"releaseAddress\",\"type\":\"address\"}],\"name\":\"setReleaseAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"OwnerBalance","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e609cd7cd8b7ad086a6f781f753641da7ae0e956","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}