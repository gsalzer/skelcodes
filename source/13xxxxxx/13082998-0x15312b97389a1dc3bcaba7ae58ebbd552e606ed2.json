{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/producers/crowdfunds/crowdfund-with-podium-editions/CrowdfundWithPodiumEditionsFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {CrowdfundWithPodiumEditionsProxy} from \\\"./CrowdfundWithPodiumEditionsProxy.sol\\\";\\nimport {CrowdfundWithPodiumEditionsLogic} from \\\"./CrowdfundWithPodiumEditionsLogic.sol\\\";\\nimport {ICrowdfundWithPodiumEditions} from \\\"./interface/ICrowdfundWithPodiumEditions.sol\\\";\\nimport {ITributaryRegistry} from \\\"../../../interface/ITributaryRegistry.sol\\\";\\nimport {Governable} from \\\"../../../lib/Governable.sol\\\";\\n\\n/**\\n * @title CrowdfundWithPodiumEditionsFactory\\n * @author MirrorXYZ\\n */\\ncontract CrowdfundWithPodiumEditionsFactory is Governable {\\n    //======== Structs ========\\n\\n    struct Parameters {\\n        address payable fundingRecipient;\\n        uint256 fundingCap;\\n        uint256 operatorPercent;\\n        string name;\\n        string symbol;\\n        uint256 feePercentage;\\n        uint256 podiumDuration;\\n    }\\n\\n    //======== Events ========\\n\\n    event CrowdfundDeployed(\\n        address crowdfundProxy,\\n        string name,\\n        string symbol,\\n        address operator\\n    );\\n\\n    //======== Configuration storage =========\\n\\n    /*\\n        Updatable via governance\\n    */\\n\\n    address public logic;\\n    address payable public editions;\\n    address public tributaryRegistry;\\n    address public treasuryConfig;\\n    uint256 public minFeePercentage = 250;\\n\\n    //======== Runtime mutable storage =========\\n\\n    // Gets set within the block, and then deleted.\\n    Parameters public parameters;\\n\\n    //======== Constructor =========\\n\\n    constructor(\\n        address owner_,\\n        address logic_,\\n        address payable editions_,\\n        address tributaryRegistry_,\\n        address treasuryConfig_\\n    ) Governable(owner_) {\\n        logic = logic_;\\n        editions = editions_;\\n        tributaryRegistry = tributaryRegistry_;\\n        treasuryConfig = treasuryConfig_;\\n    }\\n\\n    //======== Configuration =========\\n\\n    function setMinimumFeePercentage(uint256 newMinFeePercentage)\\n        public\\n        onlyGovernance\\n    {\\n        minFeePercentage = newMinFeePercentage;\\n    }\\n\\n    function setEditions(address payable newEditions) public onlyGovernance {\\n        editions = newEditions;\\n    }\\n\\n    function setLogic(address newLogic) public onlyGovernance {\\n        logic = newLogic;\\n    }\\n\\n    function setTreasuryConfig(address newTreasuryConfig)\\n        public\\n        onlyGovernance\\n    {\\n        treasuryConfig = newTreasuryConfig;\\n    }\\n\\n    function setTributaryRegistry(address newTributaryRegistry)\\n        public\\n        onlyGovernance\\n    {\\n        tributaryRegistry = newTributaryRegistry;\\n    }\\n\\n    //======== Deploy function =========\\n    struct TributaryConfig {\\n        address tributary;\\n        uint256 feePercentage;\\n    }\\n\\n    function createCrowdfund(\\n        ICrowdfundWithPodiumEditions.EditionTier[] calldata tiers,\\n        TributaryConfig calldata tributaryConfig,\\n        string calldata name_,\\n        string calldata symbol_,\\n        address payable operator_,\\n        address payable fundingRecipient_,\\n        uint256 fundingCap_,\\n        uint256 operatorPercent_,\\n        uint256 podiumDuration_\\n    ) external returns (address crowdfundProxy) {\\n        require(\\n            tributaryConfig.feePercentage >= minFeePercentage,\\n            \\\"fee is too low\\\"\\n        );\\n\\n        parameters = Parameters({\\n            name: name_,\\n            symbol: symbol_,\\n            fundingRecipient: fundingRecipient_,\\n            fundingCap: fundingCap_,\\n            operatorPercent: operatorPercent_,\\n            feePercentage: tributaryConfig.feePercentage,\\n            podiumDuration: podiumDuration_\\n        });\\n\\n        crowdfundProxy = address(\\n            new CrowdfundWithPodiumEditionsProxy{\\n                salt: keccak256(abi.encode(symbol_, operator_))\\n            }(treasuryConfig, operator_)\\n        );\\n\\n        delete parameters;\\n\\n        emit CrowdfundDeployed(crowdfundProxy, name_, symbol_, operator_);\\n\\n        ITributaryRegistry(tributaryRegistry).registerTributary(\\n            crowdfundProxy,\\n            tributaryConfig.tributary\\n        );\\n\\n        ICrowdfundWithPodiumEditions(editions).createEditions(\\n            tiers,\\n            payable(crowdfundProxy),\\n            crowdfundProxy\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/producers/crowdfunds/crowdfund-with-podium-editions/CrowdfundWithPodiumEditionsProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {CrowdfundWithPodiumEditionsStorage} from \\\"./CrowdfundWithPodiumEditionsStorage.sol\\\";\\n\\ninterface ICrowdfundWithPodiumEditionsFactory {\\n    function mediaAddress() external returns (address);\\n\\n    function logic() external returns (address);\\n\\n    function editions() external returns (address);\\n\\n    // ERC20 data.\\n    function parameters()\\n        external\\n        returns (\\n            address payable fundingRecipient,\\n            uint256 fundingCap,\\n            uint256 operatorPercent,\\n            string memory name,\\n            string memory symbol,\\n            uint256 feePercentage,\\n            uint256 podiumDuration\\n        );\\n}\\n\\n/**\\n * @title CrowdfundWithPodiumEditionsProxy\\n * @author MirrorXYZ\\n */\\ncontract CrowdfundWithPodiumEditionsProxy is\\n    CrowdfundWithPodiumEditionsStorage\\n{\\n    constructor(address treasuryConfig_, address payable operator_) {\\n        logic = ICrowdfundWithPodiumEditionsFactory(msg.sender).logic();\\n        editions = ICrowdfundWithPodiumEditionsFactory(msg.sender).editions();\\n        // Crowdfund-specific data.\\n        (\\n            fundingRecipient,\\n            fundingCap,\\n            operatorPercent,\\n            name,\\n            symbol,\\n            feePercentage,\\n            podiumDuration\\n        ) = ICrowdfundWithPodiumEditionsFactory(msg.sender).parameters();\\n\\n        operator = operator_;\\n        treasuryConfig = treasuryConfig_;\\n        // Initialize mutable storage.\\n        status = Status.FUNDING;\\n    }\\n\\n    fallback() external payable {\\n        address _impl = logic;\\n        assembly {\\n            let ptr := mload(0x40)\\n            calldatacopy(ptr, 0, calldatasize())\\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\\n            let size := returndatasize()\\n            returndatacopy(ptr, 0, size)\\n\\n            switch result\\n            case 0 {\\n                revert(ptr, size)\\n            }\\n            default {\\n                return(ptr, size)\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/producers/crowdfunds/crowdfund-with-podium-editions/CrowdfundWithPodiumEditionsLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {CrowdfundWithPodiumEditionsStorage} from \\\"./CrowdfundWithPodiumEditionsStorage.sol\\\";\\nimport {ICrowdfundWithPodiumEditions} from \\\"./interface/ICrowdfundWithPodiumEditions.sol\\\";\\nimport {ITreasuryConfig} from \\\"../../../interface/ITreasuryConfig.sol\\\";\\n\\n/**\\n * @title CrowdfundWithPodiumEditionsLogic\\n * @author MirrorXYZ\\n *\\n * Crowdfund the creation of NFTs by issuing ERC20 tokens that\\n * can be redeemed for the underlying value of the NFT once sold.\\n */\\ncontract CrowdfundWithPodiumEditionsLogic is\\n    CrowdfundWithPodiumEditionsStorage\\n{\\n    // ============ Events ============\\n\\n    event ReceivedERC721(uint256 tokenId, address sender);\\n    event Contribution(address contributor, uint256 amount);\\n    event ContributionForEdition(\\n        address contributor,\\n        uint256 amount,\\n        uint256 editionId,\\n        uint256 tokenId\\n    );\\n\\n    event FundingClosed(uint256 amountRaised, uint256 creatorAllocation);\\n    event BidAccepted(uint256 amount);\\n    event Redeemed(address contributor, uint256 amount);\\n    // ERC20 Events\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    // Podium Events\\n    event PodiumDurationExtended(uint256 editionId);\\n\\n    // ============ Modifiers ============\\n\\n    /**\\n     * @dev Modifier to check whether the `msg.sender` is the operator.\\n     * If it is, it will run the function. Otherwise, it will revert.\\n     */\\n    modifier onlyOperator() {\\n        require(msg.sender == operator);\\n        _;\\n    }\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(reentrancy_status != REENTRANCY_ENTERED, \\\"Reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        reentrancy_status = REENTRANCY_ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        reentrancy_status = REENTRANCY_NOT_ENTERED;\\n    }\\n\\n    // ============ Crowdfunding Methods ============\\n\\n    function contributeForPodium(\\n        address payable backer,\\n        uint256 editionId,\\n        uint256 amount\\n    ) external payable nonReentrant {\\n        _contribute(backer, editionId, amount, true);\\n    }\\n\\n    /**\\n     * @notice Mints tokens for the sender propotional to the\\n     *  amount of ETH sent in the transaction.\\n     * @dev Emits the Contribution event.\\n     */\\n    function contribute(\\n        address payable backer,\\n        uint256 editionId,\\n        uint256 amount\\n    ) external payable nonReentrant {\\n        _contribute(backer, editionId, amount, false);\\n    }\\n\\n    /**\\n     * @notice Burns the sender's tokens and redeems underlying ETH.\\n     * @dev Emits the Redeemed event.\\n     */\\n    function redeem(uint256 tokenAmount) external nonReentrant {\\n        // Prevent backers from accidently redeeming when balance is 0.\\n        require(\\n            address(this).balance > 0,\\n            \\\"Crowdfund: No ETH available to redeem\\\"\\n        );\\n        // Check\\n        require(\\n            balanceOf[msg.sender] >= tokenAmount,\\n            \\\"Crowdfund: Insufficient balance\\\"\\n        );\\n        require(status == Status.TRADING, \\\"Crowdfund: Funding must be trading\\\");\\n        // Effect\\n        uint256 redeemable = redeemableFromTokens(tokenAmount);\\n        _burn(msg.sender, tokenAmount);\\n        // Safe version of transfer.\\n        sendValue(payable(msg.sender), redeemable);\\n        emit Redeemed(msg.sender, redeemable);\\n    }\\n\\n    /**\\n     * @notice Returns the amount of ETH that is redeemable for tokenAmount.\\n     */\\n    function redeemableFromTokens(uint256 tokenAmount)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return (tokenAmount * address(this).balance) / totalSupply;\\n    }\\n\\n    function valueToTokens(uint256 value) public pure returns (uint256 tokens) {\\n        tokens = value * TOKEN_SCALE;\\n    }\\n\\n    function tokensToValue(uint256 tokenAmount)\\n        internal\\n        pure\\n        returns (uint256 value)\\n    {\\n        value = tokenAmount / TOKEN_SCALE;\\n    }\\n\\n    // ============ Operator Methods ============\\n\\n    /**\\n     * @notice Transfers all funds to operator, and mints tokens for the operator.\\n     *  Updates status to TRADING.\\n     * @dev Emits the FundingClosed event.\\n     */\\n    function closeFunding() external onlyOperator nonReentrant {\\n        require(status == Status.FUNDING, \\\"Crowdfund: Funding must be open\\\");\\n        // Close funding status, move to tradable.\\n        status = Status.TRADING;\\n        // Mint the operator a percent of the total supply.\\n        uint256 operatorTokens = (operatorPercent * totalSupply) /\\n            (100 - operatorPercent);\\n        _mint(operator, operatorTokens);\\n        // Announce that funding has been closed.\\n        emit FundingClosed(address(this).balance, operatorTokens);\\n        // Transfer the fee to the treasury.\\n        sendValue(\\n            ITreasuryConfig(treasuryConfig).treasury(),\\n            computeFee(address(this).balance)\\n        );\\n        // Transfer available balance to the fundingRecipient.\\n        sendValue(fundingRecipient, address(this).balance);\\n    }\\n\\n    function computeFee(uint256 amount) public view returns (uint256 fee) {\\n        fee = (feePercentage * amount) / (100 * 100);\\n    }\\n\\n    // ============ Utility Methods ============\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance >= amount,\\n            \\\"Address: insufficient balance\\\"\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(\\n            success,\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n\\n    // ============ ERC20 Spec ============\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply + value;\\n        balanceOf[to] = balanceOf[to] + value;\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] = balanceOf[from] - value;\\n        totalSupply = totalSupply - value;\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) private {\\n        balanceOf[from] = balanceOf[from] - value;\\n        balanceOf[to] = balanceOf[to] + value;\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool) {\\n        allowance[from][msg.sender] = allowance[from][msg.sender] - value;\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    // ============ Tiered Campaigns ============\\n\\n    function buyEdition(\\n        uint256 amount,\\n        uint256 editionId,\\n        address recipient\\n    ) internal returns (uint256) {\\n        // Check that the sender is paying the correct amount.\\n        require(\\n            amount >=\\n                ICrowdfundWithPodiumEditions(editions).editionPrice(editionId),\\n            \\\"Unable purchase edition with available amount\\\"\\n        );\\n        // We don't need to transfer the value to the NFT contract here,\\n        // since that contract trusts this one to check before minting.\\n        // I.E. this contract has minting privileges.\\n        return\\n            ICrowdfundWithPodiumEditions(editions).buyEdition(\\n                editionId,\\n                recipient\\n            );\\n    }\\n\\n    function buyEditionForPodium(\\n        uint256 amount,\\n        uint256 editionId,\\n        address recipient\\n    ) internal returns (uint256) {\\n        // Check that the sender is paying the correct amount.\\n        require(\\n            amount >=\\n                ICrowdfundWithPodiumEditions(editions).editionPrice(editionId),\\n            \\\"Unable purchase edition with available amount\\\"\\n        );\\n\\n        if (podiumStartTime == 0) {\\n            podiumStartTime = block.timestamp;\\n        }\\n\\n        uint256 podiumEnds = podiumStartTime + podiumDuration;\\n\\n        require(podiumEnds >= block.timestamp, \\\"podium closed\\\");\\n\\n        if (podiumEnds < block.timestamp + PODIUM_TIME_BUFFER) {\\n            // Extend duration.\\n            podiumDuration += block.timestamp + PODIUM_TIME_BUFFER - podiumEnds;\\n            emit PodiumDurationExtended(editionId);\\n        }\\n\\n        // We don't need to transfer the value to the NFT contract here,\\n        // since that contract trusts this one to check before minting.\\n        // I.E. this contract has minting privileges.\\n        return\\n            ICrowdfundWithPodiumEditions(editions).buyEdition(\\n                editionId,\\n                recipient\\n            );\\n    }\\n\\n    function _contribute(\\n        address payable backer,\\n        uint256 editionId,\\n        uint256 amount,\\n        bool forPodium\\n    ) private {\\n        require(status == Status.FUNDING, \\\"Crowdfund: Funding must be open\\\");\\n        require(amount == msg.value, \\\"Crowdfund: Amount is not value sent\\\");\\n        // This first case is the happy path, so we will keep it efficient.\\n        // The balance, which includes the current contribution, is less than or equal to cap.\\n        if (address(this).balance <= fundingCap) {\\n            // Mint equity for the contributor.\\n            _mint(backer, valueToTokens(amount));\\n\\n            // Editions start at 1, so a \\\"0\\\" edition means the user wants to contribute without\\n            // purchasing a token.\\n            if (editionId > 0) {\\n                emit ContributionForEdition(\\n                    backer,\\n                    amount,\\n                    editionId,\\n                    forPodium\\n                        ? buyEditionForPodium(amount, editionId, backer)\\n                        : buyEdition(amount, editionId, backer)\\n                );\\n            } else {\\n                emit Contribution(backer, amount);\\n            }\\n        } else {\\n            // Compute the balance of the crowdfund before the contribution was made.\\n            uint256 startAmount = address(this).balance - amount;\\n            // If that amount was already greater than the funding cap, then we should revert immediately.\\n            require(\\n                startAmount < fundingCap,\\n                \\\"Crowdfund: Funding cap already reached\\\"\\n            );\\n            // Otherwise, the contribution helped us reach the funding cap. We should\\n            // take what we can until the funding cap is reached, and refund the rest.\\n            uint256 eligibleAmount = fundingCap - startAmount;\\n            // Otherwise, we process the contribution as if it were the minimal amount.\\n            _mint(backer, valueToTokens(eligibleAmount));\\n\\n            if (editionId > 0) {\\n                emit ContributionForEdition(\\n                    backer,\\n                    eligibleAmount,\\n                    editionId,\\n                    // Attempt to purchase edition with eligible amount.\\n                    forPodium\\n                        ? buyEditionForPodium(eligibleAmount, editionId, backer)\\n                        : buyEdition(eligibleAmount, editionId, backer)\\n                );\\n            } else {\\n                emit Contribution(backer, eligibleAmount);\\n            }\\n            // Refund the sender with their contribution (e.g. 2.5 minus the diff - e.g. 1.5 = 1 ETH)\\n            sendValue(backer, amount - eligibleAmount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/producers/crowdfunds/crowdfund-with-podium-editions/interface/ICrowdfundWithPodiumEditions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ICrowdfundWithPodiumEditions {\\n    struct Edition {\\n        // The maximum number of tokens that can be sold.\\n        uint256 quantity;\\n        // The price at which each token will be sold, in ETH.\\n        uint256 price;\\n        // The account that will receive sales revenue.\\n        address payable fundingRecipient;\\n        // The number of tokens sold so far.\\n        uint256 numSold;\\n        bytes32 contentHash;\\n    }\\n\\n    struct EditionTier {\\n        // The maximum number of tokens that can be sold.\\n        uint256 quantity;\\n        // The price at which each token will be sold, in ETH.\\n        uint256 price;\\n        bytes32 contentHash;\\n    }\\n\\n    function buyEdition(uint256 editionId, address recipient)\\n        external\\n        payable\\n        returns (uint256 tokenId);\\n\\n    function editionPrice(uint256 editionId) external view returns (uint256);\\n\\n    function createEditions(\\n        EditionTier[] memory tier,\\n        // The account that should receive the revenue.\\n        address payable fundingRecipient,\\n        address minter\\n    ) external;\\n\\n    function contractURI() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ITributaryRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ITributaryRegistry {\\n    function addRegistrar(address registrar) external;\\n\\n    function removeRegistrar(address registrar) external;\\n\\n    function addSingletonProducer(address producer) external;\\n\\n    function removeSingletonProducer(address producer) external;\\n\\n    function registerTributary(address producer, address tributary) external;\\n\\n    function producerToTributary(address producer)\\n        external\\n        returns (address tributary);\\n\\n    function singletonProducer(address producer) external returns (bool);\\n\\n    function changeTributary(address producer, address newTributary) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {Ownable} from \\\"../lib/Ownable.sol\\\";\\nimport {IGovernable} from \\\"../lib/interface/IGovernable.sol\\\";\\n\\ncontract Governable is Ownable, IGovernable {\\n    // ============ Mutable Storage ============\\n\\n    // Mirror governance contract.\\n    address public override governor;\\n\\n    // ============ Modifiers ============\\n\\n    modifier onlyGovernance() {\\n        require(isOwner() || isGovernor(), \\\"caller is not governance\\\");\\n        _;\\n    }\\n\\n    modifier onlyGovernor() {\\n        require(isGovernor(), \\\"caller is not governor\\\");\\n        _;\\n    }\\n\\n    // ============ Constructor ============\\n\\n    constructor(address owner_) Ownable(owner_) {}\\n\\n    // ============ Administration ============\\n\\n    function changeGovernor(address governor_) public override onlyGovernance {\\n        governor = governor_;\\n    }\\n\\n    // ============ Utility Functions ============\\n\\n    function isGovernor() public view override returns (bool) {\\n        return msg.sender == governor;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/producers/crowdfunds/crowdfund-with-podium-editions/CrowdfundWithPodiumEditionsStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\n/**\\n * @title CrowdfundWithPodiumEditionsStorage\\n * @author MirrorXYZ\\n */\\ncontract CrowdfundWithPodiumEditionsStorage {\\n    // The two states that this contract can exist in. \\\"FUNDING\\\" allows\\n    // contributors to add funds.\\n    enum Status {\\n        FUNDING,\\n        TRADING\\n    }\\n\\n    // ============ Constants ============\\n\\n    // The factor by which ETH contributions will multiply into crowdfund tokens.\\n    uint16 internal constant TOKEN_SCALE = 1000;\\n    uint256 internal constant REENTRANCY_NOT_ENTERED = 1;\\n    uint256 internal constant REENTRANCY_ENTERED = 2;\\n    uint16 public constant PODIUM_TIME_BUFFER = 900;\\n    uint8 public constant decimals = 18;\\n\\n    // ============ Immutable Storage ============\\n\\n    // The operator has a special role to change contract status.\\n    address payable public operator;\\n    address payable public fundingRecipient;\\n    address public treasuryConfig;\\n    // We add a hard cap to prevent raising more funds than deemed reasonable.\\n    uint256 public fundingCap;\\n    uint256 public feePercentage;\\n    // The operator takes some equity in the tokens, represented by this percent.\\n    uint256 public operatorPercent;\\n    string public symbol;\\n    string public name;\\n\\n    // ============ Mutable Storage ============\\n\\n    // Represents the current state of the campaign.\\n    Status public status;\\n    uint256 internal reentrancy_status;\\n\\n\\n    // Podium storage\\n    uint256 public podiumStartTime;\\n    uint256 public podiumDuration;\\n\\n    // ============ Mutable ERC20 Attributes ============\\n\\n    uint256 public totalSupply;\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n    mapping(address => uint256) public nonces;\\n\\n    // ============ Delegation logic ============\\n    address public logic;\\n\\n    // ============ Tiered Campaigns ============\\n    // Address of the editions contract to purchase from.\\n    address public editions;\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ITreasuryConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ITreasuryConfig {\\n    function treasury() external returns (address payable);\\n\\n    function distributionModel() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ncontract Ownable {\\n    address public owner;\\n    address private nextOwner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    // modifiers\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"caller is not the owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyNextOwner() {\\n        require(isNextOwner(), \\\"current owner must set caller as next owner.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize contract by setting transaction submitter as initial owner.\\n     */\\n    constructor(address owner_) {\\n        owner = owner_;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Initiate ownership transfer by setting nextOwner.\\n     */\\n    function transferOwnership(address nextOwner_) external onlyOwner {\\n        require(nextOwner_ != address(0), \\\"Next owner is the zero address.\\\");\\n\\n        nextOwner = nextOwner_;\\n    }\\n\\n    /**\\n     * @dev Cancel ownership transfer by deleting nextOwner.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        delete nextOwner;\\n    }\\n\\n    /**\\n     * @dev Accepts ownership transfer by setting owner.\\n     */\\n    function acceptOwnership() external onlyNextOwner {\\n        delete nextOwner;\\n\\n        owner = msg.sender;\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Renounce ownership by setting owner to zero address.\\n     */\\n    function renounceOwnership() external onlyOwner {\\n        owner = address(0);\\n\\n        emit OwnershipTransferred(owner, address(0));\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the next owner.\\n     */\\n    function isNextOwner() public view returns (bool) {\\n        return msg.sender == nextOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/interface/IGovernable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IGovernable {\\n    function changeGovernor(address governor_) external;\\n\\n    function isGovernor() external view returns (bool);\\n\\n    function governor() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"logic_\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"editions_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tributaryRegistry_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasuryConfig_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"crowdfundProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"CrowdfundDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor_\",\"type\":\"address\"}],\"name\":\"changeGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"contentHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct ICrowdfundWithPodiumEditions.EditionTier[]\",\"name\":\"tiers\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tributary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"}],\"internalType\":\"struct CrowdfundWithPodiumEditionsFactory.TributaryConfig\",\"name\":\"tributaryConfig\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"operator_\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundingRecipient_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fundingCap_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operatorPercent_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"podiumDuration_\",\"type\":\"uint256\"}],\"name\":\"createCrowdfund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"crowdfundProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"editions\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGovernor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"logic\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parameters\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"fundingRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fundingCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operatorPercent\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"podiumDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newEditions\",\"type\":\"address\"}],\"name\":\"setEditions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLogic\",\"type\":\"address\"}],\"name\":\"setLogic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinFeePercentage\",\"type\":\"uint256\"}],\"name\":\"setMinimumFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTreasuryConfig\",\"type\":\"address\"}],\"name\":\"setTreasuryConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTributaryRegistry\",\"type\":\"address\"}],\"name\":\"setTributaryRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tributaryRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CrowdfundWithPodiumEditionsFactory","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"0000000000000000000000002330ee705ffd040bb0cba8cb7734dfe00e7c4b570000000000000000000000005b5746f6f5e2db8bf5e260829ca7a004c876b167000000000000000000000000c4e0f3ec24972c75df7c716922096f4270b7bb4e0000000000000000000000001171b858777120a59a6cc8148edda8982f187cd800000000000000000000000021a93be569666527dae0fdbfbe7715299dec1202","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}