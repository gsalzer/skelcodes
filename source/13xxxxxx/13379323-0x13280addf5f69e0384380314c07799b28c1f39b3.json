{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LostPunksMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport \\\"@openzeppelin/contracts@v4.3/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts@v4.3/access/Ownable.sol\\\";\\n\\ninterface CryptoPunksMarket {\\n    function punkIndexToAddress(uint256) external view returns (address);\\n}\\n\\ninterface LostPunkSociety is IERC721Enumerable {\\n    function punkAttributes(uint16) external view returns (string memory);\\n    function mintLostPunk(uint16, uint16) external payable;\\n}\\n\\n//  ██╗      ██████╗ ███████╗████████╗██████╗ ██╗   ██╗███╗   ██╗██╗  ██╗███████╗███╗   ███╗ █████╗ ██████╗ ██╗  ██╗███████╗████████╗\\n//  ██║     ██╔═══██╗██╔════╝╚══██╔══╝██╔══██╗██║   ██║████╗  ██║██║ ██╔╝██╔════╝████╗ ████║██╔══██╗██╔══██╗██║ ██╔╝██╔════╝╚══██╔══╝\\n//  ██║     ██║   ██║███████╗   ██║   ██████╔╝██║   ██║██╔██╗ ██║█████╔╝ ███████╗██╔████╔██║███████║██████╔╝█████╔╝ █████╗     ██║   \\n//  ██║     ██║   ██║╚════██║   ██║   ██╔═══╝ ██║   ██║██║╚██╗██║██╔═██╗ ╚════██║██║╚██╔╝██║██╔══██║██╔══██╗██╔═██╗ ██╔══╝     ██║   \\n//  ███████╗╚██████╔╝███████║   ██║   ██║     ╚██████╔╝██║ ╚████║██║  ██╗███████║██║ ╚═╝ ██║██║  ██║██║  ██║██║  ██╗███████╗   ██║   \\n//  ╚══════╝ ╚═════╝ ╚══════╝   ╚═╝   ╚═╝      ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═╝╚══════╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝   ╚═╝   \\n                                                                                                                                 \\ncontract LostPunksMarket is Ownable {\\n    event PriceSet(address indexed from, uint256 indexed tokenId, uint256 priceInWei);\\n    event PriceCleared(address indexed from, uint256 indexed tokenId);\\n    event PartnerSet(address indexed from, uint256 indexed tokenId, uint256 indexed partnerTokenId);\\n    event PartnerCleared(address indexed from, uint256 indexed tokenId);\\n    event Claimed(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    CryptoPunksMarket private cryptoPunksMarket;\\n    LostPunkSociety private lostPunkSociety;\\n    mapping(uint16 => address) private virtualOwners;\\n    mapping(uint16 => bool) private hasPriceSet;\\n    mapping(uint16 => uint256) private pricesInWei;\\n    mapping(uint16 => bool) private hasPartnerSet;\\n    mapping(uint16 => uint16) private partners;\\n    \\n    uint256 private GLOBAL_PRICE_IN_WEI;\\n    bool private HAS_GLOBAL_PRICE_SET;\\n    uint16 private constant CRYPTO_PUNKS_COUNT = 10000;\\n\\n    constructor() {\\n        cryptoPunksMarket = CryptoPunksMarket(0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB);\\n        lostPunkSociety = LostPunkSociety(0xa583bEACDF3Ed3808402f8dB4F6628a7E1C6ceC6);\\n    }\\n    \\n//   ██████╗ ██╗    ██╗███╗   ██╗███████╗██████╗     ███████╗██╗   ██╗███╗   ██╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗███████╗\\n//  ██╔═══██╗██║    ██║████╗  ██║██╔════╝██╔══██╗    ██╔════╝██║   ██║████╗  ██║██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║██╔════╝\\n//  ██║   ██║██║ █╗ ██║██╔██╗ ██║█████╗  ██████╔╝    █████╗  ██║   ██║██╔██╗ ██║██║        ██║   ██║██║   ██║██╔██╗ ██║███████╗\\n//  ██║   ██║██║███╗██║██║╚██╗██║██╔══╝  ██╔══██╗    ██╔══╝  ██║   ██║██║╚██╗██║██║        ██║   ██║██║   ██║██║╚██╗██║╚════██║\\n//  ╚██████╔╝╚███╔███╔╝██║ ╚████║███████╗██║  ██║    ██║     ╚██████╔╝██║ ╚████║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║███████║\\n//   ╚═════╝  ╚══╝╚══╝ ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝    ╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝\\n\\n    function destroy() external onlyOwner {\\n        selfdestruct(payable(owner()));\\n    }\\n    \\n    function setGlobalPrice(bool hasGlobalPrice, uint256 globalPriceInWei) external onlyOwner {\\n        HAS_GLOBAL_PRICE_SET = hasGlobalPrice;\\n        GLOBAL_PRICE_IN_WEI = globalPriceInWei;\\n    }\\n    \\n    address private constant giveDirectlyDonationAddress = 0xc7464dbcA260A8faF033460622B23467Df5AEA42;\\n    \\n    function withdraw() external onlyOwner {\\n        uint256 donation = address(this).balance / 10;\\n        payable(giveDirectlyDonationAddress).transfer(donation);\\n        payable(owner()).transfer(address(this).balance); \\n    }\\n    \\n//  ██████╗ ███████╗ █████╗ ██████╗     ███████╗██╗   ██╗███╗   ██╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗███████╗\\n//  ██╔══██╗██╔════╝██╔══██╗██╔══██╗    ██╔════╝██║   ██║████╗  ██║██╔════╝╚══██╔══╝██║██╔═══██╗████╗  ██║██╔════╝\\n//  ██████╔╝█████╗  ███████║██║  ██║    █████╗  ██║   ██║██╔██╗ ██║██║        ██║   ██║██║   ██║██╔██╗ ██║███████╗\\n//  ██╔══██╗██╔══╝  ██╔══██║██║  ██║    ██╔══╝  ██║   ██║██║╚██╗██║██║        ██║   ██║██║   ██║██║╚██╗██║╚════██║\\n//  ██║  ██║███████╗██║  ██║██████╔╝    ██║     ╚██████╔╝██║ ╚████║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║███████║\\n//  ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝     ╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═══╝╚══════╝\\n\\n   function punkIndexToAddress(uint256 punkIndex) public view returns (address) {\\n        require(punkIndex < CRYPTO_PUNKS_COUNT);\\n        address virtualOwner = virtualOwners[uint16(punkIndex)];\\n        return (virtualOwner != address(0)) ? virtualOwner : cryptoPunksMarket.punkIndexToAddress(punkIndex);\\n    }\\n    \\n    function numberOfRemainingChildrenToMintForPunk(uint16 punkIndex) public view returns (uint8) {\\n        uint8 numberOfEmptyChildren = 0;\\n        bytes memory stringAsBytes = bytes(lostPunkSociety.punkAttributes(punkIndex));\\n        bytes memory buffer = new bytes(stringAsBytes.length);\\n\\n        uint j = 0;\\n        for (uint i = 0; i < stringAsBytes.length; i++) {\\n            if (stringAsBytes[i] != \\\",\\\") {\\n                buffer[j++] = stringAsBytes[i];\\n            } else {\\n                if (isEmptyChildAttribute(buffer, j)) {\\n                    numberOfEmptyChildren++;\\n                }\\n                i++; // skip space\\n                j = 0;\\n            }\\n        }\\n        if ((j > 0) && isEmptyChildAttribute(buffer, j)) {\\n            numberOfEmptyChildren++;\\n        }\\n        return numberOfEmptyChildren;\\n    }\\n    \\n    function isEmptyChildAttribute(bytes memory buffer, uint length) internal pure returns (bool) {\\n        return (length == 10) \\n        && (buffer[0] == bytes1('C')) \\n        && (buffer[1] == bytes1('h'))\\n        && (buffer[2] == bytes1('i'))\\n        && (buffer[3] == bytes1('l'))\\n        && (buffer[4] == bytes1('d'));\\n    }\\n\\n    function hasPriceSetToMintRemainingChildrenForPunk(uint16 punkIndex) public view returns (bool) {\\n        require(punkIndex < CRYPTO_PUNKS_COUNT);\\n        return hasPriceSet[punkIndex] || HAS_GLOBAL_PRICE_SET;\\n    }\\n\\n    function getPriceInWeiToMintRemainingChildrenForPunk(uint16 punkIndex) public view returns (uint256) {\\n        require(hasPriceSetToMintRemainingChildrenForPunk(punkIndex));\\n        return hasPriceSet[punkIndex] ? pricesInWei[punkIndex] : GLOBAL_PRICE_IN_WEI;\\n    }\\n\\n//  ████████╗██████╗  █████╗ ██████╗ ██╗███╗   ██╗ ██████╗ \\n//  ╚══██╔══╝██╔══██╗██╔══██╗██╔══██╗██║████╗  ██║██╔════╝ \\n//     ██║   ██████╔╝███████║██║  ██║██║██╔██╗ ██║██║  ███╗\\n//     ██║   ██╔══██╗██╔══██║██║  ██║██║██║╚██╗██║██║   ██║\\n//     ██║   ██║  ██║██║  ██║██████╔╝██║██║ ╚████║╚██████╔╝\\n//     ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝ ╚═════╝ \\n\\n    function setPriceToMintRemainingChildrenForPunk(uint16 punkIndex, uint256 priceInWei) external {\\n        address punkOwner = punkIndexToAddress(punkIndex);\\n        require(punkOwner == msg.sender);\\n        pricesInWei[punkIndex] = priceInWei;\\n        hasPriceSet[punkIndex] = true;\\n        emit PriceSet(punkOwner, punkIndex, priceInWei);\\n    }\\n\\n    function clearPriceToMintRemainingChildrenForPunk(uint16 punkIndex) public {\\n        address punkOwner = punkIndexToAddress(punkIndex);\\n        require(punkOwner == msg.sender);\\n        hasPriceSet[punkIndex] = false;\\n        pricesInWei[punkIndex] = 0;\\n        emit PriceCleared(punkOwner, punkIndex);\\n    }\\n    \\n    function claimRightToMintRemainingChildrenForPunk(uint16 punkIndex) external payable {\\n        require(getPriceInWeiToMintRemainingChildrenForPunk(punkIndex) <= msg.value);\\n        require(numberOfRemainingChildrenToMintForPunk(punkIndex) > 0);\\n\\n        uint256 royalties = msg.value / 10;\\n        address previousOwner = punkIndexToAddress(punkIndex);\\n        payable(previousOwner).transfer(msg.value - royalties);\\n\\n        virtualOwners[punkIndex] = msg.sender;\\n        clearPriceToMintRemainingChildrenForPunk(punkIndex);\\n        clearPartnerToMintChildrenForPunk(punkIndex);\\n\\n        emit Claimed(previousOwner, msg.sender, punkIndex);\\n    }\\n\\n//  ██████╗  █████╗ ██████╗ ████████╗███╗   ██╗███████╗██████╗ ██╗███╗   ██╗ ██████╗ \\n//  ██╔══██╗██╔══██╗██╔══██╗╚══██╔══╝████╗  ██║██╔════╝██╔══██╗██║████╗  ██║██╔════╝ \\n//  ██████╔╝███████║██████╔╝   ██║   ██╔██╗ ██║█████╗  ██████╔╝██║██╔██╗ ██║██║  ███╗\\n//  ██╔═══╝ ██╔══██║██╔══██╗   ██║   ██║╚██╗██║██╔══╝  ██╔══██╗██║██║╚██╗██║██║   ██║\\n//  ██║     ██║  ██║██║  ██║   ██║   ██║ ╚████║███████╗██║  ██║██║██║ ╚████║╚██████╔╝\\n//  ╚═╝     ╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝ ╚═════╝ \\n\\n    function setPartnerToMintChildrenForPunk(uint16 punkIndex, uint16 partnerIndex) external {\\n        address punkOwner = punkIndexToAddress(punkIndex);\\n        require(punkOwner == msg.sender);\\n        partners[punkIndex] = partnerIndex;\\n        hasPartnerSet[punkIndex] = true;\\n        emit PartnerSet(punkOwner, punkIndex, partnerIndex);\\n    }\\n    \\n    function clearPartnerToMintChildrenForPunk(uint16 punkIndex) public {\\n        address punkOwner = punkIndexToAddress(punkIndex);\\n        require(punkOwner == msg.sender);\\n        hasPartnerSet[punkIndex] = false;\\n        partners[punkIndex] = 0;\\n        emit PartnerCleared(punkOwner, punkIndex);\\n    }\\n\\n    function mintDistributedChildrenForPartnerPunks(uint16 fatherIndex, uint16 motherIndex) external {\\n        require(hasPartnerSet[fatherIndex]);\\n        require(hasPartnerSet[motherIndex]);\\n        require(partners[fatherIndex] == motherIndex);\\n        require(partners[motherIndex] == fatherIndex);\\n        require(numberOfRemainingChildrenToMintForPunk(fatherIndex) >= 2);\\n        require(numberOfRemainingChildrenToMintForPunk(motherIndex) >= 2);\\n        \\n        address fatherOwner = punkIndexToAddress(fatherIndex);\\n        address motherOwner = punkIndexToAddress(motherIndex);\\n        virtualOwners[fatherIndex] = address(this);\\n        virtualOwners[motherIndex] = address(this);\\n        \\n        uint256 child1Index = CRYPTO_PUNKS_COUNT + lostPunkSociety.totalSupply();\\n        lostPunkSociety.mintLostPunk(fatherIndex, motherIndex);\\n        uint256 child2Index = CRYPTO_PUNKS_COUNT + lostPunkSociety.totalSupply();\\n        lostPunkSociety.mintLostPunk(fatherIndex, motherIndex);\\n        \\n        lostPunkSociety.safeTransferFrom(address(this), fatherOwner, child1Index);\\n        lostPunkSociety.safeTransferFrom(address(this), motherOwner, child2Index);\\n        \\n        virtualOwners[fatherIndex] = fatherOwner;\\n        virtualOwners[motherIndex] = motherOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@v4.3/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@v4.3/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@v4.3/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@v4.3/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@v4.3/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"PartnerCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"partnerTokenId\",\"type\":\"uint256\"}],\"name\":\"PartnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"PriceCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceInWei\",\"type\":\"uint256\"}],\"name\":\"PriceSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkIndex\",\"type\":\"uint16\"}],\"name\":\"claimRightToMintRemainingChildrenForPunk\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkIndex\",\"type\":\"uint16\"}],\"name\":\"clearPartnerToMintChildrenForPunk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkIndex\",\"type\":\"uint16\"}],\"name\":\"clearPriceToMintRemainingChildrenForPunk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkIndex\",\"type\":\"uint16\"}],\"name\":\"getPriceInWeiToMintRemainingChildrenForPunk\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkIndex\",\"type\":\"uint16\"}],\"name\":\"hasPriceSetToMintRemainingChildrenForPunk\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"fatherIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"motherIndex\",\"type\":\"uint16\"}],\"name\":\"mintDistributedChildrenForPartnerPunks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkIndex\",\"type\":\"uint16\"}],\"name\":\"numberOfRemainingChildrenToMintForPunk\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"punkIndex\",\"type\":\"uint256\"}],\"name\":\"punkIndexToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"hasGlobalPrice\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"globalPriceInWei\",\"type\":\"uint256\"}],\"name\":\"setGlobalPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"partnerIndex\",\"type\":\"uint16\"}],\"name\":\"setPartnerToMintChildrenForPunk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"priceInWei\",\"type\":\"uint256\"}],\"name\":\"setPriceToMintRemainingChildrenForPunk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LostPunksMarket","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}