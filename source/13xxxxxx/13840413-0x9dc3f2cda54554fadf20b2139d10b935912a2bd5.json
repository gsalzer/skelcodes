{"status":"1","message":"OK","result":[{"SourceCode":"{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ninterface IERC20 {\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  function name() external view returns (string memory);\\n  function symbol() external view returns (string memory);\\n  function decimals() external view returns (uint8);\\n  function totalSupply() external view returns (uint);\\n  function balanceOf(address owner) external view returns (uint);\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  function approve(address spender, uint value) external returns (bool);\\n  function transfer(address to, uint value) external returns (bool);\\n  function transferFrom(address from, address to, uint value) external returns (bool);\\n}\"},\"IERC2612.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\n/**\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\n *\\n * Adds the {permit} method, which can be used to change one\\u0027s\\n * {IERC20-allowance} without having to send a transaction, by signing a\\n * message. This allows users to spend tokens without having to hold Ether.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\n */\\ninterface IERC2612 {\\n  function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n  function nonces(address owner) external view returns (uint256);\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\"},\"IERC3156FlashBorrower.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ninterface IERC3156FlashBorrower {\\n  function onFlashLoan(\\n    address initiator,\\n    address token,\\n    uint256 amount,\\n    uint256 fee,\\n    bytes calldata data\\n  ) external returns (bytes32);\\n}\"},\"IERC3156FlashLender.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./IERC3156FlashBorrower.sol\\\";\\n\\ninterface IERC3156FlashLender {\\n  function maxFlashLoan(address token) external view returns (uint256);\\n  function flashFee(address token, uint256 amount) external view returns (uint256);\\n  function flashLoan(\\n      IERC3156FlashBorrower receiver,\\n      address token,\\n      uint256 amount,\\n      bytes calldata data\\n  ) external returns (bool);\\n}\\n\"},\"ITideBitSwapCallee.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ninterface ITideBitSwapCallee {\\n  function TideBitSwapCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\\n}\"},\"ITideBitSwapFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ninterface ITideBitSwapFactory {\\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n  function feeTo() external view returns (address);\\n  function feeToSetter() external view returns (address);\\n\\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\\n  function allPairs(uint) external view returns (address pair);\\n  function allPairsLength() external view returns (uint);\\n\\n  function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n  function setFeeTo(address) external;\\n  function setFeeToSetter(address) external;\\n}\\n\"},\"ITideBitSwapPair.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ninterface ITideBitSwapPair {\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  function name() external pure returns (string memory);\\n  function symbol() external pure returns (string memory);\\n  function decimals() external pure returns (uint8);\\n  function totalSupply() external view returns (uint);\\n  function balanceOf(address owner) external view returns (uint);\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  function approve(address spender, uint value) external returns (bool);\\n  function transfer(address to, uint value) external returns (bool);\\n  function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\n  function nonces(address owner) external view returns (uint);\\n\\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n  event Mint(address indexed sender, uint amount0, uint amount1);\\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n  event Swap(\\n    address indexed sender,\\n    uint amount0In,\\n    uint amount1In,\\n    uint amount0Out,\\n    uint amount1Out,\\n    address indexed to\\n  );\\n  event Sync(uint112 reserve0, uint112 reserve1);\\n\\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\\n  function factory() external view returns (address);\\n  function token0() external view returns (address);\\n  function token1() external view returns (address);\\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n  function price0CumulativeLast() external view returns (uint);\\n  function price1CumulativeLast() external view returns (uint);\\n  function kLast() external view returns (uint);\\n\\n  function mint(address to) external returns (uint liquidity);\\n  function burn(address to) external returns (uint amount0, uint amount1);\\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n  function skim(address to) external;\\n  function sync() external;\\n\\n  function initialize(address, address) external;\\n}\"},\"ITideBitSwapRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPLv3\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ninterface ITideBitSwapRouter {\\n  function factory() external view returns (address);\\n  function WETH() external view returns (address);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB, uint liquidity);\\n  function addLiquidityETH(\\n    address token,\\n    uint amountTokenDesired,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB);\\n  function removeLiquidityETH(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountToken, uint amountETH);\\n  function removeLiquidityWithPermit(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\n  ) external returns (uint amountA, uint amountB);\\n  function removeLiquidityETHWithPermit(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\n  ) external returns (uint amountToken, uint amountETH);\\n  function swapExactTokensForTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n  function swapTokensForExactTokens(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n\\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountETH);\\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\n  ) external returns (uint amountETH);\\n\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable;\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n}\"},\"ITideBitSwapShare.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ninterface ITideBitSwapShare {\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  function name() external pure returns (string memory);\\n  function symbol() external pure returns (string memory);\\n  function decimals() external pure returns (uint8);\\n  function totalSupply() external view returns (uint);\\n  function balanceOf(address owner) external view returns (uint);\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  function approve(address spender, uint value) external returns (bool);\\n  function transfer(address to, uint value) external returns (bool);\\n  function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\n  function nonces(address owner) external view returns (uint);\\n\\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\"},\"IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IERC2612.sol\\\";\\nimport \\\"./IERC3156FlashLender.sol\\\";\\n\\ninterface IWETH is IERC20, IERC2612, IERC3156FlashLender {\\n  function flashMinted() external view returns(uint256);\\n  function deposit() external payable;\\n  function depositTo(address to) external payable;\\n  function withdraw(uint256 value) external;\\n  function withdrawTo(address payable to, uint256 value) external;\\n  function withdrawFrom(address from, address payable to, uint256 value) external;\\n  function depositToAndCall(address to, bytes calldata data) external payable returns (bool);\\n  function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\\n  function transferAndCall(address to, uint value, bytes calldata data) external returns (bool);\\n}\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nlibrary Math {\\n  function min(uint x, uint y) internal pure returns (uint z) {\\n    z = x \\u003c y ? x : y;\\n  }\\n\\n  // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n  function sqrt(uint y) internal pure returns (uint z) {\\n    if (y \\u003e 3) {\\n      z = y;\\n      uint x = y / 2 + 1;\\n      while (x \\u003c z) {\\n        z = x;\\n        x = (y / x + x) / 2;\\n      }\\n    } else if (y != 0) {\\n      z = 1;\\n    }\\n  }\\n}\"},\"Migrations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ncontract Migrations {\\n  address public owner;\\n  uint public last_completed_migration;\\n\\n  modifier restricted() {\\n    if (msg.sender == owner) _;\\n  }\\n\\n  constructor() {\\n    owner = msg.sender;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n\\n  function upgrade(address new_address) public restricted {\\n    Migrations upgraded = Migrations(new_address);\\n    upgraded.setCompleted(last_completed_migration);\\n  }\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n  function add(uint x, uint y) internal pure returns (uint z) {\\n    require((z = x + y) \\u003e= x, \\u0027ds-math-add-overflow\\u0027);\\n  }\\n\\n  function sub(uint x, uint y) internal pure returns (uint z) {\\n    require((z = x - y) \\u003c= x, \\u0027ds-math-sub-underflow\\u0027);\\n  }\\n\\n  function mul(uint x, uint y) internal pure returns (uint z) {\\n    require(y == 0 || (z = x * y) / y == x, \\u0027ds-math-mul-overflow\\u0027);\\n  }\\n}\"},\"TideBitSwapFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPLv3\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\u0027./ITideBitSwapFactory.sol\\u0027;\\nimport \\u0027./TideBitSwapPair.sol\\u0027;\\n\\ncontract TideBitSwapFactory is ITideBitSwapFactory {\\n  address public feeTo;\\n  address public feeToSetter;\\n\\n  mapping(address =\\u003e mapping(address =\\u003e address)) public getPair;\\n  address[] public allPairs;\\n\\n  constructor() {\\n    feeTo = msg.sender;\\n    feeToSetter = msg.sender;\\n  }\\n\\n  function allPairsLength() external view returns (uint) {\\n    return allPairs.length;\\n  }\\n\\n  function createPair(address tokenA, address tokenB) external returns (address pair) {\\n    require(tokenA != tokenB, \\u0027TideBitSwap: IDENTICAL_ADDRESSES\\u0027);\\n    (address token0, address token1) = tokenA \\u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n    require(token0 != address(0), \\u0027TideBitSwap: ZERO_ADDRESS\\u0027);\\n    require(getPair[token0][token1] == address(0), \\u0027TideBitSwap: PAIR_EXISTS\\u0027); // single check is sufficient\\n    bytes memory bytecode = type(TideBitSwapPair).creationCode;\\n    bytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n    assembly {\\n      pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n    }\\n    TideBitSwapPair(pair).initialize(token0, token1);\\n    getPair[token0][token1] = pair;\\n    getPair[token1][token0] = pair; // populate mapping in the reverse direction\\n    allPairs.push(pair);\\n    emit PairCreated(token0, token1, pair, allPairs.length);\\n  }\\n\\n  function setFeeTo(address _feeTo) external {\\n    require(msg.sender == feeToSetter, \\u0027TideBitSwap: FORBIDDEN\\u0027);\\n    feeTo = _feeTo;\\n  }\\n\\n  function setFeeToSetter(address _feeToSetter) external {\\n    require(msg.sender == feeToSetter, \\u0027TideBitSwap: FORBIDDEN\\u0027);\\n    feeToSetter = _feeToSetter;\\n  }\\n}\\n\"},\"TideBitSwapLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: GPLv3\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\u0027./ITideBitSwapPair.sol\\u0027;\\nimport \\u0027./ITideBitSwapFactory.sol\\u0027;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary TideBitSwapLibrary {\\n  using SafeMath for uint;\\n\\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n    require(tokenA != tokenB, \\u0027TideBitSwapLibrary: IDENTICAL_ADDRESSES\\u0027);\\n    (token0, token1) = tokenA \\u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n    require(token0 != address(0), \\u0027TideBitSwapLibrary: ZERO_ADDRESS\\u0027);\\n  }\\n\\n  // calculates the pair address for a pair\\n  function pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) {\\n    pair = ITideBitSwapFactory(factory).getPair(tokenA, tokenB);\\n  }\\n\\n  // fetches and sorts the reserves for a pair\\n  function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\n    (address token0,) = sortTokens(tokenA, tokenB);\\n    (uint reserve0, uint reserve1,) = ITideBitSwapPair(pairFor(factory, tokenA, tokenB)).getReserves();\\n    (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n  }\\n\\n  // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n  function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n    require(amountA \\u003e 0, \\u0027TideBitSwapLibrary: INSUFFICIENT_AMOUNT\\u0027);\\n    require(reserveA \\u003e 0 \\u0026\\u0026 reserveB \\u003e 0, \\u0027TideBitSwapLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n    amountB = amountA.mul(reserveB) / reserveA;\\n  }\\n\\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\n    require(amountIn \\u003e 0, \\u0027TideBitSwapLibrary: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n    require(reserveIn \\u003e 0 \\u0026\\u0026 reserveOut \\u003e 0, \\u0027TideBitSwapLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n    uint amountInWithFee = amountIn.mul(997);\\n    uint numerator = amountInWithFee.mul(reserveOut);\\n    uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n    amountOut = numerator / denominator;\\n  }\\n\\n  // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\\n    require(amountOut \\u003e 0, \\u0027TideBitSwapLibrary: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n    require(reserveIn \\u003e 0 \\u0026\\u0026 reserveOut \\u003e 0, \\u0027TideBitSwapLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n    uint numerator = reserveIn.mul(amountOut).mul(1000);\\n    uint denominator = reserveOut.sub(amountOut).mul(997);\\n    amountIn = (numerator / denominator).add(1);\\n  }\\n\\n  // performs chained getAmountOut calculations on any number of pairs\\n  function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\\n    require(path.length \\u003e= 2, \\u0027TideBitSwapLibrary: INVALID_PATH\\u0027);\\n    amounts = new uint[](path.length);\\n    amounts[0] = amountIn;\\n    for (uint i; i \\u003c path.length - 1; i++) {\\n      (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n    }\\n  }\\n\\n  // performs chained getAmountIn calculations on any number of pairs\\n  function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\\n    require(path.length \\u003e= 2, \\u0027TideBitSwapLibrary: INVALID_PATH\\u0027);\\n    amounts = new uint[](path.length);\\n    amounts[amounts.length - 1] = amountOut;\\n    for (uint i = path.length - 1; i \\u003e 0; i--) {\\n      (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n    }\\n  }\\n}\"},\"TideBitSwapPair.sol\":{\"content\":\"// SPDX-License-Identifier: GPLv3\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\u0027./ITideBitSwapPair.sol\\u0027;\\nimport \\u0027./TideBitSwapShare.sol\\u0027;\\nimport \\u0027./Math.sol\\u0027;\\nimport \\u0027./UQ112x112.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./ITideBitSwapFactory.sol\\u0027;\\nimport \\u0027./ITideBitSwapCallee.sol\\u0027;\\n\\ncontract TideBitSwapPair is TideBitSwapShare {\\n  using SafeMath  for uint;\\n  using UQ112x112 for uint224;\\n\\n  uint public constant MINIMUM_LIQUIDITY = 10**3;\\n  bytes4 private constant SELECTOR = bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\n\\n  address public factory;\\n  address public token0;\\n  address public token1;\\n\\n  uint112 private reserve0;           // uses single storage slot, accessible via getReserves\\n  uint112 private reserve1;           // uses single storage slot, accessible via getReserves\\n  uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\\n\\n  uint public price0CumulativeLast;\\n  uint public price1CumulativeLast;\\n  uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\\n\\n  uint private unlocked = 1;\\n  modifier lock() {\\n    require(unlocked == 1, \\u0027TideBitSwap: LOCKED\\u0027);\\n    unlocked = 0;\\n    _;\\n    unlocked = 1;\\n  }\\n\\n  event Mint(address indexed sender, uint amount0, uint amount1);\\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n  event Swap(\\n    address indexed sender,\\n    uint amount0In,\\n    uint amount1In,\\n    uint amount0Out,\\n    uint amount1Out,\\n    address indexed to\\n  );\\n  event Sync(uint112 reserve0, uint112 reserve1);\\n\\n  function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\\n    _reserve0 = reserve0;\\n    _reserve1 = reserve1;\\n    _blockTimestampLast = blockTimestampLast;\\n  }\\n\\n  function _safeTransfer(address token, address to, uint value) private {\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n    require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TideBitSwap: TRANSFER_FAILED\\u0027);\\n  }\\n\\n  constructor() {\\n      factory = msg.sender;\\n  }\\n\\n  // called once by the factory at time of deployment\\n  function initialize(address _token0, address _token1) external {\\n      require(msg.sender == factory, \\u0027TideBitSwap: FORBIDDEN\\u0027); // sufficient check\\n      token0 = _token0;\\n      token1 = _token1;\\n  }\\n\\n  // update reserves and, on the first call per block, price accumulators\\n  function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {\\n      uint32 blockTimestamp = uint32(block.timestamp % 2**32);\\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n      if (timeElapsed \\u003e 0 \\u0026\\u0026 _reserve0 != 0 \\u0026\\u0026 _reserve1 != 0) {\\n          // * never overflows, and + overflow is desired\\n          price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\\n          price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\\n      }\\n      reserve0 = uint112(balance0);\\n      reserve1 = uint112(balance1);\\n      blockTimestampLast = blockTimestamp;\\n      emit Sync(reserve0, reserve1);\\n  }\\n\\n  // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\\n  function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\\n      address feeTo = ITideBitSwapFactory(factory).feeTo();\\n      feeOn = feeTo != address(0);\\n      uint _kLast = kLast; // gas savings\\n      if (feeOn) {\\n          if (_kLast != 0) {\\n              uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\\n              uint rootKLast = Math.sqrt(_kLast);\\n              if (rootK \\u003e rootKLast) {\\n                  uint numerator = totalSupply.mul(rootK.sub(rootKLast));\\n                  uint denominator = rootK.mul(5).add(rootKLast);\\n                  uint liquidity = numerator / denominator;\\n                  if (liquidity \\u003e 0) _mint(feeTo, liquidity);\\n              }\\n          }\\n      } else if (_kLast != 0) {\\n          kLast = 0;\\n      }\\n  }\\n\\n  // this low-level function should be called from a contract which performs important safety checks\\n  function mint(address to) external lock returns (uint liquidity) {\\n      (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\\n      uint balance0 = IERC20(token0).balanceOf(address(this));\\n      uint balance1 = IERC20(token1).balanceOf(address(this));\\n      uint amount0 = balance0.sub(_reserve0);\\n      uint amount1 = balance1.sub(_reserve1);\\n\\n      bool feeOn = _mintFee(_reserve0, _reserve1);\\n      uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n      if (_totalSupply == 0) {\\n          liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\\n          _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n      } else {\\n          liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\\n      }\\n      require(liquidity \\u003e 0, \\u0027TideBitSwap: INSUFFICIENT_LIQUIDITY_MINTED\\u0027);\\n      _mint(to, liquidity);\\n\\n      _update(balance0, balance1, _reserve0, _reserve1);\\n      if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n      emit Mint(msg.sender, amount0, amount1);\\n  }\\n\\n  // this low-level function should be called from a contract which performs important safety checks\\n  function burn(address to) external lock returns (uint amount0, uint amount1) {\\n      (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\\n      address _token0 = token0;                                // gas savings\\n      address _token1 = token1;                                // gas savings\\n      uint balance0 = IERC20(_token0).balanceOf(address(this));\\n      uint balance1 = IERC20(_token1).balanceOf(address(this));\\n      uint liquidity = balanceOf[address(this)];\\n\\n      bool feeOn = _mintFee(_reserve0, _reserve1);\\n      uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n      amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n      amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n      require(amount0 \\u003e 0 \\u0026\\u0026 amount1 \\u003e 0, \\u0027TideBitSwap: INSUFFICIENT_LIQUIDITY_BURNED\\u0027);\\n      _burn(address(this), liquidity);\\n      _safeTransfer(_token0, to, amount0);\\n      _safeTransfer(_token1, to, amount1);\\n      balance0 = IERC20(_token0).balanceOf(address(this));\\n      balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n      _update(balance0, balance1, _reserve0, _reserve1);\\n      if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\\n      emit Burn(msg.sender, amount0, amount1, to);\\n  }\\n\\n  // this low-level function should be called from a contract which performs important safety checks\\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\\n      require(amount0Out \\u003e 0 || amount1Out \\u003e 0, \\u0027TideBitSwap: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n      (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\\n      require(amount0Out \\u003c _reserve0 \\u0026\\u0026 amount1Out \\u003c _reserve1, \\u0027TideBitSwap: INSUFFICIENT_LIQUIDITY\\u0027);\\n\\n      uint balance0;\\n      uint balance1;\\n      { // scope for _token{0,1}, avoids stack too deep errors\\n      address _token0 = token0;\\n      address _token1 = token1;\\n      require(to != _token0 \\u0026\\u0026 to != _token1, \\u0027TideBitSwap: INVALID_TO\\u0027);\\n      if (amount0Out \\u003e 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\\n      if (amount1Out \\u003e 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\\n      if (data.length \\u003e 0) ITideBitSwapCallee(to).TideBitSwapCall(msg.sender, amount0Out, amount1Out, data);\\n      balance0 = IERC20(_token0).balanceOf(address(this));\\n      balance1 = IERC20(_token1).balanceOf(address(this));\\n      }\\n      uint amount0In = balance0 \\u003e _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\\n      uint amount1In = balance1 \\u003e _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\\n      require(amount0In \\u003e 0 || amount1In \\u003e 0, \\u0027TideBitSwap: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n      { // scope for reserve{0,1}Adjusted, avoids stack too deep errors\\n      uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\\n      uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\\n      require(balance0Adjusted.mul(balance1Adjusted) \\u003e= uint(_reserve0).mul(_reserve1).mul(1000**2), \\u0027TideBitSwap: K\\u0027);\\n      }\\n\\n      _update(balance0, balance1, _reserve0, _reserve1);\\n      emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n  }\\n\\n  // force balances to match reserves\\n  function skim(address to) external lock {\\n      address _token0 = token0; // gas savings\\n      address _token1 = token1; // gas savings\\n      _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\\n      _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\\n  }\\n\\n  // force reserves to match balances\\n  function sync() external lock {\\n      _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\\n  }\\n}\"},\"TideBitSwapRouter.sol\":{\"content\":\"// SPDX-License-Identifier: GPLv3\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\u0027./ITideBitSwapFactory.sol\\u0027;\\nimport \\u0027./TransferHelper.sol\\u0027;\\n\\nimport \\u0027./ITideBitSwapRouter.sol\\u0027;\\nimport \\u0027./TideBitSwapLibrary.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./IERC20.sol\\u0027;\\nimport \\u0027./IWETH.sol\\u0027;\\n\\ncontract TideBitSwapRouter is ITideBitSwapRouter {\\n  using SafeMath for uint;\\n\\n  address public immutable override factory;\\n  address public immutable override WETH;\\n\\n  modifier ensure(uint deadline) {\\n    require(deadline \\u003e= block.timestamp, \\u0027TideBitSwapRouter: EXPIRED\\u0027);\\n    _;\\n  }\\n\\n  constructor(address _factory, address _WETH) {\\n    factory = _factory;\\n    WETH = _WETH;\\n  }\\n\\n  receive() external payable {\\n    assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n  }\\n\\n  // **** ADD LIQUIDITY ****\\n  function _addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin\\n  ) internal virtual returns (uint amountA, uint amountB) {\\n    // create the pair if it doesn\\u0027t exist yet\\n    if (ITideBitSwapFactory(factory).getPair(tokenA, tokenB) == address(0)) {\\n      ITideBitSwapFactory(factory).createPair(tokenA, tokenB);\\n    }\\n    (uint reserveA, uint reserveB) = TideBitSwapLibrary.getReserves(factory, tokenA, tokenB);\\n    if (reserveA == 0 \\u0026\\u0026 reserveB == 0) {\\n      (amountA, amountB) = (amountADesired, amountBDesired);\\n    } else {\\n      uint amountBOptimal = TideBitSwapLibrary.quote(amountADesired, reserveA, reserveB);\\n      if (amountBOptimal \\u003c= amountBDesired) {\\n        require(amountBOptimal \\u003e= amountBMin, \\u0027TideBitSwapRouter: INSUFFICIENT_B_AMOUNT\\u0027);\\n        (amountA, amountB) = (amountADesired, amountBOptimal);\\n      } else {\\n        uint amountAOptimal = TideBitSwapLibrary.quote(amountBDesired, reserveB, reserveA);\\n        assert(amountAOptimal \\u003c= amountADesired);\\n        require(amountAOptimal \\u003e= amountAMin, \\u0027TideBitSwapRouter: INSUFFICIENT_A_AMOUNT\\u0027);\\n        (amountA, amountB) = (amountAOptimal, amountBDesired);\\n      }\\n    }\\n  }\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\\n    (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\\n    address pair = TideBitSwapLibrary.pairFor(factory, tokenA, tokenB);\\n    TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\\n    TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\\n    liquidity = ITideBitSwapPair(pair).mint(to);\\n  }\\n  function addLiquidityETH(\\n    address token,\\n    uint amountTokenDesired,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) {\\n    (amountToken, amountETH) = _addLiquidity(\\n      token,\\n      WETH,\\n      amountTokenDesired,\\n      msg.value,\\n      amountTokenMin,\\n      amountETHMin\\n    );\\n    address pair = TideBitSwapLibrary.pairFor(factory, token, WETH);\\n    TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\\n    IWETH(WETH).deposit{value: amountETH}();\\n    assert(IWETH(WETH).transfer(pair, amountETH));\\n    liquidity = ITideBitSwapPair(pair).mint(to);\\n    // refund dust eth, if any\\n    if (msg.value \\u003e amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\\n  }\\n\\n  // **** REMOVE LIQUIDITY ****\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\\n    address pair = TideBitSwapLibrary.pairFor(factory, tokenA, tokenB);\\n    ITideBitSwapPair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n    (uint amount0, uint amount1) = ITideBitSwapPair(pair).burn(to);\\n    (address token0,) = TideBitSwapLibrary.sortTokens(tokenA, tokenB);\\n    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\\n    require(amountA \\u003e= amountAMin, \\u0027TideBitSwapRouter: INSUFFICIENT_A_AMOUNT\\u0027);\\n    require(amountB \\u003e= amountBMin, \\u0027TideBitSwapRouter: INSUFFICIENT_B_AMOUNT\\u0027);\\n  }\\n  function removeLiquidityETH(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\\n    (amountToken, amountETH) = removeLiquidity(\\n      token,\\n      WETH,\\n      liquidity,\\n      amountTokenMin,\\n      amountETHMin,\\n      address(this),\\n      deadline\\n    );\\n    TransferHelper.safeTransfer(token, to, amountToken);\\n    IWETH(WETH).withdraw(amountETH);\\n    TransferHelper.safeTransferETH(to, amountETH);\\n  }\\n  function removeLiquidityWithPermit(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\n  ) external virtual override returns (uint amountA, uint amountB) {\\n    address pair = TideBitSwapLibrary.pairFor(factory, tokenA, tokenB);\\n    uint value = approveMax ? (2**256 - 1) : liquidity;\\n    ITideBitSwapPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n    (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\\n  }\\n  function removeLiquidityETHWithPermit(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\n  ) external virtual override returns (uint amountToken, uint amountETH) {\\n    address pair = TideBitSwapLibrary.pairFor(factory, token, WETH);\\n    uint value = approveMax ? (2**256 - 1) : liquidity;\\n    ITideBitSwapPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n    (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\\n  }\\n\\n  // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) public virtual override ensure(deadline) returns (uint amountETH) {\\n    (, amountETH) = removeLiquidity(\\n      token,\\n      WETH,\\n      liquidity,\\n      amountTokenMin,\\n      amountETHMin,\\n      address(this),\\n      deadline\\n    );\\n    TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\\n    IWETH(WETH).withdraw(amountETH);\\n    TransferHelper.safeTransferETH(to, amountETH);\\n  }\\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\n  ) external virtual override returns (uint amountETH) {\\n    address pair = TideBitSwapLibrary.pairFor(factory, token, WETH);\\n    uint value = approveMax ? (2**256 - 1) : liquidity;\\n    ITideBitSwapPair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\\n    amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\\n      token, liquidity, amountTokenMin, amountETHMin, to, deadline\\n    );\\n  }\\n\\n  // **** SWAP ****\\n  // requires the initial amount to have already been sent to the first pair\\n  function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\\n    for (uint i; i \\u003c path.length - 1; i++) {\\n      (address input, address output) = (path[i], path[i + 1]);\\n      (address token0,) = TideBitSwapLibrary.sortTokens(input, output);\\n      uint amountOut = amounts[i + 1];\\n      (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\\n      address to = i \\u003c path.length - 2 ? TideBitSwapLibrary.pairFor(factory, output, path[i + 2]) : _to;\\n      ITideBitSwapPair(TideBitSwapLibrary.pairFor(factory, input, output)).swap(\\n        amount0Out, amount1Out, to, new bytes(0)\\n      );\\n    }\\n  }\\n  function swapExactTokensForTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n    amounts = TideBitSwapLibrary.getAmountsOut(factory, amountIn, path);\\n    require(amounts[amounts.length - 1] \\u003e= amountOutMin, \\u0027TideBitSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n    TransferHelper.safeTransferFrom(\\n      path[0], msg.sender, TideBitSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n    );\\n    _swap(amounts, path, to);\\n  }\\n  function swapTokensForExactTokens(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\\n    amounts = TideBitSwapLibrary.getAmountsIn(factory, amountOut, path);\\n    require(amounts[0] \\u003c= amountInMax, \\u0027TideBitSwapRouter: EXCESSIVE_INPUT_AMOUNT\\u0027);\\n    TransferHelper.safeTransferFrom(\\n      path[0], msg.sender, TideBitSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n    );\\n    _swap(amounts, path, to);\\n  }\\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    virtual\\n    override\\n    payable\\n    ensure(deadline)\\n    returns (uint[] memory amounts)\\n  {\\n    require(path[0] == WETH, \\u0027TideBitSwapRouter: INVALID_PATH\\u0027);\\n    amounts = TideBitSwapLibrary.getAmountsOut(factory, msg.value, path);\\n    require(amounts[amounts.length - 1] \\u003e= amountOutMin, \\u0027TideBitSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n    IWETH(WETH).deposit{value: amounts[0]}();\\n    assert(IWETH(WETH).transfer(TideBitSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\\n    _swap(amounts, path, to);\\n  }\\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n    external\\n    virtual\\n    override\\n    ensure(deadline)\\n    returns (uint[] memory amounts)\\n  {\\n    require(path[path.length - 1] == WETH, \\u0027TideBitSwapRouter: INVALID_PATH\\u0027);\\n    amounts = TideBitSwapLibrary.getAmountsIn(factory, amountOut, path);\\n    require(amounts[0] \\u003c= amountInMax, \\u0027TideBitSwapRouter: EXCESSIVE_INPUT_AMOUNT\\u0027);\\n    TransferHelper.safeTransferFrom(\\n      path[0], msg.sender, TideBitSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n    );\\n    _swap(amounts, path, address(this));\\n    IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n    TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n  }\\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    virtual\\n    override\\n    ensure(deadline)\\n    returns (uint[] memory amounts)\\n  {\\n    require(path[path.length - 1] == WETH, \\u0027TideBitSwapRouter: INVALID_PATH\\u0027);\\n    amounts = TideBitSwapLibrary.getAmountsOut(factory, amountIn, path);\\n    require(amounts[amounts.length - 1] \\u003e= amountOutMin, \\u0027TideBitSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n    TransferHelper.safeTransferFrom(\\n      path[0], msg.sender, TideBitSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]\\n    );\\n    _swap(amounts, path, address(this));\\n    IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n    TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n  }\\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n    external\\n    virtual\\n    override\\n    payable\\n    ensure(deadline)\\n    returns (uint[] memory amounts)\\n  {\\n    require(path[0] == WETH, \\u0027TideBitSwapRouter: INVALID_PATH\\u0027);\\n    amounts = TideBitSwapLibrary.getAmountsIn(factory, amountOut, path);\\n    require(amounts[0] \\u003c= msg.value, \\u0027TideBitSwapRouter: EXCESSIVE_INPUT_AMOUNT\\u0027);\\n    IWETH(WETH).deposit{value: amounts[0]}();\\n    assert(IWETH(WETH).transfer(TideBitSwapLibrary.pairFor(factory, path[0], path[1]), amounts[0]));\\n    _swap(amounts, path, to);\\n    // refund dust eth, if any\\n    if (msg.value \\u003e amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\\n  }\\n\\n  // **** SWAP (supporting fee-on-transfer tokens) ****\\n  // requires the initial amount to have already been sent to the first pair\\n  function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\\n    for (uint i; i \\u003c path.length - 1; i++) {\\n      (address input, address output) = (path[i], path[i + 1]);\\n      (address token0,) = TideBitSwapLibrary.sortTokens(input, output);\\n      ITideBitSwapPair pair = ITideBitSwapPair(TideBitSwapLibrary.pairFor(factory, input, output));\\n      uint amountInput;\\n      uint amountOutput;\\n      { // scope to avoid stack too deep errors\\n      (uint reserve0, uint reserve1,) = pair.getReserves();\\n      (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n      amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\\n      amountOutput = TideBitSwapLibrary.getAmountOut(amountInput, reserveInput, reserveOutput);\\n      }\\n      (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\\n      address to = i \\u003c path.length - 2 ? TideBitSwapLibrary.pairFor(factory, output, path[i + 2]) : _to;\\n      pair.swap(amount0Out, amount1Out, to, new bytes(0));\\n    }\\n  }\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external virtual override ensure(deadline) {\\n    TransferHelper.safeTransferFrom(\\n      path[0], msg.sender, TideBitSwapLibrary.pairFor(factory, path[0], path[1]), amountIn\\n    );\\n    uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\\n    _swapSupportingFeeOnTransferTokens(path, to);\\n    require(\\n      IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) \\u003e= amountOutMin,\\n      \\u0027TideBitSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT\\u0027\\n    );\\n  }\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  )\\n    external\\n    virtual\\n    override\\n    payable\\n    ensure(deadline)\\n  {\\n    require(path[0] == WETH, \\u0027TideBitSwapRouter: INVALID_PATH\\u0027);\\n    uint amountIn = msg.value;\\n    IWETH(WETH).deposit{value: amountIn}();\\n    assert(IWETH(WETH).transfer(TideBitSwapLibrary.pairFor(factory, path[0], path[1]), amountIn));\\n    uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\\n    _swapSupportingFeeOnTransferTokens(path, to);\\n    require(\\n      IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) \\u003e= amountOutMin,\\n      \\u0027TideBitSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT\\u0027\\n    );\\n  }\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  )\\n    external\\n    virtual\\n    override\\n    ensure(deadline)\\n  {\\n    require(path[path.length - 1] == WETH, \\u0027TideBitSwapRouter: INVALID_PATH\\u0027);\\n    TransferHelper.safeTransferFrom(\\n      path[0], msg.sender, TideBitSwapLibrary.pairFor(factory, path[0], path[1]), amountIn\\n    );\\n    _swapSupportingFeeOnTransferTokens(path, address(this));\\n    uint amountOut = IERC20(WETH).balanceOf(address(this));\\n    require(amountOut \\u003e= amountOutMin, \\u0027TideBitSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n    IWETH(WETH).withdraw(amountOut);\\n    TransferHelper.safeTransferETH(to, amountOut);\\n  }\\n\\n  // **** LIBRARY FUNCTIONS ****\\n  function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) {\\n    return TideBitSwapLibrary.quote(amountA, reserveA, reserveB);\\n  }\\n\\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\\n    public\\n    pure\\n    virtual\\n    override\\n    returns (uint amountOut)\\n  {\\n    return TideBitSwapLibrary.getAmountOut(amountIn, reserveIn, reserveOut);\\n  }\\n\\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\\n    public\\n    pure\\n    virtual\\n    override\\n    returns (uint amountIn)\\n  {\\n    return TideBitSwapLibrary.getAmountIn(amountOut, reserveIn, reserveOut);\\n  }\\n\\n  function getAmountsOut(uint amountIn, address[] memory path)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (uint[] memory amounts)\\n  {\\n    return TideBitSwapLibrary.getAmountsOut(factory, amountIn, path);\\n  }\\n\\n  function getAmountsIn(uint amountOut, address[] memory path)\\n    public\\n    view\\n    virtual\\n    override\\n    returns (uint[] memory amounts)\\n  {\\n    return TideBitSwapLibrary.getAmountsIn(factory, amountOut, path);\\n  }\\n}\"},\"TideBitSwapShare.sol\":{\"content\":\"// SPDX-License-Identifier: GPLv3\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\u0027./ITideBitSwapShare.sol\\u0027;\\nimport \\u0027./SafeMath.sol\\u0027;\\n\\ncontract TideBitSwapShare is ITideBitSwapShare {\\n  using SafeMath for uint;\\n\\n  string public constant name = \\u0027TideBit Swap\\u0027;\\n  string public constant symbol = \\u0027TBS\\u0027;\\n  uint8 public constant decimals = 18;\\n  uint public totalSupply;\\n  mapping(address =\\u003e uint) public balanceOf;\\n  mapping(address =\\u003e mapping(address =\\u003e uint)) public allowance;\\n\\n  bytes32 public DOMAIN_SEPARATOR;\\n  bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n  mapping(address =\\u003e uint) public nonces;\\n\\n  constructor() {\\n    uint chainId;\\n    assembly {\\n      chainId := chainid()\\n    }\\n    DOMAIN_SEPARATOR = keccak256(\\n      abi.encode(\\n        keccak256(\\u0027EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\u0027),\\n        keccak256(bytes(name)),\\n        keccak256(bytes(\\u00271\\u0027)),\\n        chainId,\\n        address(this)\\n      )\\n    );\\n  }\\n\\n  function _mint(address to, uint value) internal {\\n    totalSupply = totalSupply.add(value);\\n    balanceOf[to] = balanceOf[to].add(value);\\n    emit Transfer(address(0), to, value);\\n  }\\n\\n  function _burn(address from, uint value) internal {\\n    balanceOf[from] = balanceOf[from].sub(value);\\n    totalSupply = totalSupply.sub(value);\\n    emit Transfer(from, address(0), value);\\n  }\\n\\n  function _approve(address owner, address spender, uint value) private {\\n    allowance[owner][spender] = value;\\n    emit Approval(owner, spender, value);\\n  }\\n\\n  function _transfer(address from, address to, uint value) private {\\n    balanceOf[from] = balanceOf[from].sub(value);\\n    balanceOf[to] = balanceOf[to].add(value);\\n    emit Transfer(from, to, value);\\n  }\\n\\n  function approve(address spender, uint value) external returns (bool) {\\n    _approve(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  function transfer(address to, uint value) external returns (bool) {\\n    _transfer(msg.sender, to, value);\\n    return true;\\n  }\\n\\n  function transferFrom(address from, address to, uint value) external returns (bool) {\\n    if (allowance[from][msg.sender] \\u003e value) {\\n      allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n    }\\n    _transfer(from, to, value);\\n    return true;\\n  }\\n\\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\\n    require(deadline \\u003e= block.timestamp, \\u0027TideBitSwap: EXPIRED\\u0027);\\n    bytes32 digest = keccak256(\\n      abi.encodePacked(\\n        \\u0027\\\\x19\\\\x01\\u0027,\\n        DOMAIN_SEPARATOR,\\n        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n      )\\n    );\\n    address recoveredAddress = ecrecover(digest, v, r, s);\\n    require(recoveredAddress != address(0) \\u0026\\u0026 recoveredAddress == owner, \\u0027TideBitSwap: INVALID_SIGNATURE\\u0027);\\n    _approve(owner, spender, value);\\n  }\\n}\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n  function safeApprove(\\n    address token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n    require(\\n      success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n      \\u0027TransferHelper::safeApprove: approve failed\\u0027\\n    );\\n  }\\n\\n  function safeTransfer(\\n    address token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n    require(\\n      success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n      \\u0027TransferHelper::safeTransfer: transfer failed\\u0027\\n    );\\n  }\\n\\n  function safeTransferFrom(\\n    address token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\n    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n    require(\\n      success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\n      \\u0027TransferHelper::transferFrom: transferFrom failed\\u0027\\n    );\\n  }\\n\\n  function safeTransferETH(address to, uint256 value) internal {\\n    (bool success, ) = to.call{value: value}(new bytes(0));\\n    require(success, \\u0027TransferHelper::safeTransferETH: ETH transfer failed\\u0027);\\n  }\\n}\"},\"UQ112x112.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n  uint224 constant Q112 = 2**112;\\n\\n  // encode a uint112 as a UQ112x112\\n  function encode(uint112 y) internal pure returns (uint224 z) {\\n    z = uint224(y) * Q112; // never overflows\\n  }\\n\\n  // divide a UQ112x112 by a uint112, returning a UQ112x112\\n  function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n    z = x / uint224(y);\\n  }\\n}\"},\"WETH10.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Copyright (C) 2015, 2016, 2017 Dapphub\\n// Adapted by Ethereum Community 2021\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./IWETH.sol\\\";\\nimport \\\"./IERC3156FlashBorrower.sol\\\";\\n\\ninterface ITransferReceiver {\\n  function onTokenTransfer(address, uint, bytes calldata) external returns (bool);\\n}\\n\\ninterface IApprovalReceiver {\\n  function onTokenApproval(address, uint, bytes calldata) external returns (bool);\\n}\\n\\n/// @dev Wrapped Ether v10 (WETH10) is an Ether (ETH) ERC-20 wrapper. You can `deposit` ETH and obtain a WETH10 balance which can then be operated as an ERC-20 token. You can\\n/// `withdraw` ETH from WETH10, which will then burn WETH10 token in your wallet. The amount of WETH10 token in any wallet is always identical to the\\n/// balance of ETH deposited minus the ETH withdrawn with that specific wallet.\\ncontract WETH10 is IWETH {\\n  string public constant name = \\\"Wrapped Ether v10\\\";\\n  string public constant symbol = \\\"WETH10\\\";\\n  uint8  public constant decimals = 18;\\n\\n  bytes32 public immutable CALLBACK_SUCCESS = keccak256(\\\"ERC3156FlashBorrower.onFlashLoan\\\");\\n  bytes32 public immutable PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n  uint256 public immutable deploymentChainId;\\n  bytes32 private immutable _DOMAIN_SEPARATOR;\\n\\n  /// @dev Records amount of WETH10 token owned by account.\\n  mapping (address =\\u003e uint256) public override balanceOf;\\n\\n  /// @dev Records current ERC2612 nonce for account. This value must be included whenever signature is generated for {permit}.\\n  /// Every successful call to {permit} increases account\\u0027s nonce by one. This prevents signature from being used multiple times.\\n  mapping (address =\\u003e uint256) public override nonces;\\n\\n  /// @dev Records number of WETH10 token that account (second) will be allowed to spend on behalf of another account (first) through {transferFrom}.\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) public override allowance;\\n\\n  /// @dev Current amount of flash-minted WETH10 token.\\n  uint256 public override flashMinted;\\n  \\n  constructor() {\\n    uint256 chainId;\\n    assembly {chainId := chainid()}\\n    deploymentChainId = chainId;\\n    _DOMAIN_SEPARATOR = _calculateDomainSeparator(chainId);\\n  }\\n\\n  /// @dev Calculate the DOMAIN_SEPARATOR.\\n  function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\\n    return keccak256(\\n      abi.encode(\\n        keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n        keccak256(bytes(name)),\\n        keccak256(bytes(\\\"1\\\")),\\n        chainId,\\n        address(this)\\n      )\\n    );\\n  }\\n\\n  /// @dev Return the DOMAIN_SEPARATOR.\\n  function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\n    uint256 chainId;\\n    assembly {chainId := chainid()}\\n    return chainId == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\\n  }\\n  \\n  /// @dev Returns the total supply of WETH10 token as the ETH held in this contract.\\n  function totalSupply() external view override returns (uint256) {\\n    return address(this).balance + flashMinted;\\n  }\\n\\n  /// @dev Fallback, `msg.value` of ETH sent to this contract grants caller account a matching increase in WETH10 token balance.\\n  /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to caller account.\\n  receive() external payable {\\n    // _mintTo(msg.sender, msg.value);\\n    balanceOf[msg.sender] += msg.value;\\n    emit Transfer(address(0), msg.sender, msg.value);\\n  }\\n\\n  /// @dev `msg.value` of ETH sent to this contract grants caller account a matching increase in WETH10 token balance.\\n  /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to caller account.\\n  function deposit() external override payable {\\n    // _mintTo(msg.sender, msg.value);\\n    balanceOf[msg.sender] += msg.value;\\n    emit Transfer(address(0), msg.sender, msg.value);\\n  }\\n\\n  /// @dev `msg.value` of ETH sent to this contract grants `to` account a matching increase in WETH10 token balance.\\n  /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from `address(0)` to `to` account.\\n  function depositTo(address to) external override payable {\\n    // _mintTo(to, msg.value);\\n    balanceOf[to] += msg.value;\\n    emit Transfer(address(0), to, msg.value);\\n  }\\n\\n  /// @dev `msg.value` of ETH sent to this contract grants `to` account a matching increase in WETH10 token balance,\\n  /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\\n  /// Emits {Transfer} event.\\n  /// Returns boolean value indicating whether operation succeeded.\\n  /// For more information on {transferAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\\n  function depositToAndCall(address to, bytes calldata data) external override payable returns (bool success) {\\n    // _mintTo(to, msg.value);\\n    balanceOf[to] += msg.value;\\n    emit Transfer(address(0), to, msg.value);\\n\\n    return ITransferReceiver(to).onTokenTransfer(msg.sender, msg.value, data);\\n  }\\n\\n  /// @dev Return the amount of WETH10 token that can be flash-lent.\\n  function maxFlashLoan(address token) external view override returns (uint256) {\\n    return token == address(this) ? type(uint112).max - flashMinted : 0; // Can\\u0027t underflow\\n  }\\n\\n  /// @dev Return the fee (zero) for flash lending an amount of WETH10 token.\\n  function flashFee(address token, uint256) external view override returns (uint256) {\\n    require(token == address(this), \\\"WETH: flash mint only WETH10\\\");\\n    return 0;\\n  }\\n\\n  /// @dev Flash lends `value` WETH10 token to the receiver address.\\n  /// By the end of the transaction, `value` WETH10 token will be burned from the receiver.\\n  /// The flash-minted WETH10 token is not backed by real ETH, but can be withdrawn as such up to the ETH balance of this contract.\\n  /// Arbitrary data can be passed as a bytes calldata parameter.\\n  /// Emits {Approval} event to reflect reduced allowance `value` for this contract to spend from receiver account (`receiver`),\\n  /// unless allowance is set to `type(uint256).max`\\n  /// Emits two {Transfer} events for minting and burning of the flash-minted amount.\\n  /// Returns boolean value indicating whether operation succeeded.\\n  /// Requirements:\\n  ///   - `value` must be less or equal to type(uint112).max.\\n  ///   - The total of all flash loans in a tx must be less or equal to type(uint112).max.\\n  function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 value, bytes calldata data) external override returns (bool) {\\n    require(token == address(this), \\\"WETH: flash mint only WETH10\\\");\\n    require(value \\u003c= type(uint112).max, \\\"WETH: individual loan limit exceeded\\\");\\n    flashMinted = flashMinted + value;\\n    require(flashMinted \\u003c= type(uint112).max, \\\"WETH: total loan limit exceeded\\\");\\n    \\n    // _mintTo(address(receiver), value);\\n    balanceOf[address(receiver)] += value;\\n    emit Transfer(address(0), address(receiver), value);\\n\\n    require(\\n      receiver.onFlashLoan(msg.sender, address(this), value, 0, data) == CALLBACK_SUCCESS,\\n      \\\"WETH: flash loan failed\\\"\\n    );\\n    \\n    // _decreaseAllowance(address(receiver), address(this), value);\\n    uint256 allowed = allowance[address(receiver)][address(this)];\\n    if (allowed != type(uint256).max) {\\n      require(allowed \\u003e= value, \\\"WETH: request exceeds allowance\\\");\\n      uint256 reduced = allowed - value;\\n      allowance[address(receiver)][address(this)] = reduced;\\n      emit Approval(address(receiver), address(this), reduced);\\n    }\\n\\n    // _burnFrom(address(receiver), value);\\n    uint256 balance = balanceOf[address(receiver)];\\n    require(balance \\u003e= value, \\\"WETH: burn amount exceeds balance\\\");\\n    balanceOf[address(receiver)] = balance - value;\\n    emit Transfer(address(receiver), address(0), value);\\n    \\n    flashMinted = flashMinted - value;\\n    return true;\\n  }\\n\\n  /// @dev Burn `value` WETH10 token from caller account and withdraw matching ETH to the same.\\n  /// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from caller account. \\n  /// Requirements:\\n  ///   - caller account must have at least `value` balance of WETH10 token.\\n  function withdraw(uint256 value) external override {\\n    // _burnFrom(msg.sender, value);\\n    uint256 balance = balanceOf[msg.sender];\\n    require(balance \\u003e= value, \\\"WETH: burn amount exceeds balance\\\");\\n    balanceOf[msg.sender] = balance - value;\\n    emit Transfer(msg.sender, address(0), value);\\n\\n    // _transferEther(msg.sender, value);        \\n    (bool success, ) = msg.sender.call{value: value}(\\\"\\\");\\n    require(success, \\\"WETH: ETH transfer failed\\\");\\n  }\\n\\n  /// @dev Burn `value` WETH10 token from caller account and withdraw matching ETH to account (`to`).\\n  /// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from caller account.\\n  /// Requirements:\\n  ///   - caller account must have at least `value` balance of WETH10 token.\\n  function withdrawTo(address payable to, uint256 value) external override {\\n    // _burnFrom(msg.sender, value);\\n    uint256 balance = balanceOf[msg.sender];\\n    require(balance \\u003e= value, \\\"WETH: burn amount exceeds balance\\\");\\n    balanceOf[msg.sender] = balance - value;\\n    emit Transfer(msg.sender, address(0), value);\\n\\n    // _transferEther(to, value);        \\n    (bool success, ) = to.call{value: value}(\\\"\\\");\\n    require(success, \\\"WETH: ETH transfer failed\\\");\\n  }\\n\\n  /// @dev Burn `value` WETH10 token from account (`from`) and withdraw matching ETH to account (`to`).\\n  /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\\n  /// unless allowance is set to `type(uint256).max`\\n  /// Emits {Transfer} event to reflect WETH10 token burn of `value` to `address(0)` from account (`from`).\\n  /// Requirements:\\n  ///   - `from` account must have at least `value` balance of WETH10 token.\\n  ///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same account.\\n  function withdrawFrom(address from, address payable to, uint256 value) external override {\\n    if (from != msg.sender) {\\n      // _decreaseAllowance(from, msg.sender, value);\\n      uint256 allowed = allowance[from][msg.sender];\\n      if (allowed != type(uint256).max) {\\n        require(allowed \\u003e= value, \\\"WETH: request exceeds allowance\\\");\\n        uint256 reduced = allowed - value;\\n        allowance[from][msg.sender] = reduced;\\n        emit Approval(from, msg.sender, reduced);\\n      }\\n    }\\n    \\n    // _burnFrom(from, value);\\n    uint256 balance = balanceOf[from];\\n    require(balance \\u003e= value, \\\"WETH: burn amount exceeds balance\\\");\\n    balanceOf[from] = balance - value;\\n    emit Transfer(from, address(0), value);\\n\\n    // _transferEther(to, value);        \\n    (bool success, ) = to.call{value: value}(\\\"\\\");\\n    require(success, \\\"WETH: Ether transfer failed\\\");\\n  }\\n\\n  /// @dev Sets `value` as allowance of `spender` account over caller account\\u0027s WETH10 token.\\n  /// Emits {Approval} event.\\n  /// Returns boolean value indicating whether operation succeeded.\\n  function approve(address spender, uint256 value) external override returns (bool) {\\n    // _approve(msg.sender, spender, value);\\n    allowance[msg.sender][spender] = value;\\n    emit Approval(msg.sender, spender, value);\\n\\n    return true;\\n  }\\n\\n  /// @dev Sets `value` as allowance of `spender` account over caller account\\u0027s WETH10 token,\\n  /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\\n  /// Emits {Approval} event.\\n  /// Returns boolean value indicating whether operation succeeded.\\n  /// For more information on {approveAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\\n  function approveAndCall(address spender, uint256 value, bytes calldata data) external override returns (bool) {\\n    // _approve(msg.sender, spender, value);\\n    allowance[msg.sender][spender] = value;\\n    emit Approval(msg.sender, spender, value);\\n    \\n    return IApprovalReceiver(spender).onTokenApproval(msg.sender, value, data);\\n  }\\n\\n  /// @dev Sets `value` as allowance of `spender` account over `owner` account\\u0027s WETH10 token, given `owner` account\\u0027s signed approval.\\n  /// Emits {Approval} event.\\n  /// Requirements:\\n  ///   - `deadline` must be timestamp in future.\\n  ///   - `v`, `r` and `s` must be valid `secp256k1` signature from `owner` account over EIP712-formatted function arguments.\\n  ///   - the signature must use `owner` account\\u0027s current nonce (see {nonces}).\\n  ///   - the signer cannot be `address(0)` and must be `owner` account.\\n  /// For more information on signature format, see https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP section].\\n  /// WETH10 token implementation adapted from https://github.com/albertocuestacanada/ERC20Permit/blob/master/contracts/ERC20Permit.sol.\\n  function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {\\n    require(block.timestamp \\u003c= deadline, \\\"WETH: Expired permit\\\");\\n\\n    uint256 chainId;\\n    assembly {chainId := chainid()}\\n\\n    bytes32 hashStruct = keccak256(\\n      abi.encode(\\n          PERMIT_TYPEHASH,\\n          owner,\\n          spender,\\n          value,\\n          nonces[owner]++,\\n          deadline));\\n\\n    bytes32 hash = keccak256(\\n      abi.encodePacked(\\n        \\\"\\\\x19\\\\x01\\\",\\n        chainId == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId),\\n        hashStruct));\\n\\n    address signer = ecrecover(hash, v, r, s);\\n    require(signer != address(0) \\u0026\\u0026 signer == owner, \\\"WETH: invalid permit\\\");\\n\\n    // _approve(owner, spender, value);\\n    allowance[owner][spender] = value;\\n    emit Approval(owner, spender, value);\\n  }\\n\\n  /// @dev Moves `value` WETH10 token from caller\\u0027s account to account (`to`).\\n  /// A transfer to `address(0)` triggers an ETH withdraw matching the sent WETH10 token in favor of caller.\\n  /// Emits {Transfer} event.\\n  /// Returns boolean value indicating whether operation succeeded.\\n  /// Requirements:\\n  ///   - caller account must have at least `value` WETH10 token.\\n  function transfer(address to, uint256 value) external override returns (bool) {\\n    // _transferFrom(msg.sender, to, value);\\n    if (to != address(0)) { // Transfer\\n      uint256 balance = balanceOf[msg.sender];\\n      require(balance \\u003e= value, \\\"WETH: transfer amount exceeds balance\\\");\\n\\n      balanceOf[msg.sender] = balance - value;\\n      balanceOf[to] += value;\\n      emit Transfer(msg.sender, to, value);\\n    } else { // Withdraw\\n      uint256 balance = balanceOf[msg.sender];\\n      require(balance \\u003e= value, \\\"WETH: burn amount exceeds balance\\\");\\n      balanceOf[msg.sender] = balance - value;\\n      emit Transfer(msg.sender, address(0), value);\\n      \\n      (bool success, ) = msg.sender.call{value: value}(\\\"\\\");\\n      require(success, \\\"WETH: ETH transfer failed\\\");\\n    }\\n    \\n    return true;\\n  }\\n\\n  /// @dev Moves `value` WETH10 token from account (`from`) to account (`to`) using allowance mechanism.\\n  /// `value` is then deducted from caller account\\u0027s allowance, unless set to `type(uint256).max`.\\n  /// A transfer to `address(0)` triggers an ETH withdraw matching the sent WETH10 token in favor of caller.\\n  /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\\n  /// unless allowance is set to `type(uint256).max`\\n  /// Emits {Transfer} event.\\n  /// Returns boolean value indicating whether operation succeeded.\\n  /// Requirements:\\n  ///   - `from` account must have at least `value` balance of WETH10 token.\\n  ///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same account.\\n  function transferFrom(address from, address to, uint256 value) external override returns (bool) {\\n    if (from != msg.sender) {\\n      // _decreaseAllowance(from, msg.sender, value);\\n      uint256 allowed = allowance[from][msg.sender];\\n      if (allowed != type(uint256).max) {\\n        require(allowed \\u003e= value, \\\"WETH: request exceeds allowance\\\");\\n        uint256 reduced = allowed - value;\\n        allowance[from][msg.sender] = reduced;\\n        emit Approval(from, msg.sender, reduced);\\n      }\\n    }\\n    \\n    // _transferFrom(from, to, value);\\n    if (to != address(0)) { // Transfer\\n      uint256 balance = balanceOf[from];\\n      require(balance \\u003e= value, \\\"WETH: transfer amount exceeds balance\\\");\\n\\n      balanceOf[from] = balance - value;\\n      balanceOf[to] += value;\\n      emit Transfer(from, to, value);\\n    } else { // Withdraw\\n      uint256 balance = balanceOf[from];\\n      require(balance \\u003e= value, \\\"WETH: burn amount exceeds balance\\\");\\n      balanceOf[from] = balance - value;\\n      emit Transfer(from, address(0), value);\\n  \\n      (bool success, ) = msg.sender.call{value: value}(\\\"\\\");\\n      require(success, \\\"WETH: ETH transfer failed\\\");\\n    }\\n    \\n    return true;\\n  }\\n\\n  /// @dev Moves `value` WETH10 token from caller\\u0027s account to account (`to`), \\n  /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\\n  /// A transfer to `address(0)` triggers an ETH withdraw matching the sent WETH10 token in favor of caller.\\n  /// Emits {Transfer} event.\\n  /// Returns boolean value indicating whether operation succeeded.\\n  /// Requirements:\\n  ///   - caller account must have at least `value` WETH10 token.\\n  /// For more information on {transferAndCall} format, see https://github.com/ethereum/EIPs/issues/677.\\n  function transferAndCall(address to, uint value, bytes calldata data) external override returns (bool) {\\n    // _transferFrom(msg.sender, to, value);\\n    if (to != address(0)) { // Transfer\\n      uint256 balance = balanceOf[msg.sender];\\n      require(balance \\u003e= value, \\\"WETH: transfer amount exceeds balance\\\");\\n\\n      balanceOf[msg.sender] = balance - value;\\n      balanceOf[to] += value;\\n      emit Transfer(msg.sender, to, value);\\n    } else { // Withdraw\\n      uint256 balance = balanceOf[msg.sender];\\n      require(balance \\u003e= value, \\\"WETH: burn amount exceeds balance\\\");\\n      balanceOf[msg.sender] = balance - value;\\n      emit Transfer(msg.sender, address(0), value);\\n  \\n      (bool success, ) = msg.sender.call{value: value}(\\\"\\\");\\n      require(success, \\\"WETH: ETH transfer failed\\\");\\n    }\\n\\n    return ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);\\n  }\\n}\"}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PairCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allPairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPairsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"createPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeToSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeTo\",\"type\":\"address\"}],\"name\":\"setFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeToSetter\",\"type\":\"address\"}],\"name\":\"setFeeToSetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TideBitSwapFactory","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://8585cbf063cc64c82fff78990c6804a3d7898203ce37ac198dc07944ac797335"}]}