{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Vesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"./DateTime.sol\\\";\\n\\n/* ========== ERRORS ========== */\\n\\nlibrary Errors {\\n  string internal constant InvalidTimestamp = \\\"invalid timestamp\\\";\\n  string internal constant InvalidInput = \\\"invalid input provided\\\";\\n  string internal constant NoVestingSchedule =\\n    \\\"sender has not been registered for a vesting schedule\\\";\\n  string internal constant InsufficientTokenBalance =\\n    \\\"contract does not have enough tokens to distribute\\\";\\n}\\n\\n/* ========== DATA STRUCTURES ========== */\\n\\n// @notice A vesting schedule for an individual address.\\nstruct VestingSchedule {\\n  uint256 lastClaim;\\n  uint16 monthsRemaining;\\n  uint32 tokensPerMonth;\\n}\\n\\ncontract Vesting is Ownable, ERC1155Receiver {\\n  /* ========== EVENTS ========== */\\n\\n  event VestingTokensGranted(\\n    address indexed to,\\n    uint256 totalMonths,\\n    uint256 tokensPerMonth\\n  );\\n  event VestedTokensClaimed(\\n    address indexed by,\\n    uint256 monthsClaimed,\\n    uint256 amount\\n  );\\n  event VestingTokensRevoked(address indexed from);\\n  event RewardTokenSet(address tokenAddress, uint256 tokenId);\\n  event TokensWithdrawnFromContract(address indexed to, uint256 amount);\\n\\n  /* ========== STATE VARIABLES ========== */\\n\\n  address private _tokenAddress;\\n  uint256 private _tokenId;\\n\\n  mapping(address => VestingSchedule) private _vestingSchedules;\\n\\n  /* ========== CONSTRUCTOR ========== */\\n\\n  constructor(address tokenAddress, uint256 tokenId) ERC1155Receiver() {\\n    _tokenAddress = tokenAddress;\\n    _tokenId = tokenId;\\n  }\\n\\n  /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n  // @notice Claim your vested tokens since last claiming timestamp.\\n  function claimTokens() external returns (uint256 tokensToClaim) {\\n    VestingSchedule storage userVestingSchedule = _vestingSchedules[msg.sender];\\n\\n    uint256 monthsPassed = DateTime.diffMonths(\\n      _vestingSchedules[msg.sender].lastClaim,\\n      block.timestamp\\n    );\\n\\n    // use uint16 because we can not claim more than the months remaining. avoid overflow later when assumptions are more complex.\\n    // explicit conversion here should be fine, since we already min() with a upscaled uint16 (monthsRemaining), so the range should fall within a single uint16\\n    uint16 monthsClaimed = uint16(\\n      Math.min(userVestingSchedule.monthsRemaining, monthsPassed)\\n    );\\n\\n    if (monthsClaimed == 0) {\\n      return 0;\\n    } else {\\n      tokensToClaim =\\n        uint256(userVestingSchedule.tokensPerMonth) *\\n        monthsClaimed;\\n    }\\n\\n    IERC1155 token = IERC1155(_tokenAddress);\\n    require(\\n      token.balanceOf(address(this), _tokenId) >= tokensToClaim,\\n      Errors.InsufficientTokenBalance\\n    );\\n\\n    _vestingSchedules[msg.sender].lastClaim = block.timestamp;\\n    _vestingSchedules[msg.sender].monthsRemaining =\\n      _vestingSchedules[msg.sender].monthsRemaining -\\n      monthsClaimed;\\n\\n    token.safeTransferFrom(\\n      address(this),\\n      msg.sender,\\n      _tokenId,\\n      tokensToClaim,\\n      \\\"Claiming vested tokens\\\"\\n    );\\n    emit VestedTokensClaimed(msg.sender, monthsClaimed, tokensToClaim);\\n  }\\n\\n  // @notice Grant vesting tokens to a specified address.\\n  // @param toGrant Address to receive tokens on a vesting schedule.\\n  // @param numberOfMonths Number of months to grant tokens for.\\n  // @param tokensPerMonth Number of tokens to grant per month.\\n  function grantVestingTokens(\\n    address toGrant,\\n    uint16 numberOfMonths,\\n    uint32 tokensPerMonth\\n  ) external onlyOwner {\\n    require(toGrant != address(0), Errors.InvalidInput);\\n    _vestingSchedules[toGrant] = VestingSchedule(\\n      block.timestamp,\\n      numberOfMonths,\\n      tokensPerMonth\\n    );\\n    emit VestingTokensGranted(toGrant, numberOfMonths, tokensPerMonth);\\n  }\\n\\n  // @notice Owner can withdraw tokens deposited into the contract.\\n  // @param count The number of tokens to withdraw.\\n  function withdrawTokens(uint256 count) external onlyOwner {\\n    IERC1155 token = IERC1155(_tokenAddress);\\n    require(\\n      token.balanceOf(address(this), _tokenId) >= count,\\n      Errors.InsufficientTokenBalance\\n    );\\n\\n    token.safeTransferFrom(\\n      address(this),\\n      msg.sender,\\n      _tokenId,\\n      count,\\n      \\\"Withdrawing tokens\\\"\\n    );\\n\\n    emit TokensWithdrawnFromContract(msg.sender, count);\\n  }\\n\\n  // @notice Revoke vesting tokens from specified address.\\n  // @param revokeAddress The address to revoke tokens from.\\n  function revokeVestingTokens(address revokeAddress) external onlyOwner {\\n    _vestingSchedules[revokeAddress].tokensPerMonth = 0;\\n    _vestingSchedules[revokeAddress].monthsRemaining = 0;\\n    emit VestingTokensRevoked(revokeAddress);\\n  }\\n\\n  /*\\n   * @notice Set the token to be used for vesting rewards.\\n   * @dev Token must implement ERC1155.\\n   * @param tokenAddress The address of the token contract.\\n   * @param tokenId The id of the token.\\n   */\\n  function setToken(address tokenAddress, uint256 id) external onlyOwner {\\n    _tokenAddress = tokenAddress;\\n    _tokenId = id;\\n    emit RewardTokenSet(tokenAddress, id);\\n  }\\n\\n  /* ========== VIEW FUNCTIONS ========== */\\n\\n  /*\\n   * @notice Get the vested token address and ID.\\n   */\\n  function getToken() external view returns (address, uint256) {\\n    return (_tokenAddress, _tokenId);\\n  }\\n\\n  /*\\n   * @notice Get the vesting schedule for a specified address.\\n   * @param addr The address to get the schedule for.\\n   */\\n  function getVestingSchedule(address addr)\\n    external\\n    view\\n    returns (\\n      uint256 timestamp,\\n      uint16 monthsRemaining,\\n      uint32 tokensPerMonth\\n    )\\n  {\\n    VestingSchedule storage _vestingSchedule = _vestingSchedules[addr];\\n    return (\\n      _vestingSchedule.lastClaim,\\n      _vestingSchedule.monthsRemaining,\\n      _vestingSchedule.tokensPerMonth\\n    );\\n  }\\n\\n  function onERC1155Received(\\n    address operator,\\n    address from,\\n    uint256 id,\\n    uint256 value,\\n    bytes calldata data\\n  ) external pure override returns (bytes4) {\\n    return\\n      bytes4(\\n        keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\")\\n      );\\n  }\\n\\n  function onERC1155BatchReceived(\\n    address operator,\\n    address from,\\n    uint256[] calldata ids,\\n    uint256[] calldata values,\\n    bytes calldata data\\n  ) external pure override returns (bytes4) {\\n    return\\n      bytes4(\\n        keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\")\\n      );\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155Receiver.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.9.0;\\n\\n// ----------------------------------------------------------------------------\\n// BokkyPooBah's DateTime Library v1.01\\n//\\n// A gas-efficient Solidity date and time library\\n//\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n//\\n// Tested date range 1970/01/01 to 2345/12/31\\n//\\n// Conventions:\\n// Unit      | Range         | Notes\\n// :-------- |:-------------:|:-----\\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\n// year      | 1970 ... 2345 |\\n// month     | 1 ... 12      |\\n// day       | 1 ... 31      |\\n// hour      | 0 ... 23      |\\n// minute    | 0 ... 59      |\\n// second    | 0 ... 59      |\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\n//\\n//\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\n// ----------------------------------------------------------------------------\\n\\nlibrary DateTime {\\n  uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\\n  uint256 constant SECONDS_PER_HOUR = 60 * 60;\\n  uint256 constant SECONDS_PER_MINUTE = 60;\\n  int256 constant OFFSET19700101 = 2440588;\\n\\n  uint256 constant DOW_MON = 1;\\n  uint256 constant DOW_TUE = 2;\\n  uint256 constant DOW_WED = 3;\\n  uint256 constant DOW_THU = 4;\\n  uint256 constant DOW_FRI = 5;\\n  uint256 constant DOW_SAT = 6;\\n  uint256 constant DOW_SUN = 7;\\n\\n  // ------------------------------------------------------------------------\\n  // Calculate the number of days from 1970/01/01 to year/month/day using\\n  // the date conversion algorithm from\\n  //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n  // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\n  //\\n  // days = day\\n  //      - 32075\\n  //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\n  //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\n  //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\n  //      - offset\\n  // ------------------------------------------------------------------------\\n  function _daysFromDate(\\n    uint256 year,\\n    uint256 month,\\n    uint256 day\\n  ) internal pure returns (uint256 _days) {\\n    // require(year >= 1970);\\n    int256 _year = int256(year);\\n    int256 _month = int256(month);\\n    int256 _day = int256(day);\\n\\n    int256 __days = _day -\\n      32075 +\\n      (1461 * (_year + 4800 + (_month - 14) / 12)) /\\n      4 +\\n      (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\\n      12 -\\n      (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\\n      4 -\\n      OFFSET19700101;\\n\\n    _days = uint256(__days);\\n  }\\n\\n  // ------------------------------------------------------------------------\\n  // Calculate year/month/day from the number of days since 1970/01/01 using\\n  // the date conversion algorithm from\\n  //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n  // and adding the offset 2440588 so that 1970/01/01 is day 0\\n  //\\n  // int L = days + 68569 + offset\\n  // int N = 4 * L / 146097\\n  // L = L - (146097 * N + 3) / 4\\n  // year = 4000 * (L + 1) / 1461001\\n  // L = L - 1461 * year / 4 + 31\\n  // month = 80 * L / 2447\\n  // dd = L - 2447 * month / 80\\n  // L = month / 11\\n  // month = month + 2 - 12 * L\\n  // year = 100 * (N - 49) + year + L\\n  // ------------------------------------------------------------------------\\n  function _daysToDate(uint256 _days)\\n    internal\\n    pure\\n    returns (\\n      uint256 year,\\n      uint256 month,\\n      uint256 day\\n    )\\n  {\\n    int256 __days = int256(_days);\\n\\n    int256 L = __days + 68569 + OFFSET19700101;\\n    int256 N = (4 * L) / 146097;\\n    L = L - (146097 * N + 3) / 4;\\n    int256 _year = (4000 * (L + 1)) / 1461001;\\n    L = L - (1461 * _year) / 4 + 31;\\n    int256 _month = (80 * L) / 2447;\\n    int256 _day = L - (2447 * _month) / 80;\\n    L = _month / 11;\\n    _month = _month + 2 - 12 * L;\\n    _year = 100 * (N - 49) + _year + L;\\n\\n    year = uint256(_year);\\n    month = uint256(_month);\\n    day = uint256(_day);\\n  }\\n\\n  function timestampFromDate(\\n    uint256 year,\\n    uint256 month,\\n    uint256 day\\n  ) internal pure returns (uint256 timestamp) {\\n    timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\\n  }\\n\\n  function timestampFromDateTime(\\n    uint256 year,\\n    uint256 month,\\n    uint256 day,\\n    uint256 hour,\\n    uint256 minute,\\n    uint256 second\\n  ) internal pure returns (uint256 timestamp) {\\n    timestamp =\\n      _daysFromDate(year, month, day) *\\n      SECONDS_PER_DAY +\\n      hour *\\n      SECONDS_PER_HOUR +\\n      minute *\\n      SECONDS_PER_MINUTE +\\n      second;\\n  }\\n\\n  function timestampToDate(uint256 timestamp)\\n    internal\\n    pure\\n    returns (\\n      uint256 year,\\n      uint256 month,\\n      uint256 day\\n    )\\n  {\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n  }\\n\\n  function timestampToDateTime(uint256 timestamp)\\n    internal\\n    pure\\n    returns (\\n      uint256 year,\\n      uint256 month,\\n      uint256 day,\\n      uint256 hour,\\n      uint256 minute,\\n      uint256 second\\n    )\\n  {\\n    (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    uint256 secs = timestamp % SECONDS_PER_DAY;\\n    hour = secs / SECONDS_PER_HOUR;\\n    secs = secs % SECONDS_PER_HOUR;\\n    minute = secs / SECONDS_PER_MINUTE;\\n    second = secs % SECONDS_PER_MINUTE;\\n  }\\n\\n  function isValidDate(\\n    uint256 year,\\n    uint256 month,\\n    uint256 day\\n  ) internal pure returns (bool valid) {\\n    if (year >= 1970 && month > 0 && month <= 12) {\\n      uint256 daysInMonth = _getDaysInMonth(year, month);\\n      if (day > 0 && day <= daysInMonth) {\\n        valid = true;\\n      }\\n    }\\n  }\\n\\n  function isValidDateTime(\\n    uint256 year,\\n    uint256 month,\\n    uint256 day,\\n    uint256 hour,\\n    uint256 minute,\\n    uint256 second\\n  ) internal pure returns (bool valid) {\\n    if (isValidDate(year, month, day)) {\\n      if (hour < 24 && minute < 60 && second < 60) {\\n        valid = true;\\n      }\\n    }\\n  }\\n\\n  function isLeapYear(uint256 timestamp) internal pure returns (bool leapYear) {\\n    (uint256 year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    leapYear = _isLeapYear(year);\\n  }\\n\\n  function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\\n    leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\\n  }\\n\\n  function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {\\n    weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\\n  }\\n\\n  function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {\\n    weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\\n  }\\n\\n  function getDaysInMonth(uint256 timestamp)\\n    internal\\n    pure\\n    returns (uint256 daysInMonth)\\n  {\\n    (uint256 year, uint256 month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    daysInMonth = _getDaysInMonth(year, month);\\n  }\\n\\n  function _getDaysInMonth(uint256 year, uint256 month)\\n    internal\\n    pure\\n    returns (uint256 daysInMonth)\\n  {\\n    if (\\n      month == 1 ||\\n      month == 3 ||\\n      month == 5 ||\\n      month == 7 ||\\n      month == 8 ||\\n      month == 10 ||\\n      month == 12\\n    ) {\\n      daysInMonth = 31;\\n    } else if (month != 2) {\\n      daysInMonth = 30;\\n    } else {\\n      daysInMonth = _isLeapYear(year) ? 29 : 28;\\n    }\\n  }\\n\\n  // 1 = Monday, 7 = Sunday\\n  function getDayOfWeek(uint256 timestamp)\\n    internal\\n    pure\\n    returns (uint256 dayOfWeek)\\n  {\\n    uint256 _days = timestamp / SECONDS_PER_DAY;\\n    dayOfWeek = ((_days + 3) % 7) + 1;\\n  }\\n\\n  function getYear(uint256 timestamp) internal pure returns (uint256 year) {\\n    (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n  }\\n\\n  function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\\n    (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n  }\\n\\n  function getDay(uint256 timestamp) internal pure returns (uint256 day) {\\n    (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n  }\\n\\n  function getHour(uint256 timestamp) internal pure returns (uint256 hour) {\\n    uint256 secs = timestamp % SECONDS_PER_DAY;\\n    hour = secs / SECONDS_PER_HOUR;\\n  }\\n\\n  function getMinute(uint256 timestamp) internal pure returns (uint256 minute) {\\n    uint256 secs = timestamp % SECONDS_PER_HOUR;\\n    minute = secs / SECONDS_PER_MINUTE;\\n  }\\n\\n  function getSecond(uint256 timestamp) internal pure returns (uint256 second) {\\n    second = timestamp % SECONDS_PER_MINUTE;\\n  }\\n\\n  function addYears(uint256 timestamp, uint256 _years)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    (uint256 year, uint256 month, uint256 day) = _daysToDate(\\n      timestamp / SECONDS_PER_DAY\\n    );\\n    year += _years;\\n    uint256 daysInMonth = _getDaysInMonth(year, month);\\n    if (day > daysInMonth) {\\n      day = daysInMonth;\\n    }\\n    newTimestamp =\\n      _daysFromDate(year, month, day) *\\n      SECONDS_PER_DAY +\\n      (timestamp % SECONDS_PER_DAY);\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function addMonths(uint256 timestamp, uint256 _months)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    (uint256 year, uint256 month, uint256 day) = _daysToDate(\\n      timestamp / SECONDS_PER_DAY\\n    );\\n    month += _months;\\n    year += (month - 1) / 12;\\n    month = ((month - 1) % 12) + 1;\\n    uint256 daysInMonth = _getDaysInMonth(year, month);\\n    if (day > daysInMonth) {\\n      day = daysInMonth;\\n    }\\n    newTimestamp =\\n      _daysFromDate(year, month, day) *\\n      SECONDS_PER_DAY +\\n      (timestamp % SECONDS_PER_DAY);\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function addDays(uint256 timestamp, uint256 _days)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp + _days * SECONDS_PER_DAY;\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function addHours(uint256 timestamp, uint256 _hours)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function addMinutes(uint256 timestamp, uint256 _minutes)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function addSeconds(uint256 timestamp, uint256 _seconds)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp + _seconds;\\n    require(newTimestamp >= timestamp);\\n  }\\n\\n  function subYears(uint256 timestamp, uint256 _years)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    (uint256 year, uint256 month, uint256 day) = _daysToDate(\\n      timestamp / SECONDS_PER_DAY\\n    );\\n    year -= _years;\\n    uint256 daysInMonth = _getDaysInMonth(year, month);\\n    if (day > daysInMonth) {\\n      day = daysInMonth;\\n    }\\n    newTimestamp =\\n      _daysFromDate(year, month, day) *\\n      SECONDS_PER_DAY +\\n      (timestamp % SECONDS_PER_DAY);\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function subMonths(uint256 timestamp, uint256 _months)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    (uint256 year, uint256 month, uint256 day) = _daysToDate(\\n      timestamp / SECONDS_PER_DAY\\n    );\\n    uint256 yearMonth = year * 12 + (month - 1) - _months;\\n    year = yearMonth / 12;\\n    month = (yearMonth % 12) + 1;\\n    uint256 daysInMonth = _getDaysInMonth(year, month);\\n    if (day > daysInMonth) {\\n      day = daysInMonth;\\n    }\\n    newTimestamp =\\n      _daysFromDate(year, month, day) *\\n      SECONDS_PER_DAY +\\n      (timestamp % SECONDS_PER_DAY);\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function subDays(uint256 timestamp, uint256 _days)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp - _days * SECONDS_PER_DAY;\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function subHours(uint256 timestamp, uint256 _hours)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function subMinutes(uint256 timestamp, uint256 _minutes)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function subSeconds(uint256 timestamp, uint256 _seconds)\\n    internal\\n    pure\\n    returns (uint256 newTimestamp)\\n  {\\n    newTimestamp = timestamp - _seconds;\\n    require(newTimestamp <= timestamp);\\n  }\\n\\n  function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\\n    internal\\n    pure\\n    returns (uint256 _years)\\n  {\\n    require(fromTimestamp <= toTimestamp);\\n    (uint256 fromYear, , ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\n    (uint256 toYear, , ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n    _years = toYear - fromYear;\\n  }\\n\\n  function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\\n    internal\\n    pure\\n    returns (uint256 _months)\\n  {\\n    require(fromTimestamp <= toTimestamp);\\n    (uint256 fromYear, uint256 fromMonth, ) = _daysToDate(\\n      fromTimestamp / SECONDS_PER_DAY\\n    );\\n    (uint256 toYear, uint256 toMonth, ) = _daysToDate(\\n      toTimestamp / SECONDS_PER_DAY\\n    );\\n    _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\n  }\\n\\n  function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\\n    internal\\n    pure\\n    returns (uint256 _days)\\n  {\\n    require(fromTimestamp <= toTimestamp);\\n    _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\n  }\\n\\n  function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\\n    internal\\n    pure\\n    returns (uint256 _hours)\\n  {\\n    require(fromTimestamp <= toTimestamp);\\n    _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\\n  }\\n\\n  function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\\n    internal\\n    pure\\n    returns (uint256 _minutes)\\n  {\\n    require(fromTimestamp <= toTimestamp);\\n    _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\\n  }\\n\\n  function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\\n    internal\\n    pure\\n    returns (uint256 _seconds)\\n  {\\n    require(fromTimestamp <= toTimestamp);\\n    _seconds = toTimestamp - fromTimestamp;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"RewardTokenSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensWithdrawnFromContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"monthsClaimed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VestedTokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalMonths\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensPerMonth\",\"type\":\"uint256\"}],\"name\":\"VestingTokensGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"VestingTokensRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensToClaim\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getVestingSchedule\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"monthsRemaining\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"tokensPerMonth\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toGrant\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"numberOfMonths\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"tokensPerMonth\",\"type\":\"uint32\"}],\"name\":\"grantVestingTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"revokeAddress\",\"type\":\"address\"}],\"name\":\"revokeVestingTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"setToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Vesting","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007eef591a6cc0403b9652e98e88476fe1bf31ddeb000000000000000000000000000000000000000000000000000000000000002a","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}