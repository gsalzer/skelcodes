{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-10-22\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n  _____                  _        _____               _      \r\n / ____|                | |      |  __ \\             | |     \r\n| |     _ __ _   _ _ __ | |_ ___ | |__) |   _ _______| | ___ \r\n| |    | '__| | | | '_ \\| __/ _ \\|  ___/ | | |_  /_  / |/ _ \\\r\n| |____| |  | |_| | |_) | || (_) | |   | |_| |/ / / /| |  __/\r\n \\_____|_|   \\__, | .__/ \\__\\___/|_|    \\__,_/___/___|_|\\___|\r\n              __/ | |                                        \r\n             |___/|_|                    \r\n             \r\nby Macha and Wardesq\r\n             \r\n */\r\n \r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\ninterface IFundsDistributionTokenOptional {\r\n\r\n\t/** \r\n\t * @notice Deposits funds to this contract.\r\n\t * The deposited funds may be distributed to other accounts.\r\n\t */\r\n\tfunction depositFunds() external payable;\r\n\r\n\t/** \r\n\t * @notice Returns the total amount of funds that have been deposited to this contract but not yet distributed.\r\n\t */\r\n\tfunction undistributedFunds() external view returns(uint256);\r\n\r\n\t/** \r\n\t * @notice Returns the total amount of funds that have been distributed.\r\n\t */\r\n\tfunction distributedFunds() external view returns(uint256);\r\n\r\n\t/** \r\n\t * @notice Distributes undistributed funds to accounts.\r\n\t */\r\n\tfunction distributeFunds() external;\r\n\r\n\t/** \r\n\t * @notice Deposits and distributes funds to accounts.\r\n\t * @param from The source of the funds.\r\n\t */\r\n\tfunction depositAndDistributeFunds(address from) external payable;\r\n\r\n\t/**\r\n\t * @dev This event MUST emit when funds are deposited to this contract.\r\n\t * @param by the address of the sender of who deposited funds.\r\n\t * @param fundsDeposited The amount of distributed funds.\r\n\t */\r\n\tevent FundsDeposited(address indexed by, uint256 fundsDeposited);\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract CryptoPuzzle {\r\n    using Strings for uint256;\r\n    using SafeMath for uint256;\r\n    \r\naddress public owner;    \r\n\r\nstring public name;\r\nstring public symbol;\r\nuint8 public decimals;\r\nuint256 public TOTALSUPPLY;\r\n//uint internal nexttokenIndexToAssign;\r\n//bool internal alltokenAssigned = false;\r\nuint public tokenAssign;\r\nuint public\r\n\r\n\r\ntokenLinearClaim;\r\nuint public claimPrice;\r\nuint internal randNonce; \r\nuint256 public OWNERCUTPERCENTAGE = 3;\r\nuint256 public ownerCutTotalSupply;\r\nuint256 public PRIZECUTPERCENTAGE = 3;\r\nuint256 public prizeCutTotalSupply;\r\nuint public forceBuyPrice;\r\nuint public forceBuyInterval;\r\nbool public publicSale = false;\r\nuint public saleStartTime;\r\nuint public saleDuration;\r\nbool internal isLocked; //claim security : reentrancyGuard\r\nbool public marketPaused;\r\nbytes32 DOMAIN_SEPARATOR;\r\nbytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(string name,uint256 chainId,address verifyingContract)\"\r\n    );\r\nbytes32 constant TRADE_TYPEHASH = keccak256(\r\n        \"SignTrade(address maker,uint256 makerWei,uint256[] makerIds,address taker,uint256 takerWei,uint256[] takerIds,uint256 expiry)\"\r\n    );\r\n    \r\n    \r\n\r\nmapping(uint => address) public tokenIndexToAddress; \r\nmapping(address => uint) public pendingWithdrawals;\r\nmapping (bytes32 => bool) cancelledTrade;\r\n\r\nstruct SignTrade {\r\n        address maker;\r\n        uint256 makerWei;\r\n        uint256[] makerIds;// Its for trade NFT to NFT without ether ? \r\n        address taker;\r\n        uint256 takerWei;\r\n        uint256[] takerIds;// Its for trade NFT to NFT without ether ? \r\n        uint256 expiry;\r\n   }\r\n   \r\n       struct EIP712Domain {\r\n        string name;\r\n        uint256 chainId;\r\n        address verifyingContract;\r\n    }\r\n\r\n\r\n\r\n    event Assign(address indexed to, uint256 tokenIndex);\r\n    event SaleForced(uint indexed tokenIndex, uint value, address indexed from, address indexed to);\r\n    event Transfer(address indexed from, address indexed to, uint256 tokenIndex, uint value);\r\n    event Claim(address indexed to, uint256 tokenIndex, uint256 value, address indexed from);\r\n    event Mint(address indexed to, uint256 tokenIndex, uint256 value, address indexed from);\r\n    event Deposit(uint indexed tokenIndex, uint value, address indexed from, address indexed to);\r\n    event Withdraw(uint indexed tokenIndex, uint value, address indexed from, address indexed to);\r\n    event Trade(address indexed maker, uint makerWei, uint[] makerIds, address indexed taker, uint takerWei, uint[] takerIds,  uint expiry, bytes signature);\r\n    event Store (uint8 NumberRobot, string indexed robotString);\r\n    event TradeCancelled(address indexed maker, uint makerWei, uint[] makerIds, address indexed taker, uint takerWei, uint[] takerIds,  uint expiry);\r\n  \r\n   IFundsDistributionTokenOptional a_contract_instance;\r\n    constructor (address _a_contract_address) {\r\n        a_contract_instance = IFundsDistributionTokenOptional(_a_contract_address);\r\n    \towner = msg.sender;\r\n    TOTALSUPPLY = 5201;             // update total supply\r\n    name = \"CryptoPuzzle\";          // set the name for display purposes\r\n    symbol = unicode\"ðŸ§©\";                  // set the symbol for display purposes\r\n    decimals = 0;                   // amount of decimals for display purposes\r\n DOMAIN_SEPARATOR = hash(EIP712Domain({\r\n            name: \"https://cryptopuzzle.com/\",\r\n            chainId: 1,\r\n            verifyingContract: address(this)\r\n        }));\r\n        tokenIndexToAddress[0] = msg.sender;\r\n    emit Claim(msg.sender, 0, 0, address(0x0));\r\n   // tokenAssign++; // Not necesary for only 0's claim\r\n    }\r\n\r\n      ////////////////\r\n     /// Security ///\r\n    ////////////////\r\n    \r\n    //If size > 0 => contract\r\n              function isContract(address addr) internal view returns (uint32 size){\r\n  assembly {\r\n    size := extcodesize(addr)\r\n  }\r\n  return size;\r\n}\r\n    \r\n    modifier reentrancyGuard() { //claim security : reentrancyGuard\r\n    require(!isLocked, \"Locked\");\r\n    isLocked = true;\r\n    _;\r\n    isLocked = false;\r\n}\r\n\r\nfunction pauseMarket(bool _paused) external {\r\n    require(msg.sender == owner);\r\n        marketPaused = _paused;\r\n    }\r\n    \r\n      //////////////////\r\n     /// SSTORE NFT ///\r\n    //////////////////\r\n    \r\n    string public baseTokenURI;\r\n    event BaseURIChanged(string baseURI);\r\n    \r\n     function _baseURI() internal view returns (string memory) {\r\n        return baseTokenURI;\r\n    }\r\n\r\n    function setBaseURI(string memory baseURI) public {\r\n        require (msg.sender == owner);\r\n        baseTokenURI = baseURI;\r\n        emit BaseURIChanged(baseURI);\r\n    }\r\n    \r\nfunction tokenURI(uint256 tokenId) public view returns (string memory) {\r\n   // require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n    string memory baseURI = _baseURI();\r\n    return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n}\r\n\r\n\r\n    ////////////////\r\n   /// ERC 2222 ///\r\n  ////////////////\r\n    \r\n    function stack() public payable reentrancyGuard {\r\n    uint amount = ownerCutTotalSupply;\r\n    ownerCutTotalSupply = 0;\r\n    a_contract_instance.depositFunds{value:amount}();\r\n}\r\n     \r\n    ////////////\r\n   /// Bank ///\r\n  ////////////  \r\n    \r\n    function deposit() public payable {\r\n\trequire (msg.value > 0);\r\n\tpendingWithdrawals[msg.sender] += msg.value;\r\n\temit Deposit (0, msg.value, msg.sender, address(0x0));\r\n\t}\r\n\r\n    function withdraw() public reentrancyGuard {\r\n        require (pendingWithdrawals[msg.sender] > 0);\r\n        uint amount = pendingWithdrawals[msg.sender];\r\n        pendingWithdrawals[msg.sender] = 0;\r\n        payable(msg.sender).transfer(amount);\r\n        emit Withdraw(0, amount, msg.sender, address(0x0));\r\n       }\r\n   \r\n    ///////////////////////////\r\n   /// CPZ gameDesignRules ///\r\n  //////////////////////////\r\n    \r\n    function startSale(uint _price, uint _forceBuyPrice, uint _forceBuyInterval, uint _saleDuration) external {\r\n        require(!publicSale);\r\n        require(msg.sender == owner);\r\n        claimPrice = _price;\r\n        forceBuyPrice = _forceBuyPrice;\r\n        forceBuyInterval = _forceBuyInterval;\r\n        saleDuration = _saleDuration;\r\n        saleStartTime = block.timestamp;\r\n        publicSale = true;\r\n    }\r\n    \r\n    function getClaimPrice() public view returns (uint) {\r\n        require(publicSale, \"Sale not started.\");\r\n        uint elapsed = block.timestamp.sub(saleStartTime);\r\n        if (elapsed >= saleDuration) {\r\n            return 0;\r\n        } else { if (msg.sender == owner) {\r\n            return 0 wei;\r\n        } else {\r\n            //return saleDuration.sub(elapsed).mul(price).div(saleDuration);\r\n            return claimPrice;\r\n        }\r\n    }}\r\n\r\n\r\n       function claimtoken() public reentrancyGuard payable returns(uint){\r\n           require(publicSale, \"Sale not started.\");\r\n           require(!marketPaused, \"The market is on pause\"); \r\n           require (tokenAssign < 5000);  //gameDesignRules\r\n           uint salePrice = getClaimPrice();\r\n      require (msg.value >= salePrice); //gameDesignRules\r\n      \r\n     if (msg.value > salePrice) {\r\n            pendingWithdrawals[msg.sender] = pendingWithdrawals[msg.sender].add(msg.value.sub(salePrice));\r\n        }\r\n       uint tokenIndex = 5001;\r\n       randNonce++;  \r\n       uint tokenClaimId = uint(keccak256(abi.encodePacked(block.timestamp, msg.sender, randNonce))) % tokenIndex;\r\nownerCutTotalSupply = ownerCutTotalSupply.add(msg.value.div(10));\r\nprizeCutTotalSupply = prizeCutTotalSupply.add(msg.value.div(10).mul(9));\r\n               if (tokenAssign < 4200) \r\n               {\r\n                tokenClaimId = claimRandom(tokenClaimId);\r\n            if (tokenIndexToAddress[tokenClaimId] == address(0x0)) \r\n            {\r\n                tokenIndexToAddress[tokenClaimId] = msg.sender;\r\n                tokenAssign++;\r\n                emit Claim(msg.sender, tokenClaimId, msg.value, address(0x0));\r\n                return tokenClaimId;\r\n            } \r\n            else {revert(\"No puzzle available for your 150 loops. Try again !\");}\r\n        } \r\n        else {\r\n                tokenLinearClaim = claimLinear(tokenLinearClaim);\r\n            if (tokenIndexToAddress[tokenLinearClaim] == address(0x0)) {\r\n                tokenIndexToAddress[tokenLinearClaim] = msg.sender;\r\n                tokenAssign++;\r\n                emit Claim(msg.sender, tokenLinearClaim, msg.value, address(0x0));\r\n                return tokenLinearClaim;\r\n                } else {\r\n                    return tokenLinearClaim;\r\n                    //revert(\"No puzzle available for your 150 loops. Try again !\");\r\n                    }\r\n        }\r\n            }\r\n  \r\n   function claimRandom(uint tokenClaimId) internal view returns (uint x) {\r\n          uint countview = 0;\r\n                 do {\r\n                tokenClaimId++; \r\n                tokenClaimId %= 5001;\r\n                countview++;\r\n            } while (tokenIndexToAddress[tokenClaimId] != address(0x0) && countview < 150);\r\n          x = tokenClaimId;\r\n          return x;\r\n}\r\n\r\nfunction claimLinear(uint tokenLinearClaimF) internal view returns (uint x) {\r\n          uint countview = 0;\r\n           do {\r\n                tokenLinearClaimF ++; \r\n                tokenLinearClaimF %= 5001;\r\n                countview++;\r\n            } while (tokenIndexToAddress[tokenLinearClaimF] != address(0x0) && countview < 150);\r\n      x = tokenLinearClaimF;\r\n          return x;\r\n}   \r\n    \r\n    function transferToken(address to, uint tokenIndex) public {\r\n        require (to != address(0x0));\r\n        require (tokenIndex <= TOTALSUPPLY); //gameDesignRules\r\n        require(tokenIndexToAddress[tokenIndex.add(24).div(25).add(5000)] == address(0x0), \"Already Mint\");//gameDesignRules\r\n        require (tokenIndexToAddress[tokenIndex] == msg.sender); //gameDesignRules\r\n        if (isContract(to) > 0 && tokenIndex <= 5000) {\r\n            if (tokenIndex != 0) {\r\n        revert (\"Cannot transfer pieces to a contract\");           \r\n        }}\r\n        tokenIndexToAddress[tokenIndex] = to;\r\n        emit Transfer(msg.sender, to , tokenIndex, 0);\r\n    }\r\n\r\n\tfunction forceBuy(uint tokenIndex) payable public {\r\n\trequire (tokenAssign >= 5000, \"Not all claims are made!\");\r\n\trequire (tokenIndex <= 5000); //gameDesignRules\r\n\trequire (msg.value == (forceBuyPrice)); //gameDesignRules\r\n\trequire (tokenIndexToAddress[tokenIndex] != address(0x0)); //gameDesignRules\r\n\trequire (tokenIndexToAddress[tokenIndex] != msg.sender); //gameDesignRules\r\n\trequire (tokenIndexToAddress[tokenIndex.add(24).div(25).add(5000)] == address(0x0), \"Already Mint\");//gameDesignRules\r\n\trequire (tokenIndex != 0);\r\n\taddress forceSeller = tokenIndexToAddress[tokenIndex];\r\n\tpendingWithdrawals[forceSeller] = pendingWithdrawals[forceSeller].add(msg.value.sub(msg.value.mul(6).div(100)));\r\n\townerCutTotalSupply = ownerCutTotalSupply.add(msg.value.mul(OWNERCUTPERCENTAGE).div(100));\r\n\tprizeCutTotalSupply = prizeCutTotalSupply.add(msg.value.mul(PRIZECUTPERCENTAGE).div(100));\r\n\ttokenIndexToAddress[tokenIndex] = msg.sender;\r\n\temit SaleForced(tokenIndex, msg.value, forceSeller, msg.sender);\r\n\t}\r\n    \r\n    \r\n    function mintCPZ (uint familyId) public reentrancyGuard {\r\n            require (tokenAssign >= 5000, \"Not all claims are made!\");\r\n            require (tokenIndexToAddress[familyId.add(5000)] == address(0x0));//gameDesignRules\r\n            uint proof = 0;\r\n            for (uint i = 0; i < 25; i++) {\r\n                if (tokenIndexToAddress[familyId * 25 - uint(i)] == msg.sender) {proof++;} \r\n            } \r\n                if (proof == 25) {\r\n                forceBuyPrice += forceBuyInterval;\r\n           tokenIndexToAddress[familyId.add(5000)] = msg.sender;\r\n        pendingWithdrawals[msg.sender] = pendingWithdrawals[msg.sender].add(prizeCutTotalSupply.div(20));\r\n        emit Mint(msg.sender, familyId.add(5000), prizeCutTotalSupply.div(20), address(0x0));\r\n        prizeCutTotalSupply = prizeCutTotalSupply.sub(prizeCutTotalSupply.div(20));\r\n            } else {revert(\"You don't have all this familyId's puzzles\");\r\n            }}\r\n    \r\n\r\n\r\n    \r\n    \r\n     ///////////////////////////\r\n    /// Market with EIP 712 ///\r\n   ///////////////////////////\r\n    \r\n        function hash(EIP712Domain memory eip712Domain) private pure returns (bytes32) {\r\n        return keccak256(abi.encode(\r\n            EIP712DOMAIN_TYPEHASH,\r\n            keccak256(bytes(eip712Domain.name)),\r\n            eip712Domain.chainId,\r\n            eip712Domain.verifyingContract\r\n        ));\r\n    }\r\n \r\n         function hash(SignTrade memory trade) private pure returns (bytes32) {\r\n        return keccak256(abi.encode(\r\n            TRADE_TYPEHASH,\r\n            trade.maker,\r\n            trade.makerWei,\r\n            keccak256(abi.encodePacked(trade.makerIds)),\r\n            trade.taker,\r\n            trade.takerWei,\r\n            keccak256(abi.encodePacked(trade.takerIds)),\r\n            trade.expiry\r\n        ));\r\n    }\r\n    \r\n      function verify(address signer, SignTrade memory trade, bytes memory signature) internal view returns (bool) {\r\n        // Note: we need to use `encodePacked` here instead of `encode`.\r\n        require(signer != address(0));\r\n        require(signature.length == 65);\r\n        bytes32 digest = keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPARATOR,\r\n            hash(trade)\r\n        ));\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            v := byte(0, mload(add(signature, 96)))\r\n        }\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n        require(v == 27 || v == 28);\r\n        return ecrecover(digest, v, r, s) == trade.maker;\r\n    }\r\n\r\n    function tradeValid(address maker, uint256 makerWei, uint256[] memory makerIds, address taker, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, bytes memory signature) \r\n    view public returns (bool) {\r\n        SignTrade memory trade = SignTrade(maker, makerWei, makerIds, taker, takerWei, takerIds, expiry);\r\n        // Check for cancellation\r\n        bytes32 hashCancel = keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPARATOR,\r\n            hash(trade)\r\n        ));\r\n        require(cancelledTrade[hashCancel] == false, \"Trade offer was cancelled.\");\r\n        // Verify signature\r\n        require(verify(trade.maker, trade, signature), \"Signature not valid.\");\r\n        // Check for expiry\r\n        require(block.timestamp < trade.expiry, \"Trade offer expired.\");\r\n        // Only one side should ever have to pay, not both\r\n        require(makerWei == 0 || takerWei == 0, \"Only one side of trade must pay.\");\r\n        // At least one side should offer tokens\r\n        require(makerIds.length > 0 || takerIds.length > 0, \"One side must offer tokens.\");\r\n        // Make sure the maker has funded the trade\r\n        require(pendingWithdrawals[trade.maker] >= trade.makerWei, \"Maker does not have sufficient balance.\");\r\n        // Ensure the maker owns the maker tokens\r\n        for (uint i = 0; i < trade.makerIds.length; i++) {\r\n            require(tokenIndexToAddress[trade.makerIds[i]] == trade.maker, \"At least one maker token doesn't belong to maker.\");\r\n        if (trade.makerIds[i] != 0) {require(tokenIndexToAddress[trade.makerIds[i].add(24).div(25).add(5000)] == address(0x0), \"Already Mint\");\r\n        }\r\n        }\r\n        // If the taker can be anybody, then there can be no taker tokens\r\n        if (trade.taker == address(0)) {\r\n            //// If taker not specified, then can't specify IDs\r\n            //require(trade.takerIds.length == 0, \"If trade is offered to anybody, cannot specify tokens from taker.\");\r\n            for (uint i = 0; i < trade.takerIds.length; i++) {\r\n                require(tokenIndexToAddress[trade.takerIds[i]] == msg.sender, \"At least one taker token doesn't belong to taker.\");\r\n                if (trade.takerIds[i] != 0) {require(tokenIndexToAddress[trade.takerIds[i].add(24).div(25).add(5000)] == address(0x0), \"Already Mint\");\r\n            }\r\n            }\r\n        } else {\r\n            // Ensure the taker owns the taker tokens\r\n            for (uint i = 0; i < trade.takerIds.length; i++) {\r\n                require(tokenIndexToAddress[trade.takerIds[i]] == trade.taker, \"At least one taker token doesn't belong to taker.\");\r\n            if (trade.takerIds[i] != 0) {require(tokenIndexToAddress[trade.takerIds[i].add(24).div(25).add(5000)] == address(0x0), \"Already Mint\");\r\n            }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function cancelTrade(address maker, uint256 makerWei, uint256[] memory makerIds, address taker, uint256 takerWei, uint256[] memory takerIds, uint256 expiry) external {\r\n        require(maker == msg.sender, \"Only the maker can cancel this offer.\");\r\n        SignTrade memory trade = SignTrade(maker, makerWei, makerIds, taker, takerWei, takerIds, expiry);\r\n        bytes32 hashCancel = keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPARATOR,\r\n            hash(trade)\r\n        ));\r\n        cancelledTrade[hashCancel] = true;\r\n        emit TradeCancelled(trade.maker, trade.makerWei, trade.makerIds, trade.taker, trade.takerWei, trade.takerIds, expiry);\r\n    }\r\n\r\n    function acceptTrade(address maker, uint256 makerWei, uint256[] memory makerIds, address taker, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, bytes memory signature) external payable reentrancyGuard {\r\n        require(msg.sender != maker, \"Can't accept ones own trade.\");\r\n        SignTrade memory trade = SignTrade(maker, makerWei, makerIds, taker, takerWei, takerIds, expiry);\r\n        if (msg.value > 0) {\r\n            pendingWithdrawals[msg.sender] = pendingWithdrawals[msg.sender].add(msg.value);\r\n         //  emit Deposit(msg.sender, msg.value);\r\n        }\r\n        require(trade.taker == address(0) || trade.taker == msg.sender, \"Not the recipient of this offer.\");\r\n        require(tradeValid(maker, makerWei, makerIds, taker, takerWei, takerIds, expiry, signature), \"Trade not valid.\");\r\n        require(pendingWithdrawals[msg.sender] >= trade.takerWei, \"Insufficient funds to execute trade.\");\r\n        // Transfer ETH & Tax\r\n            address weiEmitter;\r\n            address weiReceiver;\r\n            uint amountTrade;\r\n            uint taxNumber;\r\n        if (trade.makerWei > 0) {\r\n             weiEmitter = trade.maker;\r\n             weiReceiver = msg.sender;\r\n             amountTrade = trade.makerWei;\r\n        } else {\r\n             weiEmitter = msg.sender;\r\n             weiReceiver = trade.maker;\r\n             amountTrade = trade.takerWei;\r\n        }\r\n        for (uint i = 0; i < takerIds.length; i++) {\r\n            if (trade.takerIds[i] == 0 || trade.takerIds[i] >= 5001) {\r\n                 taxNumber = 1;\r\n            } else {\r\n                 taxNumber = 2;\r\n            }\r\n        }\r\n        for (uint i = 0; i < makerIds.length; i++) {\r\n            if (trade.makerIds[i] == 0 || trade.makerIds[i] >= 5001) {\r\n                 taxNumber = 1;\r\n                                                                      } else  {\r\n                 taxNumber = 2;\r\n                                                                              }\r\n                                                    }\r\n        pendingWithdrawals[weiEmitter] = pendingWithdrawals[weiEmitter].sub(amountTrade);\r\n        pendingWithdrawals[weiReceiver] = pendingWithdrawals[weiReceiver].add(amountTrade.sub(amountTrade.mul(3).mul(taxNumber).div(100)));\r\n        ownerCutTotalSupply = ownerCutTotalSupply.add(amountTrade.mul(OWNERCUTPERCENTAGE).div(100));\r\n        prizeCutTotalSupply = prizeCutTotalSupply.add(amountTrade.mul(PRIZECUTPERCENTAGE).mul(taxNumber.sub(1)).div(100));\r\n        // Transfer maker ids to taker (msg.sender)\r\n        for (uint i = 0; i < makerIds.length; i++) {\r\n            tokenIndexToAddress[trade.makerIds[i]] = msg.sender;\r\n            //transfertoken(msg.sender, makerIds[i]);\r\n        }\r\n        // Transfer taker ids to maker\r\n        for (uint i = 0; i < takerIds.length; i++) {\r\n            tokenIndexToAddress[trade.takerIds[i]] = maker;\r\n            //transfertoken(maker, takerIds[i]);\r\n        }\r\n        // Prevent a replay attack on this offer\r\n        bytes32 hashCancel = keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPARATOR,\r\n            hash(trade)\r\n        ));\r\n        cancelledTrade[hashCancel] = true;\r\n    emit Trade(trade.maker, trade.makerWei, trade.makerIds, msg.sender, trade.takerWei, trade.takerIds, expiry, signature);\r\n    }\r\n        }","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_a_contract_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenIndex\",\"type\":\"uint256\"}],\"name\":\"Assign\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"BaseURIChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"SaleForced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"NumberRobot\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"robotString\",\"type\":\"string\"}],\"name\":\"Store\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"makerWei\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"makerIds\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerWei\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"takerIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"Trade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"makerWei\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"makerIds\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerWei\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"takerIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"TradeCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"OWNERCUTPERCENTAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRIZECUTPERCENTAGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTALSUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makerWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"makerIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"takerWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"takerIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"acceptTrade\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makerWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"makerIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"takerWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"takerIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"cancelTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimtoken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenIndex\",\"type\":\"uint256\"}],\"name\":\"forceBuy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceBuyInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceBuyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"familyId\",\"type\":\"uint256\"}],\"name\":\"mintCPZ\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerCutTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"pauseMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingWithdrawals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prizeCutTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stack\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_forceBuyPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_forceBuyInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_saleDuration\",\"type\":\"uint256\"}],\"name\":\"startSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAssign\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIndexToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenLinearClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"makerWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"makerIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"takerWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"takerIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"tradeValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenIndex\",\"type\":\"uint256\"}],\"name\":\"transferToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CryptoPuzzle","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000c6ee915d58b2e3c120ecbf7527e34054ccde378","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://564bae8475c68d175bf8a23d95310d33739e4d108a1b9d95658b139524f68951"}]}