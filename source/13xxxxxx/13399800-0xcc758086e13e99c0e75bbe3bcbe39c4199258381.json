{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BasementDwellersStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface Factory {\\n    function mint(address) external;\\n}\\n\\ninterface Pass {\\n    function balanceOf(address) external view returns (uint256);\\n}\\n\\ncontract BasementDwellersStore is Ownable {\\n    Pass public constant pass =\\n        Pass(0x3c17017F5a584628cf8cb579A38455DBBF3f93e7);\\n    Factory public constant bdFactory =\\n        Factory(0x9A95eCEe5161b888fFE9Abd3D920c5D38e8539dA);\\n\\n    address private constant core1Address =\\n        0x105195bE68a677d80303B9962b309A30DEf24783;\\n    uint256 private constant core1Shares = 62625;\\n\\n    address private constant core2Address =\\n        0x073DfB7bf2A23f13a547FB4898a46d072f6792f8;\\n    uint256 private constant core2Shares = 26375;\\n\\n    address private constant core3Address =\\n        0x32b9d0167BD2ffaf4Fb6Be5B1CA5cc3FB29b7c40;\\n\\n    address private constant core4Address =\\n        0x704c7dA8D117Ff5cf3C3268EeCaB6A80188B2AAc;\\n    uint256 private constant core4Shares = 7000;\\n\\n    address private constant advisor1Address =\\n        0xD09659effC0DE1855e9D33A4F80Eb4348CA50aF2;\\n    uint256 private constant advisor1Shares = 4000;\\n\\n\\n    uint256 private constant baseMod = 100000;\\n\\n    /**\\n        Numbers for Basement Dwellers Factory\\n     */\\n    uint256 public constant maxDwellers = 10000;\\n\\n    /**\\n        Team allocated Dwellers\\n     */\\n    // Dwellers which is minted by the owner\\n    uint256 public preMintedDwellers = 0;\\n    // MAX Dwellers which owner can mint\\n    uint256 public constant maxPreMintDwellers = 150;\\n\\n    /**\\n        Mint Pass\\n     */\\n    uint256 public newlyMintedDwellersWithPass = 0;\\n    uint256 public constant maxDwellersPerPass = 5;\\n    mapping(address => uint256) public mintedDwellersOf;\\n\\n    /**\\n        Tracking Dweller Sales After Presale\\n     */\\n    uint256 public mintedDwellersAfterPresale = 0;\\n\\n    /**\\n        Scheduling\\n     */\\n    uint256 public openingHours = 1633996800; // Mon Oct 11 2021 17:00:00 PDT\\n    uint256 public constant operationSecondsForVIP = 3600 * 24; // 24 hours\\n    uint256 public constant operationSeconds = 3600 * 24; // 24 hours\\n\\n    /**\\n        Ticket\\n     */\\n    uint256 public constant ticketPrice = 0.069 ether;\\n    uint256 public totalTickets = 0;\\n    mapping(address => ticket) public ticketsOf;\\n    struct ticket {\\n        uint256 index; // Incl\\n        uint256 amount;\\n    }\\n\\n    /**\\n        Withdrawal totals\\n     */\\n    uint256 public withdrawTotal = 0;\\n\\n    /**\\n        Security\\n     */\\n    uint256 public constant maxMintPerTx = 30;\\n\\n    /**\\n        Raffle\\n     */\\n    uint256 public raffleNumber;\\n    uint256 public offsetInSlot;\\n    uint256 public slotSize;\\n    uint256 public lastTargetIndex; // index greater than this is dis-regarded\\n    mapping(address => result) public resultOf;\\n    struct result {\\n        bool executed;\\n        uint256 validTicketAmount;\\n    }\\n\\n    bool public isSoldOut = false;\\n    uint256 public remainingDwellers = 0;\\n\\n    // event SetPass(address pass);\\n    // event SetDwellersFactory(address bdFactory);\\n    event SetOpeningHours(uint256 openingHours);\\n    event MintWithPass(address account, uint256 amount, uint256 changes);\\n    event TakingTickets(address account, uint256 amount, uint256 changes);\\n    event SetRemainingDwellers(uint256 remainingDwellers);\\n    event RunRaffle(uint256 raffleNumber);\\n    event SetResult(\\n        address account,\\n        uint256 validTicketAmount,\\n        uint256 changes\\n    );\\n    event PurchaseRemainingDwellers(address account, uint256 amount);\\n    event MintDwellers(address account, uint256 mintRequestAmount);\\n    event Withdraw(address to);\\n\\n    constructor() {}\\n\\n    modifier whenOpened() {\\n        require(\\n            block.timestamp >= openingHours + operationSecondsForVIP,\\n            \\\"Store is not opened\\\"\\n        );\\n        require(\\n            block.timestamp <\\n                openingHours + operationSecondsForVIP + operationSeconds,\\n            \\\"Store is closed\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier whenVIPOpened() {\\n        require(block.timestamp >= openingHours, \\\"Store is not opened for VIP\\\");\\n        require(\\n            block.timestamp < openingHours + operationSecondsForVIP,\\n            \\\"Store is closed for VIP\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyOwnerOrTeam() {\\n        require(\\n            core1Address == msg.sender || core2Address == msg.sender || core3Address == msg.sender || core4Address == msg.sender || owner() == msg.sender,\\n            \\\"caller is neither Team Wallet nor Owner\\\"\\n        );\\n        _;\\n    }\\n\\n    // function setPass(Pass _pass) external onlyOwner {\\n    //     pass = _pass;\\n    //     emit SetPass(address(_pass));\\n    // }\\n\\n    // function setDwellersFactory(Factory _bdFactory) external onlyOwner {\\n    //     bdFactory = _bdFactory;\\n    //     emit SetDwellersFactory(address(_bdFactory));\\n    // }\\n\\n    function setOpeningHours(uint256 _openingHours) external onlyOwner {\\n        openingHours = _openingHours;\\n        emit SetOpeningHours(_openingHours);\\n    }\\n\\n    // Do not update newlyMintedDwellers to prevent withdrawal\\n    function preMintDwellers(address[] memory recipients) external onlyOwner {\\n        require(\\n            block.timestamp <\\n                openingHours + operationSecondsForVIP + operationSeconds,\\n            \\\"Not available after ticketing period\\\"\\n        );\\n        uint256 totalRecipients = recipients.length;\\n\\n        require(\\n            totalRecipients > 0,\\n            \\\"Number of recipients must be greater than 0\\\"\\n        );\\n        require(\\n            preMintedDwellers + totalRecipients <= maxPreMintDwellers,\\n            \\\"Exceeds max pre-mint Dwellers\\\"\\n        );\\n\\n        for (uint256 i = 0; i < totalRecipients; i++) {\\n            address to = recipients[i];\\n            require(to != address(0), \\\"receiver can not be empty address\\\");\\n            bdFactory.mint(to);\\n        }\\n\\n        preMintedDwellers += totalRecipients;\\n    }\\n\\n    function mintWithPass(uint256 _amount) external payable whenVIPOpened {\\n        require(_amount <= maxMintPerTx, \\\"mint amount exceeds maximum\\\");\\n        require(_amount > 0, \\\"Need to mint more than 0\\\");\\n\\n        uint256 mintedDwellers = mintedDwellersOf[msg.sender];\\n\\n        uint256 passAmount = pass.balanceOf(msg.sender);\\n\\n        // if (passAmount < bonusPassAmount) {\\n        //     passAmount = bonusPassAmount;\\n        // }\\n\\n        require(\\n            passAmount * maxDwellersPerPass - mintedDwellers >= _amount,\\n            \\\"Not enough Pass\\\"\\n        );\\n\\n        uint256 totalPrice = ticketPrice * _amount;\\n        require(totalPrice <= msg.value, \\\"Not enough money\\\");\\n\\n        for (uint256 i = 0; i < _amount; i += 1) {\\n            bdFactory.mint(msg.sender);\\n        }\\n\\n        mintedDwellersOf[msg.sender] = mintedDwellers + _amount;\\n        newlyMintedDwellersWithPass += _amount;\\n\\n        // Refund changes\\n        uint256 changes = msg.value - totalPrice;\\n        emit MintWithPass(msg.sender, _amount, changes);\\n\\n        if (changes > 0) {\\n            payable(msg.sender).transfer(changes);\\n        }\\n    }\\n\\n    function takingTickets(uint256 _amount) external payable whenOpened {\\n        require(_amount > 0, \\\"Need to take ticket more than 0\\\");\\n\\n        ticket storage myTicket = ticketsOf[msg.sender];\\n        require(myTicket.amount == 0, \\\"Already registered\\\");\\n\\n        uint256 totalPrice = ticketPrice * _amount;\\n        require(totalPrice <= msg.value, \\\"Not enough money\\\");\\n\\n        myTicket.index = totalTickets;\\n        myTicket.amount = _amount;\\n\\n        totalTickets = totalTickets + _amount;\\n\\n        // Refund changes\\n        uint256 changes = msg.value - totalPrice;\\n        emit TakingTickets(msg.sender, _amount, changes);\\n\\n        if (changes > 0) {\\n            payable(msg.sender).transfer(changes);\\n        }\\n    }\\n\\n    function runRaffle(uint256 _raffleNumber) external onlyOwner {\\n        require(\\n            block.timestamp >\\n                openingHours + operationSecondsForVIP + operationSeconds,\\n            \\\"Store is not closed yet\\\"\\n        );\\n        require(raffleNumber == 0, \\\"raffle number is already set\\\");\\n\\n        raffleNumber = _raffleNumber;\\n\\n        uint256 _remainingDwellers = maxDwellers -\\n            preMintedDwellers -\\n            newlyMintedDwellersWithPass;\\n\\n        if (totalTickets <= _remainingDwellers) {\\n            isSoldOut = false;\\n            remainingDwellers = _remainingDwellers - totalTickets;\\n\\n            mintedDwellersAfterPresale = totalTickets;\\n        } else {\\n            isSoldOut = true;\\n\\n            slotSize = totalTickets / _remainingDwellers;\\n            offsetInSlot = _raffleNumber % slotSize;\\n            lastTargetIndex = slotSize * _remainingDwellers - 1;\\n\\n            mintedDwellersAfterPresale = _remainingDwellers;\\n        }\\n\\n        emit RunRaffle(_raffleNumber);\\n    }\\n\\n    function calculateValidTicketAmount(\\n        uint256 index,\\n        uint256 amount,\\n        uint256 _slotSize,\\n        uint256 _offsetInSlot,\\n        uint256 _lastTargetIndex\\n    ) internal pure returns (uint256 validTicketAmount) {\\n        /**\\n\\n        /_____fio___\\\\___________________________________/lio\\\\___________\\n                v   f |         v     |         v     |     l   v     |\\n        ______slot #n__|___slot #n+1___|____slot #n+2__|____slot #n+3__|\\n\\n            f : first index (incl.)\\n            l : last index (incl.)\\n            v : win ticket\\n            fio : first index offset\\n            lio : last index offset\\n            n, n+1,... : slot index\\n            \\n            v in (slot #n+1) is ths firstWinIndex\\n            v in (slot #n+2) is ths lastWinIndex\\n        */\\n        uint256 lastIndex = index + amount - 1; // incl.\\n        if (lastIndex > _lastTargetIndex) {\\n            lastIndex = _lastTargetIndex;\\n        }\\n\\n        uint256 firstIndexOffset = index % _slotSize;\\n        uint256 lastIndexOffset = lastIndex % _slotSize;\\n\\n        uint256 firstWinIndex;\\n        if (firstIndexOffset <= _offsetInSlot) {\\n            firstWinIndex = index + _offsetInSlot - firstIndexOffset;\\n        } else {\\n            firstWinIndex =\\n                index +\\n                _slotSize +\\n                _offsetInSlot -\\n                firstIndexOffset;\\n        }\\n\\n        // Nothing is selected\\n        if (firstWinIndex > _lastTargetIndex) {\\n            validTicketAmount = 0;\\n        } else {\\n            uint256 lastWinIndex;\\n            if (lastIndexOffset >= _offsetInSlot) {\\n                lastWinIndex = lastIndex + _offsetInSlot - lastIndexOffset;\\n            } else if (lastIndex < _slotSize) {\\n                lastWinIndex = 0;\\n            } else {\\n                lastWinIndex =\\n                    lastIndex +\\n                    _offsetInSlot -\\n                    lastIndexOffset -\\n                    _slotSize;\\n            }\\n\\n            if (firstWinIndex > lastWinIndex) {\\n                validTicketAmount = 0;\\n            } else {\\n                validTicketAmount =\\n                    (lastWinIndex - firstWinIndex) /\\n                    _slotSize +\\n                    1;\\n            }\\n        }\\n    }\\n\\n    function calculateMyResult() external {\\n        require(raffleNumber > 0, \\\"raffle number is not set yet\\\");\\n\\n        ticket storage myTicket = ticketsOf[msg.sender];\\n        require(myTicket.amount > 0, \\\"No available ticket\\\");\\n\\n        result storage myResult = resultOf[msg.sender];\\n        require(!myResult.executed, \\\"Already checked\\\");\\n\\n        uint256 validTicketAmount;\\n        if (!isSoldOut) {\\n            validTicketAmount = myTicket.amount;\\n        } else {\\n            validTicketAmount = calculateValidTicketAmount(\\n                myTicket.index,\\n                myTicket.amount,\\n                slotSize,\\n                offsetInSlot,\\n                lastTargetIndex\\n            );\\n        }\\n\\n        myResult.validTicketAmount = validTicketAmount;\\n        myResult.executed = true;\\n\\n        uint256 remainingTickets = myTicket.amount - validTicketAmount;\\n        uint256 changes = remainingTickets * ticketPrice;\\n\\n        emit SetResult(msg.sender, validTicketAmount, changes);\\n        if (changes > 0) {\\n            payable(msg.sender).transfer(changes);\\n        }\\n    }\\n\\n    function purchaseRemainingDwellers(uint256 _amount) external payable {\\n        require(_amount <= remainingDwellers, \\\"Exceeds dwellers max supply\\\");\\n\\n        uint256 totalPrice = ticketPrice * _amount;\\n        require(totalPrice <= msg.value, \\\"Not enough money\\\");\\n\\n        for (uint256 i = 0; i < _amount; i += 1) {\\n            bdFactory.mint(msg.sender);\\n        }\\n\\n        mintedDwellersAfterPresale += _amount;\\n        remainingDwellers -= _amount;\\n\\n        uint256 changes = msg.value - totalPrice;\\n        if (changes > 0) {\\n            payable(msg.sender).transfer(changes);\\n        }\\n\\n        emit PurchaseRemainingDwellers(msg.sender, _amount);\\n    }\\n\\n    function mintDwellers() external {\\n        result storage myResult = resultOf[msg.sender];\\n\\n        require(myResult.executed, \\\"result is not calculated yet\\\");\\n        require(myResult.validTicketAmount > 0, \\\"No valid tickets\\\");\\n\\n        uint256 mintRequestAmount = 0;\\n\\n        // test if over max mint per tx\\n        if (myResult.validTicketAmount > maxMintPerTx) {\\n            mintRequestAmount = maxMintPerTx;\\n            myResult.validTicketAmount -= maxMintPerTx;\\n        } else {\\n            mintRequestAmount = myResult.validTicketAmount;\\n            myResult.validTicketAmount = 0;\\n        }\\n\\n        for (uint256 i = 0; i < mintRequestAmount; i += 1) {\\n            bdFactory.mint(msg.sender);\\n        }\\n\\n        emit MintDwellers(msg.sender, mintRequestAmount);\\n    }\\n\\n    // withdraw eth for sold Dwellers\\n    function withdrawAll() external onlyOwnerOrTeam {\\n        uint256 maxWithdrawalAmount = ticketPrice *\\n            (newlyMintedDwellersWithPass + mintedDwellersAfterPresale);\\n\\n        require(\\n            maxWithdrawalAmount > withdrawTotal,\\n            \\\"No Funds Currently To Withdraw\\\"\\n        );\\n\\n        uint256 withdrawalAmount = maxWithdrawalAmount - withdrawTotal;\\n\\n        _splitAll(withdrawalAmount);\\n        withdrawTotal += withdrawalAmount;\\n    }\\n\\n    function _splitAll(uint256 _amount) private {\\n        uint256 singleShare = _amount / baseMod;\\n        _withdraw(core1Address, singleShare * core1Shares);\\n        _withdraw(core2Address, singleShare * core2Shares);\\n        _withdraw(core4Address, singleShare * core4Shares);\\n        _withdraw(advisor1Address, singleShare * advisor1Shares);\\n    }\\n\\n    function _withdraw(address _address, uint256 _amount) private {\\n        payable(_address).transfer(_amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintRequestAmount\",\"type\":\"uint256\"}],\"name\":\"MintDwellers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"changes\",\"type\":\"uint256\"}],\"name\":\"MintWithPass\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PurchaseRemainingDwellers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raffleNumber\",\"type\":\"uint256\"}],\"name\":\"RunRaffle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"openingHours\",\"type\":\"uint256\"}],\"name\":\"SetOpeningHours\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingDwellers\",\"type\":\"uint256\"}],\"name\":\"SetRemainingDwellers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validTicketAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"changes\",\"type\":\"uint256\"}],\"name\":\"SetResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"changes\",\"type\":\"uint256\"}],\"name\":\"TakingTickets\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"bdFactory\",\"outputs\":[{\"internalType\":\"contract Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateMyResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSoldOut\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTargetIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDwellers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDwellersPerPass\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintPerTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPreMintDwellers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintDwellers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintWithPass\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintedDwellersAfterPresale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintedDwellersOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newlyMintedDwellersWithPass\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetInSlot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openingHours\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operationSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operationSecondsForVIP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pass\",\"outputs\":[{\"internalType\":\"contract Pass\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"}],\"name\":\"preMintDwellers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"preMintedDwellers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"purchaseRemainingDwellers\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raffleNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingDwellers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"resultOf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"validTicketAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_raffleNumber\",\"type\":\"uint256\"}],\"name\":\"runRaffle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_openingHours\",\"type\":\"uint256\"}],\"name\":\"setOpeningHours\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slotSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"takingTickets\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ticketsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BasementDwellersStore","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}