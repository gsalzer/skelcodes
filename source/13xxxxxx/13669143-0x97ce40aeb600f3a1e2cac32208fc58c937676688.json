{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/crossApproach/lib/RapidityTxLib.sol\n\n/*\n\n  Copyright 2019 Wanchain Foundation.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\n//                            _           _           _\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\n//\n//\n\npragma solidity ^0.4.26;\n\nlibrary RapidityTxLib {\n\n    /**\n     *\n     * ENUMS\n     *\n     */\n\n    /// @notice tx info status\n    /// @notice uninitialized,Redeemed\n    enum TxStatus {None, Redeemed}\n\n    /**\n     *\n     * STRUCTURES\n     *\n     */\n    struct Data {\n        /// @notice mapping of uniqueID to TxStatus -- uniqueID->TxStatus\n        mapping(bytes32 => TxStatus) mapTxStatus;\n\n    }\n\n    /**\n     *\n     * MANIPULATIONS\n     *\n     */\n\n    /// @notice                     add user transaction info\n    /// @param  uniqueID            Rapidity random number\n    function addRapidityTx(Data storage self, bytes32 uniqueID)\n        internal\n    {\n        TxStatus status = self.mapTxStatus[uniqueID];\n        require(status == TxStatus.None, \"Rapidity tx exists\");\n        self.mapTxStatus[uniqueID] = TxStatus.Redeemed;\n    }\n}\n\n// File: contracts/interfaces/IRC20Protocol.sol\n\n/*\n\n  Copyright 2019 Wanchain Foundation.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\n//                            _           _           _\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\n//\n//\n\npragma solidity ^0.4.26;\n\ninterface IRC20Protocol {\n    function transfer(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n    function balanceOf(address _owner) external view returns (uint);\n}\n\n// File: contracts/interfaces/IQuota.sol\n\n/*\n\n  Copyright 2019 Wanchain Foundation.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\n//                            _           _           _\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\n//\n//\n\npragma solidity 0.4.26;\n\ninterface IQuota {\n  function userLock(uint tokenId, bytes32 storemanGroupId, uint value) external;\n  function userBurn(uint tokenId, bytes32 storemanGroupId, uint value) external;\n\n  function smgRelease(uint tokenId, bytes32 storemanGroupId, uint value) external;\n  function smgMint(uint tokenId, bytes32 storemanGroupId, uint value) external;\n\n  function upgrade(bytes32 storemanGroupId) external;\n\n  function transferAsset(bytes32 srcStoremanGroupId, bytes32 dstStoremanGroupId) external;\n  function receiveDebt(bytes32 srcStoremanGroupId, bytes32 dstStoremanGroupId) external;\n\n  function getUserMintQuota(uint tokenId, bytes32 storemanGroupId) external view returns (uint);\n  function getSmgMintQuota(uint tokenId, bytes32 storemanGroupId) external view returns (uint);\n\n  function getUserBurnQuota(uint tokenId, bytes32 storemanGroupId) external view returns (uint);\n  function getSmgBurnQuota(uint tokenId, bytes32 storemanGroupId) external view returns (uint);\n\n  function getAsset(uint tokenId, bytes32 storemanGroupId) external view returns (uint asset, uint asset_receivable, uint asset_payable);\n  function getDebt(uint tokenId, bytes32 storemanGroupId) external view returns (uint debt, uint debt_receivable, uint debt_payable);\n\n  function isDebtClean(bytes32 storemanGroupId) external view returns (bool);\n}\n\n// File: contracts/interfaces/IStoremanGroup.sol\n\n/*\n\n  Copyright 2019 Wanchain Foundation.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\n//                            _           _           _\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\n//\n//\n\npragma solidity ^0.4.24;\n\ninterface IStoremanGroup {\n    function getSelectedSmNumber(bytes32 groupId) external view returns(uint number);\n    function getStoremanGroupConfig(bytes32 id) external view returns(bytes32 groupId, uint8 status, uint deposit, uint chain1, uint chain2, uint curve1, uint curve2,  bytes gpk1, bytes gpk2, uint startTime, uint endTime);\n    function getDeposit(bytes32 id) external view returns(uint);\n    function getStoremanGroupStatus(bytes32 id) external view returns(uint8 status, uint startTime, uint endTime);\n    function setGpk(bytes32 groupId, bytes gpk1, bytes gpk2) external;\n    function setInvalidSm(bytes32 groupId, uint[] indexs, uint8[] slashTypes) external returns(bool isContinue);\n    function getThresholdByGrpId(bytes32 groupId) external view returns (uint);\n    function getSelectedSmInfo(bytes32 groupId, uint index) external view returns(address wkAddr, bytes PK, bytes enodeId);\n    function recordSmSlash(address wk) public;\n}\n\n// File: contracts/interfaces/ITokenManager.sol\n\n/*\n\n  Copyright 2019 Wanchain Foundation.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\n//                            _           _           _\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\n//\n//\n\npragma solidity 0.4.26;\n\ninterface ITokenManager {\n    function getTokenPairInfo(uint id) external view\n      returns (uint origChainID, bytes tokenOrigAccount, uint shadowChainID, bytes tokenShadowAccount);\n\n    function getTokenPairInfoSlim(uint id) external view \n      returns (uint origChainID, bytes tokenOrigAccount, uint shadowChainID);\n\n    function getAncestorInfo(uint id) external view\n      returns (bytes account, string name, string symbol, uint8 decimals, uint chainId);\n\n    function mintToken(address tokenAddress, address to, uint value) external;\n\n    function burnToken(address tokenAddress, address from, uint value) external;\n}\n\n// File: contracts/interfaces/ISignatureVerifier.sol\n\n/*\n\n  Copyright 2019 Wanchain Foundation.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\n//                            _           _           _\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\n//\n//\n\npragma solidity 0.4.26;\n\ninterface ISignatureVerifier {\n  function verify(\n        uint curveId,\n        bytes32 signature,\n        bytes32 groupKeyX,\n        bytes32 groupKeyY,\n        bytes32 randomPointX,\n        bytes32 randomPointY,\n        bytes32 message\n    ) external returns (bool);\n}\n\n// File: contracts/lib/SafeMath.sol\n\npragma solidity ^0.4.24;\n\n/**\n * Math operations with safety checks\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath mul overflow\");\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath div 0\"); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath sub b > a\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath add overflow\");\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath mod 0\");\n        return a % b;\n    }\n}\n\n// File: contracts/crossApproach/lib/HTLCTxLib.sol\n\n/*\n\n  Copyright 2019 Wanchain Foundation.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\n//                            _           _           _\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\n//\n//\n\npragma solidity ^0.4.26;\n\n\n\nlibrary HTLCTxLib {\n    using SafeMath for uint;\n\n    /**\n     *\n     * ENUMS\n     *\n     */\n\n    /// @notice tx info status\n    /// @notice uninitialized,locked,redeemed,revoked\n    enum TxStatus {None, Locked, Redeemed, Revoked, AssetLocked, DebtLocked}\n\n    /**\n     *\n     * STRUCTURES\n     *\n     */\n\n    /// @notice struct of HTLC user mint lock parameters\n    struct HTLCUserParams {\n        bytes32 xHash;                  /// hash of HTLC random number\n        bytes32 smgID;                  /// ID of storeman group which user has selected\n        uint tokenPairID;               /// token pair id on cross chain\n        uint value;                     /// exchange token value\n        uint lockFee;                   /// exchange token value\n        uint lockedTime;                /// HTLC lock time\n    }\n\n    /// @notice HTLC(Hashed TimeLock Contract) tx info\n    struct BaseTx {\n        bytes32 smgID;                  /// HTLC transaction storeman ID\n        uint lockedTime;                /// HTLC transaction locked time\n        uint beginLockedTime;           /// HTLC transaction begin locked time\n        TxStatus status;                /// HTLC transaction status\n    }\n\n    /// @notice user  tx info\n    struct UserTx {\n        BaseTx baseTx;\n        uint tokenPairID;\n        uint value;\n        uint fee;\n        address userAccount;            /// HTLC transaction sender address for the security check while user's revoke\n    }\n    /// @notice storeman  tx info\n    struct SmgTx {\n        BaseTx baseTx;\n        uint tokenPairID;\n        uint value;\n        address  userAccount;          /// HTLC transaction user address for the security check while user's redeem\n    }\n    /// @notice storeman  debt tx info\n    struct DebtTx {\n        BaseTx baseTx;\n        bytes32 srcSmgID;              /// HTLC transaction sender(source storeman) ID\n    }\n\n    struct Data {\n        /// @notice mapping of hash(x) to UserTx -- xHash->htlcUserTxData\n        mapping(bytes32 => UserTx) mapHashXUserTxs;\n\n        /// @notice mapping of hash(x) to SmgTx -- xHash->htlcSmgTxData\n        mapping(bytes32 => SmgTx) mapHashXSmgTxs;\n\n        /// @notice mapping of hash(x) to DebtTx -- xHash->htlcDebtTxData\n        mapping(bytes32 => DebtTx) mapHashXDebtTxs;\n\n    }\n\n    /**\n     *\n     * MANIPULATIONS\n     *\n     */\n\n    /// @notice                     add user transaction info\n    /// @param params               parameters for user tx\n    function addUserTx(Data storage self, HTLCUserParams memory params)\n        public\n    {\n        UserTx memory userTx = self.mapHashXUserTxs[params.xHash];\n        // UserTx storage userTx = self.mapHashXUserTxs[params.xHash];\n        // require(params.value != 0, \"Value is invalid\");\n        require(userTx.baseTx.status == TxStatus.None, \"User tx exists\");\n\n        userTx.baseTx.smgID = params.smgID;\n        userTx.baseTx.lockedTime = params.lockedTime;\n        userTx.baseTx.beginLockedTime = now;\n        userTx.baseTx.status = TxStatus.Locked;\n        userTx.tokenPairID = params.tokenPairID;\n        userTx.value = params.value;\n        userTx.fee = params.lockFee;\n        userTx.userAccount = msg.sender;\n\n        self.mapHashXUserTxs[params.xHash] = userTx;\n    }\n\n    /// @notice                     refund coins from HTLC transaction, which is used for storeman redeem(outbound)\n    /// @param x                    HTLC random number\n    function redeemUserTx(Data storage self, bytes32 x)\n        external\n        returns(bytes32 xHash)\n    {\n        xHash = sha256(abi.encodePacked(x));\n\n        UserTx storage userTx = self.mapHashXUserTxs[xHash];\n        require(userTx.baseTx.status == TxStatus.Locked, \"Status is not locked\");\n        require(now < userTx.baseTx.beginLockedTime.add(userTx.baseTx.lockedTime), \"Redeem timeout\");\n\n        userTx.baseTx.status = TxStatus.Redeemed;\n\n        return xHash;\n    }\n\n    /// @notice                     revoke user transaction\n    /// @param  xHash               hash of HTLC random number\n    function revokeUserTx(Data storage self, bytes32 xHash)\n        external\n    {\n        UserTx storage userTx = self.mapHashXUserTxs[xHash];\n        require(userTx.baseTx.status == TxStatus.Locked, \"Status is not locked\");\n        require(now >= userTx.baseTx.beginLockedTime.add(userTx.baseTx.lockedTime), \"Revoke is not permitted\");\n\n        userTx.baseTx.status = TxStatus.Revoked;\n    }\n\n    /// @notice                    function for get user info\n    /// @param xHash               hash of HTLC random number\n    /// @return smgID              ID of storeman which user has selected\n    /// @return tokenPairID        token pair ID of cross chain\n    /// @return value              exchange value\n    /// @return fee                exchange fee\n    /// @return userAccount        HTLC transaction sender address for the security check while user's revoke\n    function getUserTx(Data storage self, bytes32 xHash)\n        external\n        view\n        returns (bytes32, uint, uint, uint, address)\n    {\n        UserTx storage userTx = self.mapHashXUserTxs[xHash];\n        return (userTx.baseTx.smgID, userTx.tokenPairID, userTx.value, userTx.fee, userTx.userAccount);\n    }\n\n    /// @notice                     add storeman transaction info\n    /// @param  xHash               hash of HTLC random number\n    /// @param  smgID               ID of the storeman which user has selected\n    /// @param  tokenPairID         token pair ID of cross chain\n    /// @param  value               HTLC transfer value of token\n    /// @param  userAccount            user account address on the destination chain, which is used to redeem token\n    function addSmgTx(Data storage self, bytes32 xHash, bytes32 smgID, uint tokenPairID, uint value, address userAccount, uint lockedTime)\n        external\n    {\n        SmgTx memory smgTx = self.mapHashXSmgTxs[xHash];\n        // SmgTx storage smgTx = self.mapHashXSmgTxs[xHash];\n        require(value != 0, \"Value is invalid\");\n        require(smgTx.baseTx.status == TxStatus.None, \"Smg tx exists\");\n\n        smgTx.baseTx.smgID = smgID;\n        smgTx.baseTx.status = TxStatus.Locked;\n        smgTx.baseTx.lockedTime = lockedTime;\n        smgTx.baseTx.beginLockedTime = now;\n        smgTx.tokenPairID = tokenPairID;\n        smgTx.value = value;\n        smgTx.userAccount = userAccount;\n\n        self.mapHashXSmgTxs[xHash] = smgTx;\n    }\n\n    /// @notice                     refund coins from HTLC transaction, which is used for users redeem(inbound)\n    /// @param x                    HTLC random number\n    function redeemSmgTx(Data storage self, bytes32 x)\n        external\n        returns(bytes32 xHash)\n    {\n        xHash = sha256(abi.encodePacked(x));\n\n        SmgTx storage smgTx = self.mapHashXSmgTxs[xHash];\n        require(smgTx.baseTx.status == TxStatus.Locked, \"Status is not locked\");\n        require(now < smgTx.baseTx.beginLockedTime.add(smgTx.baseTx.lockedTime), \"Redeem timeout\");\n\n        smgTx.baseTx.status = TxStatus.Redeemed;\n\n        return xHash;\n    }\n\n    /// @notice                     revoke storeman transaction\n    /// @param  xHash               hash of HTLC random number\n    function revokeSmgTx(Data storage self, bytes32 xHash)\n        external\n    {\n        SmgTx storage smgTx = self.mapHashXSmgTxs[xHash];\n        require(smgTx.baseTx.status == TxStatus.Locked, \"Status is not locked\");\n        require(now >= smgTx.baseTx.beginLockedTime.add(smgTx.baseTx.lockedTime), \"Revoke is not permitted\");\n\n        smgTx.baseTx.status = TxStatus.Revoked;\n    }\n\n    /// @notice                     function for get smg info\n    /// @param xHash                hash of HTLC random number\n    /// @return smgID               ID of storeman which user has selected\n    /// @return tokenPairID         token pair ID of cross chain\n    /// @return value               exchange value\n    /// @return userAccount            user account address for redeem\n    function getSmgTx(Data storage self, bytes32 xHash)\n        external\n        view\n        returns (bytes32, uint, uint, address)\n    {\n        SmgTx storage smgTx = self.mapHashXSmgTxs[xHash];\n        return (smgTx.baseTx.smgID, smgTx.tokenPairID, smgTx.value, smgTx.userAccount);\n    }\n\n    /// @notice                     add storeman transaction info\n    /// @param  xHash               hash of HTLC random number\n    /// @param  srcSmgID            ID of source storeman group\n    /// @param  destSmgID           ID of the storeman which will take over of the debt of source storeman group\n    /// @param  lockedTime          HTLC lock time\n    /// @param  status              Status, should be 'Locked' for asset or 'DebtLocked' for debt\n    function addDebtTx(Data storage self, bytes32 xHash, bytes32 srcSmgID, bytes32 destSmgID, uint lockedTime, TxStatus status)\n        external\n    {\n        DebtTx memory debtTx = self.mapHashXDebtTxs[xHash];\n        // DebtTx storage debtTx = self.mapHashXDebtTxs[xHash];\n        require(debtTx.baseTx.status == TxStatus.None, \"Debt tx exists\");\n\n        debtTx.baseTx.smgID = destSmgID;\n        debtTx.baseTx.status = status;//TxStatus.Locked;\n        debtTx.baseTx.lockedTime = lockedTime;\n        debtTx.baseTx.beginLockedTime = now;\n        debtTx.srcSmgID = srcSmgID;\n\n        self.mapHashXDebtTxs[xHash] = debtTx;\n    }\n\n    /// @notice                     refund coins from HTLC transaction\n    /// @param x                    HTLC random number\n    /// @param status               Status, should be 'Locked' for asset or 'DebtLocked' for debt\n    function redeemDebtTx(Data storage self, bytes32 x, TxStatus status)\n        external\n        returns(bytes32 xHash)\n    {\n        xHash = sha256(abi.encodePacked(x));\n\n        DebtTx storage debtTx = self.mapHashXDebtTxs[xHash];\n        // require(debtTx.baseTx.status == TxStatus.Locked, \"Status is not locked\");\n        require(debtTx.baseTx.status == status, \"Status is not locked\");\n        require(now < debtTx.baseTx.beginLockedTime.add(debtTx.baseTx.lockedTime), \"Redeem timeout\");\n\n        debtTx.baseTx.status = TxStatus.Redeemed;\n\n        return xHash;\n    }\n\n    /// @notice                     revoke debt transaction, which is used for source storeman group\n    /// @param  xHash               hash of HTLC random number\n    /// @param  status              Status, should be 'Locked' for asset or 'DebtLocked' for debt\n    function revokeDebtTx(Data storage self, bytes32 xHash, TxStatus status)\n        external\n    {\n        DebtTx storage debtTx = self.mapHashXDebtTxs[xHash];\n        // require(debtTx.baseTx.status == TxStatus.Locked, \"Status is not locked\");\n        require(debtTx.baseTx.status == status, \"Status is not locked\");\n        require(now >= debtTx.baseTx.beginLockedTime.add(debtTx.baseTx.lockedTime), \"Revoke is not permitted\");\n\n        debtTx.baseTx.status = TxStatus.Revoked;\n    }\n\n    /// @notice                     function for get debt info\n    /// @param xHash                hash of HTLC random number\n    /// @return srcSmgID            ID of source storeman\n    /// @return destSmgID           ID of destination storeman\n    function getDebtTx(Data storage self, bytes32 xHash)\n        external\n        view\n        returns (bytes32, bytes32)\n    {\n        DebtTx storage debtTx = self.mapHashXDebtTxs[xHash];\n        return (debtTx.srcSmgID, debtTx.baseTx.smgID);\n    }\n\n    function getLeftTime(uint endTime) private view returns (uint) {\n        if (now < endTime) {\n            return endTime.sub(now);\n        }\n        return 0;\n    }\n\n    /// @notice                     function for get debt info\n    /// @param xHash                hash of HTLC random number\n    /// @return leftTime            the left lock time\n    function getLeftLockedTime(Data storage self, bytes32 xHash)\n        external\n        view\n        returns (uint)\n    {\n        UserTx storage userTx = self.mapHashXUserTxs[xHash];\n        if (userTx.baseTx.status != TxStatus.None) {\n            return getLeftTime(userTx.baseTx.beginLockedTime.add(userTx.baseTx.lockedTime));\n        }\n        SmgTx storage smgTx = self.mapHashXSmgTxs[xHash];\n        if (smgTx.baseTx.status != TxStatus.None) {\n            return getLeftTime(smgTx.baseTx.beginLockedTime.add(smgTx.baseTx.lockedTime));\n        }\n        DebtTx storage debtTx = self.mapHashXDebtTxs[xHash];\n        if (debtTx.baseTx.status != TxStatus.None) {\n            return getLeftTime(debtTx.baseTx.beginLockedTime.add(debtTx.baseTx.lockedTime));\n        }\n        require(false, 'invalid xHash');\n    }\n}\n\n// File: contracts/crossApproach/lib/CrossTypesV1.sol\n\n/*\n\n  Copyright 2019 Wanchain Foundation.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\n//                            _           _           _\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\n//\n//\n\npragma solidity ^0.4.26;\n\n\n\n\n\n\n\n\nlibrary CrossTypesV1 {\n    using SafeMath for uint;\n\n    /**\n     *\n     * STRUCTURES\n     *\n     */\n\n    struct Data {\n\n        /// map of the htlc transaction info\n        HTLCTxLib.Data htlcTxData;\n\n        /// map of the rapidity transaction info\n        RapidityTxLib.Data rapidityTxData;\n\n        /// quota data of storeman group\n        IQuota quota;\n\n        /// token manager instance interface\n        ITokenManager tokenManager;\n\n        /// storemanGroup admin instance interface\n        IStoremanGroup smgAdminProxy;\n\n        /// storemanGroup fee admin instance address\n        address smgFeeProxy;\n\n        ISignatureVerifier sigVerifier;\n\n        /// @notice transaction fee, smgID => fee\n        mapping(bytes32 => uint) mapStoremanFee;\n\n        /// @notice transaction fee, origChainID => shadowChainID => fee\n        mapping(uint => mapping(uint =>uint)) mapContractFee;\n\n        /// @notice transaction fee, origChainID => shadowChainID => fee\n        mapping(uint => mapping(uint =>uint)) mapAgentFee;\n\n    }\n\n    /**\n     *\n     * MANIPULATIONS\n     *\n     */\n\n    // /// @notice       convert bytes32 to address\n    // /// @param b      bytes32\n    // function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n    //     return address(uint160(bytes20(b))); // high\n    //     // return address(uint160(uint256(b))); // low\n    // }\n\n    /// @notice       convert bytes to address\n    /// @param b      bytes\n    function bytesToAddress(bytes b) internal pure returns (address addr) {\n        assembly {\n            addr := mload(add(b,20))\n        }\n    }\n\n    function transfer(address tokenScAddr, address to, uint value)\n        internal\n        returns(bool)\n    {\n        uint beforeBalance;\n        uint afterBalance;\n        beforeBalance = IRC20Protocol(tokenScAddr).balanceOf(to);\n        // IRC20Protocol(tokenScAddr).transfer(to, value);\n        tokenScAddr.call(bytes4(keccak256(\"transfer(address,uint256)\")), to, value);\n        afterBalance = IRC20Protocol(tokenScAddr).balanceOf(to);\n        return afterBalance == beforeBalance.add(value);\n    }\n\n    function transferFrom(address tokenScAddr, address from, address to, uint value)\n        internal\n        returns(bool)\n    {\n        uint beforeBalance;\n        uint afterBalance;\n        beforeBalance = IRC20Protocol(tokenScAddr).balanceOf(to);\n        // IRC20Protocol(tokenScAddr).transferFrom(from, to, value);\n        tokenScAddr.call(bytes4(keccak256(\"transferFrom(address,address,uint256)\")), from, to, value);\n        afterBalance = IRC20Protocol(tokenScAddr).balanceOf(to);\n        return afterBalance == beforeBalance.add(value);\n    }\n}\n\n// File: contracts/interfaces/ISmgFeeProxy.sol\n\n/*\n\n  Copyright 2019 Wanchain Foundation.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\n//                            _           _           _\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\n//\n//\n\npragma solidity 0.4.26;\n\ninterface ISmgFeeProxy {\n  function smgTransfer(bytes32 smgID) external payable;\n}\n\n// File: contracts/crossApproach/lib/RapidityLibV2.sol\n\n/*\n\n  Copyright 2019 Wanchain Foundation.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\n\n//                            _           _           _\n//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\n//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\n//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\n//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\n//\n//\npragma experimental ABIEncoderV2;\npragma solidity ^0.4.26;\n\n\n\n\n\n\n\nlibrary RapidityLibV2 {\n    using SafeMath for uint;\n    using RapidityTxLib for RapidityTxLib.Data;\n\n    /**\n    *\n    * STRUCTURES\n    *\n    */\n\n    /// @notice struct of Rapidity storeman mint lock parameters\n    struct CrossFeeParams {\n        uint contractFee;                 /// token pair id on cross chain\n        uint agentFee;                    /// exchange token value\n    }\n\n    /// @notice struct of Rapidity storeman mint lock parameters\n    struct RapidityUserLockParams {\n        bytes32 smgID;                    /// ID of storeman group which user has selected\n        uint tokenPairID;                 /// token pair id on cross chain\n        uint value;                       /// exchange token value\n        uint currentChainID;              /// current chain ID\n        bytes destUserAccount;            /// account of shadow chain, used to receive token\n    }\n\n    /// @notice struct of Rapidity storeman mint lock parameters\n    struct RapiditySmgMintParams {\n        bytes32 uniqueID;                 /// Rapidity random number\n        bytes32 smgID;                    /// ID of storeman group which user has selected\n        uint tokenPairID;                 /// token pair id on cross chain\n        uint value;                       /// exchange token value\n        address destTokenAccount;         /// shadow token account\n        address destUserAccount;          /// account of shadow chain, used to receive token\n    }\n\n    /// @notice struct of Rapidity user burn lock parameters\n    struct RapidityUserBurnParams {\n        bytes32 smgID;                  /// ID of storeman group which user has selected\n        uint tokenPairID;               /// token pair id on cross chain\n        uint value;                     /// exchange token value\n        uint currentChainID;            /// current chain ID\n        uint fee;                       /// exchange token fee\n        address srcTokenAccount;        /// shadow token account\n        bytes destUserAccount;          /// account of token destination chain, used to receive token\n    }\n\n    /// @notice struct of Rapidity user burn lock parameters\n    struct RapiditySmgReleaseParams {\n        bytes32 uniqueID;               /// Rapidity random number\n        bytes32 smgID;                  /// ID of storeman group which user has selected\n        uint tokenPairID;               /// token pair id on cross chain\n        uint value;                     /// exchange token value\n        address destTokenAccount;       /// original token/coin account\n        address destUserAccount;        /// account of token original chain, used to receive token\n    }\n\n    /**\n     *\n     * EVENTS\n     *\n     **/\n\n\n    /// @notice                         event of exchange WRC-20 token with original chain token request\n    /// @notice                         event invoked by storeman group\n    /// @param smgID                    ID of storemanGroup\n    /// @param tokenPairID              token pair ID of cross chain token\n    /// @param tokenAccount             Rapidity original token account\n    /// @param value                    Rapidity value\n    /// @param userAccount              account of shadow chain, used to receive token\n    event UserLockLogger(bytes32 indexed smgID, uint indexed tokenPairID, address indexed tokenAccount, uint value, uint contractFee, bytes userAccount);\n\n    /// @notice                         event of exchange WRC-20 token with original chain token request\n    /// @notice                         event invoked by storeman group\n    /// @param smgID                    ID of storemanGroup\n    /// @param tokenPairID              token pair ID of cross chain token\n    /// @param tokenAccount             Rapidity shadow token account\n    /// @param value                    Rapidity value\n    /// @param userAccount              account of shadow chain, used to receive token\n    event UserBurnLogger(bytes32 indexed smgID, uint indexed tokenPairID, address indexed tokenAccount, uint value, uint contractFee, uint fee, bytes userAccount);\n\n    /// @notice                         event of exchange WRC-20 token with original chain token request\n    /// @notice                         event invoked by storeman group\n    /// @param uniqueID                 unique random number\n    /// @param smgID                    ID of storemanGroup\n    /// @param tokenPairID              token pair ID of cross chain token\n    /// @param value                    Rapidity value\n    /// @param tokenAccount             Rapidity shadow token account\n    /// @param userAccount              account of original chain, used to receive token\n    event SmgMintLogger(bytes32 indexed uniqueID, bytes32 indexed smgID, uint indexed tokenPairID, uint value, address tokenAccount, address userAccount);\n\n    /// @notice                         event of exchange WRC-20 token with original chain token request\n    /// @notice                         event invoked by storeman group\n    /// @param uniqueID                 unique random number\n    /// @param smgID                    ID of storemanGroup\n    /// @param tokenPairID              token pair ID of cross chain token\n    /// @param value                    Rapidity value\n    /// @param tokenAccount             Rapidity original token account\n    /// @param userAccount              account of original chain, used to receive token\n    event SmgReleaseLogger(bytes32 indexed uniqueID, bytes32 indexed smgID, uint indexed tokenPairID, uint value, address tokenAccount, address userAccount);\n\n    /**\n    *\n    * MANIPULATIONS\n    *\n    */\n\n    /// @notice                         mintBridge, user lock token on token original chain\n    /// @notice                         event invoked by user mint lock\n    /// @param storageData              Cross storage data\n    /// @param params                   parameters for user mint lock token on token original chain\n    function userLock(CrossTypesV1.Data storage storageData, RapidityUserLockParams memory params)\n        public\n    {\n        uint fromChainID;\n        uint toChainID;\n        bytes memory fromTokenAccount;\n        (fromChainID,fromTokenAccount,toChainID) = storageData.tokenManager.getTokenPairInfoSlim(params.tokenPairID);\n        require(fromChainID != 0, \"Token does not exist\");\n\n        if (address(storageData.quota) != address(0)) {\n            storageData.quota.userLock(params.tokenPairID, params.smgID, params.value);\n        }\n\n        uint contractFee = storageData.mapContractFee[fromChainID][toChainID];\n        if (contractFee > 0) {\n            if (storageData.smgFeeProxy == address(0)) {\n                storageData.mapStoremanFee[bytes32(0)] = storageData.mapStoremanFee[bytes32(0)].add(contractFee);\n            } else {\n                (storageData.smgFeeProxy).transfer(contractFee);\n            }\n        }\n\n        address tokenScAddr = CrossTypesV1.bytesToAddress(fromTokenAccount);\n\n        uint left;\n        if (tokenScAddr == address(0)) {\n            left = (msg.value).sub(params.value).sub(contractFee);\n        } else {\n            left = (msg.value).sub(contractFee);\n\n            require(CrossTypesV1.transferFrom(tokenScAddr, msg.sender, this, params.value), \"Lock token failed\");\n        }\n        if (left != 0) {\n            (msg.sender).transfer(left);\n        }\n        emit UserLockLogger(params.smgID, params.tokenPairID, tokenScAddr, params.value, contractFee, params.destUserAccount);\n    }\n\n    /// @notice                         burnBridge, user lock token on token original chain\n    /// @notice                         event invoked by user burn lock\n    /// @param storageData              Cross storage data\n    /// @param params                   parameters for user burn lock token on token original chain\n    function userBurn(CrossTypesV1.Data storage storageData, RapidityUserBurnParams memory params)\n        public\n    {\n        ITokenManager tokenManager = storageData.tokenManager;\n        uint fromChainID;\n        uint toChainID;\n        bytes memory fromTokenAccount;\n        bytes memory toTokenAccount;\n        (fromChainID,fromTokenAccount,toChainID,toTokenAccount) = tokenManager.getTokenPairInfo(params.tokenPairID);\n        require(fromChainID != 0, \"Token does not exist\");\n\n        uint256 contractFee;\n        address tokenScAddr;\n        if (params.currentChainID == toChainID) {\n            contractFee = storageData.mapContractFee[toChainID][fromChainID];\n            tokenScAddr = CrossTypesV1.bytesToAddress(toTokenAccount);\n        } else if (params.currentChainID == fromChainID) {\n            contractFee = storageData.mapContractFee[fromChainID][toChainID];\n            tokenScAddr = CrossTypesV1.bytesToAddress(fromTokenAccount);\n        } else {\n            require(false, \"Invalid token pair\");\n        }\n        require(params.srcTokenAccount == tokenScAddr, \"invalid token account\");\n\n        if (address(storageData.quota) != address(0)) {\n            storageData.quota.userBurn(params.tokenPairID, params.smgID, params.value);\n        }\n\n        require(burnShadowToken(tokenManager, tokenScAddr, msg.sender, params.value), \"burn failed\");\n\n        if (contractFee > 0) {\n            if (storageData.smgFeeProxy == address(0)) {\n                storageData.mapStoremanFee[bytes32(0)] = storageData.mapStoremanFee[bytes32(0)].add(contractFee);\n            } else {\n                (storageData.smgFeeProxy).transfer(contractFee);\n            }\n        }\n\n        uint left = (msg.value).sub(contractFee);\n        // uint left = (msg.value).sub(contractFee);\n        if (left != 0) {\n            (msg.sender).transfer(left);\n        }\n\n        emit UserBurnLogger(params.smgID, params.tokenPairID, tokenScAddr, params.value, contractFee, params.fee, params.destUserAccount);\n    }\n\n    /// @notice                         mintBridge, storeman mint lock token on token shadow chain\n    /// @notice                         event invoked by user mint lock\n    /// @param storageData              Cross storage data\n    /// @param params                   parameters for storeman mint lock token on token shadow chain\n    function smgMint(CrossTypesV1.Data storage storageData, RapiditySmgMintParams memory params)\n        public\n    {\n        storageData.rapidityTxData.addRapidityTx(params.uniqueID);\n\n        if (address(storageData.quota) != address(0)) {\n            storageData.quota.smgMint(params.tokenPairID, params.smgID, params.value);\n        }\n\n        require(mintShadowToken(storageData.tokenManager, params.destTokenAccount, params.destUserAccount, params.value), \"mint failed\");\n\n        emit SmgMintLogger(params.uniqueID, params.smgID, params.tokenPairID, params.value, params.destTokenAccount, params.destUserAccount);\n    }\n\n    /// @notice                         burnBridge, storeman burn lock token on token shadow chain\n    /// @notice                         event invoked by user burn lock\n    /// @param storageData              Cross storage data\n    /// @param params                   parameters for storeman burn lock token on token shadow chain\n    function smgRelease(CrossTypesV1.Data storage storageData, RapiditySmgReleaseParams memory params)\n        public\n    {\n        storageData.rapidityTxData.addRapidityTx(params.uniqueID);\n\n        if (address(storageData.quota) != address(0)) {\n            storageData.quota.smgRelease(params.tokenPairID, params.smgID, params.value);\n        }\n\n        if (params.destTokenAccount == address(0)) {\n            (params.destUserAccount).transfer(params.value);\n        } else {\n            require(CrossTypesV1.transfer(params.destTokenAccount, params.destUserAccount, params.value), \"Transfer token failed\");\n        }\n\n        emit SmgReleaseLogger(params.uniqueID, params.smgID, params.tokenPairID, params.value, params.destTokenAccount, params.destUserAccount);\n    }\n\n    function burnShadowToken(address tokenManager, address tokenAddress, address userAccount, uint value) private returns (bool) {\n        uint beforeBalance;\n        uint afterBalance;\n        beforeBalance = IRC20Protocol(tokenAddress).balanceOf(userAccount);\n\n        ITokenManager(tokenManager).burnToken(tokenAddress, userAccount, value);\n\n        afterBalance = IRC20Protocol(tokenAddress).balanceOf(userAccount);\n        return afterBalance == beforeBalance.sub(value);\n    }\n\n    function mintShadowToken(address tokenManager, address tokenAddress, address userAccount, uint value) private returns (bool) {\n        uint beforeBalance;\n        uint afterBalance;\n        beforeBalance = IRC20Protocol(tokenAddress).balanceOf(userAccount);\n\n        ITokenManager(tokenManager).mintToken(tokenAddress, userAccount, value);\n\n        afterBalance = IRC20Protocol(tokenAddress).balanceOf(userAccount);\n        return afterBalance == beforeBalance.add(value);\n    }\n\n}\n\n","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"storageData\",\"type\":\"CrossTypesV1.Data storage\"},{\"components\":[{\"name\":\"uniqueID\",\"type\":\"bytes32\"},{\"name\":\"smgID\",\"type\":\"bytes32\"},{\"name\":\"tokenPairID\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"destTokenAccount\",\"type\":\"address\"},{\"name\":\"destUserAccount\",\"type\":\"address\"}],\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"smgRelease\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"storageData\",\"type\":\"CrossTypesV1.Data storage\"},{\"components\":[{\"name\":\"smgID\",\"type\":\"bytes32\"},{\"name\":\"tokenPairID\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"currentChainID\",\"type\":\"uint256\"},{\"name\":\"destUserAccount\",\"type\":\"bytes\"}],\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"userLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"storageData\",\"type\":\"CrossTypesV1.Data storage\"},{\"components\":[{\"name\":\"smgID\",\"type\":\"bytes32\"},{\"name\":\"tokenPairID\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"currentChainID\",\"type\":\"uint256\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"srcTokenAccount\",\"type\":\"address\"},{\"name\":\"destUserAccount\",\"type\":\"bytes\"}],\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"userBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"storageData\",\"type\":\"CrossTypesV1.Data storage\"},{\"components\":[{\"name\":\"uniqueID\",\"type\":\"bytes32\"},{\"name\":\"smgID\",\"type\":\"bytes32\"},{\"name\":\"tokenPairID\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"destTokenAccount\",\"type\":\"address\"},{\"name\":\"destUserAccount\",\"type\":\"address\"}],\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"smgMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"smgID\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"tokenPairID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokenAccount\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contractFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"userAccount\",\"type\":\"bytes\"}],\"name\":\"UserLockLogger\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"smgID\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"tokenPairID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokenAccount\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contractFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"userAccount\",\"type\":\"bytes\"}],\"name\":\"UserBurnLogger\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"uniqueID\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"smgID\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"tokenPairID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAccount\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"userAccount\",\"type\":\"address\"}],\"name\":\"SmgMintLogger\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"uniqueID\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"smgID\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"tokenPairID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAccount\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"userAccount\",\"type\":\"address\"}],\"name\":\"SmgReleaseLogger\",\"type\":\"event\"}]","ContractName":"RapidityLibV2","CompilerVersion":"v0.4.26+commit.4563c3fc","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"byzantium","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":""}]}