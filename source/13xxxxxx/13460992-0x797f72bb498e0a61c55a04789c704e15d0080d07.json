{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/balances.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\ncontract Balances {\\n    \\n    struct Balance {\\n        address user;\\n        address token;\\n        uint256 amount;\\n    }\\n    \\n    /* public functions */\\n    \\n    /* Check the ERC20 token balances of a wallet for multiple tokens and addresses.\\n     Returns array of token balances in wei units. */\\n    function tokenBalances(address[] calldata users,  address[] calldata tokens) external view returns (Balance[] memory balances) {\\n        balances = new Balance[](users.length * tokens.length);\\n        \\n        uint idx = 0;\\n        \\n        for(uint i = 0; i < tokens.length; i++) {\\n            \\n            for (uint j = 0; j < users.length; j++) {\\n                \\n                balances[idx].user = users[j];\\n                balances[idx].token = tokens[i];\\n                \\n                if(tokens[i] != address(0x0)) { \\n                    balances[idx].amount = tokenBalance(users[j], tokens[i]); // check token balance and catch errors\\n                } else {\\n                    balances[idx].amount = users[j].balance; // ETH balance    \\n                }\\n                idx++;\\n            }\\n        }    \\n        return balances;\\n    }\\n    \\n    \\n    /* Private functions */\\n    \\n    \\n    /* Check the token balance of a wallet in a token contract.\\n    Returns 0 on a bad token contract   */\\n    function tokenBalance(address user, address token) internal view returns (uint) {\\n        // token.balanceOf(user), selector 0x70a08231\\n        return getNumberOneArg(token, 0x70a08231, user);\\n    }\\n    \\n    \\n    /* Generic private functions */\\n    \\n    // Get a token or exchange value that requires 1 address argument (most likely arg1 == user).\\n    // selector is the hashed function signature (see top comments)\\n    function getNumberOneArg(address contractAddr, bytes4 selector, address arg1) internal view returns (uint) {\\n        if(isAContract(contractAddr)) {\\n            (bool success, bytes memory result) = contractAddr.staticcall(abi.encodeWithSelector(selector, arg1));\\n            // if the contract call succeeded & the result looks good to parse\\n            if(success && result.length == 32) {\\n                return abi.decode(result, (uint)); // return the result as uint\\n            } else {\\n                return 0; // function call failed, return 0\\n            }\\n        } else {\\n            return 0; // not a valid contract, return 0 instead of error\\n        }\\n    }\\n    \\n    // check if contract (token, exchange) is actually a smart contract and not a 'regular' address\\n    function isAContract(address contractAddr) internal view returns (bool) {\\n        uint256 codeSize;\\n        assembly { codeSize := extcodesize(contractAddr) } // contract code size\\n        return codeSize > 0; \\n        // Might not be 100% foolproof, but reliable enough for an early return in 'view' functions \\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"tokenBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Balances.Balance[]\",\"name\":\"balances\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Balances","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}