{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/utils/ProtocolUpgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"../Interfaces.sol\\\";\\nimport \\\"../DAOStackInterfaces.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\n\\ninterface OldMarketMaker {\\n\\tstruct ReserveToken {\\n\\t\\t// Determines the reserve token balance\\n\\t\\t// that the reserve contract holds\\n\\t\\tuint256 reserveSupply;\\n\\t\\t// Determines the current ratio between\\n\\t\\t// the reserve token and the GD token\\n\\t\\tuint32 reserveRatio;\\n\\t\\t// How many GD tokens have been minted\\n\\t\\t// against that reserve token\\n\\t\\tuint256 gdSupply;\\n\\t}\\n\\n\\tfunction reserveTokens(address token)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (ReserveToken memory);\\n}\\n\\n/**\\n a scheme that once approved in old AbsoluteVotingMachine is in charge of upgrading to new contracts\\n */\\ncontract ProtocolUpgrade {\\n\\tController controller;\\n\\taddress owner;\\n\\taddress avatar;\\n\\n\\tmodifier onlyOwner() {\\n\\t\\trequire(msg.sender == owner, \\\"only owner\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tconstructor(Controller _controller, address _owner) {\\n\\t\\tcontroller = _controller;\\n\\t\\towner = _owner;\\n\\t\\tavatar = address(controller.avatar());\\n\\t}\\n\\n\\t/**\\n\\t1. set the DAO contracts in registery after they have been deployedDAO\\n\\t2. set the initial staking contracts and their rewards\\n\\t */\\n\\tfunction upgradeBasic(\\n\\t\\tINameService ns,\\n\\t\\tbytes32[] calldata nameHash,\\n\\t\\taddress[] calldata nameAddress,\\n\\t\\taddress[] calldata staking,\\n\\t\\tuint256[] calldata monthlyRewards\\n\\t) external onlyOwner {\\n\\t\\trequire(nameHash.length == nameAddress.length, \\\"length mismatch\\\");\\n\\t\\trequire(staking.length == monthlyRewards.length, \\\"staking length mismatch\\\");\\n\\n\\t\\t_setNameServiceContracts(ns, nameHash, nameAddress);\\n\\n\\t\\t_setStakingRewards(ns, staking, monthlyRewards);\\n\\n\\t\\t//identity has no need for special permissions, just needs to be registered\\n\\t\\trequire(\\n\\t\\t\\tcontroller.registerScheme(\\n\\t\\t\\t\\tns.getAddress(\\\"IDENTITY\\\"),\\n\\t\\t\\t\\tbytes32(0x0),\\n\\t\\t\\t\\tbytes4(0x00000001),\\n\\t\\t\\t\\tavatar\\n\\t\\t\\t),\\n\\t\\t\\t\\\"registering Identity failed\\\"\\n\\t\\t);\\n\\n\\t\\t//formula has no need to be a registered scheme\\n\\t\\taddress formula = IGoodDollar(ns.getAddress(\\\"GOODDOLLAR\\\")).formula();\\n\\t\\tif (controller.isSchemeRegistered(formula, avatar))\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tcontroller.unregisterScheme(\\n\\t\\t\\t\\t\\tIGoodDollar(ns.getAddress(\\\"GOODDOLLAR\\\")).formula(),\\n\\t\\t\\t\\t\\tavatar\\n\\t\\t\\t\\t),\\n\\t\\t\\t\\t\\\"unregistering formula failed\\\"\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t3. set new reserve as sole minter\\n\\t4. upgrade to new reserve\\n\\t */\\n\\tfunction upgradeReserve(\\n\\t\\tINameService ns,\\n\\t\\taddress oldReserve,\\n\\t\\taddress oldMarketMaker,\\n\\t\\taddress oldFundManager,\\n\\t\\taddress COMP\\n\\t) external onlyOwner {\\n\\t\\t_setReserveSoleMinter(ns);\\n\\n\\t\\tif (oldReserve != address(0)) {\\n\\t\\t\\t_setNewReserve(ns, oldReserve, oldMarketMaker, COMP);\\n\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tcontroller.unregisterScheme(oldFundManager, avatar),\\n\\t\\t\\t\\t\\\"unregistering old FundManager failed\\\"\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t5. upgrade donation staking contract\\n\\t */\\n\\tfunction upgradeDonationStaking(\\n\\t\\tINameService ns,\\n\\t\\taddress oldDonationStaking,\\n\\t\\taddress payable donationStaking,\\n\\t\\taddress oldSimpleDAIStaking\\n\\t) public onlyOwner {\\n\\t\\tbool ok;\\n\\t\\tbytes memory result;\\n\\n\\t\\t(ok, result) = controller.genericCall(\\n\\t\\t\\toldDonationStaking,\\n\\t\\t\\tabi.encodeWithSignature(\\\"end()\\\"),\\n\\t\\t\\tavatar,\\n\\t\\t\\t0\\n\\t\\t);\\n\\n\\t\\trequire(ok, \\\"Calling oldDonationStaking end failed\\\");\\n\\t\\t(uint256 dai, uint256 eth) = abi.decode(result, (uint256, uint256));\\n\\t\\tok = controller.externalTokenTransfer(\\n\\t\\t\\tns.getAddress(\\\"DAI\\\"),\\n\\t\\t\\tdonationStaking,\\n\\t\\t\\tdai,\\n\\t\\t\\tavatar\\n\\t\\t);\\n\\n\\t\\trequire(ok, \\\"Calling DAI externalTokenTransfer failed\\\");\\n\\t\\tif (eth > 0) {\\n\\t\\t\\tok = controller.sendEther(eth, payable(this), avatar);\\n\\n\\t\\t\\trequire(ok, \\\"Calling  sendEther failed\\\");\\n\\n\\t\\t\\tAddressUpgradeable.sendValue(donationStaking, eth);\\n\\t\\t}\\n\\t\\tIDonationStaking(donationStaking).stakeDonations();\\n\\n\\t\\t(ok, result) = controller.genericCall(\\n\\t\\t\\toldSimpleDAIStaking,\\n\\t\\t\\tabi.encodeWithSignature(\\\"end()\\\"),\\n\\t\\t\\tavatar,\\n\\t\\t\\t0\\n\\t\\t);\\n\\n\\t\\trequire(ok, \\\"Calling old SimpleDAIStaking end failed\\\");\\n\\n\\t\\trequire(\\n\\t\\t\\tcontroller.unregisterScheme(oldSimpleDAIStaking, avatar),\\n\\t\\t\\t\\\"unregistering old SimpleDAIStaking failed\\\"\\n\\t\\t);\\n\\t}\\n\\n\\treceive() external payable {}\\n\\n\\t/**\\n\\t * 6. upgrade to new DAO and relinquish control\\n\\t * unregister old voting schemes\\n\\t * register new voting scheme with all DAO permissions\\n\\t * NOTICE: call this last to finalize DAO decentralization!!!\\n\\t */\\n\\tfunction upgradeGovernance(\\n\\t\\taddress schemeRegistrar,\\n\\t\\taddress upgradeScheme,\\n\\t\\taddress compoundVotingMachine\\n\\t) public onlyOwner {\\n\\t\\tif (schemeRegistrar != address(0))\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tcontroller.unregisterScheme(schemeRegistrar, avatar),\\n\\t\\t\\t\\t\\\"unregistering schemeRegistrar failed\\\"\\n\\t\\t\\t);\\n\\n\\t\\tif (upgradeScheme != address(0))\\n\\t\\t\\trequire(\\n\\t\\t\\t\\tcontroller.unregisterScheme(upgradeScheme, avatar),\\n\\t\\t\\t\\t\\\"unregistering upgradeScheme failed\\\"\\n\\t\\t\\t);\\n\\n\\t\\trequire(\\n\\t\\t\\tcontroller.registerScheme(\\n\\t\\t\\t\\tcompoundVotingMachine,\\n\\t\\t\\t\\tbytes32(0x0),\\n\\t\\t\\t\\tbytes4(0x0000001F),\\n\\t\\t\\t\\tavatar\\n\\t\\t\\t),\\n\\t\\t\\t\\\"registering compoundVotingMachine failed\\\"\\n\\t\\t);\\n\\n\\t\\trequire(\\n\\t\\t\\tcontroller.registerScheme(\\n\\t\\t\\t\\towner,\\n\\t\\t\\t\\tbytes32(0x0),\\n\\t\\t\\t\\tbytes4(0x0000001F),\\n\\t\\t\\t\\tavatar\\n\\t\\t\\t),\\n\\t\\t\\t\\\"registering governance failsafe failed\\\"\\n\\t\\t);\\n\\n\\t\\trequire(\\n\\t\\t\\tcontroller.unregisterSelf(avatar),\\n\\t\\t\\t\\\"unregistering protocolupgrade failed\\\"\\n\\t\\t);\\n\\t\\tselfdestruct(payable(owner));\\n\\t}\\n\\n\\t//add new reserve as minter\\n\\t//renounace minter from avatar\\n\\t//add reserve as global constraint on controller\\n\\tfunction _setReserveSoleMinter(INameService ns) internal {\\n\\t\\tbool ok;\\n\\t\\t(ok, ) = controller.genericCall(\\n\\t\\t\\tns.getAddress(\\\"GOODDOLLAR\\\"),\\n\\t\\t\\tabi.encodeWithSignature(\\\"addMinter(address)\\\", ns.getAddress(\\\"RESERVE\\\")),\\n\\t\\t\\tavatar,\\n\\t\\t\\t0\\n\\t\\t);\\n\\t\\trequire(ok, \\\"Calling addMinter failed\\\");\\n\\n\\t\\t(ok, ) = controller.genericCall(\\n\\t\\t\\taddress(ns.getAddress(\\\"GOODDOLLAR\\\")),\\n\\t\\t\\tabi.encodeWithSignature(\\\"renounceMinter()\\\"),\\n\\t\\t\\tavatar,\\n\\t\\t\\t0\\n\\t\\t);\\n\\t\\trequire(ok, \\\"Calling renounceMinter failed\\\");\\n\\n\\t\\tok = controller.addGlobalConstraint(\\n\\t\\t\\tns.getAddress(\\\"RESERVE\\\"),\\n\\t\\t\\tbytes32(0x0),\\n\\t\\t\\tavatar\\n\\t\\t);\\n\\n\\t\\trequire(ok, \\\"Calling addGlobalConstraint failed\\\");\\n\\t}\\n\\n\\t//transfer funds(cdai + comp) from old reserve to new reserve/avatar\\n\\t//end old reserve\\n\\t//initialize new marketmaker with current cdai price, rr, reserves\\n\\tfunction _setNewReserve(\\n\\t\\tINameService ns,\\n\\t\\taddress oldReserve,\\n\\t\\taddress oldMarketMaker,\\n\\t\\taddress COMP\\n\\t) internal {\\n\\t\\tbool ok;\\n\\t\\tif (COMP != address(0x0)) {\\n\\t\\t\\t(ok, ) = controller.genericCall(\\n\\t\\t\\t\\toldReserve,\\n\\t\\t\\t\\tabi.encodeWithSignature(\\\"recover(address)\\\", COMP),\\n\\t\\t\\t\\tavatar,\\n\\t\\t\\t\\t0\\n\\t\\t\\t);\\n\\n\\t\\t\\trequire(ok, \\\"calling Reserve comp recover failed\\\");\\n\\t\\t}\\n\\n\\t\\taddress cdai = ns.getAddress(\\\"CDAI\\\");\\n\\t\\tuint256 oldReserveCdaiBalance = ERC20(cdai).balanceOf(oldReserve);\\n\\t\\t(ok, ) = controller.genericCall(\\n\\t\\t\\toldReserve,\\n\\t\\t\\tabi.encodeWithSignature(\\\"end()\\\"),\\n\\t\\t\\tavatar,\\n\\t\\t\\t0\\n\\t\\t);\\n\\n\\t\\trequire(ok, \\\"calling Reserve end failed\\\");\\n\\n\\t\\tOldMarketMaker.ReserveToken memory rToken = OldMarketMaker(oldMarketMaker)\\n\\t\\t\\t.reserveTokens(cdai);\\n\\t\\tok = controller.externalTokenTransfer(\\n\\t\\t\\tcdai,\\n\\t\\t\\tns.getAddress(\\\"RESERVE\\\"),\\n\\t\\t\\toldReserveCdaiBalance,\\n\\t\\t\\tavatar\\n\\t\\t);\\n\\n\\t\\trequire(ok, \\\"transfer cdai to new reserve failed\\\");\\n\\n\\t\\t(ok, ) = controller.genericCall(\\n\\t\\t\\tns.getAddress(\\\"MARKET_MAKER\\\"),\\n\\t\\t\\tabi.encodeWithSignature(\\n\\t\\t\\t\\t\\\"initializeToken(address,uint256,uint256,uint32)\\\",\\n\\t\\t\\t\\tcdai,\\n\\t\\t\\t\\trToken.gdSupply,\\n\\t\\t\\t\\trToken.reserveSupply,\\n\\t\\t\\t\\trToken.reserveRatio\\n\\t\\t\\t),\\n\\t\\t\\tavatar,\\n\\t\\t\\t0\\n\\t\\t);\\n\\n\\t\\trequire(ok, \\\"calling marketMaker initializeToken failed\\\");\\n\\n\\t\\trequire(\\n\\t\\t\\tcontroller.unregisterScheme(oldReserve, avatar),\\n\\t\\t\\t\\\"unregistering old reserve failed\\\"\\n\\t\\t);\\n\\t}\\n\\n\\t//set contracts in nameservice that are deployed after INameService is created\\n\\t//\\tFUND_MANAGER RESERVE REPUTATION GDAO_STAKING  GDAO_CLAIMERS ...\\n\\tfunction _setNameServiceContracts(\\n\\t\\tINameService ns,\\n\\t\\tbytes32[] memory names,\\n\\t\\taddress[] memory addresses\\n\\t) internal {\\n\\t\\t(bool ok, ) = controller.genericCall(\\n\\t\\t\\taddress(ns),\\n\\t\\t\\tabi.encodeWithSignature(\\n\\t\\t\\t\\t\\\"setAddresses(bytes32[],address[])\\\",\\n\\t\\t\\t\\tnames,\\n\\t\\t\\t\\taddresses\\n\\t\\t\\t),\\n\\t\\t\\tavatar,\\n\\t\\t\\t0\\n\\t\\t);\\n\\t\\trequire(ok, \\\"Calling setNameServiceContracts failed\\\");\\n\\t}\\n\\n\\t//initialize rewards for v2 starting staking contracts\\n\\tfunction _setStakingRewards(\\n\\t\\tINameService ns,\\n\\t\\taddress[] memory contracts,\\n\\t\\tuint256[] memory rewards\\n\\t) internal {\\n\\t\\tfor (uint256 i = 0; i < contracts.length; i++) {\\n\\t\\t\\t(bool ok, ) = controller.genericCall(\\n\\t\\t\\t\\tns.getAddress(\\\"FUND_MANAGER\\\"),\\n\\t\\t\\t\\tabi.encodeWithSignature(\\n\\t\\t\\t\\t\\t\\\"setStakingReward(uint32,address,uint32,uint32,bool)\\\",\\n\\t\\t\\t\\t\\trewards[i],\\n\\t\\t\\t\\t\\tcontracts[i],\\n\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\t0,\\n\\t\\t\\t\\t\\tfalse\\n\\t\\t\\t\\t),\\n\\t\\t\\t\\tavatar,\\n\\t\\t\\t\\t0\\n\\t\\t\\t);\\n\\t\\t\\trequire(ok, \\\"Calling setStakingRewards failed\\\");\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\nimport { DataTypes } from \\\"./utils/DataTypes.sol\\\";\\npragma solidity >=0.8.0;\\n\\npragma experimental ABIEncoderV2;\\n\\ninterface ERC20 {\\n\\tfunction balanceOf(address addr) external view returns (uint256);\\n\\n\\tfunction transfer(address to, uint256 amount) external returns (bool);\\n\\n\\tfunction approve(address spender, uint256 amount) external returns (bool);\\n\\n\\tfunction decimals() external view returns (uint8);\\n\\n\\tfunction mint(address to, uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\tfunction allowance(address owner, address spender)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\tfunction transferFrom(\\n\\t\\taddress sender,\\n\\t\\taddress recipient,\\n\\t\\tuint256 amount\\n\\t) external returns (bool);\\n\\n\\tfunction name() external view returns (string memory);\\n\\n\\tfunction symbol() external view returns (string memory);\\n\\n\\tevent Transfer(address indexed from, address indexed to, uint256 amount);\\n\\tevent Transfer(\\n\\t\\taddress indexed from,\\n\\t\\taddress indexed to,\\n\\t\\tuint256 amount,\\n\\t\\tbytes data\\n\\t);\\n}\\n\\ninterface cERC20 is ERC20 {\\n\\tfunction mint(uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction redeemUnderlying(uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction redeem(uint256 mintAmount) external returns (uint256);\\n\\n\\tfunction exchangeRateCurrent() external returns (uint256);\\n\\n\\tfunction exchangeRateStored() external view returns (uint256);\\n\\n\\tfunction underlying() external returns (address);\\n}\\n\\ninterface IGoodDollar is ERC20 {\\n\\tfunction getFees(uint256 value) external view returns (uint256, bool);\\n\\n\\tfunction burn(uint256 amount) external;\\n\\n\\tfunction burnFrom(address account, uint256 amount) external;\\n\\n\\tfunction renounceMinter() external;\\n\\n\\tfunction addMinter(address minter) external;\\n\\n\\tfunction isMinter(address minter) external view returns (bool);\\n\\n\\tfunction transferAndCall(\\n\\t\\taddress to,\\n\\t\\tuint256 value,\\n\\t\\tbytes calldata data\\n\\t) external returns (bool);\\n\\n\\tfunction formula() external view returns (address);\\n}\\n\\ninterface IERC2917 is ERC20 {\\n\\t/// @dev This emit when interests amount per block is changed by the owner of the contract.\\n\\t/// It emits with the old interests amount and the new interests amount.\\n\\tevent InterestRatePerBlockChanged(uint256 oldValue, uint256 newValue);\\n\\n\\t/// @dev This emit when a users' productivity has changed\\n\\t/// It emits with the user's address and the the value after the change.\\n\\tevent ProductivityIncreased(address indexed user, uint256 value);\\n\\n\\t/// @dev This emit when a users' productivity has changed\\n\\t/// It emits with the user's address and the the value after the change.\\n\\tevent ProductivityDecreased(address indexed user, uint256 value);\\n\\n\\t/// @dev Return the current contract's interests rate per block.\\n\\t/// @return The amount of interests currently producing per each block.\\n\\tfunction interestsPerBlock() external view returns (uint256);\\n\\n\\t/// @notice Change the current contract's interests rate.\\n\\t/// @dev Note the best practice will be restrict the gross product provider's contract address to call this.\\n\\t/// @return The true/fase to notice that the value has successfully changed or not, when it succeed, it will emite the InterestRatePerBlockChanged event.\\n\\tfunction changeInterestRatePerBlock(uint256 value) external returns (bool);\\n\\n\\t/// @notice It will get the productivity of given user.\\n\\t/// @dev it will return 0 if user has no productivity proved in the contract.\\n\\t/// @return user's productivity and overall productivity.\\n\\tfunction getProductivity(address user)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256, uint256);\\n\\n\\t/// @notice increase a user's productivity.\\n\\t/// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\\n\\t/// @return true to confirm that the productivity added success.\\n\\tfunction increaseProductivity(address user, uint256 value)\\n\\t\\texternal\\n\\t\\treturns (bool);\\n\\n\\t/// @notice decrease a user's productivity.\\n\\t/// @dev Note the best practice will be restrict the callee to prove of productivity's contract address.\\n\\t/// @return true to confirm that the productivity removed success.\\n\\tfunction decreaseProductivity(address user, uint256 value)\\n\\t\\texternal\\n\\t\\treturns (bool);\\n\\n\\t/// @notice take() will return the interests that callee will get at current block height.\\n\\t/// @dev it will always calculated by block.number, so it will change when block height changes.\\n\\t/// @return amount of the interests that user are able to mint() at current block height.\\n\\tfunction take() external view returns (uint256);\\n\\n\\t/// @notice similar to take(), but with the block height joined to calculate return.\\n\\t/// @dev for instance, it returns (_amount, _block), which means at block height _block, the callee has accumulated _amount of interests.\\n\\t/// @return amount of interests and the block height.\\n\\tfunction takeWithBlock() external view returns (uint256, uint256);\\n\\n\\t/// @notice mint the avaiable interests to callee.\\n\\t/// @dev once it mint, the amount of interests will transfer to callee's address.\\n\\t/// @return the amount of interests minted.\\n\\tfunction mint() external returns (uint256);\\n}\\n\\ninterface Staking {\\n\\tstruct Staker {\\n\\t\\t// The staked DAI amount\\n\\t\\tuint256 stakedDAI;\\n\\t\\t// The latest block number which the\\n\\t\\t// staker has staked tokens\\n\\t\\tuint256 lastStake;\\n\\t}\\n\\n\\tfunction stakeDAI(uint256 amount) external;\\n\\n\\tfunction withdrawStake() external;\\n\\n\\tfunction stakers(address staker) external view returns (Staker memory);\\n}\\n\\ninterface Uniswap {\\n\\tfunction swapExactETHForTokens(\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external payable returns (uint256[] memory amounts);\\n\\n\\tfunction swapExactTokensForETH(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256[] memory amounts);\\n\\n\\tfunction swapExactTokensForTokens(\\n\\t\\tuint256 amountIn,\\n\\t\\tuint256 amountOutMin,\\n\\t\\taddress[] calldata path,\\n\\t\\taddress to,\\n\\t\\tuint256 deadline\\n\\t) external returns (uint256[] memory amounts);\\n\\n\\tfunction WETH() external pure returns (address);\\n\\n\\tfunction factory() external pure returns (address);\\n\\n\\tfunction quote(\\n\\t\\tuint256 amountA,\\n\\t\\tuint256 reserveA,\\n\\t\\tuint256 reserveB\\n\\t) external pure returns (uint256 amountB);\\n\\n\\tfunction getAmountIn(\\n\\t\\tuint256 amountOut,\\n\\t\\tuint256 reserveIn,\\n\\t\\tuint256 reserveOut\\n\\t) external pure returns (uint256 amountIn);\\n\\n\\tfunction getAmountOut(\\n\\t\\tuint256 amountI,\\n\\t\\tuint256 reserveIn,\\n\\t\\tuint256 reserveOut\\n\\t) external pure returns (uint256 amountOut);\\n\\n\\tfunction getAmountsOut(uint256 amountIn, address[] memory path)\\n\\t\\texternal\\n\\t\\tpure\\n\\t\\treturns (uint256[] memory amounts);\\n}\\n\\ninterface UniswapFactory {\\n\\tfunction getPair(address tokenA, address tokenB)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (address);\\n}\\n\\ninterface UniswapPair {\\n\\tfunction getReserves()\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint112 reserve0,\\n\\t\\t\\tuint112 reserve1,\\n\\t\\t\\tuint32 blockTimestampLast\\n\\t\\t);\\n\\n\\tfunction kLast() external view returns (uint256);\\n\\n\\tfunction token0() external view returns (address);\\n\\n\\tfunction token1() external view returns (address);\\n\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\tfunction balanceOf(address owner) external view returns (uint256);\\n}\\n\\ninterface Reserve {\\n\\tfunction buy(\\n\\t\\taddress _buyWith,\\n\\t\\tuint256 _tokenAmount,\\n\\t\\tuint256 _minReturn\\n\\t) external returns (uint256);\\n}\\n\\ninterface IIdentity {\\n\\tfunction isWhitelisted(address user) external view returns (bool);\\n\\n\\tfunction addWhitelistedWithDID(address account, string memory did) external;\\n\\n\\tfunction removeWhitelisted(address account) external;\\n\\n\\tfunction addIdentityAdmin(address account) external returns (bool);\\n\\n\\tfunction setAvatar(address _avatar) external;\\n\\n\\tfunction isIdentityAdmin(address account) external view returns (bool);\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\tevent WhitelistedAdded(address user);\\n}\\n\\ninterface IUBIScheme {\\n\\tfunction currentDay() external view returns (uint256);\\n\\n\\tfunction periodStart() external view returns (uint256);\\n\\n\\tfunction hasClaimed(address claimer) external view returns (bool);\\n}\\n\\ninterface IFirstClaimPool {\\n\\tfunction awardUser(address user) external returns (uint256);\\n\\n\\tfunction claimAmount() external view returns (uint256);\\n}\\n\\ninterface ProxyAdmin {\\n\\tfunction getProxyImplementation(address proxy)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (address);\\n\\n\\tfunction getProxyAdmin(address proxy) external view returns (address);\\n\\n\\tfunction upgrade(address proxy, address implementation) external;\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\tfunction transferOwnership(address newOwner) external;\\n}\\n\\n/**\\n * @dev Interface for chainlink oracles to obtain price datas\\n */\\ninterface AggregatorV3Interface {\\n\\tfunction decimals() external view returns (uint8);\\n\\n\\tfunction description() external view returns (string memory);\\n\\n\\tfunction version() external view returns (uint256);\\n\\n\\t// getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n\\t// if they do not have data to report, instead of returning unset values\\n\\t// which could be misinterpreted as actual reported values.\\n\\tfunction getRoundData(uint80 _roundId)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint80 roundId,\\n\\t\\t\\tint256 answer,\\n\\t\\t\\tuint256 startedAt,\\n\\t\\t\\tuint256 updatedAt,\\n\\t\\t\\tuint80 answeredInRound\\n\\t\\t);\\n\\n\\tfunction latestAnswer() external view returns (int256);\\n}\\n\\n/**\\n\\t@dev interface for AAVE lending Pool\\n */\\ninterface ILendingPool {\\n\\t/**\\n\\t * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n\\t * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n\\t * @param asset The address of the underlying asset to deposit\\n\\t * @param amount The amount to be deposited\\n\\t * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n\\t *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n\\t *   is a different wallet\\n\\t * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n\\t *   0 if the action is executed directly by the user, without any middle-man\\n\\t **/\\n\\tfunction deposit(\\n\\t\\taddress asset,\\n\\t\\tuint256 amount,\\n\\t\\taddress onBehalfOf,\\n\\t\\tuint16 referralCode\\n\\t) external;\\n\\n\\t/**\\n\\t * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n\\t * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n\\t * @param asset The address of the underlying asset to withdraw\\n\\t * @param amount The underlying amount to be withdrawn\\n\\t *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n\\t * @param to Address that will receive the underlying, same as msg.sender if the user\\n\\t *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n\\t *   different wallet\\n\\t * @return The final amount withdrawn\\n\\t **/\\n\\tfunction withdraw(\\n\\t\\taddress asset,\\n\\t\\tuint256 amount,\\n\\t\\taddress to\\n\\t) external returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the state and configuration of the reserve\\n\\t * @param asset The address of the underlying asset of the reserve\\n\\t * @return The state of the reserve\\n\\t **/\\n\\tfunction getReserveData(address asset)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (DataTypes.ReserveData memory);\\n}\\n\\ninterface IDonationStaking {\\n\\tfunction stakeDonations() external payable;\\n}\\n\\ninterface INameService {\\n\\tfunction getAddress(string memory _name) external view returns (address);\\n}\\n\\ninterface IAaveIncentivesController {\\n\\t/**\\n\\t * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\\n\\t * @param amount Amount of rewards to claim\\n\\t * @param to Address that will be receiving the rewards\\n\\t * @return Rewards claimed\\n\\t **/\\n\\tfunction claimRewards(\\n\\t\\taddress[] calldata assets,\\n\\t\\tuint256 amount,\\n\\t\\taddress to\\n\\t) external returns (uint256);\\n\\n\\t/**\\n\\t * @dev Returns the total of rewards of an user, already accrued + not yet accrued\\n\\t * @param user The address of the user\\n\\t * @return The rewards\\n\\t **/\\n\\tfunction getRewardsBalance(address[] calldata assets, address user)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n}\\n\\ninterface IGoodStaking {\\n\\tfunction collectUBIInterest(address recipient)\\n\\t\\texternal\\n\\t\\treturns (\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256\\n\\t\\t);\\n\\n\\tfunction iToken() external view returns (address);\\n\\n\\tfunction currentGains(\\n\\t\\tbool _returnTokenBalanceInUSD,\\n\\t\\tbool _returnTokenGainsInUSD\\n\\t)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256,\\n\\t\\t\\tuint256\\n\\t\\t);\\n\\n\\tfunction getRewardEarned(address user) external view returns (uint256);\\n\\n\\tfunction getGasCostForInterestTransfer() external view returns (uint256);\\n\\n\\tfunction rewardsMinted(\\n\\t\\taddress user,\\n\\t\\tuint256 rewardsPerBlock,\\n\\t\\tuint256 blockStart,\\n\\t\\tuint256 blockEnd\\n\\t) external returns (uint256);\\n}\\n\\ninterface IHasRouter {\\n\\tfunction getRouter() external view returns (Uniswap);\\n}\\n\\ninterface IAdminWallet {\\n\\tfunction addAdmins(address payable[] memory _admins) external;\\n\\n\\tfunction removeAdmins(address[] memory _admins) external;\\n\\n\\tfunction owner() external view returns (address);\\n\\n\\tfunction transferOwnership(address _owner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/DAOStackInterfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface Avatar {\\n\\tfunction nativeToken() external view returns (address);\\n\\n\\tfunction nativeReputation() external view returns (address);\\n\\n\\tfunction owner() external view returns (address);\\n}\\n\\ninterface Controller {\\n\\tevent RegisterScheme(address indexed _sender, address indexed _scheme);\\n\\tevent UnregisterScheme(address indexed _sender, address indexed _scheme);\\n\\n\\tfunction genericCall(\\n\\t\\taddress _contract,\\n\\t\\tbytes calldata _data,\\n\\t\\taddress _avatar,\\n\\t\\tuint256 _value\\n\\t) external returns (bool, bytes memory);\\n\\n\\tfunction avatar() external view returns (address);\\n\\n\\tfunction unregisterScheme(address _scheme, address _avatar)\\n\\t\\texternal\\n\\t\\treturns (bool);\\n\\n\\tfunction unregisterSelf(address _avatar) external returns (bool);\\n\\n\\tfunction registerScheme(\\n\\t\\taddress _scheme,\\n\\t\\tbytes32 _paramsHash,\\n\\t\\tbytes4 _permissions,\\n\\t\\taddress _avatar\\n\\t) external returns (bool);\\n\\n\\tfunction isSchemeRegistered(address _scheme, address _avatar)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (bool);\\n\\n\\tfunction getSchemePermissions(address _scheme, address _avatar)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (bytes4);\\n\\n\\tfunction addGlobalConstraint(\\n\\t\\taddress _constraint,\\n\\t\\tbytes32 _paramHash,\\n\\t\\taddress _avatar\\n\\t) external returns (bool);\\n\\n\\tfunction mintTokens(\\n\\t\\tuint256 _amount,\\n\\t\\taddress _beneficiary,\\n\\t\\taddress _avatar\\n\\t) external returns (bool);\\n\\n\\tfunction externalTokenTransfer(\\n\\t\\taddress _token,\\n\\t\\taddress _recipient,\\n\\t\\tuint256 _amount,\\n\\t\\taddress _avatar\\n\\t) external returns (bool);\\n\\n\\tfunction sendEther(\\n\\t\\tuint256 _amountInWei,\\n\\t\\taddress payable _to,\\n\\t\\taddress _avatar\\n\\t) external returns (bool);\\n}\\n\\ninterface GlobalConstraintInterface {\\n\\tenum CallPhase {\\n\\t\\tPre,\\n\\t\\tPost,\\n\\t\\tPreAndPost\\n\\t}\\n\\n\\tfunction pre(\\n\\t\\taddress _scheme,\\n\\t\\tbytes32 _params,\\n\\t\\tbytes32 _method\\n\\t) external returns (bool);\\n\\n\\t/**\\n\\t * @dev when return if this globalConstraints is pre, post or both.\\n\\t * @return CallPhase enum indication  Pre, Post or PreAndPost.\\n\\t */\\n\\tfunction when() external returns (CallPhase);\\n}\\n\\ninterface ReputationInterface {\\n\\tfunction balanceOf(address _user) external view returns (uint256);\\n\\n\\tfunction balanceOfAt(address _user, uint256 _blockNumber)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\tfunction getVotes(address _user) external view returns (uint256);\\n\\n\\tfunction getVotesAt(\\n\\t\\taddress _user,\\n\\t\\tbool _global,\\n\\t\\tuint256 _blockNumber\\n\\t) external view returns (uint256);\\n\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\tfunction totalSupplyAt(uint256 _blockNumber)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\tfunction delegateOf(address _user) external returns (address);\\n}\\n\\ninterface SchemeRegistrar {\\n\\tfunction proposeScheme(\\n\\t\\tAvatar _avatar,\\n\\t\\taddress _scheme,\\n\\t\\tbytes32 _parametersHash,\\n\\t\\tbytes4 _permissions,\\n\\t\\tstring memory _descriptionHash\\n\\t) external returns (bytes32);\\n\\n\\tevent NewSchemeProposal(\\n\\t\\taddress indexed _avatar,\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _intVoteInterface,\\n\\t\\taddress _scheme,\\n\\t\\tbytes32 _parametersHash,\\n\\t\\tbytes4 _permissions,\\n\\t\\tstring _descriptionHash\\n\\t);\\n}\\n\\ninterface IntVoteInterface {\\n\\tevent NewProposal(\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _organization,\\n\\t\\tuint256 _numOfChoices,\\n\\t\\taddress _proposer,\\n\\t\\tbytes32 _paramsHash\\n\\t);\\n\\n\\tevent ExecuteProposal(\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _organization,\\n\\t\\tuint256 _decision,\\n\\t\\tuint256 _totalReputation\\n\\t);\\n\\n\\tevent VoteProposal(\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _organization,\\n\\t\\taddress indexed _voter,\\n\\t\\tuint256 _vote,\\n\\t\\tuint256 _reputation\\n\\t);\\n\\n\\tevent CancelProposal(\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _organization\\n\\t);\\n\\tevent CancelVoting(\\n\\t\\tbytes32 indexed _proposalId,\\n\\t\\taddress indexed _organization,\\n\\t\\taddress indexed _voter\\n\\t);\\n\\n\\t/**\\n\\t * @dev register a new proposal with the given parameters. Every proposal has a unique ID which is being\\n\\t * generated by calculating keccak256 of a incremented counter.\\n\\t * @param _numOfChoices number of voting choices\\n\\t * @param _proposalParameters defines the parameters of the voting machine used for this proposal\\n\\t * @param _proposer address\\n\\t * @param _organization address - if this address is zero the msg.sender will be used as the organization address.\\n\\t * @return proposal's id.\\n\\t */\\n\\tfunction propose(\\n\\t\\tuint256 _numOfChoices,\\n\\t\\tbytes32 _proposalParameters,\\n\\t\\taddress _proposer,\\n\\t\\taddress _organization\\n\\t) external returns (bytes32);\\n\\n\\tfunction vote(\\n\\t\\tbytes32 _proposalId,\\n\\t\\tuint256 _vote,\\n\\t\\tuint256 _rep,\\n\\t\\taddress _voter\\n\\t) external returns (bool);\\n\\n\\tfunction cancelVote(bytes32 _proposalId) external;\\n\\n\\tfunction getNumberOfChoices(bytes32 _proposalId)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\tfunction isVotable(bytes32 _proposalId) external view returns (bool);\\n\\n\\t/**\\n\\t * @dev voteStatus returns the reputation voted for a proposal for a specific voting choice.\\n\\t * @param _proposalId the ID of the proposal\\n\\t * @param _choice the index in the\\n\\t * @return voted reputation for the given choice\\n\\t */\\n\\tfunction voteStatus(bytes32 _proposalId, uint256 _choice)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (uint256);\\n\\n\\t/**\\n\\t * @dev isAbstainAllow returns if the voting machine allow abstain (0)\\n\\t * @return bool true or false\\n\\t */\\n\\tfunction isAbstainAllow() external pure returns (bool);\\n\\n\\t/**\\n     * @dev getAllowedRangeOfChoices returns the allowed range of choices for a voting machine.\\n     * @return min - minimum number of choices\\n               max - maximum number of choices\\n     */\\n\\tfunction getAllowedRangeOfChoices()\\n\\t\\texternal\\n\\t\\tpure\\n\\t\\treturns (uint256 min, uint256 max);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nlibrary DataTypes {\\n\\t// refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\\n\\tstruct ReserveData {\\n\\t\\t//stores the reserve configuration\\n\\t\\tReserveConfigurationMap configuration;\\n\\t\\t//the liquidity index. Expressed in ray\\n\\t\\tuint128 liquidityIndex;\\n\\t\\t//variable borrow index. Expressed in ray\\n\\t\\tuint128 variableBorrowIndex;\\n\\t\\t//the current supply rate. Expressed in ray\\n\\t\\tuint128 currentLiquidityRate;\\n\\t\\t//the current variable borrow rate. Expressed in ray\\n\\t\\tuint128 currentVariableBorrowRate;\\n\\t\\t//the current stable borrow rate. Expressed in ray\\n\\t\\tuint128 currentStableBorrowRate;\\n\\t\\tuint40 lastUpdateTimestamp;\\n\\t\\t//tokens addresses\\n\\t\\taddress aTokenAddress;\\n\\t\\taddress stableDebtTokenAddress;\\n\\t\\taddress variableDebtTokenAddress;\\n\\t\\t//address of the interest rate strategy\\n\\t\\taddress interestRateStrategyAddress;\\n\\t\\t//the id of the reserve. Represents the position in the list of the active reserves\\n\\t\\tuint8 id;\\n\\t}\\n\\n\\tstruct ReserveConfigurationMap {\\n\\t\\t//bit 0-15: LTV\\n\\t\\t//bit 16-31: Liq. threshold\\n\\t\\t//bit 32-47: Liq. bonus\\n\\t\\t//bit 48-55: Decimals\\n\\t\\t//bit 56: Reserve is active\\n\\t\\t//bit 57: reserve is frozen\\n\\t\\t//bit 58: borrowing is enabled\\n\\t\\t//bit 59: stable rate borrowing enabled\\n\\t\\t//bit 60-63: reserved\\n\\t\\t//bit 64-79: reserve factor\\n\\t\\tuint256 data;\\n\\t}\\n\\tenum InterestRateMode { NONE, STABLE, VARIABLE }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 0\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Controller\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract INameService\",\"name\":\"ns\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"nameHash\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"nameAddress\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"staking\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"monthlyRewards\",\"type\":\"uint256[]\"}],\"name\":\"upgradeBasic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract INameService\",\"name\":\"ns\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldDonationStaking\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"donationStaking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldSimpleDAIStaking\",\"type\":\"address\"}],\"name\":\"upgradeDonationStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"schemeRegistrar\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"upgradeScheme\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"compoundVotingMachine\",\"type\":\"address\"}],\"name\":\"upgradeGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract INameService\",\"name\":\"ns\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldReserve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldMarketMaker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldFundManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"COMP\",\"type\":\"address\"}],\"name\":\"upgradeReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ProtocolUpgrade","CompilerVersion":"v0.8.8+commit.dddeac2f","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"00000000000000000000000095c0d9dcea1e243ed696f34cac5e6559c3c128a30000000000000000000000003de7216149f12d8f51540d9a870149560fc11bfb","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}