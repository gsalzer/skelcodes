{"status":"1","message":"OK","result":[{"SourceCode":"// Verified using https://dapp.tools\n\n// hevm: flattened sources of src/registry.sol\n// SPDX-License-Identifier: MIT AND GPL-3.0-only\npragma solidity >=0.8.0 <0.9.0 >=0.8.2 <0.9.0 >=0.8.7 <0.9.0;\n\n////// lib/openzeppelin-contracts/contracts/utils/Context.sol\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/access/Ownable.sol\n\n/* pragma solidity ^0.8.0; */\n\n/* import \"../utils/Context.sol\"; */\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/proxy/Clones.sol\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/proxy/beacon/IBeacon.sol\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n\n////// lib/openzeppelin-contracts/contracts/utils/Address.sol\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Upgrade.sol\n\n/* pragma solidity ^0.8.2; */\n\n/* import \"../beacon/IBeacon.sol\"; */\n/* import \"../../utils/Address.sol\"; */\n/* import \"../../utils/StorageSlot.sol\"; */\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/proxy/Proxy.sol\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n\n////// lib/openzeppelin-contracts/contracts/proxy/ERC1967/ERC1967Proxy.sol\n\n/* pragma solidity ^0.8.0; */\n\n/* import \"../Proxy.sol\"; */\n/* import \"./ERC1967Upgrade.sol\"; */\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/proxy/utils/UUPSUpgradeable.sol\n\n/* pragma solidity ^0.8.0; */\n\n/* import \"../ERC1967/ERC1967Upgrade.sol\"; */\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is ERC1967Upgrade {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}\n\n////// lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n////// lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n////// lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\n\n/* pragma solidity ^0.8.0; */\n\n/* import \"../../utils/introspection/IERC165.sol\"; */\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n\n////// lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n\n////// lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol\n\n/* pragma solidity ^0.8.0; */\n\n/* import \"../IERC721.sol\"; */\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\n////// lib/openzeppelin-contracts/contracts/utils/Strings.sol\n\n/* pragma solidity ^0.8.0; */\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\n\n/* pragma solidity ^0.8.0; */\n\n/* import \"./IERC165.sol\"; */\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n////// lib/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol\n\n/* pragma solidity ^0.8.0; */\n\n/* import \"./IERC721.sol\"; */\n/* import \"./IERC721Receiver.sol\"; */\n/* import \"./extensions/IERC721Metadata.sol\"; */\n/* import \"../../utils/Address.sol\"; */\n/* import \"../../utils/Context.sol\"; */\n/* import \"../../utils/Strings.sol\"; */\n/* import \"../../utils/introspection/ERC165.sol\"; */\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n\n////// lib/radicle-drips-hub/src/Dai.sol\n/* pragma solidity ^0.8.7; */\n\n/* import {IERC20} from \"openzeppelin-contracts/token/ERC20/IERC20.sol\"; */\n\ninterface IDai is IERC20 {\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n\n////// lib/radicle-drips-hub/src/ERC20Reserve.sol\n/* pragma solidity ^0.8.7; */\n\n/* import {Ownable} from \"openzeppelin-contracts/access/Ownable.sol\"; */\n/* import {IERC20} from \"openzeppelin-contracts/token/ERC20/IERC20.sol\"; */\n\ninterface IERC20Reserve {\n    function erc20() external view returns (IERC20);\n\n    function withdraw(uint256 amt) external;\n\n    function deposit(uint256 amt) external;\n}\n\ncontract ERC20Reserve is IERC20Reserve, Ownable {\n    IERC20 public immutable override erc20;\n    address public user;\n    uint256 public balance;\n\n    event Withdrawn(address to, uint256 amt);\n    event Deposited(address from, uint256 amt);\n    event ForceWithdrawn(address to, uint256 amt);\n    event UserSet(address oldUser, address newUser);\n\n    constructor(\n        IERC20 _erc20,\n        address owner,\n        address _user\n    ) {\n        erc20 = _erc20;\n        setUser(_user);\n        transferOwnership(owner);\n    }\n\n    modifier onlyUser() {\n        require(_msgSender() == user, \"Reserve: caller is not the user\");\n        _;\n    }\n\n    function withdraw(uint256 amt) public override onlyUser {\n        require(balance >= amt, \"Reserve: withdrawal over balance\");\n        balance -= amt;\n        emit Withdrawn(_msgSender(), amt);\n        require(erc20.transfer(_msgSender(), amt), \"Reserve: transfer failed\");\n    }\n\n    function deposit(uint256 amt) public override onlyUser {\n        balance += amt;\n        emit Deposited(_msgSender(), amt);\n        require(erc20.transferFrom(_msgSender(), address(this), amt), \"Reserve: transfer failed\");\n    }\n\n    function forceWithdraw(uint256 amt) public onlyOwner {\n        emit ForceWithdrawn(_msgSender(), amt);\n        require(erc20.transfer(_msgSender(), amt), \"Reserve: transfer failed\");\n    }\n\n    function setUser(address newUser) public onlyOwner {\n        emit UserSet(user, newUser);\n        user = newUser;\n    }\n}\n\n////// lib/radicle-drips-hub/src/DaiReserve.sol\n/* pragma solidity ^0.8.7; */\n\n/* import {ERC20Reserve, IERC20Reserve} from \"./ERC20Reserve.sol\"; */\n/* import {IDai} from \"./Dai.sol\"; */\n\ninterface IDaiReserve is IERC20Reserve {\n    function dai() external view returns (IDai);\n}\n\ncontract DaiReserve is ERC20Reserve, IDaiReserve {\n    IDai public immutable override dai;\n\n    constructor(\n        IDai _dai,\n        address owner,\n        address user\n    ) ERC20Reserve(_dai, owner, user) {\n        dai = _dai;\n    }\n}\n\n////// lib/radicle-drips-hub/src/DripsHub.sol\n/* pragma solidity ^0.8.7; */\n\nstruct DripsReceiver {\n    address receiver;\n    uint128 amtPerSec;\n}\n\nstruct SplitsReceiver {\n    address receiver;\n    uint32 weight;\n}\n\n/// @notice Drips hub contract. Automatically drips and splits funds between users.\n///\n/// The user can transfer some funds to their drips balance in the contract\n/// and configure a list of receivers, to whom they want to drip these funds.\n/// As soon as the drips balance is enough to cover at least 1 second of dripping\n/// to the configured receivers, the funds start dripping automatically.\n/// Every second funds are deducted from the drips balance and moved to their receivers' accounts.\n/// The process stops automatically when the drips balance is not enough to cover another second.\n///\n/// The user can have any number of independent configurations and drips balances by using accounts.\n/// An account is identified by the user address and an account identifier.\n/// Accounts of different users are separate entities, even if they have the same identifiers.\n/// An account can be used to drip or give, but not to receive funds.\n///\n/// Every user has a receiver balance, in which they have funds received from other users.\n/// The dripped funds are added to the receiver balances in global cycles.\n/// Every `cycleSecs` seconds the drips hub adds dripped funds to the receivers' balances,\n/// so recently dripped funds may not be collectable immediately.\n/// `cycleSecs` is a constant configured when the drips hub is deployed.\n/// The receiver balance is independent from the drips balance,\n/// to drip received funds they need to be first collected and then added to the drips balance.\n///\n/// The user can share collected funds with other users by using splits.\n/// When collecting, the user gives each of their splits receivers a fraction of the received funds.\n/// Funds received from splits are available for collection immediately regardless of the cycle.\n/// They aren't exempt from being split, so they too can be split when collected.\n/// Users can build chains and networks of splits between each other.\n/// Anybody can request collection of funds for any user,\n/// which can be used to enforce the flow of funds in the network of splits.\n///\n/// The concept of something happening periodically, e.g. every second or every `cycleSecs` are\n/// only high-level abstractions for the user, Ethereum isn't really capable of scheduling work.\n/// The actual implementation emulates that behavior by calculating the results of the scheduled\n/// events based on how many seconds have passed and only when the user needs their outcomes.\n///\n/// The contract assumes that all amounts in the system can be stored in signed 128-bit integers.\n/// It's guaranteed to be safe only when working with assets with supply lower than `2 ^ 127`.\nabstract contract DripsHub {\n    /// @notice On every timestamp `T`, which is a multiple of `cycleSecs`, the receivers\n    /// gain access to drips collected during `T - cycleSecs` to `T - 1`.\n    uint64 public immutable cycleSecs;\n    /// @notice Timestamp at which all drips must be finished\n    uint64 internal constant MAX_TIMESTAMP = type(uint64).max - 2;\n    /// @notice Maximum number of drips receivers of a single user.\n    /// Limits cost of changes in drips configuration.\n    uint32 public constant MAX_DRIPS_RECEIVERS = 100;\n    /// @notice Maximum number of splits receivers of a single user.\n    /// Limits cost of collecting.\n    uint32 public constant MAX_SPLITS_RECEIVERS = 200;\n    /// @notice The total splits weight of a user\n    uint32 public constant TOTAL_SPLITS_WEIGHT = 1_000_000;\n    /// @notice The ERC-1967 storage slot for the contract.\n    /// It holds a single `DripsHubStorage` structure.\n    bytes32 private constant SLOT_STORAGE =\n        bytes32(uint256(keccak256(\"eip1967.dripsHub.storage\")) - 1);\n\n    /// @notice Emitted when drips from a user to a receiver are updated.\n    /// Funds are being dripped on every second between the event block's timestamp (inclusively)\n    /// and`endTime` (exclusively) or until the timestamp of the next drips update (exclusively).\n    /// @param user The dripping user\n    /// @param receiver The receiver of the updated drips\n    /// @param amtPerSec The new amount per second dripped from the user\n    /// to the receiver or 0 if the drips are stopped\n    /// @param endTime The timestamp when dripping will stop,\n    /// always larger than the block timestamp or equal to it if the drips are stopped\n    event Dripping(\n        address indexed user,\n        address indexed receiver,\n        uint128 amtPerSec,\n        uint64 endTime\n    );\n\n    /// @notice Emitted when drips from a user's account to a receiver are updated.\n    /// Funds are being dripped on every second between the event block's timestamp (inclusively)\n    /// and`endTime` (exclusively) or until the timestamp of the next drips update (exclusively).\n    /// @param user The user\n    /// @param account The dripping account\n    /// @param receiver The receiver of the updated drips\n    /// @param amtPerSec The new amount per second dripped from the user's account\n    /// to the receiver or 0 if the drips are stopped\n    /// @param endTime The timestamp when dripping will stop,\n    /// always larger than the block timestamp or equal to it if the drips are stopped\n    event Dripping(\n        address indexed user,\n        uint256 indexed account,\n        address indexed receiver,\n        uint128 amtPerSec,\n        uint64 endTime\n    );\n\n    /// @notice Emitted when the drips configuration of a user is updated.\n    /// @param user The user\n    /// @param balance The new drips balance. These funds will be dripped to the receivers.\n    /// @param receivers The new list of the drips receivers.\n    event DripsUpdated(address indexed user, uint128 balance, DripsReceiver[] receivers);\n\n    /// @notice Emitted when the drips configuration of a user's account is updated.\n    /// @param user The user\n    /// @param account The account\n    /// @param balance The new drips balance. These funds will be dripped to the receivers.\n    /// @param receivers The new list of the drips receivers.\n    event DripsUpdated(\n        address indexed user,\n        uint256 indexed account,\n        uint128 balance,\n        DripsReceiver[] receivers\n    );\n\n    /// @notice Emitted when the user's splits are updated.\n    /// @param user The user\n    /// @param receivers The list of the user's splits receivers.\n    event SplitsUpdated(address indexed user, SplitsReceiver[] receivers);\n\n    /// @notice Emitted when a user collects funds\n    /// @param user The user\n    /// @param collected The collected amount\n    /// @param split The amount split to the user's splits receivers\n    event Collected(address indexed user, uint128 collected, uint128 split);\n\n    /// @notice Emitted when funds are split from a user to a receiver.\n    /// This is caused by the user collecting received funds.\n    /// @param user The user\n    /// @param receiver The splits receiver\n    /// @param amt The amount split to the receiver\n    event Split(address indexed user, address indexed receiver, uint128 amt);\n\n    /// @notice Emitted when funds are given from the user to the receiver.\n    /// @param user The address of the user\n    /// @param receiver The receiver\n    /// @param amt The given amount\n    event Given(address indexed user, address indexed receiver, uint128 amt);\n\n    /// @notice Emitted when funds are given from the user's account to the receiver.\n    /// @param user The address of the user\n    /// @param account The user's account\n    /// @param receiver The receiver\n    /// @param amt The given amount\n    event Given(\n        address indexed user,\n        uint256 indexed account,\n        address indexed receiver,\n        uint128 amt\n    );\n\n    struct ReceiverState {\n        // The amount collectable independently from cycles\n        uint128 collectable;\n        // The next cycle to be collected\n        uint64 nextCollectedCycle;\n        // --- SLOT BOUNDARY\n        // The changes of collected amounts on specific cycle.\n        // The keys are cycles, each cycle `C` becomes collectable on timestamp `C * cycleSecs`.\n        // Values for cycles before `nextCollectedCycle` are guaranteed to be zeroed.\n        // This means that the value of `amtDeltas[nextCollectedCycle].thisCycle` is always\n        // relative to 0 or in other words it's an absolute value independent from other cycles.\n        mapping(uint64 => AmtDelta) amtDeltas;\n    }\n\n    struct AmtDelta {\n        // Amount delta applied on this cycle\n        int128 thisCycle;\n        // Amount delta applied on the next cycle\n        int128 nextCycle;\n    }\n\n    struct UserOrAccount {\n        bool isAccount;\n        address user;\n        uint256 account;\n    }\n\n    struct DripsHubStorage {\n        /// @notice Users' splits configuration hashes, see `hashSplits`.\n        /// The key is the user address.\n        mapping(address => bytes32) splitsHash;\n        /// @notice Users' drips configuration hashes, see `hashDrips`.\n        /// The key is the user address.\n        mapping(address => bytes32) userDripsHashes;\n        /// @notice Users' accounts' configuration hashes, see `hashDrips`.\n        /// The key are the user address and the account.\n        mapping(address => mapping(uint256 => bytes32)) accountDripsHashes;\n        /// @notice Users' receiver states.\n        /// The key is the user address.\n        mapping(address => ReceiverState) receiverStates;\n    }\n\n    /// @param _cycleSecs The length of cycleSecs to be used in the contract instance.\n    /// Low value makes funds more available by shortening the average time of funds being frozen\n    /// between being taken from the users' drips balances and being collectable by their receivers.\n    /// High value makes collecting cheaper by making it process less cycles for a given time range.\n    constructor(uint64 _cycleSecs) {\n        cycleSecs = _cycleSecs;\n    }\n\n    /// @notice Returns the contract storage.\n    /// @return dripsHubStorage The storage.\n    function _storage() internal pure returns (DripsHubStorage storage dripsHubStorage) {\n        bytes32 slot = SLOT_STORAGE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Based on OpenZeppelin's StorageSlot\n            dripsHubStorage.slot := slot\n        }\n    }\n\n    /// @notice Returns amount of received funds available for collection for a user.\n    /// @param user The user\n    /// @param currReceivers The list of the user's current splits receivers.\n    /// @return collected The collected amount\n    /// @return split The amount split to the user's splits receivers\n    function collectable(address user, SplitsReceiver[] memory currReceivers)\n        public\n        view\n        returns (uint128 collected, uint128 split)\n    {\n        ReceiverState storage receiver = _storage().receiverStates[user];\n        _assertCurrSplits(user, currReceivers);\n\n        // Collectable independently from cycles\n        collected = receiver.collectable;\n\n        // Collectable from cycles\n        uint64 collectedCycle = receiver.nextCollectedCycle;\n        uint64 currFinishedCycle = _currTimestamp() / cycleSecs;\n        if (collectedCycle != 0 && collectedCycle <= currFinishedCycle) {\n            int128 cycleAmt = 0;\n            for (; collectedCycle <= currFinishedCycle; collectedCycle++) {\n                cycleAmt += receiver.amtDeltas[collectedCycle].thisCycle;\n                collected += uint128(cycleAmt);\n                cycleAmt += receiver.amtDeltas[collectedCycle].nextCycle;\n            }\n        }\n\n        // split when collected\n        if (collected > 0 && currReceivers.length > 0) {\n            uint32 splitsWeight = 0;\n            for (uint256 i = 0; i < currReceivers.length; i++) {\n                splitsWeight += currReceivers[i].weight;\n            }\n            split = uint128((uint160(collected) * splitsWeight) / TOTAL_SPLITS_WEIGHT);\n            collected -= split;\n        }\n    }\n\n    /// @notice Collects all received funds available for the user\n    /// and transfers them out of the drips hub contract to that user's wallet.\n    /// @param user The user\n    /// @param currReceivers The list of the user's current splits receivers.\n    /// @return collected The collected amount\n    /// @return split The amount split to the user's splits receivers\n    function collect(address user, SplitsReceiver[] memory currReceivers)\n        public\n        virtual\n        returns (uint128 collected, uint128 split)\n    {\n        (collected, split) = _collectInternal(user, currReceivers);\n        _transfer(user, int128(collected));\n    }\n\n    /// @notice Counts cycles which will need to be analyzed when collecting or flushing.\n    /// This function can be used to detect that there are too many cycles\n    /// to analyze in a single transaction and flushing is needed.\n    /// @param user The user\n    /// @return flushable The number of cycles which can be flushed\n    function flushableCycles(address user) public view returns (uint64 flushable) {\n        uint64 nextCollectedCycle = _storage().receiverStates[user].nextCollectedCycle;\n        if (nextCollectedCycle == 0) return 0;\n        uint64 currFinishedCycle = _currTimestamp() / cycleSecs;\n        return currFinishedCycle + 1 - nextCollectedCycle;\n    }\n\n    /// @notice Flushes uncollected cycles of the user.\n    /// Flushed cycles won't need to be analyzed when the user collects from them.\n    /// Calling this function does not collect and does not affect the collectable amount.\n    ///\n    /// This function is needed when collecting funds received over a period so long, that the gas\n    /// needed for analyzing all the uncollected cycles can't fit in a single transaction.\n    /// Calling this function allows spreading the analysis cost over multiple transactions.\n    /// A cycle is never flushed more than once, even if this function is called many times.\n    /// @param user The user\n    /// @param maxCycles The maximum number of flushed cycles.\n    /// If too low, flushing will be cheap, but will cut little gas from the next collection.\n    /// If too high, flushing may become too expensive to fit in a single transaction.\n    /// @return flushable The number of cycles which can be flushed\n    function flushCycles(address user, uint64 maxCycles) public virtual returns (uint64 flushable) {\n        flushable = flushableCycles(user);\n        uint64 cycles = maxCycles < flushable ? maxCycles : flushable;\n        flushable -= cycles;\n        uint128 collected = _flushCyclesInternal(user, cycles);\n        if (collected > 0) _storage().receiverStates[user].collectable += collected;\n    }\n\n    /// @notice Collects all received funds available for the user,\n    /// but doesn't transfer them to the user's wallet.\n    /// @param user The user\n    /// @param currReceivers The list of the user's current splits receivers.\n    /// @return collected The collected amount\n    /// @return split The amount split to the user's splits receivers\n    function _collectInternal(address user, SplitsReceiver[] memory currReceivers)\n        internal\n        returns (uint128 collected, uint128 split)\n    {\n        mapping(address => ReceiverState) storage receiverStates = _storage().receiverStates;\n        ReceiverState storage receiver = receiverStates[user];\n        _assertCurrSplits(user, currReceivers);\n\n        // Collectable independently from cycles\n        collected = receiver.collectable;\n        if (collected > 0) receiver.collectable = 0;\n\n        // Collectable from cycles\n        uint64 cycles = flushableCycles(user);\n        collected += _flushCyclesInternal(user, cycles);\n\n        // split when collected\n        if (collected > 0 && currReceivers.length > 0) {\n            uint32 splitsWeight = 0;\n            for (uint256 i = 0; i < currReceivers.length; i++) {\n                splitsWeight += currReceivers[i].weight;\n                uint128 splitsAmt = uint128(\n                    (uint160(collected) * splitsWeight) / TOTAL_SPLITS_WEIGHT - split\n                );\n                split += splitsAmt;\n                address splitsReceiver = currReceivers[i].receiver;\n                receiverStates[splitsReceiver].collectable += splitsAmt;\n                emit Split(user, splitsReceiver, splitsAmt);\n            }\n            collected -= split;\n        }\n        emit Collected(user, collected, split);\n    }\n\n    /// @notice Collects and clears user's cycles\n    /// @param user The user\n    /// @param count The number of flushed cycles.\n    /// @return collectedAmt The collected amount\n    function _flushCyclesInternal(address user, uint64 count)\n        internal\n        returns (uint128 collectedAmt)\n    {\n        if (count == 0) return 0;\n        ReceiverState storage receiver = _storage().receiverStates[user];\n        uint64 cycle = receiver.nextCollectedCycle;\n        int128 cycleAmt = 0;\n        for (uint256 i = 0; i < count; i++) {\n            cycleAmt += receiver.amtDeltas[cycle].thisCycle;\n            collectedAmt += uint128(cycleAmt);\n            cycleAmt += receiver.amtDeltas[cycle].nextCycle;\n            delete receiver.amtDeltas[cycle];\n            cycle++;\n        }\n        // The next cycle delta must be relative to the last collected cycle, which got zeroed.\n        // In other words the next cycle delta must be an absolute value.\n        if (cycleAmt != 0) receiver.amtDeltas[cycle].thisCycle += cycleAmt;\n        receiver.nextCollectedCycle = cycle;\n    }\n\n    /// @notice Gives funds from the user or their account to the receiver.\n    /// The receiver can collect them immediately.\n    /// Transfers the funds to be given from the user's wallet to the drips hub contract.\n    /// @param userOrAccount The user or their account\n    /// @param receiver The receiver\n    /// @param amt The given amount\n    function _give(\n        UserOrAccount memory userOrAccount,\n        address receiver,\n        uint128 amt\n    ) internal {\n        _storage().receiverStates[receiver].collectable += amt;\n        if (userOrAccount.isAccount) {\n            emit Given(userOrAccount.user, userOrAccount.account, receiver, amt);\n        } else {\n            emit Given(userOrAccount.user, receiver, amt);\n        }\n        _transfer(userOrAccount.user, -int128(amt));\n    }\n\n    /// @notice Current user's drips hash, see `hashDrips`.\n    /// @param user The user\n    /// @return currDripsHash The current user's drips hash\n    function dripsHash(address user) public view returns (bytes32 currDripsHash) {\n        return _storage().userDripsHashes[user];\n    }\n\n    /// @notice Current user account's drips hash, see `hashDrips`.\n    /// @param user The user\n    /// @param account The account\n    /// @return currDripsHash The current user account's drips hash\n    function dripsHash(address user, uint256 account) public view returns (bytes32 currDripsHash) {\n        return _storage().accountDripsHashes[user][account];\n    }\n\n    /// @notice Sets the user's or the account's drips configuration.\n    /// Transfers funds between the user's wallet and the drips hub contract\n    /// to fulfill the change of the drips balance.\n    /// @param userOrAccount The user or their account\n    /// @param lastUpdate The timestamp of the last drips update of the user or the account.\n    /// If this is the first update, pass zero.\n    /// @param lastBalance The drips balance after the last drips update of the user or the account.\n    /// If this is the first update, pass zero.\n    /// @param currReceivers The list of the drips receivers set in the last drips update\n    /// of the user or the account.\n    /// If this is the first update, pass an empty array.\n    /// @param balanceDelta The drips balance change to be applied.\n    /// Positive to add funds to the drips balance, negative to remove them.\n    /// @param newReceivers The list of the drips receivers of the user or the account to be set.\n    /// Must be sorted by the receivers' addresses, deduplicated and without 0 amtPerSecs.\n    /// @return newBalance The new drips balance of the user or the account.\n    /// Pass it as `lastBalance` when updating that user or the account for the next time.\n    /// @return realBalanceDelta The actually applied drips balance change.\n    function _setDrips(\n        UserOrAccount memory userOrAccount,\n        uint64 lastUpdate,\n        uint128 lastBalance,\n        DripsReceiver[] memory currReceivers,\n        int128 balanceDelta,\n        DripsReceiver[] memory newReceivers\n    ) internal returns (uint128 newBalance, int128 realBalanceDelta) {\n        _assertCurrDrips(userOrAccount, lastUpdate, lastBalance, currReceivers);\n        uint128 newAmtPerSec = _assertDripsReceiversValid(newReceivers);\n        uint128 currAmtPerSec = _totalDripsAmtPerSec(currReceivers);\n        uint64 currEndTime = _dripsEndTime(lastUpdate, lastBalance, currAmtPerSec);\n        (newBalance, realBalanceDelta) = _updateDripsBalance(\n            lastUpdate,\n            lastBalance,\n            currEndTime,\n            currAmtPerSec,\n            balanceDelta\n        );\n        uint64 newEndTime = _dripsEndTime(_currTimestamp(), newBalance, newAmtPerSec);\n        _updateDripsReceiversStates(\n            userOrAccount,\n            currReceivers,\n            currEndTime,\n            newReceivers,\n            newEndTime\n        );\n        _storeNewDrips(userOrAccount, newBalance, newReceivers);\n        _emitDripsUpdated(userOrAccount, newBalance, newReceivers);\n        _transfer(userOrAccount.user, -realBalanceDelta);\n    }\n\n    /// @notice Validates a list of drips receivers.\n    /// @param receivers The list of drips receivers.\n    /// Must be sorted by the receivers' addresses, deduplicated and without 0 amtPerSecs.\n    /// @return totalAmtPerSec The total amount per second of all drips receivers.\n    function _assertDripsReceiversValid(DripsReceiver[] memory receivers)\n        internal\n        pure\n        returns (uint128 totalAmtPerSec)\n    {\n        require(receivers.length <= MAX_DRIPS_RECEIVERS, \"Too many drips receivers\");\n        uint256 amtPerSec = 0;\n        address prevReceiver;\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint128 amt = receivers[i].amtPerSec;\n            require(amt != 0, \"Drips receiver amtPerSec is zero\");\n            amtPerSec += amt;\n            address receiver = receivers[i].receiver;\n            if (i > 0) {\n                require(prevReceiver != receiver, \"Duplicate drips receivers\");\n                require(prevReceiver < receiver, \"Drips receivers not sorted by address\");\n            }\n            prevReceiver = receiver;\n        }\n        require(amtPerSec <= type(uint128).max, \"Total drips receivers amtPerSec too high\");\n        return uint128(amtPerSec);\n    }\n\n    /// @notice Calculates the total amount per second of all the drips receivers.\n    /// @param receivers The list of the receivers.\n    /// It must have passed `_assertDripsReceiversValid` in the past.\n    /// @return totalAmtPerSec The total amount per second of all the drips receivers\n    function _totalDripsAmtPerSec(DripsReceiver[] memory receivers)\n        internal\n        pure\n        returns (uint128 totalAmtPerSec)\n    {\n        uint256 length = receivers.length;\n        uint256 i = 0;\n        while (i < length) {\n            // Safe, because `receivers` passed `_assertDripsReceiversValid` in the past\n            unchecked {\n                totalAmtPerSec += receivers[i++].amtPerSec;\n            }\n        }\n    }\n\n    /// @notice Updates drips balance.\n    /// @param lastUpdate The timestamp of the last drips update.\n    /// If this is the first update, pass zero.\n    /// @param lastBalance The drips balance after the last drips update.\n    /// If this is the first update, pass zero.\n    /// @param currEndTime Time when drips were supposed to end according to the last drips update.\n    /// @param currAmtPerSec The total amount per second of all drips receivers\n    /// according to the last drips update.\n    /// @param balanceDelta The drips balance change to be applied.\n    /// Positive to add funds to the drips balance, negative to remove them.\n    /// @return newBalance The new drips balance.\n    /// Pass it as `lastBalance` when updating for the next time.\n    /// @return realBalanceDelta The actually applied drips balance change.\n    /// If positive, this is the amount which should be transferred from the user to the drips hub,\n    /// or if negative, from the drips hub to the user.\n    function _updateDripsBalance(\n        uint64 lastUpdate,\n        uint128 lastBalance,\n        uint64 currEndTime,\n        uint128 currAmtPerSec,\n        int128 balanceDelta\n    ) internal view returns (uint128 newBalance, int128 realBalanceDelta) {\n        if (currEndTime > _currTimestamp()) currEndTime = _currTimestamp();\n        uint128 dripped = (currEndTime - lastUpdate) * currAmtPerSec;\n        int128 currBalance = int128(lastBalance - dripped);\n        int136 balance = currBalance + int136(balanceDelta);\n        if (balance < 0) balance = 0;\n        return (uint128(uint136(balance)), int128(balance - currBalance));\n    }\n\n    /// @notice Emit an event when drips are updated.\n    /// @param userOrAccount The user or their account\n    /// @param balance The new drips balance.\n    /// @param receivers The new list of the drips receivers.\n    function _emitDripsUpdated(\n        UserOrAccount memory userOrAccount,\n        uint128 balance,\n        DripsReceiver[] memory receivers\n    ) internal {\n        if (userOrAccount.isAccount) {\n            emit DripsUpdated(userOrAccount.user, userOrAccount.account, balance, receivers);\n        } else {\n            emit DripsUpdated(userOrAccount.user, balance, receivers);\n        }\n    }\n\n    /// @notice Updates the user's or the account's drips receivers' states.\n    /// It applies the effects of the change of the drips configuration.\n    /// @param userOrAccount The user or their account\n    /// @param currReceivers The list of the drips receivers set in the last drips update\n    /// of the user or the account.\n    /// If this is the first update, pass an empty array.\n    /// @param currEndTime Time when drips were supposed to end according to the last drips update.\n    /// @param newReceivers  The list of the drips receivers of the user or the account to be set.\n    /// Must be sorted by the receivers' addresses, deduplicated and without 0 amtPerSecs.\n    /// @param newEndTime Time when drips will end according to the new drips configuration.\n    function _updateDripsReceiversStates(\n        UserOrAccount memory userOrAccount,\n        DripsReceiver[] memory currReceivers,\n        uint64 currEndTime,\n        DripsReceiver[] memory newReceivers,\n        uint64 newEndTime\n    ) internal {\n        // Skip iterating over `currReceivers` if dripping has run out\n        uint256 currIdx = currEndTime > _currTimestamp() ? 0 : currReceivers.length;\n        // Skip iterating over `newReceivers` if no new dripping is started\n        uint256 newIdx = newEndTime > _currTimestamp() ? 0 : newReceivers.length;\n        while (true) {\n            // Each iteration gets the next drips update and applies it on the receiver state.\n            // A drips update is composed of two drips receiver configurations,\n            // one current and one new, or from a single drips receiver configuration\n            // if the drips receiver is being added or removed.\n            bool pickCurr = currIdx < currReceivers.length;\n            bool pickNew = newIdx < newReceivers.length;\n            if (!pickCurr && !pickNew) break;\n            if (pickCurr && pickNew) {\n                // There are two candidate drips receiver configurations to create a drips update.\n                // Pick both if they describe the same receiver or the one with a lower address.\n                // The one with a higher address won't be used in this iteration.\n                // Because drips receivers lists are sorted by addresses and deduplicated,\n                // all matching pairs of drips receiver configurations will be found.\n                address currReceiver = currReceivers[currIdx].receiver;\n                address newReceiver = newReceivers[newIdx].receiver;\n                pickCurr = currReceiver <= newReceiver;\n                pickNew = newReceiver <= currReceiver;\n            }\n            // The drips update parameters\n            address receiver;\n            int128 currAmtPerSec = 0;\n            int128 newAmtPerSec = 0;\n            if (pickCurr) {\n                receiver = currReceivers[currIdx].receiver;\n                currAmtPerSec = int128(currReceivers[currIdx].amtPerSec);\n                // Clear the obsolete drips end\n                _setDelta(receiver, currEndTime, currAmtPerSec);\n                currIdx++;\n            }\n            if (pickNew) {\n                receiver = newReceivers[newIdx].receiver;\n                newAmtPerSec = int128(newReceivers[newIdx].amtPerSec);\n                // Apply the new drips end\n                _setDelta(receiver, newEndTime, -newAmtPerSec);\n                newIdx++;\n            }\n            // Apply the drips update since now\n            _setDelta(receiver, _currTimestamp(), newAmtPerSec - currAmtPerSec);\n            _emitDripping(userOrAccount, receiver, uint128(newAmtPerSec), newEndTime);\n            // The receiver may have never been used\n            if (!pickCurr) {\n                ReceiverState storage receiverState = _storage().receiverStates[receiver];\n                // The receiver has never been used, initialize it\n                if (receiverState.nextCollectedCycle == 0) {\n                    receiverState.nextCollectedCycle = _currTimestamp() / cycleSecs + 1;\n                }\n            }\n        }\n    }\n\n    /// @notice Emit an event when drips from a user to a receiver are updated.\n    /// @param userOrAccount The user or their account\n    /// @param receiver The receiver\n    /// @param amtPerSec The new amount per second dripped from the user or the account\n    /// to the receiver or 0 if the drips are stopped\n    /// @param endTime The timestamp when dripping will stop\n    function _emitDripping(\n        UserOrAccount memory userOrAccount,\n        address receiver,\n        uint128 amtPerSec,\n        uint64 endTime\n    ) internal {\n        if (amtPerSec == 0) endTime = _currTimestamp();\n        if (userOrAccount.isAccount) {\n            emit Dripping(userOrAccount.user, userOrAccount.account, receiver, amtPerSec, endTime);\n        } else {\n            emit Dripping(userOrAccount.user, receiver, amtPerSec, endTime);\n        }\n    }\n\n    /// @notice Calculates the timestamp when dripping will end.\n    /// @param startTime Time when dripping is started.\n    /// @param startBalance The drips balance when dripping is started.\n    /// @param totalAmtPerSec The total amount per second of all the drips receivers\n    /// @return dripsEndTime The dripping end time.\n    function _dripsEndTime(\n        uint64 startTime,\n        uint128 startBalance,\n        uint128 totalAmtPerSec\n    ) internal pure returns (uint64 dripsEndTime) {\n        if (totalAmtPerSec == 0) return startTime;\n        uint256 endTime = startTime + uint256(startBalance / totalAmtPerSec);\n        return endTime > MAX_TIMESTAMP ? MAX_TIMESTAMP : uint64(endTime);\n    }\n\n    /// @notice Asserts that the drips configuration is the currently used one.\n    /// @param userOrAccount The user or their account\n    /// @param lastUpdate The timestamp of the last drips update of the user or the account.\n    /// If this is the first update, pass zero.\n    /// @param lastBalance The drips balance after the last drips update of the user or the account.\n    /// If this is the first update, pass zero.\n    /// @param currReceivers The list of the drips receivers set in the last drips update\n    /// of the user or the account.\n    /// If this is the first update, pass an empty array.\n    function _assertCurrDrips(\n        UserOrAccount memory userOrAccount,\n        uint64 lastUpdate,\n        uint128 lastBalance,\n        DripsReceiver[] memory currReceivers\n    ) internal view {\n        bytes32 expectedHash;\n        if (userOrAccount.isAccount) {\n            expectedHash = _storage().accountDripsHashes[userOrAccount.user][userOrAccount.account];\n        } else {\n            expectedHash = _storage().userDripsHashes[userOrAccount.user];\n        }\n        bytes32 actualHash = hashDrips(lastUpdate, lastBalance, currReceivers);\n        require(actualHash == expectedHash, \"Invalid current drips configuration\");\n    }\n\n    /// @notice Stores the hash of the new drips configuration to be used in `_assertCurrDrips`.\n    /// @param userOrAccount The user or their account\n    /// @param newBalance The user or the account drips balance.\n    /// @param newReceivers The list of the drips receivers of the user or the account.\n    /// Must be sorted by the receivers' addresses, deduplicated and without 0 amtPerSecs.\n    function _storeNewDrips(\n        UserOrAccount memory userOrAccount,\n        uint128 newBalance,\n        DripsReceiver[] memory newReceivers\n    ) internal {\n        bytes32 newDripsHash = hashDrips(_currTimestamp(), newBalance, newReceivers);\n        if (userOrAccount.isAccount) {\n            _storage().accountDripsHashes[userOrAccount.user][userOrAccount.account] = newDripsHash;\n        } else {\n            _storage().userDripsHashes[userOrAccount.user] = newDripsHash;\n        }\n    }\n\n    /// @notice Calculates the hash of the drips configuration.\n    /// It's used to verify if drips configuration is the previously set one.\n    /// @param update The timestamp of the drips update.\n    /// If the drips have never been updated, pass zero.\n    /// @param balance The drips balance.\n    /// If the drips have never been updated, pass zero.\n    /// @param receivers The list of the drips receivers.\n    /// Must be sorted by the receivers' addresses, deduplicated and without 0 amtPerSecs.\n    /// If the drips have never been updated, pass an empty array.\n    /// @return dripsConfigurationHash The hash of the drips configuration\n    function hashDrips(\n        uint64 update,\n        uint128 balance,\n        DripsReceiver[] memory receivers\n    ) public pure returns (bytes32 dripsConfigurationHash) {\n        if (update == 0 && balance == 0 && receivers.length == 0) return bytes32(0);\n        return keccak256(abi.encode(receivers, update, balance));\n    }\n\n    /// @notice Collects funds received by the user and sets their splits.\n    /// The collected funds are split according to `currReceivers`.\n    /// @param user The user\n    /// @param currReceivers The list of the user's splits receivers which is currently in use.\n    /// If this function is called for the first time for the user, should be an empty array.\n    /// @param newReceivers The new list of the user's splits receivers.\n    /// Must be sorted by the splits receivers' addresses, deduplicated and without 0 weights.\n    /// Each splits receiver will be getting `weight / TOTAL_SPLITS_WEIGHT`\n    /// share of the funds collected by the user.\n    /// @return collected The collected amount\n    /// @return split The amount split to the user's splits receivers\n    function _setSplits(\n        address user,\n        SplitsReceiver[] memory currReceivers,\n        SplitsReceiver[] memory newReceivers\n    ) internal returns (uint128 collected, uint128 split) {\n        (collected, split) = _collectInternal(user, currReceivers);\n        _assertSplitsValid(newReceivers);\n        _storage().splitsHash[user] = hashSplits(newReceivers);\n        emit SplitsUpdated(user, newReceivers);\n        _transfer(user, int128(collected));\n    }\n\n    /// @notice Validates a list of splits receivers\n    /// @param receivers The list of splits receivers\n    /// Must be sorted by the splits receivers' addresses, deduplicated and without 0 weights.\n    function _assertSplitsValid(SplitsReceiver[] memory receivers) internal pure {\n        require(receivers.length <= MAX_SPLITS_RECEIVERS, \"Too many splits receivers\");\n        uint64 totalWeight = 0;\n        address prevReceiver;\n        for (uint256 i = 0; i < receivers.length; i++) {\n            uint32 weight = receivers[i].weight;\n            require(weight != 0, \"Splits receiver weight is zero\");\n            totalWeight += weight;\n            address receiver = receivers[i].receiver;\n            if (i > 0) {\n                require(prevReceiver != receiver, \"Duplicate splits receivers\");\n                require(prevReceiver < receiver, \"Splits receivers not sorted by address\");\n            }\n            prevReceiver = receiver;\n        }\n        require(totalWeight <= TOTAL_SPLITS_WEIGHT, \"Splits weights sum too high\");\n    }\n\n    /// @notice Current user's splits hash, see `hashSplits`.\n    /// @param user The user\n    /// @return currSplitsHash The current user's splits hash\n    function splitsHash(address user) public view returns (bytes32 currSplitsHash) {\n        return _storage().splitsHash[user];\n    }\n\n    /// @notice Asserts that the list of splits receivers is the user's currently used one.\n    /// @param user The user\n    /// @param currReceivers The list of the user's current splits receivers.\n    function _assertCurrSplits(address user, SplitsReceiver[] memory currReceivers) internal view {\n        require(\n            hashSplits(currReceivers) == _storage().splitsHash[user],\n            \"Invalid current splits receivers\"\n        );\n    }\n\n    /// @notice Calculates the hash of the list of splits receivers.\n    /// @param receivers The list of the splits receivers.\n    /// Must be sorted by the splits receivers' addresses, deduplicated and without 0 weights.\n    /// @return receiversHash The hash of the list of splits receivers.\n    function hashSplits(SplitsReceiver[] memory receivers)\n        public\n        pure\n        returns (bytes32 receiversHash)\n    {\n        if (receivers.length == 0) return bytes32(0);\n        return keccak256(abi.encode(receivers));\n    }\n\n    /// @notice Called when funds need to be transferred between the user and the drips hub.\n    /// The function must be called no more than once per transaction.\n    /// @param user The user\n    /// @param amt The transferred amount.\n    /// Positive to transfer funds to the user, negative to transfer from them.\n    function _transfer(address user, int128 amt) internal virtual;\n\n    /// @notice Sets amt delta of a user on a given timestamp\n    /// @param user The user\n    /// @param timestamp The timestamp from which the delta takes effect\n    /// @param amtPerSecDelta Change of the per-second receiving rate\n    function _setDelta(\n        address user,\n        uint64 timestamp,\n        int128 amtPerSecDelta\n    ) internal {\n        if (amtPerSecDelta == 0) return;\n        mapping(uint64 => AmtDelta) storage amtDeltas = _storage().receiverStates[user].amtDeltas;\n        // In order to set a delta on a specific timestamp it must be introduced in two cycles.\n        // The cycle delta is split proportionally based on how much this cycle is affected.\n        // The next cycle has the rest of the delta applied, so the update is fully completed.\n        uint64 thisCycle = timestamp / cycleSecs + 1;\n        uint64 nextCycleSecs = timestamp % cycleSecs;\n        uint64 thisCycleSecs = cycleSecs - nextCycleSecs;\n        amtDeltas[thisCycle].thisCycle += int128(uint128(thisCycleSecs)) * amtPerSecDelta;\n        amtDeltas[thisCycle].nextCycle += int128(uint128(nextCycleSecs)) * amtPerSecDelta;\n    }\n\n    function _userOrAccount(address user) internal pure returns (UserOrAccount memory) {\n        return UserOrAccount({isAccount: false, user: user, account: 0});\n    }\n\n    function _userOrAccount(address user, uint256 account)\n        internal\n        pure\n        returns (UserOrAccount memory)\n    {\n        return UserOrAccount({isAccount: true, user: user, account: account});\n    }\n\n    function _currTimestamp() internal view returns (uint64) {\n        return uint64(block.timestamp);\n    }\n}\n\n////// lib/radicle-drips-hub/src/ManagedDripsHub.sol\n/* pragma solidity ^0.8.7; */\n\n/* import {UUPSUpgradeable} from \"openzeppelin-contracts/proxy/utils/UUPSUpgradeable.sol\"; */\n/* import {ERC1967Proxy} from \"openzeppelin-contracts/proxy/ERC1967/ERC1967Proxy.sol\"; */\n/* import {ERC1967Upgrade} from \"openzeppelin-contracts/proxy/ERC1967/ERC1967Upgrade.sol\"; */\n/* import {StorageSlot} from \"openzeppelin-contracts/utils/StorageSlot.sol\"; */\n/* import {DripsHub, SplitsReceiver} from \"./DripsHub.sol\"; */\n\n/// @notice The DripsHub which is UUPS-upgradable, pausable and has an admin.\n/// It can't be used directly, only via a proxy.\n///\n/// ManagedDripsHub uses the ERC-1967 admin slot to store the admin address.\n/// All instances of the contracts are owned by address `0x00`.\n/// While this contract is capable of updating the admin,\n/// the proxy is expected to set up the initial value of the ERC-1967 admin.\n///\n/// All instances of the contracts are paused and can't be unpaused.\n/// When a proxy uses such contract via delegation, it's initially unpaused.\nabstract contract ManagedDripsHub is DripsHub, UUPSUpgradeable {\n    /// @notice The ERC-1967 storage slot for the contract.\n    /// It holds a single boolean indicating if the contract is paused.\n    bytes32 private constant SLOT_PAUSED =\n        bytes32(uint256(keccak256(\"eip1967.managedDripsHub.paused\")) - 1);\n\n    /// @notice Emitted when the pause is triggered.\n    /// @param account The account which triggered the change.\n    event Paused(address account);\n\n    /// @notice Emitted when the pause is lifted.\n    /// @param account The account which triggered the change.\n    event Unpaused(address account);\n\n    /// @notice Initializes the contract in paused state and with no admin.\n    /// The contract instance can be used only as a call delegation target for a proxy.\n    /// @param cycleSecs The length of cycleSecs to be used in the contract instance.\n    /// Low value makes funds more available by shortening the average time of funds being frozen\n    /// between being taken from the users' drips balances and being collectable by their receivers.\n    /// High value makes collecting cheaper by making it process less cycles for a given time range.\n    constructor(uint64 cycleSecs) DripsHub(cycleSecs) {\n        _pausedSlot().value = true;\n    }\n\n    /// @notice Collects all received funds available for the user\n    /// and transfers them out of the drips hub contract to that user's wallet.\n    /// @param user The user\n    /// @param currReceivers The list of the user's current splits receivers.\n    /// @return collected The collected amount\n    /// @return split The amount split to the user's splits receivers\n    function collect(address user, SplitsReceiver[] memory currReceivers)\n        public\n        override\n        whenNotPaused\n        returns (uint128 collected, uint128 split)\n    {\n        return super.collect(user, currReceivers);\n    }\n\n    /// @notice Flushes uncollected cycles of the user.\n    /// Flushed cycles won't need to be analyzed when the user collects from them.\n    /// Calling this function does not collect and does not affect the collectable amount.\n    ///\n    /// This function is needed when collecting funds received over a period so long, that the gas\n    /// needed for analyzing all the uncollected cycles can't fit in a single transaction.\n    /// Calling this function allows spreading the analysis cost over multiple transactions.\n    /// A cycle is never flushed more than once, even if this function is called many times.\n    /// @param user The user\n    /// @param maxCycles The maximum number of flushed cycles.\n    /// If too low, flushing will be cheap, but will cut little gas from the next collection.\n    /// If too high, flushing may become too expensive to fit in a single transaction.\n    /// @return flushable The number of cycles which can be flushed\n    function flushCycles(address user, uint64 maxCycles)\n        public\n        override\n        whenNotPaused\n        returns (uint64 flushable)\n    {\n        return super.flushCycles(user, maxCycles);\n    }\n\n    /// @notice Authorizes the contract upgrade. See `UUPSUpgradable` docs for more details.\n    function _authorizeUpgrade(address newImplementation) internal view override onlyAdmin {\n        newImplementation;\n    }\n\n    /// @notice Returns the address of the current admin.\n    function admin() public view returns (address) {\n        return _getAdmin();\n    }\n\n    /// @notice Changes the admin of the contract.\n    /// Can only be called by the current admin.\n    function changeAdmin(address newAdmin) public onlyAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /// @notice Throws if called by any account other than the admin.\n    modifier onlyAdmin() {\n        require(admin() == msg.sender, \"Caller is not the admin\");\n        _;\n    }\n\n    /// @notice Returns true if the contract is paused, and false otherwise.\n    function paused() public view returns (bool isPaused) {\n        return _pausedSlot().value;\n    }\n\n    /// @notice Triggers stopped state.\n    function pause() public whenNotPaused onlyAdmin {\n        _pausedSlot().value = true;\n        emit Paused(msg.sender);\n    }\n\n    /// @notice Returns to normal state.\n    function unpause() public whenPaused onlyAdmin {\n        _pausedSlot().value = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /// @notice Modifier to make a function callable only when the contract is not paused.\n    modifier whenNotPaused() {\n        require(!paused(), \"Contract paused\");\n        _;\n    }\n\n    /// @notice Modifier to make a function callable only when the contract is paused.\n    modifier whenPaused() {\n        require(paused(), \"Contract not paused\");\n        _;\n    }\n\n    /// @notice Gets the storage slot holding the paused flag.\n    function _pausedSlot() private pure returns (StorageSlot.BooleanSlot storage) {\n        return StorageSlot.getBooleanSlot(SLOT_PAUSED);\n    }\n}\n\n/// @notice A generic ManagedDripsHub proxy.\ncontract ManagedDripsHubProxy is ERC1967Proxy {\n    constructor(ManagedDripsHub hubLogic, address admin)\n        ERC1967Proxy(address(hubLogic), new bytes(0))\n    {\n        _changeAdmin(admin);\n    }\n}\n\n////// lib/radicle-drips-hub/src/ERC20DripsHub.sol\n/* pragma solidity ^0.8.7; */\n\n/* import {SplitsReceiver, DripsReceiver} from \"./DripsHub.sol\"; */\n/* import {ManagedDripsHub} from \"./ManagedDripsHub.sol\"; */\n/* import {IERC20Reserve} from \"./ERC20Reserve.sol\"; */\n/* import {IERC20} from \"openzeppelin-contracts/token/ERC20/IERC20.sol\"; */\n/* import {StorageSlot} from \"openzeppelin-contracts/utils/StorageSlot.sol\"; */\n\n/// @notice Drips hub contract for any ERC-20 token. Must be used via a proxy.\n/// See the base `DripsHub` and `ManagedDripsHub` contract docs for more details.\ncontract ERC20DripsHub is ManagedDripsHub {\n    /// @notice The ERC-1967 storage slot for the contract.\n    /// It holds a single address of the ERC-20 reserve.\n    bytes32 private constant SLOT_RESERVE =\n        bytes32(uint256(keccak256(\"eip1967.erc20DripsHub.reserve\")) - 1);\n    /// @notice The address of the ERC-20 contract which tokens the drips hub works with\n    IERC20 public immutable erc20;\n\n    /// @notice Emitted when the reserve address is set\n    event ReserveSet(IERC20Reserve oldReserve, IERC20Reserve newReserve);\n\n    /// @param cycleSecs The length of cycleSecs to be used in the contract instance.\n    /// Low value makes funds more available by shortening the average time of funds being frozen\n    /// between being taken from the users' drips balances and being collectable by their receivers.\n    /// High value makes collecting cheaper by making it process less cycles for a given time range.\n    /// @param _erc20 The address of an ERC-20 contract which tokens the drips hub will work with.\n    constructor(uint64 cycleSecs, IERC20 _erc20) ManagedDripsHub(cycleSecs) {\n        erc20 = _erc20;\n    }\n\n    /// @notice Sets the drips configuration of the `msg.sender`.\n    /// Transfers funds to or from the sender to fulfill the update of the drips balance.\n    /// The sender must first grant the contract a sufficient allowance.\n    /// @param lastUpdate The timestamp of the last drips update of the `msg.sender`.\n    /// If this is the first update, pass zero.\n    /// @param lastBalance The drips balance after the last drips update of the `msg.sender`.\n    /// If this is the first update, pass zero.\n    /// @param currReceivers The list of the drips receivers set in the last drips update\n    /// of the `msg.sender`.\n    /// If this is the first update, pass an empty array.\n    /// @param balanceDelta The drips balance change to be applied.\n    /// Positive to add funds to the drips balance, negative to remove them.\n    /// @param newReceivers The list of the drips receivers of the `msg.sender` to be set.\n    /// Must be sorted by the receivers' addresses, deduplicated and without 0 amtPerSecs.\n    /// @return newBalance The new drips balance of the `msg.sender`.\n    /// Pass it as `lastBalance` when updating that user or the account for the next time.\n    /// @return realBalanceDelta The actually applied drips balance change.\n    function setDrips(\n        uint64 lastUpdate,\n        uint128 lastBalance,\n        DripsReceiver[] memory currReceivers,\n        int128 balanceDelta,\n        DripsReceiver[] memory newReceivers\n    ) public whenNotPaused returns (uint128 newBalance, int128 realBalanceDelta) {\n        return\n            _setDrips(\n                _userOrAccount(msg.sender),\n                lastUpdate,\n                lastBalance,\n                currReceivers,\n                balanceDelta,\n                newReceivers\n            );\n    }\n\n    /// @notice Sets the drips configuration of an account of the `msg.sender`.\n    /// See `setDrips` for more details\n    /// @param account The account\n    function setDrips(\n        uint256 account,\n        uint64 lastUpdate,\n        uint128 lastBalance,\n        DripsReceiver[] memory currReceivers,\n        int128 balanceDelta,\n        DripsReceiver[] memory newReceivers\n    ) public whenNotPaused returns (uint128 newBalance, int128 realBalanceDelta) {\n        return\n            _setDrips(\n                _userOrAccount(msg.sender, account),\n                lastUpdate,\n                lastBalance,\n                currReceivers,\n                balanceDelta,\n                newReceivers\n            );\n    }\n\n    /// @notice Gives funds from the `msg.sender` to the receiver.\n    /// The receiver can collect them immediately.\n    /// Transfers the funds to be given from the sender's wallet to the drips hub contract.\n    /// @param receiver The receiver\n    /// @param amt The given amount\n    function give(address receiver, uint128 amt) public whenNotPaused {\n        _give(_userOrAccount(msg.sender), receiver, amt);\n    }\n\n    /// @notice Gives funds from the account of the `msg.sender` to the receiver.\n    /// The receiver can collect them immediately.\n    /// Transfers the funds to be given from the sender's wallet to the drips hub contract.\n    /// @param account The account\n    /// @param receiver The receiver\n    /// @param amt The given amount\n    function give(\n        uint256 account,\n        address receiver,\n        uint128 amt\n    ) public whenNotPaused {\n        _give(_userOrAccount(msg.sender, account), receiver, amt);\n    }\n\n    /// @notice Collects funds received by the `msg.sender` and sets their splits.\n    /// The collected funds are split according to `currReceivers`.\n    /// @param currReceivers The list of the user's splits receivers which is currently in use.\n    /// If this function is called for the first time for the user, should be an empty array.\n    /// @param newReceivers The new list of the user's splits receivers.\n    /// Must be sorted by the splits receivers' addresses, deduplicated and without 0 weights.\n    /// Each splits receiver will be getting `weight / TOTAL_SPLITS_WEIGHT`\n    /// share of the funds collected by the user.\n    /// @return collected The collected amount\n    /// @return split The amount split to the user's splits receivers\n    function setSplits(SplitsReceiver[] memory currReceivers, SplitsReceiver[] memory newReceivers)\n        public\n        whenNotPaused\n        returns (uint128 collected, uint128 split)\n    {\n        return _setSplits(msg.sender, currReceivers, newReceivers);\n    }\n\n    /// @notice Gets the the reserve where funds are stored.\n    function reserve() public view returns (IERC20Reserve) {\n        return IERC20Reserve(_reserveSlot().value);\n    }\n\n    /// @notice Set the new reserve address to store funds.\n    /// @param newReserve The new reserve.\n    function setReserve(IERC20Reserve newReserve) public onlyAdmin {\n        require(newReserve.erc20() == erc20, \"Invalid reserve ERC-20 address\");\n        IERC20Reserve oldReserve = reserve();\n        if (address(oldReserve) != address(0)) erc20.approve(address(oldReserve), 0);\n        _reserveSlot().value = address(newReserve);\n        erc20.approve(address(newReserve), type(uint256).max);\n        emit ReserveSet(oldReserve, newReserve);\n    }\n\n    function _reserveSlot() private pure returns (StorageSlot.AddressSlot storage) {\n        return StorageSlot.getAddressSlot(SLOT_RESERVE);\n    }\n\n    function _transfer(address user, int128 amt) internal override {\n        IERC20Reserve erc20Reserve = reserve();\n        require(address(erc20Reserve) != address(0), \"Reserve unset\");\n        if (amt > 0) {\n            uint256 withdraw = uint128(amt);\n            erc20Reserve.withdraw(withdraw);\n            erc20.transfer(user, withdraw);\n        } else if (amt < 0) {\n            uint256 deposit = uint128(-amt);\n            erc20.transferFrom(user, address(this), deposit);\n            erc20Reserve.deposit(deposit);\n        }\n    }\n}\n\n////// lib/radicle-drips-hub/src/DaiDripsHub.sol\n/* pragma solidity ^0.8.7; */\n\n/* import {ERC20DripsHub, DripsReceiver, SplitsReceiver} from \"./ERC20DripsHub.sol\"; */\n/* import {IDai} from \"./Dai.sol\"; */\n/* import {IDaiReserve} from \"./DaiReserve.sol\"; */\n\nstruct PermitArgs {\n    uint256 nonce;\n    uint256 expiry;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\n/// @notice Drips hub contract for DAI token. Must be used via a proxy.\n/// See the base `DripsHub` contract docs for more details.\ncontract DaiDripsHub is ERC20DripsHub {\n    /// @notice The address of the Dai contract which tokens the drips hub works with.\n    /// Always equal to `erc20`, but more strictly typed.\n    IDai public immutable dai;\n\n    /// @notice See `ERC20DripsHub` constructor documentation for more details.\n    constructor(uint64 cycleSecs, IDai _dai) ERC20DripsHub(cycleSecs, _dai) {\n        dai = _dai;\n    }\n\n    /// @notice Sets the drips configuration of the `msg.sender`\n    /// and permits spending their Dai by the drips hub.\n    /// This function is an extension of `setDrips`, see its documentation for more details.\n    ///\n    /// The user must sign a Dai permission document allowing the drips hub to spend their funds.\n    /// These parameters will be passed to the Dai contract by this function.\n    /// @param permitArgs The Dai permission arguments.\n    function setDripsAndPermit(\n        uint64 lastUpdate,\n        uint128 lastBalance,\n        DripsReceiver[] memory currReceivers,\n        int128 balanceDelta,\n        DripsReceiver[] memory newReceivers,\n        PermitArgs calldata permitArgs\n    ) public whenNotPaused returns (uint128 newBalance, int128 realBalanceDelta) {\n        _permit(permitArgs);\n        return setDrips(lastUpdate, lastBalance, currReceivers, balanceDelta, newReceivers);\n    }\n\n    /// @notice Sets the drips configuration of an account of the `msg.sender`\n    /// and permits spending their Dai by the drips hub.\n    /// This function is an extension of `setDrips`, see its documentation for more details.\n    ///\n    /// The user must sign a Dai permission document allowing the drips hub to spend their funds.\n    /// These parameters will be passed to the Dai contract by this function.\n    /// @param permitArgs The Dai permission arguments.\n    function setDripsAndPermit(\n        uint256 account,\n        uint64 lastUpdate,\n        uint128 lastBalance,\n        DripsReceiver[] memory currReceivers,\n        int128 balanceDelta,\n        DripsReceiver[] memory newReceivers,\n        PermitArgs calldata permitArgs\n    ) public whenNotPaused returns (uint128 newBalance, int128 realBalanceDelta) {\n        _permit(permitArgs);\n        return\n            setDrips(account, lastUpdate, lastBalance, currReceivers, balanceDelta, newReceivers);\n    }\n\n    /// @notice Gives funds from the `msg.sender` to the receiver\n    /// and permits spending sender's Dai by the drips hub.\n    /// This function is an extension of `give`, see its documentation for more details.\n    ///\n    /// The user must sign a Dai permission document allowing the drips hub to spend their funds.\n    /// These parameters will be passed to the Dai contract by this function.\n    /// @param permitArgs The Dai permission arguments.\n    function giveAndPermit(\n        address receiver,\n        uint128 amt,\n        PermitArgs calldata permitArgs\n    ) public whenNotPaused {\n        _permit(permitArgs);\n        give(receiver, amt);\n    }\n\n    /// @notice Gives funds from the account of the `msg.sender` to the receiver\n    /// and permits spending sender's Dai by the drips hub.\n    /// This function is an extension of `give` see its documentation for more details.\n    ///\n    /// The user must sign a Dai permission document allowing the drips hub to spend their funds.\n    /// These parameters will be passed to the Dai contract by this function.\n    /// @param permitArgs The Dai permission arguments.\n    function giveAndPermit(\n        uint256 account,\n        address receiver,\n        uint128 amt,\n        PermitArgs calldata permitArgs\n    ) public whenNotPaused {\n        _permit(permitArgs);\n        give(account, receiver, amt);\n    }\n\n    /// @notice Permits the drips hub to spend the message sender's Dai.\n    /// @param permitArgs The Dai permission arguments.\n    function _permit(PermitArgs calldata permitArgs) internal {\n        dai.permit(\n            msg.sender,\n            address(this),\n            permitArgs.nonce,\n            permitArgs.expiry,\n            true,\n            permitArgs.v,\n            permitArgs.r,\n            permitArgs.s\n        );\n    }\n}\n\n////// src/builder/interface.sol\n/* pragma solidity ^0.8.7; */\n\ninterface IBuilder {\n    function buildMetaData(\n        string memory projectName,\n        uint128 tokenId,\n        uint128 nftType,\n        bool streaming,\n        uint128 amtPerCycle,\n        bool active\n    ) external view returns (string memory);\n\n    function buildMetaData(\n        string memory projectName,\n        uint128 tokenId,\n        uint128 nftType,\n        bool streaming,\n        uint128 amtPerCycle,\n        bool active,\n        string memory ipfsHash\n    ) external view returns (string memory);\n}\n\n////// src/token.sol\n/* pragma solidity ^0.8.7; */\n\n/* import {ERC721} from \"openzeppelin-contracts/token/ERC721/ERC721.sol\"; */\n/* import {IERC20} from \"openzeppelin-contracts/token/ERC20/IERC20.sol\"; */\n/* import {Ownable} from \"openzeppelin-contracts/access/Ownable.sol\"; */\n/* import {DaiDripsHub, DripsReceiver, IDai, SplitsReceiver} from \"drips-hub/DaiDripsHub.sol\"; */\n/* import {IBuilder} from \"./builder/interface.sol\"; */\n\nstruct InputType {\n    uint128 nftTypeId;\n    uint64 limit;\n    // minimum amtPerSecond or minGiveAmt\n    uint128 minAmt;\n    bool streaming;\n    string ipfsHash;\n}\n\ninterface IDripsToken {\n    function init(\n        string calldata name_,\n        string calldata symbol_,\n        address owner,\n        string calldata contractURI_,\n        InputType[] memory inputTypes,\n        IBuilder builder_,\n        SplitsReceiver[] memory splits\n    ) external;\n}\n\ncontract DripsToken is ERC721, Ownable, IDripsToken {\n    address public immutable deployer;\n    DaiDripsHub public immutable hub;\n    IDai public immutable dai;\n    uint64 public immutable cycleSecs;\n    IBuilder public builder;\n\n    string internal _name;\n    string internal _symbol;\n    string public contractURI;\n    bool public initialized;\n\n    struct Type {\n        uint64 limit;\n        uint64 minted;\n        uint128 minAmt;\n        bool streaming;\n        string ipfsHash;\n    }\n\n    struct Token {\n        uint64 timeMinted;\n        // amtPerSec if the Token is streaming otherwise the amt given at mint\n        uint128 amt;\n        uint128 lastBalance;\n        uint64 lastUpdate;\n    }\n\n    mapping(uint128 => Type) public nftTypes;\n    mapping(uint256 => Token) public nfts;\n\n    // events\n    event NewType(\n        uint128 indexed nftType,\n        uint64 limit,\n        uint128 minAmt,\n        bool streaming,\n        string ipfsHash\n    );\n    event NewStreamingToken(\n        uint256 indexed tokenId,\n        address indexed receiver,\n        uint128 indexed typeId,\n        uint128 topUp,\n        uint128 amtPerSec\n    );\n    event NewToken(\n        uint256 indexed tokenId,\n        address indexed receiver,\n        uint128 indexed typeId,\n        uint128 giveAmt\n    );\n\n    event NewContractURI(string contractURI);\n    event NewBuilder(IBuilder builder);\n    event SplitsUpdated(SplitsReceiver[] splits);\n\n    constructor(DaiDripsHub hub_, address deployer_) ERC721(\"\", \"\") {\n        deployer = deployer_;\n        hub = hub_;\n        dai = hub_.dai();\n        cycleSecs = hub_.cycleSecs();\n    }\n\n    modifier onlyTokenHolder(uint256 tokenId) {\n        require(ownerOf(tokenId) == msg.sender, \"not-nft-owner\");\n        _;\n    }\n\n    function init(\n        string calldata name_,\n        string calldata symbol_,\n        address owner,\n        string calldata contractURI_,\n        InputType[] memory inputTypes,\n        IBuilder builder_,\n        SplitsReceiver[] memory splits\n    ) public override {\n        require(!initialized, \"already-initialized\");\n        initialized = true;\n        require(msg.sender == deployer, \"not-deployer\");\n        require(owner != address(0), \"owner-address-is-zero\");\n        _name = name_;\n        _symbol = symbol_;\n        _changeBuilder(builder_);\n        _addTypes(inputTypes);\n        _changeContractURI(contractURI_);\n        _transferOwnership(owner);\n        if (splits.length > 0) {\n            _changeSplitsReceivers(new SplitsReceiver[](0), splits);\n        }\n        dai.approve(address(hub), type(uint256).max);\n    }\n\n    function changeContractURI(string calldata contractURI_) public onlyOwner {\n        _changeContractURI(contractURI_);\n    }\n\n    function _changeContractURI(string calldata contractURI_) internal {\n        contractURI = contractURI_;\n        emit NewContractURI(contractURI_);\n    }\n\n    function _changeBuilder(IBuilder newBuilder) internal {\n        builder = newBuilder;\n        emit NewBuilder(newBuilder);\n    }\n\n    function addTypes(InputType[] memory inputTypes) public onlyOwner {\n        _addTypes(inputTypes);\n    }\n\n    function _addTypes(InputType[] memory inputTypes) internal {\n        for (uint256 i = 0; i < inputTypes.length; i++) {\n            _addType(\n                inputTypes[i].nftTypeId,\n                inputTypes[i].limit,\n                inputTypes[i].minAmt,\n                inputTypes[i].ipfsHash,\n                inputTypes[i].streaming\n            );\n        }\n    }\n\n    function addStreamingType(\n        uint128 newTypeId,\n        uint64 limit,\n        uint128 minAmtPerSec,\n        string memory ipfsHash\n    ) public onlyOwner {\n        _addType(newTypeId, limit, minAmtPerSec, ipfsHash, true);\n    }\n\n    function addType(\n        uint128 newTypeId,\n        uint64 limit,\n        uint128 minGiveAmt,\n        string memory ipfsHash\n    ) public onlyOwner {\n        _addType(newTypeId, limit, minGiveAmt, ipfsHash, false);\n    }\n\n    function _addType(\n        uint128 newTypeId,\n        uint64 limit,\n        uint128 minAmt,\n        string memory ipfsHash,\n        bool streaming_\n    ) internal {\n        require(nftTypes[newTypeId].limit == 0, \"nft-type-already-exists\");\n        require(limit > 0, \"zero-limit-not-allowed\");\n\n        nftTypes[newTypeId].minAmt = minAmt;\n        nftTypes[newTypeId].limit = limit;\n        nftTypes[newTypeId].ipfsHash = ipfsHash;\n        nftTypes[newTypeId].streaming = streaming_;\n        emit NewType(newTypeId, limit, minAmt, streaming_, ipfsHash);\n    }\n\n    function createTokenId(uint128 id, uint128 nftType) public pure returns (uint256 tokenId) {\n        return uint256((uint256(nftType) << 128)) | id;\n    }\n\n    function tokenType(uint256 tokenId) public pure returns (uint128 nftType) {\n        return uint128(tokenId >> 128);\n    }\n\n    function mintStreaming(\n        address nftReceiver,\n        uint128 typeId,\n        uint128 topUpAmt,\n        uint128 amtPerSec,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        dai.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n        return mintStreaming(nftReceiver, typeId, topUpAmt, amtPerSec);\n    }\n\n    function mint(\n        address nftReceiver,\n        uint128 typeId,\n        uint128 amtGive,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        dai.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n        return mint(nftReceiver, typeId, amtGive);\n    }\n\n    function mint(\n        address nftReceiver,\n        uint128 typeId,\n        uint128 giveAmt\n    ) public returns (uint256 newTokenId) {\n        require(giveAmt >= nftTypes[typeId].minAmt, \"giveAmt-too-low\");\n        require(nftTypes[typeId].streaming == false, \"type-is-streaming\");\n        newTokenId = _mintInternal(nftReceiver, typeId, giveAmt);\n        // one time give instead of streaming\n        hub.give(newTokenId, address(this), giveAmt);\n        nfts[newTokenId].amt = giveAmt;\n        emit NewToken(newTokenId, nftReceiver, typeId, giveAmt);\n    }\n\n    function authMint(\n        address nftReceiver,\n        uint128 typeId,\n        uint128 value\n    ) public onlyOwner returns (uint256 newTokenId) {\n        require(nftTypes[typeId].streaming == false, \"type-is-streaming\");\n        newTokenId = _mintInternal(nftReceiver, typeId, 0);\n        // amt is needed for influence\n        nfts[newTokenId].amt = value;\n        emit NewToken(newTokenId, nftReceiver, typeId, 0);\n    }\n\n    function _mintInternal(\n        address nftReceiver,\n        uint128 typeId,\n        uint128 topUpAmt\n    ) internal returns (uint256 newTokenId) {\n        require(nftTypes[typeId].minted++ < nftTypes[typeId].limit, \"nft-type-reached-limit\");\n        newTokenId = createTokenId(nftTypes[typeId].minted, typeId);\n        _mint(nftReceiver, newTokenId);\n        nfts[newTokenId].timeMinted = uint64(block.timestamp);\n        // transfer currency to Token registry\n        if (topUpAmt > 0) dai.transferFrom(nftReceiver, address(this), topUpAmt);\n    }\n\n    function mintStreaming(\n        address nftReceiver,\n        uint128 typeId,\n        uint128 topUpAmt,\n        uint128 amtPerSec\n    ) public returns (uint256 newTokenId) {\n        require(amtPerSec >= nftTypes[typeId].minAmt, \"amt-per-sec-too-low\");\n        require(nftTypes[typeId].streaming, \"nft-type-not-streaming\");\n        require(topUpAmt >= amtPerSec * cycleSecs, \"toUp-too-low\");\n\n        newTokenId = _mintInternal(nftReceiver, typeId, topUpAmt);\n        // start streaming\n        hub.setDrips(newTokenId, 0, 0, _receivers(0), int128(topUpAmt), _receivers(amtPerSec));\n        nfts[newTokenId].amt = amtPerSec;\n        nfts[newTokenId].lastUpdate = uint64(block.timestamp);\n        nfts[newTokenId].lastBalance = topUpAmt;\n        emit NewStreamingToken(newTokenId, nftReceiver, typeId, topUpAmt, amtPerSec);\n    }\n\n    function collect(SplitsReceiver[] calldata currSplits)\n        public\n        onlyOwner\n        returns (uint128 collected, uint128 split)\n    {\n        (, split) = hub.collect(address(this), currSplits);\n        collected = uint128(dai.balanceOf(address(this)));\n        dai.transfer(owner(), collected);\n    }\n\n    function collectable(SplitsReceiver[] calldata currSplits)\n        public\n        view\n        returns (uint128 toCollect, uint128 toSplit)\n    {\n        (toCollect, toSplit) = hub.collectable(address(this), currSplits);\n        toCollect += uint128(dai.balanceOf(address(this)));\n    }\n\n    function topUp(\n        uint256 tokenId,\n        uint128 topUpAmt,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        dai.permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\n        topUp(tokenId, topUpAmt);\n    }\n\n    function topUp(uint256 tokenId, uint128 topUpAmt) public onlyTokenHolder(tokenId) {\n        require(nftTypes[tokenType(tokenId)].streaming, \"not-a-streaming-nft\");\n        dai.transferFrom(msg.sender, address(this), topUpAmt);\n        DripsReceiver[] memory receivers = _tokenReceivers(tokenId);\n        (uint128 newBalance, ) = hub.setDrips(\n            tokenId,\n            nfts[tokenId].lastUpdate,\n            nfts[tokenId].lastBalance,\n            receivers,\n            int128(topUpAmt),\n            receivers\n        );\n        nfts[tokenId].lastUpdate = uint64(block.timestamp);\n        nfts[tokenId].lastBalance = newBalance;\n    }\n\n    function withdraw(uint256 tokenId, uint128 withdrawAmt)\n        public\n        onlyTokenHolder(tokenId)\n        returns (uint128 withdrawn)\n    {\n        uint128 withdrawableAmt = withdrawable(tokenId);\n        if (withdrawAmt > withdrawableAmt) {\n            withdrawAmt = withdrawableAmt;\n        }\n        DripsReceiver[] memory receivers = _tokenReceivers(tokenId);\n        (uint128 newBalance, int128 realBalanceDelta) = hub.setDrips(\n            tokenId,\n            nfts[tokenId].lastUpdate,\n            nfts[tokenId].lastBalance,\n            receivers,\n            -int128(withdrawAmt),\n            receivers\n        );\n        nfts[tokenId].lastUpdate = uint64(block.timestamp);\n        nfts[tokenId].lastBalance = newBalance;\n        withdrawn = uint128(-realBalanceDelta);\n        dai.transfer(msg.sender, withdrawn);\n    }\n\n    function changeSplitsReceivers(\n        SplitsReceiver[] memory currSplits,\n        SplitsReceiver[] memory newSplits\n    ) public onlyOwner {\n        _changeSplitsReceivers(currSplits, newSplits);\n    }\n\n    function _changeSplitsReceivers(\n        SplitsReceiver[] memory currSplits,\n        SplitsReceiver[] memory newSplits\n    ) internal {\n        hub.setSplits(currSplits, newSplits);\n        emit SplitsUpdated(newSplits);\n    }\n\n    function withdrawable(uint256 tokenId) public view returns (uint128) {\n        require(_exists(tokenId), \"nonexistent-token\");\n        if (nftTypes[tokenType(tokenId)].streaming == false) return 0;\n        Token storage nft = nfts[tokenId];\n        uint64 spentUntil = uint64(block.timestamp);\n        uint64 minSpentUntil = nft.timeMinted + cycleSecs;\n        if (spentUntil < minSpentUntil) spentUntil = minSpentUntil;\n        uint192 spent = (spentUntil - nft.lastUpdate) * uint192(nft.amt);\n        if (nft.lastBalance < spent) return nft.lastBalance % nft.amt;\n        return nft.lastBalance - uint128(spent);\n    }\n\n    function activeUntil(uint256 tokenId) public view returns (uint128) {\n        require(_exists(tokenId), \"nonexistent-token\");\n        Type storage nftType = nftTypes[tokenType(tokenId)];\n        if (nftType.streaming == false || nftType.minAmt == 0) {\n            return type(uint128).max;\n        }\n        Token storage nft = nfts[tokenId];\n        return nft.lastUpdate + nft.lastBalance / nft.amt - 1;\n    }\n\n    function active(uint256 tokenId) public view returns (bool) {\n        return activeUntil(tokenId) >= block.timestamp;\n    }\n\n    function streaming(uint256 tokenId) public view returns (bool) {\n        return nftTypes[tokenType(tokenId)].streaming;\n    }\n\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function changeBuilder(IBuilder newBuilder) public onlyOwner {\n        _changeBuilder(newBuilder);\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"nonexistent-token\");\n        string memory ipfsHash = nftTypes[tokenType(tokenId)].ipfsHash;\n        uint128 amtPerCycle = nfts[tokenId].amt * cycleSecs;\n        if (bytes(ipfsHash).length == 0) {\n            return\n                builder.buildMetaData(\n                    name(),\n                    uint128(tokenId),\n                    tokenType(tokenId),\n                    nftTypes[tokenType(tokenId)].streaming,\n                    amtPerCycle,\n                    active(tokenId)\n                );\n        }\n        return\n            builder.buildMetaData(\n                name(),\n                uint128(tokenId),\n                tokenType(tokenId),\n                nftTypes[tokenType(tokenId)].streaming,\n                amtPerCycle,\n                active(tokenId),\n                ipfsHash\n            );\n    }\n\n    function currLeftSecsInCycle() public view returns (uint64) {\n        return cycleSecs - (uint64(block.timestamp) % cycleSecs);\n    }\n\n    function influence(uint256 tokenId) public view returns (uint256 influenceScore) {\n        if (active(tokenId)) {\n            if (streaming(tokenId) == false) {\n                return nfts[tokenId].amt;\n            }\n            return nfts[tokenId].amt * (block.timestamp - nfts[tokenId].timeMinted);\n        }\n        return 0;\n    }\n\n    function _tokenReceivers(uint256 tokenId)\n        internal\n        view\n        returns (DripsReceiver[] memory receivers)\n    {\n        return _receivers(nfts[tokenId].amt);\n    }\n\n    function _receivers(uint128 amtPerSec)\n        internal\n        view\n        returns (DripsReceiver[] memory receivers)\n    {\n        if (amtPerSec == 0) return new DripsReceiver[](0);\n        receivers = new DripsReceiver[](1);\n        receivers[0] = DripsReceiver(address(this), amtPerSec);\n    }\n}\n\n////// src/registry.sol\n/* pragma solidity ^0.8.7; */\n\n/* import {DripsToken, IDripsToken, InputType, SplitsReceiver} from \"./token.sol\"; */\n/* import {DaiDripsHub} from \"drips-hub/DaiDripsHub.sol\"; */\n/* import {Clones} from \"openzeppelin-contracts/proxy/Clones.sol\"; */\n/* import {IBuilder} from \"./builder/interface.sol\"; */\n/* import {Ownable} from \"openzeppelin-contracts/access/Ownable.sol\"; */\n\ncontract RadicleRegistry is Ownable {\n    IBuilder public builder;\n\n    event NewProject(\n        address dripTokenTemplate,\n        address indexed fundingToken,\n        address indexed projectOwner,\n        string name\n    );\n    event NewBuilder(IBuilder builder);\n    event NewTemplate(address template);\n\n    address public dripsTokenTemplate;\n    uint256 public nextId;\n\n    mapping(uint256 => address) public dripsToken;\n\n    constructor(IBuilder builder_, address owner) {\n        changeBuilder(builder_);\n        _transferOwnership(owner);\n    }\n\n    function changeTemplate(address newTemplate) public onlyOwner {\n        dripsTokenTemplate = newTemplate;\n        emit NewTemplate(newTemplate);\n    }\n\n    function newProject(\n        string calldata name,\n        string calldata symbol,\n        address projectOwner,\n        string calldata contractURI,\n        InputType[] calldata inputTypes,\n        SplitsReceiver[] memory splits\n    ) public returns (address fundingToken) {\n        fundingToken = Clones.cloneDeterministic(dripsTokenTemplate, bytes32(nextId));\n        IDripsToken(fundingToken).init(\n            name,\n            symbol,\n            projectOwner,\n            contractURI,\n            inputTypes,\n            builder,\n            splits\n        );\n        emit NewProject(dripsTokenTemplate, fundingToken, projectOwner, name);\n        dripsToken[nextId] = fundingToken;\n        nextId++;\n    }\n\n    function changeBuilder(IBuilder newBuilder) public onlyOwner {\n        builder = newBuilder;\n        emit NewBuilder(newBuilder);\n    }\n}\n","ABI":"[{\"inputs\":[{\"internalType\":\"contract IBuilder\",\"name\":\"builder_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IBuilder\",\"name\":\"builder\",\"type\":\"address\"}],\"name\":\"NewBuilder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dripTokenTemplate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fundingToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"projectOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NewProject\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"template\",\"type\":\"address\"}],\"name\":\"NewTemplate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"builder\",\"outputs\":[{\"internalType\":\"contract IBuilder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBuilder\",\"name\":\"newBuilder\",\"type\":\"address\"}],\"name\":\"changeBuilder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTemplate\",\"type\":\"address\"}],\"name\":\"changeTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dripsToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dripsTokenTemplate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"projectOwner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint128\",\"name\":\"nftTypeId\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"limit\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"minAmt\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"streaming\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"}],\"internalType\":\"struct InputType[]\",\"name\":\"inputTypes\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"weight\",\"type\":\"uint32\"}],\"internalType\":\"struct SplitsReceiver[]\",\"name\":\"splits\",\"type\":\"tuple[]\"}],\"name\":\"newProject\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"fundingToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RadicleRegistry","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000058be54b173e324f80ec03672ec14c4d079b82ac000000000000000000000000abadefe1ce7bb6f1d5146f3f476701f791b18c6c","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}