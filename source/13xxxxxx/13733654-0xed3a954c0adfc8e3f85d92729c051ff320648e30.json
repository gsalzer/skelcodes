{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/multiply/GuniMultiplyProxyActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity >=0.7.6;\\npragma abicoder v2;\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"./ExchangeData.sol\\\";\\nimport \\\"../utils/SafeMath.sol\\\";\\nimport \\\"../interfaces/mcd/IJoin.sol\\\";\\nimport \\\"../interfaces/mcd/IManager.sol\\\";\\nimport \\\"../interfaces/mcd/IVat.sol\\\";\\nimport \\\"../interfaces/mcd/IJug.sol\\\";\\nimport \\\"../interfaces/mcd/IDaiJoin.sol\\\";\\nimport \\\"../interfaces/misc/IUniPool.sol\\\";\\nimport \\\"../interfaces/misc/IGUNIRouter.sol\\\";\\nimport \\\"../interfaces/misc/IGUNIResolver.sol\\\";\\nimport \\\"../interfaces/misc/IGUNIToken.sol\\\";\\nimport \\\"../interfaces/exchange/IExchange.sol\\\";\\nimport \\\"./../flashMint/interface/IERC3156FlashBorrower.sol\\\";\\nimport \\\"./../flashMint/interface/IERC3156FlashLender.sol\\\";\\n\\nstruct CdpData {\\n  address gemJoin;\\n  address payable fundsReceiver;\\n  uint256 cdpId;\\n  bytes32 ilk;\\n  uint256 requiredDebt;\\n  uint256 token0Amount;\\n  string methodName;\\n}\\n\\nstruct GuniAddressRegistry {\\n  address guni;\\n  address router;\\n  address resolver;\\n  address guniProxyActions;\\n  address otherToken;\\n  address exchange;\\n  address jug;\\n  address manager;\\n  address lender;\\n}\\n\\ncontract GuniMultiplyProxyActions is IERC3156FlashBorrower {\\n  using SafeMath for uint256;\\n  uint256 constant RAY = 10**27;\\n  address public constant DAIJOIN = 0x9759A6Ac90977b93B58547b4A71c78317f391A28;\\n  address public constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n  IERC20 public constant daiContract = IERC20(DAI);\\n\\n  modifier logMethodName(\\n    string memory name,\\n    CdpData memory data,\\n    address destination\\n  ) {\\n    if (bytes(data.methodName).length == 0) {\\n      data.methodName = name;\\n    }\\n    _;\\n    data.methodName = \\\"\\\";\\n  }\\n\\n  function openMultiplyGuniVault(\\n    ExchangeData calldata exchangeData,\\n    CdpData memory cdpData,\\n    GuniAddressRegistry calldata guniAddressRegistry\\n  ) public logMethodName(\\\"openMultiplyGuniVault\\\", cdpData, guniAddressRegistry.guniProxyActions) {\\n    cdpData.ilk = IJoin(cdpData.gemJoin).ilk();\\n    cdpData.cdpId = IManager(guniAddressRegistry.manager).open(cdpData.ilk, address(this));\\n\\n    increaseMultipleGuni(exchangeData, cdpData, guniAddressRegistry);\\n  }\\n\\n  function increaseMultipleGuni(\\n    ExchangeData calldata exchangeData,\\n    CdpData memory cdpData,\\n    GuniAddressRegistry calldata guniAddressRegistry\\n  ) public logMethodName(\\\"increaseMultipleGuni\\\", cdpData, guniAddressRegistry.guniProxyActions) {\\n    daiContract.transferFrom(\\n      msg.sender,\\n      guniAddressRegistry.guniProxyActions,\\n      cdpData.token0Amount\\n    );\\n    takeAFlashLoan(exchangeData, cdpData, guniAddressRegistry, 1);\\n  }\\n\\n  function closeGuniVaultExitDai(\\n    ExchangeData calldata exchangeData,\\n    CdpData memory cdpData,\\n    GuniAddressRegistry calldata guniAddressRegistry\\n  ) public logMethodName(\\\"closeGuniVaultExitDai\\\", cdpData, guniAddressRegistry.guniProxyActions) {\\n    cdpData.ilk = IJoin(cdpData.gemJoin).ilk();\\n\\n    address urn = IManager(guniAddressRegistry.manager).urns(cdpData.cdpId);\\n    address vat = IManager(guniAddressRegistry.manager).vat();\\n\\n    uint256 wadD = _getWipeAllWad(vat, urn, urn, cdpData.ilk);\\n    cdpData.requiredDebt = wadD;\\n\\n    takeAFlashLoan(exchangeData, cdpData, guniAddressRegistry, 0);\\n  }\\n\\n  function takeAFlashLoan(\\n    ExchangeData calldata exchangeData,\\n    CdpData memory cdpData,\\n    GuniAddressRegistry calldata guniAddressRegistry,\\n    uint256 action\\n  ) internal {\\n    bytes memory paramsData = abi.encode(action, exchangeData, cdpData, guniAddressRegistry);\\n\\n    IManager(guniAddressRegistry.manager).cdpAllow(\\n      cdpData.cdpId,\\n      guniAddressRegistry.guniProxyActions,\\n      1\\n    );\\n\\n    IERC3156FlashLender(guniAddressRegistry.lender).flashLoan(\\n      IERC3156FlashBorrower(guniAddressRegistry.guniProxyActions),\\n      DAI,\\n      cdpData.requiredDebt,\\n      paramsData\\n    );\\n\\n    IManager(guniAddressRegistry.manager).cdpAllow(\\n      cdpData.cdpId,\\n      guniAddressRegistry.guniProxyActions,\\n      0\\n    );\\n  }\\n\\n  function _increaseMPGuni(\\n    ExchangeData memory exchangeData,\\n    CdpData memory cdpData,\\n    GuniAddressRegistry memory guniAddressRegistry,\\n    uint256 borrowedDaiAmount\\n  ) internal {\\n    IGUNIToken guni = IGUNIToken(guniAddressRegistry.guni);\\n    IERC20 otherToken = IERC20(guniAddressRegistry.otherToken);\\n\\n    uint256 bal0 = daiContract.balanceOf(address(this));\\n\\n    {\\n      IExchange exchange = IExchange(guniAddressRegistry.exchange);\\n\\n      daiContract.approve(address(exchange), exchangeData.fromTokenAmount);\\n\\n      exchange.swapDaiForToken(\\n        exchangeData.toTokenAddress,\\n        exchangeData.fromTokenAmount,\\n        exchangeData.minToTokenAmount,\\n        exchangeData.exchangeAddress,\\n        exchangeData._exchangeCalldata\\n      );\\n    }\\n\\n    uint256 guniBalance;\\n    uint256 bal1 = otherToken.balanceOf(address(this));\\n    bal0 = daiContract.balanceOf(address(this));\\n\\n    {\\n      IGUNIRouter router = IGUNIRouter(guniAddressRegistry.router);\\n      daiContract.approve(address(router), bal0);\\n      otherToken.approve(address(router), bal1);\\n\\n      (, , guniBalance) = router.addLiquidity(address(guni), bal0, bal1, 0, 0, address(this));\\n    }\\n\\n    guni.approve(guniAddressRegistry.guniProxyActions, guniBalance);\\n    joinDrawDebt(\\n      cdpData,\\n      borrowedDaiAmount.sub(IERC20(DAI).balanceOf(address(this))),\\n      guniAddressRegistry.manager,\\n      guniAddressRegistry.jug\\n    );\\n\\n    uint256 daiLeft = IERC20(DAI).balanceOf(address(this)).sub(borrowedDaiAmount);\\n    uint256 otherTokenLeft = otherToken.balanceOf(address(this));\\n\\n    emit MultipleActionCalled(\\n      cdpData.methodName,\\n      cdpData.cdpId,\\n      exchangeData.minToTokenAmount,\\n      exchangeData.toTokenAmount,\\n      0,\\n      daiLeft\\n    );\\n\\n    if (daiLeft > 0) {\\n      IERC20(DAI).transfer(cdpData.fundsReceiver, daiLeft);\\n    }\\n    if (otherTokenLeft > 0) {\\n      otherToken.transfer(cdpData.fundsReceiver, otherTokenLeft);\\n    }\\n  }\\n\\n  function _closeToDaiMPGuni(\\n    ExchangeData memory exchangeData,\\n    CdpData memory cdpData,\\n    GuniAddressRegistry memory guniAddressRegistry,\\n    uint256 borrowedDaiAmount\\n  ) internal {\\n    IExchange exchange = IExchange(guniAddressRegistry.exchange);\\n    IERC20 otherToken = IERC20(guniAddressRegistry.otherToken);\\n    uint256 ink = getInk(guniAddressRegistry.manager, cdpData);\\n\\n    wipeAndFreeGem(\\n      guniAddressRegistry.manager,\\n      cdpData.gemJoin,\\n      cdpData.cdpId,\\n      cdpData.requiredDebt,\\n      ink\\n    );\\n\\n    IGUNIToken guni = IGUNIToken(guniAddressRegistry.guni);\\n\\n    uint256 guniBalance = guni.balanceOf(address(this));\\n\\n    {\\n      IGUNIRouter router = IGUNIRouter(guniAddressRegistry.router);\\n      guni.approve(address(router), guniBalance);\\n      router.removeLiquidity(address(guni), guniBalance, 0, 0, address(this));\\n    }\\n\\n    otherToken.approve(address(exchange), otherToken.balanceOf(address(this)));\\n    exchange.swapTokenForDai(\\n      exchangeData.toTokenAddress,\\n      otherToken.balanceOf(address(this)),\\n      exchangeData.minToTokenAmount,\\n      exchangeData.exchangeAddress,\\n      exchangeData._exchangeCalldata\\n    );\\n\\n    uint256 daiLeft = IERC20(DAI).balanceOf(address(this)).sub(borrowedDaiAmount);\\n    uint256 otherTokenLeft = otherToken.balanceOf(address(this));\\n\\n    emit MultipleActionCalled(\\n      cdpData.methodName,\\n      cdpData.cdpId,\\n      exchangeData.minToTokenAmount,\\n      exchangeData.toTokenAmount,\\n      0,\\n      daiLeft\\n    );\\n\\n    if (daiLeft > 0) {\\n      IERC20(DAI).transfer(cdpData.fundsReceiver, daiLeft);\\n    }\\n    if (otherTokenLeft > 0) {\\n      otherToken.transfer(cdpData.fundsReceiver, otherTokenLeft);\\n    }\\n  }\\n\\n  function onFlashLoan(\\n    address initiator,\\n    address token,\\n    uint256 amount,\\n    uint256 fee,\\n    bytes calldata params\\n  ) public override returns (bytes32) {\\n    (\\n      uint256 mode,\\n      ExchangeData memory exchangeData,\\n      CdpData memory cdpData,\\n      GuniAddressRegistry memory guniAddressRegistry\\n    ) = abi.decode(params, (uint256, ExchangeData, CdpData, GuniAddressRegistry));\\n\\n    require(msg.sender == address(guniAddressRegistry.lender), \\\"mpa-untrusted-lender\\\");\\n    uint256 borrowedDaiAmount;\\n    {\\n      borrowedDaiAmount = amount.add(fee);\\n    }\\n    emit FLData(IERC20(DAI).balanceOf(address(this)).sub(cdpData.token0Amount), borrowedDaiAmount);\\n\\n    require(\\n      cdpData.requiredDebt.add(cdpData.token0Amount) <= IERC20(DAI).balanceOf(address(this)),\\n      \\\"mpa-receive-requested-amount-mismatch\\\"\\n    );\\n\\n    if (mode == 1) {\\n      _increaseMPGuni(exchangeData, cdpData, guniAddressRegistry, borrowedDaiAmount);\\n    }\\n    if (mode == 0) {\\n      _closeToDaiMPGuni(exchangeData, cdpData, guniAddressRegistry, borrowedDaiAmount);\\n    }\\n\\n    IERC20(token).approve(guniAddressRegistry.lender, borrowedDaiAmount);\\n\\n    return keccak256(\\\"ERC3156FlashBorrower.onFlashLoan\\\");\\n  }\\n\\n  function getOtherTokenAmount(\\n    IGUNIToken guni,\\n    IGUNIResolver resolver,\\n    uint256 bal0,\\n    uint256 otherTokenDecimals\\n  ) public view returns (uint256 amount) {\\n    (uint256 sqrtPriceX96, , , , , , ) = IUniPool(guni.pool()).slot0();\\n\\n    uint256 otherTokenTo18Conv = 10**(18 - otherTokenDecimals);\\n\\n    (, amount) = resolver.getRebalanceParams(\\n      address(guni),\\n      guni.token0() == DAI ? bal0 : 0,\\n      guni.token1() == DAI ? bal0 : 0,\\n      ((((sqrtPriceX96 * sqrtPriceX96) >> 96) * 1e18) >> 96) * otherTokenTo18Conv\\n    );\\n  }\\n\\n  function getInk(address manager, CdpData memory cdpData) internal view returns (uint256) {\\n    address urn = IManager(manager).urns(cdpData.cdpId);\\n    address vat = IManager(manager).vat();\\n\\n    (uint256 ink, ) = IVat(vat).urns(cdpData.ilk, urn);\\n    return ink;\\n  }\\n\\n  function wipeAndFreeGem(\\n    address manager,\\n    address gemJoin,\\n    uint256 cdp,\\n    uint256 borrowedDai,\\n    uint256 collateralDraw\\n  ) internal {\\n    address vat = IManager(manager).vat();\\n    address urn = IManager(manager).urns(cdp);\\n    bytes32 ilk = IManager(manager).ilks(cdp);\\n\\n    IERC20(DAI).approve(DAIJOIN, borrowedDai);\\n    IDaiJoin(DAIJOIN).join(urn, borrowedDai);\\n\\n    uint256 wadC = convertTo18(gemJoin, collateralDraw);\\n\\n    IManager(manager).frob(cdp, -toInt256(wadC), _getWipeDart(vat, IVat(vat).dai(urn), urn, ilk));\\n\\n    IManager(manager).flux(cdp, address(this), wadC);\\n    IJoin(gemJoin).exit(address(this), collateralDraw);\\n  }\\n\\n  function convertTo18(address gemJoin, uint256 amt) internal returns (uint256 wad) {\\n    // For those collaterals that have less than 18 decimals precision we need to do the conversion before passing to frob function\\n    // Adapters will automatically handle the difference of precision\\n    wad = amt.mul(10**(18 - IJoin(gemJoin).dec()));\\n  }\\n\\n  function _getWipeDart(\\n    address vat,\\n    uint256 dai,\\n    address urn,\\n    bytes32 ilk\\n  ) internal view returns (int256 dart) {\\n    // Gets actual rate from the vat\\n    (, uint256 rate, , , ) = IVat(vat).ilks(ilk);\\n    // Gets actual art value of the urn\\n    (, uint256 art) = IVat(vat).urns(ilk, urn);\\n\\n    // Uses the whole dai balance in the vat to reduce the debt\\n    dart = toInt256(dai / rate);\\n    // Checks the calculated dart is not higher than urn.art (total debt), otherwise uses its value\\n    dart = uint256(dart) <= art ? -dart : -toInt256(art);\\n  }\\n\\n  function joinDrawDebt(\\n    CdpData memory cdpData,\\n    uint256 borrowedDai,\\n    address manager,\\n    address jug\\n  ) private {\\n    IGem gem = IJoin(cdpData.gemJoin).gem();\\n\\n    uint256 balance = IERC20(address(gem)).balanceOf(address(this));\\n    gem.approve(address(cdpData.gemJoin), balance);\\n\\n    address urn = IManager(manager).urns(cdpData.cdpId);\\n    address vat = IManager(manager).vat();\\n\\n    IJoin(cdpData.gemJoin).join(urn, balance);\\n\\n    IManager(manager).frob(\\n      cdpData.cdpId,\\n      toInt256(convertTo18(cdpData.gemJoin, balance)),\\n      _getDrawDart(vat, jug, urn, cdpData.ilk, borrowedDai)\\n    );\\n    IManager(manager).move(cdpData.cdpId, address(this), borrowedDai.mul(RAY));\\n\\n    IVat(vat).hope(DAIJOIN);\\n\\n    IJoin(DAIJOIN).exit(address(this), borrowedDai);\\n  }\\n\\n  function _getDrawDart(\\n    address vat,\\n    address jug,\\n    address urn,\\n    bytes32 ilk,\\n    uint256 wad\\n  ) internal returns (int256 dart) {\\n    // Updates stability fee rate\\n    uint256 rate = IJug(jug).drip(ilk);\\n\\n    // Gets DAI balance of the urn in the vat\\n    uint256 dai = IVat(vat).dai(urn);\\n\\n    // If there was already enough DAI in the vat balance, just exits it without adding more debt\\n    if (dai < wad.mul(RAY)) {\\n      // Calculates the needed dart so together with the existing dai in the vat is enough to exit wad amount of DAI tokens\\n      dart = toInt256(wad.mul(RAY).sub(dai) / rate);\\n      // This is neeeded due lack of precision. It might need to sum an extra dart wei (for the given DAI wad amount)\\n      dart = uint256(dart).mul(rate) < wad.mul(RAY) ? dart + 1 : dart;\\n    }\\n  }\\n\\n  function toRad(uint256 wad) internal pure returns (uint256 rad) {\\n    rad = wad.mul(10**27);\\n  }\\n\\n  function toInt256(uint256 x) internal pure returns (int256 y) {\\n    y = int256(x);\\n    require(y >= 0, \\\"int256-overflow\\\");\\n  }\\n\\n  function _getWipeAllWad(\\n    address vat,\\n    address usr,\\n    address urn,\\n    bytes32 ilk\\n  ) internal view returns (uint256 wad) {\\n    // Gets actual rate from the vat\\n    (, uint256 rate, , , ) = IVat(vat).ilks(ilk);\\n    // Gets actual art value of the urn\\n    (, uint256 art) = IVat(vat).urns(ilk, urn);\\n    // Gets actual dai amount in the urn\\n    uint256 dai = IVat(vat).dai(usr);\\n\\n    uint256 rad = art.mul(rate).sub(dai);\\n    wad = rad / RAY;\\n\\n    // If the rad precision has some dust, it will need to request for 1 extra wad wei\\n    wad = wad.mul(RAY) < rad ? wad + 1 : wad;\\n  }\\n\\n  event FLData(uint256 borrowed, uint256 due);\\n  event MultipleActionCalled(\\n    string methodName,\\n    uint256 indexed cdpId,\\n    uint256 swapMinAmount,\\n    uint256 swapOptimistAmount,\\n    uint256 collateralLeft,\\n    uint256 daiLeft\\n  );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256 supply);\\n\\n  function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n  function transfer(address _to, uint256 _value) external returns (bool success);\\n\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _value\\n  ) external returns (bool success);\\n\\n  function approve(address _spender, uint256 _value) external returns (bool success);\\n\\n  function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n\\n  function decimals() external view returns (uint256 digits);\\n\\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n}\\n\"\r\n    },\r\n    \"contracts/multiply/ExchangeData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity >=0.7.6;\\n\\nstruct ExchangeData {\\n  address fromTokenAddress;\\n  address toTokenAddress;\\n  uint256 fromTokenAmount;\\n  uint256 toTokenAmount;\\n  uint256 minToTokenAmount;\\n  address exchangeAddress;\\n  bytes _exchangeCalldata;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.6;\\n\\nlibrary SafeMath {\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IJoin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport './IGem.sol';\\n\\nabstract contract IJoin {\\n  bytes32 public ilk;\\n\\n  function dec() public view virtual returns (uint256);\\n\\n  function gem() public view virtual returns (IGem);\\n\\n  function join(address, uint256) public payable virtual;\\n\\n  function exit(address, uint256) public virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nabstract contract IManager {\\n  function last(address) public virtual returns (uint256);\\n\\n  function cdpCan(\\n    address,\\n    uint256,\\n    address\\n  ) public view virtual returns (uint256);\\n\\n  function ilks(uint256) public view virtual returns (bytes32);\\n\\n  function owns(uint256) public view virtual returns (address);\\n\\n  function urns(uint256) public view virtual returns (address);\\n\\n  function vat() public view virtual returns (address);\\n\\n  function open(bytes32, address) public virtual returns (uint256);\\n\\n  function give(uint256, address) public virtual;\\n\\n  function cdpAllow(\\n    uint256,\\n    address,\\n    uint256\\n  ) public virtual;\\n\\n  function urnAllow(address, uint256) public virtual;\\n\\n  function frob(\\n    uint256,\\n    int256,\\n    int256\\n  ) public virtual;\\n\\n  function flux(\\n    uint256,\\n    address,\\n    uint256\\n  ) public virtual;\\n\\n  function move(\\n    uint256,\\n    address,\\n    uint256\\n  ) public virtual;\\n\\n  function exit(\\n    address,\\n    uint256,\\n    address,\\n    uint256\\n  ) public virtual;\\n\\n  function quit(uint256, address) public virtual;\\n\\n  function enter(address, uint256) public virtual;\\n\\n  function shift(uint256, uint256) public virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IVat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nabstract contract IVat {\\n  struct Urn {\\n    uint256 ink; // Locked Collateral  [wad]\\n    uint256 art; // Normalised Debt    [wad]\\n  }\\n\\n  struct Ilk {\\n    uint256 Art; // Total Normalised Debt     [wad]\\n    uint256 rate; // Accumulated Rates         [ray]\\n    uint256 spot; // Price with Safety Margin  [ray]\\n    uint256 line; // Debt Ceiling              [rad]\\n    uint256 dust; // Urn Debt Floor            [rad]\\n  }\\n\\n  mapping(bytes32 => mapping(address => Urn)) public urns;\\n  mapping(bytes32 => Ilk) public ilks;\\n  mapping(bytes32 => mapping(address => uint256)) public gem; // [wad]\\n\\n  function can(address, address) public view virtual returns (uint256);\\n\\n  function dai(address) public view virtual returns (uint256);\\n\\n  function frob(\\n    bytes32,\\n    address,\\n    address,\\n    address,\\n    int256,\\n    int256\\n  ) public virtual;\\n\\n  function hope(address) public virtual;\\n\\n  function move(\\n    address,\\n    address,\\n    uint256\\n  ) public virtual;\\n\\n  function fork(\\n    bytes32,\\n    address,\\n    address,\\n    int256,\\n    int256\\n  ) public virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IJug.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nabstract contract IJug {\\n  struct Ilk {\\n    uint256 duty;\\n    uint256 rho;\\n  }\\n\\n  mapping(bytes32 => Ilk) public ilks;\\n\\n  function drip(bytes32) public virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IDaiJoin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport './IVat.sol';\\nimport './IGem.sol';\\n\\nabstract contract IDaiJoin {\\n  function vat() public virtual returns (IVat);\\n\\n  function dai() public virtual returns (IGem);\\n\\n  function join(address, uint256) public payable virtual;\\n\\n  function exit(address, uint256) public virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/misc/IUniPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nabstract contract IUniPool {\\n  function slot0()\\n    public view virtual\\n    returns (\\n      uint160,\\n      int24,\\n      uint16,\\n      uint16,\\n      uint16,\\n      uint8,\\n      bool\\n    );\\n\\n  function swap(\\n    address,\\n    bool,\\n    int256,\\n    uint160,\\n    bytes calldata\\n  ) public view virtual;\\n\\n  function positions(bytes32)\\n    public view virtual\\n    returns (\\n      uint128,\\n      uint256,\\n      uint256,\\n      uint128,\\n      uint128\\n    );\\n}\"\r\n    },\r\n    \"contracts/interfaces/misc/IGUNIRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nabstract contract IGUNIRouter {\\n  function addLiquidity(\\n    address _pool,\\n    uint256 _amount0Max,\\n    uint256 _amount1Max,\\n    uint256 _amount0Min,\\n    uint256 _amount1Min,\\n    address _receiver\\n  )\\n    public virtual\\n    returns (\\n      uint256 amount0,\\n      uint256 amount1,\\n      uint256 mintAmount\\n    );\\n\\n  function removeLiquidity(\\n    address _pool,\\n    uint256 _burnAmount,\\n    uint256 _amount0Min,\\n    uint256 _amount1Min,\\n    address _receiver\\n  )\\n    public virtual\\n    returns (\\n      uint256 amount0,\\n      uint256 amount1,\\n      uint256 liquidityBurned\\n    );\\n}\"\r\n    },\r\n    \"contracts/interfaces/misc/IGUNIResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n\\nabstract contract  IGUNIResolver {\\n  function getRebalanceParams(\\n    address pool,\\n    uint256 amount0In,\\n    uint256 amount1In,\\n    uint256 price18Decimals\\n  ) external view virtual returns (bool zeroForOne, uint256 swapAmount);\\n}\"\r\n    },\r\n    \"contracts/interfaces/misc/IGUNIToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./../IERC20.sol\\\";\\n\\nabstract contract IGUNIToken is IERC20 {\\n  function mint(uint256 mintAmount, address receiver)\\n    public virtual\\n    returns (\\n      uint256 amount0,\\n      uint256 amount1,\\n      uint128 liquidityMinted\\n    );\\n\\n  function burn(uint256 burnAmount, address receiver)\\n    public virtual\\n    returns (\\n      uint256 amount0,\\n      uint256 amount1,\\n      uint128 liquidityBurned\\n    );\\n\\n  function getMintAmounts(uint256 amount0Max, uint256 amount1Max)\\n    public virtual\\n    view\\n    returns (\\n      uint256 amount0,\\n      uint256 amount1,\\n      uint256 mintAmount\\n    );\\n\\n  function token0() public virtual view returns (address);\\n\\n  function token1() public virtual view returns (address);\\n\\n  function pool() public virtual view returns (address);\\n\\n  function getUnderlyingBalances() public virtual view returns (uint256, uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/exchange/IExchange.sol\": {\r\n      \"content\": \"pragma solidity >=0.7.0;\\n\\nabstract contract IExchange {\\n  function swapDaiForToken(\\n    address asset,\\n    uint256 amount,\\n    uint256 receiveAtLeast,\\n    address callee,\\n    bytes calldata withData\\n  ) external virtual;\\n\\n  function swapTokenForDai(\\n    address asset,\\n    uint256 amount,\\n    uint256 receiveAtLeast,\\n    address callee,\\n    bytes calldata withData\\n  ) external virtual;\\n}\\n\"\r\n    },\r\n    \"contracts/flashMint/interface/IERC3156FlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Copyright (C) 2021 Dai Foundation\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.6.12;\\n\\ninterface IERC3156FlashBorrower {\\n\\n    /**\\n     * @dev Receive a flash loan.\\n     * @param initiator The initiator of the loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param fee The additional amount of tokens to repay.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return The keccak256 hash of \\\"ERC3156FlashBorrower.onFlashLoan\\\"\\n     */\\n    function onFlashLoan(\\n        address initiator,\\n        address token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/flashMint/interface/IERC3156FlashLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Copyright (C) 2021 Dai Foundation\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.6.12;\\n\\nimport \\\"./IERC3156FlashBorrower.sol\\\";\\n\\ninterface IERC3156FlashLender {\\n\\n    /**\\n     * @dev The amount of currency available to be lent.\\n     * @param token The loan currency.\\n     * @return The amount of `token` that can be borrowed.\\n     */\\n    function maxFlashLoan(\\n        address token\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev The fee to be charged for a given loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\\n     */\\n    function flashFee(\\n        address token,\\n        uint256 amount\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Initiate a flash loan.\\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     */\\n    function flashLoan(\\n        IERC3156FlashBorrower receiver,\\n        address token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/mcd/IGem.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nabstract contract IGem {\\n  function dec() public virtual returns (uint256);\\n\\n  function gem() public virtual returns (IGem);\\n\\n  function join(address, uint256) public payable virtual;\\n\\n  function exit(address, uint256) public virtual;\\n\\n  function approve(address, uint256) public virtual;\\n\\n  function transfer(address, uint256) public virtual returns (bool);\\n\\n  function transferFrom(\\n    address,\\n    address,\\n    uint256\\n  ) public virtual returns (bool);\\n\\n  function deposit() public payable virtual;\\n\\n  function withdraw(uint256) public virtual;\\n\\n  function allowance(address, address) public virtual returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"due\",\"type\":\"uint256\"}],\"name\":\"FLData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapMinAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapOptimistAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralLeft\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiLeft\",\"type\":\"uint256\"}],\"name\":\"MultipleActionCalled\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAIJOIN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0Amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"guni\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guniProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"otherToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"}],\"internalType\":\"struct GuniAddressRegistry\",\"name\":\"guniAddressRegistry\",\"type\":\"tuple\"}],\"name\":\"closeGuniVaultExitDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daiContract\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IGUNIToken\",\"name\":\"guni\",\"type\":\"address\"},{\"internalType\":\"contract IGUNIResolver\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bal0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"otherTokenDecimals\",\"type\":\"uint256\"}],\"name\":\"getOtherTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0Amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"guni\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guniProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"otherToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"}],\"internalType\":\"struct GuniAddressRegistry\",\"name\":\"guniAddressRegistry\",\"type\":\"tuple\"}],\"name\":\"increaseMultipleGuni\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"onFlashLoan\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fromTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minToTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exchangeAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_exchangeCalldata\",\"type\":\"bytes\"}],\"internalType\":\"struct ExchangeData\",\"name\":\"exchangeData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"gemJoin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"fundsReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"ilk\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"requiredDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token0Amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct CdpData\",\"name\":\"cdpData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"guni\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"guniProxyActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"otherToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"jug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"}],\"internalType\":\"struct GuniAddressRegistry\",\"name\":\"guniAddressRegistry\",\"type\":\"tuple\"}],\"name\":\"openMultiplyGuniVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GuniMultiplyProxyActions","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}