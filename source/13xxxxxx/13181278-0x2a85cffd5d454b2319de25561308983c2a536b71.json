{"status":"1","message":"OK","result":[{"SourceCode":"{\"Include.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ncontract PlaceHolder {\\r\\n    \\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title Proxy\\r\\n * @dev Implements delegation of calls to other contracts, with proper\\r\\n * forwarding of return values and bubbling of failures.\\r\\n * It defines a fallback function that delegates all calls to the address\\r\\n * returned by the abstract _implementation() internal function.\\r\\n */\\r\\nabstract contract Proxy {\\r\\n  /**\\r\\n   * @dev Fallback function.\\r\\n   * Implemented entirely in `_fallback`.\\r\\n   */\\r\\n  fallback () payable external {\\r\\n    _fallback();\\r\\n  }\\r\\n  \\r\\n  receive () virtual payable external {\\r\\n    _fallback();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The Address of the implementation.\\r\\n   */\\r\\n  function _implementation() virtual internal view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @dev Delegates execution to an implementation contract.\\r\\n   * This is a low level function that doesn\\u0027t return to its internal call site.\\r\\n   * It will return to the external caller whatever the implementation returns.\\r\\n   * @param implementation Address to delegate.\\r\\n   */\\r\\n  function _delegate(address implementation) internal {\\r\\n    assembly {\\r\\n      // Copy msg.data. We take full control of memory in this inline assembly\\r\\n      // block because it will not return to Solidity code. We overwrite the\\r\\n      // Solidity scratch pad at memory position 0.\\r\\n      calldatacopy(0, 0, calldatasize())\\r\\n\\r\\n      // Call the implementation.\\r\\n      // out and outsize are 0 because we don\\u0027t know the size yet.\\r\\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\r\\n\\r\\n      // Copy the returned data.\\r\\n      returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n      switch result\\r\\n      // delegatecall returns 0 on error.\\r\\n      case 0 { revert(0, returndatasize()) }\\r\\n      default { return(0, returndatasize()) }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Function that is run as the first thing in the fallback function.\\r\\n   * Can be redefined in derived contracts to add functionality.\\r\\n   * Redefinitions must call super._willFallback().\\r\\n   */\\r\\n  function _willFallback() virtual internal {\\r\\n      \\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev fallback implementation.\\r\\n   * Extracted to enable manual triggering.\\r\\n   */\\r\\n  function _fallback() internal {\\r\\n    if(OpenZeppelinUpgradesAddress.isContract(msg.sender) \\u0026\\u0026 msg.data.length == 0 \\u0026\\u0026 gasleft() \\u003c= 2300)         // for receive ETH only from other contract\\r\\n        return;\\r\\n    _willFallback();\\r\\n    _delegate(_implementation());\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title BaseUpgradeabilityProxy\\r\\n * @dev This contract implements a proxy that allows to change the\\r\\n * implementation address to which it will delegate.\\r\\n * Such a change is called an implementation upgrade.\\r\\n */\\r\\nabstract contract BaseUpgradeabilityProxy is Proxy {\\r\\n  /**\\r\\n   * @dev Emitted when the implementation is upgraded.\\r\\n   * @param implementation Address of the new implementation.\\r\\n   */\\r\\n  event Upgraded(address indexed implementation);\\r\\n\\r\\n  /**\\r\\n   * @dev Storage slot with the address of the current implementation.\\r\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\r\\n   * validated in the constructor.\\r\\n   */\\r\\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the current implementation.\\r\\n   * @return impl Address of the current implementation\\r\\n   */\\r\\n  function _implementation() virtual override internal view returns (address impl) {\\r\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\r\\n    assembly {\\r\\n      impl := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Upgrades the proxy to a new implementation.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   */\\r\\n  function _upgradeTo(address newImplementation) internal {\\r\\n    _setImplementation(newImplementation);\\r\\n    emit Upgraded(newImplementation);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the implementation address of the proxy.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   */\\r\\n  function _setImplementation(address newImplementation) internal {\\r\\n    require(newImplementation == address(0) || OpenZeppelinUpgradesAddress.isContract(newImplementation), \\\"Cannot set a proxy implementation to a non-contract address\\\");\\r\\n\\r\\n    bytes32 slot = IMPLEMENTATION_SLOT;\\r\\n\\r\\n    assembly {\\r\\n      sstore(slot, newImplementation)\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title BaseAdminUpgradeabilityProxy\\r\\n * @dev This contract combines an upgradeability proxy with an authorization\\r\\n * mechanism for administrative tasks.\\r\\n * All external functions in this contract must be guarded by the\\r\\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\\r\\n * feature proposal that would enable this to be done automatically.\\r\\n */\\r\\ncontract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\\r\\n  /**\\r\\n   * @dev Emitted when the administration has been transferred.\\r\\n   * @param previousAdmin Address of the previous admin.\\r\\n   * @param newAdmin Address of the new admin.\\r\\n   */\\r\\n  event AdminChanged(address previousAdmin, address newAdmin);\\r\\n\\r\\n  /**\\r\\n   * @dev Storage slot with the admin of the contract.\\r\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\r\\n   * validated in the constructor.\\r\\n   */\\r\\n\\r\\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\r\\n\\r\\n  /**\\r\\n   * @dev Modifier to check whether the `msg.sender` is the admin.\\r\\n   * If it is, it will run the function. Otherwise, it will delegate the call\\r\\n   * to the implementation.\\r\\n   */\\r\\n  modifier ifAdmin() {\\r\\n    if (msg.sender == _admin()) {\\r\\n      _;\\r\\n    } else {\\r\\n      _fallback();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The address of the proxy admin.\\r\\n   */\\r\\n  function admin() external ifAdmin returns (address) {\\r\\n    return _admin();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The address of the implementation.\\r\\n   */\\r\\n  function implementation() external ifAdmin returns (address) {\\r\\n    return _implementation();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Changes the admin of the proxy.\\r\\n   * Only the current admin can call this function.\\r\\n   * @param newAdmin Address to transfer proxy administration to.\\r\\n   */\\r\\n  function changeAdmin(address newAdmin) external ifAdmin {\\r\\n    require(newAdmin != address(0), \\\"Cannot change the admin of a proxy to the zero address\\\");\\r\\n    emit AdminChanged(_admin(), newAdmin);\\r\\n    _setAdmin(newAdmin);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Upgrade the backing implementation of the proxy.\\r\\n   * Only the admin can call this function.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   */\\r\\n  function upgradeTo(address newImplementation) external ifAdmin {\\r\\n    _upgradeTo(newImplementation);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Upgrade the backing implementation of the proxy and call a function\\r\\n   * on the new implementation.\\r\\n   * This is useful to initialize the proxied contract.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   * @param data Data to send as msg.data in the low level call.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   */\\r\\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\\r\\n    _upgradeTo(newImplementation);\\r\\n    (bool success,) = newImplementation.delegatecall(data);\\r\\n    require(success);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return adm The admin slot.\\r\\n   */\\r\\n  function _admin() internal view returns (address adm) {\\r\\n    bytes32 slot = ADMIN_SLOT;\\r\\n    assembly {\\r\\n      adm := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the address of the proxy admin.\\r\\n   * @param newAdmin Address of the new proxy admin.\\r\\n   */\\r\\n  function _setAdmin(address newAdmin) internal {\\r\\n    bytes32 slot = ADMIN_SLOT;\\r\\n\\r\\n    assembly {\\r\\n      sstore(slot, newAdmin)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Only fall back when the sender is not the admin.\\r\\n   */\\r\\n  function _willFallback() virtual override internal {\\r\\n    require(msg.sender != _admin(), \\\"Cannot call fallback function from the proxy admin\\\");\\r\\n    //super._willFallback();\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface IAdminUpgradeabilityProxyView {\\r\\n  function admin() external view returns (address);\\r\\n  function implementation() external view returns (address);\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title UpgradeabilityProxy\\r\\n * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\\r\\n * implementation and init data.\\r\\n */\\r\\nabstract contract UpgradeabilityProxy is BaseUpgradeabilityProxy {\\r\\n  /**\\r\\n   * @dev Contract constructor.\\r\\n   * @param _logic Address of the initial implementation.\\r\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  constructor(address _logic, bytes memory _data) public payable {\\r\\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\u0027eip1967.proxy.implementation\\u0027)) - 1));\\r\\n    _setImplementation(_logic);\\r\\n    if(_data.length \\u003e 0) {\\r\\n      (bool success,) = _logic.delegatecall(_data);\\r\\n      require(success);\\r\\n    }\\r\\n  }  \\r\\n  \\r\\n  //function _willFallback() virtual override internal {\\r\\n    //super._willFallback();\\r\\n  //}\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title AdminUpgradeabilityProxy\\r\\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \\r\\n * initializing the implementation, admin, and init data.\\r\\n */\\r\\ncontract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\\r\\n  /**\\r\\n   * Contract constructor.\\r\\n   * @param _logic address of the initial implementation.\\r\\n   * @param _admin Address of the proxy administrator.\\r\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {\\r\\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256(\\u0027eip1967.proxy.admin\\u0027)) - 1));\\r\\n    _setAdmin(_admin);\\r\\n  }\\r\\n  \\r\\n  function _willFallback() override(Proxy, BaseAdminUpgradeabilityProxy) internal {\\r\\n    super._willFallback();\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title BaseAdminUpgradeabilityProxy\\r\\n * @dev This contract combines an upgradeability proxy with an authorization\\r\\n * mechanism for administrative tasks.\\r\\n * All external functions in this contract must be guarded by the\\r\\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\\r\\n * feature proposal that would enable this to be done automatically.\\r\\n */\\r\\ncontract __BaseAdminUpgradeabilityProxy__ is BaseUpgradeabilityProxy {\\r\\n  /**\\r\\n   * @dev Emitted when the administration has been transferred.\\r\\n   * @param previousAdmin Address of the previous admin.\\r\\n   * @param newAdmin Address of the new admin.\\r\\n   */\\r\\n  event AdminChanged(address previousAdmin, address newAdmin);\\r\\n\\r\\n  /**\\r\\n   * @dev Storage slot with the admin of the contract.\\r\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\r\\n   * validated in the constructor.\\r\\n   */\\r\\n\\r\\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\r\\n\\r\\n  /**\\r\\n   * @dev Modifier to check whether the `msg.sender` is the admin.\\r\\n   * If it is, it will run the function. Otherwise, it will delegate the call\\r\\n   * to the implementation.\\r\\n   */\\r\\n  //modifier ifAdmin() {\\r\\n  //  if (msg.sender == _admin()) {\\r\\n  //    _;\\r\\n  //  } else {\\r\\n  //    _fallback();\\r\\n  //  }\\r\\n  //}\\r\\n  modifier ifAdmin() {\\r\\n    require (msg.sender == _admin(), \\u0027only admin\\u0027);\\r\\n      _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The address of the proxy admin.\\r\\n   */\\r\\n  //function admin() external ifAdmin returns (address) {\\r\\n  //  return _admin();\\r\\n  //}\\r\\n  function __admin__() external view returns (address) {\\r\\n    return _admin();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return The address of the implementation.\\r\\n   */\\r\\n  //function implementation() external ifAdmin returns (address) {\\r\\n  //  return _implementation();\\r\\n  //}\\r\\n  function __implementation__() external view returns (address) {\\r\\n    return _implementation();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Changes the admin of the proxy.\\r\\n   * Only the current admin can call this function.\\r\\n   * @param newAdmin Address to transfer proxy administration to.\\r\\n   */\\r\\n  //function changeAdmin(address newAdmin) external ifAdmin {\\r\\n  //  require(newAdmin != address(0), \\\"Cannot change the admin of a proxy to the zero address\\\");\\r\\n  //  emit AdminChanged(_admin(), newAdmin);\\r\\n  //  _setAdmin(newAdmin);\\r\\n  //}\\r\\n  function __changeAdmin__(address newAdmin) external ifAdmin {\\r\\n    require(newAdmin != address(0), \\\"Cannot change the admin of a proxy to the zero address\\\");\\r\\n    emit AdminChanged(_admin(), newAdmin);\\r\\n    _setAdmin(newAdmin);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Upgrade the backing implementation of the proxy.\\r\\n   * Only the admin can call this function.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   */\\r\\n  //function upgradeTo(address newImplementation) external ifAdmin {\\r\\n  //  _upgradeTo(newImplementation);\\r\\n  //}\\r\\n  function __upgradeTo__(address newImplementation) external ifAdmin {\\r\\n    _upgradeTo(newImplementation);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Upgrade the backing implementation of the proxy and call a function\\r\\n   * on the new implementation.\\r\\n   * This is useful to initialize the proxied contract.\\r\\n   * @param newImplementation Address of the new implementation.\\r\\n   * @param data Data to send as msg.data in the low level call.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   */\\r\\n  //function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\\r\\n  //  _upgradeTo(newImplementation);\\r\\n  //  (bool success,) = newImplementation.delegatecall(data);\\r\\n  //  require(success);\\r\\n  //}\\r\\n  function __upgradeToAndCall__(address newImplementation, bytes calldata data) payable external ifAdmin {\\r\\n    _upgradeTo(newImplementation);\\r\\n    (bool success,) = newImplementation.delegatecall(data);\\r\\n    require(success);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @return adm The admin slot.\\r\\n   */\\r\\n  function _admin() internal view returns (address adm) {\\r\\n    bytes32 slot = ADMIN_SLOT;\\r\\n    assembly {\\r\\n      adm := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the address of the proxy admin.\\r\\n   * @param newAdmin Address of the new proxy admin.\\r\\n   */\\r\\n  function _setAdmin(address newAdmin) internal {\\r\\n    bytes32 slot = ADMIN_SLOT;\\r\\n\\r\\n    assembly {\\r\\n      sstore(slot, newAdmin)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Only fall back when the sender is not the admin.\\r\\n   */\\r\\n  //function _willFallback() virtual override internal {\\r\\n  //  require(msg.sender != _admin(), \\\"Cannot call fallback function from the proxy admin\\\");\\r\\n  //  //super._willFallback();\\r\\n  //}\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title AdminUpgradeabilityProxy\\r\\n * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \\r\\n * initializing the implementation, admin, and init data.\\r\\n */\\r\\ncontract __AdminUpgradeabilityProxy__ is __BaseAdminUpgradeabilityProxy__, UpgradeabilityProxy {\\r\\n  /**\\r\\n   * Contract constructor.\\r\\n   * @param _logic address of the initial implementation.\\r\\n   * @param _admin Address of the proxy administrator.\\r\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  constructor(address _logic, address _admin, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {\\r\\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256(\\u0027eip1967.proxy.admin\\u0027)) - 1));\\r\\n    _setAdmin(_admin);\\r\\n  }\\r\\n  \\r\\n  //function _willFallback() override(Proxy, BaseAdminUpgradeabilityProxy) internal {\\r\\n  //  super._willFallback();\\r\\n  //}\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title InitializableUpgradeabilityProxy\\r\\n * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\\r\\n * implementation and init data.\\r\\n */\\r\\nabstract contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\\r\\n  /**\\r\\n   * @dev Contract initializer.\\r\\n   * @param _logic Address of the initial implementation.\\r\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  function initialize(address _logic, bytes memory _data) public payable {\\r\\n    require(_implementation() == address(0));\\r\\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\u0027eip1967.proxy.implementation\\u0027)) - 1));\\r\\n    _setImplementation(_logic);\\r\\n    if(_data.length \\u003e 0) {\\r\\n      (bool success,) = _logic.delegatecall(_data);\\r\\n      require(success);\\r\\n    }\\r\\n  }  \\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title InitializableAdminUpgradeabilityProxy\\r\\n * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for \\r\\n * initializing the implementation, admin, and init data.\\r\\n */\\r\\ncontract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {\\r\\n  /**\\r\\n   * Contract initializer.\\r\\n   * @param _logic address of the initial implementation.\\r\\n   * @param _admin Address of the proxy administrator.\\r\\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  function initialize(address _logic, address _admin, bytes memory _data) public payable {\\r\\n    require(_implementation() == address(0));\\r\\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\\r\\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256(\\u0027eip1967.proxy.admin\\u0027)) - 1));\\r\\n    _setAdmin(_admin);\\r\\n  }\\r\\n  \\r\\n  function _willFallback() override(Proxy, BaseAdminUpgradeabilityProxy) internal {\\r\\n    super._willFallback();\\r\\n  }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\ninterface IProxyFactory {\\r\\n    function governor() external view returns (address);\\r\\n    function __admin__() external view returns (address);\\r\\n    function productImplementation() external view returns (address);\\r\\n    function productImplementations(bytes32 name) external view returns (address);\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title ProductProxy\\r\\n * @dev This contract implements a proxy that \\r\\n * it is deploied by ProxyFactory, \\r\\n * and it\\u0027s implementation is stored in factory.\\r\\n */\\r\\ncontract ProductProxy is Proxy {\\r\\n    \\r\\n  /**\\r\\n   * @dev Storage slot with the address of the ProxyFactory.\\r\\n   * This is the keccak-256 hash of \\\"eip1967.proxy.factory\\\" subtracted by 1, and is\\r\\n   * validated in the constructor.\\r\\n   */\\r\\n  bytes32 internal constant FACTORY_SLOT = 0x7a45a402e4cb6e08ebc196f20f66d5d30e67285a2a8aa80503fa409e727a4af1;\\r\\n  bytes32 internal constant NAME_SLOT    = 0x4cd9b827ca535ceb0880425d70eff88561ecdf04dc32fcf7ff3b15c587f8a870;      // bytes32(uint256(keccak256(\\u0027eip1967.proxy.name\\u0027)) - 1)\\r\\n\\r\\n  function _name() virtual internal view returns (bytes32 name_) {\\r\\n    bytes32 slot = NAME_SLOT;\\r\\n    assembly {  name_ := sload(slot)  }\\r\\n  }\\r\\n  \\r\\n  function _setName(bytes32 name_) internal {\\r\\n    bytes32 slot = NAME_SLOT;\\r\\n    assembly {  sstore(slot, name_)  }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the factory address of the ProductProxy.\\r\\n   * @param newFactory Address of the new factory.\\r\\n   */\\r\\n  function _setFactory(address newFactory) internal {\\r\\n    require(newFactory == address(0) || OpenZeppelinUpgradesAddress.isContract(newFactory), \\\"Cannot set a factory to a non-contract address\\\");\\r\\n\\r\\n    bytes32 slot = FACTORY_SLOT;\\r\\n\\r\\n    assembly {\\r\\n      sstore(slot, newFactory)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the factory.\\r\\n   * @return factory_ Address of the factory.\\r\\n   */\\r\\n  function _factory() internal view returns (address factory_) {\\r\\n    bytes32 slot = FACTORY_SLOT;\\r\\n    assembly {\\r\\n      factory_ := sload(slot)\\r\\n    }\\r\\n  }\\r\\n  \\r\\n  /**\\r\\n   * @dev Returns the current implementation.\\r\\n   * @return Address of the current implementation\\r\\n   */\\r\\n  function _implementation() virtual override internal view returns (address) {\\r\\n    address factory_ = _factory();\\r\\n    bytes32 name_ = _name();\\r\\n    if(OpenZeppelinUpgradesAddress.isContract(factory_))\\r\\n        if(name_ != 0x0)\\r\\n            return IProxyFactory(factory_).productImplementations(name_);\\r\\n        else\\r\\n            return IProxyFactory(factory_).productImplementation();\\r\\n    else\\r\\n        return address(0);\\r\\n  }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title InitializableProductProxy\\r\\n * @dev Extends ProductProxy with an initializer for initializing\\r\\n * factory and init data.\\r\\n */\\r\\ncontract InitializableProductProxy is ProductProxy {\\r\\n  /**\\r\\n   * @dev Contract initializer.\\r\\n   * @param factory Address of the initial factory.\\r\\n   * @param data Data to send as msg.data to the implementation to initialize the proxied contract.\\r\\n   * It should include the signature and the parameters of the function to be called, as described in\\r\\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\\r\\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\\r\\n   */\\r\\n  function __InitializableProductProxy_init(address factory, bytes32 name, bytes memory data) external payable {\\r\\n    address factory_ = _factory();\\r\\n    require(factory_ == address(0) || msg.sender == factory_ || msg.sender == IProxyFactory(factory_).governor() || msg.sender == IProxyFactory(factory_).__admin__());\\r\\n    assert(FACTORY_SLOT == bytes32(uint256(keccak256(\\u0027eip1967.proxy.factory\\u0027)) - 1));\\r\\n    assert(NAME_SLOT    == bytes32(uint256(keccak256(\\u0027eip1967.proxy.name\\u0027)) - 1));\\r\\n    _setFactory(factory);\\r\\n    _setName(name);\\r\\n    if(data.length \\u003e 0) {\\r\\n      (bool success,) = _implementation().delegatecall(data);\\r\\n      require(success);\\r\\n    }\\r\\n  }  \\r\\n}\\r\\n\\r\\n\\r\\ncontract __InitializableAdminUpgradeabilityProductProxy__ is __BaseAdminUpgradeabilityProxy__, ProductProxy {\\r\\n  function __InitializableAdminUpgradeabilityProductProxy_init__(address logic, address admin, address factory, bytes32 name, bytes memory data) public payable {\\r\\n    assert(IMPLEMENTATION_SLOT  == bytes32(uint256(keccak256(\\u0027eip1967.proxy.implementation\\u0027)) - 1));\\r\\n    assert(ADMIN_SLOT           == bytes32(uint256(keccak256(\\u0027eip1967.proxy.admin\\u0027)) - 1));\\r\\n    assert(FACTORY_SLOT         == bytes32(uint256(keccak256(\\u0027eip1967.proxy.factory\\u0027)) - 1));\\r\\n    assert(NAME_SLOT            == bytes32(uint256(keccak256(\\u0027eip1967.proxy.name\\u0027)) - 1));\\r\\n    address admin_ = _admin();\\r\\n    require(admin_ == address(0) || msg.sender == admin_);\\r\\n    _setAdmin(admin);\\r\\n    _setImplementation(logic);\\r\\n    _setFactory(factory);\\r\\n    _setName(name);\\r\\n    if(data.length \\u003e 0) {\\r\\n      (bool success,) = _implementation().delegatecall(data);\\r\\n      require(success);\\r\\n    }\\r\\n  }\\r\\n  \\r\\n  function _implementation() virtual override(BaseUpgradeabilityProxy, ProductProxy) internal view returns (address impl) {\\r\\n    impl = ProductProxy._implementation();\\r\\n    if(impl == address(0))\\r\\n        impl = BaseUpgradeabilityProxy._implementation();\\r\\n  }\\r\\n}\\r\\n\\r\\ncontract __AdminUpgradeabilityProductProxy__ is __InitializableAdminUpgradeabilityProductProxy__ {\\r\\n  constructor(address logic, address admin, address factory, bytes32 name, bytes memory data) public payable {\\r\\n    __InitializableAdminUpgradeabilityProductProxy_init__(logic, admin, factory, name, data);\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title Initializable\\r\\n *\\r\\n * @dev Helper contract to support initializer functions. To use it, replace\\r\\n * the constructor with a function that has the `initializer` modifier.\\r\\n * WARNING: Unlike constructors, initializer functions must be manually\\r\\n * invoked. This applies both to deploying an Initializable contract, as well\\r\\n * as extending an Initializable contract via inheritance.\\r\\n * WARNING: When used with inheritance, manual care must be taken to not invoke\\r\\n * a parent initializer twice, or ensure that all initializers are idempotent,\\r\\n * because this is not dealt with automatically as with constructors.\\r\\n */\\r\\ncontract Initializable {\\r\\n\\r\\n  /**\\r\\n   * @dev Indicates that the contract has been initialized.\\r\\n   */\\r\\n  bool private initialized;\\r\\n\\r\\n  /**\\r\\n   * @dev Indicates that the contract is in the process of being initialized.\\r\\n   */\\r\\n  bool private initializing;\\r\\n\\r\\n  /**\\r\\n   * @dev Modifier to use in the initializer function of a contract.\\r\\n   */\\r\\n  modifier initializer() {\\r\\n    require(initializing || isConstructor() || !initialized, \\\"Contract instance has already been initialized\\\");\\r\\n\\r\\n    bool isTopLevelCall = !initializing;\\r\\n    if (isTopLevelCall) {\\r\\n      initializing = true;\\r\\n      initialized = true;\\r\\n    }\\r\\n\\r\\n    _;\\r\\n\\r\\n    if (isTopLevelCall) {\\r\\n      initializing = false;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev Returns true if and only if the function is running in the constructor\\r\\n  function isConstructor() private view returns (bool) {\\r\\n    // extcodesize checks the size of the code stored in an address, and\\r\\n    // address returns the current address. Since the code is still not\\r\\n    // deployed when running a constructor, any checks on its code size will\\r\\n    // yield zero, making it an effective way to detect if a contract is\\r\\n    // under construction or not.\\r\\n    address self = address(this);\\r\\n    uint256 cs;\\r\\n    assembly { cs := extcodesize(self) }\\r\\n    return cs == 0;\\r\\n  }\\r\\n\\r\\n  // Reserved storage space to allow for layout changes in the future.\\r\\n  uint256[50] private ______gap;\\r\\n}\\r\\n\\r\\n\\r\\n/*\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with GSN meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\ncontract ContextUpgradeSafe is Initializable {\\r\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\r\\n    // an instance of this contract, which should be used via inheritance.\\r\\n\\r\\n    function __Context_init() internal initializer {\\r\\n        __Context_init_unchained();\\r\\n    }\\r\\n\\r\\n    function __Context_init_unchained() internal initializer {\\r\\n\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\r\\n        return msg.data;\\r\\n    }\\r\\n\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\ncontract ReentrancyGuardUpgradeSafe is Initializable {\\r\\n    bool private _notEntered;\\r\\n\\r\\n\\r\\n    function __ReentrancyGuard_init() internal initializer {\\r\\n        __ReentrancyGuard_init_unchained();\\r\\n    }\\r\\n\\r\\n    function __ReentrancyGuard_init_unchained() internal initializer {\\r\\n\\r\\n\\r\\n        // Storing an initial non-zero value makes deployment a bit more\\r\\n        // expensive, but in exchange the refund on every call to nonReentrant\\r\\n        // will be lower in amount. Since refunds are capped to a percetange of\\r\\n        // the total transaction\\u0027s gas, it is best to keep them low in cases\\r\\n        // like this one, to increase the likelihood of the full refund coming\\r\\n        // into effect.\\r\\n        _notEntered = true;\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and make it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _notEntered = false;\\r\\n\\r\\n        _;\\r\\n\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _notEntered = true;\\r\\n    }\\r\\n\\r\\n    uint256[49] private __gap;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Standard math utilities missing in the Solidity language.\\r\\n */\\r\\nlibrary Math {\\r\\n    /**\\r\\n     * @dev Returns the largest of two numbers.\\r\\n     */\\r\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e= b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the smallest of two numbers.\\r\\n     */\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the average of two numbers. The result is rounded towards\\r\\n     * zero.\\r\\n     */\\r\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // (a + b) / 2 can overflow, so we distribute\\r\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\r\\n    }\\r\\n\\r\\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\\r\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\r\\n        if (x == 0) return 0;\\r\\n        // this block is equivalent to r = uint256(1) \\u003c\\u003c (BitMath.mostSignificantBit(x) / 2);\\r\\n        // however that code costs significantly more gas\\r\\n        uint256 xx = x;\\r\\n        uint256 r = 1;\\r\\n        if (xx \\u003e= 0x100000000000000000000000000000000) {\\r\\n            xx \\u003e\\u003e= 128;\\r\\n            r \\u003c\\u003c= 64;\\r\\n        }\\r\\n        if (xx \\u003e= 0x10000000000000000) {\\r\\n            xx \\u003e\\u003e= 64;\\r\\n            r \\u003c\\u003c= 32;\\r\\n        }\\r\\n        if (xx \\u003e= 0x100000000) {\\r\\n            xx \\u003e\\u003e= 32;\\r\\n            r \\u003c\\u003c= 16;\\r\\n        }\\r\\n        if (xx \\u003e= 0x10000) {\\r\\n            xx \\u003e\\u003e= 16;\\r\\n            r \\u003c\\u003c= 8;\\r\\n        }\\r\\n        if (xx \\u003e= 0x100) {\\r\\n            xx \\u003e\\u003e= 8;\\r\\n            r \\u003c\\u003c= 4;\\r\\n        }\\r\\n        if (xx \\u003e= 0x10) {\\r\\n            xx \\u003e\\u003e= 4;\\r\\n            r \\u003c\\u003c= 2;\\r\\n        }\\r\\n        if (xx \\u003e= 0x8) {\\r\\n            r \\u003c\\u003c= 1;\\r\\n        }\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1;\\r\\n        r = (r + x / r) \\u003e\\u003e 1; // Seven iterations should be enough\\r\\n        uint256 r1 = x / r;\\r\\n        return (r \\u003c r1 ? r : r1);\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub0(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003e b ? a - b : 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Utility library of inline functions on addresses\\r\\n *\\r\\n * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol\\r\\n * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\\r\\n * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\\r\\n * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\\r\\n */\\r\\nlibrary OpenZeppelinUpgradesAddress {\\r\\n    /**\\r\\n     * Returns whether the target address is a contract\\r\\n     * @dev This function will return false if invoked during the constructor of a contract,\\r\\n     * as the code is not actually created until after the constructor finishes.\\r\\n     * @param account address of the account to check\\r\\n     * @return whether the target address is a contract\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        // XXX Currently there is no better way to check if there is a contract in an address\\r\\n        // than to check the size of the code at that address.\\r\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\r\\n        // for more details about how this works.\\r\\n        // TODO Check this again before the Serenity release, because all addresses will be\\r\\n        // contracts then.\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { size := extcodesize(account) }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {ERC20MinterPauser}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\r\\n * of returning `false` on failure. This behavior is nonetheless conventional\\r\\n * and does not conflict with the expectations of ERC20 applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn\\u0027t required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IERC20-approve}.\\r\\n */\\r\\ncontract ERC20UpgradeSafe is ContextUpgradeSafe, IERC20 {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping (address =\\u003e uint256) internal _balances;\\r\\n\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) internal _allowances;\\r\\n\\r\\n    uint256 internal _totalSupply;\\r\\n\\r\\n    string internal _name;\\r\\n    string internal _symbol;\\r\\n    uint8 internal _decimals;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\r\\n     * a default value of 18.\\r\\n     *\\r\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\r\\n     *\\r\\n     * All three of these values are immutable: they can only be set once during\\r\\n     * construction.\\r\\n     */\\r\\n\\r\\n    function __ERC20_init(string memory name, string memory symbol) internal initializer {\\r\\n        __Context_init_unchained();\\r\\n        __ERC20_init_unchained(name, symbol);\\r\\n    }\\r\\n\\r\\n    function __ERC20_init_unchained(string memory name, string memory symbol) internal initializer {\\r\\n\\r\\n\\r\\n        _name = name;\\r\\n        _symbol = symbol;\\r\\n        _decimals = 18;\\r\\n\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n     * name.\\r\\n     */\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of decimals used to get its user representation.\\r\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n     *\\r\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\r\\n     * called.\\r\\n     *\\r\\n     * NOTE: This information is only used for _display_ purposes: it in\\r\\n     * no way affects any of the arithmetic of the contract, including\\r\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n     */\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-totalSupply}.\\r\\n     */\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - the caller must have a balance of at least `amount`.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-allowance}.\\r\\n     */\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-approve}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC20-transferFrom}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n     * required by the EIP. See the note at the beginning of {ERC20};\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - `sender` and `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     * - the caller must have allowance for ``sender``\\u0027s tokens of at least\\r\\n     * `amount`.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        if(sender != _msgSender() \\u0026\\u0026 _allowances[sender][_msgSender()] != uint(-1))\\r\\n            _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n     *\\r\\n     * This is an alternative to {approve} that can be used as a mitigation for\\r\\n     * problems described in {IERC20-approve}.\\r\\n     *\\r\\n     * Emits an {Approval} event indicating the updated allowance.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `spender` cannot be the zero address.\\r\\n     * - `spender` must have allowance for the caller of at least\\r\\n     * `subtractedValue`.\\r\\n     */\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * This is internal function is equivalent to {transfer}, and can be used to\\r\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(address(0), account, amount);\\r\\n\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(account, address(0), amount);\\r\\n\\r\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        emit Transfer(account, address(0), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n     *\\r\\n     * This is internal function is equivalent to `approve`, and can be used to\\r\\n     * e.g. set automatic allowances for certain subsystems, etc.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\r\\n     *\\r\\n     * WARNING: This function should only be called from the constructor. Most\\r\\n     * applications that interact with token contracts will not expect\\r\\n     * {decimals} to ever change, and may work incorrectly if it does.\\r\\n     */\\r\\n    function _setupDecimals(uint8 decimals_) internal {\\r\\n        _decimals = decimals_;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``\\u0027s tokens\\r\\n     * will be to transferred to `to`.\\r\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\r\\n     * - when `to` is zero, `amount` of ``from``\\u0027s tokens will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\r\\n\\r\\n    uint256[44] private __gap;\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\\r\\n */\\r\\ncontract ERC20CappedUpgradeSafe is ERC20UpgradeSafe {\\r\\n    uint256 internal _cap;\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\\r\\n     * set once during construction.\\r\\n     */\\r\\n\\r\\n    function __ERC20Capped_init(uint256 cap) internal initializer {\\r\\n        __Context_init_unchained();\\r\\n        __ERC20Capped_init_unchained(cap);\\r\\n    }\\r\\n\\r\\n    function __ERC20Capped_init_unchained(uint256 cap) internal initializer {\\r\\n        require(cap \\u003e 0, \\\"ERC20Capped: cap is 0\\\");\\r\\n        _cap = cap;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the cap on the token\\u0027s total supply.\\r\\n     */\\r\\n    function cap() virtual public view returns (uint256) {\\r\\n        return _cap;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {ERC20-_beforeTokenTransfer}.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - minted tokens must not cause the total supply to go over the cap.\\r\\n     */\\r\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\\r\\n        super._beforeTokenTransfer(from, to, amount);\\r\\n\\r\\n        if (from == address(0)) { // When minting tokens\\r\\n            require(totalSupply().add(amount) \\u003c= _cap, \\\"ERC20Capped: cap exceeded\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    uint256[49] private __gap;\\r\\n}\\r\\n\\r\\n\\r\\nabstract contract Permit {\\r\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\r\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\r\\n    function DOMAIN_SEPARATOR() virtual public view returns (bytes32);\\r\\n\\r\\n    mapping (address =\\u003e uint) public nonces;\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\\r\\n        require(deadline \\u003e= block.timestamp, \\u0027permit EXPIRED\\u0027);\\r\\n        bytes32 digest = keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\u0027\\\\x19\\\\x01\\u0027,\\r\\n                DOMAIN_SEPARATOR(),\\r\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\r\\n            )\\r\\n        );\\r\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\r\\n        require(recoveredAddress != address(0) \\u0026\\u0026 recoveredAddress == owner, \\u0027permit INVALID_SIGNATURE\\u0027);\\r\\n        _approve(owner, spender, value);\\r\\n    }\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 amount) internal virtual;    \\r\\n\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\\r\\ncontract PermitERC20UpgradeSafe is Permit, ERC20UpgradeSafe {\\r\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\r\\n    \\r\\n    function DOMAIN_SEPARATOR() virtual override public view returns (bytes32) {\\r\\n        return keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name())), _chainId(), address(this)));\\r\\n    }\\r\\n    \\r\\n    function _chainId() internal pure returns (uint id) {\\r\\n        assembly { id := chainid() }\\r\\n    }\\r\\n    \\r\\n    function _approve(address owner, address spender, uint256 amount) virtual override(Permit, ERC20UpgradeSafe) internal {\\r\\n        return ERC20UpgradeSafe._approve(owner, spender, amount);\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n/**\\r\\n * @title SafeERC20\\r\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\r\\n * contract returns false). Tokens that return no value (and instead revert or\\r\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\r\\n * successful.\\r\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\r\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\r\\n */\\r\\nlibrary SafeERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    using Address for address;\\r\\n\\r\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n    }\\r\\n\\r\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\r\\n        // safeApprove should only be called when setting an initial allowance,\\r\\n        // or when resetting it to zero. To increase and decrease it, use\\r\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n        );\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n    }\\r\\n\\r\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\r\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\r\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\r\\n     * @param token The token targeted by the call.\\r\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\r\\n     */\\r\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\r\\n        // we\\u0027re implementing it ourselves.\\r\\n\\r\\n        // A Solidity high level call has three parts:\\r\\n        //  1. The target address is checked to verify it contains contract code\\r\\n        //  2. The call itself is made, and success asserted\\r\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\r\\n        // solhint-disable-next-line max-line-length\\r\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = address(token).call(data);\\r\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\r\\n\\r\\n        if (returndata.length \\u003e 0) { // Return data is optional\\r\\n            // solhint-disable-next-line max-line-length\\r\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\ncontract Governable is Initializable {\\r\\n    // bytes32(uint256(keccak256(\\u0027eip1967.proxy.admin\\u0027)) - 1)\\r\\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\r\\n\\r\\n    address public governor;\\r\\n\\r\\n    event GovernorshipTransferred(address indexed previousGovernor, address indexed newGovernor);\\r\\n\\r\\n    /**\\r\\n     * @dev Contract initializer.\\r\\n     * called once by the factory at time of deployment\\r\\n     */\\r\\n    function __Governable_init_unchained(address governor_) virtual public initializer {\\r\\n        governor = governor_;\\r\\n        emit GovernorshipTransferred(address(0), governor);\\r\\n    }\\r\\n\\r\\n    function _admin() internal view returns (address adm) {\\r\\n        bytes32 slot = ADMIN_SLOT;\\r\\n        assembly {\\r\\n            adm := sload(slot)\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    modifier governance() {\\r\\n        require(msg.sender == governor || msg.sender == _admin());\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current governor to relinquish control of the contract.\\r\\n     * @notice Renouncing to governorship will leave the contract without an governor.\\r\\n     * It will not be possible to call the functions with the `governance`\\r\\n     * modifier anymore.\\r\\n     */\\r\\n    function renounceGovernorship() public governance {\\r\\n        emit GovernorshipTransferred(governor, address(0));\\r\\n        governor = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows the current governor to transfer control of the contract to a newGovernor.\\r\\n     * @param newGovernor The address to transfer governorship to.\\r\\n     */\\r\\n    function transferGovernorship(address newGovernor) public governance {\\r\\n        _transferGovernorship(newGovernor);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers control of the contract to a newGovernor.\\r\\n     * @param newGovernor The address to transfer governorship to.\\r\\n     */\\r\\n    function _transferGovernorship(address newGovernor) internal {\\r\\n        require(newGovernor != address(0));\\r\\n        emit GovernorshipTransferred(governor, newGovernor);\\r\\n        governor = newGovernor;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\ncontract Configurable is Governable {\\r\\n    mapping (bytes32 =\\u003e uint) internal config;\\r\\n    \\r\\n    function getConfig(bytes32 key) public view returns (uint) {\\r\\n        return config[key];\\r\\n    }\\r\\n    function getConfigI(bytes32 key, uint index) public view returns (uint) {\\r\\n        return config[bytes32(uint(key) ^ index)];\\r\\n    }\\r\\n    function getConfigA(bytes32 key, address addr) public view returns (uint) {\\r\\n        return config[bytes32(uint(key) ^ uint(addr))];\\r\\n    }\\r\\n\\r\\n    function _setConfig(bytes32 key, uint value) internal {\\r\\n        if(config[key] != value)\\r\\n            config[key] = value;\\r\\n    }\\r\\n    function _setConfig(bytes32 key, uint index, uint value) internal {\\r\\n        _setConfig(bytes32(uint(key) ^ index), value);\\r\\n    }\\r\\n    function _setConfig(bytes32 key, address addr, uint value) internal {\\r\\n        _setConfig(bytes32(uint(key) ^ uint(addr)), value);\\r\\n    }\\r\\n\\r\\n    function setConfig(bytes32 key, uint value) external governance {\\r\\n        _setConfig(key, value);\\r\\n    }\\r\\n    function setConfigI(bytes32 key, uint index, uint value) external governance {\\r\\n        _setConfig(bytes32(uint(key) ^ index), value);\\r\\n    }\\r\\n    function setConfigA(bytes32 key, address addr, uint value) public governance {\\r\\n        _setConfig(bytes32(uint(key) ^ uint(addr)), value);\\r\\n    }\\r\\n}\\r\\n\\r\\n\"},\"Mining.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\nimport \\\"./Include.sol\\\";\\r\\n\\r\\n// Inheritancea\\r\\ninterface IStakingRewards {\\r\\n    // Views\\r\\n    function lastTimeRewardApplicable() external view returns (uint256);\\r\\n\\r\\n    function rewardPerToken() external view returns (uint256);\\r\\n\\r\\n    function rewards(address account) external view returns (uint256);\\r\\n\\r\\n    function earned(address account) external view returns (uint256);\\r\\n\\r\\n    function getRewardForDuration() external view returns (uint256);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    // Mutative\\r\\n\\r\\n    function stake(uint256 amount) external;\\r\\n\\r\\n    function withdraw(uint256 amount) external;\\r\\n\\r\\n    function getReward() external;\\r\\n\\r\\n    function exit() external;\\r\\n}\\r\\n\\r\\nabstract contract RewardsDistributionRecipient {\\r\\n    address public rewardsDistribution;\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward) virtual external;\\r\\n\\r\\n    modifier onlyRewardsDistribution() {\\r\\n        require(msg.sender == rewardsDistribution, \\\"Caller is not RewardsDistribution contract\\\");\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract StakingRewards is IStakingRewards, RewardsDistributionRecipient, ReentrancyGuardUpgradeSafe {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    IERC20 public rewardsToken;\\r\\n    IERC20 public stakingToken;\\r\\n    uint256 public periodFinish = 0;\\r\\n    uint256 public rewardRate = 0;                  // obsoleted\\r\\n    uint256 public rewardsDuration = 60 days;\\r\\n    uint256 public lastUpdateTime;\\r\\n    uint256 public rewardPerTokenStored;\\r\\n\\r\\n    mapping(address =\\u003e uint256) public userRewardPerTokenPaid;\\r\\n    mapping(address =\\u003e uint256) override public rewards;\\r\\n\\r\\n    uint256 internal _totalSupply;\\r\\n    mapping(address =\\u003e uint256) internal _balances;\\r\\n\\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n\\r\\n    //constructor(\\r\\n    function __StakingRewards_init(\\r\\n        address _rewardsDistribution,\\r\\n        address _rewardsToken,\\r\\n        address _stakingToken\\r\\n    ) public virtual initializer {\\r\\n        __ReentrancyGuard_init_unchained();\\r\\n        __StakingRewards_init_unchained(_rewardsDistribution, _rewardsToken, _stakingToken);\\r\\n    }\\r\\n\\r\\n    function __StakingRewards_init_unchained(\\r\\n        address _rewardsDistribution,\\r\\n        address _rewardsToken,\\r\\n        address _stakingToken\\r\\n    ) public virtual initializer {\\r\\n        rewardsToken = IERC20(_rewardsToken);\\r\\n        stakingToken = IERC20(_stakingToken);\\r\\n        rewardsDistribution = _rewardsDistribution;\\r\\n    }\\r\\n\\r\\n    /* ========== VIEWS ========== */\\r\\n\\r\\n    function totalSupply() virtual override public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) virtual override public view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function lastTimeRewardApplicable() override public view returns (uint256) {\\r\\n        return Math.min(block.timestamp, periodFinish);\\r\\n    }\\r\\n\\r\\n    function rewardPerToken() virtual override public view returns (uint256) {\\r\\n        if (_totalSupply == 0) {\\r\\n            return rewardPerTokenStored;\\r\\n        }\\r\\n        return\\r\\n            rewardPerTokenStored.add(\\r\\n                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function earned(address account) virtual override public view returns (uint256) {\\r\\n        return _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account]);\\r\\n    }\\r\\n\\r\\n    function getRewardForDuration() virtual override external view returns (uint256) {\\r\\n        return rewardRate.mul(rewardsDuration);\\r\\n    }\\r\\n\\r\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\r\\n\\r\\n    function stakeWithPermit(uint256 amount, uint deadline, uint8 v, bytes32 r, bytes32 s) virtual public nonReentrant updateReward(msg.sender) {\\r\\n        require(amount \\u003e 0, \\\"Cannot stake 0\\\");\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\r\\n\\r\\n        // permit\\r\\n        IPermit(address(stakingToken)).permit(msg.sender, address(this), amount, deadline, v, r, s);\\r\\n\\r\\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\\r\\n        emit Staked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function stake(uint256 amount) virtual override public nonReentrant updateReward(msg.sender) {\\r\\n        require(amount \\u003e 0, \\\"Cannot stake 0\\\");\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\r\\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\\r\\n        emit Staked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256 amount) virtual override public nonReentrant updateReward(msg.sender) {\\r\\n        require(amount \\u003e 0, \\\"Cannot withdraw 0\\\");\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\r\\n        stakingToken.safeTransfer(msg.sender, amount);\\r\\n        emit Withdrawn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function getReward() virtual override public nonReentrant updateReward(msg.sender) {\\r\\n        uint256 reward = rewards[msg.sender];\\r\\n        if (reward \\u003e 0) {\\r\\n            rewards[msg.sender] = 0;\\r\\n            rewardsToken.safeTransfer(msg.sender, reward);\\r\\n            emit RewardPaid(msg.sender, reward);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function exit() virtual override public {\\r\\n        withdraw(_balances[msg.sender]);\\r\\n        getReward();\\r\\n    }\\r\\n\\r\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\r\\n\\r\\n    function notifyRewardAmount(uint256 reward) override external onlyRewardsDistribution updateReward(address(0)) {\\r\\n        if (block.timestamp \\u003e= periodFinish) {\\r\\n            rewardRate = reward.div(rewardsDuration);\\r\\n        } else {\\r\\n            uint256 remaining = periodFinish.sub(block.timestamp);\\r\\n            uint256 leftover = remaining.mul(rewardRate);\\r\\n            rewardRate = reward.add(leftover).div(rewardsDuration);\\r\\n        }\\r\\n\\r\\n        // Ensure the provided reward amount is not more than the balance in the contract.\\r\\n        // This keeps the reward rate in the right range, preventing overflows due to\\r\\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\\r\\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\\r\\n        uint balance = rewardsToken.balanceOf(address(this));\\r\\n        require(rewardRate \\u003c= balance.div(rewardsDuration), \\\"Provided reward too high\\\");\\r\\n\\r\\n        lastUpdateTime = block.timestamp;\\r\\n        periodFinish = block.timestamp.add(rewardsDuration);\\r\\n        emit RewardAdded(reward);\\r\\n    }\\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n\\r\\n    modifier updateReward(address account) virtual {\\r\\n        rewardPerTokenStored = rewardPerToken();\\r\\n        lastUpdateTime = lastTimeRewardApplicable();\\r\\n        if (account != address(0)) {\\r\\n            rewards[account] = earned(account);\\r\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /* ========== EVENTS ========== */\\r\\n\\r\\n    event RewardAdded(uint256 reward);\\r\\n    event Staked(address indexed user, uint256 amount);\\r\\n    event Withdrawn(address indexed user, uint256 amount);\\r\\n    event RewardPaid(address indexed user, uint256 reward);\\r\\n}\\r\\n\\r\\ninterface IPermit {\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n}\\r\\n\\r\\ncontract StakingPool is Configurable, StakingRewards {\\r\\n    using Address for address payable;\\r\\n    \\r\\n    bytes32 internal constant _ecoAddr_         = \\u0027ecoAddr\\u0027;\\r\\n    bytes32 internal constant _ecoRatio_        = \\u0027ecoRatio\\u0027;\\r\\n\\tbytes32 internal constant _allowContract_   = \\u0027allowContract\\u0027;\\r\\n\\tbytes32 internal constant _allowlist_       = \\u0027allowlist\\u0027;\\r\\n\\tbytes32 internal constant _blocklist_       = \\u0027blocklist\\u0027;\\r\\n\\t\\r\\n\\tbytes32 internal constant _rewards2Token_   = \\u0027rewards2Token\\u0027;\\r\\n\\tbytes32 internal constant _rewards2Ratio_   = \\u0027rewards2Ratio\\u0027;\\r\\n\\t//bytes32 internal constant _rewards2Span_    = \\u0027rewards2Span\\u0027;\\r\\n\\tbytes32 internal constant _rewards2Begin_   = \\u0027rewards2Begin\\u0027;\\r\\n\\r\\n\\tuint public lep;            // 1: linear, 2: exponential, 3: power\\r\\n\\t//uint public period;         // obsolete\\r\\n\\tuint public begin;\\r\\n\\r\\n    mapping (address =\\u003e uint256) public paid;\\r\\n    \\r\\n    address swapFactory;\\r\\n    address[] pathTVL;\\r\\n    address[] pathAPY;\\r\\n\\r\\n    function __StakingPool_init(address _governor, \\r\\n        address _rewardsDistribution,\\r\\n        address _rewardsToken,\\r\\n        address _stakingToken,\\r\\n        address _ecoAddr\\r\\n    ) public virtual initializer {\\r\\n\\t    __ReentrancyGuard_init_unchained();\\r\\n\\t    __Governable_init_unchained(_governor);\\r\\n        //__StakingRewards_init_unchained(_rewardsDistribution, _rewardsToken, _stakingToken);\\r\\n        __StakingPool_init_unchained(_rewardsDistribution, _rewardsToken, _stakingToken, _ecoAddr);\\r\\n    }\\r\\n\\r\\n    function __StakingPool_init_unchained(address _rewardsDistribution, address _rewardsToken, address _stakingToken, address _ecoAddr) public virtual governance {\\r\\n        rewardsToken = IERC20(_rewardsToken);\\r\\n        stakingToken = IERC20(_stakingToken);\\r\\n        rewardsDistribution = _rewardsDistribution;\\r\\n        config[_ecoAddr_] = uint(_ecoAddr);\\r\\n        config[_ecoRatio_] = 0.1 ether;\\r\\n    }\\r\\n\\r\\n    function notifyRewardBegin(uint _lep, /*uint _period,*/ uint _span, uint _begin) virtual public governance updateReward(address(0)) {\\r\\n        lep             = _lep;         // 1: linear, 2: exponential, 3: power\\r\\n        //period          = _period;\\r\\n        rewardsDuration = _span;\\r\\n        begin           = _begin;\\r\\n        periodFinish    = _begin.add(_span);\\r\\n    }\\r\\n    \\r\\n    function notifyReward2(address _rewards2Token, uint _ratio, /*uint _span,*/ uint _begin) virtual external governance updateReward(address(0)) {\\r\\n        config[_rewards2Token_] = uint(_rewards2Token);\\r\\n        config[_rewards2Ratio_] = _ratio;\\r\\n        //config[_rewards2Span_]  = _span;\\r\\n        config[_rewards2Begin_] = _begin;\\r\\n    }\\r\\n\\r\\n    function rewardQuota() public view returns (uint amt) {\\r\\n        address mine = rewardsDistribution == address(0) ? address(this) : rewardsDistribution;\\r\\n        amt = rewardsToken.balanceOf(mine);\\r\\n        if(mine != address(this))\\r\\n            amt = Math.min(rewardsToken.allowance(mine, address(this)), amt);\\r\\n        amt = amt.sub0(rewards[address(0)]);\\r\\n    }\\r\\n    \\r\\n    function rewardDelta() public view returns (uint amt) {\\r\\n        if(begin == 0 || begin \\u003e= now || lastUpdateTime \\u003e= now)\\r\\n            return 0;\\r\\n            \\r\\n        amt = rewardQuota();\\r\\n        \\r\\n        // calc rewardDelta in period\\r\\n        if(lep == 3) {                                                              // power\\r\\n            //uint y = period.mul(1 ether).div(lastUpdateTime.add(rewardsDuration).sub(begin));\\r\\n            //uint amt1 = amt.mul(1 ether).div(y);\\r\\n            //uint amt2 = amt1.mul(period).div(now.add(rewardsDuration).sub(begin));\\r\\n            uint amt2 = amt.mul(lastUpdateTime.add(rewardsDuration).sub(begin)).div(now.add(rewardsDuration).sub(begin));\\r\\n            amt = amt.sub(amt2);\\r\\n        } else if(lep == 2) {                                                       // exponential\\r\\n            if(now.sub(lastUpdateTime) \\u003c rewardsDuration)\\r\\n                amt = amt.mul(now.sub(lastUpdateTime)).div(rewardsDuration);\\r\\n        }else if(now \\u003c periodFinish)                                                // linear\\r\\n            amt = amt.mul(now.sub(lastUpdateTime)).div(periodFinish.sub(lastUpdateTime));\\r\\n        else if(lastUpdateTime \\u003e= periodFinish)\\r\\n            amt = 0;\\r\\n            \\r\\n        if(config[_ecoAddr_] != 0)\\r\\n            amt = amt.mul(uint(1e18).sub(config[_ecoRatio_])).div(1 ether);\\r\\n    }\\r\\n    \\r\\n    function rewardPerToken() virtual override public view returns (uint256) {\\r\\n        if (_totalSupply == 0) {\\r\\n            return rewardPerTokenStored;\\r\\n        }\\r\\n        return\\r\\n            rewardPerTokenStored.add(\\r\\n                rewardDelta().mul(1e18).div(_totalSupply)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function earned(address account) virtual override public view returns (uint256 amt) {\\r\\n        return Math.min(super.earned(account), rewardQuota());\\r\\n\\t}    \\r\\n\\t\\r\\n    modifier updateReward(address account) override {\\r\\n        rewardPerTokenStored = rewardPerToken();\\r\\n        uint delta = rewardDelta();\\r\\n        {\\r\\n            address addr = address(config[_ecoAddr_]);\\r\\n            uint ratio = config[_ecoRatio_];\\r\\n            if(addr != address(0) \\u0026\\u0026 ratio != 0) {\\r\\n                uint d = delta.mul(ratio).div(uint(1e18).sub(ratio));\\r\\n                rewards[addr] = rewards[addr].add(d);\\r\\n                delta = delta.add(d);\\r\\n            }\\r\\n        }\\r\\n        rewards[address(0)] = rewards[address(0)].add(delta);\\r\\n        lastUpdateTime = now;\\r\\n        if (account != address(0)) {\\r\\n            rewards[account] = earned(account);\\r\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function getReward() virtual override public {\\r\\n        getRewardA(msg.sender);\\r\\n    }\\r\\n    function getRewardA(address payable acct) virtual public nonReentrant updateReward(acct) {\\r\\n        require(getConfigA(_blocklist_, acct) == 0, \\u0027In blocklist\\u0027);\\r\\n        bool isContract = acct.isContract();\\r\\n        require(!isContract || config[_allowContract_] != 0 || getConfigA(_allowlist_, acct) != 0, \\u0027No allowContract\\u0027);\\r\\n\\r\\n        uint256 reward = rewards[acct];\\r\\n        if (reward \\u003e 0) {\\r\\n            rewards[acct] = 0;\\r\\n            rewards[address(0)] = rewards[address(0)].sub0(reward);\\r\\n            if(rewardsDistribution == address(this) || rewardsDistribution == address(0))\\r\\n                rewardsToken.safeTransfer(acct, reward);\\r\\n            else\\r\\n                rewardsToken.safeTransferFrom(rewardsDistribution, acct, reward);\\r\\n            emit RewardPaid(acct, reward);\\r\\n            \\r\\n            if(config[_rewards2Token_] != 0 \\u0026\\u0026 config[_rewards2Begin_] \\u003c= now) {\\r\\n                uint reward2 = Math.min(reward.mul(config[_rewards2Ratio_]).div(1e18), IERC20(config[_rewards2Token_]).balanceOf(address(this)));\\r\\n                IERC20(config[_rewards2Token_]).safeTransfer(acct, reward2);\\r\\n                emit RewardPaid2(acct, reward2);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    event RewardPaid2(address indexed user, uint256 reward2);\\r\\n\\r\\n    //function compound() virtual public nonReentrant updateReward(msg.sender) {      // only for pool3\\r\\n    //    require(getConfigA(_blocklist_, msg.sender) == 0, \\u0027In blocklist\\u0027);\\r\\n    //    bool isContract = msg.sender.isContract();\\r\\n    //    require(!isContract || config[_allowContract_] != 0 || getConfigA(_allowlist_, msg.sender) != 0, \\u0027No allowContract\\u0027);\\r\\n    //    require(stakingToken == rewardsToken, \\u0027not pool3\\u0027);\\r\\n    //\\r\\n    //    uint reward = rewards[msg.sender];\\r\\n    //    if (reward \\u003e 0) {\\r\\n    //        rewards[msg.sender] = 0;\\r\\n    //        rewards[address(0)] = rewards[address(0)].sub0(reward);\\r\\n    //        rewardsToken.safeTransferFrom(rewardsDistribution, address(this), reward);\\r\\n    //        emit RewardPaid(msg.sender, reward);\\r\\n    //        \\r\\n    //        _totalSupply = _totalSupply.add(reward);\\r\\n    //        _balances[msg.sender] = _balances[msg.sender].add(reward);\\r\\n    //        emit Staked(msg.sender, reward);\\r\\n    //    }\\r\\n    //}\\r\\n\\r\\n    function getRewardForDuration() override external view returns (uint256) {\\r\\n        return rewardsToken.allowance(rewardsDistribution, address(this)).sub0(rewards[address(0)]);\\r\\n    }\\r\\n    \\r\\n    function rewards2Token() virtual external view returns (address) {\\r\\n        return address(config[_rewards2Token_]);\\r\\n    }\\r\\n    \\r\\n    function rewards2Ratio() virtual external view returns (uint) {\\r\\n        return config[_rewards2Ratio_];\\r\\n    }\\r\\n    \\r\\n    function setPath(address swapFactory_, address[] memory pathTVL_, address[] memory pathAPY_) virtual external governance {\\r\\n        uint m = pathTVL_.length;\\r\\n        uint n = pathAPY_.length;\\r\\n        require(m \\u003e 0 \\u0026\\u0026 n \\u003e 0 \\u0026\\u0026 pathTVL_[m-1] == pathAPY_[n-1]);\\r\\n        for(uint i=0; i\\u003cm-1; i++)\\r\\n            require(address(0) != IUniswapV2Factory(swapFactory_).getPair(pathTVL_[i], pathTVL_[i+1]));\\r\\n        for(uint i=0; i\\u003cn-1; i++)\\r\\n            require(address(0) != IUniswapV2Factory(swapFactory_).getPair(pathAPY_[i], pathAPY_[i+1]));\\r\\n            \\r\\n        swapFactory = swapFactory_;\\r\\n        pathTVL = pathTVL_;\\r\\n        pathAPY = pathAPY_;\\r\\n    }\\r\\n    \\r\\n    function lptValueTotal() virtual public view returns (uint) {\\r\\n        require(pathTVL.length \\u003e 0 \\u0026\\u0026 pathTVL[0] != address(stakingToken));\\r\\n        return IERC20(pathTVL[0]).balanceOf(address(stakingToken)).mul(2);\\r\\n    }\\r\\n    \\r\\n    function lptValue(uint vol) virtual public view returns (uint) {\\r\\n        return lptValueTotal().mul(vol).div(IERC20(stakingToken).totalSupply());\\r\\n    }\\r\\n    \\r\\n    function swapValue(uint vol, address[] memory path) virtual public view returns (uint v) {\\r\\n        v = vol;\\r\\n        for(uint i=0; i\\u003cpath.length-1; i++) {\\r\\n            (uint reserve0, uint reserve1,) = IUniswapV2Pair(IUniswapV2Factory(swapFactory).getPair(path[i], path[i+1])).getReserves();\\r\\n            v =  path[i+1] \\u003c path[i] ? v.mul(reserve0) / reserve1 : v.mul(reserve1) / reserve0;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function TVL() virtual public view returns (uint tvl) {\\r\\n        if(pathTVL[0] != address(stakingToken))\\r\\n            tvl = lptValueTotal();\\r\\n        else\\r\\n            tvl = totalSupply();\\r\\n        tvl = swapValue(tvl, pathTVL);\\r\\n    }\\r\\n    \\r\\n    function APY() virtual public view returns (uint) {\\r\\n        uint amt = rewardQuota();\\r\\n        \\r\\n        if(lep == 3) {                                                              // power\\r\\n            uint amt2 = amt.mul(365 days).mul(now.add(rewardsDuration).sub(begin)).div(now.add(1).add(rewardsDuration).sub(begin));\\r\\n            amt = amt.sub(amt2);\\r\\n        } else if(lep == 2) {                                                       // exponential\\r\\n            amt = amt.mul(365 days).div(rewardsDuration);\\r\\n        }else if(now \\u003c periodFinish)                                                // linear\\r\\n            amt = amt.mul(365 days).div(periodFinish.sub(lastUpdateTime));\\r\\n        else if(lastUpdateTime \\u003e= periodFinish)\\r\\n            amt = 0;\\r\\n        \\r\\n        require(address(rewardsToken) == pathAPY[0]);\\r\\n        amt = swapValue(amt, pathAPY);\\r\\n        return amt.mul(1e18).div(TVL());\\r\\n    }\\r\\n\\r\\n    // Reserved storage space to allow for layout changes in the future.\\r\\n    uint256[50] private ______gap;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n}\\r\\n\\r\\ninterface IWETH is IERC20 {\\r\\n    function deposit() external payable;\\r\\n    function withdraw(uint) external;\\r\\n}\\r\\n\\r\\ncontract EthPool is StakingPool {\\r\\n    bytes32 internal constant _WETH_\\t\\t\\t= \\u0027WETH\\u0027;\\r\\n\\r\\n    function __EthPool_init(address _governor, \\r\\n        address _rewardsDistribution,\\r\\n        address _rewardsToken,\\r\\n        address _stakingToken,\\r\\n        address _ecoAddr,\\r\\n\\t\\taddress _WETH\\r\\n    ) public virtual initializer {\\r\\n\\t    __ReentrancyGuard_init_unchained();\\r\\n\\t    __Governable_init_unchained(_governor);\\r\\n        //__StakingRewards_init_unchained(_rewardsDistribution, _rewardsToken, _stakingToken);\\r\\n        __StakingPool_init_unchained(_rewardsDistribution, _rewardsToken, _stakingToken, _ecoAddr);\\r\\n\\t\\t__EthPool_init_unchained(_WETH);\\r\\n    }\\r\\n\\r\\n    function __EthPool_init_unchained(address _WETH) public virtual governance {\\r\\n        config[_WETH_] = uint(_WETH);\\r\\n    }\\r\\n\\r\\n    function stakeEth() virtual public payable nonReentrant updateReward(msg.sender) {\\r\\n        require(address(stakingToken) == address(config[_WETH_]), \\u0027stakingToken is not WETH\\u0027);\\r\\n        uint amount = msg.value;\\r\\n        require(amount \\u003e 0, \\\"Cannot stake 0\\\");\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\\r\\n        IWETH(address(stakingToken)).deposit{value: amount}();                   //stakingToken.safeTransferFrom(msg.sender, address(this), amount);\\r\\n        emit Staked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function withdrawEth(uint256 amount) virtual public nonReentrant updateReward(msg.sender) {\\r\\n        require(address(stakingToken) == address(config[_WETH_]), \\u0027stakingToken is not WETH\\u0027);\\r\\n        require(amount \\u003e 0, \\\"Cannot withdraw 0\\\");\\r\\n        _totalSupply = _totalSupply.sub(amount);\\r\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\r\\n        IWETH(address(stakingToken)).withdraw(amount);                           //stakingToken.safeTransfer(msg.sender, amount);\\r\\n        msg.sender.transfer(amount);\\r\\n        emit Withdrawn(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function exitEth() virtual public {\\r\\n        withdrawEth(_balances[msg.sender]);\\r\\n        getReward();\\r\\n    }\\r\\n    \\r\\n    receive () payable external {\\r\\n        stakeEth();\\r\\n    }\\r\\n\\r\\n    // Reserved storage space to allow for layout changes in the future.\\r\\n    uint256[50] private ______gap;\\r\\n}\\r\\n\\r\\ncontract DoublePool is StakingPool {\\r\\n    IStakingRewards public stakingPool2;\\r\\n    IERC20 public rewardsToken2;\\r\\n    //uint256 public lastUpdateTime2;                                 // obsoleted\\r\\n    //uint256 public rewardPerTokenStored2;                           // obsoleted\\r\\n    mapping(address =\\u003e uint256) public userRewardPerTokenPaid2;\\r\\n    mapping(address =\\u003e uint256) public rewards2;\\r\\n\\r\\n    function __DoublePool_init(address _governor, address _rewardsDistribution, address _rewardsToken, address _stakingToken, address _ecoAddr, address _stakingPool2, address _rewardsToken2) public initializer {\\r\\n\\t    __ReentrancyGuard_init_unchained();\\r\\n\\t    __Governable_init_unchained(_governor);\\r\\n\\t    //__StakingRewards_init_unchained(_rewardsDistribution, _rewardsToken, _stakingToken);\\r\\n\\t    __StakingPool_init_unchained(_rewardsDistribution, _rewardsToken, _stakingToken, _ecoAddr);\\r\\n\\t    __DoublePool_init_unchained(_stakingPool2, _rewardsToken2);\\r\\n\\t}\\r\\n    \\r\\n    function __DoublePool_init_unchained(address _stakingPool2, address _rewardsToken2) public governance {\\r\\n\\t    stakingPool2 = IStakingRewards(_stakingPool2);\\r\\n\\t    rewardsToken2 = IERC20(_rewardsToken2);\\r\\n\\t}\\r\\n    \\r\\n    function notifyRewardBegin(uint _lep, /*uint _period,*/ uint _span, uint _begin) virtual override public governance updateReward2(address(0)) {\\r\\n        super.notifyRewardBegin(_lep, /*_period,*/ _span, _begin);\\r\\n    }\\r\\n    \\r\\n    function stake(uint amount) virtual override public updateReward2(msg.sender) {\\r\\n        super.stake(amount);\\r\\n        stakingToken.safeApprove(address(stakingPool2), amount);\\r\\n        stakingPool2.stake(amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint amount) virtual override public updateReward2(msg.sender) {\\r\\n        stakingPool2.withdraw(amount);\\r\\n        super.withdraw(amount);\\r\\n    }\\r\\n    \\r\\n    function getReward2() virtual public nonReentrant updateReward2(msg.sender) {\\r\\n        uint256 reward2 = rewards2[msg.sender];\\r\\n        if (reward2 \\u003e 0) {\\r\\n            rewards2[msg.sender] = 0;\\r\\n            stakingPool2.getReward();\\r\\n            rewardsToken2.safeTransfer(msg.sender, reward2);\\r\\n            emit RewardPaid2(msg.sender, reward2);\\r\\n        }\\r\\n    }\\r\\n    event RewardPaid2(address indexed user, uint256 reward2);\\r\\n\\r\\n    function getDoubleReward() virtual public {\\r\\n        getReward();\\r\\n        getReward2();\\r\\n    }\\r\\n    \\r\\n    function exit() override public {\\r\\n        super.exit();\\r\\n        getReward2();\\r\\n    }\\r\\n    \\r\\n    function rewardPerToken2() virtual public view returns (uint256) {\\r\\n        return stakingPool2.rewardPerToken();\\r\\n    }\\r\\n\\r\\n    function earned2(address account) virtual public view returns (uint256) {\\r\\n        return _balances[account].mul(rewardPerToken2().sub(userRewardPerTokenPaid2[account])).div(1e18).add(rewards2[account]);\\r\\n    }\\r\\n\\r\\n    modifier updateReward2(address account) virtual {\\r\\n        if (account != address(0)) {\\r\\n            rewards2[account] = earned2(account);\\r\\n            userRewardPerTokenPaid2[account] = rewardPerToken2();\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Reserved storage space to allow for layout changes in the future.\\r\\n    uint256[50] private ______gap;\\r\\n}\\r\\n\\r\\n\\r\\ninterface IMasterChef {\\r\\n    function poolInfo(uint pid) external view returns (address lpToken, uint allocPoint, uint lastRewardBlock, uint accCakePerShare);\\r\\n    function userInfo(uint pid, address user) external view returns (uint amount, uint rewardDebt);\\r\\n    function pending(uint pid, address user) external view returns (uint);\\r\\n    function pendingCake(uint pid, address user) external view returns (uint);\\r\\n    function deposit(uint pid, uint amount) external;\\r\\n    function withdraw(uint pid, uint amount) external;\\r\\n}\\r\\n\\r\\ncontract NestMasterChef is StakingPool {\\r\\n    IERC20 internal constant Cake = IERC20(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\\r\\n    \\r\\n    IMasterChef public stakingPool2;\\r\\n    IERC20 public rewardsToken2;\\r\\n    mapping(address =\\u003e uint256) public userRewardPerTokenPaid2;\\r\\n    mapping(address =\\u003e uint256) public rewards2;\\r\\n    uint public pid2;\\r\\n    uint internal _rewardPerToken2;\\r\\n\\r\\n    function __NestMasterChef_init(address _governor, address _rewardsDistribution, address _rewardsToken, address _stakingToken, address _ecoAddr, address _stakingPool2, address _rewardsToken2, uint _pid2) public initializer {\\r\\n\\t    __Governable_init_unchained(_governor);\\r\\n        __ReentrancyGuard_init_unchained();\\r\\n        //__StakingRewards_init_unchained(_rewardsDistribution, _rewardsToken, _stakingToken);\\r\\n        __StakingPool_init_unchained(_rewardsDistribution, _rewardsToken, _stakingToken, _ecoAddr);\\r\\n        __NestMasterChef_init_unchained(_stakingPool2, _rewardsToken2, _pid2);\\r\\n\\t}\\r\\n\\r\\n    function __NestMasterChef_init_unchained(address _stakingPool2, address _rewardsToken2, uint _pid2) public governance {\\r\\n\\t    stakingPool2 = IMasterChef(_stakingPool2);\\r\\n\\t    rewardsToken2 = IERC20(_rewardsToken2);\\r\\n\\t    pid2 = _pid2;\\r\\n    }\\r\\n    \\r\\n    function notifyRewardBegin(uint _lep, /*uint _period,*/ uint _span, uint _begin) virtual override public governance updateReward2(address(0)) {\\r\\n        super.notifyRewardBegin(_lep, /*_period,*/ _span, _begin);\\r\\n    }\\r\\n    \\r\\n    function migrate() virtual public governance updateReward2(address(0)) {\\r\\n        uint total = stakingToken.balanceOf(address(this));\\r\\n        stakingToken.approve(address(stakingPool2), total);\\r\\n        stakingPool2.deposit(pid2, total);\\r\\n    }        \\r\\n    \\r\\n    function stake(uint amount) virtual override public updateReward2(msg.sender) {\\r\\n        super.stake(amount);\\r\\n        stakingToken.approve(address(stakingPool2), amount);\\r\\n        stakingPool2.deposit(pid2, amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint amount) virtual override public updateReward2(msg.sender) {\\r\\n        stakingPool2.withdraw(pid2, amount);\\r\\n        super.withdraw(amount);\\r\\n    }\\r\\n    \\r\\n    function getReward2() virtual public nonReentrant updateReward2(msg.sender) {\\r\\n        uint256 reward2 = rewards2[msg.sender];\\r\\n        if (reward2 \\u003e 0) {\\r\\n            rewards2[msg.sender] = 0;\\r\\n            rewardsToken2.safeTransfer(msg.sender, reward2);\\r\\n            emit RewardPaid2(msg.sender, reward2);\\r\\n        }\\r\\n    }\\r\\n    event RewardPaid2(address indexed user, uint256 reward2);\\r\\n\\r\\n    function getDoubleReward() virtual public {\\r\\n        getReward();\\r\\n        getReward2();\\r\\n    }\\r\\n    \\r\\n    function exit() virtual override public {\\r\\n        super.exit();\\r\\n        getReward2();\\r\\n    }\\r\\n    \\r\\n    function rewardPerToken2() virtual public view returns (uint256) {\\r\\n        if(_totalSupply == 0)\\r\\n            return _rewardPerToken2;\\r\\n        else if(rewardsToken2 == Cake)\\r\\n            return stakingPool2.pendingCake(pid2, address(this)).mul(1e18).div(_totalSupply).add(_rewardPerToken2);\\r\\n        else\\r\\n            return stakingPool2.pending(pid2, address(this)).mul(1e18).div(_totalSupply).add(_rewardPerToken2);\\r\\n    }\\r\\n\\r\\n    function earned2(address account) virtual public view returns (uint256) {\\r\\n        return _balances[account].mul(rewardPerToken2().sub(userRewardPerTokenPaid2[account])).div(1e18).add(rewards2[account]);\\r\\n    }\\r\\n\\r\\n    modifier updateReward2(address account) virtual {\\r\\n        if(_totalSupply \\u003e 0) {\\r\\n            uint delta = rewardsToken2.balanceOf(address(this));\\r\\n            stakingPool2.deposit(pid2, 0);\\r\\n            delta = rewardsToken2.balanceOf(address(this)).sub(delta);\\r\\n            _rewardPerToken2 = delta.mul(1e18).div(_totalSupply).add(_rewardPerToken2);\\r\\n        }\\r\\n        \\r\\n        if (account != address(0)) {\\r\\n            rewards2[account] = earned2(account);\\r\\n            userRewardPerTokenPaid2[account] = _rewardPerToken2;\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\\r\\ncontract IioPoolV2 is StakingPool {         // support multi IIO at the same time\\r\\n    //address internal constant HelmetAddress = 0x948d2a81086A075b3130BAc19e4c6DEe1D2E3fE8;\\r\\n    address internal constant BurnAddress   = 0x000000000000000000000000000000000000dEaD;\\r\\n\\r\\n    uint private __lastUpdateTime3;                             // obsolete\\r\\n    IERC20 private __rewardsToken3;                             // obsolete\\r\\n    mapping(IERC20 =\\u003e uint) public totalSupply3;                                    // rewardsToken3 =\\u003e totalSupply3\\r\\n    mapping(IERC20 =\\u003e uint) internal _rewardPerToken3;                              // rewardsToken3 =\\u003e _rewardPerToken3\\r\\n    mapping(IERC20 =\\u003e uint) public begin3;                                          // rewardsToken3 =\\u003e begin3\\r\\n    mapping(IERC20 =\\u003e uint) public end3;                                            // rewardsToken3 =\\u003e end3\\r\\n    mapping(IERC20 =\\u003e uint) public claimTime3;                                      // rewardsToken3 =\\u003e claimTime3\\r\\n    mapping(IERC20 =\\u003e uint) public ticketVol3;                                      // rewardsToken3 =\\u003e ticketVol3\\r\\n    mapping(IERC20 =\\u003e IERC20)  public ticketToken3;                                 // rewardsToken3 =\\u003e ticketToken3\\r\\n    mapping(IERC20 =\\u003e address) public ticketRecipient3;                             // rewardsToken3 =\\u003e ticketRecipient3\\r\\n\\r\\n    mapping(IERC20 =\\u003e mapping(address =\\u003e bool)) public applied3;                    // rewardsToken3 =\\u003e acct =\\u003e applied3\\r\\n    mapping(IERC20 =\\u003e mapping(address =\\u003e uint)) public userRewardPerTokenPaid3;     // rewardsToken3 =\\u003e acct =\\u003e paid3\\r\\n    mapping(IERC20 =\\u003e mapping(address =\\u003e uint)) public rewards3;                    // rewardsToken3 =\\u003e acct =\\u003e rewards3\\r\\n    \\r\\n    mapping(IERC20 =\\u003e uint) public lastUpdateTime3;                                 // rewardsToken3 =\\u003e lastUpdateTime3\\r\\n    IERC20[] public all;                                                            // all rewardsToken3\\r\\n    IERC20[] public active;                                                         // active rewardsToken3\\r\\n    \\r\\n    //function setReward3BurnHelmet(IERC20 rewardsToken3_, uint begin3_, uint end3_, uint claimTime3_, uint ticketVol3_) virtual external {\\r\\n    //    setReward3(rewardsToken3_, begin3_, end3_, claimTime3_, ticketVol3_, IERC20(HelmetAddress), BurnAddress);\\r\\n    //}\\r\\n    function setReward3(IERC20 rewardsToken3_, uint begin3_, uint end3_, uint claimTime3_, uint ticketVol3_, IERC20 ticketToken3_, address ticketRecipient3_) virtual public governance {\\r\\n        lastUpdateTime3     [rewardsToken3_]= begin3_;\\r\\n        //rewardsToken3       = rewardsToken3_;\\r\\n        begin3              [rewardsToken3_] = begin3_;\\r\\n        end3                [rewardsToken3_] = end3_;\\r\\n        claimTime3          [rewardsToken3_] = claimTime3_;\\r\\n        ticketVol3          [rewardsToken3_] = ticketVol3_;\\r\\n        ticketToken3        [rewardsToken3_] = ticketToken3_;\\r\\n        ticketRecipient3    [rewardsToken3_] = ticketRecipient3_;\\r\\n        \\r\\n        uint i=0;\\r\\n        for(; i\\u003call.length; i++)\\r\\n            if(all[i] == rewardsToken3_)\\r\\n                break;\\r\\n        if(i\\u003e=all.length)\\r\\n            all.push(rewardsToken3_);\\r\\n            \\r\\n        i=0;\\r\\n        for(; i\\u003cactive.length; i++)\\r\\n            if(active[i] == rewardsToken3_)\\r\\n                break;\\r\\n        if(i\\u003e=active.length)\\r\\n            active.push(rewardsToken3_);\\r\\n            \\r\\n        emit SetReward3(rewardsToken3_, begin3_, end3_, claimTime3_, ticketVol3_, ticketToken3_, ticketRecipient3_);\\r\\n    }\\r\\n    event SetReward3(IERC20 indexed rewardsToken3_, uint begin3_, uint end3_, uint claimTime3_, uint ticketVol3_, IERC20 indexed ticketToken3_, address indexed ticketRecipient3_);\\r\\n    \\r\\n    //function deactive(IERC20 rewardsToken3_) virtual public governance {\\r\\n    //    for(uint i=0; i\\u003cactive.length; i++)\\r\\n    //        if(active[i] == rewardsToken3_) {\\r\\n    //            active[i] = active[active.length-1];\\r\\n    //            active.pop();\\r\\n    //            emit Deactive(rewardsToken3_);\\r\\n    //            return;\\r\\n    //        }\\r\\n    //    revert(\\u0027not found active rewardsToken3_\\u0027);\\r\\n    //}\\r\\n    //event Deactive(IERC20 indexed rewardsToken3_);\\r\\n\\r\\n    function applyReward3(IERC20 rewardsToken3_) virtual public updateReward3(rewardsToken3_, msg.sender) {\\r\\n        //IERC20 rewardsToken3_ = rewardsToken3;                                          // save gas\\r\\n        require(!applied3[rewardsToken3_][msg.sender], \\u0027applied already\\u0027);\\r\\n        require(now \\u003c end3[rewardsToken3_], \\u0027expired\\u0027);\\r\\n        \\r\\n        IERC20 ticketToken3_ = ticketToken3[rewardsToken3_];                            // save gas\\r\\n        if(address(ticketToken3_) != address(0))\\r\\n            ticketToken3_.safeTransferFrom(msg.sender, ticketRecipient3[rewardsToken3_], ticketVol3[rewardsToken3_]);\\r\\n        applied3[rewardsToken3_][msg.sender] = true;\\r\\n        userRewardPerTokenPaid3[rewardsToken3_][msg.sender] = _rewardPerToken3[rewardsToken3_];\\r\\n        totalSupply3[rewardsToken3_] = totalSupply3[rewardsToken3_].add(_balances[msg.sender]);\\r\\n        emit ApplyReward3(msg.sender, rewardsToken3_);\\r\\n    }\\r\\n    event ApplyReward3(address indexed acct, IERC20 indexed rewardsToken3);\\r\\n    \\r\\n    function rewardDelta3(IERC20 rewardsToken3_) virtual public view returns (uint amt) {\\r\\n        //IERC20 rewardsToken3_ = rewardsToken3;                                          // save gas\\r\\n        uint lastUpdateTime3_ = lastUpdateTime3[rewardsToken3_];                        // save gas\\r\\n        if(begin3[rewardsToken3_] == 0 || begin3[rewardsToken3_] \\u003e= now || lastUpdateTime3_ \\u003e= now)\\r\\n            return 0;\\r\\n            \\r\\n        amt = Math.min(rewardsToken3_.allowance(rewardsDistribution, address(this)), rewardsToken3_.balanceOf(rewardsDistribution)).sub0(rewards3[rewardsToken3_][address(0)]);\\r\\n        \\r\\n        uint end3_ = end3[rewardsToken3_];                                              // save gas\\r\\n        if(now \\u003c end3_)\\r\\n            amt = amt.mul(now.sub(lastUpdateTime3_)).div(end3_.sub(lastUpdateTime3_));\\r\\n        else if(lastUpdateTime3_ \\u003e= end3_)\\r\\n            amt = 0;\\r\\n            \\r\\n        if(config[_ecoAddr_] != 0)\\r\\n            amt = amt.mul(uint(1e18).sub(config[_ecoRatio_])).div(1 ether);\\r\\n    }\\r\\n    \\r\\n    function rewardPerToken3(IERC20 rewardsToken3_) virtual public view returns (uint) {\\r\\n        if (totalSupply3[rewardsToken3_] == 0) {\\r\\n            return _rewardPerToken3[rewardsToken3_];\\r\\n        }\\r\\n        return\\r\\n            _rewardPerToken3[rewardsToken3_].add(\\r\\n                rewardDelta3(rewardsToken3_).mul(1e18).div(totalSupply3[rewardsToken3_])\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function earned3(IERC20 rewardsToken3_, address account) virtual public view returns (uint) {\\r\\n        if(!applied3[rewardsToken3_][account])\\r\\n            return 0;\\r\\n        return Math.min(rewardsToken3_.balanceOf(rewardsDistribution), _balances[account].mul(rewardPerToken3(rewardsToken3_).sub(userRewardPerTokenPaid3[rewardsToken3_][account])).div(1e18).add(rewards3[rewardsToken3_][account]));\\r\\n    }\\r\\n\\r\\n    function _updateReward3(IERC20 rewardsToken3_, address account) virtual internal {\\r\\n        bool applied3_ = applied3[rewardsToken3_][account];                             // save gas\\r\\n        if(account == address(0) || applied3_) {\\r\\n            _rewardPerToken3[rewardsToken3_] = rewardPerToken3(rewardsToken3_);\\r\\n            uint delta = rewardDelta3(rewardsToken3_);\\r\\n            {\\r\\n                address addr = address(config[_ecoAddr_]);\\r\\n                uint ratio = config[_ecoRatio_];\\r\\n                if(addr != address(0) \\u0026\\u0026 ratio != 0) {\\r\\n                    uint d = delta.mul(ratio).div(uint(1e18).sub(ratio));\\r\\n                    rewards3[rewardsToken3_][addr] = rewards3[rewardsToken3_][addr].add(d);\\r\\n                    delta = delta.add(d);\\r\\n                }\\r\\n            }\\r\\n            rewards3[rewardsToken3_][address(0)] = rewards3[rewardsToken3_][address(0)].add(delta);\\r\\n            lastUpdateTime3[rewardsToken3_] = Math.max(begin3[rewardsToken3_], Math.min(now, end3[rewardsToken3_]));\\r\\n        }\\r\\n        if (account != address(0) \\u0026\\u0026 applied3_) {\\r\\n            rewards3[rewardsToken3_][account] = earned3(rewardsToken3_, account);\\r\\n            userRewardPerTokenPaid3[rewardsToken3_][account] = _rewardPerToken3[rewardsToken3_];\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    modifier updateReward3(IERC20 rewardsToken3_, address account) virtual {\\r\\n        _updateReward3(rewardsToken3_, account);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function stake(uint amount) virtual override public {\\r\\n        super.stake(amount);\\r\\n        for(uint i=0; i\\u003cactive.length; i++) {\\r\\n            IERC20 rewardsToken3_ = active[i];                                          // save gas\\r\\n            _updateReward3(rewardsToken3_, msg.sender);\\r\\n            if(applied3[rewardsToken3_][msg.sender])\\r\\n                totalSupply3[rewardsToken3_] = totalSupply3[rewardsToken3_].add(amount);\\r\\n        }    \\r\\n    }\\r\\n\\r\\n    function withdraw(uint amount) virtual override public {\\r\\n        for(uint i=0; i\\u003cactive.length; i++) {\\r\\n            IERC20 rewardsToken3_ = active[i];                                          // save gas\\r\\n            _updateReward3(rewardsToken3_, msg.sender);\\r\\n            if(applied3[rewardsToken3_][msg.sender])\\r\\n                totalSupply3[rewardsToken3_] = totalSupply3[rewardsToken3_].sub(amount);\\r\\n        }\\r\\n        super.withdraw(amount);\\r\\n    }\\r\\n    \\r\\n    function getReward3(IERC20 rewardsToken3_) virtual public nonReentrant updateReward3(rewardsToken3_, msg.sender) {\\r\\n        require(getConfigA(_blocklist_, msg.sender) == 0, \\u0027In blocklist\\u0027);\\r\\n        bool isContract = msg.sender.isContract();\\r\\n        require(!isContract || config[_allowContract_] != 0 || getConfigA(_allowlist_, msg.sender) != 0, \\u0027No allowContract\\u0027);\\r\\n\\r\\n        //IERC20 rewardsToken3_ = rewardsToken3;                                          // save gas\\r\\n        require(now \\u003e= claimTime3[rewardsToken3_], \\\"it\\u0027s not time yet\\\");\\r\\n        uint256 reward3 = rewards3[rewardsToken3_][msg.sender];\\r\\n        if (reward3 \\u003e 0) {\\r\\n            rewards3[rewardsToken3_][msg.sender] = 0;\\r\\n            rewards3[rewardsToken3_][address(0)] = rewards3[rewardsToken3_][address(0)].sub0(reward3);\\r\\n            rewardsToken3_.safeTransferFrom(rewardsDistribution, msg.sender, reward3);\\r\\n            emit RewardPaid3(msg.sender, rewardsToken3_, reward3);\\r\\n        }\\r\\n    }\\r\\n    event RewardPaid3(address indexed user, IERC20 indexed rewardsToken3_, uint256 reward3);\\r\\n    \\r\\n    uint[47] private __gap;\\r\\n}\\r\\n\\r\\ncontract NestMasterChefIioV2 is NestMasterChef, IioPoolV2 {\\r\\n    function notifyRewardBegin(uint _lep, /*uint _period,*/ uint _span, uint _begin) virtual override(StakingPool, NestMasterChef) public {\\r\\n        NestMasterChef.notifyRewardBegin(_lep, /*_period,*/ _span, _begin);\\r\\n    }\\r\\n    \\r\\n    function stake(uint amount) virtual override(NestMasterChef, IioPoolV2) public {\\r\\n        super.stake(amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(uint amount) virtual override(NestMasterChef, IioPoolV2) public {\\r\\n        super.withdraw(amount);\\r\\n    }\\r\\n    \\r\\n    function exit() virtual override(StakingRewards, NestMasterChef) public {\\r\\n        NestMasterChef.exit();\\r\\n    }\\r\\n    \\r\\n    \\r\\n    uint[50] private __gap;\\r\\n}\\r\\n    \\r\\ncontract BurningPool is StakingPool {\\r\\n    address internal constant BurnAddress   = 0x000000000000000000000000000000000000dEaD;\\r\\n    \\r\\n    function stake(uint256 amount) virtual override public {\\r\\n        super.stake(amount);\\r\\n        stakingToken.safeTransfer(BurnAddress, stakingToken.balanceOf(address(this)));\\r\\n    }\\r\\n\\r\\n    function withdraw(uint256) virtual override public {\\r\\n        revert(\\u0027Burned already, none to withdraw\\u0027);\\r\\n    }\\r\\n\\r\\n    // Reserved storage space to allow for layout changes in the future.\\r\\n    uint256[50] private ______gap;\\r\\n}\\r\\n\\r\\n\\r\\ncontract Mine is Governable {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    address public reward;\\r\\n    mapping (bytes32 =\\u003e address) public productImplementations;\\r\\n\\r\\n    function __Mine_init(address governor, address reward_) public initializer {\\r\\n        __Governable_init_unchained(governor);\\r\\n        __Mine_init_unchained(reward_);\\r\\n    }\\r\\n    \\r\\n    function __Mine_init_unchained(address reward_) public governance {\\r\\n        reward = reward_;\\r\\n    }\\r\\n    \\r\\n    function approvePool(address pool, uint amount) public governance {\\r\\n        IERC20(reward).approve(pool, amount);\\r\\n    }\\r\\n    \\r\\n    function approveToken(address token, address pool, uint amount) public governance {\\r\\n        IERC20(token).approve(pool, amount);\\r\\n    }\\r\\n    \\r\\n    function setProductImplementation(bytes32 name, address logic) public governance {\\r\\n        productImplementations[name] = logic;\\r\\n    }\\r\\n\\r\\n    // Reserved storage space to allow for layout changes in the future.\\r\\n    uint256[49] private ______gap;\\r\\n}\\r\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousGovernor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"GovernorshipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor_\",\"type\":\"address\"}],\"name\":\"__Governable_init_unchained\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"governor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reward_\",\"type\":\"address\"}],\"name\":\"__Mine_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reward_\",\"type\":\"address\"}],\"name\":\"__Mine_init_unchained\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approvePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"productImplementations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceGovernorship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reward\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"logic\",\"type\":\"address\"}],\"name\":\"setProductImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"transferGovernorship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Mine","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://927de28cb724c94b49d7f6be509abc2480bf6177ab396d6cf669130fe1990a8a"}]}