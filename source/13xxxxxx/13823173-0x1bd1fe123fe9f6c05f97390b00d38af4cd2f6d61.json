{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Hive.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./ICryptoBees.sol\\\";\\nimport \\\"./IHoney.sol\\\";\\nimport \\\"./IHive.sol\\\";\\nimport \\\"./IAttack.sol\\\";\\n\\ncontract Hive is IHive, Ownable, IERC721Receiver, Pausable {\\n    using Strings for uint256;\\n    using Strings for uint48;\\n    using Strings for uint32;\\n    using Strings for uint16;\\n    using Strings for uint8;\\n\\n    event AddedToHive(address indexed owner, uint256 indexed hiveId, uint256 tokenId, uint256 timestamp);\\n    event AddedToWaitingRoom(address indexed owner, uint256 indexed tokenId, uint256 timestamp);\\n    event RemovedFromWaitingRoom(address indexed owner, uint256 indexed tokenId, uint256 timestamp);\\n    event TokenClaimed(address indexed owner, uint256 indexed tokenId, uint256 earned);\\n    event HiveRestarted(uint256 indexed hiveId);\\n    event HiveFull(address indexed owner, uint256 hiveId, uint256 tokenId, uint256 timestamp);\\n\\n    // contract references\\n    ICryptoBees beesContract;\\n    IAttack attackContract;\\n\\n    // maps tokenId to hives\\n    mapping(uint256 => BeeHive) public hives;\\n\\n    mapping(uint256 => Bee) public waitingRoom;\\n\\n    // bee must have stay 1 day in the hive\\n    uint256 public constant MINIMUM_TO_EXIT = 1 days;\\n\\n    // number of Bees staked\\n    uint256 public totalBeesStaked;\\n    // hive to stake in\\n    uint256 public availableHive;\\n    // extra hives above minted / 100\\n    uint256 public extraHives = 2;\\n    // emergency rescue to allow unstaking without any checks but without $HONEY\\n    bool public rescueEnabled = false;\\n\\n    constructor() {}\\n\\n    function setContracts(address _BEES, address _ATTACK) external onlyOwner {\\n        beesContract = ICryptoBees(_BEES);\\n        attackContract = IAttack(_ATTACK);\\n    }\\n\\n    /** STAKING */\\n\\n    /**\\n     * calculates how much $honey a bee got so far\\n     * it's progressive based on the hive age\\n     * it's precalculated off chain to save gas\\n     */\\n    // how much a hive creates honey each day of it's life\\n    uint16[] accDaily = [400, 480, 576, 690, 830, 1000, 1200];\\n    uint16[] accCombined = [400, 880, 1456, 2146, 2976, 3976, 5176];\\n\\n    function calculateAccumulation(uint256 start, uint256 end) internal view returns (uint256 owed) {\\n        uint256 d = (end - start) / 1 days;\\n        if (d > 6) d = 6;\\n        uint256 left = end - start;\\n        if (left > d * 1 days) left = left - (d * 1 days);\\n        else left = 0;\\n        if (d > 0) owed = accCombined[d - 1];\\n        owed += ((left * accDaily[d]) / 1 days);\\n    }\\n\\n    function calculateBeeOwed(uint256 hiveId, uint256 tokenId) public view returns (uint256 owed) {\\n        uint256 since = hives[hiveId].bees[tokenId].since;\\n        owed = calculateAccumulation(hives[hiveId].startedTimestamp, block.timestamp);\\n        if (since > hives[hiveId].startedTimestamp) {\\n            owed -= calculateAccumulation(hives[hiveId].startedTimestamp, since);\\n        }\\n        if (since < hives[hiveId].lastCollectedHoneyTimestamp && hives[hiveId].startedTimestamp < hives[hiveId].lastCollectedHoneyTimestamp) {\\n            if (owed > hives[hiveId].collectionAmountPerBee) owed -= hives[hiveId].collectionAmountPerBee;\\n            else owed = 0;\\n        }\\n    }\\n\\n    /**\\n     * stakes an unknown Token type\\n     * @param account the address of the staker\\n     * @param tokenId the ID of the Token to add\\n     */\\n    function addToWaitingRoom(address account, uint256 tokenId) external whenNotPaused {\\n        require(_msgSender() == address(beesContract), \\\"HIVE:ADD TO WAITING ROOM:ONLY BEES CONTRACT\\\");\\n        waitingRoom[tokenId] = Bee({owner: account, tokenId: uint16(tokenId), index: 0, since: uint48(block.timestamp)});\\n        emit AddedToWaitingRoom(account, tokenId, block.timestamp);\\n    }\\n\\n    /**\\n     * either unstakes or adds to hive\\n     * @param tokenId the ID of the token\\n     */\\n    function removeFromWaitingRoom(uint256 tokenId, uint256 hiveId) external whenNotPaused {\\n        Bee memory token = waitingRoom[tokenId];\\n        if (token.tokenId > 0 && beesContract.getTokenData(token.tokenId)._type == 1) {\\n            if (availableHive != 0 && hiveId == 0 && hives[availableHive].beesArray.length < 100) hiveId = availableHive;\\n            if (hiveId == 0) {\\n                uint256 totalHives = ((beesContract.getMinted() / 100) + extraHives);\\n                for (uint256 i = 1; i <= totalHives; i++) {\\n                    if (hives[i].beesArray.length < 100) {\\n                        hiveId = i;\\n                        availableHive = i;\\n                        break;\\n                    }\\n                }\\n            }\\n            _addBeeToHive(token.owner, tokenId, hiveId);\\n            delete waitingRoom[tokenId];\\n        } else if (token.tokenId > 0 && beesContract.getTokenData(token.tokenId)._type > 1) {\\n            beesContract.performSafeTransferFrom(address(this), _msgSender(), tokenId); // send the bear/beekeeper back\\n            delete waitingRoom[tokenId];\\n            emit TokenClaimed(_msgSender(), tokenId, 0);\\n        } else if (token.tokenId > 0) {\\n            require(_msgSender() == owner() || token.owner == _msgSender(), \\\"CANNOT REMOVE UNREVEALED TOKEN\\\");\\n            beesContract.performSafeTransferFrom(address(this), _msgSender(), tokenId); // send the bear/beekeeper back\\n            delete waitingRoom[tokenId];\\n            emit TokenClaimed(_msgSender(), tokenId, 0);\\n        }\\n    }\\n\\n    /**\\n     * adds Bees to the Hive\\n     * @param account the address of the staker\\n     * @param tokenIds the IDs of the Bees\\n     * @param hiveIds the IDs of the Hives\\n     */\\n    function addManyToHive(\\n        address account,\\n        uint16[] calldata tokenIds,\\n        uint16[] calldata hiveIds\\n    ) external whenNotPaused {\\n        require(account == _msgSender() || _msgSender() == address(beesContract), \\\"DONT GIVE YOUR TOKENS AWAY\\\");\\n        require(tokenIds.length == hiveIds.length, \\\"THE ARGUMENTS LENGTHS DO NOT MATCH\\\");\\n        uint256 totalHives = ((beesContract.getMinted() / 100) + extraHives);\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            require(beesContract.getTokenData(tokenIds[i])._type == 1, \\\"TOKEN MUST BE A BEE\\\");\\n\\n            require(totalHives >= hiveIds[i], \\\"HIVE NOT AVAILABLE\\\");\\n\\n            // dont do this step if its a mint + stake\\n            if (_msgSender() != address(beesContract)) {\\n                require(beesContract.getOwnerOf(tokenIds[i]) == _msgSender(), \\\"AINT YO TOKEN\\\");\\n                beesContract.performTransferFrom(_msgSender(), address(this), tokenIds[i]);\\n            }\\n            _addBeeToHive(account, tokenIds[i], hiveIds[i]);\\n        }\\n    }\\n\\n    /**\\n     * adds a single Bee to a specific Hive\\n     * @param account the address of the staker\\n     * @param tokenId the ID of the Bee to add\\n     * @param hiveId the ID of the Hive\\n     */\\n    function _addBeeToHive(\\n        address account,\\n        uint256 tokenId,\\n        uint256 hiveId\\n    ) internal {\\n        uint256 index = hives[hiveId].beesArray.length;\\n        require(index < 100, \\\"HIVE IS FULL\\\");\\n        require(hiveId > 0, \\\"HIVE 0 NOT AVAILABLE\\\");\\n        if (hives[hiveId].startedTimestamp == 0) hives[hiveId].startedTimestamp = uint32(block.timestamp);\\n        hives[hiveId].bees[tokenId] = Bee({owner: account, tokenId: uint16(tokenId), index: uint8(index), since: uint48(block.timestamp)});\\n        hives[hiveId].beesArray.push(uint16(tokenId));\\n        if (hives[hiveId].beesArray.length < 90 && availableHive != hiveId) {\\n            availableHive = hiveId;\\n        }\\n        totalBeesStaked += 1;\\n        emit AddedToHive(account, hiveId, tokenId, block.timestamp);\\n    }\\n\\n    /** CLAIMING / UNSTAKING */\\n\\n    /**\\n     * change hive or unstake and realize $HONEY earnings\\n     * it requires it has 1 day worth of $HONEY unclaimed\\n     * @param tokenIds the IDs of the tokens to claim earnings from\\n     * @param hiveIds the IDs of the Hives for each Bee\\n     * @param newHiveIds the IDs of new Hives (or to unstake if it's -1)\\n     */\\n    function claimManyFromHive(\\n        uint16[] calldata tokenIds,\\n        uint16[] calldata hiveIds,\\n        uint16[] calldata newHiveIds\\n    ) external whenNotPaused {\\n        require(tokenIds.length == hiveIds.length && tokenIds.length == newHiveIds.length, \\\"THE ARGUMENTS LENGTHS DO NOT MATCH\\\");\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            _claimBeeFromHive(tokenIds[i], hiveIds[i], newHiveIds[i]);\\n        }\\n    }\\n\\n    /**\\n     * change hive or unstake and realize $HONEY earnings\\n     * @param tokenId the ID of the Bee to claim earnings from\\n     * @param hiveId the ID of the Hive where the Bee is\\n     * @param newHiveId the ID of the Hive where the Bee want to go (-1 for unstake)\\n     * @return owed - the amount of $HONEY earned\\n     */\\n    function _claimBeeFromHive(\\n        uint256 tokenId,\\n        uint256 hiveId,\\n        uint256 newHiveId\\n    ) internal returns (uint256 owed) {\\n        Bee memory bee = hives[hiveId].bees[tokenId];\\n        require(bee.owner == _msgSender(), \\\"YOU ARE NOT THE OWNER\\\");\\n        if (!rescueEnabled) {\\n            require(block.timestamp - bee.since > MINIMUM_TO_EXIT, \\\"YOU NEED MORE HONEY TO GET OUT OF THE HIVE\\\");\\n        }\\n        owed = calculateBeeOwed(hiveId, tokenId);\\n        beesContract.increaseTokensPot(bee.owner, owed);\\n        if (newHiveId == 0) {\\n            beesContract.performSafeTransferFrom(address(this), _msgSender(), tokenId); // send the bee back\\n            uint256 index = hives[hiveId].bees[tokenId].index;\\n\\n            if (index != hives[hiveId].beesArray.length - 1) {\\n                uint256 lastIndex = hives[hiveId].beesArray.length - 1;\\n                uint256 lastTokenIndex = hives[hiveId].beesArray[lastIndex];\\n                hives[hiveId].beesArray[index] = uint16(lastTokenIndex);\\n                hives[hiveId].bees[lastTokenIndex].index = uint8(index);\\n            }\\n            hives[hiveId].beesArray.pop();\\n            delete hives[hiveId].bees[tokenId];\\n\\n            totalBeesStaked -= 1;\\n            emit TokenClaimed(_msgSender(), tokenId, owed);\\n        } else if (hives[newHiveId].beesArray.length < 100) {\\n            uint256 index = hives[hiveId].bees[tokenId].index;\\n            if (index != hives[hiveId].beesArray.length - 1) {\\n                uint256 lastIndex = hives[hiveId].beesArray.length - 1;\\n                uint256 lastTokenIndex = hives[hiveId].beesArray[lastIndex];\\n                hives[hiveId].beesArray[index] = uint16(lastTokenIndex);\\n                hives[hiveId].bees[lastTokenIndex].index = uint8(index);\\n            }\\n            hives[hiveId].beesArray.pop();\\n            delete hives[hiveId].bees[tokenId];\\n\\n            uint256 newIndex = hives[newHiveId].beesArray.length;\\n            hives[newHiveId].bees[tokenId] = Bee({owner: _msgSender(), tokenId: uint16(tokenId), index: uint8(newIndex), since: uint48(block.timestamp)}); // reset stake\\n            if (hives[newHiveId].startedTimestamp == 0) hives[newHiveId].startedTimestamp = uint32(block.timestamp);\\n            hives[newHiveId].beesArray.push(uint16(tokenId));\\n            if (newIndex < 90 && availableHive != newHiveId) {\\n                availableHive = newHiveId;\\n            }\\n            emit AddedToHive(_msgSender(), newHiveId, tokenId, block.timestamp);\\n        } else {\\n            emit HiveFull(_msgSender(), newHiveId, tokenId, block.timestamp);\\n        }\\n    }\\n\\n    // GETTERS / SETTERS\\n    function getLastStolenHoneyTimestamp(uint256 hiveId) external view returns (uint256 lastStolenHoneyTimestamp) {\\n        lastStolenHoneyTimestamp = hives[hiveId].lastStolenHoneyTimestamp;\\n    }\\n\\n    function getHiveProtectionBears(uint256 hiveId) external view returns (uint256 hiveProtectionBears) {\\n        hiveProtectionBears = hives[hiveId].hiveProtectionBears;\\n    }\\n\\n    function isHiveProtectedFromKeepers(uint256 hiveId) external view returns (bool) {\\n        return hives[hiveId].collectionAmount > 0 ? true : false;\\n    }\\n\\n    function getHiveOccupancy(uint256 hiveId) external view returns (uint256 occupancy) {\\n        occupancy = hives[hiveId].beesArray.length;\\n    }\\n\\n    function getBeeSinceTimestamp(uint256 hiveId, uint256 tokenId) external view returns (uint256 since) {\\n        since = hives[hiveId].bees[tokenId].since;\\n    }\\n\\n    function getBeeTokenId(uint256 hiveId, uint256 index) external view returns (uint256 tokenId) {\\n        tokenId = hives[hiveId].beesArray[index];\\n    }\\n\\n    function setBeeSince(\\n        uint256 hiveId,\\n        uint256 tokenId,\\n        uint48 since\\n    ) external {\\n        require(_msgSender() == address(attackContract), \\\"ONLY ATTACK CONTRACT CAN CALL THIS\\\");\\n        hives[hiveId].bees[tokenId].since = since;\\n    }\\n\\n    function incSuccessfulAttacks(uint256 hiveId) external {\\n        require(_msgSender() == address(attackContract), \\\"ONLY ATTACK CONTRACT CAN CALL THIS\\\");\\n        hives[hiveId].successfulAttacks += 1;\\n    }\\n\\n    function incTotalAttacks(uint256 hiveId) external {\\n        require(_msgSender() == address(attackContract), \\\"ONLY ATTACK CONTRACT CAN CALL THIS\\\");\\n        hives[hiveId].totalAttacks += 1;\\n    }\\n\\n    function setBearAttackData(\\n        uint256 hiveId,\\n        uint32 timestamp,\\n        uint32 protection\\n    ) external {\\n        require(_msgSender() == address(attackContract), \\\"ONLY ATTACK CONTRACT CAN CALL THIS\\\");\\n        hives[hiveId].lastStolenHoneyTimestamp = timestamp;\\n        hives[hiveId].hiveProtectionBears = protection;\\n    }\\n\\n    function setKeeperAttackData(\\n        uint256 hiveId,\\n        uint32 timestamp,\\n        uint32 collected,\\n        uint32 collectedPerBee\\n    ) external {\\n        require(_msgSender() == address(attackContract), \\\"ONLY ATTACK CONTRACT CAN CALL THIS\\\");\\n        hives[hiveId].lastCollectedHoneyTimestamp = timestamp;\\n        hives[hiveId].collectionAmount = collected;\\n        hives[hiveId].collectionAmountPerBee = collectedPerBee;\\n    }\\n\\n    function resetHive(uint256 hiveId) external {\\n        require(_msgSender() == address(attackContract) || _msgSender() == owner(), \\\"ONLY ATTACK CONTRACT CAN CALL THIS\\\");\\n        hives[hiveId].startedTimestamp = uint32(block.timestamp);\\n        hives[hiveId].lastCollectedHoneyTimestamp = 0;\\n        hives[hiveId].hiveProtectionBears = 0;\\n        hives[hiveId].lastStolenHoneyTimestamp = 0;\\n        hives[hiveId].collectionAmount = 0;\\n        hives[hiveId].collectionAmountPerBee = 0;\\n        hives[hiveId].successfulAttacks = 0;\\n        hives[hiveId].totalAttacks = 0;\\n        emit HiveRestarted(hiveId);\\n    }\\n\\n    /** ADMIN */\\n\\n    function setRescueEnabled(bool _enabled) external onlyOwner {\\n        rescueEnabled = _enabled;\\n    }\\n\\n    function setExtraHives(uint256 _extra) external onlyOwner {\\n        extraHives = _extra;\\n    }\\n\\n    function setPaused(bool _paused) external onlyOwner {\\n        if (_paused) _pause();\\n        else _unpause();\\n    }\\n\\n    function setAvailableHive(uint256 _hiveId) external onlyOwner {\\n        availableHive = _hiveId;\\n    }\\n\\n    /** READ ONLY */\\n\\n    function getInfoOnBee(uint256 tokenId, uint256 hiveId) public view returns (Bee memory) {\\n        return hives[hiveId].bees[tokenId];\\n    }\\n\\n    function getHiveAge(uint256 hiveId) external view returns (uint32) {\\n        return hives[hiveId].startedTimestamp;\\n    }\\n\\n    function getHiveSuccessfulAttacks(uint256 hiveId) external view returns (uint8) {\\n        return hives[hiveId].successfulAttacks;\\n    }\\n\\n    function getWaitingRoomOwner(uint256 tokenId) external view returns (address) {\\n        return waitingRoom[tokenId].owner;\\n    }\\n\\n    function getInfoOnHive(uint256 hiveId) public view returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    uint32(hives[hiveId].startedTimestamp).toString(),\\n                    \\\",\\\",\\n                    uint32(hives[hiveId].lastCollectedHoneyTimestamp).toString(),\\n                    \\\",\\\",\\n                    uint32(hives[hiveId].lastStolenHoneyTimestamp).toString(),\\n                    \\\",\\\",\\n                    uint32(hives[hiveId].hiveProtectionBears).toString(),\\n                    \\\",\\\",\\n                    uint32(hives[hiveId].collectionAmount).toString(),\\n                    \\\",\\\",\\n                    uint16(hives[hiveId].beesArray.length).toString(),\\n                    \\\",\\\",\\n                    uint8(hives[hiveId].successfulAttacks).toString(),\\n                    \\\",\\\",\\n                    uint8(hives[hiveId].totalAttacks).toString()\\n                )\\n            );\\n    }\\n\\n    function getInfoOnHives(uint256 _start, uint256 _to) public view returns (string memory) {\\n        string memory result;\\n        uint256 minted = beesContract.getMinted();\\n        if (minted == 0) minted = 1;\\n        uint256 to = _to > 0 ? _to : ((minted / 100) + extraHives);\\n        uint256 start = _start > 0 ? _start : 1;\\n        for (uint256 i = start; i <= to; i++) {\\n            result = string(abi.encodePacked(result, uint16(i).toString(), \\\":\\\", getInfoOnHive(i), \\\";\\\"));\\n        }\\n        return result;\\n    }\\n\\n    function onERC721Received(\\n        address,\\n        address from,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (bytes4) {\\n        require(from == address(0x0), \\\"Cannot send tokens to Hive directly\\\");\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ICryptoBees.sol\": {\r\n      \"content\": \"//Contract based on https://docs.openzeppelin.com/contracts/3.x/erc721\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n// import \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface ICryptoBees {\\n    struct Token {\\n        uint8 _type;\\n        uint8 color;\\n        uint8 eyes;\\n        uint8 mouth;\\n        uint8 nose;\\n        uint8 hair;\\n        uint8 accessory;\\n        uint8 feelers;\\n        uint8 strength;\\n        uint48 lastAttackTimestamp;\\n        uint48 cooldownTillTimestamp;\\n    }\\n\\n    function getMinted() external view returns (uint256 m);\\n\\n    function increaseTokensPot(address _owner, uint256 amount) external;\\n\\n    function updateTokensLastAttack(\\n        uint256 tokenId,\\n        uint48 timestamp,\\n        uint48 till\\n    ) external;\\n\\n    function mint(\\n        address addr,\\n        uint256 tokenId,\\n        bool stake\\n    ) external;\\n\\n    function setPaused(bool _paused) external;\\n\\n    function getTokenData(uint256 tokenId) external view returns (Token memory token);\\n\\n    function getOwnerOf(uint256 tokenId) external view returns (address);\\n\\n    function doesExist(uint256 tokenId) external view returns (bool exists);\\n\\n    function performTransferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    function performSafeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IHoney.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.9;\\n\\ninterface IHoney {\\n    function mint(address to, uint256 amount) external;\\n\\n    function mintGiveaway(address[] calldata addresses, uint256 amount) external;\\n\\n    function burn(address from, uint256 amount) external;\\n\\n    function disableGiveaway() external;\\n\\n    function addController(address controller) external;\\n\\n    function removeController(address controller) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IHive.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.9;\\n\\ninterface IHive {\\n    struct Bee {\\n        address owner;\\n        uint32 tokenId;\\n        uint48 since;\\n        uint8 index;\\n    }\\n\\n    struct BeeHive {\\n        uint32 startedTimestamp;\\n        uint32 lastCollectedHoneyTimestamp;\\n        uint32 hiveProtectionBears;\\n        uint32 lastStolenHoneyTimestamp;\\n        uint32 collectionAmount;\\n        uint32 collectionAmountPerBee;\\n        uint8 successfulAttacks;\\n        uint8 totalAttacks;\\n        mapping(uint256 => Bee) bees;\\n        uint16[] beesArray;\\n    }\\n\\n    function addManyToHive(\\n        address account,\\n        uint16[] calldata tokenIds,\\n        uint16[] calldata hiveIds\\n    ) external;\\n\\n    function claimManyFromHive(\\n        uint16[] calldata tokenIds,\\n        uint16[] calldata hiveIds,\\n        uint16[] calldata newHiveIds\\n    ) external;\\n\\n    function addToWaitingRoom(address account, uint256 tokenId) external;\\n\\n    function removeFromWaitingRoom(uint256 tokenId, uint256 hiveId) external;\\n\\n    function setRescueEnabled(bool _enabled) external;\\n\\n    function setPaused(bool _paused) external;\\n\\n    function setBeeSince(\\n        uint256 hiveId,\\n        uint256 tokenId,\\n        uint48 since\\n    ) external;\\n\\n    function calculateBeeOwed(uint256 hiveId, uint256 tokenId) external view returns (uint256 owed);\\n\\n    function incSuccessfulAttacks(uint256 hiveId) external;\\n\\n    function incTotalAttacks(uint256 hiveId) external;\\n\\n    function setBearAttackData(\\n        uint256 hiveId,\\n        uint32 timestamp,\\n        uint32 protection\\n    ) external;\\n\\n    function setKeeperAttackData(\\n        uint256 hiveId,\\n        uint32 timestamp,\\n        uint32 collected,\\n        uint32 collectedPerBee\\n    ) external;\\n\\n    function getLastStolenHoneyTimestamp(uint256 hiveId) external view returns (uint256 lastStolenHoneyTimestamp);\\n\\n    function getHiveProtectionBears(uint256 hiveId) external view returns (uint256 hiveProtectionBears);\\n\\n    function isHiveProtectedFromKeepers(uint256 hiveId) external view returns (bool);\\n\\n    function getHiveOccupancy(uint256 hiveId) external view returns (uint256 occupancy);\\n\\n    function getBeeSinceTimestamp(uint256 hiveId, uint256 tokenId) external view returns (uint256 since);\\n\\n    function getBeeTokenId(uint256 hiveId, uint256 index) external view returns (uint256 tokenId);\\n\\n    function getHiveAge(uint256 hiveId) external view returns (uint32);\\n\\n    function getHiveSuccessfulAttacks(uint256 hiveId) external view returns (uint8);\\n\\n    function getWaitingRoomOwner(uint256 tokenId) external view returns (address);\\n\\n    function resetHive(uint256 hiveId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IAttack.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.9;\\n\\ninterface IAttack {\\n    struct Settings {\\n        uint8 bearChance;\\n        uint8 beekeeperMultiplier;\\n        uint24 hiveProtectionBear;\\n        uint24 hiveProtectionKeeper;\\n        uint24 bearCooldownBase;\\n        uint24 bearCooldownPerHiveDay;\\n        uint24 beekeeperCooldownBase;\\n        uint24 beekeeperCooldownPerHiveDay;\\n        uint8 attacksToRestart;\\n    }\\n    struct UnresolvedAttack {\\n        uint24 tokenId;\\n        uint48 nonce;\\n        uint64 block;\\n        uint32 howMuch;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"AddedToHive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"AddedToWaitingRoom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"HiveFull\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"}],\"name\":\"HiveRestarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RemovedFromWaitingRoom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"}],\"name\":\"TokenClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MINIMUM_TO_EXIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"hiveIds\",\"type\":\"uint16[]\"}],\"name\":\"addManyToHive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"addToWaitingRoom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableHive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"calculateBeeOwed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"hiveIds\",\"type\":\"uint16[]\"},{\"internalType\":\"uint16[]\",\"name\":\"newHiveIds\",\"type\":\"uint16[]\"}],\"name\":\"claimManyFromHive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extraHives\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getBeeSinceTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"since\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getBeeTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"}],\"name\":\"getHiveAge\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"}],\"name\":\"getHiveOccupancy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"occupancy\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"}],\"name\":\"getHiveProtectionBears\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveProtectionBears\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"}],\"name\":\"getHiveSuccessfulAttacks\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"}],\"name\":\"getInfoOnBee\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint48\",\"name\":\"since\",\"type\":\"uint48\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"internalType\":\"struct IHive.Bee\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"}],\"name\":\"getInfoOnHive\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getInfoOnHives\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"}],\"name\":\"getLastStolenHoneyTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastStolenHoneyTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getWaitingRoomOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hives\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"startedTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lastCollectedHoneyTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"hiveProtectionBears\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lastStolenHoneyTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"collectionAmount\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"collectionAmountPerBee\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"successfulAttacks\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"totalAttacks\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"}],\"name\":\"incSuccessfulAttacks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"}],\"name\":\"incTotalAttacks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"}],\"name\":\"isHiveProtectedFromKeepers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"}],\"name\":\"removeFromWaitingRoom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"}],\"name\":\"resetHive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hiveId\",\"type\":\"uint256\"}],\"name\":\"setAvailableHive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"protection\",\"type\":\"uint32\"}],\"name\":\"setBearAttackData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint48\",\"name\":\"since\",\"type\":\"uint48\"}],\"name\":\"setBeeSince\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_BEES\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ATTACK\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_extra\",\"type\":\"uint256\"}],\"name\":\"setExtraHives\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hiveId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"collected\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"collectedPerBee\",\"type\":\"uint32\"}],\"name\":\"setKeeperAttackData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setRescueEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBeesStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"waitingRoom\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"internalType\":\"uint48\",\"name\":\"since\",\"type\":\"uint48\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Hive","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}