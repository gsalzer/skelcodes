{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/accounts/module1/Implementation_m1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.6;\\npragma experimental ABIEncoderV2;\\n\\nimport {Variables} from \\\"../variables.sol\\\";\\n\\n/**\\n * @title StakeAllAccountV2.\\n * @dev DeFi Smart Account Wallet.\\n */\\n\\ninterface ConnectorsInterface {\\n    function isConnectors(string[] calldata connectorNames)\\n        external\\n        view\\n        returns (bool, address[] memory);\\n}\\n\\ncontract Constants is Variables {\\n    // StakeAllIndex Address.\\n    address internal immutable stakeAllIndex;\\n    // Connectors Address.\\n    address public immutable connectorsM1;\\n\\n    constructor(address _stakeAllIndex, address _connectors) {\\n        connectorsM1 = _connectors;\\n        stakeAllIndex = _stakeAllIndex;\\n    }\\n}\\n\\ncontract StakeAllImplementationM1 is Constants {\\n    constructor(address _stakeAllIndex, address _connectors)\\n        Constants(_stakeAllIndex, _connectors)\\n    {}\\n\\n    function decodeEvent(bytes memory response)\\n        internal\\n        pure\\n        returns (string memory _eventCode, bytes memory _eventParams)\\n    {\\n        if (response.length > 0) {\\n            (_eventCode, _eventParams) = abi.decode(response, (string, bytes));\\n        }\\n    }\\n\\n    event LogCast(\\n        address indexed origin,\\n        address indexed sender,\\n        uint256 value,\\n        string[] targetsNames,\\n        address[] targets,\\n        string[] eventNames,\\n        bytes[] eventParams\\n    );\\n\\n    receive() external payable {}\\n\\n    /**\\n     * @dev Delegate the calls to Connector.\\n     * @param _target Connector address\\n     * @param _data CallData of function.\\n     */\\n    function spell(address _target, bytes memory _data)\\n        internal\\n        returns (bytes memory response)\\n    {\\n        require(_target != address(0), \\\"target-invalid\\\");\\n        assembly {\\n            let succeeded := delegatecall(\\n                gas(),\\n                _target,\\n                add(_data, 0x20),\\n                mload(_data),\\n                0,\\n                0\\n            )\\n            let size := returndatasize()\\n\\n            response := mload(0x40)\\n            mstore(\\n                0x40,\\n                add(response, and(add(add(size, 0x20), 0x1f), not(0x1f)))\\n            )\\n            mstore(response, size)\\n            returndatacopy(add(response, 0x20), 0, size)\\n\\n            switch iszero(succeeded)\\n            case 1 {\\n                // throw if delegatecall failed\\n                returndatacopy(0x00, 0x00, size)\\n                revert(0x00, size)\\n            }\\n        }\\n    }\\n\\n    function _cast(\\n        string[] calldata _targetNames,\\n        bytes[] calldata _datas,\\n        address _origin\\n    ) internal returns (bytes32) {\\n        uint256 _length = _targetNames.length;\\n        require(_length != 0, \\\"1: length-invalid\\\");\\n        require(_length == _datas.length, \\\"1: array-length-invalid\\\");\\n\\n        string[] memory eventNames = new string[](_length);\\n        bytes[] memory eventParams = new bytes[](_length);\\n\\n        (bool isOk, address[] memory _targets) = ConnectorsInterface(\\n            connectorsM1\\n        ).isConnectors(_targetNames);\\n\\n        require(isOk, \\\"1: not-connector\\\");\\n\\n        for (uint256 i = 0; i < _length; i++) {\\n            bytes memory response = spell(_targets[i], _datas[i]);\\n            (eventNames[i], eventParams[i]) = decodeEvent(response);\\n        }\\n\\n        emit LogCast(\\n            _origin,\\n            msg.sender,\\n            msg.value,\\n            _targetNames,\\n            _targets,\\n            eventNames,\\n            eventParams\\n        );\\n    }\\n\\n    /**\\n     * @dev This is the main function, Where all the different functions are called\\n     * from Smart Account.\\n     * @param _targetNames Array of Connector address.\\n     * @param _datas Array of Calldata.\\n     */\\n    function cast(\\n        string[] calldata _targetNames,\\n        bytes[] calldata _datas,\\n        address _origin\\n    )\\n        external\\n        payable\\n        returns (\\n            bytes32 // Dummy return to fix stakeAllIndex buildWithCast function\\n        )\\n    {\\n        require(\\n            _auth[msg.sender] || msg.sender == stakeAllIndex,\\n            \\\"1: permission-denied\\\"\\n        );\\n\\n        return _cast(_targetNames, _datas, _origin);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/accounts/variables.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.6;\\n\\ncontract Variables {\\n    // Auth Module(Address of Auth => bool).\\n    mapping(address => bool) internal _auth;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeAllIndex\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_connectors\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"targetsNames\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"targets\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"eventNames\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"eventParams\",\"type\":\"bytes[]\"}],\"name\":\"LogCast\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_targetNames\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_datas\",\"type\":\"bytes[]\"},{\"internalType\":\"address\",\"name\":\"_origin\",\"type\":\"address\"}],\"name\":\"cast\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"connectorsM1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"StakeAllImplementationM1","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000086d9b80cf2907843b4030c8aa60f1bc8d92a226c000000000000000000000000a1cf404cb82d2956bf479f49da37f5676ea19f3e","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}