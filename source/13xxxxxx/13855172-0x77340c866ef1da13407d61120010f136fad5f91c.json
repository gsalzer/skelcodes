{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/EvmHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./Ether.sol\\\";\\nimport \\\"./MultiCall.sol\\\";\\nimport \\\"./UniV3Helper.sol\\\";\\n\\n//solhint-disable-next-line no-empty-blocks\\ncontract EvmHelpers is Ether, MultiCall, UniV3Helper {}\\n\"\r\n    },\r\n    \"contracts/Ether.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.11;\\n\\n\\ncontract Ether {\\n    function balanceOf(address wallet) external view returns (uint256) {\\n        return wallet.balance;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/MultiCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.11;\\n\\n\\ncontract MultiCall {\\n    struct Call {\\n        address to;\\n        bytes data;\\n    }\\n\\n   function multicall(Call[] memory calls) public returns (bytes[] memory results) {\\n        results = new bytes[](calls.length);\\n        for (uint i = 0; i < calls.length; i++) {\\n            (, results[i]) = calls[i].to.call(calls[i].data);  // solhint-disable-line avoid-low-level-calls\\n        }\\n    }\\n\\n\\n    // be careful with calls.length == 0\\n    function multicallWithGasLimitation(Call[] memory calls, uint256 gasBuffer) public returns (bytes[] memory results, uint256 lastSuccessIndex) {\\n        results = new bytes[](calls.length);\\n        for (uint i = 0; i < calls.length; i++) {\\n            (, results[i]) = calls[i].to.call(calls[i].data);  // solhint-disable-line avoid-low-level-calls\\n            if (gasleft() < gasBuffer) {\\n                return (results, i);\\n            }\\n        }\\n        return (results, calls.length - 1);\\n    }\\n\\n   function multicallWithGas(Call[] memory calls) public returns (bytes[] memory results, uint256[] memory gasUsed) {\\n        results = new bytes[](calls.length);\\n        gasUsed = new uint256[](calls.length);\\n        for (uint i = 0; i < calls.length; i++) {\\n            uint256 initialGas = gasleft();\\n            (, results[i]) = calls[i].to.call(calls[i].data);  // solhint-disable-line avoid-low-level-calls\\n            gasUsed[i] = initialGas - gasleft();\\n        }\\n    }\\n\\n    function gaslimit() external view returns (uint256) {\\n        return block.gaslimit;\\n    }\\n\\n    function gasLeft() external view returns (uint256) {\\n        return gasleft();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/UniV3Helper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./interfaces/IUniswapV3.sol\\\";\\n\\n\\ncontract UniV3Helper {\\n    int24 private constant _MIN_TICK = -887272;\\n    int24 private constant _MAX_TICK = -_MIN_TICK;\\n\\n    struct Tick {\\n        uint128 liquidityGross;\\n        int128 liquidityNet;\\n        uint256 feeGrowthOutside0X128;\\n        uint256 feeGrowthOutside1X128;\\n        int56 tickCumulativeOutside;\\n        uint160 secondsPerLiquidityOutsideX128;\\n        uint32 secondsOutside;\\n        int24 index; // tick index\\n    }\\n\\n    function getTicks(IUniswapV3 pool, int24 tickRange) external view returns (bytes[] memory ticks) {\\n        int24 tickSpacing = pool.tickSpacing();\\n        (,int24 tick,,,,,) = pool.slot0();\\n\\n        int24 fromTick = tick - (tickSpacing * tickRange);\\n        int24 toTick = tick + (tickSpacing * tickRange);\\n        if (fromTick < _MIN_TICK) {\\n            fromTick = _MIN_TICK;\\n        }\\n        if (toTick > _MAX_TICK) {\\n            toTick = _MAX_TICK;\\n        }\\n\\n        int24[] memory initTicks = new int24[](uint256(int256((toTick - fromTick + 1) / tickSpacing)));\\n\\n        uint256 counter = 0;\\n        for (int24 tickNum = (fromTick / tickSpacing * tickSpacing); tickNum <=  (toTick / tickSpacing * tickSpacing); tickNum += (256 * tickSpacing)) {\\n            int16 pos = int16((tickNum / tickSpacing) >> 8);\\n            uint256 bm = pool.tickBitmap(pos);\\n\\n             while (bm != 0) {\\n                 uint8 bit = _mostSignificantBit(bm);\\n                 initTicks[counter] = (int24(pos) * 256 + int24(uint24(bit))) * tickSpacing;\\n\\n                 counter += 1;\\n                 bm ^= 1 << bit;\\n             }\\n\\n        }\\n\\n        ticks = new bytes[](counter);\\n        for (uint256 i = 0; i < counter; i++) {\\n            (\\n                uint128 liquidityGross,\\n                int128 liquidityNet,\\n                uint256 feeGrowthOutside0X128,\\n                uint256 feeGrowthOutside1X128\\n                , // int56 tickCumulativeOutside,\\n                , // secondsPerLiquidityOutsideX128\\n                , // uint32 secondsOutside\\n                , // init\\n            ) = pool.ticks(initTicks[i]);\\n\\n             ticks[i] = abi.encodePacked(\\n                 liquidityGross,\\n                 liquidityNet,\\n                 feeGrowthOutside0X128,\\n                 feeGrowthOutside1X128,\\n                 // tickCumulativeOutside,\\n                 // secondsPerLiquidityOutsideX128,\\n                 // secondsOutside,\\n                 initTicks[i]\\n             );\\n        }\\n    }\\n\\n    function _mostSignificantBit(uint256 x) private pure returns (uint8 r) {\\n        require(x > 0, \\\"x is 0\\\");\\n\\n        if (x >= 0x100000000000000000000000000000000) {\\n            x >>= 128;\\n            r += 128;\\n        }\\n        if (x >= 0x10000000000000000) {\\n            x >>= 64;\\n            r += 64;\\n        }\\n        if (x >= 0x100000000) {\\n            x >>= 32;\\n            r += 32;\\n        }\\n        if (x >= 0x10000) {\\n            x >>= 16;\\n            r += 16;\\n        }\\n        if (x >= 0x100) {\\n            x >>= 8;\\n            r += 8;\\n        }\\n        if (x >= 0x10) {\\n            x >>= 4;\\n            r += 4;\\n        }\\n        if (x >= 0x4) {\\n            x >>= 2;\\n            r += 2;\\n        }\\n        if (x >= 0x2) r += 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.11;\\n\\n\\ninterface IUniswapV3 {\\n    function tickSpacing() external view returns (int24);\\n\\n    function slot0()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n        );\\n\\n    function feeGrowthGlobal0X128() external view returns (uint256);\\n\\n    function feeGrowthGlobal1X128() external view returns (uint256);\\n\\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\\n\\n    function liquidity() external view returns (uint128);\\n\\n    function ticks(int24 tick)\\n        external\\n        view\\n        returns (\\n            uint128 liquidityGross,\\n            int128 liquidityNet,\\n            uint256 feeGrowthOutside0X128,\\n            uint256 feeGrowthOutside1X128,\\n            int56 tickCumulativeOutside,\\n            uint160 secondsPerLiquidityOutsideX128,\\n            uint32 secondsOutside,\\n            bool initialized\\n        );\\n\\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\\n\\n    function positions(bytes32 key)\\n        external\\n        view\\n        returns (\\n            uint128 _liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n        );\\n\\n    function observations(uint256 index)\\n        external\\n        view\\n        returns (\\n            uint32 blockTimestamp,\\n            int56 tickCumulative,\\n            uint160 secondsPerLiquidityCumulativeX128,\\n            bool initialized\\n        );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaslimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniswapV3\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickRange\",\"type\":\"int24\"}],\"name\":\"getTicks\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"ticks\",\"type\":\"bytes[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCall.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCall.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"multicallWithGas\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"gasUsed\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct MultiCall.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"gasBuffer\",\"type\":\"uint256\"}],\"name\":\"multicallWithGasLimitation\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256\",\"name\":\"lastSuccessIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"EvmHelpers","CompilerVersion":"v0.8.11+commit.d7f03943","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}