{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.7;\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface ERC721 is ERC165 {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\ninterface ERC721Metadata is ERC721 {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string memory _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string memory _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\ninterface ERC721Enumerable is ERC721 {\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n}\r\n\r\ncontract NFT is ERC721Metadata, ERC721Enumerable {\r\n    mapping (uint256 => address) private tokenOwnerFromTokenId;\r\n    uint256 public immutable override totalSupply;\r\n    mapping (address => uint256) public override balanceOf;\r\n    mapping (address => mapping (address => bool)) public override isApprovedForAll;\r\n    mapping (uint256 => address) public override getApproved;\r\n    string public override name;\r\n    string public override symbol;\r\n    string private IPFSbase;\r\n    address private immutable originOwner;\r\n    uint256 private mintCounter = 0;\r\n    \r\n    constructor(uint256 _totalSupply, string memory _name, string memory _symbol, string memory _IPFSbase) {\r\n        totalSupply = _totalSupply;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        IPFSbase = _IPFSbase; // \"ipfs://bafybeih6a5b7kakekyfla4qtooq6u5vxtaoixxbezybl7hi5elc23xcx3u/\"\r\n        originOwner = msg.sender;\r\n        balanceOf[msg.sender] = _totalSupply;\r\n    }\r\n    \r\n    modifier validTokenId(uint256 _tokenId) {\r\n        require(_tokenId < totalSupply, \"Token ID invalid.\");\r\n        _;\r\n    }\r\n    \r\n    function ownerOf(uint256 _tokenId) external view override validTokenId(_tokenId) returns (address) {\r\n        address owner = tokenOwnerFromTokenId[_tokenId];\r\n        return owner == address(0x0) ? originOwner : owner;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external override {\r\n        _transferFrom(_from, _to, _tokenId);\r\n    }\r\n    \r\n    function _transferFrom(address _from, address _to, uint256 _tokenId) internal validTokenId(_tokenId) {\r\n        require(_to != address(0x0), \"Zero address recipient.\");\r\n        address owner = tokenOwnerFromTokenId[_tokenId];\r\n        require(msg.sender == _from || isApprovedForAll[_from][msg.sender] || getApproved[_tokenId] == msg.sender || (_from == originOwner && owner == address(0x0)), \"Transfer authorization failed.\");\r\n        require(owner == _from, \"Not owning token trying to transfer\");\r\n        \r\n        balanceOf[_from]--;\r\n        balanceOf[_to]++;\r\n        tokenOwnerFromTokenId[_tokenId] = _to;\r\n        \r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n    \r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external override {\r\n        _safeTransferFrom(_from, _to, _tokenId, data);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external override {\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n    \r\n    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) internal {\r\n        _transferFrom(_from, _to, _tokenId);\r\n        \r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_to)\r\n        }\r\n        if (size == 0) {\r\n            return;\r\n        }\r\n        \r\n        require(ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, data) == ERC721TokenReceiver.onERC721Received.selector, \"safeTransferFrom invalid return\");\r\n    }\r\n    \r\n    function setApprovalForAll(address _operator, bool _approved) external override {\r\n        isApprovedForAll[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n    \r\n    function approve(address _approvee, uint256 _tokenId) external override validTokenId(_tokenId) {\r\n        address owner = tokenOwnerFromTokenId[_tokenId];\r\n        require(owner == msg.sender || isApprovedForAll[owner][msg.sender] || getApproved[_tokenId] == msg.sender, \"Approve authorization failed.\");\r\n        getApproved[_tokenId] = _approvee;\r\n        \r\n        emit Approval(owner, _approvee, _tokenId);\r\n    }\r\n    \r\n    function tokenByIndex(uint256 _index) external view override validTokenId(_index) returns (uint256) {\r\n        return _index;\r\n    }\r\n    \r\n    function mint(uint256 number) external {\r\n        uint256 _mintCounter = mintCounter;\r\n        uint256 mcAndNumber = _mintCounter + number;\r\n        uint256 target = mcAndNumber < totalSupply ? mcAndNumber : totalSupply;\r\n        \r\n        while (_mintCounter < target) {\r\n            address owner = tokenOwnerFromTokenId[_mintCounter];\r\n            if (owner != address(0x0)) {\r\n                _mintCounter++;\r\n                continue;\r\n            }\r\n            \r\n            emit Transfer(address(0x0), originOwner, _mintCounter);\r\n            _mintCounter++;\r\n        }\r\n        \r\n        mintCounter = _mintCounter;\r\n    }\r\n    \r\n    function supportsInterface(bytes4 interfaceId) external pure override returns (bool) {\r\n        return interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f || interfaceId == 0x780e9d63;\r\n    }\r\n    \r\n    function tokenURI(uint256 _tokenId) external view override validTokenId(_tokenId) returns (string memory) {\r\n        // Base for the base 10 encoding https://stackoverflow.com/a/65707309\r\n        uint len;\r\n        if (_tokenId == 0) {\r\n            len = 1;\r\n        } else {\r\n            uint j = _tokenId;\r\n            while (j != 0) {\r\n                len++;\r\n                j /= 10;\r\n            }\r\n        }\r\n        bytes memory base = bytes(IPFSbase);\r\n        uint lbase = base.length;\r\n        len += lbase;\r\n        bytes memory bstr = new bytes(len+5);\r\n        while (lbase > 0) { // copy \"ipfs://bafy.../\" at the start\r\n            lbase--;\r\n            bstr[lbase] = base[lbase];\r\n        }\r\n        bstr[len] = \".\"; // copy \".json\" at the end\r\n        bstr[len+1] = \"j\";\r\n        bstr[len+2] = \"s\";\r\n        bstr[len+3] = \"o\";\r\n        bstr[len+4] = \"n\";\r\n        if (_tokenId > 0) {\r\n            while (_tokenId != 0) { // base10 encode the id in the middle\r\n                len--;\r\n                bstr[len] = bytes1((48 + uint8(_tokenId - _tokenId / 10 * 10)));\r\n                _tokenId /= 10;\r\n            }\r\n        } else {\r\n            bstr[len-1] = \"0\";\r\n        }\r\n        return string(bstr);\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_IPFSbase\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approvee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"NFT","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"99999","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000008416c706861626574000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000341424300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000043697066733a2f2f626166796265696836613562376b616b656b79666c613471746f6f71367535767874616f69787862657a79626c37686935656c63323378637833752f0000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":"0","Implementation":"","SwarmSource":"ipfs://73b6e0369ce904e51b9227d24ec5931aa1a10d71ebade4f4cba08bb17da5eb6f"}]}