{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/staking/PremiaStakingWithFeeDiscount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IERC20} from \\\"@solidstate/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport {SafeCast} from \\\"@solidstate/contracts/utils/SafeCast.sol\\\";\\r\\nimport {IERC2612} from \\\"@solidstate/contracts/token/ERC20/permit/IERC2612.sol\\\";\\r\\n\\r\\nimport {PremiaStaking} from \\\"./PremiaStaking.sol\\\";\\r\\nimport {FeeDiscount} from \\\"./FeeDiscount.sol\\\";\\r\\nimport {FeeDiscountStorage} from \\\"./FeeDiscountStorage.sol\\\";\\r\\n\\r\\nimport {IPremiaStakingOld} from \\\"./IPremiaStakingOld.sol\\\";\\r\\nimport {IPremiaStakingWithFeeDiscount} from \\\"./IPremiaStakingWithFeeDiscount.sol\\\";\\r\\n\\r\\ncontract PremiaStakingWithFeeDiscount is\\r\\n    IPremiaStakingWithFeeDiscount,\\r\\n    PremiaStaking,\\r\\n    FeeDiscount\\r\\n{\\r\\n    using SafeCast for uint256;\\r\\n\\r\\n    // The old PremiaFeeDiscount contract\\r\\n    address private immutable OLD_FEE_DISCOUNT;\\r\\n    // The old PremiaStaking contract\\r\\n    address private immutable OLD_STAKING;\\r\\n\\r\\n    constructor(\\r\\n        address premia,\\r\\n        address oldFeeDiscount,\\r\\n        address oldStaking\\r\\n    ) PremiaStaking(premia) FeeDiscount(address(this)) {\\r\\n        OLD_FEE_DISCOUNT = oldFeeDiscount;\\r\\n        OLD_STAKING = oldStaking;\\r\\n    }\\r\\n\\r\\n    function _transferXPremia(\\r\\n        address holder,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal override {\\r\\n        _transfer(holder, recipient, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Migrate old xPremia from old FeeDiscount contract to new xPremia\\r\\n     * @param user User for whom to migrate\\r\\n     * @param amount Amount of old xPremia to migrate\\r\\n     * @param stakePeriod Stake period selected in old contract\\r\\n     * @param lockedUntil Lock end date from old contract\\r\\n     */\\r\\n    function migrate(\\r\\n        address user,\\r\\n        uint256 amount,\\r\\n        uint256 stakePeriod,\\r\\n        uint256 lockedUntil\\r\\n    ) external {\\r\\n        require(msg.sender == OLD_FEE_DISCOUNT, \\\"Not authorized\\\");\\r\\n\\r\\n        (uint256 premiaDeposited, uint256 xPremiaMinted) = _migrateWithoutLock(\\r\\n            amount,\\r\\n            address(this)\\r\\n        );\\r\\n\\r\\n        emit Deposit(user, premiaDeposited);\\r\\n\\r\\n        FeeDiscountStorage.Layout storage l = FeeDiscountStorage.layout();\\r\\n        FeeDiscountStorage.UserInfo storage userInfo = l.userInfo[user];\\r\\n\\r\\n        uint64 _lockedUntil = lockedUntil.toUint64();\\r\\n        uint64 _stakePeriod = stakePeriod.toUint64();\\r\\n\\r\\n        userInfo.balance += xPremiaMinted;\\r\\n\\r\\n        if (_lockedUntil > userInfo.lockedUntil) {\\r\\n            userInfo.lockedUntil = lockedUntil.toUint64();\\r\\n        }\\r\\n\\r\\n        if (_stakePeriod > userInfo.stakePeriod) {\\r\\n            userInfo.stakePeriod = stakePeriod.toUint64();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Migrate old xPremia to new xPremia using IERC2612 permit\\r\\n     * @param amount Amount of old xPremia to migrate\\r\\n     * @param deadline Deadline after which permit will fail\\r\\n     * @param v V\\r\\n     * @param r R\\r\\n     * @param s S\\r\\n     */\\r\\n    function migrateWithoutLockWithPermit(\\r\\n        uint256 amount,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external returns (uint256 premiaDeposited, uint256 xPremiaMinted) {\\r\\n        IERC2612(address(OLD_STAKING)).permit(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            amount,\\r\\n            deadline,\\r\\n            v,\\r\\n            r,\\r\\n            s\\r\\n        );\\r\\n        (premiaDeposited, xPremiaMinted) = _migrateWithoutLock(\\r\\n            amount,\\r\\n            msg.sender\\r\\n        );\\r\\n        emit Deposit(msg.sender, premiaDeposited);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Migrate old xPremia to new xPremia\\r\\n     * @param amount Amount of old xPremia to migrate\\r\\n     * @return premiaDeposited Amount of premia deposited\\r\\n     * @return xPremiaMinted Amount of xPremia minted\\r\\n     */\\r\\n    function migrateWithoutLock(uint256 amount)\\r\\n        external\\r\\n        returns (uint256 premiaDeposited, uint256 xPremiaMinted)\\r\\n    {\\r\\n        (premiaDeposited, xPremiaMinted) = _migrateWithoutLock(\\r\\n            amount,\\r\\n            msg.sender\\r\\n        );\\r\\n        emit Deposit(msg.sender, premiaDeposited);\\r\\n    }\\r\\n\\r\\n    function _migrateWithoutLock(uint256 amount, address to)\\r\\n        internal\\r\\n        returns (uint256 premiaDeposited, uint256 xPremiaMinted)\\r\\n    {\\r\\n        // Gets the amount of Premia locked in the contract\\r\\n        uint256 totalPremia = _getStakedPremiaAmount();\\r\\n\\r\\n        //\\r\\n\\r\\n        IERC20(OLD_STAKING).transferFrom(msg.sender, address(this), amount);\\r\\n\\r\\n        uint256 oldPremiaBalance = IERC20(PREMIA).balanceOf(address(this));\\r\\n        IPremiaStakingOld(OLD_STAKING).leave(amount);\\r\\n        uint256 newPremiaBalance = IERC20(PREMIA).balanceOf(address(this));\\r\\n\\r\\n        uint256 toDeposit = newPremiaBalance - oldPremiaBalance;\\r\\n\\r\\n        return (toDeposit, _mintShares(to, toDeposit, totalPremia));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20Internal } from './IERC20Internal.sol';\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IERC20 is IERC20Internal {\\n    /**\\n     * @notice query the total minted token supply\\n     * @return token supply\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice query the token balance of given account\\n     * @param account address to query\\n     * @return token balance\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @notice query the allowance granted from given holder to given spender\\n     * @param holder approver of allowance\\n     * @param spender recipient of allowance\\n     * @return token allowance\\n     */\\n    function allowance(address holder, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice grant approval to spender to spend tokens\\n     * @dev prefer ERC20Extended functions to avoid transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\\n     * @param spender recipient of allowance\\n     * @param amount quantity of tokens approved for spending\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @notice transfer tokens to given recipient\\n     * @param recipient beneficiary of token transfer\\n     * @param amount quantity of tokens to transfer\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @notice transfer tokens to given recipient on behalf of given holder\\n     * @param holder holder of tokens prior to transfer\\n     * @param recipient beneficiary of token transfer\\n     * @param amount quantity of tokens to transfer\\n     * @return success status (always true; otherwise function should revert)\\n     */\\n    function transferFrom(\\n        address holder,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Helper library for safe casting of uint and int values\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary SafeCast {\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, 'SafeCast: value does not fit');\\n        return uint224(value);\\n    }\\n\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, 'SafeCast: value does not fit');\\n        return uint128(value);\\n    }\\n\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, 'SafeCast: value does not fit');\\n        return uint96(value);\\n    }\\n\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, 'SafeCast: value does not fit');\\n        return uint64(value);\\n    }\\n\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, 'SafeCast: value does not fit');\\n        return uint32(value);\\n    }\\n\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, 'SafeCast: value does not fit');\\n        return uint16(value);\\n    }\\n\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, 'SafeCast: value does not fit');\\n        return uint8(value);\\n    }\\n\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, 'SafeCast: value must be positive');\\n        return uint256(value);\\n    }\\n\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(\\n            value >= type(int128).min && value <= type(int128).max,\\n            'SafeCast: value does not fit'\\n        );\\n        return int128(value);\\n    }\\n\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(\\n            value >= type(int64).min && value <= type(int64).max,\\n            'SafeCast: value does not fit'\\n        );\\n        return int64(value);\\n    }\\n\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(\\n            value >= type(int32).min && value <= type(int32).max,\\n            'SafeCast: value does not fit'\\n        );\\n        return int32(value);\\n    }\\n\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(\\n            value >= type(int16).min && value <= type(int16).max,\\n            'SafeCast: value does not fit'\\n        );\\n        return int16(value);\\n    }\\n\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(\\n            value >= type(int8).min && value <= type(int8).max,\\n            'SafeCast: value does not fit'\\n        );\\n        return int8(value);\\n    }\\n\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(\\n            value <= uint256(type(int256).max),\\n            'SafeCast: value does not fit'\\n        );\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/permit/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice ERC2612 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-2612.\\n */\\ninterface IERC2612 {\\n    /**\\n     * @notice approve spender to transfer tokens held by owner via signature\\n     * @dev this function may be vulnerable to approval replay attacks\\n     * @param owner holder of tokens and signer of permit\\n     * @param spender beneficiary of approval\\n     * @param amount quantity of tokens to approve\\n     * @param v secp256k1 'v' value\\n     * @param r secp256k1 'r' value\\n     * @param s secp256k1 's' value\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @notice get the current ERC2612 nonce for the given address\\n     * @return current nonce\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/staking/PremiaStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IERC20} from \\\"@solidstate/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport {ERC20} from \\\"@solidstate/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport {IERC2612} from \\\"@solidstate/contracts/token/ERC20/permit/IERC2612.sol\\\";\\r\\nimport {ERC20Permit} from \\\"@solidstate/contracts/token/ERC20/permit/ERC20Permit.sol\\\";\\r\\nimport {SafeERC20} from \\\"@solidstate/contracts/utils/SafeERC20.sol\\\";\\r\\n\\r\\nimport {IPremiaStaking} from \\\"./IPremiaStaking.sol\\\";\\r\\nimport {PremiaStakingStorage} from \\\"./PremiaStakingStorage.sol\\\";\\r\\n\\r\\ncontract PremiaStaking is IPremiaStaking, ERC20, ERC20Permit {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    address internal immutable PREMIA;\\r\\n\\r\\n    constructor(address premia) {\\r\\n        PREMIA = premia;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function depositWithPermit(\\r\\n        uint256 amount,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external override {\\r\\n        IERC2612(PREMIA).permit(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            amount,\\r\\n            deadline,\\r\\n            v,\\r\\n            r,\\r\\n            s\\r\\n        );\\r\\n        _deposit(amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function deposit(uint256 amount) external override {\\r\\n        _deposit(amount);\\r\\n    }\\r\\n\\r\\n    function _deposit(uint256 amount) internal {\\r\\n        // Gets the amount of Premia locked in the contract\\r\\n        uint256 totalPremia = _getStakedPremiaAmount();\\r\\n\\r\\n        _mintShares(msg.sender, amount, totalPremia);\\r\\n\\r\\n        // Lock the Premia in the contract\\r\\n        IERC20(PREMIA).safeTransferFrom(msg.sender, address(this), amount);\\r\\n\\r\\n        emit Deposit(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function _mintShares(\\r\\n        address to,\\r\\n        uint256 amount,\\r\\n        uint256 totalPremia\\r\\n    ) internal returns (uint256) {\\r\\n        // Gets the amount of xPremia in existence\\r\\n        uint256 totalShares = _totalSupply();\\r\\n        // If no xPremia exists, mint it 1:1 to the amount put in\\r\\n        if (totalShares == 0 || totalPremia == 0) {\\r\\n            _mint(to, amount);\\r\\n            return amount;\\r\\n        }\\r\\n        // Calculate and mint the amount of xPremia the Premia is worth. The ratio will change overtime, as xPremia is burned/minted and Premia deposited + gained from fees / withdrawn.\\r\\n        else {\\r\\n            uint256 shares = (amount * totalShares) / totalPremia;\\r\\n            _mint(to, shares);\\r\\n            return shares;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function startWithdraw(uint256 amount) external override {\\r\\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\\r\\n\\r\\n        // Gets the amount of xPremia in existence\\r\\n        uint256 totalShares = _totalSupply();\\r\\n\\r\\n        // Calculates the amount of Premia the xPremia is worth\\r\\n        uint256 premiaAmount = (amount * _getStakedPremiaAmount()) /\\r\\n            totalShares;\\r\\n        _burn(msg.sender, amount);\\r\\n        l.pendingWithdrawal += premiaAmount;\\r\\n\\r\\n        l.withdrawals[msg.sender].amount += premiaAmount;\\r\\n        l.withdrawals[msg.sender].startDate = block.timestamp;\\r\\n\\r\\n        emit StartWithdrawal(msg.sender, premiaAmount, block.timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function withdraw() external override {\\r\\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\\r\\n\\r\\n        uint256 startDate = l.withdrawals[msg.sender].startDate;\\r\\n\\r\\n        require(startDate > 0, \\\"No pending withdrawal\\\");\\r\\n        require(\\r\\n            block.timestamp > startDate + l.withdrawalDelay,\\r\\n            \\\"Withdrawal still pending\\\"\\r\\n        );\\r\\n\\r\\n        uint256 amount = l.withdrawals[msg.sender].amount;\\r\\n\\r\\n        l.pendingWithdrawal -= amount;\\r\\n        delete l.withdrawals[msg.sender];\\r\\n\\r\\n        IERC20(PREMIA).safeTransfer(msg.sender, amount);\\r\\n\\r\\n        emit Withdrawal(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function getWithdrawalDelay() external view override returns (uint256) {\\r\\n        return PremiaStakingStorage.layout().withdrawalDelay;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function setWithdrawalDelay(uint256 delay) external override {\\r\\n        PremiaStakingStorage.layout().withdrawalDelay = delay;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function getXPremiaToPremiaRatio()\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return (_getStakedPremiaAmount() * 1e18) / _totalSupply();\\r\\n    }\\r\\n\\r\\n    function getPendingWithdrawal(address user)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (\\r\\n            uint256 amount,\\r\\n            uint256 startDate,\\r\\n            uint256 unlockDate\\r\\n        )\\r\\n    {\\r\\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\\r\\n        amount = l.withdrawals[user].amount;\\r\\n        startDate = l.withdrawals[user].startDate;\\r\\n        unlockDate = startDate + l.withdrawalDelay;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IPremiaStaking\\r\\n     */\\r\\n    function getStakedPremiaAmount() external view override returns (uint256) {\\r\\n        return _getStakedPremiaAmount();\\r\\n    }\\r\\n\\r\\n    function _getStakedPremiaAmount() internal view returns (uint256) {\\r\\n        PremiaStakingStorage.Layout storage l = PremiaStakingStorage.layout();\\r\\n        return IERC20(PREMIA).balanceOf(address(this)) - l.pendingWithdrawal;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/staking/FeeDiscount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {SafeCast} from \\\"@solidstate/contracts/utils/SafeCast.sol\\\";\\r\\nimport {IERC20, SafeERC20} from \\\"@solidstate/contracts/utils/SafeERC20.sol\\\";\\r\\nimport {IERC2612} from \\\"@solidstate/contracts/token/ERC20/permit/IERC2612.sol\\\";\\r\\n\\r\\nimport {FeeDiscountStorage} from \\\"./FeeDiscountStorage.sol\\\";\\r\\nimport {IFeeDiscount} from \\\"./IFeeDiscount.sol\\\";\\r\\n\\r\\n/**\\r\\n * @author Premia\\r\\n * @title A contract allowing you to lock xPremia to get Premia protocol fee discounts\\r\\n */\\r\\ncontract FeeDiscount is IFeeDiscount {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using SafeCast for uint256;\\r\\n\\r\\n    address internal immutable xPREMIA;\\r\\n    uint256 internal constant INVERSE_BASIS_POINT = 1e4;\\r\\n\\r\\n    constructor(address xPremia) {\\r\\n        xPREMIA = xPremia;\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    //////////\\r\\n    // Main //\\r\\n    //////////\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function stakeWithPermit(\\r\\n        uint256 amount,\\r\\n        uint256 period,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external {\\r\\n        IERC2612(address(xPREMIA)).permit(\\r\\n            msg.sender,\\r\\n            address(this),\\r\\n            amount,\\r\\n            deadline,\\r\\n            v,\\r\\n            r,\\r\\n            s\\r\\n        );\\r\\n        _stake(amount, period);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function stake(uint256 amount, uint256 period) external override {\\r\\n        _stake(amount, period);\\r\\n    }\\r\\n\\r\\n    function _stake(uint256 amount, uint256 period) internal {\\r\\n        FeeDiscountStorage.Layout storage l = FeeDiscountStorage.layout();\\r\\n\\r\\n        require(\\r\\n            _getStakePeriodMultiplier(period) > 0,\\r\\n            \\\"Stake period does not exists\\\"\\r\\n        );\\r\\n        FeeDiscountStorage.UserInfo storage user = l.userInfo[msg.sender];\\r\\n\\r\\n        uint256 lockedUntil = block.timestamp + period;\\r\\n        require(\\r\\n            lockedUntil > user.lockedUntil,\\r\\n            \\\"Cannot add stake with lower stake period\\\"\\r\\n        );\\r\\n\\r\\n        _transferXPremia(msg.sender, address(this), amount);\\r\\n        user.balance = user.balance + amount;\\r\\n        user.lockedUntil = lockedUntil.toUint64();\\r\\n        user.stakePeriod = period.toUint64();\\r\\n\\r\\n        emit Staked(msg.sender, amount, period, lockedUntil);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function unstake(uint256 amount) external override {\\r\\n        FeeDiscountStorage.Layout storage l = FeeDiscountStorage.layout();\\r\\n\\r\\n        FeeDiscountStorage.UserInfo storage user = l.userInfo[msg.sender];\\r\\n\\r\\n        // We allow unstake if the stakePeriod that the user used has been disabled\\r\\n        require(user.lockedUntil <= block.timestamp, \\\"Stake still locked\\\");\\r\\n\\r\\n        user.balance -= amount;\\r\\n        _transferXPremia(address(this), msg.sender, amount);\\r\\n\\r\\n        emit Unstaked(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    //////////\\r\\n    // View //\\r\\n    //////////\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function getStakeAmountWithBonus(address user)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getStakeAmountWithBonus(user);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function getDiscount(address user)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        uint256 userBalance = _getStakeAmountWithBonus(user);\\r\\n\\r\\n        IFeeDiscount.StakeLevel[] memory stakeLevels = _getStakeLevels();\\r\\n\\r\\n        for (uint256 i = 0; i < stakeLevels.length; i++) {\\r\\n            IFeeDiscount.StakeLevel memory level = stakeLevels[i];\\r\\n\\r\\n            if (userBalance < level.amount) {\\r\\n                uint256 amountPrevLevel;\\r\\n                uint256 discountPrevLevel;\\r\\n\\r\\n                // If stake is lower, user is in this level, and we need to LERP with prev level to get discount value\\r\\n                if (i > 0) {\\r\\n                    amountPrevLevel = stakeLevels[i - 1].amount;\\r\\n                    discountPrevLevel = stakeLevels[i - 1].discount;\\r\\n                } else {\\r\\n                    // If this is the first level, prev level is 0 / 0\\r\\n                    amountPrevLevel = 0;\\r\\n                    discountPrevLevel = 0;\\r\\n                }\\r\\n\\r\\n                uint256 remappedDiscount = level.discount - discountPrevLevel;\\r\\n\\r\\n                uint256 remappedAmount = level.amount - amountPrevLevel;\\r\\n                uint256 remappedBalance = userBalance - amountPrevLevel;\\r\\n                uint256 levelProgress = (remappedBalance *\\r\\n                    INVERSE_BASIS_POINT) / remappedAmount;\\r\\n\\r\\n                return\\r\\n                    discountPrevLevel +\\r\\n                    ((remappedDiscount * levelProgress) / INVERSE_BASIS_POINT);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // If no match found it means user is >= max possible stake, and therefore has max discount possible\\r\\n        return stakeLevels[stakeLevels.length - 1].discount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function getStakeLevels()\\r\\n        external\\r\\n        pure\\r\\n        override\\r\\n        returns (IFeeDiscount.StakeLevel[] memory stakeLevels)\\r\\n    {\\r\\n        return _getStakeLevels();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function getStakePeriodMultiplier(uint256 period)\\r\\n        external\\r\\n        pure\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _getStakePeriodMultiplier(period);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @inheritdoc IFeeDiscount\\r\\n     */\\r\\n    function getUserInfo(address user)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (FeeDiscountStorage.UserInfo memory)\\r\\n    {\\r\\n        return FeeDiscountStorage.layout().userInfo[user];\\r\\n    }\\r\\n\\r\\n    //////////////////////////////////////////////////\\r\\n\\r\\n    //////////////\\r\\n    // Internal //\\r\\n    //////////////\\r\\n\\r\\n    /**\\r\\n     * @notice Utility function to check if a value is inside an array\\r\\n     * @param value The value to look for\\r\\n     * @param array The array to check\\r\\n     * @return Whether the value is in the array or not\\r\\n     */\\r\\n    function _isInArray(uint256 value, uint256[] memory array)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool)\\r\\n    {\\r\\n        uint256 length = array.length;\\r\\n        for (uint256 i = 0; i < length; ++i) {\\r\\n            if (array[i] == value) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function _getStakeLevels()\\r\\n        internal\\r\\n        pure\\r\\n        returns (IFeeDiscount.StakeLevel[] memory stakeLevels)\\r\\n    {\\r\\n        stakeLevels = new IFeeDiscount.StakeLevel[](4);\\r\\n\\r\\n        stakeLevels[0] = IFeeDiscount.StakeLevel(5000 * 1e18, 2500); // -25%\\r\\n        stakeLevels[1] = IFeeDiscount.StakeLevel(50000 * 1e18, 5000); // -50%\\r\\n        stakeLevels[2] = IFeeDiscount.StakeLevel(250000 * 1e18, 7500); // -75%\\r\\n        stakeLevels[3] = IFeeDiscount.StakeLevel(500000 * 1e18, 9500); // -95%\\r\\n    }\\r\\n\\r\\n    function _getStakePeriodMultiplier(uint256 period)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        if (period == 30 days) return 10000; // x1\\r\\n        if (period == 90 days) return 12500; // x1.25\\r\\n        if (period == 180 days) return 15000; // x1.5\\r\\n        if (period == 360 days) return 20000; // x2\\r\\n\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function _getStakeAmountWithBonus(address user)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        FeeDiscountStorage.Layout storage l = FeeDiscountStorage.layout();\\r\\n\\r\\n        FeeDiscountStorage.UserInfo memory userInfo = l.userInfo[user];\\r\\n        return\\r\\n            (userInfo.balance *\\r\\n                _getStakePeriodMultiplier(userInfo.stakePeriod)) /\\r\\n            INVERSE_BASIS_POINT;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice transfer tokens from holder to recipient\\r\\n     * @param holder owner of tokens to be transferred\\r\\n     * @param recipient beneficiary of transfer\\r\\n     * @param amount quantity of tokens transferred\\r\\n     */\\r\\n    function _transferXPremia(\\r\\n        address holder,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal virtual {\\r\\n        if (holder == address(this)) {\\r\\n            IERC20(xPREMIA).safeTransfer(recipient, amount);\\r\\n        } else {\\r\\n            IERC20(xPREMIA).safeTransferFrom(holder, recipient, amount);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/staking/FeeDiscountStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary FeeDiscountStorage {\\r\\n    bytes32 internal constant STORAGE_SLOT =\\r\\n        keccak256(\\\"premia.contracts.staking.PremiaFeeDiscount\\\");\\r\\n\\r\\n    struct UserInfo {\\r\\n        uint256 balance; // Balance staked by user\\r\\n        uint64 stakePeriod; // Stake period selected by user\\r\\n        uint64 lockedUntil; // Timestamp at which the lock ends\\r\\n    }\\r\\n\\r\\n    struct Layout {\\r\\n        // User data with xPREMIA balance staked and date at which lock ends\\r\\n        mapping(address => UserInfo) userInfo;\\r\\n    }\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/staking/IPremiaStakingOld.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPremiaStakingOld {\\r\\n    /**\\r\\n     * @notice stake PREMIA using IERC2612 permit\\r\\n     * @param amount quantity of PREMIA to stake\\r\\n     * @param deadline timestamp after which permit will fail\\r\\n     * @param v signature \\\"v\\\" value\\r\\n     * @param r signature \\\"r\\\" value\\r\\n     * @param s signature \\\"s\\\" value\\r\\n     */\\r\\n    function enterWithPermit(\\r\\n        uint256 amount,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice stake PREMIA in exchange for xPremia\\r\\n     * @param amount quantity of PREMIA to stake\\r\\n     */\\r\\n    function enter(uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @notice burn xPremia in exchange for staked PREMIA\\r\\n     * @param amount quantity of xPremia to unstake\\r\\n     */\\r\\n    function leave(uint256 amount) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/staking/IPremiaStakingWithFeeDiscount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {IPremiaStaking} from \\\"./IPremiaStaking.sol\\\";\\r\\nimport {IFeeDiscount} from \\\"./IFeeDiscount.sol\\\";\\r\\n\\r\\ninterface IPremiaStakingWithFeeDiscount is IPremiaStaking, IFeeDiscount {}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial ERC20 interface needed by internal functions\\n */\\ninterface IERC20Internal {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ERC20Base } from './base/ERC20Base.sol';\\nimport { ERC20Extended } from './extended/ERC20Extended.sol';\\nimport { ERC20Metadata } from './metadata/ERC20Metadata.sol';\\n\\n/**\\n * @title SolidState ERC20 implementation, including recommended extensions\\n */\\nabstract contract ERC20 is ERC20Base, ERC20Extended, ERC20Metadata {\\n\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/permit/ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { ECDSA } from '../../../cryptography/ECDSA.sol';\\nimport { ERC20Base } from '../base/ERC20Base.sol';\\nimport { ERC20Metadata } from '../metadata/ERC20Metadata.sol';\\nimport { ERC20PermitStorage } from './ERC20PermitStorage.sol';\\nimport { IERC2612 } from './IERC2612.sol';\\n\\n/**\\n * @title ERC20 extension with support for ERC2612 permits\\n * @dev derived from https://github.com/soliditylabs/ERC20-Permit (MIT license)\\n */\\nabstract contract ERC20Permit is IERC2612, ERC20Base, ERC20Metadata {\\n    using ECDSA for bytes32;\\n\\n    /**\\n     * @inheritdoc IERC2612\\n     * @dev If https://eips.ethereum.org/EIPS/eip-1344[ChainID] ever changes, the\\n     * EIP712 Domain Separator is automatically recalculated.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, 'ERC20Permit: expired deadline');\\n\\n        // Assembly for more efficiently computing:\\n        // bytes32 hashStruct = keccak256(\\n        //   abi.encode(\\n        //     _PERMIT_TYPEHASH,\\n        //     owner,\\n        //     spender,\\n        //     amount,\\n        //     _nonces[owner].current(),\\n        //     deadline\\n        //   )\\n        // );\\n\\n        bytes32 hashStruct;\\n        uint256 nonce = ERC20PermitStorage.layout().nonces[owner];\\n\\n        assembly {\\n            // Load free memory pointer\\n            let memPtr := mload(64)\\n\\n            // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")\\n            mstore(\\n                memPtr,\\n                0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9\\n            )\\n            mstore(add(memPtr, 32), owner)\\n            mstore(add(memPtr, 64), spender)\\n            mstore(add(memPtr, 96), amount)\\n            mstore(add(memPtr, 128), nonce)\\n            mstore(add(memPtr, 160), deadline)\\n\\n            hashStruct := keccak256(memPtr, 192)\\n        }\\n\\n        bytes32 eip712DomainHash = _domainSeparator();\\n\\n        // Assembly for more efficient computing:\\n        // bytes32 hash = keccak256(\\n        //   abi.encodePacked(uint16(0x1901), eip712DomainHash, hashStruct)\\n        // );\\n\\n        bytes32 hash;\\n\\n        assembly {\\n            // Load free memory pointer\\n            let memPtr := mload(64)\\n\\n            mstore(\\n                memPtr,\\n                0x1901000000000000000000000000000000000000000000000000000000000000\\n            ) // EIP191 header\\n            mstore(add(memPtr, 2), eip712DomainHash) // EIP712 domain hash\\n            mstore(add(memPtr, 34), hashStruct) // Hash of struct\\n\\n            hash := keccak256(memPtr, 66)\\n        }\\n\\n        address signer = hash.recover(v, r, s);\\n\\n        require(signer == owner, 'ERC20Permit: invalid signature');\\n\\n        ERC20PermitStorage.layout().nonces[owner]++;\\n        _approve(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev inhertidoc IERC2612\\n     */\\n    function nonces(address owner) public view override returns (uint256) {\\n        return ERC20PermitStorage.layout().nonces[owner];\\n    }\\n\\n    /**\\n     * @notice update domain separator for new chain ID\\n     * @return new domain separator\\n     */\\n    function _updateDomainSeparator() private returns (bytes32) {\\n        uint256 chainId = _chainId();\\n\\n        // no need for assembly, running very rarely\\n        bytes32 newDomainSeparator = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\\n                ),\\n                keccak256(bytes(name())), // ERC-20 Name\\n                keccak256(bytes('1')), // Version\\n                chainId,\\n                address(this)\\n            )\\n        );\\n\\n        ERC20PermitStorage.layout().domainSeparators[\\n            chainId\\n        ] = newDomainSeparator;\\n\\n        return newDomainSeparator;\\n    }\\n\\n    /**\\n     * @notice update chain ID if changed and return domain separator\\n     * @return domain separator\\n     */\\n    function _domainSeparator() private returns (bytes32) {\\n        bytes32 domainSeparator = ERC20PermitStorage.layout().domainSeparators[\\n            _chainId()\\n        ];\\n\\n        if (domainSeparator != 0x00) {\\n            return domainSeparator;\\n        }\\n\\n        return _updateDomainSeparator();\\n    }\\n\\n    /**\\n     * @notice get the current chain ID\\n     * @return chainId chain ID\\n     */\\n    function _chainId() private view returns (uint256 chainId) {\\n        assembly {\\n            chainId := chainid()\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '../token/ERC20/IERC20.sol';\\nimport { AddressUtils } from './AddressUtils.sol';\\n\\n/**\\n * @title Safe ERC20 interaction library\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary SafeERC20 {\\n    using AddressUtils for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transfer.selector, to, value)\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\\n        );\\n    }\\n\\n    /**\\n     * @dev safeApprove (like approve) should only be called when setting an initial allowance or when resetting it to zero; otherwise prefer safeIncreaseAllowance and safeDecreaseAllowance\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            'SafeERC20: approve from non-zero to non-zero allowance'\\n        );\\n\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(token.approve.selector, spender, value)\\n        );\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(\\n            token,\\n            abi.encodeWithSelector(\\n                token.approve.selector,\\n                spender,\\n                newAllowance\\n            )\\n        );\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(\\n                oldAllowance >= value,\\n                'SafeERC20: decreased allowance below zero'\\n            );\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(\\n                token,\\n                abi.encodeWithSelector(\\n                    token.approve.selector,\\n                    spender,\\n                    newAllowance\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @notice send transaction data and check validity of return value, if present\\n     * @param token ERC20 token interface\\n     * @param data transaction data\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata = address(token).functionCall(\\n            data,\\n            'SafeERC20: low-level call failed'\\n        );\\n\\n        if (returndata.length > 0) {\\n            require(\\n                abi.decode(returndata, (bool)),\\n                'SafeERC20: ERC20 operation did not succeed'\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/IPremiaStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {PremiaStakingStorage} from \\\"./PremiaStakingStorage.sol\\\";\\r\\n\\r\\ninterface IPremiaStaking {\\r\\n    event Deposit(address indexed user, uint256 amount);\\r\\n    event StartWithdrawal(\\r\\n        address indexed user,\\r\\n        uint256 premiaAmount,\\r\\n        uint256 startDate\\r\\n    );\\r\\n    event Withdrawal(address indexed user, uint256 amount);\\r\\n\\r\\n    /**\\r\\n     * @notice stake PREMIA using IERC2612 permit\\r\\n     * @param amount quantity of PREMIA to stake\\r\\n     * @param deadline timestamp after which permit will fail\\r\\n     * @param v signature \\\"v\\\" value\\r\\n     * @param r signature \\\"r\\\" value\\r\\n     * @param s signature \\\"s\\\" value\\r\\n     */\\r\\n    function depositWithPermit(\\r\\n        uint256 amount,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice stake PREMIA in exchange for xPremia\\r\\n     * @param amount quantity of PREMIA to stake\\r\\n     */\\r\\n    function deposit(uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Initiate the withdrawal process by burning xPremia, starting the delay period\\r\\n     * @param amount quantity of xPremia to unstake\\r\\n     */\\r\\n    function startWithdraw(uint256 amount) external;\\r\\n\\r\\n    /**\\r\\n     * @notice withdraw PREMIA after withdrawal delay has passed\\r\\n     */\\r\\n    function withdraw() external;\\r\\n\\r\\n    /**\\r\\n     * @notice get current withdrawal delay\\r\\n     * @return withdrawal delay\\r\\n     */\\r\\n    function getWithdrawalDelay() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice set current withdrawal delay\\r\\n     * @param delay withdrawal delay\\r\\n     */\\r\\n    function setWithdrawalDelay(uint256 delay) external;\\r\\n\\r\\n    /**\\r\\n     * @notice get the xPREMIA : PREMIA ratio (with 18 decimals)\\r\\n     * @return xPREMIA : PREMIA ratio (with 18 decimals)\\r\\n     */\\r\\n    function getXPremiaToPremiaRatio() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice get pending withdrawal data of a user\\r\\n     * @return amount pending withdrawal amount\\r\\n     * @return startDate start timestamp of withdrawal\\r\\n     * @return unlockDate timestamp at which withdrawal becomes available\\r\\n     */\\r\\n    function getPendingWithdrawal(address user)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 amount,\\r\\n            uint256 startDate,\\r\\n            uint256 unlockDate\\r\\n        );\\r\\n\\r\\n    /**\\r\\n     * @notice get the amount of PREMIA staked (subtracting all pending withdrawals)\\r\\n     * @return amount of PREMIA staked\\r\\n     */\\r\\n    function getStakedPremiaAmount() external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/staking/PremiaStakingStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n// For further clarification please see https://license.premia.legal\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary PremiaStakingStorage {\\r\\n    bytes32 internal constant STORAGE_SLOT =\\r\\n        keccak256(\\\"premia.contracts.staking.PremiaStaking\\\");\\r\\n\\r\\n    struct Withdrawal {\\r\\n        uint256 amount; // Premia amount\\r\\n        uint256 startDate; // Will unlock at startDate + withdrawalDelay\\r\\n    }\\r\\n\\r\\n    struct Layout {\\r\\n        uint256 pendingWithdrawal;\\r\\n        uint256 withdrawalDelay;\\r\\n        mapping(address => Withdrawal) withdrawals;\\r\\n    }\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/base/ERC20Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from '../IERC20.sol';\\nimport { ERC20BaseInternal } from './ERC20BaseInternal.sol';\\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\\n\\n/**\\n * @title Base ERC20 implementation, excluding optional extensions\\n */\\nabstract contract ERC20Base is IERC20, ERC20BaseInternal {\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function balanceOf(address account)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return _balanceOf(account);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function allowance(address holder, address spender)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        return ERC20BaseStorage.layout().allowances[holder][spender];\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function approve(address spender, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        public\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20\\n     */\\n    function transferFrom(\\n        address holder,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        uint256 currentAllowance = ERC20BaseStorage.layout().allowances[holder][\\n            msg.sender\\n        ];\\n        require(\\n            currentAllowance >= amount,\\n            'ERC20: transfer amount exceeds allowance'\\n        );\\n        unchecked {\\n            _approve(holder, msg.sender, currentAllowance - amount);\\n        }\\n        _transfer(holder, recipient, amount);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/extended/ERC20Extended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ERC20Base, ERC20BaseStorage } from '../base/ERC20Base.sol';\\n\\n/**\\n * @title ERC20 safe approval extensions\\n * @dev mitigations for transaction-ordering vulnerability (see https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729)\\n */\\nabstract contract ERC20Extended is ERC20Base {\\n    /**\\n     * @notice increase spend amount granted to spender\\n     * @param spender address whose allowance to increase\\n     * @param amount quantity by which to increase allowance\\n     * @return success status (always true; otherwise function will revert)\\n     */\\n    function increaseAllowance(address spender, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        unchecked {\\n            mapping(address => uint256) storage allowances = ERC20BaseStorage\\n                .layout()\\n                .allowances[msg.sender];\\n\\n            uint256 allowance = allowances[spender];\\n            require(\\n                allowance + amount >= allowance,\\n                'ERC20Extended: excessive allowance'\\n            );\\n\\n            _approve(\\n                msg.sender,\\n                spender,\\n                allowances[spender] = allowance + amount\\n            );\\n\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @notice decrease spend amount granted to spender\\n     * @param spender address whose allowance to decrease\\n     * @param amount quantity by which to decrease allowance\\n     * @return success status (always true; otherwise function will revert)\\n     */\\n    function decreaseAllowance(address spender, uint256 amount)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        unchecked {\\n            mapping(address => uint256) storage allowances = ERC20BaseStorage\\n                .layout()\\n                .allowances[msg.sender];\\n\\n            uint256 allowance = allowances[spender];\\n            require(\\n                amount <= allowance,\\n                'ERC20Extended: insufficient allowance'\\n            );\\n\\n            _approve(\\n                msg.sender,\\n                spender,\\n                allowances[spender] = allowance - amount\\n            );\\n\\n            return true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/metadata/ERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ERC20MetadataStorage } from './ERC20MetadataStorage.sol';\\nimport { IERC20Metadata } from './IERC20Metadata.sol';\\n\\n/**\\n * @title ERC20 metadata extensions\\n */\\nabstract contract ERC20Metadata is IERC20Metadata {\\n    /**\\n     * @inheritdoc IERC20Metadata\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return ERC20MetadataStorage.layout().name;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20Metadata\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return ERC20MetadataStorage.layout().symbol;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC20Metadata\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return ERC20MetadataStorage.layout().decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/base/ERC20BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC20Internal } from '../IERC20Internal.sol';\\nimport { ERC20BaseStorage } from './ERC20BaseStorage.sol';\\n\\n/**\\n * @title Base ERC20 implementation, excluding optional extensions\\n */\\nabstract contract ERC20BaseInternal is IERC20Internal {\\n    /**\\n     * @notice query the total minted token supply\\n     * @return token supply\\n     */\\n    function _totalSupply() internal view virtual returns (uint256) {\\n        return ERC20BaseStorage.layout().totalSupply;\\n    }\\n\\n    /**\\n     * @notice query the token balance of given account\\n     * @param account address to query\\n     * @return token balance\\n     */\\n    function _balanceOf(address account)\\n        internal\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        return ERC20BaseStorage.layout().balances[account];\\n    }\\n\\n    /**\\n     * @notice enable spender to spend tokens on behalf of holder\\n     * @param holder address on whose behalf tokens may be spent\\n     * @param spender recipient of allowance\\n     * @param amount quantity of tokens approved for spending\\n     */\\n    function _approve(\\n        address holder,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(holder != address(0), 'ERC20: approve from the zero address');\\n        require(spender != address(0), 'ERC20: approve to the zero address');\\n\\n        ERC20BaseStorage.layout().allowances[holder][spender] = amount;\\n\\n        emit Approval(holder, spender, amount);\\n    }\\n\\n    /**\\n     * @notice mint tokens for given account\\n     * @param account recipient of minted tokens\\n     * @param amount quantity of tokens minted\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), 'ERC20: mint to the zero address');\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\n        l.totalSupply += amount;\\n        l.balances[account] += amount;\\n\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @notice burn tokens held by given account\\n     * @param account holder of burned tokens\\n     * @param amount quantity of tokens burned\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), 'ERC20: burn from the zero address');\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\n        uint256 balance = l.balances[account];\\n        require(balance >= amount, 'ERC20: burn amount exceeds balance');\\n        unchecked {\\n            l.balances[account] = balance - amount;\\n        }\\n        l.totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @notice transfer tokens from holder to recipient\\n     * @param holder owner of tokens to be transferred\\n     * @param recipient beneficiary of transfer\\n     * @param amount quantity of tokens transferred\\n     */\\n    function _transfer(\\n        address holder,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(holder != address(0), 'ERC20: transfer from the zero address');\\n        require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n        _beforeTokenTransfer(holder, recipient, amount);\\n\\n        ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\n        uint256 holderBalance = l.balances[holder];\\n        require(\\n            holderBalance >= amount,\\n            'ERC20: transfer amount exceeds balance'\\n        );\\n        unchecked {\\n            l.balances[holder] = holderBalance - amount;\\n        }\\n        l.balances[recipient] += amount;\\n\\n        emit Transfer(holder, recipient, amount);\\n    }\\n\\n    /**\\n     * @notice ERC20 hook, called before all transfers including mint and burn\\n     * @dev function should be overridden and new implementation must call super\\n     * @param from sender of tokens\\n     * @param to receiver of tokens\\n     * @param amount quantity of tokens transferred\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/base/ERC20BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ERC20BaseStorage {\\n    struct Layout {\\n        mapping(address => uint256) balances;\\n        mapping(address => mapping(address => uint256)) allowances;\\n        uint256 totalSupply;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC20Base');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/metadata/ERC20MetadataStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ERC20MetadataStorage {\\n    struct Layout {\\n        string name;\\n        string symbol;\\n        uint8 decimals;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC20Metadata');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function setName(Layout storage l, string memory name) internal {\\n        l.name = name;\\n    }\\n\\n    function setSymbol(Layout storage l, string memory symbol) internal {\\n        l.symbol = symbol;\\n    }\\n\\n    function setDecimals(Layout storage l, uint8 decimals) internal {\\n        l.decimals = decimals;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/metadata/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC20 metadata interface\\n */\\ninterface IERC20Metadata {\\n    /**\\n     * @notice return token name\\n     * @return token name\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @notice return token symbol\\n     * @return token symbol\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @notice return token decimals, generally used only for display purposes\\n     * @return token decimals\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Elliptic Curve Digital Signature Algorithm (ECDSA) operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary ECDSA {\\n    /**\\n     * @notice recover signer of hashed message from signature\\n     * @param hash hashed data payload\\n     * @param signature signed data payload\\n     * @return recovered message signer\\n     */\\n    function recover(bytes32 hash, bytes memory signature)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        require(signature.length == 65, 'ECDSA: invalid signature length');\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @notice recover signer of hashed message from signature v, r, and s values\\n     * @param hash hashed data payload\\n     * @param v signature \\\"v\\\" value\\n     * @param r signature \\\"r\\\" value\\n     * @param s signature \\\"s\\\" value\\n     * @return recovered message signer\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(\\n            uint256(s) <=\\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n            \\\"ECDSA: invalid signature 's' value\\\"\\n        );\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), 'ECDSA: invalid signature');\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @notice generate an \\\"Ethereum Signed Message\\\" in the format returned by the eth_sign JSON-RPC method\\n     * @param hash hashed data payload\\n     * @return signed message hash\\n     */\\n    function toEthSignedMessageHash(bytes32 hash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked('\\\\x19Ethereum Signed Message:\\\\n32', hash)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/permit/ERC20PermitStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ERC20PermitStorage {\\n    struct Layout {\\n        mapping(address => uint256) nonces;\\n        // Mapping of ChainID to domain separators. This is a very gas efficient way\\n        // to not recalculate the domain separator on every call, while still\\n        // automatically detecting ChainID changes.\\n        mapping(uint256 => bytes32) domainSeparators;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC20Permit');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary AddressUtils {\\n    function toString(address account) internal pure returns (string memory) {\\n        bytes32 value = bytes32(uint256(uint160(account)));\\n        bytes memory alphabet = '0123456789abcdef';\\n        bytes memory chars = new bytes(42);\\n\\n        chars[0] = '0';\\n        chars[1] = 'x';\\n\\n        for (uint256 i = 0; i < 20; i++) {\\n            chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\\n            chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\\n        }\\n\\n        return string(chars);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        require(success, 'AddressUtils: failed to send value');\\n    }\\n\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            'AddressUtils: insufficient balance for call'\\n        );\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        require(\\n            isContract(target),\\n            'AddressUtils: function call to non-contract'\\n        );\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/IFeeDiscount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport {FeeDiscountStorage} from \\\"./FeeDiscountStorage.sol\\\";\\r\\n\\r\\ninterface IFeeDiscount {\\r\\n    event Staked(\\r\\n        address indexed user,\\r\\n        uint256 amount,\\r\\n        uint256 stakePeriod,\\r\\n        uint256 lockedUntil\\r\\n    );\\r\\n    event Unstaked(address indexed user, uint256 amount);\\r\\n\\r\\n    struct StakeLevel {\\r\\n        uint256 amount; // Amount to stake\\r\\n        uint256 discount; // Discount when amount is reached\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Stake using IERC2612 permit\\r\\n     * @param amount The amount of xPremia to stake\\r\\n     * @param period The lockup period (in seconds)\\r\\n     * @param deadline Deadline after which permit will fail\\r\\n     * @param v V\\r\\n     * @param r R\\r\\n     * @param s S\\r\\n     */\\r\\n    function stakeWithPermit(\\r\\n        uint256 amount,\\r\\n        uint256 period,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Lockup xPremia for protocol fee discounts\\r\\n     *          Longer period of locking will apply a multiplier on the amount staked, in the fee discount calculation\\r\\n     * @param amount The amount of xPremia to stake\\r\\n     * @param period The lockup period (in seconds)\\r\\n     */\\r\\n    function stake(uint256 amount, uint256 period) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Unstake xPremia (If lockup period has ended)\\r\\n     * @param amount The amount of xPremia to unstake\\r\\n     */\\r\\n    function unstake(uint256 amount) external;\\r\\n\\r\\n    //////////\\r\\n    // View //\\r\\n    //////////\\r\\n\\r\\n    /**\\r\\n     * Calculate the stake amount of a user, after applying the bonus from the lockup period chosen\\r\\n     * @param user The user from which to query the stake amount\\r\\n     * @return The user stake amount after applying the bonus\\r\\n     */\\r\\n    function getStakeAmountWithBonus(address user)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate the % of fee discount for user, based on his stake\\r\\n     * @param user The _user for which the discount is for\\r\\n     * @return Percentage of protocol fee discount (in basis point)\\r\\n     *         Ex : 1000 = 10% fee discount\\r\\n     */\\r\\n    function getDiscount(address user) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Get stake levels\\r\\n     * @return Stake levels\\r\\n     *         Ex : 2500 = -25%\\r\\n     */\\r\\n    function getStakeLevels() external returns (StakeLevel[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Get stake period multiplier\\r\\n     * @param period The duration (in seconds) for which tokens are locked\\r\\n     * @return The multiplier for this staking period\\r\\n     *         Ex : 20000 = x2\\r\\n     */\\r\\n    function getStakePeriodMultiplier(uint256 period)\\r\\n        external\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Get staking infos of a user\\r\\n     * @param user The user address for which to get staking infos\\r\\n     * @return The staking infos of the user\\r\\n     */\\r\\n    function getUserInfo(address user)\\r\\n        external\\r\\n        view\\r\\n        returns (FeeDiscountStorage.UserInfo memory);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"premia\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldFeeDiscount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldStaking\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakePeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"premiaAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"}],\"name\":\"StartWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"depositWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getPendingWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getStakeAmountWithBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeLevels\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"discount\",\"type\":\"uint256\"}],\"internalType\":\"struct IFeeDiscount.StakeLevel[]\",\"name\":\"stakeLevels\",\"type\":\"tuple[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"getStakePeriodMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakedPremiaAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"stakePeriod\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lockedUntil\",\"type\":\"uint64\"}],\"internalType\":\"struct FeeDiscountStorage.UserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawalDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getXPremiaToPremiaRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"migrateWithoutLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"premiaDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xPremiaMinted\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"migrateWithoutLockWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"premiaDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xPremiaMinted\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"setWithdrawalDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"stakeWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"startWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PremiaStakingWithFeeDiscount","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006399c842dd2be3de30bf99bc7d1bbf6fa3650e70000000000000000000000000f5aae75d1ad6fdd62cce66137f2674c96feda85400000000000000000000000016f9d564df80376c61ac914205d3fdff7057d610","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}