{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/bridge/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\n\\r\\nlibrary ECDSA {\\r\\n  function isMessageValid(bytes memory message) public pure returns (bool) {\\r\\n    return message.length == 136;\\r\\n  }\\r\\n\\r\\n  function formMessage(address from, address to, uint amount, uint nonce) external pure \\r\\n    returns (bytes32)\\r\\n  {\\r\\n    bytes32 message = keccak256(abi.encodePacked(\\r\\n      from,\\r\\n      to, \\r\\n      amount,\\r\\n      nonce\\r\\n    ));\\r\\n    return message;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Accepts the (v,r,s) signature and the message and returns the \\r\\n   * address that signed the signature. It accounts for malleability issue\\r\\n   * with the native ecrecover.\\r\\n   */\\r\\n  function getSigner(\\r\\n    bytes32 message, \\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) private pure returns (address) {\\r\\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\r\\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\r\\n    // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\\r\\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\r\\n    //\\r\\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\r\\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\r\\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\r\\n    // these malleable signatures as well.\\r\\n    require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\r\\n            \\\"ECDSA: invalid signature 's' value\\\");\\r\\n    require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\r\\n\\r\\n    // If the signature is valid (and not malleable), return the signer address\\r\\n    address signer = ecrecover(hashMessage(message), v, r, s);\\r\\n    require(signer != address(0), \\\"ECDSA:invalid signature\\\");\\r\\n\\r\\n    return signer;\\r\\n  }\\r\\n\\r\\n  function hashMessage(bytes32 message) internal pure returns (bytes32) {\\r\\n    bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\r\\n    return keccak256(abi.encodePacked(prefix, message));\\r\\n  }\\r\\n\\r\\n  /**\\r\\n    * @dev Returns the address that signed a hashed message (`hash`) with\\r\\n    * `signature`. This address can then be used for verification purposes.\\r\\n    *\\r\\n    * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\r\\n    * this function rejects them by requiring the `s` value to be in the lower\\r\\n    * half order, and the `v` value to be either 27 or 28.\\r\\n    *\\r\\n    * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\r\\n    * verification to be secure: it is possible to craft signatures that\\r\\n    * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\r\\n    * this is by receiving a hash of the original message (which may otherwise\\r\\n    * be too long), and then calling {toEthSignedMessageHash} on it.\\r\\n    */\\r\\n  function recoverAddress(\\r\\n    bytes32 message, \\r\\n    bytes memory signature\\r\\n  ) external view returns (address) {\\r\\n    // Check the signature length\\r\\n    require(signature.length == 65, \\\"ECDSA: invalid signature length\\\");\\r\\n\\r\\n    // Divide the signature in r, s and v variables\\r\\n    bytes32 r;\\r\\n    bytes32 s;\\r\\n    uint8 v;\\r\\n\\r\\n    // ecrecover takes the signature parameters, and the only way to get them\\r\\n    // currently is to use assembly.\\r\\n    // solhint-disable-next-line no-inline-assembly\\r\\n    assembly {\\r\\n      r := mload(add(signature, 0x20))\\r\\n      s := mload(add(signature, 0x40))\\r\\n      v := byte(0, mload(add(signature, 0x60)))\\r\\n    }\\r\\n\\r\\n    return getSigner(message, v, r, s);\\r\\n  }\\r\\n\\r\\n  // layout of message :: bytes:\\r\\n  // offset  0: 32 bytes :: uint256 - message length\\r\\n  // offset 32: 20 bytes :: address - recipient address\\r\\n  // offset 52: 32 bytes :: uint256 - value\\r\\n  // offset 84: 32 bytes :: bytes32 - transaction hash\\r\\n  // offset 116: 32 bytes :: uint256 - nonce\\r\\n  // offset 136: 20 bytes :: address - contract address to prevent double spending\\r\\n\\r\\n  // mload always reads 32 bytes.\\r\\n  // so we can and have to start reading recipient at offset 20 instead of 32.\\r\\n  // if we were to read at 32 the address would contain part of value and be corrupted.\\r\\n  // when reading from offset 20 mload will read 12 bytes (most of them zeros) followed\\r\\n  // by the 20 recipient address bytes and correctly convert it into an address.\\r\\n  // this saves some storage/gas over the alternative solution\\r\\n  // which is padding address to 32 bytes and reading recipient at offset 32.\\r\\n  // for more details see discussion in:\\r\\n  // https://github.com/paritytech/parity-bridge/issues/61\\r\\n  function parseMessage(bytes memory message) internal view returns (\\r\\n    address recipient, \\r\\n    uint256 amount, \\r\\n    uint256 txHash,\\r\\n    uint256 nonce,\\r\\n    address contractAddress\\r\\n  ) {\\r\\n    require(isMessageValid(message), \\\"ECDSA: parse error invalid message\\\");\\r\\n    \\r\\n    assembly {\\r\\n      recipient := mload(add(message, 20))\\r\\n      amount := mload(add(message, 52))\\r\\n      txHash := mload(add(message, 84))\\r\\n      nonce := mload(add(message, 116))\\r\\n      contractAddress := mload(add(message, 136))\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"formMessage\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"isMessageValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"message\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"recoverAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ECDSA","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://23d5b09d301b9262ed08c76dd3d548b224cb98caca756f629d0b7fb28038246a"}]}