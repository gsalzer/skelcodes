{"status":"1","message":"OK","result":[{"SourceCode":"{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"},\"Migrations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ncontract Migrations {\\r\\n  address public owner = msg.sender;\\r\\n  uint public last_completed_migration;\\r\\n\\r\\n  modifier restricted() {\\r\\n    require(\\r\\n      msg.sender == owner,\\r\\n      \\\"This function is restricted to the contract\\u0027s owner\\\"\\r\\n    );\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function setCompleted(uint completed) public restricted {\\r\\n    last_completed_migration = completed;\\r\\n  }\\r\\n}\\r\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _setOwner(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _setOwner(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _setOwner(newOwner);\\r\\n    }\\r\\n\\r\\n    function _setOwner(address newOwner) private {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"},\"RankNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\n// Created by Al Razzaq\\r\\n// Name of the project\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\n\\r\\ncontract RankNFT is Ownable {\\r\\n    \\r\\n    using SafeMath for uint256;\\r\\n  \\r\\n//*********** Variables *****************\\r\\n\\r\\n  uint constant DAY_IN_SECONDS = 86400;\\r\\n  uint constant MINUTES_IN_SECONDS = 3600;\\r\\n  address constant private developer = 0xE813d775f33a97BDA25D71240525C724423D4Cd0;\\r\\n  \\r\\n  uint private costOfSixMonthMemmbership =  0.7 ether;\\r\\n  uint private costOfOneMonthMemmbership =  0.15 ether;\\r\\n  uint private costOfSevenDaysMemmbership =  0.06 ether;\\r\\n  uint private costOfOneDayMemmbership =  0.02 ether;\\r\\n  \\r\\n  address[] private whitelistedUsers;\\r\\n\\r\\n\\r\\n//*********** Mappings *****************\\r\\n\\r\\n  mapping(address =\\u003e uint256) public whitelisting_period;\\r\\n  mapping(address =\\u003e uint256) public subscription_period;\\r\\n  \\r\\n\\r\\n//*********** Events *****************\\r\\n  event AmountChanged(address account);\\r\\n  event MembershipAssigned(address account, uint duration);\\r\\n\\r\\n  event WhiteListed(address account, uint duration);\\r\\n  event BlackListed(address account);\\r\\n  event PaymentReleased(address to, uint256 amount);\\r\\n  event PaymentReceived(address from, uint256 amount);\\r\\n   \\r\\n  \\r\\n  function developer_address() public pure returns(address){\\r\\n    return developer;\\r\\n  }\\r\\n\\r\\n  function set_cost_of_subscription(uint256 _days, uint256 _amount) public onlyOwner{\\r\\n      require(_days == 1 || _days == 7 || _days == 30 || _days == 180);\\r\\n      \\r\\n      if(_days == 1){\\r\\n        costOfOneDayMemmbership = _amount;\\r\\n      }\\r\\n      if(_days == 7){\\r\\n        costOfSevenDaysMemmbership = _amount;\\r\\n      }\\r\\n      if(_days == 30){\\r\\n        costOfOneMonthMemmbership = _amount;\\r\\n      }\\r\\n      if(_days == 180){\\r\\n        costOfSixMonthMemmbership = _amount;\\r\\n      }\\r\\n      \\r\\n  }\\r\\n  \\r\\n  function get_cost_of_subscription(uint256 _days) view public returns(uint) {\\r\\n      require(_days == 1 || _days == 7 || _days == 30 || _days == 180);\\r\\n      \\r\\n      if(_days == 1){\\r\\n        return costOfOneDayMemmbership;\\r\\n      }\\r\\n      if(_days == 7){\\r\\n        return costOfSevenDaysMemmbership;\\r\\n      }\\r\\n      if(_days == 30){\\r\\n        return costOfOneMonthMemmbership;\\r\\n      }\\r\\n      if(_days == 180){\\r\\n        return costOfSixMonthMemmbership;\\r\\n      }\\r\\n      else {\\r\\n          return 0;\\r\\n      }\\r\\n\\r\\n  }\\r\\n \\r\\n\\r\\n  function assign_subscription(address _user, uint256 _days) internal {\\r\\n\\r\\n    whitelistUser(_user, _days);\\r\\n\\r\\n    if(subscription_period[_user] \\u003e block.timestamp){\\r\\n        subscription_period[_user] = subscription_period[_user].add(DAY_IN_SECONDS.mul(_days));\\r\\n        emit MembershipAssigned(_user, subscription_period[_user]);\\r\\n    }\\r\\n    else{\\r\\n        subscription_period[_user] = block.timestamp.add(DAY_IN_SECONDS.mul(_days));\\r\\n        emit MembershipAssigned(_user, subscription_period[_user]);\\r\\n\\r\\n    }\\r\\n\\r\\n   distribute_equity();\\r\\n            \\r\\n}\\r\\n\\r\\n  function whitelistUser(address _user, uint256 _days) internal {\\r\\n\\r\\n    if(whitelisting_period[_user] \\u003e block.timestamp){\\r\\n        whitelisting_period[_user] = whitelisting_period[_user].add(DAY_IN_SECONDS.mul(_days));\\r\\n        emit WhiteListed(_user, whitelisting_period[_user]);\\r\\n    }\\r\\n    else {\\r\\n        whitelistedUsers.push(_user);\\r\\n        whitelisting_period[_user] = block.timestamp.add(DAY_IN_SECONDS.mul(_days));\\r\\n        emit WhiteListed(_user, whitelisting_period[_user]);\\r\\n\\r\\n    }\\r\\n    \\r\\n  }\\r\\n\\r\\n  function blacklistUser(address _user) internal {\\r\\n    delete whitelisting_period[_user];\\r\\n    delete subscription_period[_user];\\r\\n    emit BlackListed(_user);\\r\\n  }\\r\\n\\r\\n  \\r\\n      // free one hour subscription\\r\\n  function giveaway_subscription(address[] memory _users, uint _hours) public onlyOwner {\\r\\n    \\r\\n    for(uint i = 0; i \\u003c _users.length; i++){\\r\\n\\r\\n        if(whitelisting_period[_users[i]] \\u003e block.timestamp){\\r\\n            whitelisting_period[_users[i]] = whitelisting_period[_users[i]].add(MINUTES_IN_SECONDS.mul(_hours));\\r\\n            emit WhiteListed(_users[i], whitelisting_period[_users[i]]);\\r\\n        }\\r\\n        else {\\r\\n            whitelistedUsers.push(_users[i]);\\r\\n            whitelisting_period[_users[i]] = block.timestamp.add(MINUTES_IN_SECONDS.mul(_hours));\\r\\n            emit WhiteListed(_users[i], whitelisting_period[_users[i]]);\\r\\n    \\r\\n        }      \\r\\n          subscription_period[_users[i]] \\u003e block.timestamp ?\\r\\n                subscription_period[_users[i]] = subscription_period[_users[i]].add(MINUTES_IN_SECONDS.mul(_hours)) :\\r\\n                subscription_period[_users[i]] = block.timestamp.add(MINUTES_IN_SECONDS.mul(_hours));\\r\\n                \\r\\n    }\\r\\n    \\r\\n  }\\r\\n\\r\\n\\r\\n\\r\\n      // Daily subscription\\r\\n  function get_single_day_subscription() public payable {\\r\\n\\r\\n      require(msg.value \\u003e= costOfOneDayMemmbership, \\\"not enough money sent\\\");\\r\\n      require(whitelisting_period[msg.sender] \\u003e block.timestamp, \\\"Not whitelisting_period, Please contact to Admin\\\");\\r\\n\\r\\n    assign_subscription(msg.sender, 1);\\r\\n\\r\\n  }     \\r\\n   \\r\\n      // Weekly subscription\\r\\n  function get_seven_days_subscription() public payable {\\r\\n\\r\\n      require(msg.value \\u003e= costOfSevenDaysMemmbership, \\\"not enough money sent\\\");\\r\\n      require(whitelisting_period[msg.sender] \\u003eblock.timestamp, \\\"Not whitelisting_period, Please contact to Admin\\\");\\r\\n      \\r\\n      assign_subscription(msg.sender, 7);\\r\\n\\r\\n}\\r\\n\\r\\n      // Monthly subscription\\r\\n  function get_one_month_subscription() public payable {\\r\\n\\r\\n      require(msg.value \\u003e= costOfOneMonthMemmbership, \\\"not enough money sent\\\");\\r\\n      require(whitelisting_period[msg.sender] \\u003eblock.timestamp, \\\"Not whitelisting_period, Please contact to Admin\\\");\\r\\n\\r\\n         assign_subscription(msg.sender, 30);\\r\\n\\r\\n}\\r\\n\\r\\n      // Six Monthl subscription\\r\\n  function get_six_month_subscription() public payable {\\r\\n\\r\\n      require(msg.value \\u003e= costOfSixMonthMemmbership, \\\"not enough money sent\\\");\\r\\n      require(whitelisting_period[msg.sender] \\u003e block.timestamp, \\\"Not whitelisting_period, Please contact to Admin\\\");\\r\\n\\r\\n      assign_subscription(msg.sender, 180);\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n  function is_whitelisted(address _address) public view returns (bool) {\\r\\n    return whitelisting_period[_address] \\u003e block.timestamp;\\r\\n  }\\r\\n  \\r\\n  function is_subscriber(address _address) public view returns (bool) {\\r\\n    return subscription_period[_address] \\u003e block.timestamp;\\r\\n  }\\r\\n   \\r\\n \\r\\n  function whitelist_users(address[] memory _users, uint256 _days) public onlyOwner {\\r\\n      \\r\\n    if(_users.length == 1){\\r\\n        whitelistUser(_users[0], _days);\\r\\n    }\\r\\n    else {\\r\\n        for(uint i = 0; i \\u003c _users.length; i++){\\r\\n            whitelistUser(_users[i], _days);\\r\\n        }\\r\\n    }\\r\\n  }\\r\\n  \\r\\n\\r\\n  function blacklist_users(address[] memory _users) public onlyOwner {\\r\\n      \\r\\n    if(_users.length == 1){\\r\\n        blacklistUser(_users[0]);\\r\\n    }\\r\\n    else {\\r\\n        for(uint i = 0; i \\u003c _users.length; i++){\\r\\n        blacklistUser(_users[i]);\\r\\n        }\\r\\n    }\\r\\n  }\\r\\n  \\r\\n  \\r\\n  function list_of_whitelisted_users() public view returns(address[] memory){\\r\\n    return whitelistedUsers;\\r\\n  }\\r\\n  \\r\\n  // function refresh_list_of_whitelisted_users() public onlyOwner{\\r\\n      \\r\\n  //   address[] memory allWhitelistedUsers = whitelistedUsers;\\r\\n\\r\\n  //   whitelistedUsers = new address[](0);\\r\\n      \\r\\n  //   for(uint i = 0; i \\u003c allWhitelistedUsers.length; i++){\\r\\n  //       if( whitelisting_period[allWhitelistedUsers[i]] \\u003e  block.timestamp){\\r\\n  //           whitelistedUsers.push(allWhitelistedUsers[i]);\\r\\n  //       }\\r\\n  //   }\\r\\n  // }\\r\\n  \\r\\n  \\r\\n  function total_balance_available() public view returns(uint256) {\\r\\n        return  address(this).balance;\\r\\n  }\\r\\n    \\r\\n  \\r\\n  function withdraw_total_amount() public onlyOwner {\\r\\n      distribute_equity();\\r\\n  }\\r\\n \\r\\n    \\r\\n  function distribute_equity() internal {\\r\\n        \\r\\n        uint256 totalamount =  address(this).balance;\\r\\n        require(totalamount \\u003e 0, \\\"balance is nill\\\");\\r\\n\\r\\n        address owner = owner();\\r\\n        \\r\\n        // distribute owner\\u0027s 80% cut\\r\\n        uint256 ownersCut =  totalamount.mul(80).div(100);     \\r\\n        bool sentOwner = payable(owner).send(ownersCut);\\r\\n        require(sentOwner, \\\"Failed to send Ether\\\");\\r\\n        emit PaymentReleased(owner, ownersCut);\\r\\n        \\r\\n        // distribute remaining 20% to developer\\r\\n        uint developersCut = totalamount.sub(ownersCut);\\r\\n        bool sentDeveloper = payable(developer).send(developersCut);\\r\\n        require(sentDeveloper, \\\"Failed to send Ether\\\");\\r\\n        emit PaymentReleased(developer, developersCut);\\r\\n        \\r\\n    }\\r\\n  \\r\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// CAUTION\\r\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\r\\n// because it relies on the compiler\\u0027s built in overflow checks.\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations.\\r\\n *\\r\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\r\\n * now has built in overflow checking.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c \\u003c a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b \\u003e a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003c= a, errorMessage);\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003e 0, errorMessage);\\r\\n            return a / b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting with custom message when dividing by zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003e 0, errorMessage);\\r\\n            return a % b;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AmountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BlackListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"MembershipAssigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"WhiteListed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"}],\"name\":\"blacklist_users\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"get_cost_of_subscription\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_one_month_subscription\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_seven_days_subscription\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_single_day_subscription\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"get_six_month_subscription\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_hours\",\"type\":\"uint256\"}],\"name\":\"giveaway_subscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"is_subscriber\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"is_whitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"list_of_whitelisted_users\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"set_cost_of_subscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"subscription_period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total_balance_available\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"whitelist_users\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisting_period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw_total_amount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"RankNFT","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3ae332ec181bc2308c86f23266458121a5d7a6ab274f7265dc64b5c4cd68d786"}]}