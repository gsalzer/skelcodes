{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/deployer/PoolDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox. Generalized leverage protocol that allows to take leverage and then use it across other DeFi protocols and platforms in a composable way.\\n// (c) Gearbox.fi, 2021\\npragma solidity ^0.7.4;\\npragma abicoder v2;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\nimport {AddressProvider} from \\\"../core/AddressProvider.sol\\\";\\nimport {ContractsRegister} from \\\"../core/ContractsRegister.sol\\\";\\nimport {ACL} from \\\"../core/ACL.sol\\\";\\n\\nimport {DieselToken} from \\\"../tokens/DieselToken.sol\\\";\\nimport {LinearInterestRateModel} from \\\"../pool/LinearInterestRateModel.sol\\\";\\nimport {PoolService} from \\\"../pool/PoolService.sol\\\";\\nimport {CreditManager} from \\\"../credit/CreditManager.sol\\\";\\nimport {CreditFilter} from \\\"../credit/CreditFilter.sol\\\";\\n\\nimport {Constants} from \\\"../libraries/helpers/Constants.sol\\\";\\nimport {Errors} from \\\"../libraries/helpers/Errors.sol\\\";\\n\\ncontract PoolDeployer is Ownable {\\n    struct DeployOpts {\\n        address addressProvider; // address of addressProvider contract\\n        address underlyingToken; // address of underlying token for pool and creditManager\\n        uint256 U_optimal; // linear interest model parameter\\n        uint256 R_base; // linear interest model parameter\\n        uint256 R_slope1; // linear interest model parameter\\n        uint256 R_slope2; // linear interest model parameter\\n        uint256 expectedLiquidityLimit; // linear interest model parameter\\n        uint256 minAmount; // minimal amount for credit account\\n        uint256 maxAmount; // maximum amount for credit account\\n        uint256 maxLeverage; // high bound for Leverage (x100 value)\\n        uint256 withdrawFee; // withdrawFee\\n        address defaultSwapContract; // address for Uniswap V2 compatible contract which is used during CloseAccount action\\n        AllowedToken[] allowedTokens;\\n    }\\n\\n    struct AllowedToken {\\n        address token;\\n        uint256 liquidationThreshold;\\n    }\\n\\n    AllowedToken[] allowedTokens;\\n\\n    AddressProvider public addressProvider;\\n    PoolService public pool;\\n    CreditFilter public creditFilter;\\n    CreditManager public creditManager;\\n    address public root;\\n    uint256 public withdrawFee;\\n\\n    constructor(DeployOpts memory opts) {\\n        addressProvider = AddressProvider(opts.addressProvider);\\n\\n        for (uint256 i = 0; i < opts.allowedTokens.length; i++) {\\n            allowedTokens.push(opts.allowedTokens[i]);\\n        }\\n\\n        ERC20 token = ERC20(opts.underlyingToken);\\n        DieselToken dieselToken = new DieselToken(\\n            string(abi.encodePacked(\\\"diesel \\\", token.name())),\\n            string(abi.encodePacked(\\\"d\\\", token.symbol())),\\n            token.decimals()\\n        ); // T:[PD-1]\\n\\n        LinearInterestRateModel linearModel = new LinearInterestRateModel(\\n            opts.U_optimal,\\n            opts.R_base,\\n            opts.R_slope1,\\n            opts.R_slope2\\n        ); // T:[PD-1]\\n\\n        pool = new PoolService(\\n            opts.addressProvider,\\n            opts.underlyingToken,\\n            address(dieselToken),\\n            address(linearModel),\\n            opts.expectedLiquidityLimit\\n        );\\n\\n        creditFilter = new CreditFilter(\\n            opts.addressProvider,\\n            opts.underlyingToken\\n        ); // T:[PD-1]\\n\\n        creditManager = new CreditManager(\\n            opts.addressProvider,\\n            opts.minAmount,\\n            opts.maxAmount,\\n            opts.maxLeverage,\\n            address(pool),\\n            address(creditFilter),\\n            opts.defaultSwapContract\\n        ); // T:[PD-1]\\n\\n        dieselToken.transferOwnership(address(pool));\\n\\n        withdrawFee = opts.withdrawFee;\\n        root = ACL(addressProvider.getACL()).owner();\\n    }\\n\\n    function configure() external onlyOwner {\\n        ACL acl = ACL(addressProvider.getACL());\\n        ContractsRegister cr = ContractsRegister(\\n            addressProvider.getContractsRegister()\\n        );\\n\\n        pool.setWithdrawFee(withdrawFee);\\n\\n        cr.addPool(address(pool)); // T:[PD-2]\\n        cr.addCreditManager(address(creditManager)); // T:[PD-2]\\n\\n        pool.connectCreditManager(address(creditManager));\\n\\n        for (uint256 i; i < allowedTokens.length; i++) {\\n            creditFilter.allowToken(\\n                allowedTokens[i].token,\\n                allowedTokens[i].liquidationThreshold\\n            ); // T:[PD-2]\\n        }\\n\\n        creditFilter.connectCreditManager(address(creditManager)); // T:[PD-2]\\n\\n        acl.transferOwnership(root); // T:[PD-2]\\n    }\\n\\n    // Will be used in case of configure() revert\\n    function getRootBack() external onlyOwner {\\n        ACL acl = ACL(addressProvider.getACL()); // T:[PD-3]\\n        acl.transferOwnership(root);\\n    }\\n\\n    function destoy() external onlyOwner {\\n        selfdestruct(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"contracts/core/AddressProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\nimport {IAppAddressProvider} from \\\"../interfaces/app/IAppAddressProvider.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {Errors} from \\\"../libraries/helpers/Errors.sol\\\";\\n\\n\\n/// @title AddressRepository\\n/// @notice Stores addresses of deployed contracts\\ncontract AddressProvider is Ownable, IAppAddressProvider {\\n    // Mapping which keeps all addresses\\n    mapping(bytes32 => address) public addresses;\\n\\n    // Emits each time when new address is set\\n    event AddressSet(bytes32 indexed service, address indexed newAddress);\\n\\n    // This event is triggered when a call to ClaimTokens succeeds.\\n    event Claimed(uint256 user_id, address account, uint256 amount, bytes32 leaf);\\n\\n    // Repositories & services\\n    bytes32 public constant CONTRACTS_REGISTER = \\\"CONTRACTS_REGISTER\\\";\\n    bytes32 public constant ACL = \\\"ACL\\\";\\n    bytes32 public constant PRICE_ORACLE = \\\"PRICE_ORACLE\\\";\\n    bytes32 public constant ACCOUNT_FACTORY = \\\"ACCOUNT_FACTORY\\\";\\n    bytes32 public constant DATA_COMPRESSOR = \\\"DATA_COMPRESSOR\\\";\\n    bytes32 public constant TREASURY_CONTRACT = \\\"TREASURY_CONTRACT\\\";\\n    bytes32 public constant GEAR_TOKEN = \\\"GEAR_TOKEN\\\";\\n    bytes32 public constant WETH_TOKEN = \\\"WETH_TOKEN\\\";\\n    bytes32 public constant WETH_GATEWAY = \\\"WETH_GATEWAY\\\";\\n    bytes32 public constant LEVERAGED_ACTIONS = \\\"LEVERAGED_ACTIONS\\\";\\n\\n    // Contract version\\n    uint256 public constant version = 1;\\n\\n    constructor() {\\n        // @dev Emits first event for contract discovery\\n        emit AddressSet(\\\"ADDRESS_PROVIDER\\\", address(this));\\n    }\\n\\n    /// @return Address of ACL contract\\n    function getACL() external view returns (address) {\\n        return _getAddress(ACL); // T:[AP-3]\\n    }\\n\\n    /// @dev Sets address of ACL contract\\n    /// @param _address Address of ACL contract\\n    function setACL(address _address)\\n        external\\n        onlyOwner // T:[AP-15]\\n    {\\n        _setAddress(ACL, _address); // T:[AP-3]\\n    }\\n\\n    /// @return Address of ContractsRegister\\n    function getContractsRegister() external view returns (address) {\\n        return _getAddress(CONTRACTS_REGISTER); // T:[AP-4]\\n    }\\n\\n    /// @dev Sets address of ContractsRegister\\n    /// @param _address Address of ContractsRegister\\n    function setContractsRegister(address _address)\\n        external\\n        onlyOwner // T:[AP-15]\\n    {\\n        _setAddress(CONTRACTS_REGISTER, _address); // T:[AP-4]\\n    }\\n\\n    /// @return Address of PriceOracle\\n    function getPriceOracle() external view override returns (address) {\\n        return _getAddress(PRICE_ORACLE); // T:[AP-5]\\n    }\\n\\n    /// @dev Sets address of PriceOracle\\n    /// @param _address Address of PriceOracle\\n    function setPriceOracle(address _address)\\n        external\\n        onlyOwner // T:[AP-15]\\n    {\\n        _setAddress(PRICE_ORACLE, _address); // T:[AP-5]\\n    }\\n\\n    /// @return Address of AccountFactory\\n    function getAccountFactory() external view returns (address) {\\n        return _getAddress(ACCOUNT_FACTORY); // T:[AP-6]\\n    }\\n\\n    /// @dev Sets address of AccountFactory\\n    /// @param _address Address of AccountFactory\\n    function setAccountFactory(address _address)\\n        external\\n        onlyOwner // T:[AP-15]\\n    {\\n        _setAddress(ACCOUNT_FACTORY, _address); // T:[AP-7]\\n    }\\n\\n    /// @return Address of AccountFactory\\n    function getDataCompressor() external view override returns (address) {\\n        return _getAddress(DATA_COMPRESSOR); // T:[AP-8]\\n    }\\n\\n    /// @dev Sets address of AccountFactory\\n    /// @param _address Address of AccountFactory\\n    function setDataCompressor(address _address)\\n        external\\n        onlyOwner // T:[AP-15]\\n    {\\n        _setAddress(DATA_COMPRESSOR, _address); // T:[AP-8]\\n    }\\n\\n    /// @return Address of Treasury contract\\n    function getTreasuryContract() external view returns (address) {\\n        return _getAddress(TREASURY_CONTRACT); //T:[AP-11]\\n    }\\n\\n    /// @dev Sets address of Treasury Contract\\n    /// @param _address Address of Treasury Contract\\n    function setTreasuryContract(address _address)\\n        external\\n        onlyOwner // T:[AP-15]\\n    {\\n        _setAddress(TREASURY_CONTRACT, _address); //T:[AP-11]\\n    }\\n\\n    /// @return Address of GEAR token\\n    function getGearToken() external view override returns (address) {\\n        return _getAddress(GEAR_TOKEN); // T:[AP-12]\\n    }\\n\\n    /// @dev Sets address of GEAR token\\n    /// @param _address Address of GEAR token\\n    function setGearToken(address _address)\\n        external\\n        onlyOwner // T:[AP-15]\\n    {\\n        _setAddress(GEAR_TOKEN, _address); // T:[AP-12]\\n    }\\n\\n    /// @return Address of WETH token\\n    function getWethToken() external view override returns (address) {\\n        return _getAddress(WETH_TOKEN); // T:[AP-13]\\n    }\\n\\n    /// @dev Sets address of WETH token\\n    /// @param _address Address of WETH token\\n    function setWethToken(address _address)\\n        external\\n        onlyOwner // T:[AP-15]\\n    {\\n        _setAddress(WETH_TOKEN, _address); // T:[AP-13]\\n    }\\n\\n    /// @return Address of WETH token\\n    function getWETHGateway() external view override returns (address) {\\n        return _getAddress(WETH_GATEWAY); // T:[AP-14]\\n    }\\n\\n    /// @dev Sets address of WETH token\\n    /// @param _address Address of WETH token\\n    function setWETHGateway(address _address)\\n        external\\n        onlyOwner // T:[AP-15]\\n    {\\n        _setAddress(WETH_GATEWAY, _address); // T:[AP-14]\\n    }\\n\\n    /// @return Address of WETH token\\n    function getLeveragedActions() external view override returns (address) {\\n        return _getAddress(LEVERAGED_ACTIONS); // T:[AP-7]\\n    }\\n\\n    /// @dev Sets address of WETH token\\n    /// @param _address Address of WETH token\\n    function setLeveragedActions(address _address)\\n        external\\n        onlyOwner // T:[AP-15]\\n    {\\n        _setAddress(LEVERAGED_ACTIONS, _address); // T:[AP-7]\\n    }\\n\\n    /// @return Address of key, reverts if key doesn't exist\\n    function _getAddress(bytes32 key) internal view returns (address) {\\n        address result = addresses[key];\\n        require(result != address(0), Errors.AS_ADDRESS_NOT_FOUND); // T:[AP-1]\\n        return result; // T:[AP-3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\\n    }\\n\\n    /// @dev Sets address to map by its key\\n    /// @param key Key in string format\\n    /// @param value Address\\n    function _setAddress(bytes32 key, address value) internal {\\n        addresses[key] = value; // T:[AP-3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\\n        emit AddressSet(key, value); // T:[AP-2]\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/ContractsRegister.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\nimport {Errors} from \\\"../libraries/helpers/Errors.sol\\\";\\nimport {ACLTrait} from \\\"./ACLTrait.sol\\\";\\n\\n\\n/// @title Pools & Contract managers registry\\n/// @notice Keeps pools & contract manager addresses\\ncontract ContractsRegister is ACLTrait {\\n    // Pools list\\n    address[] public pools;\\n    mapping(address => bool) public isPool;\\n\\n    // Credit Managers list\\n    address[] public creditManagers;\\n    mapping(address => bool) public isCreditManager;\\n\\n    // Contract version\\n    uint256 public constant version = 1;\\n\\n    // emits each time when new pool was added to register\\n    event NewPoolAdded(address indexed pool);\\n\\n    // emits each time when new credit Manager was added to register\\n    event NewCreditManagerAdded(address indexed creditManager);\\n\\n    constructor(address addressProvider) ACLTrait(addressProvider) {}\\n\\n    /// @dev Adds pool to list\\n    /// @param newPoolAddress Address on new pool added\\n    function addPool(address newPoolAddress)\\n        external\\n        configuratorOnly // T:[CR-1]\\n    {\\n        require(\\n            newPoolAddress != address(0),\\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\\n        );\\n        require(!isPool[newPoolAddress], Errors.CR_POOL_ALREADY_ADDED); // T:[CR-2]\\n        pools.push(newPoolAddress); // T:[CR-3]\\n        isPool[newPoolAddress] = true; // T:[CR-3]\\n\\n        emit NewPoolAdded(newPoolAddress); // T:[CR-4]\\n    }\\n\\n    /// @dev Returns array of registered pool addresses\\n    function getPools() external view returns (address[] memory) {\\n        return pools;\\n    }\\n\\n    /// @return Returns quantity of registered pools\\n    function getPoolsCount() external view returns (uint256) {\\n        return pools.length; // T:[CR-3]\\n    }\\n\\n    /// @dev Adds credit accounts manager address to the registry\\n    /// @param newCreditManager Address on new pausableAdmin added\\n    function addCreditManager(address newCreditManager)\\n        external\\n        configuratorOnly // T:[CR-1]\\n    {\\n        require(\\n            newCreditManager != address(0),\\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\\n        );\\n\\n        require(\\n            !isCreditManager[newCreditManager],\\n            Errors.CR_CREDIT_MANAGER_ALREADY_ADDED\\n        ); // T:[CR-5]\\n        creditManagers.push(newCreditManager); // T:[CR-6]\\n        isCreditManager[newCreditManager] = true; // T:[CR-6]\\n\\n        emit NewCreditManagerAdded(newCreditManager); // T:[CR-7]\\n    }\\n\\n    /// @dev Returns array of registered credit manager addresses\\n    function getCreditManagers() external view returns (address[] memory) {\\n        return creditManagers;\\n    }\\n\\n    /// @return Returns quantity of registered credit managers\\n    function getCreditManagersCount() external view returns (uint256) {\\n        return creditManagers.length; // T:[CR-6]\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/ACL.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {Errors} from \\\"../libraries/helpers/Errors.sol\\\";\\n\\n\\n/// @title ACL keeps admins addresses\\n/// More info: https://dev.gearbox.fi/security/roles\\ncontract ACL is Ownable {\\n    mapping(address => bool) public pausableAdminSet;\\n    mapping(address => bool) public unpausableAdminSet;\\n\\n    // Contract version\\n    uint256 public constant version = 1;\\n\\n    // emits each time when new pausable admin added\\n    event PausableAdminAdded(address indexed newAdmin);\\n\\n    // emits each time when pausable admin removed\\n    event PausableAdminRemoved(address indexed admin);\\n\\n    // emits each time when new unpausable admin added\\n    event UnpausableAdminAdded(address indexed newAdmin);\\n\\n    // emits each times when unpausable admin removed\\n    event UnpausableAdminRemoved(address indexed admin);\\n\\n    /// @dev Adds pausable admin address\\n    /// @param newAdmin Address of new pausable admin\\n    function addPausableAdmin(address newAdmin)\\n        external\\n        onlyOwner // T:[ACL-1]\\n    {\\n        pausableAdminSet[newAdmin] = true; // T:[ACL-2]\\n        emit PausableAdminAdded(newAdmin); // T:[ACL-2]\\n    }\\n\\n    /// @dev Removes pausable admin\\n    /// @param admin Address of admin which should be removed\\n    function removePausableAdmin(address admin)\\n        external\\n        onlyOwner // T:[ACL-1]\\n    {\\n        pausableAdminSet[admin] = false; // T:[ACL-3]\\n        emit PausableAdminRemoved(admin); // T:[ACL-3]\\n    }\\n\\n    /// @dev Returns true if the address is pausable admin and false if not\\n    function isPausableAdmin(address addr) external view returns (bool) {\\n        return pausableAdminSet[addr]; // T:[ACL-2,3]\\n    }\\n\\n    /// @dev Adds unpausable admin address to the list\\n    /// @param newAdmin Address of new unpausable admin\\n    function addUnpausableAdmin(address newAdmin)\\n        external\\n        onlyOwner // T:[ACL-1]\\n    {\\n        unpausableAdminSet[newAdmin] = true; // T:[ACL-4]\\n        emit UnpausableAdminAdded(newAdmin); // T:[ACL-4]\\n    }\\n\\n    /// @dev Removes unpausable admin\\n    /// @param admin Address of admin to be removed\\n    function removeUnpausableAdmin(address admin)\\n        external\\n        onlyOwner // T:[ACL-1]\\n    {\\n        unpausableAdminSet[admin] = false; // T:[ACL-5]\\n        emit UnpausableAdminRemoved(admin); // T:[ACL-5]\\n    }\\n\\n    /// @dev Returns true if the address is unpausable admin and false if not\\n    function isUnpausableAdmin(address addr) external view returns (bool) {\\n        return unpausableAdminSet[addr]; // T:[ACL-4,5]\\n    }\\n\\n    /// @dev Returns true if addr has configurator rights\\n    function isConfigurator(address account) external view returns (bool) {\\n        return account == owner(); // T:[ACL-6]\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/DieselToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\n/// @dev DieselToken is LP token for Gearbox pools\\ncontract DieselToken is ERC20, Ownable {\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint8 decimals_\\n    ) ERC20(name_, symbol_) {\\n        _setupDecimals(decimals_);\\n    }\\n\\n    function mint(address to, uint256 amount) external onlyOwner {\\n        _mint(to, amount);\\n    }\\n\\n    function burn(address to, uint256 amount) external onlyOwner {\\n        _burn(to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pool/LinearInterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport {PercentageMath} from \\\"../libraries/math/PercentageMath.sol\\\";\\nimport {WadRayMath} from \\\"../libraries/math/WadRayMath.sol\\\";\\nimport {IInterestRateModel} from \\\"../interfaces/IInterestRateModel.sol\\\";\\nimport {Constants} from \\\"../libraries/helpers/Constants.sol\\\";\\nimport {Errors} from \\\"../libraries/helpers/Errors.sol\\\";\\n\\n\\n/// @title Linear Interest Rate Model\\n/// @notice Linear interest rate model, similar which Aave uses\\ncontract LinearInterestRateModel is IInterestRateModel {\\n    using PercentageMath for uint256;\\n    using SafeMath for uint256;\\n    using WadRayMath for uint256;\\n\\n    // Uoptimal[0;1] in Wad\\n    uint256 public immutable _U_Optimal_WAD;\\n\\n    // 1 - Uoptimal [0;1] x10.000, percentage plus two decimals\\n    uint256 public immutable _U_Optimal_inverted_WAD;\\n\\n    // R_base in Ray\\n    uint256 public immutable _R_base_RAY;\\n\\n    // R_Slope1 in Ray\\n    uint256 public immutable _R_slope1_RAY;\\n\\n    // R_Slope2 in Ray\\n    uint256 public immutable _R_slope2_RAY;\\n\\n    // Contract version\\n    uint constant public version = 1;\\n\\n    /// @dev Constructor\\n    /// @param U_optimal Optimal U in percentage format: x10.000 - percentage plus two decimals\\n    /// @param R_base R_base in percentage format: x10.000 - percentage plus two decimals @param R_slope1 R_Slope1 in Ray\\n    /// @param R_slope1 R_Slope1 in percentage format: x10.000 - percentage plus two decimals\\n    /// @param R_slope2 R_Slope2 in percentage format: x10.000 - percentage plus two decimals\\n    constructor(\\n        uint256 U_optimal,\\n        uint256 R_base,\\n        uint256 R_slope1,\\n        uint256 R_slope2\\n    ) {\\n        require(\\n            U_optimal <= PercentageMath.PERCENTAGE_FACTOR,\\n            Errors.INCORRECT_PARAMETER\\n        );\\n        require(\\n            R_base <= PercentageMath.PERCENTAGE_FACTOR,\\n            Errors.INCORRECT_PARAMETER\\n        );\\n        require(\\n            R_slope1 <= PercentageMath.PERCENTAGE_FACTOR,\\n            Errors.INCORRECT_PARAMETER\\n        );\\n\\n        // Convert percetns to WAD\\n        uint256 U_optimal_WAD = WadRayMath.WAD.percentMul(U_optimal);\\n        _U_Optimal_WAD = U_optimal_WAD;\\n\\n        // 1 - Uoptimal in WAD\\n        _U_Optimal_inverted_WAD = WadRayMath.WAD.sub(U_optimal_WAD);\\n\\n        _R_base_RAY = WadRayMath.RAY.percentMul(R_base);\\n        _R_slope1_RAY = WadRayMath.RAY.percentMul(R_slope1);\\n        _R_slope2_RAY = WadRayMath.RAY.percentMul(R_slope2);\\n    }\\n\\n    /// @dev Calculated borrow rate based on expectedLiquidity and availableLiquidity\\n    /// @param expectedLiquidity Expected liquidity in the pool\\n    /// @param availableLiquidity Available liquidity in the pool\\n    function calcBorrowRate(\\n        uint256 expectedLiquidity,\\n        uint256 availableLiquidity\\n    ) external view override returns (uint256) {\\n        // Protection from direct sending tokens on PoolService account\\n        //    T:[LR-5]                     // T:[LR-6]\\n        if (expectedLiquidity == 0 || expectedLiquidity < availableLiquidity) {\\n            return _R_base_RAY;\\n        }\\n\\n        //      expectedLiquidity - availableLiquidity\\n        // U = -------------------------------------\\n        //             expectedLiquidity\\n\\n        uint256 U_WAD = (expectedLiquidity.sub(availableLiquidity))\\n        .mul(WadRayMath.WAD)\\n        .div(expectedLiquidity);\\n\\n        // if U < Uoptimal:\\n        //\\n        //                                    U\\n        // borrowRate = Rbase + Rslope1 * ----------\\n        //                                 Uoptimal\\n        //\\n\\n        if (U_WAD < _U_Optimal_WAD) {\\n            return\\n                _R_base_RAY.add(_R_slope1_RAY.mul(U_WAD).div(_U_Optimal_WAD));\\n        }\\n\\n        // if U >= Uoptimal:\\n        //\\n        //                                           U - Uoptimal\\n        // borrowRate = Rbase + Rslope1 + Rslope2 * --------------\\n        //                                           1 - Uoptimal\\n\\n        return\\n            _R_base_RAY.add(_R_slope1_RAY).add(\\n                _R_slope2_RAY.mul(U_WAD.sub(_U_Optimal_WAD)).div(\\n                    _U_Optimal_inverted_WAD\\n                )\\n            ); // T:[LR-1,2,3]\\n    }\\n\\n    /// @dev Gets model parameters\\n    /// @param U_optimal U_optimal in percentage format: [0;10,000] - percentage plus two decimals\\n    /// @param R_base R_base in RAY format\\n    /// @param R_slope1 R_slope1 in RAY format\\n    /// @param R_slope2 R_slope2 in RAY format\\n    function getModelParameters()\\n        external\\n        view\\n        returns (\\n            uint256 U_optimal,\\n            uint256 R_base,\\n            uint256 R_slope1,\\n            uint256 R_slope2\\n        )\\n    {\\n        U_optimal = _U_Optimal_WAD.percentDiv(WadRayMath.WAD); // T:[LR-4]\\n        R_base = _R_base_RAY; // T:[LR-4]\\n        R_slope1 = _R_slope1_RAY; // T:[LR-4]\\n        R_slope2 = _R_slope2_RAY; // T:[LR-4]\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/pool/PoolService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport {ACLTrait} from \\\"../core/ACLTrait.sol\\\";\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport {Math} from \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport {WadRayMath} from \\\"../libraries/math/WadRayMath.sol\\\";\\nimport {PercentageMath} from \\\"../libraries/math/PercentageMath.sol\\\";\\n\\nimport {IInterestRateModel} from \\\"../interfaces/IInterestRateModel.sol\\\";\\nimport {IPoolService} from \\\"../interfaces/IPoolService.sol\\\";\\nimport {ICreditFilter} from \\\"../interfaces/ICreditFilter.sol\\\";\\nimport {ICreditManager} from \\\"../interfaces/ICreditManager.sol\\\";\\n\\nimport {AddressProvider} from \\\"../core/AddressProvider.sol\\\";\\nimport {DieselToken} from \\\"../tokens/DieselToken.sol\\\";\\nimport {Constants} from \\\"../libraries/helpers/Constants.sol\\\";\\nimport {Errors} from \\\"../libraries/helpers/Errors.sol\\\";\\n\\n/// @title Pool Service\\n/// @notice Encapsulates business logic for:\\n///  - Adding/removing pool liquidity\\n///  - Managing diesel tokens & diesel rates\\n///  - Lend funds to credit manager\\n///\\n/// #define currentBorrowRate() uint =\\n///     let expLiq := expectedLiquidity() in\\n///     let availLiq := availableLiquidity() in\\n///         interestRateModel.calcBorrowRate(expLiq, availLiq);\\n///\\n/// More: https://dev.gearbox.fi/developers/pools/pool-service\\ncontract PoolService is IPoolService, ACLTrait, ReentrancyGuard {\\n    using SafeMath for uint256;\\n    using WadRayMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using PercentageMath for uint256;\\n\\n    // Expected liquidity at last update (LU)\\n    uint256 public _expectedLiquidityLU;\\n\\n    // Expected liquidity limit\\n    uint256 public override expectedLiquidityLimit;\\n\\n    // Total borrowed amount: https://dev.gearbox.fi/developers/pools/economy/total-borrowed\\n    uint256 public override totalBorrowed;\\n\\n    // Address repository\\n    AddressProvider public addressProvider;\\n\\n    // Interest rate model\\n    IInterestRateModel public interestRateModel;\\n\\n    // Underlying token address\\n    address public override underlyingToken;\\n\\n    // Diesel(LP) token address\\n    address public override dieselToken;\\n\\n    // Credit managers mapping with permission to borrow / repay\\n    mapping(address => bool) public override creditManagersCanBorrow;\\n    mapping(address => bool) public creditManagersCanRepay;\\n\\n    // Credif managers\\n    address[] public override creditManagers;\\n\\n    // Treasury address for tokens\\n    address public treasuryAddress;\\n\\n    // Cumulative index in RAY\\n    uint256 public override _cumulativeIndex_RAY;\\n\\n    // Current borrow rate in RAY: https://dev.gearbox.fi/developers/pools/economy#borrow-apy\\n    uint256 public override borrowAPY_RAY;\\n\\n    // Timestamp of last update\\n    uint256 public override _timestampLU;\\n\\n    // Withdraw fee in PERCENTAGE FORMAT\\n    uint256 public override withdrawFee;\\n\\n    // Contract version\\n    uint256 public constant version = 1;\\n\\n    //\\n    // CONSTRUCTOR\\n    //\\n\\n    /// @dev Constructor\\n    /// @param _addressProvider Address Repository for upgradable contract model\\n    /// @param _underlyingToken Address of underlying token\\n    /// @param _dieselAddress Address of diesel (LP) token\\n    /// @param _interestRateModelAddress Address of interest rate model\\n    constructor(\\n        address _addressProvider,\\n        address _underlyingToken,\\n        address _dieselAddress,\\n        address _interestRateModelAddress,\\n        uint256 _expectedLiquidityLimit\\n    ) ACLTrait(_addressProvider) {\\n        require(\\n            _addressProvider != address(0) &&\\n                _underlyingToken != address(0) &&\\n                _dieselAddress != address(0) &&\\n                _interestRateModelAddress != address(0),\\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\\n        );\\n\\n        addressProvider = AddressProvider(_addressProvider);\\n\\n        underlyingToken = _underlyingToken;\\n        dieselToken = _dieselAddress;\\n        treasuryAddress = addressProvider.getTreasuryContract();\\n\\n        _cumulativeIndex_RAY = WadRayMath.RAY; // T:[PS-5]\\n        _updateInterestRateModel(_interestRateModelAddress);\\n        expectedLiquidityLimit = _expectedLiquidityLimit;\\n    }\\n\\n    //\\n    // LIQUIDITY MANAGEMENT\\n    //\\n\\n    /**\\n     * @dev Adds liquidity to pool\\n     * - Transfers underlying asset to pool\\n     * - Mints diesel (LP) token with current diesel rate\\n     * - Updates expected liquidity\\n     * - Updates borrow rate\\n     *\\n     * More: https://dev.gearbox.fi/developers/pools/pool-service#addliquidity\\n     *\\n     * @param amount Amount of tokens to be transfer\\n     * @param onBehalfOf The address that will receive the diesel tokens, same as msg.sender if the user\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of diesel\\n     * tokens is a different wallet\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     *\\n     * #if_succeeds {:msg \\\"After addLiquidity() the pool gets the correct amoung of underlyingToken(s)\\\"}\\n     *      IERC20(underlyingToken).balanceOf(address(this)) == old(IERC20(underlyingToken).balanceOf(address(this))) + amount;\\n     * #if_succeeds {:msg \\\"After addLiquidity() onBehalfOf gets the right amount of dieselTokens\\\"}\\n     *      IERC20(dieselToken).balanceOf(onBehalfOf) == old(IERC20(dieselToken).balanceOf(onBehalfOf)) + old(toDiesel(amount));\\n     * #if_succeeds {:msg \\\"After addLiquidity() borrow rate decreases\\\"}\\n     *      amount > 0 ==> borrowAPY_RAY <= old(currentBorrowRate());\\n     * #limit {:msg \\\"Not more than 1 day since last borrow rate update\\\"} block.timestamp <= _timestampLU + 3600 * 24;\\n     */\\n    function addLiquidity(\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint256 referralCode\\n    )\\n        external\\n        override\\n        whenNotPaused // T:[PS-4]\\n        nonReentrant\\n    {\\n        require(onBehalfOf != address(0), Errors.ZERO_ADDRESS_IS_NOT_ALLOWED);\\n\\n        require(\\n            expectedLiquidity().add(amount) <= expectedLiquidityLimit,\\n            Errors.POOL_MORE_THAN_EXPECTED_LIQUIDITY_LIMIT\\n        ); // T:[PS-31]\\n\\n        uint256 balanceBefore = IERC20(underlyingToken).balanceOf(\\n            address(this)\\n        );\\n\\n        IERC20(underlyingToken).safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            amount\\n        ); // T:[PS-2, 7]\\n\\n        amount = IERC20(underlyingToken).balanceOf(address(this)).sub(\\n            balanceBefore\\n        ); // T:[FT-1]\\n\\n        DieselToken(dieselToken).mint(onBehalfOf, toDiesel(amount)); // T:[PS-2, 7]\\n\\n        _expectedLiquidityLU = _expectedLiquidityLU.add(amount); // T:[PS-2, 7]\\n        _updateBorrowRate(0); // T:[PS-2, 7]\\n\\n        emit AddLiquidity(msg.sender, onBehalfOf, amount, referralCode); // T:[PS-2, 7]\\n    }\\n\\n    /**\\n     * @dev Removes liquidity from pool\\n     * - Transfers to LP underlying account = amount * diesel rate\\n     * - Burns diesel tokens\\n     * - Decreases underlying amount from total_liquidity\\n     * - Updates borrow rate\\n     *\\n     * More: https://dev.gearbox.fi/developers/pools/pool-service#removeliquidity\\n     *\\n     * @param amount Amount of tokens to be transfer\\n     * @param to Address to transfer liquidity\\n     *\\n     * #if_succeeds {:msg \\\"For removeLiquidity() sender must have sufficient diesel\\\"}\\n     *      old(DieselToken(dieselToken).balanceOf(msg.sender)) >= amount;\\n     * #if_succeeds {:msg \\\"After removeLiquidity() `to` gets the liquidity in underlyingToken(s)\\\"}\\n     *      (to != address(this) && to != treasuryAddress) ==>\\n     *          IERC20(underlyingToken).balanceOf(to) == old(IERC20(underlyingToken).balanceOf(to) + (let t:= fromDiesel(amount) in t.sub(t.percentMul(withdrawFee))));\\n     * #if_succeeds {:msg \\\"After removeLiquidity() treasury gets the withdraw fee in underlyingToken(s)\\\"}\\n     *      (to != address(this) && to != treasuryAddress) ==>\\n     *          IERC20(underlyingToken).balanceOf(treasuryAddress) == old(IERC20(underlyingToken).balanceOf(treasuryAddress) + fromDiesel(amount).percentMul(withdrawFee));\\n     * #if_succeeds {:msg \\\"After removeLiquidity() borrow rate increases\\\"}\\n     *      (to != address(this) && amount > 0) ==> borrowAPY_RAY >= old(currentBorrowRate());\\n     * #limit {:msg \\\"Not more than 1 day since last borrow rate update\\\"} block.timestamp <= _timestampLU + 3600 * 24;\\n     */\\n    function removeLiquidity(uint256 amount, address to)\\n        external\\n        override\\n        whenNotPaused // T:[PS-4]\\n        nonReentrant\\n        returns (uint256)\\n    {\\n        require(to != address(0), Errors.ZERO_ADDRESS_IS_NOT_ALLOWED);\\n\\n        uint256 underlyingTokensAmount = fromDiesel(amount); // T:[PS-3, 8]\\n\\n        uint256 amountTreasury = underlyingTokensAmount.percentMul(withdrawFee);\\n        uint256 amountSent = underlyingTokensAmount.sub(amountTreasury);\\n\\n        IERC20(underlyingToken).safeTransfer(to, amountSent); // T:[PS-3, 34]\\n\\n        if (amountTreasury > 0) {\\n            IERC20(underlyingToken).safeTransfer(\\n                treasuryAddress,\\n                amountTreasury\\n            );\\n        } // T:[PS-3, 34]\\n\\n        DieselToken(dieselToken).burn(msg.sender, amount); // T:[PS-3, 8]\\n\\n        _expectedLiquidityLU = _expectedLiquidityLU.sub(underlyingTokensAmount); // T:[PS-3, 8]\\n        _updateBorrowRate(0); // T:[PS-3,8 ]\\n\\n        emit RemoveLiquidity(msg.sender, to, amount); // T:[PS-3, 8]\\n\\n        return amountSent;\\n    }\\n\\n    /// @dev Returns expected liquidity - the amount of money should be in the pool\\n    /// if all users close their Credit accounts and return debt\\n    ///\\n    /// More: https://dev.gearbox.fi/developers/pools/economy#expected-liquidity\\n    function expectedLiquidity() public view override returns (uint256) {\\n        // timeDifference = blockTime - previous timeStamp\\n        uint256 timeDifference = block.timestamp.sub(uint256(_timestampLU));\\n\\n        //                                    currentBorrowRate * timeDifference\\n        //  interestAccrued = totalBorrow *  ------------------------------------\\n        //                                             SECONDS_PER_YEAR\\n        //\\n        uint256 interestAccrued = totalBorrowed\\n        .mul(borrowAPY_RAY)\\n        .mul(timeDifference)\\n        .div(Constants.RAY)\\n        .div(Constants.SECONDS_PER_YEAR); // T:[PS-29]\\n\\n        return _expectedLiquidityLU.add(interestAccrued); // T:[PS-29]\\n    }\\n\\n    /// @dev Returns available liquidity in the pool (pool balance)\\n    /// More: https://dev.gearbox.fi/developers/\\n    function availableLiquidity() public view override returns (uint256) {\\n        return IERC20(underlyingToken).balanceOf(address(this));\\n    }\\n\\n    //\\n    // CREDIT ACCOUNT LENDING\\n    //\\n\\n    /// @dev Lends funds to credit manager and updates the pool parameters\\n    /// More: https://dev.gearbox.fi/developers/pools/pool-service#lendcreditAccount\\n    ///\\n    /// @param borrowedAmount Borrowed amount for credit account\\n    /// @param creditAccount Credit account address\\n    ///\\n    /// #if_succeeds {:msg \\\"After lendCreditAccount() borrow rate increases\\\"}\\n    ///      borrowedAmount > 0 ==> borrowAPY_RAY >= old(currentBorrowRate());\\n    /// #limit {:msg \\\"Not more than 1 day since last borrow rate update\\\"} block.timestamp <= _timestampLU + 3600 * 24;\\n    function lendCreditAccount(uint256 borrowedAmount, address creditAccount)\\n        external\\n        override\\n        whenNotPaused // T:[PS-4]\\n    {\\n        require(\\n            creditManagersCanBorrow[msg.sender],\\n            Errors.POOL_CONNECTED_CREDIT_MANAGERS_ONLY\\n        ); // T:[PS-12, 13]\\n\\n        // Transfer funds to credit account\\n        IERC20(underlyingToken).safeTransfer(creditAccount, borrowedAmount); // T:[PS-14]\\n\\n        // Update borrow Rate\\n        _updateBorrowRate(0); // T:[PS-17]\\n\\n        // Increase total borrowed amount\\n        totalBorrowed = totalBorrowed.add(borrowedAmount); // T:[PS-16]\\n\\n        emit Borrow(msg.sender, creditAccount, borrowedAmount); // T:[PS-15]\\n    }\\n\\n    /// @dev It's called after credit account funds transfer back to pool and updates corretly parameters.\\n    /// More: https://dev.gearbox.fi/developers/pools/pool-service#repaycreditAccount\\n    ///\\n    /// @param borrowedAmount Borrowed amount (without interest accrued)\\n    /// @param profit Represents PnL value if PnL > 0\\n    /// @param loss Represents PnL value if PnL <0\\n    ///\\n    /// #if_succeeds {:msg \\\"Cant have both profit and loss\\\"} !(profit > 0 && loss > 0);\\n    /// #if_succeeds {:msg \\\"After repayCreditAccount() if we are profitabe, or treasury can cover the losses, diesel rate doesn't decrease\\\"}\\n    ///      (profit > 0 || toDiesel(loss) >= DieselToken(dieselToken).balanceOf(treasuryAddress)) ==> getDieselRate_RAY() >= old(getDieselRate_RAY());\\n    /// #limit {:msg \\\"Not more than 1 day since last borrow rate update\\\"} block.timestamp <= _timestampLU + 3600 * 24;\\n    function repayCreditAccount(\\n        uint256 borrowedAmount,\\n        uint256 profit,\\n        uint256 loss\\n    )\\n        external\\n        override\\n        whenNotPaused // T:[PS-4]\\n    {\\n        require(\\n            creditManagersCanRepay[msg.sender],\\n            Errors.POOL_CONNECTED_CREDIT_MANAGERS_ONLY\\n        ); // T:[PS-12]\\n\\n        // For fee surplus we mint tokens for treasury\\n        if (profit > 0) {\\n            // T:[PS-22] provess that diesel rate will be the same within the margin of error\\n            DieselToken(dieselToken).mint(treasuryAddress, toDiesel(profit)); // T:[PS-21, 22]\\n            _expectedLiquidityLU = _expectedLiquidityLU.add(profit); // T:[PS-21, 22]\\n        }\\n        // If returned money < borrowed amount + interest accrued\\n        // it tries to compensate loss by burning diesel (LP) tokens\\n        // from treasury fund\\n        else {\\n            uint256 amountToBurn = toDiesel(loss); // T:[PS-19,20]\\n\\n            uint256 treasuryBalance = DieselToken(dieselToken).balanceOf(\\n                treasuryAddress\\n            ); // T:[PS-19,20]\\n\\n            if (treasuryBalance < amountToBurn) {\\n                amountToBurn = treasuryBalance;\\n                emit UncoveredLoss(\\n                    msg.sender,\\n                    loss.sub(fromDiesel(treasuryBalance))\\n                ); // T:[PS-23]\\n            }\\n\\n            // If treasury has enough funds, it just burns needed amount\\n            // to keep diesel rate on the same level\\n            DieselToken(dieselToken).burn(treasuryAddress, amountToBurn); // T:[PS-19, 20]\\n\\n            //            _expectedLiquidityLU = _expectedLiquidityLU.sub(loss); //T:[PS-19,20]\\n        }\\n\\n        // Update available liquidity\\n        _updateBorrowRate(loss); // T:[PS-19, 20, 21]\\n\\n        // Reduce total borrowed. Should be after _updateBorrowRate() for correct calculations\\n        totalBorrowed = totalBorrowed.sub(borrowedAmount); // T:[PS-19, 20]\\n\\n        emit Repay(msg.sender, borrowedAmount, profit, loss); // T:[PS-18]\\n    }\\n\\n    //\\n    // INTEREST RATE MANAGEMENT\\n    //\\n\\n    /**\\n     * @dev Calculates interest accrued from the last update using the linear model\\n     *\\n     *                                    /     currentBorrowRate * timeDifference \\\\\\n     *  newCumIndex  = currentCumIndex * | 1 + ------------------------------------ |\\n     *                                    \\\\              SECONDS_PER_YEAR          /\\n     *\\n     * @return current cumulative index in RAY\\n     */\\n    function calcLinearCumulative_RAY() public view override returns (uint256) {\\n        //solium-disable-next-line\\n        uint256 timeDifference = block.timestamp.sub(uint256(_timestampLU)); // T:[PS-28]\\n\\n        return\\n            calcLinearIndex_RAY(\\n                _cumulativeIndex_RAY,\\n                borrowAPY_RAY,\\n                timeDifference\\n            ); // T:[PS-28]\\n    }\\n\\n    /// @dev Calculate linear index\\n    /// @param cumulativeIndex_RAY Current cumulative index in RAY\\n    /// @param currentBorrowRate_RAY Current borrow rate in RAY\\n    /// @param timeDifference Duration in seconds\\n    /// @return newCumulativeIndex Cumulative index accrued duration in Rays\\n    function calcLinearIndex_RAY(\\n        uint256 cumulativeIndex_RAY,\\n        uint256 currentBorrowRate_RAY,\\n        uint256 timeDifference\\n    ) public pure returns (uint256) {\\n        //                                    /     currentBorrowRate * timeDifference \\\\\\n        //  newCumIndex  = currentCumIndex * | 1 + ------------------------------------ |\\n        //                                    \\\\              SECONDS_PER_YEAR          /\\n        //\\n        uint256 linearAccumulated_RAY = WadRayMath.RAY.add(\\n            currentBorrowRate_RAY.mul(timeDifference).div(\\n                Constants.SECONDS_PER_YEAR\\n            )\\n        ); // T:[GM-2]\\n\\n        return cumulativeIndex_RAY.rayMul(linearAccumulated_RAY); // T:[GM-2]\\n    }\\n\\n    /// @dev Updates Cumulative index when liquidity parameters are changed\\n    ///  - compute how much interest were accrued from last update\\n    ///  - compute new cumulative index based on updated liquidity parameters\\n    ///  - stores new cumulative index and timestamp when it was updated\\n    function _updateBorrowRate(uint256 loss) internal {\\n        // Update total _expectedLiquidityLU\\n\\n        _expectedLiquidityLU = expectedLiquidity().sub(loss); // T:[PS-27]\\n\\n        // Update cumulativeIndex\\n        _cumulativeIndex_RAY = calcLinearCumulative_RAY(); // T:[PS-27]\\n\\n        // update borrow APY\\n        borrowAPY_RAY = interestRateModel.calcBorrowRate(\\n            _expectedLiquidityLU,\\n            availableLiquidity()\\n        ); // T:[PS-27]\\n        _timestampLU = block.timestamp; // T:[PS-27]\\n    }\\n\\n    //\\n    // DIESEL TOKEN MGMT\\n    //\\n\\n    /// @dev Returns current diesel rate in RAY format\\n    /// More info: https://dev.gearbox.fi/developers/pools/economy#diesel-rate\\n    function getDieselRate_RAY() public view override returns (uint256) {\\n        uint256 dieselSupply = IERC20(dieselToken).totalSupply();\\n        if (dieselSupply == 0) return WadRayMath.RAY; // T:[PS-1]\\n        return expectedLiquidity().mul(Constants.RAY).div(dieselSupply); // T:[PS-6]\\n    }\\n\\n    /// @dev Converts amount into diesel tokens\\n    /// @param amount Amount in underlying tokens to be converted to diesel tokens\\n    function toDiesel(uint256 amount) public view override returns (uint256) {\\n        return amount.mul(Constants.RAY).div(getDieselRate_RAY()); // T:[PS-24]\\n    }\\n\\n    /// @dev Converts amount from diesel tokens to undelying token\\n    /// @param amount Amount in diesel tokens to be converted to diesel tokens\\n    function fromDiesel(uint256 amount) public view override returns (uint256) {\\n        return amount.mul(getDieselRate_RAY()).div(Constants.RAY); // T:[PS-24]\\n    }\\n\\n    //\\n    // CONFIGURATION\\n    //\\n\\n    /// @dev Connects new Credif manager to pool\\n    /// @param _creditManager Address of credif manager\\n    function connectCreditManager(address _creditManager)\\n        external\\n        configuratorOnly // T:[PS-9]\\n    {\\n        require(\\n            address(this) == ICreditManager(_creditManager).poolService(),\\n            Errors.POOL_INCOMPATIBLE_CREDIT_ACCOUNT_MANAGER\\n        ); // T:[PS-10]\\n\\n        require(\\n            !creditManagersCanRepay[_creditManager],\\n            Errors.POOL_CANT_ADD_CREDIT_MANAGER_TWICE\\n        ); // T:[PS-35]\\n\\n        creditManagersCanBorrow[_creditManager] = true; // T:[PS-11]\\n        creditManagersCanRepay[_creditManager] = true; // T:[PS-11]\\n        creditManagers.push(_creditManager); // T:[PS-11]\\n        emit NewCreditManagerConnected(_creditManager); // T:[PS-11]\\n    }\\n\\n    /// @dev Forbid to borrow for particulat credif manager\\n    /// @param _creditManager Address of credif manager\\n    function forbidCreditManagerToBorrow(address _creditManager)\\n        external\\n        configuratorOnly // T:[PS-9]\\n    {\\n        creditManagersCanBorrow[_creditManager] = false; // T:[PS-13]\\n        emit BorrowForbidden(_creditManager); // T:[PS-13]\\n    }\\n\\n    /// @dev Sets the new interest rate model for pool\\n    /// @param _interestRateModel Address of new interest rate model contract\\n    /// #limit {:msg \\\"Disallow updating the interest rate model after the constructor\\\"} address(interestRateModel) == address(0x0);\\n    function updateInterestRateModel(address _interestRateModel)\\n        public\\n        configuratorOnly // T:[PS-9]\\n    {\\n        _updateInterestRateModel(_interestRateModel);\\n    }\\n\\n    function _updateInterestRateModel(address _interestRateModel) internal {\\n        require(\\n            _interestRateModel != address(0),\\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\\n        );\\n        interestRateModel = IInterestRateModel(_interestRateModel); // T:[PS-25]\\n        _updateBorrowRate(0); // T:[PS-26]\\n        emit NewInterestRateModel(_interestRateModel); // T:[PS-25]\\n    }\\n\\n    /// @dev Sets expected liquidity limit\\n    /// @param newLimit New expected liquidity limit\\n    function setExpectedLiquidityLimit(uint256 newLimit)\\n        external\\n        configuratorOnly // T:[PS-9]\\n    {\\n        expectedLiquidityLimit = newLimit; // T:[PS-30]\\n        emit NewExpectedLiquidityLimit(newLimit); // T:[PS-30]\\n    }\\n\\n    /// @dev Sets withdraw fee\\n    function setWithdrawFee(uint256 fee)\\n        public\\n        configuratorOnly // T:[PS-9]\\n    {\\n        require(\\n            fee <= Constants.MAX_WITHDRAW_FEE,\\n            Errors.POOL_INCORRECT_WITHDRAW_FEE\\n        ); // T:[PS-32]\\n        withdrawFee = fee; // T:[PS-33]\\n        emit NewWithdrawFee(fee); // T:[PS-33]\\n    }\\n\\n    /// @dev Returns quantity of connected credit accounts managers\\n    function creditManagersCount() external view override returns (uint256) {\\n        return creditManagers.length; // T:[PS-11]\\n    }\\n\\n    function calcCumulativeIndexAtBorrowMore(\\n        uint256 amount,\\n        uint256 dAmount,\\n        uint256 cumulativeIndexAtOpen\\n    ) external view override returns (uint256) {\\n        return\\n            calcLinearCumulative_RAY()\\n                .mul(cumulativeIndexAtOpen)\\n                .mul(amount.add(dAmount))\\n                .div(\\n                calcLinearCumulative_RAY().mul(amount).add(\\n                    dAmount.mul(cumulativeIndexAtOpen)\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/credit/CreditManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\npragma abicoder v2;\\n\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport {PercentageMath} from \\\"../libraries/math/PercentageMath.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\nimport {IAccountFactory} from \\\"../interfaces/IAccountFactory.sol\\\";\\nimport {ICreditAccount} from \\\"../interfaces/ICreditAccount.sol\\\";\\nimport {IPoolService} from \\\"../interfaces/IPoolService.sol\\\";\\nimport {IWETHGateway} from \\\"../interfaces/IWETHGateway.sol\\\";\\nimport {ICreditManager} from \\\"../interfaces/ICreditManager.sol\\\";\\nimport {ICreditFilter} from \\\"../interfaces/ICreditFilter.sol\\\";\\nimport {AddressProvider} from \\\"../core/AddressProvider.sol\\\";\\nimport {ACLTrait} from \\\"../core/ACLTrait.sol\\\";\\n\\nimport {Constants} from \\\"../libraries/helpers/Constants.sol\\\";\\nimport {Errors} from \\\"../libraries/helpers/Errors.sol\\\";\\nimport {DataTypes} from \\\"../libraries/data/Types.sol\\\";\\n\\n\\n/// @title Credit Manager\\n/// @notice It encapsulates business logic for managing credit accounts\\n///\\n/// More info: https://dev.gearbox.fi/developers/credit/credit_manager\\n///\\n/// #define roughEq(uint256 a, uint256 b) bool =\\n///     a == b || a + 1 == b || a == b + 1;\\n///\\n/// #define borrowedPlusInterest(address creditAccount) uint =\\n///     let borrowedAmount, cumIndexAtOpen := getCreditAccountParameters(creditAccount) in\\n///     let curCumulativeIndex := IPoolService(poolService).calcLinearCumulative_RAY() in\\n///         borrowedAmount.mul(curCumulativeIndex).div(cumIndexAtOpen);\\ncontract CreditManager is ICreditManager, ACLTrait, ReentrancyGuard {\\n    using SafeMath for uint256;\\n    using PercentageMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using Address for address payable;\\n\\n    // Minimal amount for open credit account\\n    uint256 public override minAmount;\\n\\n    //  Maximum amount for open credit account\\n    uint256 public override maxAmount;\\n\\n    // Maximum leveraged factor allowed for this pool\\n    uint256 public override maxLeverageFactor;\\n\\n    // Minimal allowed Hf after increasing borrow amount\\n    uint256 public override minHealthFactor;\\n\\n    // Mapping between borrowers'/farmers' address and credit account\\n    mapping(address => address) public override creditAccounts;\\n\\n    // Account manager - provides credit accounts to pool\\n    IAccountFactory internal _accountFactory;\\n\\n    // Credit Manager filter\\n    ICreditFilter public override creditFilter;\\n\\n    // Underlying token address\\n    address public override underlyingToken;\\n\\n    // Address of connected pool\\n    address public override poolService;\\n\\n    // Address of WETH token\\n    address public wethAddress;\\n\\n    // Address of WETH Gateway\\n    address public wethGateway;\\n\\n    // Default swap contracts - uses for automatic close\\n    address public override defaultSwapContract;\\n\\n    uint256 public override feeInterest;\\n\\n    uint256 public override feeLiquidation;\\n\\n    uint256 public override liquidationDiscount;\\n\\n    // Contract version\\n    uint constant public version = 1;\\n\\n    //\\n    // MODIFIERS\\n    //\\n\\n    /// @dev Restricts actions for users with opened credit accounts only\\n    modifier allowedAdaptersOnly(address targetContract) {\\n        require(\\n            creditFilter.contractToAdapter(targetContract) == msg.sender,\\n            Errors.CM_TARGET_CONTRACT_iS_NOT_ALLOWED\\n        );\\n        _;\\n    }\\n\\n    /// @dev Constructor\\n    /// @param _addressProvider Address Repository for upgradable contract model\\n    /// @param _minAmount Minimal amount for open credit account\\n    /// @param _maxAmount Maximum amount for open credit account\\n    /// @param _maxLeverage Maximum allowed leverage factor\\n    /// @param _poolService Address of pool service\\n    /// @param _creditFilterAddress CreditFilter address. It should be finalised\\n    /// @param _defaultSwapContract Default IUniswapV2Router02 contract to change assets in case of closing account\\n    constructor(\\n        address _addressProvider,\\n        uint256 _minAmount,\\n        uint256 _maxAmount,\\n        uint256 _maxLeverage,\\n        address _poolService,\\n        address _creditFilterAddress,\\n        address _defaultSwapContract\\n    ) ACLTrait(_addressProvider) {\\n        require(\\n            _addressProvider != address(0) &&\\n                _poolService != address(0) &&\\n                _creditFilterAddress != address(0) &&\\n                _defaultSwapContract != address(0),\\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\\n        );\\n        AddressProvider addressProvider = AddressProvider(_addressProvider); // T:[CM-1]\\n        poolService = _poolService; // T:[CM-1]\\n        underlyingToken = IPoolService(_poolService).underlyingToken(); // T:[CM-1]\\n\\n        wethAddress = addressProvider.getWethToken(); // T:[CM-1]\\n        wethGateway = addressProvider.getWETHGateway(); // T:[CM-1]\\n        defaultSwapContract = _defaultSwapContract; // T:[CM-1]\\n        _accountFactory = IAccountFactory(addressProvider.getAccountFactory()); // T:[CM-1]\\n\\n        _setParams(\\n            _minAmount,\\n            _maxAmount,\\n            _maxLeverage,\\n            Constants.FEE_INTEREST,\\n            Constants.FEE_LIQUIDATION,\\n            Constants.LIQUIDATION_DISCOUNTED_SUM\\n        ); // T:[CM-1]\\n\\n        creditFilter = ICreditFilter(_creditFilterAddress); // T:[CM-1]\\n    }\\n\\n    //\\n    // CREDIT ACCOUNT MANAGEMENT\\n    //\\n\\n    /**\\n     * @dev Opens credit account and provides credit funds.\\n     * - Opens credit account (take it from account factory^1)\\n     * - Transfers trader /farmers initial funds to credit account\\n     * - Transfers borrowed leveraged amount from pool (= amount x leverageFactor) calling lendCreditAccount() on connected Pool contract.\\n     * - Emits OpenCreditAccount event\\n     * Function reverts if user has already opened position\\n     *\\n     * More info: https://dev.gearbox.fi/developers/credit/credit_manager#open-credit-account\\n     *\\n     * @param amount Borrowers own funds\\n     * @param onBehalfOf The address that we open credit account. Same as msg.sender if the user wants to open it for  his own wallet,\\n     *  or a different address if the beneficiary is a different wallet\\n     * @param leverageFactor Multiplier to borrowers own funds\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     *\\n     * #if_succeeds {:msg \\\"A credit account with the correct balance is opened.\\\"}\\n     *      let newAccount := creditAccounts[onBehalfOf] in\\n     *      newAccount != address(0) &&\\n     *          IERC20(underlyingToken).balanceOf(newAccount) >=\\n     *          amount.add(amount.mul(leverageFactor).div(Constants.LEVERAGE_DECIMALS));\\n     *\\n     * #if_succeeds {:msg \\\"Sender looses amount tokens.\\\" }\\n     *      IERC20(underlyingToken).balanceOf(msg.sender) == old(IERC20(underlyingToken).balanceOf(msg.sender)) - amount;\\n     *\\n     * #if_succeeds {:msg \\\"Pool provides correct leverage (amount x leverageFactor).\\\" }\\n     *      IERC20(underlyingToken).balanceOf(poolService) == old(IERC20(underlyingToken).balanceOf(poolService)) - amount.mul(leverageFactor).div(Constants.LEVERAGE_DECIMALS);\\n     *\\n     * #if_succeeds {:msg \\\"The new account is healthy.\\\"}\\n     *      creditFilter.calcCreditAccountHealthFactor(creditAccounts[onBehalfOf]) >= PercentageMath.PERCENTAGE_FACTOR;\\n     *\\n     * #if_succeeds {:msg \\\"The new account has balance <= 1 for all tokens other than the underlying token.\\\"}\\n     *     let newAccount := creditAccounts[onBehalfOf] in\\n     *         forall (uint i in 1...creditFilter.allowedTokensCount())\\n     *             IERC20(creditFilter.allowedTokens(i)).balanceOf(newAccount) <= 1;\\n     */\\n    function openCreditAccount(\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint256 leverageFactor,\\n        uint256 referralCode\\n    )\\n        external\\n        override\\n        whenNotPaused // T:[CM-39]\\n        nonReentrant\\n    {\\n        // Checks that amount is in limits\\n        require(\\n            amount >= minAmount &&\\n                amount <= maxAmount &&\\n                leverageFactor > 0 &&\\n                leverageFactor <= maxLeverageFactor,\\n            Errors.CM_INCORRECT_PARAMS\\n        ); // T:[CM-2]\\n\\n        // Checks that user \\\"onBehalfOf\\\" has no opened accounts\\n        //        require(\\n        //            !hasOpenedCreditAccount(onBehalfOf) && onBehalfOf != address(0),\\n        //            Errors.CM_ZERO_ADDRESS_OR_USER_HAVE_ALREADY_OPEN_CREDIT_ACCOUNT\\n        //        ); // T:[CM-3]\\n\\n        _checkAccountTransfer(onBehalfOf);\\n\\n        // borrowedAmount = amount * leverageFactor\\n        uint256 borrowedAmount = amount.mul(leverageFactor).div(\\n            Constants.LEVERAGE_DECIMALS\\n        ); // T:[CM-7]\\n\\n        // Get Reusable Credit account creditAccount\\n        address creditAccount = _accountFactory.takeCreditAccount(\\n            borrowedAmount,\\n            IPoolService(poolService).calcLinearCumulative_RAY()\\n        ); // T:[CM-5]\\n\\n        // Initializes enabled tokens for the account. Enabled tokens is a bit mask which\\n        // holds information which tokens were used by user\\n        creditFilter.initEnabledTokens(creditAccount); // T:[CM-5]\\n\\n        // Transfer pool tokens to new credit account\\n        IPoolService(poolService).lendCreditAccount(\\n            borrowedAmount,\\n            creditAccount\\n        ); // T:[CM-7]\\n\\n        // Transfer borrower own fund to credit account\\n        IERC20(underlyingToken).safeTransferFrom(\\n            msg.sender,\\n            creditAccount,\\n            amount\\n        ); // T:[CM-6]\\n\\n        // link credit account address with borrower address\\n        creditAccounts[onBehalfOf] = creditAccount; // T:[CM-5]\\n\\n        // emit new event\\n        emit OpenCreditAccount(\\n            msg.sender,\\n            onBehalfOf,\\n            creditAccount,\\n            amount,\\n            borrowedAmount,\\n            referralCode\\n        ); // T:[CM-8]\\n    }\\n\\n    /**\\n     * @dev Closes credit account\\n     * - Swaps all assets to underlying one using default swap protocol\\n     * - Pays borrowed amount + interest accrued + fees back to the pool by calling repayCreditAccount\\n     * - Transfers remaining funds to the trader / farmer\\n     * - Closes the credit account and return it to account factory\\n     * - Emits CloseCreditAccount event\\n     *\\n     * More info: https://dev.gearbox.fi/developers/credit/credit_manager#close-credit-account\\n     *\\n     * @param to Address to send remaining funds\\n     * @param paths Exchange type data which provides paths + amountMinOut\\n     *\\n     * #if_succeeds {:msg \\\"Can only be called by account holder\\\"} old(creditAccounts[msg.sender]) != address(0x0);\\n     * #if_succeeds {:msg \\\"Can only close healthy accounts\\\" } old(creditFilter.calcCreditAccountHealthFactor(creditAccounts[msg.sender])) > PercentageMath.PERCENTAGE_FACTOR;\\n     * #if_succeeds {:msg \\\"If this succeeded the pool gets paid at least borrowed + interest\\\"}\\n     *    let minAmountOwedToPool := old(borrowedPlusInterest(creditAccounts[msg.sender])) in\\n     *        IERC20(underlyingToken).balanceOf(poolService) >= old(IERC20(underlyingToken).balanceOf(poolService)).add(minAmountOwedToPool);\\n     */\\n    function closeCreditAccount(address to, DataTypes.Exchange[] calldata paths)\\n        external\\n        override\\n        whenNotPaused // T:[CM-39]\\n        nonReentrant\\n    {\\n        address creditAccount = getCreditAccountOrRevert(msg.sender); // T: [CM-9, 44]\\n\\n        // Converts all assets to underlying one. _convertAllAssetsToUnderlying is virtual\\n        _convertAllAssetsToUnderlying(creditAccount, paths); // T: [CM-44]\\n\\n        // total value equals underlying assets after converting all assets\\n        uint256 totalValue = IERC20(underlyingToken).balanceOf(creditAccount); // T: [CM-44]\\n\\n        (, uint256 remainingFunds) = _closeCreditAccountImpl(\\n            creditAccount,\\n            Constants.OPERATION_CLOSURE,\\n            totalValue,\\n            msg.sender,\\n            address(0),\\n            to\\n        ); // T: [CM-44]\\n\\n        emit CloseCreditAccount(msg.sender, to, remainingFunds); // T: [CM-44]\\n    }\\n\\n    /**\\n     * @dev Liquidates credit account\\n     * - Transfers discounted total credit account value from liquidators account\\n     * - Pays borrowed funds + interest + fees back to pool, than transfers remaining funds to credit account owner\\n     * - Transfer all assets from credit account to liquidator (\\\"to\\\") account\\n     * - Returns credit account to factory\\n     * - Emits LiquidateCreditAccount event\\n     *\\n     * More info: https://dev.gearbox.fi/developers/credit/credit_manager#liquidate-credit-account\\n     *\\n     * @param borrower Borrower address\\n     * @param to Address to transfer all assets from credit account\\n     *\\n     * #if_succeeds {:msg \\\"Can only be called by account holder\\\"} old(creditAccounts[msg.sender]) != address(0x0);\\n     * #if_succeeds {:msg \\\"Can only liquidate an un-healthy accounts\\\" } old(creditFilter.calcCreditAccountHealthFactor(creditAccounts[msg.sender])) < PercentageMath.PERCENTAGE_FACTOR;\\n     */\\n    function liquidateCreditAccount(\\n        address borrower,\\n        address to,\\n        bool force\\n    )\\n        external\\n        override\\n        whenNotPaused // T:[CM-39]\\n        nonReentrant\\n    {\\n        address creditAccount = getCreditAccountOrRevert(borrower); // T: [CM-9]\\n\\n        // transfers assets to \\\"to\\\" address and compute total value (tv) & threshold weighted value (twv)\\n        (uint256 totalValue, uint256 tvw) = _transferAssetsTo(\\n            creditAccount,\\n            to,\\n            force\\n        ); // T:[CM-13, 16, 17]\\n\\n        // Checks that current Hf < 1\\n        require(\\n            tvw <\\n                creditFilter\\n                .calcCreditAccountAccruedInterest(creditAccount)\\n                .mul(PercentageMath.PERCENTAGE_FACTOR),\\n            Errors.CM_CAN_LIQUIDATE_WITH_SUCH_HEALTH_FACTOR\\n        ); // T:[CM-13, 16, 17]\\n\\n        // Liquidate credit account\\n        (, uint256 remainingFunds) = _closeCreditAccountImpl(\\n            creditAccount,\\n            Constants.OPERATION_LIQUIDATION,\\n            totalValue,\\n            borrower,\\n            msg.sender,\\n            to\\n        ); // T:[CM-13]\\n\\n        emit LiquidateCreditAccount(borrower, msg.sender, remainingFunds); // T:[CM-13]\\n    }\\n\\n    /// @dev Repays credit account\\n    /// More info: https://dev.gearbox.fi/developers/credit/credit_manager#repay-credit-account\\n    ///\\n    /// @param to Address to send credit account assets\\n    /// #if_succeeds {:msg \\\"Can only be called by account holder\\\"} old(creditAccounts[msg.sender]) != address(0x0);\\n    /// #if_succeeds {:msg \\\"If this succeeded the pool gets paid at least borrowed + interest\\\"}\\n    ///     let minAmountOwedToPool := old(borrowedPlusInterest(creditAccounts[msg.sender])) in\\n    ///         IERC20(underlyingToken).balanceOf(poolService) >= old(IERC20(underlyingToken).balanceOf(poolService)).add(minAmountOwedToPool);\\n    function repayCreditAccount(address to)\\n        external\\n        override\\n        whenNotPaused // T:[CM-39]\\n        nonReentrant\\n    {\\n        _repayCreditAccountImpl(msg.sender, to); // T:[CM-17]\\n    }\\n\\n    /// @dev Repay credit account with ETH. Restricted to be called by WETH Gateway only\\n    ///\\n    /// @param borrower Address of borrower\\n    /// @param to Address to send credit account assets\\n    /// #if_succeeds {:msg \\\"If this succeeded the pool gets paid at least borrowed + interest\\\"}\\n    ///     let minAmountOwedToPool := old(borrowedPlusInterest(creditAccounts[borrower])) in\\n    ///         IERC20(underlyingToken).balanceOf(poolService) >= old(IERC20(underlyingToken).balanceOf(poolService)).add(minAmountOwedToPool);\\n    function repayCreditAccountETH(address borrower, address to)\\n        external\\n        override\\n        whenNotPaused // T:[CM-39]\\n        nonReentrant\\n        returns (uint256)\\n    {\\n        // Checks that msg.sender is WETH Gateway\\n        require(msg.sender == wethGateway, Errors.CM_WETH_GATEWAY_ONLY); // T:[CM-38]\\n\\n        // Difference with usual Repay is that there is borrower in repay implementation call\\n        return _repayCreditAccountImpl(borrower, to); // T:[WG-11]\\n    }\\n\\n    /// @dev Implements logic for repay credit accounts\\n    ///\\n    /// @param borrower Borrower address\\n    /// @param to Address to transfer assets from credit account\\n    function _repayCreditAccountImpl(address borrower, address to)\\n        internal\\n        returns (uint256)\\n    {\\n        address creditAccount = getCreditAccountOrRevert(borrower);\\n        (uint256 totalValue, ) = _transferAssetsTo(creditAccount, to, false); // T:[CM-17, 23]\\n\\n        (uint256 amountToPool, ) = _closeCreditAccountImpl(\\n            creditAccount,\\n            Constants.OPERATION_REPAY,\\n            totalValue,\\n            borrower,\\n            borrower,\\n            to\\n        ); // T:[CM-17]\\n\\n        emit RepayCreditAccount(borrower, to); // T:[CM-18]\\n        return amountToPool;\\n    }\\n\\n    /// @dev Implementation for all closing account procedures\\n    /// #if_succeeds {:msg \\\"Credit account balances should be <= 1 for all allowed tokens after closing\\\"}\\n    ///     forall (uint i in 0...creditFilter.allowedTokensCount())\\n    ///         IERC20(creditFilter.allowedTokens(i)).balanceOf(creditAccount) <= 1;\\n    function _closeCreditAccountImpl(\\n        address creditAccount,\\n        uint8 operation,\\n        uint256 totalValue,\\n        address borrower,\\n        address liquidator,\\n        address to\\n    ) internal returns (uint256, uint256) {\\n        bool isLiquidated = operation == Constants.OPERATION_LIQUIDATION;\\n\\n        (\\n            uint256 borrowedAmount,\\n            uint256 amountToPool,\\n            uint256 remainingFunds,\\n            uint256 profit,\\n            uint256 loss\\n        ) = _calcClosePayments(creditAccount, totalValue, isLiquidated); // T:[CM-11, 15, 17]\\n\\n        if (operation == Constants.OPERATION_CLOSURE) {\\n            ICreditAccount(creditAccount).safeTransfer(\\n                underlyingToken,\\n                poolService,\\n                amountToPool\\n            ); // T:[CM-11]\\n\\n            // close operation with loss is not allowed\\n            require(remainingFunds > 0, Errors.CM_CANT_CLOSE_WITH_LOSS); // T:[CM-42]\\n\\n            // transfer remaining funds to borrower\\n            _safeTokenTransfer(\\n                creditAccount,\\n                underlyingToken,\\n                to,\\n                remainingFunds,\\n                false\\n            ); // T:[CM-11]\\n        }\\n        // LIQUIDATION\\n        else if (operation == Constants.OPERATION_LIQUIDATION) {\\n            // repay amount to pool\\n            IERC20(underlyingToken).safeTransferFrom(\\n                liquidator,\\n                poolService,\\n                amountToPool\\n            ); // T:[CM-14]\\n\\n            // transfer remaining funds to borrower\\n            if (remainingFunds > 0) {\\n                IERC20(underlyingToken).safeTransferFrom(\\n                    liquidator,\\n                    borrower,\\n                    remainingFunds\\n                ); //T:[CM-14]\\n            }\\n        }\\n        // REPAY\\n        else {\\n            // repay amount to pool\\n            IERC20(underlyingToken).safeTransferFrom(\\n                msg.sender, // msg.sender in case of WETH Gateway\\n                poolService,\\n                amountToPool\\n            ); // T:[CM-17]\\n        }\\n\\n        // Return creditAccount\\n        _accountFactory.returnCreditAccount(creditAccount); // T:[CM-21]\\n\\n        // Release memory\\n        delete creditAccounts[borrower]; // T:[CM-27]\\n\\n        // Transfer pool tokens to new credit account\\n        IPoolService(poolService).repayCreditAccount(\\n            borrowedAmount,\\n            profit,\\n            loss\\n        ); // T:[CM-11, 15]\\n\\n        return (amountToPool, remainingFunds); // T:[CM-11]\\n    }\\n\\n    /// @dev Collects data and call calc payments pure function during closure procedures\\n    /// @param creditAccount Credit account address\\n    /// @param totalValue Credit account total value\\n    /// @param isLiquidated True if calculations needed for liquidation\\n    function _calcClosePayments(\\n        address creditAccount,\\n        uint256 totalValue,\\n        bool isLiquidated\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 _borrowedAmount,\\n            uint256 amountToPool,\\n            uint256 remainingFunds,\\n            uint256 profit,\\n            uint256 loss\\n        )\\n    {\\n        // Gets credit account parameters\\n        (\\n            uint256 borrowedAmount,\\n            uint256 cumulativeIndexAtCreditAccountOpen_RAY\\n        ) = getCreditAccountParameters(creditAccount); // T:[CM-13]\\n\\n        return\\n            _calcClosePaymentsPure(\\n                totalValue,\\n                isLiquidated,\\n                borrowedAmount,\\n                cumulativeIndexAtCreditAccountOpen_RAY,\\n                IPoolService(poolService).calcLinearCumulative_RAY()\\n            );\\n    }\\n\\n    /// @dev Computes all close parameters based on data\\n    /// @param totalValue Credit account total value\\n    /// @param isLiquidated True if calculations needed for liquidation\\n    /// @param borrowedAmount Credit account borrow amount\\n    /// @param cumulativeIndexAtCreditAccountOpen_RAY Cumulative index at opening credit account in RAY format\\n    /// @param cumulativeIndexNow_RAY Current value of cumulative index in RAY format\\n    function _calcClosePaymentsPure(\\n        uint256 totalValue,\\n        bool isLiquidated,\\n        uint256 borrowedAmount,\\n        uint256 cumulativeIndexAtCreditAccountOpen_RAY,\\n        uint256 cumulativeIndexNow_RAY\\n    )\\n        public\\n        view\\n        returns (\\n            uint256 _borrowedAmount,\\n            uint256 amountToPool,\\n            uint256 remainingFunds,\\n            uint256 profit,\\n            uint256 loss\\n        )\\n    {\\n        uint256 totalFunds = isLiquidated\\n            ? totalValue.mul(liquidationDiscount).div(\\n                PercentageMath.PERCENTAGE_FACTOR\\n            )\\n            : totalValue; // T:[CM-45]\\n\\n        _borrowedAmount = borrowedAmount; // T:[CM-45]\\n\\n        uint256 borrowedAmountWithInterest = borrowedAmount\\n        .mul(cumulativeIndexNow_RAY)\\n        .div(cumulativeIndexAtCreditAccountOpen_RAY); // T:[CM-45]\\n\\n        if (totalFunds < borrowedAmountWithInterest) {\\n            amountToPool = totalFunds.sub(1); // T:[CM-45]\\n            loss = borrowedAmountWithInterest.sub(amountToPool); // T:[CM-45]\\n        } else {\\n            amountToPool = isLiquidated\\n                ? totalFunds.percentMul(feeLiquidation).add(\\n                    borrowedAmountWithInterest\\n                )\\n                : borrowedAmountWithInterest.add(\\n                    borrowedAmountWithInterest.sub(borrowedAmount).percentMul(\\n                        feeInterest\\n                    )\\n                ); // T:[CM-45]\\n\\n            if (totalFunds > amountToPool) {\\n                remainingFunds = totalFunds.sub(amountToPool).sub(1); // T:[CM-45]\\n            } else {\\n                amountToPool = totalFunds.sub(1); // T:[CM-45]\\n            }\\n\\n            profit = amountToPool.sub(borrowedAmountWithInterest); // T:[CM-45]\\n        }\\n    }\\n\\n    /// @dev Transfers all assets from borrower credit account to \\\"to\\\" account and converts WETH => ETH if applicable\\n    /// @param creditAccount  Credit account address\\n    /// @param to Address to transfer all assets to\\n    function _transferAssetsTo(\\n        address creditAccount,\\n        address to,\\n        bool force\\n    ) internal returns (uint256 totalValue, uint256 totalWeightedValue) {\\n        uint256 tokenMask;\\n        uint256 enabledTokens = creditFilter.enabledTokens(creditAccount);\\n        require(to != address(0), Errors.ZERO_ADDRESS_IS_NOT_ALLOWED);\\n\\n        for (uint256 i = 0; i < creditFilter.allowedTokensCount(); i++) {\\n            tokenMask = 1 << i;\\n            if (enabledTokens & tokenMask > 0) {\\n                (\\n                    address token,\\n                    uint256 amount,\\n                    uint256 tv,\\n                    uint256 tvw\\n                ) = creditFilter.getCreditAccountTokenById(creditAccount, i); // T:[CM-14, 17, 22, 23]\\n                if (amount > 1) {\\n                    if (\\n                        _safeTokenTransfer(\\n                            creditAccount,\\n                            token,\\n                            to,\\n                            amount.sub(1), // Michael Egorov gas efficiency trick\\n                            force\\n                        )\\n                    ) {\\n                        totalValue = totalValue.add(tv); // T:[CM-14, 17, 22, 23]\\n                        totalWeightedValue = totalWeightedValue.add(tvw); // T:[CM-14, 17, 22, 23]\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Transfers token to particular address from credit account and converts WETH => ETH if applicable\\n    /// @param creditAccount Address of credit account\\n    /// @param token Token address\\n    /// @param to Address to transfer asset\\n    /// @param amount Amount to be transferred\\n    /// @param force If true it will skip reverts of safeTransfer function. Used for force liquidation if there is\\n    /// a blocked token on creditAccount\\n    /// @return true if transfer were successful otherwise false\\n    function _safeTokenTransfer(\\n        address creditAccount,\\n        address token,\\n        address to,\\n        uint256 amount,\\n        bool force\\n    ) internal returns (bool) {\\n        if (token != wethAddress) {\\n            try\\n                ICreditAccount(creditAccount).safeTransfer(token, to, amount) // T:[CM-14, 17]\\n            {} catch {\\n                require(force, Errors.CM_TRANSFER_FAILED); // T:[CM-50]\\n                return false;\\n            }\\n        } else {\\n            ICreditAccount(creditAccount).safeTransfer(\\n                token,\\n                wethGateway,\\n                amount\\n            ); // T:[CM-22, 23]\\n            IWETHGateway(wethGateway).unwrapWETH(to, amount); // T:[CM-22, 23]\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Increases borrowed amount by transferring additional funds from\\n    /// the pool if after that HealthFactor > minHealth\\n    /// More info: https://dev.gearbox.fi/developers/credit/credit_manager#increase-borrowed-amount\\n    ///\\n    /// @param amount Amount to increase borrowed amount\\n    function increaseBorrowedAmount(uint256 amount)\\n        external\\n        override\\n        whenNotPaused // T:[CM-39]\\n        nonReentrant\\n    {\\n        address creditAccount = getCreditAccountOrRevert(msg.sender); // T: [CM-9, 30]\\n\\n        (\\n            uint256 borrowedAmount,\\n            uint256 cumulativeIndexAtOpen\\n        ) = getCreditAccountParameters(creditAccount); // T:[CM-30]\\n\\n        //\\n        uint256 newBorrowedAmount = borrowedAmount.add(amount);\\n        uint256 newCumulativeIndex = IPoolService(poolService)\\n        .calcCumulativeIndexAtBorrowMore(\\n            borrowedAmount,\\n            amount,\\n            cumulativeIndexAtOpen\\n        ); // T:[CM-30]\\n\\n        require(\\n            newBorrowedAmount.mul(Constants.LEVERAGE_DECIMALS) <\\n                maxAmount.mul(maxLeverageFactor),\\n            Errors.CM_INCORRECT_AMOUNT\\n        ); // T:[CM-51]\\n\\n        //\\n        // Increase _totalBorrowed, it used to compute forecasted interest\\n        IPoolService(poolService).lendCreditAccount(amount, creditAccount); // T:[CM-29]\\n        //\\n        // Set parameters for new credit account\\n        ICreditAccount(creditAccount).updateParameters(\\n            newBorrowedAmount,\\n            newCumulativeIndex\\n        ); // T:[CM-30]\\n\\n        //\\n        creditFilter.revertIfCantIncreaseBorrowing(\\n            creditAccount,\\n            minHealthFactor\\n        ); // T:[CM-28]\\n\\n        emit IncreaseBorrowedAmount(msg.sender, amount); // T:[CM-29]\\n    }\\n\\n    /// @dev Adds collateral to borrower's credit account\\n    /// @param onBehalfOf Address of borrower to add funds\\n    /// @param token Token address\\n    /// @param amount Amount to add\\n    function addCollateral(\\n        address onBehalfOf,\\n        address token,\\n        uint256 amount\\n    )\\n        external\\n        override\\n        whenNotPaused // T:[CM-39]\\n        nonReentrant\\n    {\\n        address creditAccount = getCreditAccountOrRevert(onBehalfOf); // T: [CM-9]\\n        creditFilter.checkAndEnableToken(creditAccount, token); // T:[CM-48]\\n        IERC20(token).safeTransferFrom(msg.sender, creditAccount, amount); // T:[CM-48]\\n        emit AddCollateral(onBehalfOf, token, amount); // T: [CM-48]\\n    }\\n\\n    /// @dev Sets fees. Restricted for configurator role only\\n    /// @param _minAmount Minimum amount to open account\\n    /// @param _maxAmount Maximum amount to open account\\n    /// @param _maxLeverageFactor Maximum leverage factor\\n    /// @param _feeInterest Interest fee multiplier\\n    /// @param _feeLiquidation Liquidation fee multiplier (for totalValue)\\n    /// @param _liquidationDiscount Liquidation premium multiplier (= PERCENTAGE_FACTOR - premium)\\n    function setParams(\\n        uint256 _minAmount,\\n        uint256 _maxAmount,\\n        uint256 _maxLeverageFactor,\\n        uint256 _feeInterest,\\n        uint256 _feeLiquidation,\\n        uint256 _liquidationDiscount\\n    )\\n        public\\n        configuratorOnly // T:[CM-36]\\n    {\\n        _setParams(\\n            _minAmount,\\n            _maxAmount,\\n            _maxLeverageFactor,\\n            _feeInterest,\\n            _feeLiquidation,\\n            _liquidationDiscount\\n        );\\n    }\\n\\n    function _setParams(\\n        uint256 _minAmount,\\n        uint256 _maxAmount,\\n        uint256 _maxLeverageFactor,\\n        uint256 _feeInterest,\\n        uint256 _feeLiquidation,\\n        uint256 _liquidationDiscount\\n    ) internal {\\n        require(\\n            _minAmount <= _maxAmount && _maxLeverageFactor > 0,\\n            Errors.CM_INCORRECT_PARAMS\\n        ); // T:[CM-34]\\n\\n        minAmount = _minAmount; // T:[CM-32]\\n        maxAmount = _maxAmount; // T:[CM-32]\\n\\n        maxLeverageFactor = _maxLeverageFactor;\\n\\n        feeInterest = _feeInterest; // T:[CM-37]\\n        feeLiquidation = _feeLiquidation; // T:[CM-37]\\n        liquidationDiscount = _liquidationDiscount; // T:[CM-37]\\n\\n        // Compute minHealthFactor: https://dev.gearbox.fi/developers/credit/credit_manager#increase-borrow-amount\\n        // LT_U = liquidationDiscount - feeLiquidation\\n        minHealthFactor = liquidationDiscount\\n        .sub(feeLiquidation)\\n        .mul(maxLeverageFactor.add(Constants.LEVERAGE_DECIMALS))\\n        .div(maxLeverageFactor); // T:[CM-41]\\n\\n        if (address(creditFilter) != address(0)) {\\n            creditFilter.updateUnderlyingTokenLiquidationThreshold(); // T:[CM-49]\\n        }\\n\\n        emit NewParameters(\\n            minAmount,\\n            maxAmount,\\n            maxLeverageFactor,\\n            feeInterest,\\n            feeLiquidation,\\n            liquidationDiscount\\n        ); // T:[CM-37]\\n    }\\n\\n    /// @dev Approves credit account for 3rd party contract\\n    /// @param targetContract Contract to check allowance\\n    /// @param token Token address of contract\\n    function approve(address targetContract, address token)\\n        external\\n        override\\n        whenNotPaused // T:[CM-39]\\n        nonReentrant\\n    {\\n        address creditAccount = getCreditAccountOrRevert(msg.sender);\\n\\n        // Checks that targetContract is allowed - it has non-zero address adapter\\n        require(\\n            creditFilter.contractToAdapter(targetContract) != address(0),\\n            Errors.CM_TARGET_CONTRACT_iS_NOT_ALLOWED\\n        );\\n\\n        creditFilter.revertIfTokenNotAllowed(token); // ToDo: add test\\n        _provideCreditAccountAllowance(creditAccount, targetContract, token);\\n    }\\n\\n    /// @dev Approve tokens for credit accounts. Restricted for adapters only\\n    /// @param creditAccount Credit account address\\n    /// @param targetContract Contract to check allowance\\n    /// @param token Token address of contract\\n    function provideCreditAccountAllowance(\\n        address creditAccount,\\n        address targetContract,\\n        address token\\n    )\\n        external\\n        override\\n        allowedAdaptersOnly(targetContract) // T:[CM-46]\\n        whenNotPaused // T:[CM-39]\\n        nonReentrant\\n    {\\n        _provideCreditAccountAllowance(creditAccount, targetContract, token); // T:[CM-35]\\n    }\\n\\n    /// @dev Checks that credit account has enough allowance for operation by comparing existing one with x10 times more than needed\\n    /// @param creditAccount Credit account address\\n    /// @param toContract Contract to check allowance\\n    /// @param token Token address of contract\\n    function _provideCreditAccountAllowance(\\n        address creditAccount,\\n        address toContract,\\n        address token\\n    ) internal {\\n        // Get 10x reserve in allowance\\n        if (\\n            IERC20(token).allowance(creditAccount, toContract) <\\n            Constants.MAX_INT_4\\n        ) {\\n            ICreditAccount(creditAccount).approveToken(token, toContract); // T:[CM-35]\\n        }\\n    }\\n\\n    /// @dev Converts all assets to underlying one using uniswap V2 protocol\\n    /// @param creditAccount Credit Account address\\n    /// @param paths Exchange type data which provides paths + amountMinOut\\n    function _convertAllAssetsToUnderlying(\\n        address creditAccount,\\n        DataTypes.Exchange[] calldata paths\\n    ) internal {\\n        uint256 tokenMask;\\n        uint256 enabledTokens = creditFilter.enabledTokens(creditAccount); // T: [CM-44]\\n\\n        require(\\n            paths.length == creditFilter.allowedTokensCount(),\\n            Errors.INCORRECT_PATH_LENGTH\\n        ); // ToDo: check\\n\\n        for (uint256 i = 1; i < paths.length; i++) {\\n            tokenMask = 1 << i;\\n            if (enabledTokens & tokenMask > 0) {\\n                (address tokenAddr, uint256 amount, , ) = creditFilter\\n                .getCreditAccountTokenById(creditAccount, i); // T: [CM-44]\\n\\n                if (amount > 1) {\\n                    _provideCreditAccountAllowance(\\n                        creditAccount,\\n                        defaultSwapContract,\\n                        tokenAddr\\n                    ); // T: [CM-44]\\n\\n                    address[] memory currentPath = paths[i].path;\\n                    currentPath[0] = tokenAddr;\\n                    currentPath[paths[i].path.length - 1] = underlyingToken;\\n\\n                    bytes memory data = abi.encodeWithSelector(\\n                        bytes4(0x38ed1739), // \\\"swapExactTokensForTokens(uint256,uint256,address[],address,uint256)\\\",\\n                        amount.sub(1),\\n                        paths[i].amountOutMin, // T: [CM-45]\\n                        currentPath,\\n                        creditAccount,\\n                        block.timestamp\\n                    ); // T: [CM-44]\\n\\n                    ICreditAccount(creditAccount).execute(\\n                        defaultSwapContract,\\n                        data\\n                    ); // T: [CM-44]\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Executes filtered order on credit account which is connected with particular borrower\\n    /// @param borrower Borrower address\\n    /// @param target Target smart-contract\\n    /// @param data Call data for call\\n    function executeOrder(\\n        address borrower,\\n        address target,\\n        bytes memory data\\n    )\\n        external\\n        override\\n        allowedAdaptersOnly(target) // T:[CM-46]\\n        whenNotPaused // T:[CM-39]\\n        nonReentrant\\n        returns (bytes memory)\\n    {\\n        address creditAccount = getCreditAccountOrRevert(borrower); // T:[CM-9]\\n        emit ExecuteOrder(borrower, target);\\n        return ICreditAccount(creditAccount).execute(target, data); // : [CM-47]\\n    }\\n\\n    //\\n    // GETTERS\\n    //\\n\\n    /// @dev Returns true if the borrower has opened a credit account\\n    /// @param borrower Borrower account\\n    function hasOpenedCreditAccount(address borrower)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return creditAccounts[borrower] != address(0); // T:[CM-26]\\n    }\\n\\n    /// @dev Returns address of borrower's credit account and reverts of borrower has no one.\\n    /// @param borrower Borrower address\\n    function getCreditAccountOrRevert(address borrower)\\n        public\\n        view\\n        override\\n        returns (address)\\n    {\\n        address result = creditAccounts[borrower]; // T: [CM-9]\\n        require(result != address(0), Errors.CM_NO_OPEN_ACCOUNT); // T: [CM-9]\\n        return result;\\n    }\\n\\n    /// @dev Calculates repay / liquidation amount\\n    /// repay amount = borrow amount + interest accrued + fee amount\\n    ///\\n    /// More info: https://dev.gearbox.fi/developers/credit/economy#repay\\n    /// https://dev.gearbox.fi/developers/credit/economy#liquidate\\n    /// @param borrower Borrower address\\n    /// @param isLiquidated True if calculated repay amount for liquidator\\n    function calcRepayAmount(address borrower, bool isLiquidated)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        address creditAccount = getCreditAccountOrRevert(borrower);\\n        uint256 totalValue = creditFilter.calcTotalValue(creditAccount);\\n\\n        (\\n            ,\\n            uint256 amountToPool,\\n            uint256 remainingFunds,\\n            ,\\n\\n        ) = _calcClosePayments(creditAccount, totalValue, isLiquidated); // T:[CM-14, 17, 31]\\n\\n        return isLiquidated ? amountToPool.add(remainingFunds) : amountToPool; // T:[CM-14, 17, 31]\\n    }\\n\\n    /// @dev Gets credit account generic parameters\\n    /// @param creditAccount Credit account address\\n    /// @return borrowedAmount Amount which pool lent to credit account\\n    /// @return cumulativeIndexAtOpen Cumulative index at open. Used for interest calculation\\n    function getCreditAccountParameters(address creditAccount)\\n        internal\\n        view\\n        returns (uint256 borrowedAmount, uint256 cumulativeIndexAtOpen)\\n    {\\n        borrowedAmount = ICreditAccount(creditAccount).borrowedAmount();\\n        cumulativeIndexAtOpen = ICreditAccount(creditAccount)\\n        .cumulativeIndexAtOpen();\\n    }\\n\\n    /// @dev Transfers account ownership to another account\\n    /// @param newOwner Address of new owner\\n    function transferAccountOwnership(address newOwner)\\n        external\\n        override\\n        whenNotPaused // T: [CM-39]\\n        nonReentrant\\n    {\\n        address creditAccount = getCreditAccountOrRevert(msg.sender); // M:[LA-1,2,3,4,5,6,7,8] // T:[CM-52,53, 54]\\n        _checkAccountTransfer(newOwner);\\n        delete creditAccounts[msg.sender]; // T:[CM-54], M:[LA-1,2,3,4,5,6,7,8]\\n        creditAccounts[newOwner] = creditAccount; // T:[CM-54], M:[LA-1,2,3,4,5,6,7,8]\\n        emit TransferAccount(msg.sender, newOwner); // T:[CM-54]\\n    }\\n\\n    function _checkAccountTransfer(address newOwner) internal view {\\n        require(\\n            newOwner != address(0) && !hasOpenedCreditAccount(newOwner),\\n            Errors.CM_ZERO_ADDRESS_OR_USER_HAVE_ALREADY_OPEN_CREDIT_ACCOUNT\\n        ); // T:[CM-52,53]\\n        if (msg.sender != newOwner) {\\n            creditFilter.revertIfAccountTransferIsNotAllowed(\\n                msg.sender,\\n                newOwner\\n            ); // T:[54,55]\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/credit/CreditFilter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\npragma abicoder v2;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\nimport {PercentageMath} from \\\"../libraries/math/PercentageMath.sol\\\";\\n\\nimport {ICreditManager} from \\\"../interfaces/ICreditManager.sol\\\";\\nimport {ICreditAccount} from \\\"../interfaces/ICreditAccount.sol\\\";\\nimport {IPriceOracle} from \\\"../interfaces/IPriceOracle.sol\\\";\\nimport {ICreditFilter} from \\\"../interfaces/ICreditFilter.sol\\\";\\nimport {IPoolService} from \\\"../interfaces/IPoolService.sol\\\";\\n\\nimport {AddressProvider} from \\\"../core/AddressProvider.sol\\\";\\nimport {ACLTrait} from \\\"../core/ACLTrait.sol\\\";\\nimport {Constants} from \\\"../libraries/helpers/Constants.sol\\\";\\nimport {Errors} from \\\"../libraries/helpers/Errors.sol\\\";\\n\\n\\n/// @title CreditFilter\\n/// @notice Implements filter logic for allowed tokens & contract-adapters\\n///   - Sets/Gets tokens for allowed tokens list\\n///   - Sets/Gets adapters & allowed contracts\\n///   - Calculates total value for credit account\\n///   - Calculates threshold weighted value for credit account\\n///   - Keeps enabled tokens for credit accounts\\n///\\n/// More: https://dev.gearbox.fi/developers/credit/credit-filter\\ncontract CreditFilter is ICreditFilter, ACLTrait {\\n    using SafeMath for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    AddressProvider public addressProvider;\\n\\n    // Address of credit Manager\\n    address public creditManager;\\n\\n    // Allowed tokens list\\n    mapping(address => bool) public override isTokenAllowed;\\n\\n    // Allowed tokens array\\n    address[] public override allowedTokens;\\n\\n    // Allowed contracts list\\n    mapping(address => uint256) public override liquidationThresholds;\\n\\n    // map token address to its mask\\n    mapping(address => uint256) public tokenMasksMap;\\n\\n    // credit account token enables mask. each bit (in order as tokens stored in allowedTokens array) set 1 if token was enable\\n    mapping(address => uint256) public override enabledTokens;\\n\\n    // keeps last block we use fast check. Fast check is not allowed to use more than one time in block\\n    mapping(address => uint256) public fastCheckCounter;\\n\\n    // Allowed contracts array\\n    EnumerableSet.AddressSet private allowedContractsSet;\\n\\n    // Allowed adapters list\\n    mapping(address => bool) public allowedAdapters;\\n\\n    // Mapping from allowed contract to allowed adapters\\n    // If contract is not allowed, contractToAdapter[contract] == address(0)\\n    mapping(address => address) public override contractToAdapter;\\n\\n    // Price oracle - uses in evaluation credit account\\n    address public override priceOracle;\\n\\n    // Underlying token address\\n    address public override underlyingToken;\\n\\n    // Pooll Service address\\n    address public poolService;\\n\\n    // Address of WETH token\\n    address public wethAddress;\\n\\n    // Minimum chi threshold for fast check\\n    uint256 public chiThreshold;\\n\\n    // Maxmimum allowed fast check operations between full health factor checks\\n    uint256 public hfCheckInterval;\\n\\n    // Allowed transfers\\n    mapping(address => mapping(address => bool)) transfersAllowed;\\n\\n    // Allowed plugins\\n    mapping(address => bool) public allowedPlugins;\\n\\n    // Contract version\\n    uint256 public constant version = 1;\\n\\n    /// Checks that sender is connected credit manager\\n    modifier creditManagerOnly {\\n        require(msg.sender == creditManager, Errors.CF_CREDIT_MANAGERS_ONLY); // T:[CF-20]\\n        _;\\n    }\\n\\n    /// Checks that sender is adapter\\n    modifier adapterOnly {\\n        require(allowedAdapters[msg.sender], Errors.CF_ADAPTERS_ONLY); // T:[CF-20]\\n        _;\\n    }\\n\\n    constructor(address _addressProvider, address _underlyingToken)\\n        ACLTrait(_addressProvider)\\n    {\\n        require(\\n            _addressProvider != address(0) && _underlyingToken != address(0),\\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\\n        );\\n        addressProvider = AddressProvider(_addressProvider);\\n        priceOracle = addressProvider.getPriceOracle(); // T:[CF-21]\\n        wethAddress = addressProvider.getWethToken(); // T:[CF-21]\\n\\n        underlyingToken = _underlyingToken; // T:[CF-21]\\n\\n        liquidationThresholds[underlyingToken] = Constants\\n        .UNDERLYING_TOKEN_LIQUIDATION_THRESHOLD; // T:[CF-21]\\n\\n        _allowToken(\\n            underlyingToken,\\n            Constants.UNDERLYING_TOKEN_LIQUIDATION_THRESHOLD\\n        ); // T:[CF-8, 21]\\n\\n        _setFastCheckParameters(\\n            Constants.CHI_THRESHOLD,\\n            Constants.HF_CHECK_INTERVAL_DEFAULT\\n        ); // T:[CF-21]\\n\\n        allowedPlugins[addressProvider.getWETHGateway()] = true;\\n    }\\n\\n    //\\n    // STATE-CHANGING FUNCTIONS\\n    //\\n\\n    /// @dev Adds token to the list of allowed tokens\\n    /// @param token Address of allowed token\\n    /// @param liquidationThreshold The credit Manager constant showing the maximum allowable ratio of Loan-To-Value for the i-th asset.\\n    function allowToken(address token, uint256 liquidationThreshold)\\n        external\\n        override\\n        configuratorOnly // T:[CF-1]\\n    {\\n        _allowToken(token, liquidationThreshold);\\n    }\\n\\n    function _allowToken(address token, uint256 liquidationThreshold) internal {\\n        require(token != address(0), Errors.ZERO_ADDRESS_IS_NOT_ALLOWED); // T:[CF-2]\\n\\n        require(\\n            liquidationThreshold > 0 &&\\n                liquidationThreshold <= liquidationThresholds[underlyingToken],\\n            Errors.CF_INCORRECT_LIQUIDATION_THRESHOLD\\n        ); // T:[CF-3]\\n\\n        require(\\n            tokenMasksMap[token] > 0 || allowedTokens.length < 256,\\n            Errors.CF_TOO_MUCH_ALLOWED_TOKENS\\n        ); // T:[CF-5]\\n\\n        // Checks that contract has balanceOf method and it returns uint256\\n        require(IERC20(token).balanceOf(address(this)) >= 0); // T:[CF-11]\\n\\n        // Checks that pair token - underlyingToken has priceFeed\\n        require(\\n            IPriceOracle(priceOracle).getLastPrice(token, underlyingToken) > 0,\\n            Errors.CF_INCORRECT_PRICEFEED\\n        );\\n\\n        // we add allowed tokens to array if it wasn't added before\\n        // T:[CF-6] controls that\\n        if (!isTokenAllowed[token]) {\\n            isTokenAllowed[token] = true; // T:[CF-4]\\n            tokenMasksMap[token] = 1 << allowedTokens.length; // T:[CF-4]\\n            allowedTokens.push(token); // T:[CF-4]\\n        }\\n\\n        liquidationThresholds[token] = liquidationThreshold; // T:[CF-4, 6]\\n        emit TokenAllowed(token, liquidationThreshold); // T:[CF-4]\\n    }\\n\\n    /// @dev Forbid token. To allow token one more time use allowToken function\\n    /// @param token Address of forbidden token\\n    function forbidToken(address token)\\n        external\\n        configuratorOnly // T:[CF-1]\\n    {\\n        isTokenAllowed[token] = false; // T: [CF-35, 36]\\n        emit TokenForbidden(token);\\n    }\\n\\n    /// @dev Adds contract and adapter to the list of allowed contracts\\n    /// if contract exists it updates adapter only\\n    /// @param targetContract Address of allowed contract\\n    /// @param adapter Adapter contract address\\n    function allowContract(address targetContract, address adapter)\\n        external\\n        override\\n        configuratorOnly // T:[CF-1]\\n    {\\n        require(\\n            targetContract != address(0) && adapter != address(0),\\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\\n        ); // T:[CF-2]\\n\\n        require(\\n            allowedAdapters[adapter] == false,\\n            Errors.CF_ADAPTER_CAN_BE_USED_ONLY_ONCE\\n        ); // ToDo: add check\\n\\n        // Remove previous adapter from allowed list and set up new one\\n        allowedAdapters[contractToAdapter[targetContract]] = false; // T:[CF-10]\\n        allowedAdapters[adapter] = true; // T:[CF-9, 10]\\n\\n        allowedContractsSet.add(targetContract);\\n        contractToAdapter[targetContract] = adapter; // T:[CF-9, 10]\\n\\n        emit ContractAllowed(targetContract, adapter); // T:[CF-12]\\n    }\\n\\n    /// @dev Forbids contract to use with credit manager\\n    /// @param targetContract Address of contract to be forbidden\\n    function forbidContract(address targetContract)\\n        external\\n        override\\n        configuratorOnly // T:[CF-1]\\n    {\\n        require(\\n            targetContract != address(0),\\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\\n        ); // T:[CF-2]\\n\\n        require(\\n            allowedContractsSet.remove(targetContract),\\n            Errors.CF_CONTRACT_IS_NOT_IN_ALLOWED_LIST\\n        ); // T:[CF-31]\\n\\n        // Remove previous adapter from allowed list\\n        allowedAdapters[contractToAdapter[targetContract]] = false; // T:[CF-32]\\n\\n        // Sets adapter to address(0), which means to forbid it usage\\n        contractToAdapter[targetContract] = address(0); // T:[CF-32]\\n\\n        emit ContractForbidden(targetContract); // T:[CF-32]\\n    }\\n\\n    /// @dev Connects credit manager and checks that it has the same underlying token as pool\\n    function connectCreditManager(address _creditManager)\\n        external\\n        override\\n        configuratorOnly // T:[CF-1]\\n    {\\n        require(\\n            _creditManager != address(0),\\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\\n        );\\n\\n        require(\\n            creditManager == address(0),\\n            Errors.CF_CREDIT_MANAGER_IS_ALREADY_SET\\n        ); // T:[CF-9,13]\\n\\n        creditManager = _creditManager; // T:[CF-14]\\n        poolService = ICreditManager(_creditManager).poolService(); //  T:[CF-14]\\n\\n        require(\\n            IPoolService(poolService).underlyingToken() == underlyingToken,\\n            Errors.CF_UNDERLYING_TOKEN_FILTER_CONFLICT\\n        ); // T:[CF-16]\\n    }\\n\\n    function upgradePriceOracle() external configuratorOnly {\\n        priceOracle = addressProvider.getPriceOracle(); // ToDo:\\n        emit PriceOracleUpdated(priceOracle);\\n    }\\n\\n    /// @dev Checks the financial order and reverts if tokens aren't in list or collateral protection alerts\\n    /// @param creditAccount Address of credit account\\n    /// @param tokenIn Address of token In in swap operation\\n    /// @param tokenOut Address of token Out in swap operation\\n    /// @param amountIn Amount of tokens in\\n    /// @param amountOut Amount of tokens out\\n    function checkCollateralChange(\\n        address creditAccount,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOut\\n    )\\n        external\\n        override\\n        adapterOnly // T:[CF-20]\\n    {\\n        _checkAndEnableToken(creditAccount, tokenOut); // T:[CF-22]\\n\\n        // Convert to WETH is more gas efficient and doesn't make difference for ratio\\n        uint256 amountInCollateral = IPriceOracle(priceOracle).convert(\\n            amountIn,\\n            tokenIn,\\n            wethAddress\\n        ); // T:[CF-24]\\n\\n        // Convert to WETH is more gas efficient and doesn't make difference for ratio\\n        uint256 amountOutCollateral = IPriceOracle(priceOracle).convert(\\n            amountOut,\\n            tokenOut,\\n            wethAddress\\n        ); // T:[CF-24]\\n\\n        _checkCollateral(\\n            creditAccount,\\n            amountInCollateral,\\n            amountOutCollateral\\n        );\\n    }\\n\\n    /// @dev Checks collateral for operation which returns more than 1 token\\n    /// @param creditAccount Address of credit account\\n    /// @param tokenOut Addresses of returned tokens\\n    function checkMultiTokenCollateral(\\n        address creditAccount,\\n        uint256[] memory amountIn,\\n        uint256[] memory amountOut,\\n        address[] memory tokenIn,\\n        address[] memory tokenOut\\n    )\\n        external\\n        override\\n        adapterOnly // T:[CF-20]\\n    {\\n        // Convert to WETH is more gas efficient and doesn't make difference for ratio\\n        uint256 amountInCollateral;\\n        uint256 amountOutCollateral;\\n\\n        require(\\n            amountIn.length == tokenIn.length &&\\n                amountOut.length == tokenOut.length,\\n            Errors.INCORRECT_ARRAY_LENGTH\\n        );\\n\\n        for (uint256 i = 0; i < amountIn.length; i++) {\\n            amountInCollateral = amountInCollateral.add(\\n                IPriceOracle(priceOracle).convert(\\n                    amountIn[i],\\n                    tokenIn[i],\\n                    wethAddress\\n                )\\n            );\\n        }\\n\\n        for (uint256 i = 0; i < amountOut.length; i++) {\\n            _checkAndEnableToken(creditAccount, tokenOut[i]); // T: [CF-33]\\n            amountOutCollateral = amountOutCollateral.add(\\n                IPriceOracle(priceOracle).convert(\\n                    amountOut[i],\\n                    tokenOut[i],\\n                    wethAddress\\n                )\\n            );\\n        }\\n\\n        _checkCollateral(\\n            creditAccount,\\n            amountInCollateral,\\n            amountOutCollateral\\n        ); // T: [CF-33]\\n    }\\n\\n    /// @dev Checks health factor after operations\\n    /// @param creditAccount Address of credit account\\n    function _checkCollateral(\\n        address creditAccount,\\n        uint256 collateralIn,\\n        uint256 collateralOut\\n    ) internal {\\n        if (\\n            (collateralOut.mul(PercentageMath.PERCENTAGE_FACTOR) >\\n                collateralIn.mul(chiThreshold)) &&\\n            fastCheckCounter[creditAccount] <= hfCheckInterval\\n        ) {\\n            fastCheckCounter[creditAccount]++; // T:[CF-25, 33]\\n        } else {\\n            // Require Hf > 1\\n\\n            require(\\n                calcCreditAccountHealthFactor(creditAccount) >=\\n                    PercentageMath.PERCENTAGE_FACTOR,\\n                Errors.CF_OPERATION_LOW_HEALTH_FACTOR\\n            ); // T:[CF-25, 33, 34]\\n            fastCheckCounter[creditAccount] = 1; // T:[CF-34]\\n        }\\n    }\\n\\n    /// @dev Initializes enabled tokens\\n    function initEnabledTokens(address creditAccount)\\n        external\\n        override\\n        creditManagerOnly // T:[CF-20]\\n    {\\n        // at opening account underlying token is enabled only\\n        enabledTokens[creditAccount] = 1; // T:[CF-19]\\n        fastCheckCounter[creditAccount] = 1; // T:[CF-19]\\n    }\\n\\n    /// @dev Checks that token is in allowed list and updates enabledTokenMask\\n    /// for provided credit account if needed\\n    /// @param creditAccount Address of credit account\\n    /// @param token Address of token to be checked\\n    function checkAndEnableToken(address creditAccount, address token)\\n        external\\n        override\\n        creditManagerOnly // T:[CF-20]\\n    {\\n        _checkAndEnableToken(creditAccount, token); // T:[CF-22, 23]\\n    }\\n\\n    /// @dev Checks that token is in allowed list and updates enabledTokenMask\\n    /// for provided credit account if needed\\n    /// @param creditAccount Address of credit account\\n    /// @param token Address of token to be checked\\n    function _checkAndEnableToken(address creditAccount, address token)\\n        internal\\n    {\\n        revertIfTokenNotAllowed(token); //T:[CF-22, 36]\\n\\n        if (enabledTokens[creditAccount] & tokenMasksMap[token] == 0) {\\n            enabledTokens[creditAccount] =\\n                enabledTokens[creditAccount] |\\n                tokenMasksMap[token];\\n        } // T:[CF-23]\\n    }\\n\\n    /// @dev Sets fast check parameters chi & hfCheckCollateral\\n    /// It reverts if 1 - chi ** hfCheckCollateral > feeLiquidation\\n    function setFastCheckParameters(\\n        uint256 _chiThreshold,\\n        uint256 _hfCheckInterval\\n    )\\n        external\\n        configuratorOnly // T:[CF-1]\\n    {\\n        _setFastCheckParameters(_chiThreshold, _hfCheckInterval);\\n    }\\n\\n    function _setFastCheckParameters(\\n        uint256 _chiThreshold,\\n        uint256 _hfCheckInterval\\n    ) internal {\\n        chiThreshold = _chiThreshold; // T:[CF-30]\\n        hfCheckInterval = _hfCheckInterval; // T:[CF-30]\\n\\n        revertIfIncorrectFastCheckParams();\\n\\n        emit NewFastCheckParameters(_chiThreshold, _hfCheckInterval); // T:[CF-30]\\n    }\\n\\n    /// @dev It updates liquidation threshold for underlying token threshold\\n    /// to have enough buffer for liquidation (liquidaion premium + fee liq.)\\n    /// It reverts if that buffer is less with new paremters, or there is any\\n    /// liquidaiton threshold > new LT\\n    function updateUnderlyingTokenLiquidationThreshold()\\n        external\\n        override\\n        creditManagerOnly // T:[CF-20]\\n    {\\n        require(\\n            ICreditManager(creditManager).feeInterest() <\\n                PercentageMath.PERCENTAGE_FACTOR &&\\n                ICreditManager(creditManager).feeLiquidation() <\\n                PercentageMath.PERCENTAGE_FACTOR &&\\n                ICreditManager(creditManager).liquidationDiscount() <\\n                PercentageMath.PERCENTAGE_FACTOR,\\n            Errors.CM_INCORRECT_FEES\\n        ); // T:[CM-36]\\n\\n        // Otherwise, new credit account will be immediately liquidated\\n        require(\\n            ICreditManager(creditManager).minHealthFactor() >\\n                PercentageMath.PERCENTAGE_FACTOR,\\n            Errors.CM_MAX_LEVERAGE_IS_TOO_HIGH\\n        ); // T:[CM-40]\\n\\n        liquidationThresholds[underlyingToken] = ICreditManager(creditManager)\\n        .liquidationDiscount()\\n        .sub(ICreditManager(creditManager).feeLiquidation()); // T:[CF-38]\\n\\n        for (uint256 i = 1; i < allowedTokens.length; i++) {\\n            require(\\n                liquidationThresholds[allowedTokens[i]] <=\\n                    liquidationThresholds[underlyingToken],\\n                Errors.CF_SOME_LIQUIDATION_THRESHOLD_MORE_THAN_NEW_ONE\\n            ); // T:[CF-39]\\n        }\\n\\n        revertIfIncorrectFastCheckParams(); // T:[CF-39]\\n    }\\n\\n    /// @dev It checks that 1 - chi ** hfCheckInterval < feeLiquidation\\n    function revertIfIncorrectFastCheckParams() internal view {\\n        // if credit manager is set, we add additional check\\n        if (creditManager != address(0)) {\\n            // computes maximum possible collateral drop between two health factor checks\\n            uint256 maxPossibleDrop = PercentageMath.PERCENTAGE_FACTOR.sub(\\n                calcMaxPossibleDrop(chiThreshold, hfCheckInterval)\\n            ); // T:[CF-39]\\n\\n            require(\\n                maxPossibleDrop <\\n                    ICreditManager(creditManager).feeLiquidation(),\\n                Errors.CF_FAST_CHECK_NOT_COVERED_COLLATERAL_DROP\\n            ); // T:[CF-39]\\n        }\\n    }\\n\\n    // @dev it computes percentage ** times\\n    // @param percentage Percentage in PERCENTAGE FACTOR format\\n    function calcMaxPossibleDrop(uint256 percentage, uint256 times)\\n        public\\n        pure\\n        returns (uint256 value)\\n    {\\n        value = PercentageMath.PERCENTAGE_FACTOR.mul(percentage); // T:[CF-37]\\n        for (uint256 i = 0; i < times.sub(1); i++) {\\n            value = value.mul(percentage).div(PercentageMath.PERCENTAGE_FACTOR); // T:[CF-37]\\n        }\\n        value = value.div(PercentageMath.PERCENTAGE_FACTOR); // T:[CF-37]\\n    }\\n\\n    //\\n    // GETTERS\\n    //\\n\\n    /// @dev Calculates total value for provided address\\n    /// More: https://dev.gearbox.fi/developers/credit/economy#total-value\\n    ///\\n    /// @param creditAccount Token creditAccount address\\n    function calcTotalValue(address creditAccount)\\n        external\\n        view\\n        override\\n        returns (uint256 total)\\n    {\\n        uint256 tokenMask;\\n        uint256 eTokens = enabledTokens[creditAccount];\\n        for (uint256 i = 0; i < allowedTokens.length; i++) {\\n            tokenMask = 1 << i; // T:[CF-17]\\n            if (eTokens & tokenMask > 0) {\\n                (, , uint256 tv, ) = getCreditAccountTokenById(\\n                    creditAccount,\\n                    i\\n                );\\n                total = total.add(tv);\\n            } // T:[CF-17]\\n        }\\n    }\\n\\n    /// @dev Calculates Threshold Weighted Total Value\\n    /// More: https://dev.gearbox.fi/developers/credit/economy#threshold-weighted-value\\n    ///\\n    /// @param creditAccount Credit account address\\n    function calcThresholdWeightedValue(address creditAccount)\\n        public\\n        view\\n        override\\n        returns (uint256 total)\\n    {\\n        uint256 tokenMask;\\n        uint256 eTokens = enabledTokens[creditAccount];\\n        for (uint256 i = 0; i < allowedTokens.length; i++) {\\n            tokenMask = 1 << i; // T:[CF-18]\\n            if (eTokens & tokenMask > 0) {\\n                (, , , uint256 twv) = getCreditAccountTokenById(\\n                    creditAccount,\\n                    i\\n                );\\n                total = total.add(twv);\\n            }\\n        } // T:[CF-18]\\n        return total.div(PercentageMath.PERCENTAGE_FACTOR); // T:[CF-18]\\n    }\\n\\n    /// @dev Returns quantity of tokens in allowed list\\n    function allowedTokensCount() external view override returns (uint256) {\\n        return allowedTokens.length; // T:[CF-4, 6]\\n    }\\n\\n    /// @dev Reverts if token isn't in token allowed list\\n    function revertIfTokenNotAllowed(address token) public view override {\\n        require(isTokenAllowed[token], Errors.CF_TOKEN_IS_NOT_ALLOWED); // T:[CF-7, 36]\\n    }\\n\\n    /// @dev Returns quantity of contracts in allowed list\\n    function allowedContractsCount() external view override returns (uint256) {\\n        return allowedContractsSet.length(); // T:[CF-9]\\n    }\\n\\n    /// @dev Returns allowed contract by index\\n    function allowedContracts(uint256 i)\\n        external\\n        view\\n        override\\n        returns (address)\\n    {\\n        return allowedContractsSet.at(i); // T:[CF-9]\\n    }\\n\\n    /// @dev Returns address & balance of token by the id of allowed token in the list\\n    /// @param creditAccount Credit account address\\n    /// @param id Id of token in allowed list\\n    /// @return token Address of token\\n    /// @return balance Token balance\\n    /// @return tv Balance converted to undelying asset using price oracle\\n    /// @return tvw Balance converted to undelying asset using price oracle multipled with liquidation threshold\\n    function getCreditAccountTokenById(address creditAccount, uint256 id)\\n        public\\n        view\\n        override\\n        returns (\\n            address token,\\n            uint256 balance,\\n            uint256 tv,\\n            uint256 tvw\\n        )\\n    {\\n        token = allowedTokens[id]; // T:[CF-28]\\n        balance = IERC20(token).balanceOf(creditAccount); // T:[CF-28]\\n\\n        // balance ==0 : T: [CF-28]\\n        if (balance > 1) {\\n            tv = IPriceOracle(priceOracle).convert(\\n                balance,\\n                token,\\n                underlyingToken\\n            ); // T:[CF-28]\\n            tvw = tv.mul(liquidationThresholds[token]); // T:[CF-28]\\n        }\\n    }\\n\\n    /// @dev Calculates credit account interest accrued\\n    /// More: https://dev.gearbox.fi/developers/credit/economy#interest-rate-accrued\\n    ///\\n    /// @param creditAccount Credit account address\\n    function calcCreditAccountAccruedInterest(address creditAccount)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return\\n            ICreditAccount(creditAccount)\\n                .borrowedAmount()\\n                .mul(IPoolService(poolService).calcLinearCumulative_RAY())\\n                .div(ICreditAccount(creditAccount).cumulativeIndexAtOpen()); // T: [CF-26]\\n    }\\n\\n    /**\\n     * @dev Calculates health factor for the credit account\\n     *\\n     *         sum(asset[i] * liquidation threshold[i])\\n     *   Hf = --------------------------------------------\\n     *             borrowed amount + interest accrued\\n     *\\n     *\\n     * More info: https://dev.gearbox.fi/developers/credit/economy#health-factor\\n     *\\n     * @param creditAccount Credit account address\\n     * @return Health factor in percents (see PERCENTAGE FACTOR in PercentageMath.sol)\\n     */\\n    function calcCreditAccountHealthFactor(address creditAccount)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return\\n            calcThresholdWeightedValue(creditAccount)\\n                .mul(PercentageMath.PERCENTAGE_FACTOR)\\n                .div(calcCreditAccountAccruedInterest(creditAccount)); // T:[CF-27]\\n    }\\n\\n    function revertIfCantIncreaseBorrowing(\\n        address creditAccount,\\n        uint256 minHealthFactor\\n    ) external view override {\\n        require(\\n            calcCreditAccountHealthFactor(creditAccount) >= minHealthFactor,\\n            Errors.CM_CAN_UPDATE_WITH_SUCH_HEALTH_FACTOR\\n        ); // T:[CM-28]\\n    }\\n\\n    function approveAccountTransfers(address from, bool state)\\n        external\\n        override\\n    {\\n        transfersAllowed[from][msg.sender] = state; // T:[CF-43]\\n        emit TransferAccountAllowed(from, msg.sender, state); // T:[CF-43]\\n    }\\n\\n    function allowanceForAccountTransfers(address from, address to)\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return transfersAllowed[from][to]; // T:[CF-43]\\n    }\\n\\n    function allowPlugin(address plugin, bool state) external configuratorOnly {\\n        allowedPlugins[plugin] = state;\\n        emit TransferPluginAllowed(plugin, state);\\n    }\\n\\n    function revertIfAccountTransferIsNotAllowed(\\n        address owner,\\n        address newOwner\\n    ) external view override {\\n        if (!allowedPlugins[owner] || allowedPlugins[newOwner]) {\\n            require(\\n                transfersAllowed[owner][newOwner],\\n                Errors.CF_TRANSFER_IS_NOT_ALLOWED\\n            ); // T:[CF-43, 44]\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/helpers/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\nimport {PercentageMath} from \\\"../math/PercentageMath.sol\\\";\\n\\nlibrary Constants {\\n    uint256 constant MAX_INT =\\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    // 25% of MAX_INT\\n    uint256 constant MAX_INT_4 =\\n        0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n\\n    // REWARD FOR LEAN DEPLOYMENT MINING\\n    uint256 constant ACCOUNT_CREATION_REWARD = 1e5;\\n    uint256 constant DEPLOYMENT_COST = 1e17;\\n\\n    // FEE = 10%\\n    uint256 constant FEE_INTEREST = 1000; // 10%\\n\\n    // FEE + LIQUIDATION_FEE 2%\\n    uint256 constant FEE_LIQUIDATION = 200;\\n\\n    // Liquidation premium 5%\\n    uint256 constant LIQUIDATION_DISCOUNTED_SUM = 9500;\\n\\n    // 100% - LIQUIDATION_FEE - LIQUIDATION_PREMIUM\\n    uint256 constant UNDERLYING_TOKEN_LIQUIDATION_THRESHOLD =\\n        LIQUIDATION_DISCOUNTED_SUM - FEE_LIQUIDATION;\\n\\n    // Seconds in a year\\n    uint256 constant SECONDS_PER_YEAR = 365 days;\\n    uint256 constant SECONDS_PER_ONE_AND_HALF_YEAR = SECONDS_PER_YEAR * 3 /2;\\n\\n    // 1e18\\n    uint256 constant RAY = 1e27;\\n    uint256 constant WAD = 1e18;\\n\\n    // OPERATIONS\\n    uint8 constant OPERATION_CLOSURE = 1;\\n    uint8 constant OPERATION_REPAY = 2;\\n    uint8 constant OPERATION_LIQUIDATION = 3;\\n\\n    // Decimals for leverage, so x4 = 4*LEVERAGE_DECIMALS for openCreditAccount function\\n    uint8 constant LEVERAGE_DECIMALS = 100;\\n\\n    // Maximum withdraw fee for pool in percentage math format. 100 = 1%\\n    uint8 constant MAX_WITHDRAW_FEE = 100;\\n\\n    uint256 constant CHI_THRESHOLD = 9950;\\n    uint256 constant HF_CHECK_INTERVAL_DEFAULT = 4;\\n\\n    uint256 constant NO_SWAP = 0;\\n    uint256 constant UNISWAP_V2 = 1;\\n    uint256 constant UNISWAP_V3 = 2;\\n    uint256 constant CURVE_V1 = 3;\\n    uint256 constant LP_YEARN = 4;\\n\\n    uint256 constant EXACT_INPUT = 1;\\n    uint256 constant EXACT_OUTPUT = 2;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/helpers/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\n\\n/// @title Errors library\\nlibrary Errors {\\n    //\\n    // COMMON\\n    //\\n\\n    string public constant ZERO_ADDRESS_IS_NOT_ALLOWED = \\\"Z0\\\";\\n    string public constant NOT_IMPLEMENTED = \\\"NI\\\";\\n    string public constant INCORRECT_PATH_LENGTH = \\\"PL\\\";\\n    string public constant INCORRECT_ARRAY_LENGTH = \\\"CR\\\";\\n    string public constant REGISTERED_CREDIT_ACCOUNT_MANAGERS_ONLY = \\\"CP\\\";\\n    string public constant REGISTERED_POOLS_ONLY = \\\"RP\\\";\\n    string public constant INCORRECT_PARAMETER = \\\"IP\\\";\\n\\n    //\\n    // MATH\\n    //\\n\\n    string public constant MATH_MULTIPLICATION_OVERFLOW = \\\"M1\\\";\\n    string public constant MATH_ADDITION_OVERFLOW = \\\"M2\\\";\\n    string public constant MATH_DIVISION_BY_ZERO = \\\"M3\\\";\\n\\n    //\\n    // POOL\\n    //\\n\\n    string public constant POOL_CONNECTED_CREDIT_MANAGERS_ONLY = \\\"PS0\\\";\\n    string public constant POOL_INCOMPATIBLE_CREDIT_ACCOUNT_MANAGER = \\\"PS1\\\";\\n    string public constant POOL_MORE_THAN_EXPECTED_LIQUIDITY_LIMIT = \\\"PS2\\\";\\n    string public constant POOL_INCORRECT_WITHDRAW_FEE = \\\"PS3\\\";\\n    string public constant POOL_CANT_ADD_CREDIT_MANAGER_TWICE = \\\"PS4\\\";\\n\\n    //\\n    // CREDIT MANAGER\\n    //\\n\\n    string public constant CM_NO_OPEN_ACCOUNT = \\\"CM1\\\";\\n    string\\n        public constant CM_ZERO_ADDRESS_OR_USER_HAVE_ALREADY_OPEN_CREDIT_ACCOUNT =\\n        \\\"CM2\\\";\\n\\n    string public constant CM_INCORRECT_AMOUNT = \\\"CM3\\\";\\n    string public constant CM_CAN_LIQUIDATE_WITH_SUCH_HEALTH_FACTOR = \\\"CM4\\\";\\n    string public constant CM_CAN_UPDATE_WITH_SUCH_HEALTH_FACTOR = \\\"CM5\\\";\\n    string public constant CM_WETH_GATEWAY_ONLY = \\\"CM6\\\";\\n    string public constant CM_INCORRECT_PARAMS = \\\"CM7\\\";\\n    string public constant CM_INCORRECT_FEES = \\\"CM8\\\";\\n    string public constant CM_MAX_LEVERAGE_IS_TOO_HIGH = \\\"CM9\\\";\\n    string public constant CM_CANT_CLOSE_WITH_LOSS = \\\"CMA\\\";\\n    string public constant CM_TARGET_CONTRACT_iS_NOT_ALLOWED = \\\"CMB\\\";\\n    string public constant CM_TRANSFER_FAILED = \\\"CMC\\\";\\n    string public constant CM_INCORRECT_NEW_OWNER = \\\"CME\\\";\\n\\n    //\\n    // ACCOUNT FACTORY\\n    //\\n\\n    string public constant AF_CANT_CLOSE_CREDIT_ACCOUNT_IN_THE_SAME_BLOCK =\\n        \\\"AF1\\\";\\n    string public constant AF_MINING_IS_FINISHED = \\\"AF2\\\";\\n    string public constant AF_CREDIT_ACCOUNT_NOT_IN_STOCK = \\\"AF3\\\";\\n    string public constant AF_EXTERNAL_ACCOUNTS_ARE_FORBIDDEN = \\\"AF4\\\";\\n\\n    //\\n    // ADDRESS PROVIDER\\n    //\\n\\n    string public constant AS_ADDRESS_NOT_FOUND = \\\"AP1\\\";\\n\\n    //\\n    // CONTRACTS REGISTER\\n    //\\n\\n    string public constant CR_POOL_ALREADY_ADDED = \\\"CR1\\\";\\n    string public constant CR_CREDIT_MANAGER_ALREADY_ADDED = \\\"CR2\\\";\\n\\n    //\\n    // CREDIT_FILTER\\n    //\\n\\n    string public constant CF_UNDERLYING_TOKEN_FILTER_CONFLICT = \\\"CF0\\\";\\n    string public constant CF_INCORRECT_LIQUIDATION_THRESHOLD = \\\"CF1\\\";\\n    string public constant CF_TOKEN_IS_NOT_ALLOWED = \\\"CF2\\\";\\n    string public constant CF_CREDIT_MANAGERS_ONLY = \\\"CF3\\\";\\n    string public constant CF_ADAPTERS_ONLY = \\\"CF4\\\";\\n    string public constant CF_OPERATION_LOW_HEALTH_FACTOR = \\\"CF5\\\";\\n    string public constant CF_TOO_MUCH_ALLOWED_TOKENS = \\\"CF6\\\";\\n    string public constant CF_INCORRECT_CHI_THRESHOLD = \\\"CF7\\\";\\n    string public constant CF_INCORRECT_FAST_CHECK = \\\"CF8\\\";\\n    string public constant CF_NON_TOKEN_CONTRACT = \\\"CF9\\\";\\n    string public constant CF_CONTRACT_IS_NOT_IN_ALLOWED_LIST = \\\"CFA\\\";\\n    string public constant CF_FAST_CHECK_NOT_COVERED_COLLATERAL_DROP = \\\"CFB\\\";\\n    string public constant CF_SOME_LIQUIDATION_THRESHOLD_MORE_THAN_NEW_ONE =\\n        \\\"CFC\\\";\\n    string public constant CF_ADAPTER_CAN_BE_USED_ONLY_ONCE = \\\"CFD\\\";\\n    string public constant CF_INCORRECT_PRICEFEED = \\\"CFE\\\";\\n    string public constant CF_TRANSFER_IS_NOT_ALLOWED = \\\"CFF\\\";\\n    string public constant CF_CREDIT_MANAGER_IS_ALREADY_SET = \\\"CFG\\\";\\n\\n    //\\n    // CREDIT ACCOUNT\\n    //\\n\\n    string public constant CA_CONNECTED_CREDIT_MANAGER_ONLY = \\\"CA1\\\";\\n    string public constant CA_FACTORY_ONLY = \\\"CA2\\\";\\n\\n    //\\n    // PRICE ORACLE\\n    //\\n\\n    string public constant PO_PRICE_FEED_DOESNT_EXIST = \\\"PO0\\\";\\n    string public constant PO_TOKENS_WITH_DECIMALS_MORE_18_ISNT_ALLOWED = \\\"PO1\\\";\\n    string public constant PO_AGGREGATOR_DECIMALS_SHOULD_BE_18 = \\\"PO2\\\";\\n\\n    //\\n    // ACL\\n    //\\n\\n    string public constant ACL_CALLER_NOT_PAUSABLE_ADMIN = \\\"ACL1\\\";\\n    string public constant ACL_CALLER_NOT_CONFIGURATOR = \\\"ACL2\\\";\\n\\n    //\\n    // WETH GATEWAY\\n    //\\n\\n    string public constant WG_DESTINATION_IS_NOT_WETH_COMPATIBLE = \\\"WG1\\\";\\n    string public constant WG_RECEIVE_IS_NOT_ALLOWED = \\\"WG2\\\";\\n    string public constant WG_NOT_ENOUGH_FUNDS = \\\"WG3\\\";\\n\\n    //\\n    // LEVERAGED ACTIONS\\n    //\\n\\n    string public constant LA_INCORRECT_VALUE = \\\"LA1\\\";\\n    string public constant LA_HAS_VALUE_WITH_TOKEN_TRANSFER = \\\"LA2\\\";\\n    string public constant LA_UNKNOWN_SWAP_INTERFACE = \\\"LA3\\\";\\n    string public constant LA_UNKNOWN_LP_INTERFACE = \\\"LA4\\\";\\n    string public constant LA_LOWER_THAN_AMOUNT_MIN = \\\"LA5\\\";\\n    string public constant LA_TOKEN_OUT_IS_NOT_COLLATERAL = \\\"LA6\\\";\\n\\n    //\\n    // YEARN PRICE FEED\\n    //\\n    string public constant YPF_PRICE_PER_SHARE_OUT_OF_RANGE = \\\"YP1\\\";\\n    string public constant YPF_INCORRECT_LIMITER_PARAMETERS = \\\"YP2\\\";\\n\\n    //\\n    // TOKEN DISTRIBUTOR\\n    //\\n    string public constant TD_WALLET_IS_ALREADY_CONNECTED_TO_VC = \\\"TD1\\\";\\n    string public constant TD_INCORRECT_WEIGHTS = \\\"TD2\\\";\\n    string public constant TD_NON_ZERO_BALANCE_AFTER_DISTRIBUTION = \\\"TD3\\\";\\n    string public constant TD_CONTRIBUTOR_IS_NOT_REGISTERED = \\\"TD4\\\";\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/app/IAppAddressProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\n\\n/// @title Optimised for front-end Address Provider interface\\ninterface IAppAddressProvider {\\n    function getDataCompressor() external view returns (address);\\n\\n    function getGearToken() external view returns (address);\\n\\n    function getWethToken() external view returns (address);\\n\\n    function getWETHGateway() external view returns (address);\\n\\n    function getPriceOracle() external view returns (address);\\n\\n    function getLeveragedActions() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/core/ACLTrait.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\nimport {Pausable} from \\\"@openzeppelin/contracts/utils/Pausable.sol\\\";\\nimport {AddressProvider} from \\\"./AddressProvider.sol\\\";\\nimport {ACL} from \\\"./ACL.sol\\\";\\nimport {Errors} from \\\"../libraries/helpers/Errors.sol\\\";\\n\\n\\n/// @title ACL Trait\\n/// @notice Trait which adds acl functions to contract\\nabstract contract ACLTrait is Pausable {\\n    // ACL contract to check rights\\n    ACL private _acl;\\n\\n    /// @dev constructor\\n    /// @param addressProvider Address of address repository\\n    constructor(address addressProvider) {\\n        require(\\n            addressProvider != address(0),\\n            Errors.ZERO_ADDRESS_IS_NOT_ALLOWED\\n        );\\n\\n        _acl = ACL(AddressProvider(addressProvider).getACL());\\n    }\\n\\n    /// @dev  Reverts if msg.sender is not configurator\\n    modifier configuratorOnly() {\\n        require(\\n            _acl.isConfigurator(msg.sender),\\n            Errors.ACL_CALLER_NOT_CONFIGURATOR\\n        ); // T:[ACLT-8]\\n        _;\\n    }\\n\\n    ///@dev Pause contract\\n    function pause() external {\\n        require(\\n            _acl.isPausableAdmin(msg.sender),\\n            Errors.ACL_CALLER_NOT_PAUSABLE_ADMIN\\n        ); // T:[ACLT-1]\\n        _pause();\\n    }\\n\\n    /// @dev Unpause contract\\n    function unpause() external {\\n        require(\\n            _acl.isUnpausableAdmin(msg.sender),\\n            Errors.ACL_CALLER_NOT_PAUSABLE_ADMIN\\n        ); // T:[ACLT-1],[ACLT-2]\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor () internal {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/math/PercentageMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.7.4;\\n\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\n\\n/**\\n * @title PercentageMath library\\n * @author Aave\\n * @notice Provides functions to perform percentage calculations\\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\\n * @dev Operations are rounded half up\\n **/\\n\\nlibrary PercentageMath {\\n    uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\\n    uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\\n\\n    /**\\n     * @dev Executes a percentage multiplication\\n     * @param value The value of which the percentage needs to be calculated\\n     * @param percentage The percentage of the value to be calculated\\n     * @return The percentage of value\\n     **/\\n    function percentMul(uint256 value, uint256 percentage)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (value == 0 || percentage == 0) {\\n            return 0; // T:[PM-1]\\n        }\\n\\n        require(\\n            value <= (type(uint256).max - HALF_PERCENT) / percentage,\\n            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        ); // T:[PM-1]\\n\\n        return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR; // T:[PM-1]\\n    }\\n\\n    /**\\n     * @dev Executes a percentage division\\n     * @param value The value of which the percentage needs to be calculated\\n     * @param percentage The percentage of the value to be calculated\\n     * @return The value divided the percentage\\n     **/\\n    function percentDiv(uint256 value, uint256 percentage)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO); // T:[PM-2]\\n        uint256 halfPercentage = percentage / 2; // T:[PM-2]\\n\\n        require(\\n            value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR,\\n            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        ); // T:[PM-2]\\n\\n        return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/math/WadRayMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.7.4;\\n\\n\\nimport {Errors} from \\\"../helpers/Errors.sol\\\";\\n\\n/**\\n * @title WadRayMath library\\n * @author Aave\\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\\n * More info https://github.com/aave/aave-protocol/blob/master/contracts/libraries/WadRayMath.sol\\n */\\n\\nlibrary WadRayMath {\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant halfWAD = WAD / 2;\\n\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant halfRAY = RAY / 2;\\n\\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\\n\\n    /**\\n     * @return One ray, 1e27\\n     */\\n    function ray() internal pure returns (uint256) {\\n        return RAY; // T:[WRM-1]\\n    }\\n\\n    /**\\n     * @return One wad, 1e18\\n     */\\n\\n    function wad() internal pure returns (uint256) {\\n        return WAD; // T:[WRM-1]\\n    }\\n\\n    /**\\n     * @return Half ray, 1e27/2\\n     */\\n    function halfRay() internal pure returns (uint256) {\\n        return halfRAY; // T:[WRM-2]\\n    }\\n\\n    /**\\n     * @return Half ray, 1e18/2\\n     */\\n    function halfWad() internal pure returns (uint256) {\\n        return halfWAD; // T:[WRM-2]\\n    }\\n\\n    /**\\n     * @dev Multiplies two wad, rounding half up to the nearest wad\\n     * @param a Wad\\n     * @param b Wad\\n     * @return The result of a*b, in wad\\n     */\\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0 || b == 0) {\\n            return 0; // T:[WRM-3]\\n        }\\n\\n        require(\\n            a <= (type(uint256).max - halfWAD) / b,\\n            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        ); // T:[WRM-3]\\n\\n        return (a * b + halfWAD) / WAD; // T:[WRM-3]\\n    }\\n\\n    /**\\n     * @dev Divides two wad, rounding half up to the nearest wad\\n     * @param a Wad\\n     * @param b Wad\\n     * @return The result of a/b, in wad\\n     */\\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, Errors.MATH_DIVISION_BY_ZERO); // T:[WRM-4]\\n        uint256 halfB = b / 2;\\n\\n        require(\\n            a <= (type(uint256).max - halfB) / WAD,\\n            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        ); // T:[WRM-4]\\n\\n        return (a * WAD + halfB) / b; // T:[WRM-4]\\n    }\\n\\n    /**\\n     * @dev Multiplies two ray, rounding half up to the nearest ray\\n     * @param a Ray\\n     * @param b Ray\\n     * @return The result of a*b, in ray\\n     */\\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0 || b == 0) {\\n            return 0; // T:[WRM-5]\\n        }\\n\\n        require(\\n            a <= (type(uint256).max - halfRAY) / b,\\n            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        ); // T:[WRM-5]\\n\\n        return (a * b + halfRAY) / RAY; // T:[WRM-5]\\n    }\\n\\n    /**\\n     * @dev Divides two ray, rounding half up to the nearest ray\\n     * @param a Ray\\n     * @param b Ray\\n     * @return The result of a/b, in ray\\n     */\\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, Errors.MATH_DIVISION_BY_ZERO); // T:[WRM-6]\\n        uint256 halfB = b / 2; // T:[WRM-6]\\n\\n        require(\\n            a <= (type(uint256).max - halfB) / RAY,\\n            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        ); // T:[WRM-6]\\n\\n        return (a * RAY + halfB) / b; // T:[WRM-6]\\n    }\\n\\n    /**\\n     * @dev Casts ray down to wad\\n     * @param a Ray\\n     * @return a casted to wad, rounded half up to the nearest wad\\n     */\\n    function rayToWad(uint256 a) internal pure returns (uint256) {\\n        uint256 halfRatio = WAD_RAY_RATIO / 2; // T:[WRM-7]\\n        uint256 result = halfRatio + a; // T:[WRM-7]\\n        require(result >= halfRatio, Errors.MATH_ADDITION_OVERFLOW); // T:[WRM-7]\\n\\n        return result / WAD_RAY_RATIO; // T:[WRM-7]\\n    }\\n\\n    /**\\n     * @dev Converts wad up to ray\\n     * @param a Wad\\n     * @return a converted in ray\\n     */\\n    function wadToRay(uint256 a) internal pure returns (uint256) {\\n        uint256 result = a * WAD_RAY_RATIO; // T:[WRM-8]\\n        require(\\n            result / WAD_RAY_RATIO == a,\\n            Errors.MATH_MULTIPLICATION_OVERFLOW\\n        ); // T:[WRM-8]\\n        return result; // T:[WRM-8]\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IInterestRateModel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\n\\n/// @title IInterestRateModel interface\\n/// @dev Interface for the calculation of the interest rates\\ninterface IInterestRateModel {\\n\\n    /// @dev Calculated borrow rate based on expectedLiquidity and availableLiquidity\\n    /// @param expectedLiquidity Expected liquidity in the pool\\n    /// @param availableLiquidity Available liquidity in the pool\\n    function calcBorrowRate(uint256 expectedLiquidity, uint256 availableLiquidity)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\nimport {IAppPoolService} from \\\"./app/IAppPoolService.sol\\\";\\n\\n\\n/// @title Pool Service Interface\\n/// @notice Implements business logic:\\n///   - Adding/removing pool liquidity\\n///   - Managing diesel tokens & diesel rates\\n///   - Lending/repaying funds to credit Manager\\n/// More: https://dev.gearbox.fi/developers/pool/abstractpoolservice\\ninterface IPoolService is IAppPoolService {\\n    // Emits each time when LP adds liquidity to the pool\\n    event AddLiquidity(\\n        address indexed sender,\\n        address indexed onBehalfOf,\\n        uint256 amount,\\n        uint256 referralCode\\n    );\\n\\n    // Emits each time when LP removes liquidity to the pool\\n    event RemoveLiquidity(\\n        address indexed sender,\\n        address indexed to,\\n        uint256 amount\\n    );\\n\\n    // Emits each time when Credit Manager borrows money from pool\\n    event Borrow(\\n        address indexed creditManager,\\n        address indexed creditAccount,\\n        uint256 amount\\n    );\\n\\n    // Emits each time when Credit Manager repays money from pool\\n    event Repay(\\n        address indexed creditManager,\\n        uint256 borrowedAmount,\\n        uint256 profit,\\n        uint256 loss\\n    );\\n\\n    // Emits each time when Interest Rate model was changed\\n    event NewInterestRateModel(address indexed newInterestRateModel);\\n\\n    // Emits each time when new credit Manager was connected\\n    event NewCreditManagerConnected(address indexed creditManager);\\n\\n    // Emits each time when borrow forbidden for credit manager\\n    event BorrowForbidden(address indexed creditManager);\\n\\n    // Emits each time when uncovered (non insured) loss accrued\\n    event UncoveredLoss(address indexed creditManager, uint256 loss);\\n\\n    // Emits after expected liquidity limit update\\n    event NewExpectedLiquidityLimit(uint256 newLimit);\\n\\n    // Emits each time when withdraw fee is udpated\\n    event NewWithdrawFee(uint256 fee);\\n\\n    //\\n    // LIQUIDITY MANAGEMENT\\n    //\\n\\n    /**\\n     * @dev Adds liquidity to pool\\n     * - transfers lp tokens to pool\\n     * - mint diesel (LP) tokens and provide them\\n     * @param amount Amount of tokens to be transfer\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n     *   is a different wallet\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     */\\n    function addLiquidity(\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint256 referralCode\\n    ) external override;\\n\\n    /**\\n     * @dev Removes liquidity from pool\\n     * - burns lp's diesel (LP) tokens\\n     * - returns underlying tokens to lp\\n     * @param amount Amount of tokens to be transfer\\n     * @param to Address to transfer liquidity\\n     */\\n\\n    function removeLiquidity(uint256 amount, address to)\\n        external\\n        override\\n        returns (uint256);\\n\\n    /**\\n     * @dev Transfers money from the pool to credit account\\n     * and updates the pool parameters\\n     * @param borrowedAmount Borrowed amount for credit account\\n     * @param creditAccount Credit account address\\n     */\\n    function lendCreditAccount(uint256 borrowedAmount, address creditAccount)\\n        external;\\n\\n    /**\\n     * @dev Recalculates total borrowed & borrowRate\\n     * mints/burns diesel tokens\\n     */\\n    function repayCreditAccount(\\n        uint256 borrowedAmount,\\n        uint256 profit,\\n        uint256 loss\\n    ) external;\\n\\n    //\\n    // GETTERS\\n    //\\n\\n    /**\\n     * @return expected pool liquidity\\n     */\\n    function expectedLiquidity() external view returns (uint256);\\n\\n    /**\\n     * @return expected liquidity limit\\n     */\\n    function expectedLiquidityLimit() external view returns (uint256);\\n\\n    /**\\n     * @dev Gets available liquidity in the pool (pool balance)\\n     * @return available pool liquidity\\n     */\\n    function availableLiquidity() external view returns (uint256);\\n\\n    /**\\n     * @dev Calculates interest accrued from the last update using the linear model\\n     */\\n    function calcLinearCumulative_RAY() external view returns (uint256);\\n\\n    /**\\n     * @dev Calculates borrow rate\\n     * @return borrow rate in RAY format\\n     */\\n    function borrowAPY_RAY() external view returns (uint256);\\n\\n    /**\\n     * @dev Gets the amount of total borrowed funds\\n     * @return Amount of borrowed funds at current time\\n     */\\n    function totalBorrowed() external view returns (uint256);\\n\\n    /**\\n     * @return Current diesel rate\\n     **/\\n\\n    function getDieselRate_RAY() external view returns (uint256);\\n\\n    /**\\n     * @dev Underlying token address getter\\n     * @return address of underlying ERC-20 token\\n     */\\n    function underlyingToken() external view returns (address);\\n\\n    /**\\n     * @dev Diesel(LP) token address getter\\n     * @return address of diesel(LP) ERC-20 token\\n     */\\n    function dieselToken() external view returns (address);\\n\\n    /**\\n     * @dev Credit Manager address getter\\n     * @return address of Credit Manager contract by id\\n     */\\n    function creditManagers(uint256 id) external view returns (address);\\n\\n    /**\\n     * @dev Credit Managers quantity\\n     * @return quantity of connected credit Managers\\n     */\\n    function creditManagersCount() external view returns (uint256);\\n\\n    function creditManagersCanBorrow(address id) external view returns (bool);\\n\\n    function toDiesel(uint256 amount) external view returns (uint256);\\n\\n    function fromDiesel(uint256 amount) external view returns (uint256);\\n\\n    function withdrawFee() external view returns (uint256);\\n\\n    function _timestampLU() external view returns (uint256);\\n\\n    function _cumulativeIndex_RAY() external view returns (uint256);\\n\\n    function calcCumulativeIndexAtBorrowMore(\\n        uint256 amount,\\n        uint256 dAmount,\\n        uint256 cumulativeIndexAtOpen\\n    ) external view returns (uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICreditFilter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\ninterface ICreditFilter {\\n    // Emits each time token is allowed or liquidtion threshold changed\\n    event TokenAllowed(address indexed token, uint256 liquidityThreshold);\\n\\n   // Emits each time token is allowed or liquidtion threshold changed\\n    event TokenForbidden(address indexed token);\\n\\n    // Emits each time contract is allowed or adapter changed\\n    event ContractAllowed(address indexed protocol, address indexed adapter);\\n\\n    // Emits each time contract is forbidden\\n    event ContractForbidden(address indexed protocol);\\n\\n    // Emits each time when fast check parameters are updated\\n    event NewFastCheckParameters(uint256 chiThreshold, uint256 fastCheckDelay);\\n\\n    event TransferAccountAllowed(\\n        address indexed from,\\n        address indexed to,\\n        bool state\\n    );\\n\\n    event TransferPluginAllowed(\\n        address indexed pugin,\\n        bool state\\n    );\\n\\n    event PriceOracleUpdated(address indexed newPriceOracle);\\n\\n    //\\n    // STATE-CHANGING FUNCTIONS\\n    //\\n\\n    /// @dev Adds token to the list of allowed tokens\\n    /// @param token Address of allowed token\\n    /// @param liquidationThreshold The constant showing the maximum allowable ratio of Loan-To-Value for the i-th asset.\\n    function allowToken(address token, uint256 liquidationThreshold) external;\\n\\n    /// @dev Adds contract to the list of allowed contracts\\n    /// @param targetContract Address of contract to be allowed\\n    /// @param adapter Adapter contract address\\n    function allowContract(address targetContract, address adapter) external;\\n\\n    /// @dev Forbids contract and removes it from the list of allowed contracts\\n    /// @param targetContract Address of allowed contract\\n    function forbidContract(address targetContract) external;\\n\\n    /// @dev Checks financial order and reverts if tokens aren't in list or collateral protection alerts\\n    /// @param creditAccount Address of credit account\\n    /// @param tokenIn Address of token In in swap operation\\n    /// @param tokenOut Address of token Out in swap operation\\n    /// @param amountIn Amount of tokens in\\n    /// @param amountOut Amount of tokens out\\n    function checkCollateralChange(\\n        address creditAccount,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOut\\n    ) external;\\n\\n    function checkMultiTokenCollateral(\\n        address creditAccount,\\n        uint256[] memory amountIn,\\n        uint256[] memory amountOut,\\n        address[] memory tokenIn,\\n        address[] memory tokenOut\\n    ) external;\\n\\n    /// @dev Connects credit managaer, hecks that all needed price feeds exists and finalize config\\n    function connectCreditManager(address poolService) external;\\n\\n    /// @dev Sets collateral protection for new credit accounts\\n    function initEnabledTokens(address creditAccount) external;\\n\\n    function checkAndEnableToken(address creditAccount, address token) external;\\n\\n    //\\n    // GETTERS\\n    //\\n\\n    /// @dev Returns quantity of contracts in allowed list\\n    function allowedContractsCount() external view returns (uint256);\\n\\n    /// @dev Returns of contract address from the allowed list by its id\\n    function allowedContracts(uint256 id) external view returns (address);\\n\\n    /// @dev Reverts if token isn't in token allowed list\\n    function revertIfTokenNotAllowed(address token) external view;\\n\\n    /// @dev Returns true if token is in allowed list otherwise false\\n    function isTokenAllowed(address token) external view returns (bool);\\n\\n    /// @dev Returns quantity of tokens in allowed list\\n    function allowedTokensCount() external view returns (uint256);\\n\\n    /// @dev Returns of token address from allowed list by its id\\n    function allowedTokens(uint256 id) external view returns (address);\\n\\n    /// @dev Calculates total value for provided address\\n    /// More: https://dev.gearbox.fi/developers/credit/economy#total-value\\n    ///\\n    /// @param creditAccount Token creditAccount address\\n    function calcTotalValue(address creditAccount)\\n        external\\n        view\\n        returns (uint256 total);\\n\\n    /// @dev Calculates Threshold Weighted Total Value\\n    /// More: https://dev.gearbox.fi/developers/credit/economy#threshold-weighted-value\\n    ///\\n    ///@param creditAccount Credit account address\\n    function calcThresholdWeightedValue(address creditAccount)\\n        external\\n        view\\n        returns (uint256 total);\\n\\n    function contractToAdapter(address allowedContract)\\n        external\\n        view\\n        returns (address);\\n\\n    /// @dev Returns address of underlying token\\n    function underlyingToken() external view returns (address);\\n\\n    /// @dev Returns address & balance of token by the id of allowed token in the list\\n    /// @param creditAccount Credit account address\\n    /// @param id Id of token in allowed list\\n    /// @return token Address of token\\n    /// @return balance Token balance\\n    function getCreditAccountTokenById(address creditAccount, uint256 id)\\n        external\\n        view\\n        returns (\\n            address token,\\n            uint256 balance,\\n            uint256 tv,\\n            uint256 twv\\n        );\\n\\n    /**\\n     * @dev Calculates health factor for the credit account\\n     *\\n     *         sum(asset[i] * liquidation threshold[i])\\n     *   Hf = --------------------------------------------\\n     *             borrowed amount + interest accrued\\n     *\\n     *\\n     * More info: https://dev.gearbox.fi/developers/credit/economy#health-factor\\n     *\\n     * @param creditAccount Credit account address\\n     * @return Health factor in percents (see PERCENTAGE FACTOR in PercentageMath.sol)\\n     */\\n    function calcCreditAccountHealthFactor(address creditAccount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @dev Calculates credit account interest accrued\\n    /// More: https://dev.gearbox.fi/developers/credit/economy#interest-rate-accrued\\n    ///\\n    /// @param creditAccount Credit account address\\n    function calcCreditAccountAccruedInterest(address creditAccount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @dev Return enabled tokens - token masks where each bit is \\\"1\\\" is token is enabled\\n    function enabledTokens(address creditAccount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function liquidationThresholds(address token)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function priceOracle() external view returns (address);\\n\\n    function updateUnderlyingTokenLiquidationThreshold() external;\\n\\n    function revertIfCantIncreaseBorrowing(\\n        address creditAccount,\\n        uint256 minHealthFactor\\n    ) external view;\\n\\n    function revertIfAccountTransferIsNotAllowed(\\n        address onwer,\\n        address creditAccount\\n    ) external view;\\n\\n    function approveAccountTransfers(address from, bool state) external;\\n\\n    function allowanceForAccountTransfers(address from, address to)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICreditManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\npragma abicoder v2;\\n\\nimport {ICreditFilter} from \\\"../interfaces/ICreditFilter.sol\\\";\\nimport {IAppCreditManager} from \\\"./app/IAppCreditManager.sol\\\";\\nimport {DataTypes} from \\\"../libraries/data/Types.sol\\\";\\n\\n\\n/// @title Credit Manager interface\\n/// @notice It encapsulates business logic for managing credit accounts\\n///\\n/// More info: https://dev.gearbox.fi/developers/credit/credit_manager\\ninterface ICreditManager is IAppCreditManager {\\n    // Emits each time when the credit account is opened\\n    event OpenCreditAccount(\\n        address indexed sender,\\n        address indexed onBehalfOf,\\n        address indexed creditAccount,\\n        uint256 amount,\\n        uint256 borrowAmount,\\n        uint256 referralCode\\n    );\\n\\n    // Emits each time when the credit account is closed\\n    event CloseCreditAccount(\\n        address indexed owner,\\n        address indexed to,\\n        uint256 remainingFunds\\n    );\\n\\n    // Emits each time when the credit account is liquidated\\n    event LiquidateCreditAccount(\\n        address indexed owner,\\n        address indexed liquidator,\\n        uint256 remainingFunds\\n    );\\n\\n    // Emits each time when borrower increases borrowed amount\\n    event IncreaseBorrowedAmount(address indexed borrower, uint256 amount);\\n\\n    // Emits each time when borrower adds collateral\\n    event AddCollateral(\\n        address indexed onBehalfOf,\\n        address indexed token,\\n        uint256 value\\n    );\\n\\n    // Emits each time when the credit account is repaid\\n    event RepayCreditAccount(address indexed owner, address indexed to);\\n\\n    // Emit each time when financial order is executed\\n    event ExecuteOrder(address indexed borrower, address indexed target);\\n\\n    // Emits each time when new fees are set\\n    event NewParameters(\\n        uint256 minAmount,\\n        uint256 maxAmount,\\n        uint256 maxLeverage,\\n        uint256 feeInterest,\\n        uint256 feeLiquidation,\\n        uint256 liquidationDiscount\\n    );\\n\\n    event TransferAccount(address indexed oldOwner, address indexed newOwner);\\n\\n    //\\n    // CREDIT ACCOUNT MANAGEMENT\\n    //\\n\\n    /**\\n     * @dev Opens credit account and provides credit funds.\\n     * - Opens credit account (take it from account factory)\\n     * - Transfers trader /farmers initial funds to credit account\\n     * - Transfers borrowed leveraged amount from pool (= amount x leverageFactor) calling lendCreditAccount() on connected Pool contract.\\n     * - Emits OpenCreditAccount event\\n     * Function reverts if user has already opened position\\n     *\\n     * More info: https://dev.gearbox.fi/developers/credit/credit_manager#open-credit-account\\n     *\\n     * @param amount Borrowers own funds\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n     *   is a different wallet\\n     * @param leverageFactor Multiplier to borrowers own funds\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     */\\n    function openCreditAccount(\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint256 leverageFactor,\\n        uint256 referralCode\\n    ) external override;\\n\\n    /**\\n     * @dev Closes credit account\\n     * - Swaps all assets to underlying one using default swap protocol\\n     * - Pays borrowed amount + interest accrued + fees back to the pool by calling repayCreditAccount\\n     * - Transfers remaining funds to the trader / farmer\\n     * - Closes the credit account and return it to account factory\\n     * - Emits CloseCreditAccount event\\n     *\\n     * More info: https://dev.gearbox.fi/developers/credit/credit_manager#close-credit-account\\n     *\\n     * @param to Address to send remaining funds\\n     * @param paths Exchange type data which provides paths + amountMinOut\\n     */\\n    function closeCreditAccount(address to, DataTypes.Exchange[] calldata paths)\\n        external\\n        override;\\n\\n    /**\\n     * @dev Liquidates credit account\\n     * - Transfers discounted total credit account value from liquidators account\\n     * - Pays borrowed funds + interest + fees back to pool, than transfers remaining funds to credit account owner\\n     * - Transfer all assets from credit account to liquidator (\\\"to\\\") account\\n     * - Returns credit account to factory\\n     * - Emits LiquidateCreditAccount event\\n     *\\n     * More info: https://dev.gearbox.fi/developers/credit/credit_manager#liquidate-credit-account\\n     *\\n     * @param borrower Borrower address\\n     * @param to Address to transfer all assets from credit account\\n     * @param force If true, use transfer function for transferring tokens instead of safeTransfer\\n     */\\n    function liquidateCreditAccount(\\n        address borrower,\\n        address to,\\n        bool force\\n    ) external;\\n\\n    /// @dev Repays credit account\\n    /// More info: https://dev.gearbox.fi/developers/credit/credit_manager#repay-credit-account\\n    ///\\n    /// @param to Address to send credit account assets\\n    function repayCreditAccount(address to) external override;\\n\\n    /// @dev Repays credit account with ETH. Restricted to be called by WETH Gateway only\\n    ///\\n    /// @param borrower Address of borrower\\n    /// @param to Address to send credit account assets\\n    function repayCreditAccountETH(address borrower, address to)\\n        external\\n        returns (uint256);\\n\\n    /// @dev Increases borrowed amount by transferring additional funds from\\n    /// the pool if after that HealthFactor > minHealth\\n    /// More info: https://dev.gearbox.fi/developers/credit/credit_manager#increase-borrowed-amount\\n    ///\\n    /// @param amount Amount to increase borrowed amount\\n    function increaseBorrowedAmount(uint256 amount) external override;\\n\\n    /// @dev Adds collateral to borrower's credit account\\n    /// @param onBehalfOf Address of borrower to add funds\\n    /// @param token Token address\\n    /// @param amount Amount to add\\n    function addCollateral(\\n        address onBehalfOf,\\n        address token,\\n        uint256 amount\\n    ) external override;\\n\\n    /// @dev Returns true if the borrower has opened a credit account\\n    /// @param borrower Borrower account\\n    function hasOpenedCreditAccount(address borrower)\\n        external\\n        view\\n        override\\n        returns (bool);\\n\\n    /// @dev Calculates Repay amount = borrow amount + interest accrued + fee\\n    ///\\n    /// More info: https://dev.gearbox.fi/developers/credit/economy#repay\\n    ///           https://dev.gearbox.fi/developers/credit/economy#liquidate\\n    ///\\n    /// @param borrower Borrower address\\n    /// @param isLiquidated True if calculated repay amount for liquidator\\n    function calcRepayAmount(address borrower, bool isLiquidated)\\n        external\\n        view\\n        override\\n        returns (uint256);\\n\\n    /// @dev Returns minimal amount for open credit account\\n    function minAmount() external view returns (uint256);\\n\\n    /// @dev Returns maximum amount for open credit account\\n    function maxAmount() external view returns (uint256);\\n\\n    /// @dev Returns maximum leveraged factor allowed for this pool\\n    function maxLeverageFactor() external view returns (uint256);\\n\\n    /// @dev Returns underlying token address\\n    function underlyingToken() external view returns (address);\\n\\n    /// @dev Returns address of connected pool\\n    function poolService() external view returns (address);\\n\\n    /// @dev Returns address of CreditFilter\\n    function creditFilter() external view returns (ICreditFilter);\\n\\n    /// @dev Returns address of CreditFilter\\n    function creditAccounts(address borrower) external view returns (address);\\n\\n    /// @dev Executes filtered order on credit account which is connected with particular borrowers\\n    /// @param borrower Borrower address\\n    /// @param target Target smart-contract\\n    /// @param data Call data for call\\n    function executeOrder(\\n        address borrower,\\n        address target,\\n        bytes memory data\\n    ) external returns (bytes memory);\\n\\n    /// @dev Approves token for msg.sender's credit account\\n    function approve(address targetContract, address token) external;\\n\\n    /// @dev Approve tokens for credit accounts. Restricted for adapters only\\n    function provideCreditAccountAllowance(\\n        address creditAccount,\\n        address toContract,\\n        address token\\n    ) external;\\n\\n    function transferAccountOwnership(address newOwner) external;\\n\\n    /// @dev Returns address of borrower's credit account and reverts of borrower has no one.\\n    /// @param borrower Borrower address\\n    function getCreditAccountOrRevert(address borrower)\\n        external\\n        view\\n        override\\n        returns (address);\\n\\n//    function feeSuccess() external view returns (uint256);\\n\\n    function feeInterest() external view returns (uint256);\\n\\n    function feeLiquidation() external view returns (uint256);\\n\\n    function liquidationDiscount() external view returns (uint256);\\n\\n    function minHealthFactor() external view returns (uint256);\\n\\n    function defaultSwapContract() external view override returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/app/IAppPoolService.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\n/// @title POptimised for front-end Pool Service Interface\\ninterface IAppPoolService {\\n\\n    function addLiquidity(\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint256 referralCode\\n    ) external;\\n\\n    function removeLiquidity(uint256 amount, address to) external returns(uint256);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/app/IAppCreditManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\npragma abicoder v2;\\n\\nimport {DataTypes} from \\\"../../libraries/data/Types.sol\\\";\\n\\n\\n/// @title Optimised for front-end credit Manager interface\\n/// @notice It's optimised for light-weight abi\\ninterface IAppCreditManager {\\n    function openCreditAccount(\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint256 leverageFactor,\\n        uint256 referralCode\\n    ) external;\\n\\n    function closeCreditAccount(address to, DataTypes.Exchange[] calldata paths)\\n        external;\\n\\n    function repayCreditAccount(address to) external;\\n\\n    function increaseBorrowedAmount(uint256 amount) external;\\n\\n    function addCollateral(\\n        address onBehalfOf,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    function calcRepayAmount(address borrower, bool isLiquidated)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getCreditAccountOrRevert(address borrower)\\n        external\\n        view\\n        returns (address);\\n\\n    function hasOpenedCreditAccount(address borrower)\\n        external\\n        view\\n        returns (bool);\\n\\n    function defaultSwapContract() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/data/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\n\\n/// @title DataType library\\n/// @notice Contains data types used in data compressor.\\nlibrary DataTypes {\\n    struct Exchange {\\n        address[] path;\\n        uint256 amountOutMin;\\n    }\\n\\n    struct TokenBalance {\\n        address token;\\n        uint256 balance;\\n        bool isAllowed;\\n    }\\n\\n    struct ContractAdapter {\\n        address allowedContract;\\n        address adapter;\\n    }\\n\\n    struct CreditAccountData {\\n        address addr;\\n        address borrower;\\n        bool inUse;\\n        address creditManager;\\n        address underlyingToken;\\n        uint256 borrowedAmountPlusInterest;\\n        uint256 totalValue;\\n        uint256 healthFactor;\\n        uint256 borrowRate;\\n        TokenBalance[] balances;\\n    }\\n\\n    struct CreditAccountDataExtended {\\n        address addr;\\n        address borrower;\\n        bool inUse;\\n        address creditManager;\\n        address underlyingToken;\\n        uint256 borrowedAmountPlusInterest;\\n        uint256 totalValue;\\n        uint256 healthFactor;\\n        uint256 borrowRate;\\n        TokenBalance[] balances;\\n        uint256 repayAmount;\\n        uint256 liquidationAmount;\\n        bool canBeClosed;\\n        uint256 borrowedAmount;\\n        uint256 cumulativeIndexAtOpen;\\n        uint256 since;\\n    }\\n\\n    struct CreditManagerData {\\n        address addr;\\n        bool hasAccount;\\n        address underlyingToken;\\n        bool isWETH;\\n        bool canBorrow;\\n        uint256 borrowRate;\\n        uint256 minAmount;\\n        uint256 maxAmount;\\n        uint256 maxLeverageFactor;\\n        uint256 availableLiquidity;\\n        address[] allowedTokens;\\n        ContractAdapter[] adapters;\\n    }\\n\\n    struct PoolData {\\n        address addr;\\n        bool isWETH;\\n        address underlyingToken;\\n        address dieselToken;\\n        uint256 linearCumulativeIndex;\\n        uint256 availableLiquidity;\\n        uint256 expectedLiquidity;\\n        uint256 expectedLiquidityLimit;\\n        uint256 totalBorrowed;\\n        uint256 depositAPY_RAY;\\n        uint256 borrowAPY_RAY;\\n        uint256 dieselRate_RAY;\\n        uint256 withdrawFee;\\n        uint256 cumulativeIndex_RAY;\\n        uint256 timestampLU;\\n    }\\n\\n    struct TokenInfo {\\n        address addr;\\n        string symbol;\\n        uint8 decimals;\\n    }\\n\\n    struct AddressProviderData {\\n        address contractRegister;\\n        address acl;\\n        address priceOracle;\\n        address traderAccountFactory;\\n        address dataCompressor;\\n        address farmingFactory;\\n        address accountMiner;\\n        address treasuryContract;\\n        address gearToken;\\n        address wethToken;\\n        address wethGateway;\\n    }\\n\\n    struct MiningApproval {\\n        address token;\\n        address swapContract;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAccountFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\npragma abicoder v2;\\n\\nimport {DataTypes} from \\\"../libraries/data/Types.sol\\\";\\n\\ninterface IAccountFactory {\\n    // emits if new account miner was changed\\n    event AccountMinerChanged(address indexed miner);\\n\\n    // emits each time when creditManager takes credit account\\n    event NewCreditAccount(address indexed account);\\n\\n    // emits each time when creditManager takes credit account\\n    event InitializeCreditAccount(\\n        address indexed account,\\n        address indexed creditManager\\n    );\\n\\n    // emits each time when pool returns credit account\\n    event ReturnCreditAccount(address indexed account);\\n\\n    // emits each time when DAO takes account from account factory forever\\n    event TakeForever(address indexed creditAccount, address indexed to);\\n\\n    /// @dev Provide new creditAccount to pool. Creates a new one, if needed\\n    /// @return Address of creditAccount\\n    function takeCreditAccount(\\n        uint256 _borrowedAmount,\\n        uint256 _cumulativeIndexAtOpen\\n    ) external returns (address);\\n\\n    /// @dev Takes credit account back and stay in tn the queue\\n    /// @param usedAccount Address of used credit account\\n    function returnCreditAccount(address usedAccount) external;\\n\\n    /// @dev Returns address of next available creditAccount\\n    function getNext(address creditAccount) external view returns (address);\\n\\n    /// @dev Returns head of list of unused credit accounts\\n    function head() external view returns (address);\\n\\n    /// @dev Returns tail of list of unused credit accounts\\n    function tail() external view returns (address);\\n\\n    /// @dev Returns quantity of unused credit accounts in the stock\\n    function countCreditAccountsInStock() external view returns (uint256);\\n\\n    /// @dev Returns credit account address by its id\\n    function creditAccounts(uint256 id) external view returns (address);\\n\\n    /// @dev Quantity of credit accounts\\n    function countCreditAccounts() external view returns (uint256);\\n\\n    //    function miningApprovals(uint i) external returns(DataTypes.MiningApproval calldata);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICreditAccount.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\n\\n/// @title Reusable Credit Account interface\\n/// @notice Implements general credit account:\\n///   - Keeps token balances\\n///   - Keeps token balances\\n///   - Stores general parameters: borrowed amount, cumulative index at open and block when it was initialized\\n///   - Approves tokens for 3rd party contracts\\n///   - Transfers assets\\n///   - Execute financial orders\\n///\\n///  More: https://dev.gearbox.fi/developers/creditManager/vanillacreditAccount\\n\\ninterface ICreditAccount {\\n    /// @dev Initializes clone contract\\n    function initialize() external;\\n\\n    /// @dev Connects credit account to credit manager\\n    /// @param _creditManager Credit manager address\\n    function connectTo(\\n        address _creditManager,\\n        uint256 _borrowedAmount,\\n        uint256 _cumulativeIndexAtOpen\\n    ) external;\\n\\n    //    /// @dev Set general credit account parameters. Restricted to credit managers only\\n    //    /// @param _borrowedAmount Amount which pool lent to credit account\\n    //    /// @param _cumulativeIndexAtOpen Cumulative index at open. Uses for interest calculation\\n    //    function setGenericParameters(\\n    //\\n    //    ) external;\\n\\n    /// @dev Updates borrowed amount. Restricted to credit managers only\\n    /// @param _borrowedAmount Amount which pool lent to credit account\\n    function updateParameters(\\n        uint256 _borrowedAmount,\\n        uint256 _cumulativeIndexAtOpen\\n    ) external;\\n\\n    /// @dev Approves particular token for swap contract\\n    /// @param token ERC20 token for allowance\\n    /// @param swapContract Swap contract address\\n    function approveToken(address token, address swapContract) external;\\n\\n    /// @dev Cancels allowance for particular contract\\n    /// @param token Address of token for allowance\\n    /// @param targetContract Address of contract to cancel allowance\\n    function cancelAllowance(address token, address targetContract) external;\\n\\n    /// Transfers tokens from credit account to provided address. Restricted for pool calls only\\n    /// @param token Token which should be tranferred from credit account\\n    /// @param to Address of recipient\\n    /// @param amount Amount to be transferred\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    /// @dev Returns borrowed amount\\n    function borrowedAmount() external view returns (uint256);\\n\\n    /// @dev Returns cumulative index at time of opening credit account\\n    function cumulativeIndexAtOpen() external view returns (uint256);\\n\\n    /// @dev Returns Block number when it was initialised last time\\n    function since() external view returns (uint256);\\n\\n    /// @dev Address of last connected credit manager\\n    function creditManager() external view returns (address);\\n\\n    /// @dev Address of last connected credit manager\\n    function factory() external view returns (address);\\n\\n    /// @dev Executed financial order on 3rd party service. Restricted for pool calls only\\n    /// @param destination Contract address which should be called\\n    /// @param data Call data which should be sent\\n    function execute(address destination, bytes memory data)\\n        external\\n        returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETHGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\n\\ninterface IWETHGateway {\\n    /// @dev convert ETH to WETH and add liqudity to pool\\n    /// @param pool Address of PoolService contract which where user wants to add liquidity. This pool should has WETH as underlying asset\\n    /// @param onBehalfOf The address that will receive the diesel tokens, same as msg.sender if the user  wants to receive them on his\\n    ///                   own wallet, or a different address if the beneficiary of diesel tokens is a different wallet\\n    /// @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n    /// 0 if the action is executed directly by the user, without any middle-man\\n    function addLiquidityETH(\\n        address pool,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external payable;\\n\\n    /// @dev Removes liquidity from pool and convert WETH to ETH\\n    ///       - burns lp's diesel (LP) tokens\\n    ///       - returns underlying tokens to lp\\n    /// @param pool Address of PoolService contract which where user wants to withdraw liquidity. This pool should has WETH as underlying asset\\n    /// @param amount Amount of tokens to be transfer\\n    /// @param to Address to transfer liquidity\\n    function removeLiquidityETH(\\n        address pool,\\n        uint256 amount,\\n        address payable to\\n    ) external;\\n\\n    /// @dev Opens credit account in ETH\\n    /// @param creditManager Address of credit Manager. Should used WETH as underlying asset\\n    /// @param onBehalfOf The address that we open credit account. Same as msg.sender if the user wants to open it for  his own wallet,\\n    ///                   or a different address if the beneficiary is a different wallet\\n    /// @param leverageFactor Multiplier to borrowers own funds\\n    /// @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n    ///                     0 if the action is executed directly by the user, without any middle-man\\n    function openCreditAccountETH(\\n        address creditManager,\\n        address payable onBehalfOf,\\n        uint256 leverageFactor,\\n        uint256 referralCode\\n    ) external payable;\\n\\n    /// @dev Repays credit account in ETH\\n    ///       - transfer borrowed money with interest + fee from borrower account to pool\\n    ///       - transfer all assets to \\\"to\\\" account\\n    /// @param creditManager Address of credit Manager. Should used WETH as underlying asset\\n    /// @param to Address to send credit account assets\\n    function repayCreditAccountETH(address creditManager, address to)\\n        external\\n        payable;\\n\\n    function addCollateralETH(address creditManager, address onBehalfOf)\\n        external\\n        payable;\\n\\n    /// @dev Unwrap WETH => ETH\\n    /// @param to Address to send eth\\n    /// @param amount Amount of WETH was transferred\\n    function unwrapWETH(address to, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n// Gearbox Protocol. Generalized leverage for DeFi protocols\\n// (c) Gearbox Holdings, 2021\\npragma solidity ^0.7.4;\\n\\n\\n/// @title Price oracle interface\\ninterface IPriceOracle {\\n\\n    // Emits each time new configurator is set up\\n    event NewPriceFeed(address indexed token, address indexed priceFeed);\\n\\n    /**\\n     * @dev Sets price feed if it doesn't exists\\n     * If pricefeed exists, it changes nothing\\n     * This logic is done to protect Gearbox from priceOracle attack\\n     * when potential attacker can get access to price oracle, change them to fraud ones\\n     * and then liquidate all funds\\n     * @param token Address of token\\n     * @param priceFeedToken Address of chainlink price feed token => Eth\\n     */\\n    function addPriceFeed(address token, address priceFeedToken) external;\\n\\n    /**\\n     * @dev Converts one asset into another using rate. Reverts if price feed doesn't exist\\n     *\\n     * @param amount Amount to convert\\n     * @param tokenFrom Token address converts from\\n     * @param tokenTo Token address - converts to\\n     * @return Amount converted to tokenTo asset\\n     */\\n    function convert(\\n        uint256 amount,\\n        address tokenFrom,\\n        address tokenTo\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Gets token rate with 18 decimals. Reverts if priceFeed doesn't exist\\n     *\\n     * @param tokenFrom Converts from token address\\n     * @param tokenTo Converts to token address\\n     * @return Rate in WAD format\\n     */\\n    function getLastPrice(address tokenFrom, address tokenTo)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addressProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"U_optimal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"R_base\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"R_slope1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"R_slope2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedLiquidityLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"defaultSwapContract\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidationThreshold\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolDeployer.AllowedToken[]\",\"name\":\"allowedTokens\",\"type\":\"tuple[]\"}],\"internalType\":\"struct PoolDeployer.DeployOpts\",\"name\":\"opts\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addressProvider\",\"outputs\":[{\"internalType\":\"contract AddressProvider\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configure\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creditFilter\",\"outputs\":[{\"internalType\":\"contract CreditFilter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creditManager\",\"outputs\":[{\"internalType\":\"contract CreditManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destoy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRootBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract PoolService\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PoolDeployer","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000cf64698aff7e5f27a11dff868af228653ba53be00000000000000000000000006b175474e89094c44da98b954eedeac495271d0f0000000000000000000000000000000000000000000000000000000000001b58000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000002710000000000000000000000000000000000000000000027b46536c66c8e300000000000000000000000000000000000000000000000000003635c9adc5dea0000000000000000000000000000000000000000000000000021e19e0c9bab2400000000000000000000000000000000000000000000000000000000000000000012c00000000000000000000000000000000000000000000000000000000000000640000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d00000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000111111111117dc0aa78b770fa6a738034120c3020000000000000000000000000000000000000000000000000000000000001e460000000000000000000000007fc66500c84a76ad7e9c93437bfc5ac33e2ddae90000000000000000000000000000000000000000000000000000000000001d4c000000000000000000000000c00e94cb662c3520282e6f5717214004a7f268880000000000000000000000000000000000000000000000000000000000001f400000000000000000000000001494ca1f11d487c2bbe4543e90080aeba4ba3c2b0000000000000000000000000000000000000000000000000000000000001e46000000000000000000000000956f47f50a910163d8bf957cf5846d573e7f87ca0000000000000000000000000000000000000000000000000000000000002134000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca0000000000000000000000000000000000000000000000000000000000001d4c000000000000000000000000c011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f0000000000000000000000000000000000000000000000000000000000001e460000000000000000000000001f9840a85d5af5bf1d1762f925bdaddc4201f9840000000000000000000000000000000000000000000000000000000000001d4c000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000000000000000000000222e0000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c5990000000000000000000000000000000000000000000000000000000000002134000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000000000000000000000000000000000000000021340000000000000000000000000bc529c00c6401aef6d220be8c6ea1667f6ad93e0000000000000000000000000000000000000000000000000000000000001c52000000000000000000000000da816459f1ab5631232fe5e97a05bbbb94970c950000000000000000000000000000000000000000000000000000000000002328000000000000000000000000a354f35829ae975e850e23e9615b11da1b3dc4de000000000000000000000000000000000000000000000000000000000000222e","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}