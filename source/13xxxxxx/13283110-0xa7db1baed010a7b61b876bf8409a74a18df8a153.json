{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/token/erc721/DefiPassport.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {ERC721Full} from \\\"@openzeppelin/contracts/token/ERC721/ERC721Full.sol\\\";\\nimport {Counters} from \\\"@openzeppelin/contracts/drafts/Counters.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport {Bytes32} from \\\"../../lib/Bytes32.sol\\\";\\nimport {Adminable} from \\\"../../lib/Adminable.sol\\\";\\nimport {Initializable} from \\\"../../lib/Initializable.sol\\\";\\nimport {DefiPassportStorage} from \\\"./DefiPassportStorage.sol\\\";\\nimport {ISapphirePassportScores} from \\\"../../sapphire/ISapphirePassportScores.sol\\\";\\nimport {SapphireTypes} from \\\"../../sapphire/SapphireTypes.sol\\\";\\n\\ncontract DefiPassport is ERC721Full, Adminable, DefiPassportStorage, Initializable {\\n\\n    /* ========== Libraries ========== */\\n\\n    using Counters for Counters.Counter;\\n    using Bytes32 for bytes32;\\n\\n    /* ========== Events ========== */\\n\\n    event BaseURISet(string _baseURI);\\n\\n    event ApprovedSkinStatusChanged(\\n        address _skin,\\n        uint256 _skinTokenId,\\n        bool _status\\n    );\\n\\n    event ApprovedSkinsStatusesChanged(\\n        SkinAndTokenIdStatusRecord[] _skinsRecords\\n    );\\n\\n    event DefaultSkinStatusChanged(\\n        address _skin,\\n        bool _status\\n    );\\n\\n    event DefaultActiveSkinChanged(\\n        address _skin,\\n        uint256 _skinTokenId\\n    );\\n\\n    event ActiveSkinSet(\\n        uint256 _tokenId,\\n        SkinRecord _skinRecord\\n    );\\n\\n    event SkinManagerSet(address _skinManager);\\n\\n    event PassportScoresContractSet(address _passportScoresContract);\\n\\n    event WhitelistSkinSet(address _skin, bool _status);\\n\\n    event ProofProtocolSet(string _protocol);\\n\\n    /* ========== Public variables ========== */\\n\\n    string public baseURI;\\n\\n    bytes32 private _proofProtocol;\\n\\n    /* ========== Constructor ========== */\\n\\n    constructor()\\n        ERC721Full(\\\"\\\", \\\"\\\")\\n        public\\n    {}\\n\\n    /* ========== Modifier ========== */\\n\\n    modifier onlySkinManager () {\\n        require(\\n            msg.sender == skinManager,\\n            \\\"DefiPassport: caller is not skin manager\\\"\\n        );\\n        _;\\n    }\\n\\n    /* ========== Restricted Functions ========== */\\n\\n    function init(\\n        string calldata _name,\\n        string calldata _symbol,\\n        address _passportScoresAddress,\\n        address _skinManager\\n    )\\n        external\\n        onlyAdmin\\n        initializer\\n    {\\n        name = _name;\\n        symbol = _symbol;\\n        skinManager = _skinManager;\\n\\n        require(\\n            _passportScoresAddress.isContract(),\\n            \\\"DefiPassport: passport scores address is not a contract\\\"\\n        );\\n\\n        passportScoresContract = ISapphirePassportScores(_passportScoresAddress);\\n\\n        /*\\n        *   register the supported interfaces to conform to ERC721 via ERC165\\n        *   bytes4(keccak256('name()')) == 0x06fdde03\\n        *   bytes4(keccak256('symbol()')) == 0x95d89b41\\n        *   bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\\n        *\\n        *   => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n        */\\n        _registerInterface(0x5b5e139f);\\n    }\\n\\n    /**\\n     * @dev Sets the base URI that is appended as a prefix to the\\n     *      token URI.\\n     */\\n    function setBaseURI(\\n        string calldata _baseURI\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        baseURI = _baseURI;\\n        emit BaseURISet(_baseURI);\\n    }\\n\\n    /**\\n     * @notice Sets the protocol to be used in the score proof when minting new passports\\n     */\\n    function setProofProtocol(\\n        bytes32 _protocol\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        _proofProtocol = _protocol;\\n\\n        emit ProofProtocolSet(_proofProtocol.toString());\\n    }\\n\\n    /**\\n     * @dev Sets the address of the skin manager role\\n     *\\n     * @param _skinManager The new skin manager\\n     */\\n    function setSkinManager(\\n        address _skinManager\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        require (\\n            _skinManager != skinManager,\\n            \\\"DefiPassport: the same skin manager is already set\\\"\\n        );\\n\\n        skinManager = _skinManager;\\n\\n        emit SkinManagerSet(skinManager);\\n    }\\n\\n    /**\\n     * @notice Registers/unregisters a default skin\\n     *\\n     * @param _skin Address of the skin NFT\\n     * @param _status Wether or not it should be considered as a default\\n     *                skin or not\\n     */\\n    function setDefaultSkin(\\n        address _skin,\\n        bool _status\\n    )\\n        external\\n        onlySkinManager\\n    {\\n        if (!_status) {\\n            require(\\n                defaultActiveSkin.skin != _skin,\\n                \\\"Defi Passport: cannot unregister the default active skin\\\"\\n            );\\n        }\\n\\n        require(\\n            defaultSkins[_skin] != _status,\\n            \\\"DefiPassport: skin already has the same status\\\"\\n        );\\n\\n        require(\\n            _skin.isContract(),\\n            \\\"DefiPassport: the given skin is not a contract\\\"\\n        );\\n\\n        require (\\n            IERC721(_skin).ownerOf(1) != address(0),\\n            \\\"DefiPassport: default skin must at least have tokenId eq 1\\\"\\n        );\\n\\n        if (defaultActiveSkin.skin == address(0)) {\\n            defaultActiveSkin = SkinRecord(address(0), _skin, 1);\\n        }\\n\\n        defaultSkins[_skin] = _status;\\n\\n        emit DefaultSkinStatusChanged(_skin, _status);\\n    }\\n\\n    /**\\n     * @dev    Set the default active skin, which will be used instead of\\n     *         unavailable user's active one\\n     * @notice Skin should be used as default one (with setDefaultSkin function)\\n     *\\n     * @param _skin        Address of the skin NFT\\n     * @param _skinTokenId The NFT token ID\\n     */\\n    function setDefaultActiveSkin(\\n        address _skin,\\n        uint256 _skinTokenId\\n    )\\n        external\\n        onlySkinManager\\n    {\\n        require(\\n            defaultSkins[_skin],\\n            \\\"DefiPassport: the given skin is not registered as a default\\\"\\n        );\\n\\n        require(\\n            defaultActiveSkin.skin != _skin ||\\n                defaultActiveSkin.skinTokenId != _skinTokenId,\\n            \\\"DefiPassport: the skin is already set as default active\\\"\\n        );\\n\\n        defaultActiveSkin = SkinRecord(address(0), _skin, _skinTokenId);\\n\\n        emit DefaultActiveSkinChanged(_skin, _skinTokenId);\\n    }\\n\\n    /**\\n     * @notice Approves a passport skin.\\n     *         Only callable by the skin manager\\n     */\\n    function setApprovedSkin(\\n        address _skin,\\n        uint256 _skinTokenId,\\n        bool _status\\n    )\\n        external\\n        onlySkinManager\\n    {\\n        approvedSkins[_skin][_skinTokenId] = _status;\\n\\n        emit ApprovedSkinStatusChanged(_skin, _skinTokenId, _status);\\n    }\\n\\n    /**\\n     * @notice Sets the approved status for all skin contracts and their\\n     *         token IDs passed into this function.\\n     */\\n    function setApprovedSkins(\\n        SkinAndTokenIdStatusRecord[] memory _skinsToApprove\\n    )\\n        public\\n        onlySkinManager\\n    {\\n        for (uint256 i = 0; i < _skinsToApprove.length; i++) {\\n            TokenIdStatus[] memory tokensAndStatuses = _skinsToApprove[i].skinTokenIdStatuses;\\n\\n            for (uint256 j = 0; j < tokensAndStatuses.length; j ++) {\\n                TokenIdStatus memory tokenStatusPair = tokensAndStatuses[j];\\n\\n                approvedSkins[_skinsToApprove[i].skin][tokenStatusPair.tokenId] = tokenStatusPair.status;\\n            }\\n        }\\n\\n        emit ApprovedSkinsStatusesChanged(_skinsToApprove);\\n    }\\n\\n    /**\\n     * @notice Adds or removes a skin contract to the whitelist.\\n     *         The Defi Passport considers all skins minted by whitelisted contracts\\n     *         to be valid skins for applying them on to the passport.\\n     *         The user applying the skins must still be their owner though.\\n     */\\n    function setWhitelistedSkin(\\n        address _skinContract,\\n        bool _status\\n    )\\n        external\\n        onlySkinManager\\n    {\\n        require (\\n            _skinContract.isContract(),\\n            \\\"DefiPassport: address is not a contract\\\"\\n        );\\n\\n        require (\\n            whitelistedSkins[_skinContract] != _status,\\n            \\\"DefiPassport: the skin already has the same whitelist status\\\"\\n        );\\n\\n        whitelistedSkins[_skinContract] = _status;\\n\\n        emit WhitelistSkinSet(_skinContract, _status);\\n    }\\n\\n    function setPassportScoresContract(\\n        address _passportScoresAddress\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        require(\\n            address(passportScoresContract) != _passportScoresAddress,\\n            \\\"DefiPassport: the same passport scores address is already set\\\"\\n        );\\n\\n        require(\\n            _passportScoresAddress.isContract(),\\n            \\\"DefiPassport: the given address is not a contract\\\"\\n        );\\n\\n        passportScoresContract = ISapphirePassportScores(_passportScoresAddress);\\n\\n        emit PassportScoresContractSet(_passportScoresAddress);\\n    }\\n\\n    /* ========== Public Functions ========== */\\n\\n    /**\\n     * @notice Mints a DeFi passport to the address specified by `_to`. Note:\\n     *         - The `_passportSkin` must be an approved or default skin.\\n     *         - The token URI will be composed by <baseURI> + `_to`,\\n     *           without the \\\"0x\\\" in front\\n     *\\n     * @param _to The receiver of the defi passport\\n     * @param _passportSkin The address of the skin NFT to be applied to the passport\\n     * @param _skinTokenId The ID of the passport skin NFT, owned by the receiver\\n     */\\n    function mint(\\n        address _to,\\n        address _passportSkin,\\n        uint256 _skinTokenId,\\n        SapphireTypes.ScoreProof calldata _scoreProof\\n    )\\n        external\\n        returns (uint256)\\n    {\\n        require(\\n            _to == _scoreProof.account,\\n            \\\"DefiPassport: the proof must correspond to the receiver\\\"\\n        );\\n\\n        require(\\n            _scoreProof.protocol == _proofProtocol,\\n            \\\"DefiPassport: invalid proof protocol\\\"\\n        );\\n\\n        passportScoresContract.verify(_scoreProof);\\n\\n        require (\\n            isSkinAvailable(_to, _passportSkin, _skinTokenId),\\n            \\\"DefiPassport: invalid skin\\\"\\n        );\\n\\n        // A user cannot have two passports\\n        require(\\n            balanceOf(_to) == 0,\\n            \\\"DefiPassport: user already has a defi passport\\\"\\n        );\\n\\n        _tokenIds.increment();\\n\\n        uint256 newTokenId = _tokenIds.current();\\n        _mint(_to, newTokenId);\\n        _setActiveSkin(newTokenId, SkinRecord(_to, _passportSkin, _skinTokenId));\\n\\n        return newTokenId;\\n    }\\n\\n    /**\\n     * @notice Changes the passport skin of the caller's passport\\n     *\\n     * @param _skin The contract address to the skin NFT\\n     * @param _skinTokenId The ID of the skin NFT\\n     */\\n    function setActiveSkin(\\n        address _skin,\\n        uint256 _skinTokenId\\n    )\\n        external\\n    {\\n        require(\\n            balanceOf(msg.sender) > 0,\\n            \\\"DefiPassport: caller has no passport\\\"\\n        );\\n\\n        require(\\n            isSkinAvailable(msg.sender, _skin, _skinTokenId),\\n            \\\"DefiPassport: invalid skin\\\"\\n        );\\n\\n        uint256 tokenId = tokenOfOwnerByIndex(msg.sender, 0);\\n\\n        _setActiveSkin(tokenId, SkinRecord(msg.sender, _skin, _skinTokenId));\\n    }\\n\\n    function approve(\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n    {\\n        revert(\\\"DefiPassport: defi passports are not transferrable\\\");\\n    }\\n\\n    function setApprovalForAll(\\n        address to,\\n        bool approved\\n    )\\n        public\\n    {\\n        revert(\\\"DefiPassport: defi passports are not transferrable\\\");\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n    {\\n        revert(\\\"DefiPassport: defi passports are not transferrable\\\");\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    )\\n        public\\n    {\\n        revert(\\\"DefiPassport: defi passports are not transferrable\\\");\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    )\\n        public\\n    {\\n        revert(\\\"DefiPassport: defi passports are not transferrable\\\");\\n    }\\n\\n    /* ========== Public View Functions ========== */\\n\\n    /**\\n     * @notice Returns whether a certain skin can be applied to the specified\\n     *         user's passport.\\n     *\\n     * @param _user The user for whom to check\\n     * @param _skinContract The address of the skin NFT\\n     * @param _skinTokenId The NFT token ID\\n     */\\n    function isSkinAvailable(\\n        address _user,\\n        address _skinContract,\\n        uint256 _skinTokenId\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        if (defaultSkins[_skinContract]) {\\n            return IERC721(_skinContract).ownerOf(_skinTokenId) != address(0);\\n        } else if (\\n            whitelistedSkins[_skinContract] ||\\n            approvedSkins[_skinContract][_skinTokenId]\\n        ) {\\n            return _isSkinOwner(_user, _skinContract, _skinTokenId);\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Returns the active skin of the given passport ID\\n     *\\n     * @param _tokenId Passport ID\\n     */\\n    function getActiveSkin(\\n        uint256 _tokenId\\n    )\\n        public\\n        view\\n        returns (SkinRecord memory)\\n    {\\n        SkinRecord memory _activeSkin = _activeSkins[_tokenId];\\n\\n        if (isSkinAvailable(_activeSkin.owner, _activeSkin.skin, _activeSkin.skinTokenId)) {\\n            return _activeSkin;\\n        } else {\\n            return defaultActiveSkin;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the URI for a given token ID. May return an empty string.\\n     *\\n     * Reverts if the token ID does not exist.\\n     */\\n    function tokenURI(\\n        uint256 tokenId\\n    )\\n        external\\n        view\\n        returns (string memory)\\n    {\\n        require(\\n            _exists(tokenId),\\n            \\\"ERC721Metadata: URI query for nonexistent token\\\"\\n        );\\n\\n        address owner = ownerOf(tokenId);\\n\\n        return string(abi.encodePacked(baseURI, \\\"0x\\\", _toAsciiString(owner)));\\n    }\\n\\n    function getProofProtocol()\\n        external\\n        view\\n        returns (string memory)\\n    {\\n        return _proofProtocol.toString();\\n    }\\n\\n    /* ========== Private Functions ========== */\\n\\n    /**\\n     * @dev Converts the given address to string. Used when minting new\\n     *      passports.\\n     */\\n    function _toAsciiString(\\n        address _address\\n    )\\n        private\\n        pure\\n        returns (string memory)\\n    {\\n        bytes memory s = new bytes(40);\\n        for (uint i = 0; i < 20; i++) {\\n            bytes1 b = bytes1(uint8(uint(uint160(_address)) / (2**(8*(19 - i)))));\\n            bytes1 hi = bytes1(uint8(b) / 16);\\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n            s[2*i] = _char(hi);\\n            s[2*i+1] = _char(lo);\\n        }\\n        return string(s);\\n    }\\n\\n    function _char(\\n        bytes1 b\\n    )\\n        private\\n        pure\\n        returns (bytes1 c)\\n    {\\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n        else return bytes1(uint8(b) + 0x57);\\n    }\\n\\n    /**\\n     * @dev Ensures that the user is the owner of the skin NFT\\n     */\\n    function _isSkinOwner(\\n        address _user,\\n        address _skin,\\n        uint256 _tokenId\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        /**\\n         * It is not sure if the skin contract implements the ERC721 or ERC1155 standard,\\n         * so we must do the check.\\n         */\\n        bytes memory payload = abi.encodeWithSignature(\\\"ownerOf(uint256)\\\", _tokenId);\\n        (bool success, bytes memory returnData) = _skin.staticcall(payload);\\n\\n        if (success) {\\n            (address owner) = abi.decode(returnData, (address));\\n\\n            return owner == _user;\\n        } else {\\n            // The skin contract might be an ERC1155 (like OpenSea)\\n            payload = abi.encodeWithSignature(\\\"balanceOf(address,uint256)\\\", _user, _tokenId);\\n            (success, returnData) = _skin.staticcall(payload);\\n\\n            if (success) {\\n                (uint256 balance) = abi.decode(returnData, (uint256));\\n\\n                return balance > 0;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function _setActiveSkin(\\n        uint256 _tokenId,\\n        SkinRecord memory _skinRecord\\n    )\\n        private\\n    {\\n        SkinRecord memory currentSkin = _activeSkins[_tokenId];\\n\\n        require(\\n            currentSkin.skin != _skinRecord.skin ||\\n                currentSkin.skinTokenId != _skinRecord.skinTokenId,\\n            \\\"DefiPassport: the same skin is already active\\\"\\n        );\\n\\n        _activeSkins[_tokenId] = _skinRecord;\\n\\n        emit ActiveSkinSet(_tokenId, _skinRecord);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721Full.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./ERC721Enumerable.sol\\\";\\nimport \\\"./ERC721Metadata.sol\\\";\\n\\n/**\\n * @title Full ERC721 Token\\n * @dev This implementation includes all the required and some optional functionality of the ERC721 standard\\n * Moreover, it includes approve all functionality using operator terminology.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\\n    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/drafts/Counters.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../math/SafeMath.sol\\\";\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\\n * directly accessed.\\n */\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ncontract IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of NFTs in `owner`'s account.\\n     */\\n    function balanceOf(address owner) public view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the NFT specified by `tokenId`.\\n     */\\n    function ownerOf(uint256 tokenId) public view returns (address owner);\\n\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     *\\n     *\\n     * Requirements:\\n     * - `from`, `to` cannot be zero.\\n     * - `tokenId` must be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this\\n     * NFT by either {approve} or {setApprovalForAll}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\\n    /**\\n     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Requirements:\\n     * - If the caller is not `from`, it must be approved to move this NFT by\\n     * either {approve} or {setApprovalForAll}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public;\\n    function approve(address to, uint256 tokenId) public;\\n    function getApproved(uint256 tokenId) public view returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) public;\\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\\n\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Bytes32.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.5.16;\\n\\nlibrary Bytes32 {\\n\\n    function toString(\\n        bytes32 _bytes\\n    )\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        uint8 i = 0;\\n        while (i < 32 && _bytes[i] != 0) {\\n            i++;\\n        }\\n        bytes memory bytesArray = new bytes(i);\\n        for (i = 0; i < 32 && _bytes[i] != 0; i++) {\\n            bytesArray[i] = _bytes[i];\\n        }\\n        return string(bytesArray);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Adminable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport { Storage } from \\\"./Storage.sol\\\";\\n\\n/**\\n * @title Adminable\\n * @author dYdX\\n *\\n * @dev EIP-1967 Proxy Admin contract.\\n */\\ncontract Adminable {\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     *  This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    bytes32 internal constant ADMIN_SLOT =\\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n    * @dev Modifier to check whether the `msg.sender` is the admin.\\n    *  If it is, it will run the function. Otherwise, it will revert.\\n    */\\n    modifier onlyAdmin() {\\n        require(\\n            msg.sender == getAdmin(),\\n            \\\"Adminable: caller is not admin\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @return The EIP-1967 proxy admin\\n     */\\n    function getAdmin()\\n        public\\n        view\\n        returns (address)\\n    {\\n        return address(uint160(uint256(Storage.load(ADMIN_SLOT))));\\n    }\\n}\"\r\n    },\r\n    \"contracts/lib/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.5.16;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * Taken from OpenZeppelin\\n */\\ncontract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/token/erc721/DefiPassportStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {Counters} from \\\"@openzeppelin/contracts/drafts/Counters.sol\\\";\\nimport {ISapphirePassportScores} from \\\"../../sapphire/ISapphirePassportScores.sol\\\";\\n\\ncontract DefiPassportStorage {\\n\\n    /* ========== Structs ========== */\\n\\n    struct SkinRecord {\\n        address owner;\\n        address skin;\\n        uint256 skinTokenId;\\n    }\\n\\n    struct TokenIdStatus {\\n        uint256 tokenId;\\n        bool status;\\n    }\\n\\n    struct SkinAndTokenIdStatusRecord {\\n        address skin;\\n        TokenIdStatus[] skinTokenIdStatuses;\\n    }\\n\\n    /* ========== Public Variables ========== */\\n\\n    string public name;\\n    string public symbol;\\n\\n    /**\\n     * @notice The credit score contract used by the passport\\n     */\\n    ISapphirePassportScores public passportScoresContract;\\n\\n    /**\\n     * @notice Records the whitelisted skins. All tokens minted by these contracts\\n     *         will be considered valid to apply on the passport, given they are\\n     *         owned by the caller.\\n     */\\n    mapping (address => bool) public whitelistedSkins;\\n\\n    /**\\n     * @notice Records the approved skins of the passport\\n     */\\n    mapping (address => mapping (uint256 => bool)) public approvedSkins;\\n\\n    /**\\n     * @notice Records the default skins\\n     */\\n    mapping (address => bool) public defaultSkins;\\n\\n    /**\\n     * @notice Records the default skins\\n     */\\n    SkinRecord public defaultActiveSkin;\\n\\n    /**\\n     * @notice The skin manager appointed by the admin, who can\\n     *         approve and revoke passport skins\\n     */\\n    address public skinManager;\\n\\n    /* ========== Internal Variables ========== */\\n\\n    /**\\n     * @notice Maps a passport (tokenId) to its active skin NFT\\n     */\\n    mapping (uint256 => SkinRecord) internal _activeSkins;\\n\\n    Counters.Counter internal _tokenIds;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/sapphire/ISapphirePassportScores.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nimport {SapphireTypes} from \\\"./SapphireTypes.sol\\\";\\n\\ninterface ISapphirePassportScores {\\n    function updateMerkleRoot(bytes32 newRoot) external;\\n\\n    function setMerkleRootUpdater(address merkleRootUpdater) external;\\n\\n    /**\\n     * Reverts if proof is invalid\\n     */\\n    function verify(SapphireTypes.ScoreProof calldata proof) external view returns(bool);\\n\\n    function setMerkleRootDelay(uint256 delay) external;\\n\\n    function setPause(bool status) external;\\n}\\n\"\r\n    },\r\n    \"contracts/sapphire/SapphireTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nlibrary SapphireTypes {\\n\\n    struct ScoreProof {\\n        address account;\\n        bytes32 protocol;\\n        uint256 score;\\n        bytes32[] merkleProof;\\n    }\\n\\n    struct Vault {\\n        uint256 collateralAmount;\\n        uint256 borrowedAmount;\\n    }\\n\\n    struct RootInfo {\\n        bytes32 merkleRoot;\\n        uint256 timestamp;\\n    }\\n\\n    enum Operation {\\n        Deposit,\\n        Withdraw,\\n        Borrow,\\n        Repay,\\n        Liquidate\\n    }\\n\\n    struct Action {\\n        uint256 amount;\\n        Operation operation;\\n        address userToLiquidate;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../drafts/Counters.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721 is Context, ERC165, IERC721 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using Counters for Counters.Counter;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from token ID to owner\\n    mapping (uint256 => address) private _tokenOwner;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to number of owned token\\n    mapping (address => Counters.Counter) private _ownedTokensCount;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\\n     *\\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    constructor () public {\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the specified address.\\n     * @param owner address to query the balance of\\n     * @return uint256 representing the amount owned by the passed address\\n     */\\n    function balanceOf(address owner) public view returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n\\n        return _ownedTokensCount[owner].current();\\n    }\\n\\n    /**\\n     * @dev Gets the owner of the specified token ID.\\n     * @param tokenId uint256 ID of the token to query the owner of\\n     * @return address currently marked as the owner of the given token ID\\n     */\\n    function ownerOf(uint256 tokenId) public view returns (address) {\\n        address owner = _tokenOwner[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev Approves another address to transfer the given token ID\\n     * The zero address indicates there is no approved address.\\n     * There can only be one approved address per token at a given time.\\n     * Can only be called by the token owner or an approved operator.\\n     * @param to address to be approved for the given token ID\\n     * @param tokenId uint256 ID of the token to be approved\\n     */\\n    function approve(address to, uint256 tokenId) public {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Gets the approved address for a token ID, or zero if no address set\\n     * Reverts if the token ID does not exist.\\n     * @param tokenId uint256 ID of the token to query the approval of\\n     * @return address currently approved for the given token ID\\n     */\\n    function getApproved(uint256 tokenId) public view returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev Sets or unsets the approval of a given operator\\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\\n     * @param to operator address to set the approval\\n     * @param approved representing the status of the approval to be set\\n     */\\n    function setApprovalForAll(address to, bool approved) public {\\n        require(to != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][to] = approved;\\n        emit ApprovalForAll(_msgSender(), to, approved);\\n    }\\n\\n    /**\\n     * @dev Tells whether an operator is approved by a given owner.\\n     * @param owner owner address which you want to query the approval of\\n     * @param operator operator address which you want to query the approval of\\n     * @return bool whether the given operator is approved by the given owner\\n     */\\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev Transfers the ownership of a given token ID to another address.\\n     * Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     * Requires the msg.sender to be the owner, approved, or operator.\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transferFrom(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Safely transfers the ownership of a given token ID to another address\\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * Requires the msg.sender to be the owner, approved, or operator\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Safely transfers the ownership of a given token ID to another address\\n     * If the target address is a contract, it must implement {IERC721Receiver-onERC721Received},\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * Requires the _msgSender() to be the owner, approved, or operator\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes data to send along with a safe transfer check\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransferFrom(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers the ownership of a given token ID to another address\\n     * If the target address is a contract, it must implement `onERC721Received`,\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * Requires the msg.sender to be the owner, approved, or operator\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes data to send along with a safe transfer check\\n     */\\n    function _safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) internal {\\n        _transferFrom(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether the specified token exists.\\n     * @param tokenId uint256 ID of the token to query the existence of\\n     * @return bool whether the token exists\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        address owner = _tokenOwner[tokenId];\\n        return owner != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether the given spender can transfer a given token ID.\\n     * @param spender address of the spender to query\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @return bool whether the msg.sender is approved for the given token ID,\\n     * is an operator of the owner, or is the owner of the token\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Internal function to safely mint a new token.\\n     * Reverts if the given token ID already exists.\\n     * If the target address is a contract, it must implement `onERC721Received`,\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * @param to The address that will own the minted token\\n     * @param tokenId uint256 ID of the token to be minted\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to safely mint a new token.\\n     * Reverts if the given token ID already exists.\\n     * If the target address is a contract, it must implement `onERC721Received`,\\n     * which is called upon a safe transfer, and return the magic value\\n     * `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`; otherwise,\\n     * the transfer is reverted.\\n     * @param to The address that will own the minted token\\n     * @param tokenId uint256 ID of the token to be minted\\n     * @param _data bytes data to send along with a safe transfer check\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to mint a new token.\\n     * Reverts if the given token ID already exists.\\n     * @param to The address that will own the minted token\\n     * @param tokenId uint256 ID of the token to be minted\\n     */\\n    function _mint(address to, uint256 tokenId) internal {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _tokenOwner[tokenId] = to;\\n        _ownedTokensCount[to].increment();\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn a specific token.\\n     * Reverts if the token does not exist.\\n     * Deprecated, use {_burn} instead.\\n     * @param owner owner of the token to burn\\n     * @param tokenId uint256 ID of the token being burned\\n     */\\n    function _burn(address owner, uint256 tokenId) internal {\\n        require(ownerOf(tokenId) == owner, \\\"ERC721: burn of token that is not own\\\");\\n\\n        _clearApproval(tokenId);\\n\\n        _ownedTokensCount[owner].decrement();\\n        _tokenOwner[tokenId] = address(0);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn a specific token.\\n     * Reverts if the token does not exist.\\n     * @param tokenId uint256 ID of the token being burned\\n     */\\n    function _burn(uint256 tokenId) internal {\\n        _burn(ownerOf(tokenId), tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ownership of a given token ID to another address.\\n     * As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\\n        require(ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _clearApproval(tokenId);\\n\\n        _ownedTokensCount[from].decrement();\\n        _ownedTokensCount[to].increment();\\n\\n        _tokenOwner[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * This is an internal detail of the `ERC721` contract and its use is deprecated.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        internal returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = to.call(abi.encodeWithSelector(\\n            IERC721Receiver(to).onERC721Received.selector,\\n            _msgSender(),\\n            from,\\n            tokenId,\\n            _data\\n        ));\\n        if (!success) {\\n            if (returndata.length > 0) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n            }\\n        } else {\\n            bytes4 retval = abi.decode(returndata, (bytes4));\\n            return (retval == _ERC721_RECEIVED);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to clear current approval of a given token ID.\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function _clearApproval(uint256 tokenId) private {\\n        if (_tokenApprovals[tokenId] != address(0)) {\\n            _tokenApprovals[tokenId] = address(0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721Enumerable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721Enumerable is Context, ERC165, ERC721, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address => uint256[]) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 => uint256) private _allTokensIndex;\\n\\n    /*\\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\\n     *\\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    /**\\n     * @dev Constructor function.\\n     */\\n    constructor () public {\\n        // register the supported interface to conform to ERC721Enumerable via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    /**\\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner.\\n     * @param owner address owning the tokens list to be accessed\\n     * @param index uint256 representing the index to be accessed of the requested tokens list\\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\\n        require(index < balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev Gets the total amount of tokens stored by the contract.\\n     * @return uint256 representing the total amount of tokens\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev Gets the token ID at a given index of all the tokens in this contract\\n     * Reverts if the index is greater or equal to the total number of tokens.\\n     * @param index uint256 representing the index to be accessed of the tokens list\\n     * @return uint256 token ID at the given index of the tokens list\\n     */\\n    function tokenByIndex(uint256 index) public view returns (uint256) {\\n        require(index < totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Internal function to transfer ownership of a given token ID to another address.\\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\\n     * @param from current owner of the token\\n     * @param to address to receive the ownership of the given token ID\\n     * @param tokenId uint256 ID of the token to be transferred\\n     */\\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\\n        super._transferFrom(from, to, tokenId);\\n\\n        _removeTokenFromOwnerEnumeration(from, tokenId);\\n\\n        _addTokenToOwnerEnumeration(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to mint a new token.\\n     * Reverts if the given token ID already exists.\\n     * @param to address the beneficiary that will own the minted token\\n     * @param tokenId uint256 ID of the token to be minted\\n     */\\n    function _mint(address to, uint256 tokenId) internal {\\n        super._mint(to, tokenId);\\n\\n        _addTokenToOwnerEnumeration(to, tokenId);\\n\\n        _addTokenToAllTokensEnumeration(tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to burn a specific token.\\n     * Reverts if the token does not exist.\\n     * Deprecated, use {ERC721-_burn} instead.\\n     * @param owner owner of the token to burn\\n     * @param tokenId uint256 ID of the token being burned\\n     */\\n    function _burn(address owner, uint256 tokenId) internal {\\n        super._burn(owner, tokenId);\\n\\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\\n        _ownedTokensIndex[tokenId] = 0;\\n\\n        _removeTokenFromAllTokensEnumeration(tokenId);\\n    }\\n\\n    /**\\n     * @dev Gets the list of token IDs of the requested owner.\\n     * @param owner address owning the tokens\\n     * @return uint256[] List of token IDs owned by the requested address\\n     */\\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\\n        return _ownedTokens[owner];\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\\n        _ownedTokens[to].push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        _ownedTokens[from].length--;\\n\\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\\n        // lastTokenId, or just over the end of the array if the token was the last one).\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        _allTokens.length--;\\n        _allTokensIndex[tokenId] = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721Metadata.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../../GSN/Context.sol\\\";\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\n\\ncontract ERC721Metadata is Context, ERC165, ERC721, IERC721Metadata {\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Base URI\\n    string private _baseURI;\\n\\n    // Optional mapping for token URIs\\n    mapping(uint256 => string) private _tokenURIs;\\n\\n    /*\\n     *     bytes4(keccak256('name()')) == 0x06fdde03\\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\\n     *\\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /**\\n     * @dev Constructor function\\n     */\\n    constructor (string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n    }\\n\\n    /**\\n     * @dev Gets the token name.\\n     * @return string representing the token name\\n     */\\n    function name() external view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Gets the token symbol.\\n     * @return string representing the token symbol\\n     */\\n    function symbol() external view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the URI for a given token ID. May return an empty string.\\n     *\\n     * If the token's URI is non-empty and a base URI was set (via\\n     * {_setBaseURI}), it will be added to the token ID's URI as a prefix.\\n     *\\n     * Reverts if the token ID does not exist.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n\\n        // Even if there is a base URI, it is only appended to non-empty token-specific URIs\\n        if (bytes(_tokenURI).length == 0) {\\n            return \\\"\\\";\\n        } else {\\n            // abi.encodePacked is being used to concatenate strings\\n            return string(abi.encodePacked(_baseURI, _tokenURI));\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function to set the token URI for a given token.\\n     *\\n     * Reverts if the token ID does not exist.\\n     *\\n     * TIP: if all token IDs share a prefix (e.g. if your URIs look like\\n     * `http://api.myproject.com/token/<id>`), use {_setBaseURI} to store\\n     * it and save gas.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the base URI for all token IDs. It is\\n     * automatically added as a prefix to the value returned in {tokenURI}.\\n     *\\n     * _Available since v2.5.0._\\n     */\\n    function _setBaseURI(string memory baseURI) internal {\\n        _baseURI = baseURI;\\n    }\\n\\n    /**\\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\\n    * automatically added as a preffix in {tokenURI} to each token's URI, when\\n    * they are non-empty.\\n    *\\n    * _Available since v2.5.0._\\n    */\\n    function baseURI() external view returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    /**\\n     * @dev Internal function to burn a specific token.\\n     * Reverts if the token does not exist.\\n     * Deprecated, use _burn(uint256) instead.\\n     * @param owner owner of the token to burn\\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\\n     */\\n    function _burn(address owner, uint256 tokenId) internal {\\n        super._burn(owner, tokenId);\\n\\n        // Clear metadata (if any)\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ncontract IERC721Receiver {\\n    /**\\n     * @notice Handle the receipt of an NFT\\n     * @dev The ERC721 smart contract calls this function on the recipient\\n     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\\n     * otherwise the caller will revert the transaction. The selector to be\\n     * returned can be obtained as `this.onERC721Received.selector`. This\\n     * function MAY throw to revert and reject the transfer.\\n     * Note: the ERC721 contract address is always the message sender.\\n     * @param operator The address which called `safeTransferFrom` function\\n     * @param from The address which previously owned the token\\n     * @param tokenId The NFT identifier which is being transferred\\n     * @param data Additional data with no specified format\\n     * @return bytes4 `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\\n    public returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following \\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash && codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\ncontract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract IERC721Enumerable is IERC721 {\\n    function totalSupply() public view returns (uint256);\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\\n\\n    function tokenByIndex(uint256 index) public view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract IERC721Metadata is IERC721 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.5.16;\\npragma experimental ABIEncoderV2;\\n\\nlibrary Storage {\\n\\n    /**\\n     * @dev Performs an SLOAD and returns the data in the slot.\\n     */\\n    function load(\\n        bytes32 slot\\n    )\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        bytes32 result;\\n        /* solium-disable-next-line security/no-inline-assembly */\\n        assembly {\\n            result := sload(slot)\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Performs an SSTORE to save the value to the slot.\\n     */\\n    function store(\\n        bytes32 slot,\\n        bytes32 value\\n    )\\n        internal\\n    {\\n        /* solium-disable-next-line security/no-inline-assembly */\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"skin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"skinTokenId\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct DefiPassportStorage.SkinRecord\",\"name\":\"_skinRecord\",\"type\":\"tuple\"}],\"name\":\"ActiveSkinSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_skin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_skinTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"ApprovedSkinStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"skin\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"internalType\":\"struct DefiPassportStorage.TokenIdStatus[]\",\"name\":\"skinTokenIdStatuses\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct DefiPassportStorage.SkinAndTokenIdStatusRecord[]\",\"name\":\"_skinsRecords\",\"type\":\"tuple[]\"}],\"name\":\"ApprovedSkinsStatusesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"BaseURISet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_skin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_skinTokenId\",\"type\":\"uint256\"}],\"name\":\"DefaultActiveSkinChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_skin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"DefaultSkinStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_passportScoresContract\",\"type\":\"address\"}],\"name\":\"PassportScoresContractSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_protocol\",\"type\":\"string\"}],\"name\":\"ProofProtocolSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_skinManager\",\"type\":\"address\"}],\"name\":\"SkinManagerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_skin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"WhitelistSkinSet\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvedSkins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultActiveSkin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"skin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"skinTokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"defaultSkins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getActiveSkin\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"skin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"skinTokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct DefiPassportStorage.SkinRecord\",\"name\":\"\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getProofProtocol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_passportScoresAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_skinManager\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_skinContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_skinTokenId\",\"type\":\"uint256\"}],\"name\":\"isSkinAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_passportSkin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_skinTokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"protocol\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct SapphireTypes.ScoreProof\",\"name\":\"_scoreProof\",\"type\":\"tuple\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"passportScoresContract\",\"outputs\":[{\"internalType\":\"contract ISapphirePassportScores\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_skin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_skinTokenId\",\"type\":\"uint256\"}],\"name\":\"setActiveSkin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_skin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_skinTokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setApprovedSkin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"skin\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"internalType\":\"struct DefiPassportStorage.TokenIdStatus[]\",\"name\":\"skinTokenIdStatuses\",\"type\":\"tuple[]\"}],\"internalType\":\"struct DefiPassportStorage.SkinAndTokenIdStatusRecord[]\",\"name\":\"_skinsToApprove\",\"type\":\"tuple[]\"}],\"name\":\"setApprovedSkins\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_skin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_skinTokenId\",\"type\":\"uint256\"}],\"name\":\"setDefaultActiveSkin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_skin\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setDefaultSkin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_passportScoresAddress\",\"type\":\"address\"}],\"name\":\"setPassportScoresContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_protocol\",\"type\":\"bytes32\"}],\"name\":\"setProofProtocol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_skinManager\",\"type\":\"address\"}],\"name\":\"setSkinManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_skinContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setWhitelistedSkin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"skinManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedSkins\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"DefiPassport","CompilerVersion":"v0.5.16+commit.9c3226ce","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}