{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/wsl-files/work/git/eth/less-contracts-for-tests/contracts/LessLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"./interface.sol\\\";\\n\\ncontract LessLibrary is Ownable {\\n    address public usd;\\n    address[] public factoryAddress = new address[](2);\\n\\n    uint256 private minInvestorBalance = 1000 * 1e18;\\n    uint256 private votingTime = 3 days; //three days\\n    uint256 private registrationTime = 1 days; // one day\\n    uint256 private minVoterBalance = 500 * 1e18; // minimum number of  tokens to hold to vote\\n    uint256 private minCreatorStakedBalance = 10000 * 1e18; // minimum number of tokens to hold to launch rocket\\n    uint8 private feePercent = 2;\\n    uint256 private usdFee;\\n    address private uniswapRouter; // uniswapV2 Router\\n    address payable private lessVault;\\n    address private devAddress;\\n    PresaleInfo[] private presaleAddresses; // track all presales created\\n\\n    mapping(address=> bool) public stablecoinWhitelist;\\n\\n    mapping(address => bool) private isPresale;\\n    mapping(bytes32 => bool) private usedSignature;\\n    mapping(address => bool) private signers; //adresses that can call sign functions\\n\\n    struct PresaleInfo {\\n        bytes32 title;\\n        address presaleAddress;\\n        string description;\\n        bool isCertified;\\n        uint256 openVotingTime;\\n    }\\n\\n    modifier onlyDev() {\\n        require(owner() == msg.sender || msg.sender == devAddress, \\\"onlyDev\\\");\\n        _;\\n    }\\n\\n    modifier onlyPresale() {\\n        require(isPresale[msg.sender], \\\"Not presale\\\");\\n        _;\\n    }\\n\\n    modifier onlyFactory() {\\n        require(factoryAddress[0] == msg.sender || factoryAddress[1] == msg.sender, \\\"onlyFactory\\\");\\n        _;\\n    }\\n\\n    modifier factoryIndexCheck(uint8 _index){\\n        require(_index == 0 || _index == 1, \\\"Invalid index\\\");\\n        _;\\n    }\\n\\n    constructor(address _dev, address payable _vault, address _uniswapRouter, address _usd, address[] memory _stablecoins, uint8 _usdDecimals) {\\n        require(_dev != address(0) && _vault != address(0) && _usdDecimals > 0, \\\"Wrong params\\\");\\n        devAddress = _dev;\\n        lessVault = _vault;\\n        uniswapRouter = _uniswapRouter;\\n        usd = _usd;\\n        usdFee = 1000 * 10 ** _usdDecimals;\\n        for(uint256 i=0; i <_stablecoins.length; i++){\\n            stablecoinWhitelist[_stablecoins[i]] = true;\\n        }\\n    }\\n\\n    function setFactoryAddress(address _factory, uint8 _index) external onlyDev factoryIndexCheck(_index){\\n        require(_factory != address(0), \\\"not 0\\\");\\n        factoryAddress[_index] = _factory;\\n    }\\n\\n    function setUsdFee(uint256 _newAmount) external onlyDev {\\n        require(_newAmount > 0, \\\"0 amt\\\");\\n        usdFee = _newAmount;\\n    }\\n\\n    function setUsdAddress(address _newAddress) external onlyDev {\\n        require(_newAddress != address(0), \\\"0 addr\\\");\\n        usd = _newAddress;\\n    }\\n\\n    function addPresaleAddress(\\n        address _presale,\\n        bytes32 _title,\\n        string memory _description,\\n        bool _type,\\n        uint256 _openVotingTime\\n    )\\n        external\\n        onlyFactory\\n        returns (uint256)\\n    {\\n        presaleAddresses.push(PresaleInfo(_title, _presale, _description, _type, _openVotingTime));\\n        isPresale[_presale] = true;\\n        return presaleAddresses.length - 1;\\n    }\\n\\n    function addOrRemoveStaiblecoin(address _stablecoin, bool _isValid) external onlyDev {\\n        require(_stablecoin != address(0), \\\"Not 0 addr\\\");\\n        if(_isValid){\\n            require(!stablecoinWhitelist[_stablecoin], \\\"Wrong param\\\");\\n        }\\n        else {\\n            require(stablecoinWhitelist[_stablecoin], \\\"Wrong param\\\");\\n        }\\n        stablecoinWhitelist[_stablecoin] = _isValid;\\n    }\\n\\n    function changeDev(address _newDev) external onlyDev {\\n        require(_newDev != address(0), \\\"Wrong new address\\\");\\n        devAddress = _newDev;\\n    }\\n\\n    function setVotingTime(uint256 _newVotingTime) external onlyDev {\\n        require(_newVotingTime > 0, \\\"Wrong new time\\\");\\n        votingTime = _newVotingTime;\\n    }\\n\\n    function setRegistrationTime(uint256 _newRegistrationTime) external onlyDev {\\n        require(_newRegistrationTime > 0, \\\"Wrong new time\\\");\\n        registrationTime = _newRegistrationTime;\\n    }\\n\\n    function setUniswapRouter(address _uniswapRouter) external onlyDev {\\n        uniswapRouter = _uniswapRouter;\\n    }\\n\\n    function setSingUsed(bytes memory _sign, address _presale) external {\\n        require(isPresale[_presale], \\\"u have no permition\\\");\\n        usedSignature[keccak256(_sign)] = true;\\n    }\\n\\n    function addOrRemoveSigner(address _address, bool _canSign) external onlyDev {\\n        signers[_address] = _canSign;\\n    }\\n\\n    function getPresalesCount() external view returns (uint256) {\\n        return presaleAddresses.length;\\n    }\\n\\n    function getUsdFee() external view returns(uint256, address) {\\n        return (usdFee, usd);\\n    }\\n\\n    function isValidStablecoin(address _stablecoin) external view returns (bool) {\\n        return stablecoinWhitelist[_stablecoin];\\n    }\\n\\n    function getPresaleAddress(uint256 id) external view returns (address) {\\n        return presaleAddresses[id].presaleAddress;\\n    }\\n\\n    function getVotingTime() external view returns(uint256){\\n        return votingTime;\\n    }\\n\\n    function getRegistrationTime() external view returns(uint256){\\n        return registrationTime;\\n    }\\n\\n    function getMinInvestorBalance() external view returns (uint256) {\\n        return minInvestorBalance;\\n    }\\n\\n    function getDev() external view onlyFactory returns (address) {\\n        return devAddress;\\n    }\\n\\n    function getMinVoterBalance() external view returns (uint256) {\\n        return minVoterBalance;\\n    }\\n    //back!!!\\n    function getMinYesVotesThreshold(uint256 totalStakedAmount) external pure returns (uint256) {\\n        uint256 stakedAmount = totalStakedAmount;\\n        return stakedAmount / 10;\\n    }\\n\\n    function getFactoryAddress(uint8 _index) external view factoryIndexCheck(_index) returns (address) {\\n        return factoryAddress[_index];\\n    }\\n\\n    function getMinCreatorStakedBalance() external view returns (uint256) {\\n        return minCreatorStakedBalance;\\n    }\\n\\n    function getUniswapRouter() external view returns (address) {\\n        return uniswapRouter;\\n    }\\n\\n    function calculateFee(uint256 amount) external view onlyPresale returns(uint256){\\n        return amount * feePercent / 100;\\n    }\\n\\n    function getVaultAddress() external view onlyPresale returns(address payable){\\n        return lessVault;\\n    }\\n\\n    function getArrForSearch() external view returns(PresaleInfo[] memory) {\\n        return presaleAddresses;\\n    }\\n    \\n    function _verifySigner(bytes32 data, bytes memory signature, uint8 _index)\\n        public\\n        view\\n        factoryIndexCheck(_index)\\n        returns (bool)\\n    {\\n        address messageSigner =\\n            ECDSA.recover(data, signature);\\n        require(\\n            isSigner(messageSigner),\\n            \\\"Unauthorised signer\\\"\\n        );\\n        return true;\\n    }\\n\\n    function getSignUsed(bytes memory _sign) external view returns(bool) {\\n        return usedSignature[keccak256(_sign)];\\n    }\\n\\n    function isSigner(address _address) internal view returns (bool) {\\n        return signers[_address];\\n    }\\n}\"\r\n    },\r\n    \"/wsl-files/work/git/eth/less-contracts-for-tests/contracts/PresaleFactoryPublic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n//import \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"./PresalePublic.sol\\\";\\n\\ncontract PresaleFactoryPublic {\\n    LessLibrary public immutable safeLibrary;\\n    /* ERC20 public lessToken;\\n    PresalePublic presale; */\\n    address public owner;\\n\\n    uint256 private lastTierTime = 6900;\\n\\n    struct PresaleInfo {\\n        address tokenAddress;\\n        uint256 tokenPriceInWei;\\n        uint256 hardCapInWei;\\n        uint256 softCapInWei;\\n        uint256 openVotingTime;\\n        uint256 openTime;\\n        uint256 closeTime;\\n        uint256 _tokenAmount;\\n        bytes _signature;\\n        uint256 _timestamp;\\n        uint8[4] poolPercentages;\\n        uint256[5] stakingTiers;\\n    }\\n\\n    struct PresalePancakeSwapInfo {\\n        uint256 listingPriceInWei;\\n        uint256 lpTokensLockDurationInDays;\\n        uint8 liquidityPercentageAllocation;\\n        uint256 liquidityAllocationTime;\\n    }\\n\\n    struct PresaleStringInfo {\\n        bytes32 saleTitle;\\n        bytes32 linkTelegram;\\n        bytes32 linkGithub;\\n        bytes32 linkTwitter;\\n        bytes32 linkWebsite;\\n        string linkLogo;\\n        string description;\\n        string whitepaper;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    modifier onlyDev {\\n        require(msg.sender == owner || safeLibrary.getDev() == msg.sender);\\n        _;\\n    }\\n\\n    event PublicPresaleCreated(\\n        uint256 presaleId,\\n        address creator,\\n        address presaleAddress,\\n        address tokenAddress,\\n        uint256 timeForLiquidity\\n    );\\n    event Received(address indexed from, uint256 amount);\\n\\n    constructor(address _bscsInfoAddress) {\\n        safeLibrary = LessLibrary(_bscsInfoAddress);\\n        owner = msg.sender;\\n    }\\n\\n    receive() external payable {\\n        emit Received(msg.sender, msg.value);\\n    }\\n\\n    function createPresale(\\n        PresaleInfo calldata _info,\\n        PresalePancakeSwapInfo calldata _cakeInfo,\\n        PresaleStringInfo calldata _stringInfo\\n    ) external payable returns (uint256 presaleId) {\\n        require(!safeLibrary.getSignUsed(_info._signature), \\\"used sign\\\");\\n        // signature check\\n        require(\\n            safeLibrary._verifySigner(\\n                keccak256(abi.encodePacked(\\n                    _info.tokenAddress,\\n                    msg.sender,\\n                    _info._tokenAmount,\\n                    _info._timestamp\\n                )),\\n                _info._signature,\\n                0\\n            ),\\n            \\\"invalid sign\\\"\\n        );\\n        require(\\n            safeLibrary.getMinCreatorStakedBalance() <= _info._tokenAmount,\\n            \\\"not enough staked tkns\\\"\\n        );\\n        //timing check\\n        require(\\n            _info.openTime > block.timestamp &&\\n                _info.openVotingTime + safeLibrary.getVotingTime() + safeLibrary.getRegistrationTime() <= \\n                _info.openTime &&\\n                _info.closeTime - _info.openTime > lastTierTime &&\\n                _info.closeTime < _cakeInfo.liquidityAllocationTime,\\n            \\\"timing err\\\"\\n        );\\n        require(\\n            _info.tokenPriceInWei > 0 &&\\n                _info.softCapInWei > 0 &&\\n                _info.hardCapInWei > 0 &&\\n                _info.hardCapInWei >= _info.softCapInWei &&\\n                _cakeInfo.listingPriceInWei > 0 &&\\n                _cakeInfo.liquidityPercentageAllocation > 0 &&\\n                _cakeInfo.lpTokensLockDurationInDays >= 30,\\n            \\\"Wrong params\\\"\\n        );\\n\\n        ERC20 _token = ERC20(_info.tokenAddress);\\n\\n      \\n        uint256 feeEth = Calculations.usdtToEthFee(address(safeLibrary));\\n        // uint256 feeEth = 50000000000000;\\n        require(msg.value >= feeEth && feeEth > 0, \\\"value<=0\\\");\\n\\n        // maxLiqPoolTokenAmount, maxTokensToBeSold, requiredTokenAmount\\n        uint256[] memory tokenAmounts = new uint256[](3);\\n        \\n        tokenAmounts = Calculations.countAmountOfTokens(\\n            _info.hardCapInWei,\\n            _info.tokenPriceInWei,\\n            _cakeInfo.listingPriceInWei,\\n            _cakeInfo.liquidityPercentageAllocation,\\n            _token.decimals()\\n        );\\n\\n        PresalePublic presale = new PresalePublic(\\n            payable(address(this)),\\n            address(safeLibrary),\\n            safeLibrary.owner(),\\n            safeLibrary.getDev()\\n        );\\n        require(\\n            _token.transferFrom(msg.sender, address(presale), tokenAmounts[2]),\\n            \\\"cant get ur tkns\\\"\\n        );\\n        payable(address(presale)).transfer(feeEth);\\n        initializePresalePublic(\\n            presale,\\n            [tokenAmounts[1], tokenAmounts[0], feeEth],\\n            _info,\\n            _cakeInfo,\\n            _stringInfo\\n        );\\n        presaleId = safeLibrary.addPresaleAddress(\\n            address(presale),\\n            _stringInfo.saleTitle,\\n            _stringInfo.description,\\n            false,\\n            _info.openVotingTime\\n        );\\n        presale.setPresaleId(presaleId);\\n        safeLibrary.setSingUsed(_info._signature, address(presale));\\n        emit PublicPresaleCreated(\\n            presaleId,\\n            msg.sender,\\n            address(presale),\\n            _info.tokenAddress,\\n            _cakeInfo.liquidityAllocationTime\\n        );\\n    }\\n\\n    function initializePresalePublic(\\n        PresalePublic _presale,\\n        uint256[3] memory _tokensForSaleLiquidityFee,\\n        PresaleInfo calldata _info,\\n        PresalePancakeSwapInfo calldata _cakeInfo,\\n        PresaleStringInfo calldata _stringInfo\\n    ) internal {\\n        _presale.init(\\n            [msg.sender, _info.tokenAddress],\\n            [\\n                _info.tokenPriceInWei,\\n                _tokensForSaleLiquidityFee[0],\\n                _tokensForSaleLiquidityFee[1],\\n                _info.softCapInWei,\\n                _info.hardCapInWei,\\n                _info.openVotingTime,\\n                _info.openTime,\\n                _info.closeTime,\\n                _tokensForSaleLiquidityFee[2]\\n            ]\\n        );\\n        _presale.setUniswapInfo(\\n            _cakeInfo.listingPriceInWei,\\n            _cakeInfo.lpTokensLockDurationInDays,\\n            _cakeInfo.liquidityPercentageAllocation,\\n            _cakeInfo.liquidityAllocationTime\\n        );\\n        _presale.setStringInfo(\\n            _stringInfo.saleTitle,\\n            _stringInfo.linkTelegram,\\n            _stringInfo.linkGithub,\\n            _stringInfo.linkTwitter,\\n            _stringInfo.linkWebsite,\\n            _stringInfo.linkLogo,\\n            _stringInfo.description,\\n            _stringInfo.whitepaper\\n        );\\n        _presale.setArrays(_info.poolPercentages, _info.stakingTiers);\\n    }\\n\\n    function migrateTo(address payable _newFactory) external onlyDev {\\n        _newFactory.transfer(address(this).balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"/wsl-files/work/git/eth/less-contracts-for-tests/contracts/PresalePublic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libraries/Calculations.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\n//import \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n//import \\\"./interface.sol\\\";\\n\\ncontract PresalePublic is ReentrancyGuard {\\n    uint256 public id;\\n\\n    address payable public factoryAddress;\\n    address public platformOwner;\\n    LessLibrary public lessLib;\\n\\n    PresaleInfo public generalInfo;\\n    PresaleUniswapInfo public uniswapInfo;\\n    PresaleStringInfo public stringInfo;\\n    IntermediateVariables public intermediate;\\n\\n    bool private initiate;\\n    bool private withdrawedFunds;\\n    address private lpAddress;\\n    uint256 private lpAmount;\\n    address private devAddress;\\n    uint256 private tokenMagnitude;\\n    address private WETHAddress;\\n\\n    mapping(address => uint256) public voters;\\n    mapping(address => bool) public claimed; // if 1, it means investor already claimed the tokens or got a refund\\n    mapping(address => Investment) public investments; // total wei invested per address\\n\\n    mapping(address => bool) public whitelistTier;\\n\\n    address[][5] public whitelist; //for backend\\n\\n    uint8[4] public poolPercentages;\\n    uint256[5] public stakingTiers;\\n\\n    TicketsInfo[] public tickets;\\n\\n    uint256[4] private tiersTimes = [6900, 6300, 5400, 3600]; // 1h55m-> 1h45m -> 1h30m -> 1h\\n    uint256 private lpDaySeconds = 1 days; // one day\\n\\n    struct TicketsInfo {\\n        address user;\\n        uint256 ticketAmount;\\n    }\\n\\n    struct PresaleInfo {\\n        address creator;\\n        address token;\\n        uint256 tokenPriceInWei;\\n        uint256 hardCapInWei;\\n        uint256 softCapInWei;\\n        uint256 tokensForSaleLeft;\\n        uint256 tokensForLiquidityLeft;\\n        uint256 openTimeVoting;\\n        uint256 closeTimeVoting;\\n        uint256 openTimePresale;\\n        uint256 closeTimePresale;\\n        uint256 collectedFee;\\n    }\\n\\n    struct IntermediateVariables {\\n        bool cancelled;\\n        bool liquidityAdded;\\n        uint256 beginingAmount;\\n        uint256 raisedAmount;\\n        uint256 raisedAmountBeforeLiquidity;\\n        uint256 participants;\\n        uint256 yesVotes;\\n        uint256 noVotes;\\n        uint256 lastTotalStakedAmount;\\n    }\\n\\n    struct PresaleUniswapInfo {\\n        uint256 listingPriceInWei;\\n        uint256 lpTokensLockDurationInDays;\\n        uint8 liquidityPercentageAllocation;\\n        uint256 liquidityAllocationTime;\\n        uint256 unlockTime;\\n    }\\n\\n    struct PresaleStringInfo {\\n        bytes32 saleTitle;\\n        bytes32 linkTelegram;\\n        bytes32 linkGithub;\\n        bytes32 linkTwitter;\\n        bytes32 linkWebsite;\\n        string linkLogo;\\n        string description;\\n        string whitepaper;\\n    }\\n\\n    struct Investment {\\n        uint256 amountEth;\\n        uint256 amountTokens;\\n    }\\n\\n    modifier onlyFabric() {\\n        require(factoryAddress == msg.sender);\\n        _;\\n    }\\n\\n    modifier onlyPlatformOwner() {\\n        require(platformOwner == msg.sender);\\n        _;\\n    }\\n\\n    modifier onlyPresaleCreator() {\\n        require(msg.sender == generalInfo.creator);\\n        _;\\n    }\\n\\n    modifier onlyOwners() {\\n        require(\\n            msg.sender == generalInfo.creator || msg.sender == platformOwner,\\n            \\\"Only owner\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier notCreator() {\\n        require(msg.sender != generalInfo.creator, \\\"No permition\\\");\\n        _;\\n    }\\n\\n    modifier liquidityAdded() {\\n        require(intermediate.liquidityAdded, \\\"Add liquidity\\\");\\n        _;\\n    }\\n\\n    modifier onlyWhenOpenVoting() {\\n        require(\\n            block.timestamp >= generalInfo.openTimeVoting &&\\n            block.timestamp <= generalInfo.closeTimeVoting,\\n            \\\"Voting closed\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyWhenOpenPresale() {\\n        uint256 nowTime = block.timestamp;\\n        require(\\n            nowTime >= generalInfo.openTimePresale &&\\n                nowTime <= generalInfo.closeTimePresale,\\n            \\\"No presales\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier presaleIsNotCancelled() {\\n        require(!intermediate.cancelled);\\n        _;\\n    }\\n\\n    modifier votesPassed(uint256 totalStakedAmount) {\\n        require(intermediate.yesVotes >= intermediate.noVotes, \\\"Not enough yes votes\\\");\\n        require(\\n            intermediate.yesVotes >= lessLib.getMinYesVotesThreshold(totalStakedAmount), \\n            \\\"Votes less min.treshold\\\"\\n        );\\n        require(block.timestamp >= generalInfo.closeTimeVoting, \\\"Voting open\\\");\\n        _;\\n    }\\n\\n    modifier openRegister() {\\n        require(\\n            block.timestamp >= generalInfo.openTimePresale - lessLib.getRegistrationTime() &&\\n                block.timestamp < generalInfo.openTimePresale,\\n            \\\"Not registration time\\\"\\n        );\\n        _;\\n    }\\n\\n    receive() external payable {}\\n\\n    constructor(\\n        address payable _factory,\\n        address _library,\\n        address _platformOwner,\\n        address _devAddress\\n    ) {\\n        require(\\n            _factory != address(0) &&\\n                _library != address(0) &&\\n                _platformOwner != address(0) &&\\n                _devAddress != address(0)\\n        );\\n        lessLib = LessLibrary(_library);\\n        factoryAddress = _factory;\\n        platformOwner = _platformOwner;\\n        devAddress = _devAddress;\\n        //generalInfo.closeTimeVoting = block.timestamp + lessLib.getVotingTime();\\n    }\\n\\n    function init(\\n        address[2] memory _creatorToken,\\n        uint256[9] memory _priceTokensForSaleLiquiditySoftHardOpenCloseFee\\n    ) external onlyFabric {\\n        require(\\n            _creatorToken[0] != address(0) && _creatorToken[1] != address(0),\\n            \\\"0 addr\\\"\\n        );\\n        require(!initiate, \\\"already inited\\\");\\n        \\n        require(\\n            _priceTokensForSaleLiquiditySoftHardOpenCloseFee[5] >=\\n                block.timestamp,\\n            \\\"not voting\\\"\\n        );\\n        \\n        generalInfo = PresaleInfo(\\n            _creatorToken[0],\\n            _creatorToken[1],\\n            _priceTokensForSaleLiquiditySoftHardOpenCloseFee[0],\\n            _priceTokensForSaleLiquiditySoftHardOpenCloseFee[4],\\n            _priceTokensForSaleLiquiditySoftHardOpenCloseFee[3],\\n            _priceTokensForSaleLiquiditySoftHardOpenCloseFee[1],\\n            _priceTokensForSaleLiquiditySoftHardOpenCloseFee[2],\\n            _priceTokensForSaleLiquiditySoftHardOpenCloseFee[5],\\n            _priceTokensForSaleLiquiditySoftHardOpenCloseFee[5] +\\n            lessLib.getVotingTime(),\\n            _priceTokensForSaleLiquiditySoftHardOpenCloseFee[6],\\n            _priceTokensForSaleLiquiditySoftHardOpenCloseFee[7],\\n            _priceTokensForSaleLiquiditySoftHardOpenCloseFee[8]\\n        );\\n\\n        uint256 tokenDecimals = ERC20(_creatorToken[1]).decimals();\\n        tokenMagnitude = uint256(10)**uint256(tokenDecimals);\\n        intermediate\\n        .beginingAmount = _priceTokensForSaleLiquiditySoftHardOpenCloseFee[1];\\n        initiate = true;\\n    }\\n\\n    function setUniswapInfo(\\n        uint256 price,\\n        uint256 duration,\\n        uint8 percent,\\n        uint256 allocationTime\\n    ) external onlyFabric {\\n        uniswapInfo = PresaleUniswapInfo(\\n            price,\\n            duration,\\n            percent,\\n            allocationTime,\\n            0\\n        );\\n    }\\n\\n    function setStringInfo(\\n        bytes32 _saleTitle,\\n        bytes32 _linkTelegram,\\n        bytes32 _linkGithub,\\n        bytes32 _linkTwitter,\\n        bytes32 _linkWebsite,\\n        string calldata _linkLogo,\\n        string calldata _description,\\n        string calldata _whitepaper\\n    ) external onlyFabric {\\n        stringInfo = PresaleStringInfo(\\n            _saleTitle,\\n            _linkTelegram,\\n            _linkGithub,\\n            _linkTwitter,\\n            _linkWebsite,\\n            _linkLogo,\\n            _description,\\n            _whitepaper\\n        );\\n    }\\n\\n    function setArrays(uint8[4] memory _poolPercentages, uint256[5] memory _stakingTiers) external onlyFabric {\\n        poolPercentages = _poolPercentages;\\n        stakingTiers = _stakingTiers;\\n    }\\n\\n    function getWhitelist(uint256 _tier)\\n        external\\n        view\\n        returns (address[] memory)\\n    {\\n        return whitelist[5 - _tier];\\n    }\\n\\n    function isWhitelisting() external view returns (bool) {\\n        return\\n            block.timestamp <= generalInfo.openTimePresale &&\\n            block.timestamp >= generalInfo.openTimePresale - lessLib.getRegistrationTime();\\n    }\\n\\n    function register(\\n        uint256 _tokenAmount,\\n        uint256 _tier,\\n        uint256 _timestamp,\\n        bytes memory _signature\\n    ) external openRegister notCreator votesPassed(intermediate.lastTotalStakedAmount) {\\n        require(_tier > 0 && _tier < 6, \\\"wr tier\\\");\\n        require(!lessLib.getSignUsed(_signature), \\\"used sign\\\");\\n        require(\\n            lessLib._verifySigner(\\n                keccak256(\\n                    abi.encodePacked(\\n                        _tokenAmount,\\n                        msg.sender,\\n                        address(this),\\n                        _timestamp\\n                    )\\n                ),\\n                _signature,\\n                0\\n            ),\\n            \\\"w sign\\\"\\n        );\\n        \\n        require(!whitelistTier[msg.sender], \\\"al. whitelisted\\\");\\n        if (_tier < 3)\\n            tickets.push(\\n                TicketsInfo(msg.sender, _tokenAmount / (500 * tokenMagnitude))\\n            );\\n        whitelistTier[msg.sender] = true;\\n        whitelist[5 - _tier].push(msg.sender);\\n        lessLib.setSingUsed(_signature, address(this));\\n    }\\n\\n    function vote(\\n        bool _yes,\\n        uint256 _stakingAmount,\\n        uint256 _timestamp,\\n        bytes memory _signature,\\n        uint256 _totalStakedAmount\\n    ) external onlyWhenOpenVoting presaleIsNotCancelled notCreator {\\n        require(!lessLib.getSignUsed(_signature), \\\"used sign\\\");\\n        require(\\n            lessLib._verifySigner(\\n                keccak256(\\n                    abi.encodePacked(\\n                        _stakingAmount,\\n                        msg.sender,\\n                        address(this),\\n                        _timestamp\\n                    )\\n                ),\\n                _signature,\\n                0\\n            )\\n        );\\n\\n        require(_stakingAmount >= lessLib.getMinVoterBalance(), \\\"scant bal\\\");\\n        require(voters[msg.sender] == 0, \\\"a.voted\\\");\\n\\n        voters[msg.sender] = _stakingAmount;\\n        if (_yes) {\\n            intermediate.yesVotes = intermediate.yesVotes + _stakingAmount;\\n        } else {\\n            intermediate.noVotes = intermediate.noVotes + _stakingAmount;\\n        }\\n        intermediate.lastTotalStakedAmount = _totalStakedAmount;\\n        lessLib.setSingUsed(_signature, address(this));\\n    }\\n\\n    // _tokenAmount only for non bnb tokens\\n    // poolPercentages starts from 5th to 2nd teirs\\n    // Staking tiers also starts from 5th to 2nd tiers\\n    function invest(\\n        bytes memory _signature,\\n        uint256 _stakedAmount,\\n        uint256 _timestamp\\n    )\\n        public\\n        payable\\n        presaleIsNotCancelled\\n        onlyWhenOpenPresale\\n        votesPassed(intermediate.lastTotalStakedAmount)\\n        nonReentrant\\n        notCreator\\n    {\\n        require(whitelistTier[msg.sender], \\\"not whitelisted\\\");\\n\\n        require(!lessLib.getSignUsed(_signature), \\\"used sign\\\");\\n        require(\\n            lessLib._verifySigner(\\n                keccak256(\\n                    abi.encodePacked(\\n                        _stakedAmount,\\n                        msg.sender,\\n                        address(this),\\n                        _timestamp\\n                    )\\n                ),\\n                _signature,\\n                0\\n            ),\\n            \\\"wrong sign\\\"\\n        );\\n\\n        uint256 tokensLeft;\\n        uint256 tokensSold = intermediate.beginingAmount - generalInfo.tokensForSaleLeft;\\n        uint256 nowTime = block.timestamp;\\n\\n        uint256[5] memory poolAmounts;\\n        uint256 prevPoolsTotalAmount;\\n        for (uint256 i = 0; i < 4; i++) {\\n            poolAmounts[i] = (intermediate.beginingAmount * poolPercentages[i] ) / 100;\\n        }\\n\\n        if (nowTime < generalInfo.openTimePresale + tiersTimes[3]) {\\n            require(\\n                _stakedAmount >= stakingTiers[0], \\n                \\\"TIER 5\\\"\\n            );\\n            tokensLeft = poolAmounts[0] - tokensSold;\\n        } else if (nowTime < generalInfo.openTimePresale + tiersTimes[2]) {\\n            require(\\n                    _stakedAmount >= stakingTiers[1],\\n                \\\"TIER 4\\\"\\n            );\\n            prevPoolsTotalAmount = poolAmounts[0];\\n            tokensLeft = poolAmounts[1] + prevPoolsTotalAmount - tokensSold;\\n        } else if (nowTime < generalInfo.openTimePresale + tiersTimes[1]) {\\n            require(\\n                    _stakedAmount >= stakingTiers[2],\\n                \\\"TIER 3\\\"\\n            );\\n            prevPoolsTotalAmount = poolAmounts[0] + poolAmounts[1];\\n            tokensLeft = poolAmounts[2] + prevPoolsTotalAmount - tokensSold;\\n        } else if (nowTime < generalInfo.openTimePresale + tiersTimes[0]) {\\n            require(\\n                    _stakedAmount >= stakingTiers[3],\\n                \\\"TIER 2\\\"\\n            );\\n            prevPoolsTotalAmount = poolAmounts[0] + poolAmounts[1] + poolAmounts[2];\\n            tokensLeft = poolAmounts[3] + prevPoolsTotalAmount - tokensSold;\\n        } else {\\n            require(\\n                _stakedAmount >= stakingTiers[4],\\n                \\\"TIER 1\\\"\\n            );\\n            tokensLeft = generalInfo.tokensForSaleLeft;\\n        }\\n        uint256 reservedTokens = getTokenAmount(msg.value);\\n        require(intermediate.raisedAmount < generalInfo.hardCapInWei, \\\"H cap\\\");\\n        require(tokensLeft >= reservedTokens, \\\"Not enough tkns in pool\\\");\\n        require(msg.value > 0, \\\"<0\\\");\\n        uint256 totalInvestmentInWei = investments[msg.sender].amountEth +\\n            msg.value;\\n\\n        if (investments[msg.sender].amountEth == 0) {\\n            intermediate.participants += 1;\\n        }\\n\\n        intermediate.raisedAmount += msg.value;\\n        investments[msg.sender].amountEth = totalInvestmentInWei;\\n        investments[msg.sender].amountTokens += reservedTokens;\\n        generalInfo.tokensForSaleLeft -= reservedTokens;\\n        lessLib.setSingUsed(_signature, address(this));\\n    }\\n\\n    function withdrawInvestment(address payable to, uint256 amount)\\n        external\\n        nonReentrant\\n    {\\n        require(block.timestamp >= generalInfo.openTimePresale, \\\"early\\\");\\n        //require(investments[msg.sender].amountEth != 0, \\\"n investor\\\");\\n        require(investments[msg.sender].amountEth >= amount, \\\"not enough amt\\\");\\n        require(amount > 0, \\\"0 amt\\\");\\n        if (!intermediate.cancelled) {\\n            require(!intermediate.liquidityAdded, \\\"afterCap withdraw\\\");\\n        }\\n        require(to != address(0), \\\"0 addr\\\");\\n        if (investments[msg.sender].amountEth - amount == 0) {\\n            intermediate.participants -= 1;\\n        }\\n        to.transfer(amount);\\n        uint256 reservedTokens = getTokenAmount(amount);\\n        intermediate.raisedAmount -= amount;\\n        investments[msg.sender].amountEth -= amount;\\n        investments[msg.sender].amountTokens -= reservedTokens;\\n        generalInfo.tokensForSaleLeft += reservedTokens;\\n    }\\n\\n    function claimTokens() external nonReentrant liquidityAdded {\\n        require(\\n            block.timestamp >= generalInfo.closeTimePresale &&\\n                !claimed[msg.sender] &&\\n                investments[msg.sender].amountEth > 0,\\n                \\\"cant claim\\\"\\n        );\\n        claimed[msg.sender] = true; // make sure this goes first before transfer to prevent reentrancy\\n        IERC20(generalInfo.token).transfer(\\n            msg.sender,\\n            investments[msg.sender].amountTokens\\n        );\\n    }\\n\\n    function addLiquidity() external presaleIsNotCancelled nonReentrant {\\n        require(msg.sender == devAddress, \\\"only dev\\\");\\n        require(\\n            uniswapInfo.liquidityAllocationTime <= block.timestamp,\\n            \\\"early\\\"\\n        );\\n\\n        require(block.timestamp >= generalInfo.closeTimePresale, \\\"n closed\\\");\\n        require(!intermediate.liquidityAdded, \\\"already added\\\");\\n        require(\\n            intermediate.raisedAmount >= generalInfo.softCapInWei,\\n            \\\"sCap n riched\\\"\\n        );\\n        uint256 raisedAmount = intermediate.raisedAmount;\\n        if (raisedAmount == 0) {\\n            intermediate.liquidityAdded = true;\\n            return;\\n        }\\n\\n        uint256 liqPoolEthAmount = (raisedAmount *\\n            uniswapInfo.liquidityPercentageAllocation) / 100;\\n        uint256 liqPoolTokenAmount = (liqPoolEthAmount * tokenMagnitude) /\\n            uniswapInfo.listingPriceInWei;\\n\\n        require(\\n            generalInfo.tokensForLiquidityLeft >= liqPoolTokenAmount,\\n            \\\"no liquidity\\\"\\n        );\\n\\n        IUniswapV2Router02 uniswapRouter = IUniswapV2Router02(\\n            address(lessLib.getUniswapRouter())\\n        );\\n\\n        IERC20 token = IERC20(generalInfo.token);\\n\\n        token.approve(address(uniswapRouter), liqPoolTokenAmount);\\n\\n        uint256 amountEth;\\n\\n        (, amountEth, lpAmount) = uniswapRouter.addLiquidityETH{value: liqPoolEthAmount}(\\n            address(token),\\n            liqPoolTokenAmount,\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp + 15 minutes\\n        );\\n\\n        intermediate.raisedAmountBeforeLiquidity = intermediate.raisedAmount;\\n        intermediate.raisedAmount -= amountEth;\\n\\n        //require(lpAmount != 0, \\\"lpAmount not null\\\");\\n\\n        IUniswapV2Factory02 uniswapFactory = IUniswapV2Factory02(\\n            uniswapRouter.factory()\\n        );\\n        lpAddress = uniswapFactory.getPair(\\n            uniswapRouter.WETH(),\\n            address(token)\\n        );\\n\\n        generalInfo.tokensForLiquidityLeft -= liqPoolTokenAmount;\\n        intermediate.liquidityAdded = true;\\n        uniswapInfo.unlockTime =\\n            block.timestamp +\\n            (uniswapInfo.lpTokensLockDurationInDays * lpDaySeconds);\\n    }\\n\\n    function collectFundsRaised()\\n        external\\n        presaleIsNotCancelled\\n        nonReentrant\\n        onlyPresaleCreator\\n        liquidityAdded\\n    {\\n        require(\\n            intermediate.raisedAmount >= generalInfo.softCapInWei,\\n            \\\"sCap n riched\\\"\\n        );\\n        require(!withdrawedFunds, \\\"only once\\\");\\n        withdrawedFunds = true;\\n        \\n        uint256 fee = lessLib.calculateFee(intermediate.raisedAmountBeforeLiquidity);\\n        lessLib.getVaultAddress().transfer(fee);\\n        payable(generalInfo.creator).transfer(\\n            intermediate.raisedAmount - fee\\n        );\\n        \\n        uint256 unsoldTokensAmount = generalInfo.tokensForSaleLeft +\\n            generalInfo.tokensForLiquidityLeft;\\n        if (unsoldTokensAmount > 0) {\\n            require(\\n                IERC20(generalInfo.token).transfer(\\n                    generalInfo.creator,\\n                    unsoldTokensAmount\\n                ),\\n                \\\"cant send tokens\\\"\\n            );\\n        }\\n    }\\n\\n    function refundLpTokens()\\n        external\\n        presaleIsNotCancelled\\n        nonReentrant\\n        onlyPresaleCreator\\n        liquidityAdded\\n    {\\n        require(lpAmount != 0 && block.timestamp >= uniswapInfo.unlockTime);\\n        require(\\n            IERC20(lpAddress).transfer(generalInfo.creator, lpAmount),\\n            \\\"transf.fail\\\"\\n        );\\n        lpAmount = 0;\\n    }\\n\\n    function collectFee() external nonReentrant {\\n        require(generalInfo.collectedFee > 0, \\\"already withdrawn\\\");\\n        require(block.timestamp >= generalInfo.closeTimeVoting, \\\"only after voting\\\");\\n        uint256 collectedFee = generalInfo.collectedFee;\\n        generalInfo.collectedFee = 0;\\n        if (\\n            intermediate.yesVotes >= intermediate.noVotes &&\\n            intermediate.yesVotes >=\\n            lessLib.getMinYesVotesThreshold(intermediate.lastTotalStakedAmount) &&\\n            !intermediate.cancelled\\n        ) {\\n            payable(platformOwner).transfer(collectedFee);\\n        } else {\\n            intermediate.cancelled = true;\\n            payable(generalInfo.creator).transfer(collectedFee);\\n            uint256 bal = IERC20(generalInfo.token).balanceOf(address(this));\\n            if(bal>0){\\n                require(IERC20(generalInfo.token).transfer(generalInfo.creator, bal), \\\"cont get ur tkns\\\");\\n            }\\n        }\\n        \\n    }\\n\\n    function changeCloseTimeVoting(uint256 _newCloseTime)\\n        external\\n        presaleIsNotCancelled\\n        onlyOwners\\n    {\\n        //uint256 openTimePresale = generalInfo.openTimePresale;\\n        require(\\n            block.timestamp < _newCloseTime &&\\n                _newCloseTime + lessLib.getRegistrationTime() <= generalInfo.openTimePresale\\n        );\\n        generalInfo.closeTimeVoting = _newCloseTime;\\n    }\\n\\n    function changePresaleTime(uint256 _newOpenTime, uint256 _newCloseTime)\\n        external\\n        presaleIsNotCancelled\\n        onlyOwners\\n    {\\n        require(block.timestamp < generalInfo.openTimePresale, \\\"started\\\");\\n        require(\\n            generalInfo.closeTimeVoting + lessLib.getRegistrationTime() < _newOpenTime &&\\n                _newCloseTime - _newOpenTime > tiersTimes[0] &&// 6900 &&\\n                _newCloseTime < uniswapInfo.liquidityAllocationTime\\n        );\\n        generalInfo.openTimePresale = _newOpenTime;\\n        generalInfo.closeTimePresale = _newCloseTime;\\n    }\\n\\n    function cancelPresale() external presaleIsNotCancelled {\\n        if(intermediate.raisedAmount < generalInfo.softCapInWei && block.timestamp >= generalInfo.closeTimePresale) {\\n            require(msg.sender == generalInfo.creator, \\\"only pres creator\\\");\\n        }\\n        else {\\n            require(msg.sender == platformOwner, \\\"only platf own\\\");\\n        }\\n        uint256 bal = IERC20(generalInfo.token).balanceOf(address(this));\\n        if(bal > 0){\\n            require(IERC20(generalInfo.token).transfer(generalInfo.creator, bal), \\\"cont get ur tkns\\\");\\n        }\\n        intermediate.cancelled = true;\\n    }\\n\\n    function getPresaleId() external view returns (uint256) {\\n        return id;\\n    }\\n\\n    function setPresaleId(uint256 _id) external onlyFabric {\\n        if (id != 0) {\\n            require(id != _id);\\n        }\\n        id = _id;\\n    }\\n\\n    function getMyVote() external view returns (uint256) {\\n        return voters[msg.sender];\\n    }\\n\\n    function getGenInfo()\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return (\\n            generalInfo.tokensForSaleLeft,\\n            generalInfo.tokensForLiquidityLeft,\\n            generalInfo.collectedFee\\n        );\\n    }\\n\\n    function getTokenAmount(uint256 _weiAmount)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return (_weiAmount * tokenMagnitude) / generalInfo.tokenPriceInWei;\\n    }\\n}\\n\"\r\n    },\r\n    \"/wsl-files/work/git/eth/less-contracts-for-tests/contracts/interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2Router02 {\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] memory path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function getAmountsOut(uint256 amountIn, address[] memory path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n}\\n\\ninterface IUniswapV2Factory02 {\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address pair);\\n}\"\r\n    },\r\n    \"/wsl-files/work/git/eth/less-contracts-for-tests/contracts/libraries/Calculations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../LessLibrary.sol\\\";\\n\\nlibrary Calculations {\\n    function swapNativeToEth(\\n        address presale,\\n        address _library,\\n        address nativeToken,\\n        uint256 liqPoolEthAmount\\n    ) external returns (uint256) {\\n        LessLibrary safeLibrary = LessLibrary(_library);\\n        IUniswapV2Router02 uniswap = IUniswapV2Router02(\\n            safeLibrary.getUniswapRouter()\\n        );\\n        address[] memory path = new address[](2);\\n        path[0] = nativeToken;\\n        path[1] = uniswap.WETH();\\n        uint256[] memory amount = uniswap.getAmountsOut(liqPoolEthAmount, path);\\n        amount = uniswap.swapTokensForExactETH(\\n            amount[1],\\n            liqPoolEthAmount,\\n            path,\\n            presale,\\n            block.timestamp + 15 minutes\\n        );\\n        return amount[1];\\n    }\\n\\n    function usdtToEthFee(address _library)\\n        external\\n        view\\n        returns (uint256 feeEth)\\n    {\\n        LessLibrary safeLibrary = LessLibrary(_library);\\n        IUniswapV2Router02 uniswap = IUniswapV2Router02(\\n            safeLibrary.getUniswapRouter()\\n        );\\n        (uint256 feeFromLib, address tether) = safeLibrary.getUsdFee();\\n        address[] memory path = new address[](2);\\n        path[0] = uniswap.WETH();\\n        path[1] = tether;\\n\\n        uint256[] memory amounts = uniswap.getAmountsIn(feeFromLib, path);\\n        return amounts[0];\\n    }\\n\\n    function countAmountOfTokens(\\n        uint256 _hardCap,\\n        uint256 _tokenPrice,\\n        uint256 _liqPrice,\\n        uint256 _liqPerc,\\n        uint8 _decimals\\n    ) external pure returns (uint256[] memory) {\\n        uint256[] memory tokenAmounts = new uint256[](3);\\n        if (_liqPrice != 0 && _liqPerc != 0) {\\n            tokenAmounts[0] = ((_hardCap *\\n                _liqPerc *\\n                (uint256(10)**uint256(_decimals))) / (_liqPrice * 100));\\n            require(tokenAmounts[0] > 0, \\\"Wrokng\\\");\\n        }\\n\\n        tokenAmounts[1] =\\n            (_hardCap  * (uint256(10)**uint256(_decimals))) / _tokenPrice;\\n        tokenAmounts[2] = tokenAmounts[0] + tokenAmounts[1];\\n        require(tokenAmounts[1] > 0, \\\"Wrong parameters\\\");\\n        return tokenAmounts;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return recover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return recover(hash, r, vs);\\n        } else {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`, `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(\\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n            \\\"ECDSA: invalid signature 's' value\\\"\\n        );\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {\r\n      \"/wsl-files/work/git/eth/less-contracts-for-tests/contracts/libraries/Calculations.sol\": {\r\n        \"Calculations\": \"0x3561A02e1192B89e2415724f43521f898e867013\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bscsInfoAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"presaleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"presaleAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeForLiquidity\",\"type\":\"uint256\"}],\"name\":\"PublicPresaleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenPriceInWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hardCapInWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"softCapInWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openVotingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint8[4]\",\"name\":\"poolPercentages\",\"type\":\"uint8[4]\"},{\"internalType\":\"uint256[5]\",\"name\":\"stakingTiers\",\"type\":\"uint256[5]\"}],\"internalType\":\"struct PresaleFactoryPublic.PresaleInfo\",\"name\":\"_info\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"listingPriceInWei\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokensLockDurationInDays\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"liquidityPercentageAllocation\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"liquidityAllocationTime\",\"type\":\"uint256\"}],\"internalType\":\"struct PresaleFactoryPublic.PresalePancakeSwapInfo\",\"name\":\"_cakeInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"saleTitle\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"linkTelegram\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"linkGithub\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"linkTwitter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"linkWebsite\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"linkLogo\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"whitepaper\",\"type\":\"string\"}],\"internalType\":\"struct PresaleFactoryPublic.PresaleStringInfo\",\"name\":\"_stringInfo\",\"type\":\"tuple\"}],\"name\":\"createPresale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"presaleId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newFactory\",\"type\":\"address\"}],\"name\":\"migrateTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeLibrary\",\"outputs\":[{\"internalType\":\"contract LessLibrary\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"PresaleFactoryPublic","CompilerVersion":"v0.8.5+commit.a4f2e591","OptimizationUsed":"1","Runs":"1","ConstructorArguments":"0000000000000000000000008ea0a4fc09cb381e18ce58673250ad47b6bed9ca","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}