{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/loans/direct/loanTypes/LoanAirdropUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./IDirectLoanBase.sol\\\";\\nimport \\\"./LoanData.sol\\\";\\nimport \\\"../../../interfaces/IDirectLoanCoordinator.sol\\\";\\nimport \\\"../../../utils/ContractKeys.sol\\\";\\nimport \\\"../../../interfaces/INftfiHub.sol\\\";\\nimport \\\"../../../interfaces/IPermittedPartners.sol\\\";\\nimport \\\"../../../interfaces/IPermittedERC20s.sol\\\";\\nimport \\\"../../../interfaces/IAirdropFlashLoan.sol\\\";\\nimport \\\"../../../interfaces/INftWrapper.sol\\\";\\nimport \\\"../../../airdrop/IAirdropReceiverFactory.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title  LoanAirdropUtils\\n * @author NFTfi\\n * @notice Helper library for LoanBase\\n */\\nlibrary LoanAirdropUtils {\\n    /**\\n     * @notice This event is fired whenever a flashloan is initiated to pull an airdrop\\n     *\\n     * @param  loanId - A unique identifier for this particular loan, sourced from the Loan Coordinator.\\n     * @param  borrower - The address of the borrower.\\n     * @param  nftCollateralId - The ID within the AirdropReceiver for the NFT being used as collateral for this\\n     * loan.\\n     * @param  nftCollateralContract - The ERC721 contract of the NFT collateral\\n     * @param target - address of the airdropping contract\\n     * @param data - function selector to be called\\n     */\\n    event AirdropPulledFlashloan(\\n        uint256 indexed loanId,\\n        address indexed borrower,\\n        uint256 nftCollateralId,\\n        address nftCollateralContract,\\n        address target,\\n        bytes data\\n    );\\n\\n    /**\\n     * @notice This event is fired whenever the collateral gets wrapped in an airdrop receiver\\n     *\\n     * @param  loanId - A unique identifier for this particular loan, sourced from the Loan Coordinator.\\n     * @param  borrower - The address of the borrower.\\n     * @param  nftCollateralId - The ID within the AirdropReceiver for the NFT being used as collateral for this\\n     * loan.\\n     * @param  nftCollateralContract - The contract of the NFT collateral\\n     * @param receiverId - id of the created AirdropReceiver, takes the place of nftCollateralId on the loan\\n     * @param receiverInstance - address of the created AirdropReceiver\\n     */\\n    event CollateralWrapped(\\n        uint256 indexed loanId,\\n        address indexed borrower,\\n        uint256 nftCollateralId,\\n        address nftCollateralContract,\\n        uint256 receiverId,\\n        address receiverInstance\\n    );\\n\\n    function pullAirdrop(\\n        uint256 _loanId,\\n        LoanData.LoanTerms memory _loan,\\n        address _target,\\n        bytes calldata _data,\\n        address _nftAirdrop,\\n        uint256 _nftAirdropId,\\n        bool _is1155,\\n        uint256 _nftAirdropAmount,\\n        INftfiHub _hub\\n    ) external {\\n        IDirectLoanCoordinator loanCoordinator = IDirectLoanCoordinator(\\n            _hub.getContract(IDirectLoanBase(address(this)).LOAN_COORDINATOR())\\n        );\\n\\n        address borrower;\\n\\n        // scoped to aviod stack too deep\\n        {\\n            IDirectLoanCoordinator.Loan memory loanCoordinatorData = loanCoordinator.getLoanData(_loanId);\\n            uint256 smartNftId = loanCoordinatorData.smartNftId;\\n            borrower = IERC721(loanCoordinator.obligationReceiptToken()).ownerOf(smartNftId);\\n        }\\n\\n        require(msg.sender == borrower, \\\"Only borrower can airdrop\\\");\\n\\n        {\\n            IAirdropFlashLoan airdropFlashLoan = IAirdropFlashLoan(_hub.getContract(ContractKeys.AIRDROP_FLASH_LOAN));\\n\\n            _transferNFT(_loan, address(this), address(airdropFlashLoan));\\n\\n            airdropFlashLoan.pullAirdrop(\\n                _loan.nftCollateralContract,\\n                _loan.nftCollateralId,\\n                _loan.nftCollateralWrapper,\\n                _target,\\n                _data,\\n                _nftAirdrop,\\n                _nftAirdropId,\\n                _is1155,\\n                _nftAirdropAmount,\\n                borrower\\n            );\\n        }\\n\\n        // revert if the collateral hasn't been transferred back before it ends\\n        require(\\n            INftWrapper(_loan.nftCollateralWrapper).isOwner(\\n                address(this),\\n                _loan.nftCollateralContract,\\n                _loan.nftCollateralId\\n            ),\\n            \\\"Collateral should be returned\\\"\\n        );\\n\\n        emit AirdropPulledFlashloan(\\n            _loanId,\\n            borrower,\\n            _loan.nftCollateralId,\\n            _loan.nftCollateralContract,\\n            _target,\\n            _data\\n        );\\n    }\\n\\n    function wrapCollateral(\\n        uint256 _loanId,\\n        LoanData.LoanTerms storage _loan,\\n        INftfiHub _hub\\n    ) external returns (address instance, uint256 receiverId) {\\n        IDirectLoanCoordinator loanCoordinator = IDirectLoanCoordinator(\\n            _hub.getContract(IDirectLoanBase(address(this)).LOAN_COORDINATOR())\\n        );\\n        // Fetch the current lender of the promissory note corresponding to this overdue loan.\\n        IDirectLoanCoordinator.Loan memory loanCoordinatorData = loanCoordinator.getLoanData(_loanId);\\n        uint256 smartNftId = loanCoordinatorData.smartNftId;\\n\\n        address borrower = IERC721(loanCoordinator.obligationReceiptToken()).ownerOf(smartNftId);\\n\\n        require(msg.sender == borrower, \\\"Only borrower can wrapp\\\");\\n\\n        IAirdropReceiverFactory factory = IAirdropReceiverFactory(_hub.getContract(ContractKeys.AIRDROP_FACTORY));\\n        (instance, receiverId) = factory.createAirdropReceiver(address(this));\\n\\n        // transfer collateral to airdrop receiver wrapper\\n        _transferNFTtoAirdropReceiver(_loan, instance, borrower);\\n\\n        emit CollateralWrapped(\\n            _loanId,\\n            borrower,\\n            _loan.nftCollateralId,\\n            _loan.nftCollateralContract,\\n            receiverId,\\n            instance\\n        );\\n\\n        // set the receiver as the new collateral\\n        _loan.nftCollateralContract = instance;\\n        _loan.nftCollateralId = receiverId;\\n    }\\n\\n    /**\\n     * @dev Transfers several types of NFTs using a wrapper that knows how to handle each case.\\n     *\\n     * @param _loan -\\n     * @param _sender - Current owner of the NFT\\n     * @param _recipient - Recipient of the transfer\\n     */\\n    function _transferNFT(\\n        LoanData.LoanTerms memory _loan,\\n        address _sender,\\n        address _recipient\\n    ) internal {\\n        Address.functionDelegateCall(\\n            _loan.nftCollateralWrapper,\\n            abi.encodeWithSelector(\\n                INftWrapper(_loan.nftCollateralWrapper).transferNFT.selector,\\n                _sender,\\n                _recipient,\\n                _loan.nftCollateralContract,\\n                _loan.nftCollateralId\\n            ),\\n            \\\"NFT not successfully transferred\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Transfers several types of NFTs to an airdrop receiver with an airdrop beneficiary\\n     * address attached as supplementing data using a wrapper that knows how to handle each case.\\n     *\\n     * @param _loan -\\n     * @param _airdropReceiverInstance - Recipient of the transfer\\n     * @param _airdropBeneficiary - Beneficiary of the future airdops\\n     */\\n    function _transferNFTtoAirdropReceiver(\\n        LoanData.LoanTerms memory _loan,\\n        address _airdropReceiverInstance,\\n        address _airdropBeneficiary\\n    ) internal {\\n        Address.functionDelegateCall(\\n            _loan.nftCollateralWrapper,\\n            abi.encodeWithSelector(\\n                INftWrapper(_loan.nftCollateralWrapper).wrapAirdropReceiver.selector,\\n                _airdropReceiverInstance,\\n                _loan.nftCollateralContract,\\n                _loan.nftCollateralId,\\n                _airdropBeneficiary\\n            ),\\n            \\\"NFT was not successfully migrated\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/loans/direct/loanTypes/IDirectLoanBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\nimport \\\"./LoanData.sol\\\";\\n\\npragma solidity 0.8.4;\\n\\ninterface IDirectLoanBase {\\n    function maximumLoanDuration() external view returns (uint256);\\n\\n    function adminFeeInBasisPoints() external view returns (uint16);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function LOAN_COORDINATOR() external view returns (bytes32);\\n\\n    function loanIdToLoan(uint256)\\n        external\\n        view\\n        returns (\\n            address,\\n            uint256,\\n            uint256,\\n            address,\\n            address,\\n            uint256,\\n            uint64,\\n            uint32,\\n            uint16,\\n            uint16\\n        );\\n\\n    function loanRepaidOrLiquidated(uint256) external view returns (bool);\\n\\n    function getWhetherNonceHasBeenUsedForUser(address _user, uint256 _nonce) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/loans/direct/loanTypes/LoanData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title  LoanData\\n * @author NFTfi\\n * @notice A convenience contract containg the main Loan struct shared by Direct Loans types.\\n */\\nabstract contract LoanData {\\n    /* ********** */\\n    /* DATA TYPES */\\n    /* ********** */\\n\\n    /**\\n     * @notice The main Loan Terms struct. This data is saved upon loan creation.\\n     *\\n     * @param loanERC20Denomination - The address of the ERC20 contract of the currency being used as principal/interest\\n     * for this loan.\\n     * @param loanPrincipalAmount - The original sum of money transferred from lender to borrower at the beginning of\\n     * the loan, measured in loanERC20Denomination's smallest units.\\n     * @param maximumRepaymentAmount - The maximum amount of money that the borrower would be required to retrieve their\\n     * collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have\\n     * to pay this amount to retrieve their collateral, regardless of whether they repay early.\\n     * @param nftCollateralContract - The address of the the NFT collateral contract.\\n     * @param nftCollateralWrapper - The NFTfi wrapper of the NFT collateral contract.\\n     * @param nftCollateralId - The ID within the NFTCollateralContract for the NFT being used as collateral for this\\n     * loan. The NFT is stored within this contract during the duration of the loan.\\n     * @param loanStartTime - The block.timestamp when the loan first began (measured in seconds).\\n     * @param loanDuration - The amount of time (measured in seconds) that can elapse before the lender can liquidate\\n     * the loan and seize the underlying collateral NFT.\\n     * @param loanInterestRateForDurationInBasisPoints - This is the interest rate (measured in basis points, e.g.\\n     * hundreths of a percent) for the loan, that must be repaid pro-rata by the borrower at the conclusion of the loan\\n     * or risk seizure of their nft collateral. Note if the type of the loan is fixed then this value  is not used and\\n     * is irrelevant so it should be set to 0.\\n     * @param loanAdminFeeInBasisPoints - The percent (measured in basis points) of the interest earned that will be\\n     * taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\\n     * earned.\\n     */\\n    struct LoanTerms {\\n        address loanERC20Denomination;\\n        uint256 loanPrincipalAmount;\\n        uint256 maximumRepaymentAmount;\\n        address nftCollateralContract;\\n        address nftCollateralWrapper;\\n        uint256 nftCollateralId;\\n        uint64 loanStartTime;\\n        uint32 loanDuration;\\n        uint16 loanInterestRateForDurationInBasisPoints;\\n        uint16 loanAdminFeeInBasisPoints;\\n    }\\n\\n    /**\\n     * @notice Some extra Loan's settings struct. This data is saved upon loan creation.\\n     * We need this to avoid stack too deep errors.\\n     *\\n     * @param revenueSharePartner - The address of the partner that will receive the revenue share.\\n     * @param revenueShareInBasisPoints - The percent (measured in basis points) of the admin fee amount that will be\\n     * taken as a revenue share for a t\\n     * @param referralFeeInBasisPoints - The percent (measured in basis points) of the loan principal amount that will\\n     * be taken as a fee to pay to the referrer, 0 if the lender is not paying referral fee.he partner, at the moment\\n     * the loan is begun.\\n     */\\n    struct LoanExtras {\\n        address revenueSharePartner;\\n        uint16 revenueShareInBasisPoints;\\n        uint16 referralFeeInBasisPoints;\\n    }\\n\\n    /**\\n     * @notice The offer made by the lender. Used as parameter on both acceptOffer (initiated by the borrower) and\\n     * acceptListing (initiated by the lender).\\n     *\\n     * @param loanERC20Denomination - The address of the ERC20 contract of the currency being used as principal/interest\\n     * for this loan.\\n     * @param loanPrincipalAmount - The original sum of money transferred from lender to borrower at the beginning of\\n     * the loan, measured in loanERC20Denomination's smallest units.\\n     * @param maximumRepaymentAmount - The maximum amount of money that the borrower would be required to retrieve their\\n     *  collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always\\n     * have to pay this amount to retrieve their collateral, regardless of whether they repay early.\\n     * @param nftCollateralContract - The address of the ERC721 contract of the NFT collateral.\\n     * @param nftCollateralId - The ID within the NFTCollateralContract for the NFT being used as collateral for this\\n     * loan. The NFT is stored within this contract during the duration of the loan.\\n     * @param referrer - The address of the referrer who found the lender matching the listing, Zero address to signal\\n     * this there is no referrer.\\n     * @param loanDuration - The amount of time (measured in seconds) that can elapse before the lender can liquidate\\n     * the loan and seize the underlying collateral NFT.\\n     * @param loanAdminFeeInBasisPoints - The percent (measured in basis points) of the interest earned that will be\\n     * taken as a fee by the contract admins when the loan is repaid. The fee is stored in the loan struct to prevent an\\n     * attack where the contract admins could adjust the fee right before a loan is repaid, and take all of the interest\\n     * earned.\\n     */\\n    struct Offer {\\n        address loanERC20Denomination;\\n        uint256 loanPrincipalAmount;\\n        uint256 maximumRepaymentAmount;\\n        address nftCollateralContract;\\n        uint256 nftCollateralId;\\n        address referrer;\\n        uint32 loanDuration;\\n        uint16 loanAdminFeeInBasisPoints;\\n    }\\n\\n    /**\\n     * @notice Signature related params. Used as parameter on both acceptOffer (containing borrower signature) and\\n     * acceptListing (containing lender signature).\\n     *\\n     * @param signer - The address of the signer. The borrower for `acceptOffer` the lender for `acceptListing`.\\n     * @param nonce - The nonce referred here is not the same as an Ethereum account's nonce.\\n     * We are referring instead to a nonce that is used by the lender or the borrower when they are first signing\\n     * off-chain NFTfi orders. These nonce can be any uint256 value that the user has not previously used to sign an\\n     * off-chain order. Each nonce can be used at most once perÂ user within NFTfi, regardless of whether they are the\\n     * lender or the borrower in that situation. This serves two purposes:\\n     * - First, it prevents replay attacks where an attacker would submit a user's off-chain order more than once.\\n     * - Second, it allows a user to cancel an off-chain order by calling NFTfi.cancelLoanCommitmentBeforeLoanHasBegun()\\n     * , which marks the nonce as used and prevents any future loan from using the user's off-chain order that contains\\n     * that nonce.\\n     * @param expiry - Date when the signature expires\\n     * @param signature - The ECDSA signature of the borrower or the lender, obtained off-chain ahead of time, signing\\n     * the following combination of parameters:\\n     * - Borrower\\n     *   - ListingTerms.loanERC20Denomination,\\n     *   - ListingTerms.minLoanPrincipalAmount,\\n     *   - ListingTerms.maxLoanPrincipalAmount,\\n     *   - ListingTerms.nftCollateralContract,\\n     *   - ListingTerms.nftCollateralId,\\n     *   - ListingTerms.revenueSharePartner,\\n     *   - ListingTerms.minLoanDuration,\\n     *   - ListingTerms.maxLoanDuration,\\n     *   - ListingTerms.maxInterestRateForDurationInBasisPoints,\\n     *   - ListingTerms.referralFeeInBasisPoints,\\n     *   - Signature.signer,\\n     *   - Signature.nonce,\\n     *   - Signature.expiry,\\n     *   - address of the loan type contract\\n     *   - chainId\\n     * - Lender:\\n     *   - Offer.loanERC20Denomination\\n     *   - Offer.loanPrincipalAmount\\n     *   - Offer.maximumRepaymentAmount\\n     *   - Offer.nftCollateralContract\\n     *   - Offer.nftCollateralId\\n     *   - Offer.referrer\\n     *   - Offer.loanDuration\\n     *   - Offer.loanAdminFeeInBasisPoints\\n     *   - Signature.signer,\\n     *   - Signature.nonce,\\n     *   - Signature.expiry,\\n     *   - address of the loan type contract\\n     *   - chainId\\n     */\\n    struct Signature {\\n        address signer;\\n        uint256 nonce;\\n        uint256 expiry;\\n        bytes signature;\\n    }\\n\\n    /**\\n     * @notice Some extra parameters that the borrower needs to set when accepting an offer.\\n     *\\n     * @param revenueSharePartner - The address of the partner that will receive the revenue share.\\n     * @param referralFeeInBasisPoints - The percent (measured in basis points) of the loan principal amount that will\\n     * be taken as a fee to pay to the referrer, 0 if the lender is not paying referral fee.\\n     */\\n    struct BorrowerSettings {\\n        address revenueSharePartner;\\n        uint16 referralFeeInBasisPoints;\\n    }\\n\\n    /**\\n     * @notice Terms the borrower set off-chain and is willing to accept automatically when fulfiled by a lender's\\n     * offer.\\n     *\\n     * @param loanERC20Denomination - The address of the ERC20 contract of the currency being used as principal/interest\\n     * for this loan.\\n     * @param minLoanPrincipalAmount - The minumum sum of money transferred from lender to borrower at the beginning of\\n     * the loan, measured in loanERC20Denomination's smallest units.\\n     * @param maxLoanPrincipalAmount - The  sum of money transferred from lender to borrower at the beginning of\\n     * the loan, measured in loanERC20Denomination's smallest units.\\n     * @param maximumRepaymentAmount - The maximum amount of money that the borrower would be required to retrieve their\\n     * collateral, measured in the smallest units of the ERC20 currency used for the loan. The borrower will always have\\n     * to pay this amount to retrieve their collateral, regardless of whether they repay early.\\n     * @param nftCollateralContract - The address of the ERC721 contract of the NFT collateral.\\n     * @param nftCollateralId - The ID within the NFTCollateralContract for the NFT being used as collateral for this\\n     * loan. The NFT is stored within this contract during the duration of the loan.\\n     * @param revenueSharePartner - The address of the partner that will receive the revenue share.\\n     * @param minLoanDuration - The minumum amount of time (measured in seconds) that can elapse before the lender can\\n     * liquidate the loan and seize the underlying collateral NFT.\\n     * @param maxLoanDuration - The maximum amount of time (measured in seconds) that can elapse before the lender can\\n     * liquidate the loan and seize the underlying collateral NFT.\\n     * @param maxInterestRateForDurationInBasisPoints - This is maximum the interest rate (measured in basis points,\\n     * e.g. hundreths of a percent) for the loan.\\n     * @param referralFeeInBasisPoints - The percent (measured in basis points) of the loan principal amount that will\\n     * be taken as a fee to pay to the referrer, 0 if the lender is not paying referral fee.\\n     */\\n    struct ListingTerms {\\n        address loanERC20Denomination;\\n        uint256 minLoanPrincipalAmount;\\n        uint256 maxLoanPrincipalAmount;\\n        address nftCollateralContract;\\n        uint256 nftCollateralId;\\n        address revenueSharePartner;\\n        uint32 minLoanDuration;\\n        uint32 maxLoanDuration;\\n        uint16 maxInterestRateForDurationInBasisPoints;\\n        uint16 referralFeeInBasisPoints;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDirectLoanCoordinator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title IDirectLoanCoordinator\\n * @author NFTfi\\n * @dev DirectLoanCoordinator interface.\\n */\\ninterface IDirectLoanCoordinator {\\n    enum StatusType {\\n        NOT_EXISTS,\\n        NEW,\\n        RESOLVED\\n    }\\n\\n    /**\\n     * @notice This struct contains data related to a loan\\n     *\\n     * @param smartNftId - The id of both the promissory note and obligation receipt.\\n     * @param status - The status in which the loan currently is.\\n     * @param loanContract - Address of the LoanType contract that created the loan.\\n     */\\n    struct Loan {\\n        uint256 smartNftId;\\n        StatusType status;\\n        address loanContract;\\n    }\\n\\n    function registerLoan(\\n        address _lender,\\n        address _borrower,\\n        bytes32 _loanType\\n    ) external returns (uint256);\\n\\n    function resolveLoan(uint256 _loanId) external;\\n\\n    function promissoryNoteToken() external view returns (address);\\n\\n    function obligationReceiptToken() external view returns (address);\\n\\n    function getLoanData(uint256 _loanId) external view returns (Loan memory);\\n\\n    function isValidLoanId(uint256 _loanId, address _loanContract) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ContractKeys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title ContractKeys\\n * @author NFTfi\\n * @dev Common library for contract keys\\n */\\nlibrary ContractKeys {\\n    bytes32 public constant PERMITTED_ERC20S = bytes32(\\\"PERMITTED_ERC20S\\\");\\n    bytes32 public constant PERMITTED_NFTS = bytes32(\\\"PERMITTED_NFTS\\\");\\n    bytes32 public constant PERMITTED_PARTNERS = bytes32(\\\"PERMITTED_PARTNERS\\\");\\n    bytes32 public constant NFT_TYPE_REGISTRY = bytes32(\\\"NFT_TYPE_REGISTRY\\\");\\n    bytes32 public constant LOAN_REGISTRY = bytes32(\\\"LOAN_REGISTRY\\\");\\n    bytes32 public constant PERMITTED_SNFT_RECEIVER = bytes32(\\\"PERMITTED_SNFT_RECEIVER\\\");\\n    bytes32 public constant PERMITTED_BUNDLE_ERC20S = bytes32(\\\"PERMITTED_BUNDLE_ERC20S\\\");\\n    bytes32 public constant PERMITTED_AIRDROPS = bytes32(\\\"PERMITTED_AIRDROPS\\\");\\n    bytes32 public constant AIRDROP_RECEIVER = bytes32(\\\"AIRDROP_RECEIVER\\\");\\n    bytes32 public constant AIRDROP_FACTORY = bytes32(\\\"AIRDROP_FACTORY\\\");\\n    bytes32 public constant AIRDROP_FLASH_LOAN = bytes32(\\\"AIRDROP_FLASH_LOAN\\\");\\n    bytes32 public constant NFTFI_BUNDLER = bytes32(\\\"NFTFI_BUNDLER\\\");\\n\\n    string public constant AIRDROP_WRAPPER_STRING = \\\"AirdropWrapper\\\";\\n\\n    /**\\n     * @notice Returns the bytes32 representation of a string\\n     * @param _key the string key\\n     * @return id bytes32 representation\\n     */\\n    function getIdFromStringKey(string memory _key) external pure returns (bytes32 id) {\\n        require(bytes(_key).length <= 32, \\\"invalid key\\\");\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            id := mload(add(_key, 32))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INftfiHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title INftfiHub\\n * @author NFTfi\\n * @dev NftfiHub interface\\n */\\ninterface INftfiHub {\\n    function setContract(string calldata _contractKey, address _contractAddress) external;\\n\\n    function getContract(bytes32 _contractKey) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPermittedPartners.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\ninterface IPermittedPartners {\\n    function getPartnerPermit(address _partner) external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPermittedERC20s.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\ninterface IPermittedERC20s {\\n    function getERC20Permit(address _erc20) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAirdropFlashLoan.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\ninterface IAirdropFlashLoan {\\n    function pullAirdrop(\\n        address _nftCollateralContract,\\n        uint256 _nftCollateralId,\\n        address _nftWrapper,\\n        address _target,\\n        bytes calldata _data,\\n        address _nftAirdrop,\\n        uint256 _nftAirdropId,\\n        bool _is1155,\\n        uint256 _nftAirdropAmount,\\n        address _beneficiary\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INftWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title INftTypeRegistry\\n * @author NFTfi\\n * @dev Interface for NFT Wrappers.\\n */\\ninterface INftWrapper {\\n    function transferNFT(\\n        address from,\\n        address to,\\n        address nftContract,\\n        uint256 tokenId\\n    ) external returns (bool);\\n\\n    function isOwner(\\n        address owner,\\n        address nftContract,\\n        uint256 tokenId\\n    ) external view returns (bool);\\n\\n    function wrapAirdropReceiver(\\n        address _recipient,\\n        address _nftContract,\\n        uint256 _nftId,\\n        address _beneficiary\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/airdrop/IAirdropReceiverFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title IAirdropReceiver\\n * @author NFTfi\\n * @dev\\n */\\ninterface IAirdropReceiverFactory {\\n    function createAirdropReceiver(address _to) external returns (address, uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftCollateralId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftCollateralContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"AirdropPulledFlashloan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftCollateralId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftCollateralContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receiverId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiverInstance\",\"type\":\"address\"}],\"name\":\"CollateralWrapped\",\"type\":\"event\"}]","ContractName":"LoanAirdropUtils","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"100","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}