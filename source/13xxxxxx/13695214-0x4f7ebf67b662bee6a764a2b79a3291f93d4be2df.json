{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TokenSVG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"base64-sol/base64.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./interfaces/ITokenSVG.sol\\\";\\n\\ncontract TokenSVG is ITokenSVG {\\n  string public constant DESC =\\n    \\\"For the PEOPLE of ConstitutionDAO who made history.Imagine there's no heaven,It's easy if you try,No hell below us,Above us,only sky.Imagine all the people,Living for today.Imagine there's no countries,It isn't hard to do,Nothing to kill or die for,And no religion too.Imagine All the people,Living life in peace...You may say I'm a dreamer,But I'm not the only one,I hope someday you'll join us.And the world will be as one,Imagine no possessions,I wonder if you can,No need for greed or hunger,A brotherhood of man.Imagine all the people,Sharing all the world...You may say I'm a dreamer,But I'm not the only one,I hope someday you'll join us,And the world will live as one.\\\";\\n\\n  function getCoordinatesStrings(int128 x, int128 y)\\n    public\\n    pure\\n    override\\n    returns (string memory sx, string memory sy)\\n  {\\n    string memory xPrefix = \\\"\\\";\\n    if (x > 0) {\\n      xPrefix = \\\"E\\\";\\n    }\\n    if (x < 0) {\\n      xPrefix = \\\"W\\\";\\n    }\\n\\n    string memory xStr;\\n    if (x >= 0) {\\n      xStr = Strings.toString(uint256(int256(x)));\\n    } else {\\n      unchecked {\\n        xStr = Strings.toString(uint256(-int256(x)));\\n      }\\n    }\\n\\n    string memory yPrefix = \\\"\\\";\\n    if (y > 0) {\\n      yPrefix = \\\"N\\\";\\n    }\\n    if (y < 0) {\\n      yPrefix = \\\"S\\\";\\n    }\\n\\n    string memory yStr;\\n    if (y >= 0) {\\n      yStr = Strings.toString(uint256(int256(y)));\\n    } else {\\n      unchecked {\\n        yStr = Strings.toString(uint256(-int256(y)));\\n      }\\n    }\\n\\n    sx = string(abi.encodePacked(xPrefix, xStr));\\n    sy = string(abi.encodePacked(yPrefix, yStr));\\n  }\\n\\n  function tokenMeta(Meta memory meta)\\n    external\\n    pure\\n    override\\n    returns (string memory result)\\n  {\\n    (string memory sx, string memory sy) = getCoordinatesStrings(\\n      meta.x,\\n      meta.y\\n    );\\n\\n    string[14] memory parts;\\n    parts[\\n      0\\n    ] = '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 360 360\\\"><rect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"#353535\\\" /><foreignObject width=\\\"360\\\" height=\\\"360\\\" x=\\\"0\\\" y=\\\"0\\\"><body xmlns=\\\"http://www.w3.org/1999/xhtml\\\"><style>.a{font-family:sans-serif;margin:10px;color:#fdf9f3;text-align:center;}.g{font-size:16px;font-weight:500;height:25px;margin-top:0px;}.b{font-size:12px;line-height:35px;margin-top:20px;}.c{margin:5px 0 auto auto;font-weight:800;font-size:0;height:45px;line-height:40px;}.c > span {vertical-align:middle;}.d{font-size:2rem;}.e{background-repeat: no-repeat;background-image: url(\\\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAoCAMAAADezbogAAAC/VBMVEUAAAD/sHbatIrGjGzmu4XKjlfuypfjtYTkuozMk3LpwY3Tll/qxZjovYbern7pv4jjtYHnvo+2ZzTgqnPMklzfs4nrw4/bq33owpXSnWzmtnnVoXLWnmm1ZTXVoG/EgEbPl2TvzZm3bEW6cETNmm3OmGiqTTbSpX69e03y2Ky6e2vouYjnu4Lcqne0a0K7cELrw5HMiFepUy3dsIPUnGa5ZTfnvIi6cUDAeUTVonK+d0Lfs4bEhU3OlGDTmmXkuYfFiVO5dFDgtorsxY/vzJvrwonQm2ypTzPw0qfCgEvtx5PrwYTLlGPBfUjrwYahMx3DhFXqv37QnW7iv5PDhF69dEzGhlTQpY7Bd2DwyIrkt4TOlF3AeEq/dkmfLRLEf1KvYTepPRrYqHrJjVfIjlnaqXntypa4bjrGiVTLkV7AfUnHiU/RmmnbrIC7dUbLiVLpvYWxWSraqoDUnWvToG+lQSOhPyfLk2KtUjXuzJzKkV7SoHPtx5LrxY3Yq4PUmW60ZELFiVTqw4ehNB/kw5+zYE3JmmuPGAjuypfvy5nuyZXuyJPvzJvux5DsxY/vzZ3sxpHtxY3ux5PsxIvuyZTtx5bsxpTswojqwIjrwYrmvIndsITbrIHnuX7lvJHjuY/rw47sxI3ov4vkuYjjtofrw5LqwpDmvY3luozesojfsYHZm2Lvy5jowI/sxIrpvYPhsHzrtXrZp3fYlVvvzp/pwpPit4vgs4frwYbqv4bkuIXgs4TvvIK/dj//2J391Zvnv5Phtormt4LcpnPYpHHdo23Pl2PUmGLNk2DPk1vBfEPw0KLzxI75yYfvvYfrwILbq33msHrZom7Tnmzcn2jQhVDDgErDfUjCcUC7cDm5aTm4YzO5azC0YSqvVirryJr80Zf1yJbwxIvfs4v1xYbpu37aqHnqsHjfqnfkq3TQmmfCbjS4SiCxNhX30J/7zo7twYzrvYnlsoLmsoDfsoDgr37ipm7lqmngo2XWk2PHhlXKi1LFh07Fhk3Lfk2uHjBdAAAAiHRSTlMAAQMF/v7+/vsK/v79/f38/PrF/v79+/v6xf7+/v78+8aOeVJLOTIqHxkQ/v7+/v38/Pz7+PHv6NXQ0MbBurmwsKqppqGXk46NgXVycnJsa2VgXEZDPjAbFv79/Pz8/Pv59vX18/Lv7+rg3dzZ1c/NzMK4t66toqGflZCOg4B3dnBqYkkqKCYgy38ewgAABE5JREFUOMt1k3OQHEEUxjvJ7t3llLvwYtu2bdu2bSfd06O17T3bdmzbtlXp2638mVfdNVXzvd97r743A8qB/0S5lpNHjACg2f6GQ4cOHjxkyM6Ge/aOHj1u4qGJ40aNath/Q7cH996AZvNex2bdy87OysrKPv329OlHjzJiH5y6/+7L8yrFl7+D8a8Xdoyo7kP7yKuHzvJrW6dLScerc+bOb99pQd3uAxuB8a8CYnijPcdgOFe76Ef7Gzfv3Ol0p+71G+3aXRtIJjj88vZVfVzcxRclVzJv3r5963rmlSslVYvitDXO7wMVwfGuxULhCRKZmVd/Cau+uFhQkB/82W1NdlkngwoAbIyvf+vW9d9Viy5qNenpvpa0vDapSpUuL6Ze8zK50cv6wqICjUHvSAyUG1UmViRiRKxKkLeoJSgPwDRhXLA18S7HYchxkGF4nqIRLat+qr/HsoprPvhG+tA0R1EIRkBKgSmO5uXVTw0iMMnY0tovUk4hDklpBDkYBTkaSYyCM70JS7oPOxNqM2LMQXzyJJQyIkhjilVWOb+JoKRA87W2DjoW0bQUJUCEGYqi5HJjyNOaRCanVc/3QbpUjkMQQoqDNKQQz/v71hlDUFK8aWGI2S6DERglcDRNIyyixCpBlZXTvcVbCGMiZTRENEpISEAUljJiNloXHD7AO3mrdRcEvA8FMck4CUUsjxlldHTI875lNLkT6tRSYhSBpaisLctikZhXCmJrAo8KenzTRbOQcGVDsxLyFKtSKxHZG+u/1npswjgCsxRmoxSKKJHksa5NbE/gxRvEVjKKGQkDWUmUJOXsWYWJja4leDoMVPDI/TIq8ViMWWIZg0VnU1JYSaou5NKUssnJ7ZsRpPRBUorYgkUmRZRCkpJa6XwDQv6jjcQwMc1gRqEQi0S8RCX4uPtYRW/vzRn+PEJICiOQmIEUSTGx/tZ6wuZeX2qe6SBHmGKkNEVzyCSRSEzGSKe7uCmRSTTI81dRUMxIIQMRjGJ5cXRQUFqN4iagAoHLr67SWiUjjlEIi2mTUimXmdVm3+DCSV65T3yIjeUpmUyuYmVKnc4/Uq22WDsXjiEyOU0WtzXb7DKZzWa3m4PMAkGiw2JJr3Fpl4eueHD7UrXZHGizJyaqBQ61Iycnx5nkquHZKPkcAgLy09LUgZFqhyXN4nTq9fqk3GRN7Z+9gKd2/hO31enQOy1W33R3usGQm+RyaeIKSpdPB+QvmxSj1SQbDIbk3ORgl0ar1WiqJentypmlmVMI3rL3s9pxWtfDh9pz2ifac+5cx10fTJaTUv9yIwCOLMuWqz+5Na5q1TpX8/MLDQ0LDAyz+MbEuOtd3gHAoPvdQsPC/Pz0SU7rs8Lw+PjwC/kXAkqFs6t2+bMNgD7kRfil8IDSkiUrVlUui149unete+PatZuvhgPQovHYkSPHTmg8dVqLGZ4NgvIVWs04OrXxgeFbm4G/oWYM72q5ssUAAAAASUVORK5CYII=\\\");background-size:100% 100%;display:inline-block;font-size:1.2rem;line-height:40px;}.f{padding:0px 10px;display:inline-block;color:#a4752a;}.h{font-size:12px;margin:50px 0 0 50px;text-align:left;-webkit-transform-origin-x:0;-webkit-transform :scale(0.8,0.8);}ul{list-style-type:disc;margin:0 0 0 -20px;}.i{margin:5px;justify-content: center;display:grid;grid-template-columns:repeat(3,max-content);grid-template-row:repeat(3,auto);grid-column-gap:5px;justify-items:start;}</style><div class=\\\"a\\\"><div class=\\\"b\\\">PEOPLELAND</div><div class=\\\"c\\\"><span class=\\\"d\\\">(</span><span class=\\\"e\\\"><span class=\\\"f\\\">';\\n\\n    parts[1] = sx;\\n    parts[\\n      2\\n    ] = '</span></span><span class=\\\"d\\\">,</span><span class=\\\"e\\\"><span class=\\\"f\\\">';\\n    parts[3] = sy;\\n    parts[4] = '</span></span><span class=\\\"d\\\">)</span></div><div class=\\\"g\\\">';\\n    parts[5] = _getSlogan(meta.slogan);\\n    parts[6] = '</div><div class=\\\"h\\\"><ul>';\\n    parts[7] = _getInviteString(meta.isPeople, meta.isBuidler, meta.invite);\\n    parts[8] = _getMintAndGiveToStr(meta.mintedAndInvitedList);\\n    parts[9] = '<li>Neighbors:</li></ul><div class=\\\"i\\\">';\\n    parts[10] = _getNeighborsStr(meta.neighbors);\\n    parts[11] = \\\"</div><ul><li>\\\";\\n    parts[12] = _getEndTip(meta.mintedAndInvitedList.length);\\n    parts[13] = \\\"</li></ul></div></div></body></foreignObject></svg>\\\";\\n\\n    string memory svgStr = string(\\n      abi.encodePacked(\\n        parts[0],\\n        parts[1],\\n        parts[2],\\n        parts[3],\\n        parts[4],\\n        parts[5],\\n        parts[6],\\n        parts[7],\\n        parts[8]\\n      )\\n    );\\n\\n    svgStr = string(\\n      abi.encodePacked(\\n        svgStr,\\n        parts[9],\\n        parts[10],\\n        parts[11],\\n        parts[12],\\n        parts[13]\\n      )\\n    );\\n\\n    string memory json = Base64.encode(\\n      bytes(\\n        string(\\n          abi.encodePacked(\\n            '{\\\"name\\\": \\\"Land #',\\n            Strings.toString(meta.tokenId),\\n            '\\\", \\\"description\\\": \\\"',\\n            DESC,\\n            '\\\", \\\"image\\\": \\\"data:image/svg+xml;base64,',\\n            Base64.encode(bytes(svgStr)),\\n            '\\\"}'\\n          )\\n        )\\n      )\\n    );\\n    result = string(abi.encodePacked(\\\"data:application/json;base64,\\\", json));\\n  }\\n\\n  function _getSlogan(string memory _slogan)\\n    private\\n    pure\\n    returns (string memory)\\n  {\\n    return\\n      bytes(_slogan).length > 0\\n        ? _slogan\\n        : \\\"<br/>For the PEOPLE of<br/>ConstitutionDAO who made history\\\";\\n  }\\n\\n  function _getInviteString(\\n    bool isPeople,\\n    bool isBuilder,\\n    TokenInfo memory info\\n  ) private pure returns (string memory result) {\\n    if (isPeople) {\\n      result = \\\"I'm this PEOPLE ^_^\\\";\\n    } else if (isBuilder) {\\n      result = \\\"I'm the BUILDER ^_^\\\";\\n    } else {\\n      result = string(\\n        abi.encodePacked(\\n          \\\"Thanks to \\\",\\n          _getTokenIdAndCoordinatesString(info.tokenId, info.x, info.y),\\n          \\\" for the invite\\\"\\n        )\\n      );\\n    }\\n\\n    result = string(abi.encodePacked(\\\"<li>\\\", result, \\\"</li>\\\"));\\n  }\\n\\n  function _getMintAndGiveToStr(TokenInfo[] memory infos)\\n    private\\n    pure\\n    returns (string memory _str)\\n  {\\n    string memory _mintStr = \\\"\\\";\\n    string memory _giveToStr = \\\"\\\";\\n    if (infos.length != 0) {\\n      for (uint8 i = 0; i < infos.length; i++) {\\n        TokenInfo memory info = infos[i];\\n        if (info.hasTokenId) {\\n          _giveToStr = string(\\n            abi.encodePacked(\\n              _giveToStr,\\n              \\\" \\\",\\n              _getTokenIdAndCoordinatesString(info.tokenId, info.x, info.y)\\n            )\\n          );\\n        } else {\\n          _mintStr = string(\\n            abi.encodePacked(\\n              _mintStr,\\n              \\\" \\\",\\n              _getCoordinatesString(info.x, info.y)\\n            )\\n          );\\n        }\\n      }\\n      _str = string(\\n        abi.encodePacked(\\n          bytes(_mintStr).length == 0\\n            ? \\\"\\\"\\n            : string(abi.encodePacked(\\\"<li>Minted\\\", _mintStr, \\\"</li>\\\")),\\n          bytes(_giveToStr).length == 0\\n            ? \\\"\\\"\\n            : string(abi.encodePacked(\\\"<li>Invited\\\", _giveToStr, \\\"</li>\\\"))\\n        )\\n      );\\n    }\\n  }\\n\\n  function _getNeighborsStr(string[] memory tokenIds)\\n    private\\n    pure\\n    returns (string memory _str)\\n  {\\n    string[8] memory _arr;\\n    for (uint8 i = 0; i < 8; i++) {\\n      _arr[i] = string(abi.encodePacked(\\\"<div>#\\\", tokenIds[i], \\\"</div>\\\"));\\n    }\\n    _str = string(\\n      abi.encodePacked(\\n        _arr[0],\\n        _arr[1],\\n        _arr[2],\\n        _arr[3],\\n        \\\"<div>Me</div>\\\",\\n        _arr[4],\\n        _arr[5],\\n        _arr[6],\\n        _arr[7]\\n      )\\n    );\\n  }\\n\\n  function _getEndTip(uint256 count) private pure returns (string memory) {\\n    if (count >= 2) {\\n      return \\\"Imagine and build!\\\";\\n    }\\n    return \\\"I'm carefully selecting our neighbors!\\\";\\n  }\\n\\n  function _getTokenIdAndCoordinatesString(\\n    uint256 tokenId,\\n    int128 x,\\n    int128 y\\n  ) private pure returns (string memory _str) {\\n    _str = string(\\n      abi.encodePacked(\\n        \\\"#\\\",\\n        Strings.toString(tokenId),\\n        _getCoordinatesString(x, y)\\n      )\\n    );\\n  }\\n\\n  function _getCoordinatesString(int128 x, int128 y)\\n    private\\n    pure\\n    returns (string memory _str)\\n  {\\n    (string memory sx, string memory sy) = getCoordinatesStrings(x, y);\\n    _str = string(abi.encodePacked(\\\"(\\\", sx, \\\",\\\", sy, \\\")\\\"));\\n  }\\n}\\n\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenSVG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ITokenSVG {\\n  struct TokenInfo {\\n    int128 x;\\n    int128 y;\\n    uint256 tokenId;\\n    bool hasTokenId;\\n  }\\n\\n  struct Meta {\\n    int128 x;\\n    int128 y;\\n    uint256 tokenId;\\n    string slogan;\\n    bool isPeople;\\n    bool isBuidler;\\n    TokenInfo invite;\\n    TokenInfo[] mintedAndInvitedList;\\n    string[] neighbors;\\n  }\\n\\n  function getCoordinatesStrings(int128 x, int128 y)\\n    external\\n    pure\\n    returns (string memory sx, string memory sy);\\n\\n  function tokenMeta(Meta memory meta)\\n    external\\n    pure\\n    returns (string memory result);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"name\":\"DESC\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int128\",\"name\":\"x\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"y\",\"type\":\"int128\"}],\"name\":\"getCoordinatesStrings\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"sx\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sy\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"int128\",\"name\":\"x\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"y\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"slogan\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isPeople\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isBuidler\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"int128\",\"name\":\"x\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"y\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasTokenId\",\"type\":\"bool\"}],\"internalType\":\"struct ITokenSVG.TokenInfo\",\"name\":\"invite\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"int128\",\"name\":\"x\",\"type\":\"int128\"},{\"internalType\":\"int128\",\"name\":\"y\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasTokenId\",\"type\":\"bool\"}],\"internalType\":\"struct ITokenSVG.TokenInfo[]\",\"name\":\"mintedAndInvitedList\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"neighbors\",\"type\":\"string[]\"}],\"internalType\":\"struct ITokenSVG.Meta\",\"name\":\"meta\",\"type\":\"tuple\"}],\"name\":\"tokenMeta\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"result\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"TokenSVG","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}