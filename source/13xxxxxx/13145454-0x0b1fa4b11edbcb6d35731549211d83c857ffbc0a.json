{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@aragon/os/contracts/lib/math/Math.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title Math\\n * @dev Assorted math operations\\n */\\n\\nlibrary Math {\\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\\n    return a >= b ? a : b;\\n  }\\n\\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\\n    return a < b ? a : b;\\n  }\\n\\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a >= b ? a : b;\\n  }\\n\\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/lib/math/SafeMath.sol\": {\r\n      \"content\": \"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\\n// Adapted to use pragma ^0.4.24 and satisfy our linter rules\\n\\npragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that revert on error\\n */\\nlibrary SafeMath {\\n    string private constant ERROR_ADD_OVERFLOW = \\\"MATH_ADD_OVERFLOW\\\";\\n    string private constant ERROR_SUB_UNDERFLOW = \\\"MATH_SUB_UNDERFLOW\\\";\\n    string private constant ERROR_MUL_OVERFLOW = \\\"MATH_MUL_OVERFLOW\\\";\\n    string private constant ERROR_DIV_ZERO = \\\"MATH_DIV_ZERO\\\";\\n\\n    /**\\n    * @dev Multiplies two numbers, reverts on overflow.\\n    */\\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\\n        if (_a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = _a * _b;\\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n    */\\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\\n        uint256 c = _a / _b;\\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\\n        uint256 c = _a - _b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, reverts on overflow.\\n    */\\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        uint256 c = _a + _b;\\n        require(c >= _a, ERROR_ADD_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0, ERROR_DIV_ZERO);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@aragon/os/contracts/lib/math/SafeMath64.sol\": {\r\n      \"content\": \"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\\n// Adapted for uint64, pragma ^0.4.24, and satisfying our linter rules\\n// Also optimized the mul() implementation, see https://github.com/aragon/aragonOS/pull/417\\n\\npragma solidity ^0.4.24;\\n\\n\\n/**\\n * @title SafeMath64\\n * @dev Math operations for uint64 with safety checks that revert on error\\n */\\nlibrary SafeMath64 {\\n    string private constant ERROR_ADD_OVERFLOW = \\\"MATH64_ADD_OVERFLOW\\\";\\n    string private constant ERROR_SUB_UNDERFLOW = \\\"MATH64_SUB_UNDERFLOW\\\";\\n    string private constant ERROR_MUL_OVERFLOW = \\\"MATH64_MUL_OVERFLOW\\\";\\n    string private constant ERROR_DIV_ZERO = \\\"MATH64_DIV_ZERO\\\";\\n\\n    /**\\n    * @dev Multiplies two numbers, reverts on overflow.\\n    */\\n    function mul(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        uint256 c = uint256(_a) * uint256(_b);\\n        require(c < 0x010000000000000000, ERROR_MUL_OVERFLOW); // 2**64 (less gas this way)\\n\\n        return uint64(c);\\n    }\\n\\n    /**\\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\\n    */\\n    function div(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\\n        uint64 c = _a / _b;\\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\\n    */\\n    function sub(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\\n        uint64 c = _a - _b;\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Adds two numbers, reverts on overflow.\\n    */\\n    function add(uint64 _a, uint64 _b) internal pure returns (uint64) {\\n        uint64 c = _a + _b;\\n        require(c >= _a, ERROR_ADD_OVERFLOW);\\n\\n        return c;\\n    }\\n\\n    /**\\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\\n    * reverts when dividing by zero.\\n    */\\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\\n        require(b != 0, ERROR_DIV_ZERO);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/governance/VotingStakingRewards.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\nimport \\\"@aragon/os/contracts/lib/math/SafeMath.sol\\\";\\nimport \\\"@aragon/os/contracts/lib/math/SafeMath64.sol\\\";\\nimport \\\"@aragon/os/contracts/lib/math/Math.sol\\\";\\n\\nimport \\\"./interfaces/IVeXBE.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IBoostLogicProvider.sol\\\";\\n\\nimport \\\"./utils/VotingPausable.sol\\\";\\nimport \\\"./utils/VotingNonReentrant.sol\\\";\\nimport \\\"./utils/VotingOwnable.sol\\\";\\nimport \\\"./utils/VotingInitializable.sol\\\";\\n\\ncontract VotingStakingRewards is\\n    VotingPausable,\\n    VotingNonReentrant,\\n    VotingOwnable,\\n    VotingInitializable\\n{\\n    using SafeMath for uint256;\\n\\n    /* ========== EVENTS ========== */\\n\\n    event RewardAdded(uint256 reward);\\n    event Staked(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RewardPaid(address indexed user, uint256 reward);\\n\\n    uint256 public constant PCT_BASE = 10**18; // 0% = 0; 1% = 10^16; 100% = 10^18\\n    uint256 internal constant MAX_BOOST_LEVEL = PCT_BASE;\\n\\n    address public treasury;\\n\\n    struct BondedReward {\\n        uint256 amount;\\n        uint256 unlockTime;\\n    }\\n\\n    mapping(address => bool) public allowance;\\n    mapping(address => BondedReward) public bondedRewardLocks;\\n\\n    uint256 public penaltyPct = PCT_BASE / 2; // PCT_BASE is 10^18\\n\\n    uint256 public inverseMaxBoostCoefficient = 40; // 1 / inverseMaxBoostCoefficient = max boost coef. (ex. if 40 then 1 / (40 / 100) = 2.5)\\n\\n    IERC20 public rewardsToken;\\n    IERC20 public stakingToken;\\n    uint256 public periodFinish;\\n    uint256 public rewardRate;\\n    uint256 public rewardsDuration;\\n    uint256 public lastUpdateTime;\\n    uint256 public rewardPerTokenStored;\\n    address public rewardsDistribution;\\n    uint256 public bondedLockDuration;\\n\\n    mapping(address => uint256) public userRewardPerTokenPaid;\\n    mapping(address => uint256) public rewards;\\n\\n    uint256 public totalSupply;\\n    mapping(address => uint256) internal _balances;\\n\\n    IVeXBE public token;\\n    IBoostLogicProvider public boostLogicProvider;\\n\\n    function configure(\\n        address _rewardsDistribution,\\n        IERC20 _rewardsToken,\\n        IERC20 _stakingToken,\\n        uint256 _rewardsDuration,\\n        IVeXBE _token,\\n        IBoostLogicProvider _boostLogicProvider,\\n        address _treasury,\\n        uint256 _bondedLockDuration,\\n        address[] memory _allowance\\n    ) public initializer {\\n        rewardsToken = _rewardsToken;\\n        stakingToken = _stakingToken;\\n        rewardsDistribution = _rewardsDistribution;\\n        rewardsDuration = _rewardsDuration;\\n        token = _token;\\n        boostLogicProvider = _boostLogicProvider;\\n        treasury = _treasury;\\n        require(_bondedLockDuration > 0, \\\"badBondDuration\\\");\\n        bondedLockDuration = _bondedLockDuration;\\n        for (uint256 i = 0; i < _allowance.length; i++) {\\n            allowance[_allowance[i]] = true;\\n        }\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier updateReward(address account) {\\n        uint256 _lastTimeReward = lastTimeRewardApplicable();\\n        uint256 _duration = _lastTimeReward.sub(lastUpdateTime);\\n        rewardPerTokenStored = _rewardPerToken(_duration);\\n        lastUpdateTime = _lastTimeReward;\\n        if (account != address(0)) {\\n            (uint256 userEarned, uint256 toTreasury) = potentialXbeReturns(\\n                0,\\n                account\\n            );\\n            rewards[account] = userEarned;\\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\\n            // transfer remaining reward share to treasury\\n            if (toTreasury > 0) {\\n                require(\\n                    stakingToken.transfer(treasury, toTreasury),\\n                    \\\"!boostDelta\\\"\\n                );\\n            }\\n        }\\n        _;\\n    }\\n\\n    modifier onlyRewardsDistribution() {\\n        require(\\n            msg.sender == rewardsDistribution,\\n            \\\"Caller is not RewardsDistribution contract\\\"\\n        );\\n        _;\\n    }\\n\\n    /* ========== OWNERS FUNCTIONS ========== */\\n\\n    function setRewardsDistribution(address _rewardsDistribution)\\n        external\\n        onlyOwner\\n    {\\n        rewardsDistribution = _rewardsDistribution;\\n    }\\n\\n    function setInverseMaxBoostCoefficient(uint256 _inverseMaxBoostCoefficient)\\n        external\\n        onlyOwner\\n    {\\n        inverseMaxBoostCoefficient = _inverseMaxBoostCoefficient;\\n        require(\\n            _inverseMaxBoostCoefficient > 0 &&\\n                _inverseMaxBoostCoefficient < 100,\\n            \\\"invalidInverseMaxBoostCoefficient\\\"\\n        );\\n    }\\n\\n    function setPenaltyPct(uint256 _penaltyPct) external onlyOwner {\\n        penaltyPct = _penaltyPct;\\n        require(_penaltyPct < PCT_BASE, \\\"tooHighPct\\\");\\n    }\\n\\n    function setBondedLockDuration(uint256 _bondedLockDuration)\\n        external\\n        onlyOwner\\n    {\\n        bondedLockDuration = _bondedLockDuration;\\n    }\\n\\n    function setBoostLogicProvider(address _boostLogicProvider)\\n        external\\n        onlyOwner\\n    {\\n        boostLogicProvider = IBoostLogicProvider(_boostLogicProvider);\\n    }\\n\\n    function setAddressWhoCanAutoStake(address _addr, bool _flag)\\n        external\\n        onlyOwner\\n    {\\n        allowance[_addr] = _flag;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function balanceOf(address account) external view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function lastTimeRewardApplicable() public view returns (uint256) {\\n        return Math.min256(block.timestamp, periodFinish);\\n    }\\n\\n    function rewardPerToken() external view returns (uint256) {\\n        return _rewardPerToken(lastTimeRewardApplicable().sub(lastUpdateTime));\\n    }\\n\\n    function _rewardPerToken(uint256 duration) internal view returns (uint256) {\\n        if (totalSupply == 0) {\\n            return rewardPerTokenStored;\\n        }\\n        return\\n            rewardPerTokenStored.add(\\n                duration.mul(rewardRate).mul(PCT_BASE).div(totalSupply)\\n            );\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function notifyRewardAmount(uint256 reward)\\n        external\\n        onlyRewardsDistribution\\n        updateReward(address(0))\\n    {\\n        if (block.timestamp >= periodFinish) {\\n            rewardRate = reward.div(rewardsDuration);\\n        } else {\\n            uint256 remaining = periodFinish.sub(block.timestamp);\\n            uint256 leftover = remaining.mul(rewardRate);\\n            rewardRate = reward.add(leftover).div(rewardsDuration);\\n        }\\n\\n        // Ensure the provided reward amount is not more than the balance in the contract.\\n        // This keeps the reward rate in the right range, preventing overflows due to\\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\\n        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\\n        uint256 balance = rewardsToken.balanceOf(address(this));\\n        require(\\n            rewardRate <= balance.div(rewardsDuration),\\n            \\\"Provided reward too high\\\"\\n        );\\n\\n        lastUpdateTime = block.timestamp;\\n        periodFinish = block.timestamp.add(rewardsDuration);\\n        emit RewardAdded(reward);\\n    }\\n\\n    function _stake(address _for, uint256 _amount) internal {\\n        require(_amount > 0, \\\"Cannot stake 0\\\");\\n        totalSupply = totalSupply.add(_amount);\\n        _balances[_for] = _balances[_for].add(_amount);\\n\\n        require(\\n            stakingToken.transferFrom(msg.sender, address(this), _amount),\\n            \\\"!t\\\"\\n        );\\n        emit Staked(_for, _amount);\\n    }\\n\\n    function stakeFor(address _for, uint256 amount)\\n        external\\n        nonReentrant\\n        whenNotPaused\\n        updateReward(_for)\\n    {\\n        require(allowance[msg.sender], \\\"stakeNotApproved\\\");\\n\\n        _stake(_for, amount);\\n\\n        BondedReward memory rewardLock = bondedRewardLocks[_for];\\n        if (block.timestamp >= rewardLock.unlockTime) {\\n            bondedRewardLocks[_for].amount = amount;\\n        } else {\\n            bondedRewardLocks[_for].amount = rewardLock.amount.add(amount);\\n        }\\n        bondedRewardLocks[_for].unlockTime = block.timestamp.add(\\n            bondedLockDuration\\n        );\\n    }\\n\\n    function stake(uint256 amount)\\n        external\\n        nonReentrant\\n        whenNotPaused\\n        updateReward(msg.sender)\\n    {\\n        _stake(msg.sender, amount);\\n    }\\n\\n    function withdrawBondedOrWithPenalty()\\n        external\\n        nonReentrant\\n        updateReward(msg.sender)\\n    {\\n        uint256 amount = bondedRewardLocks[msg.sender].amount;\\n        uint256 escrowed = token.lockedAmount(msg.sender);\\n        amount = Math.min256(amount, _balances[msg.sender].sub(escrowed));\\n\\n        totalSupply = totalSupply.sub(amount);\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n        if (block.timestamp >= bondedRewardLocks[msg.sender].unlockTime) {\\n            require(stakingToken.transfer(msg.sender, amount), \\\"!tBonded\\\");\\n        } else {\\n            uint256 penalty = amount.mul(penaltyPct).div(PCT_BASE);\\n            uint256 toTransfer = amount.sub(penalty);\\n            require(\\n                stakingToken.transfer(msg.sender, toTransfer),\\n                \\\"!tBondedWithPenalty\\\"\\n            );\\n            require(stakingToken.transfer(treasury, penalty), \\\"!tPenalty\\\");\\n        }\\n        delete bondedRewardLocks[msg.sender];\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    function withdrawUnbonded(uint256 amount)\\n        external\\n        nonReentrant\\n        updateReward(msg.sender)\\n    {\\n        require(amount > 0, \\\"!withdraw0\\\");\\n\\n        uint256 escrowed = token.lockedAmount(msg.sender);\\n        require(\\n            _balances[msg.sender].sub(escrowed).sub(\\n                bondedRewardLocks[msg.sender].amount\\n            ) >= amount,\\n            \\\"escrow amount failure\\\"\\n        );\\n\\n        totalSupply = totalSupply.sub(amount);\\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\\n\\n        require(stakingToken.transfer(msg.sender, amount), \\\"!t\\\");\\n\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    function _baseBoostLevel() internal view returns (uint256) {\\n        return PCT_BASE.mul(inverseMaxBoostCoefficient).div(100);\\n    }\\n\\n    function _lockedBoostLevel(address account)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        IVeXBE veXBE = token;\\n        uint256 votingBalance = veXBE.balanceOf(account);\\n        uint256 votingTotal = veXBE.totalSupply();\\n        uint256 lockedAmount = veXBE.lockedAmount(account);\\n        if (votingTotal == 0 || votingBalance == 0) {\\n            return _baseBoostLevel();\\n        }\\n\\n        uint256 res = PCT_BASE\\n            .mul(inverseMaxBoostCoefficient)\\n            .add(\\n                uint256(100)\\n                    .sub(inverseMaxBoostCoefficient)\\n                    .mul(PCT_BASE)\\n                    .mul(veXBE.lockedSupply())\\n                    .div(votingTotal)\\n                    .mul(votingBalance)\\n                    .div(lockedAmount)\\n            )\\n            .div(100);\\n\\n        return res < MAX_BOOST_LEVEL ? res : MAX_BOOST_LEVEL;\\n    }\\n\\n    function calculateBoostLevel(address account)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        IVeXBE veXBE = token;\\n        uint256 lockedAmount = veXBE.lockedAmount(account);\\n\\n        uint256 stakedAmount = _balances[account];\\n        if (stakedAmount == 0 || lockedAmount == 0) {\\n            return _baseBoostLevel();\\n        }\\n\\n        uint256 lockedBoost = boostLogicProvider.hasMaxBoostLevel(account)\\n            ? MAX_BOOST_LEVEL\\n            : _lockedBoostLevel(account);\\n\\n        return\\n            lockedBoost\\n                .mul(lockedAmount)\\n                .add(_baseBoostLevel().mul(stakedAmount.sub(lockedAmount)))\\n                .div(stakedAmount);\\n    }\\n\\n    function earned(address account)\\n        external\\n        view\\n        returns (\\n            uint256 // userEarned\\n        )\\n    {\\n        uint256 duration = lastTimeRewardApplicable().sub(lastUpdateTime);\\n        (uint256 userEarned, ) = potentialXbeReturns(duration, account);\\n        return userEarned;\\n    }\\n\\n    function potentialXbeReturns(uint256 duration, address account)\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256 // userEarned, toTreasury\\n        )\\n    {\\n        uint256 boostLevel = calculateBoostLevel(account);\\n        require(boostLevel <= MAX_BOOST_LEVEL, \\\"badBoostLevel\\\");\\n\\n        uint256 maxBoostedReward = _balances[account]\\n            .mul(_rewardPerToken(duration).sub(userRewardPerTokenPaid[account]))\\n            .div(PCT_BASE);\\n\\n        uint256 toUser = maxBoostedReward.mul(boostLevel).div(PCT_BASE);\\n        uint256 toTreasury = maxBoostedReward.sub(toUser);\\n\\n        return (toUser.add(rewards[account]), toTreasury);\\n    }\\n\\n    function getReward() external nonReentrant updateReward(msg.sender) {\\n        uint256 reward = rewards[msg.sender];\\n        if (reward > 0) {\\n            rewards[msg.sender] = 0;\\n            require(rewardsToken.transfer(msg.sender, reward), \\\"!t\\\");\\n            emit RewardPaid(msg.sender, reward);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/governance/interfaces/IBoostLogicProvider.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\ninterface IBoostLogicProvider {\\n    function hasMaxBoostLevel(address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/governance/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/governance/interfaces/IVeXBE.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\ninterface IVeXBE {\\n    function getLastUserSlope(address addr) external view returns (int128);\\n\\n    function lockedEnd(address addr) external view returns (uint256);\\n\\n    function lockedAmount(address addr) external view returns (uint256);\\n\\n    function userPointEpoch(address addr) external view returns (uint256);\\n\\n    function userPointHistoryTs(address addr, uint256 epoch)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOfAt(address addr, uint256 _block)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function balanceOf(address addr) external view returns (uint256);\\n\\n    function balanceOf(address addr, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function lockedSupply() external view returns (uint256);\\n\\n    function lockStarts(address addr) external view returns (uint256);\\n\\n    function totalSupplyAt(uint256 _block) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/contracts/governance/utils/VotingInitializable.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\ncontract VotingInitializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"alreadyInitialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/governance/utils/VotingNonReentrant.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\ncontract VotingNonReentrant {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n    uint256 private _status = _NOT_ENTERED;\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/governance/utils/VotingOwnable.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\ncontract VotingOwnable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"!owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"owner0\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/governance/utils/VotingPausable.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\ncontract VotingPausable {\\n    bool public paused;\\n    address private pauser;\\n\\n    constructor() public {\\n        pauser = msg.sender;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(!paused, \\\"paused\\\");\\n        _;\\n    }\\n\\n    function setPaused(bool _paused) external {\\n        require(msg.sender == pauser, \\\"!pauser\\\");\\n        paused = _paused;\\n    }\\n\\n    function transferOwnership(address newPauser) public {\\n        require(msg.sender == pauser, \\\"!pauser\\\");\\n        pauser = newPauser;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"byzantium\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBondedOrWithPenalty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"potentialXbeReturns\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rewardsDistribution\",\"type\":\"address\"}],\"name\":\"setRewardsDistribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_for\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"penaltyPct\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsDistribution\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"calculateBoostLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setAddressWhoCanAutoStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_inverseMaxBoostCoefficient\",\"type\":\"uint256\"}],\"name\":\"setInverseMaxBoostCoefficient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_penaltyPct\",\"type\":\"uint256\"}],\"name\":\"setPenaltyPct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawUnbonded\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rewardsDistribution\",\"type\":\"address\"},{\"name\":\"_rewardsToken\",\"type\":\"address\"},{\"name\":\"_stakingToken\",\"type\":\"address\"},{\"name\":\"_rewardsDuration\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_boostLogicProvider\",\"type\":\"address\"},{\"name\":\"_treasury\",\"type\":\"address\"},{\"name\":\"_bondedLockDuration\",\"type\":\"uint256\"},{\"name\":\"_allowance\",\"type\":\"address[]\"}],\"name\":\"configure\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerTokenPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bondedLockDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bondedLockDuration\",\"type\":\"uint256\"}],\"name\":\"setBondedLockDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_boostLogicProvider\",\"type\":\"address\"}],\"name\":\"setBoostLogicProvider\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bondedRewardLocks\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inverseMaxBoostCoefficient\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"boostLogicProvider\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PCT_BASE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"VotingStakingRewards","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"byzantium","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}