{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/WallexBankToken.sol\": {\r\n      \"content\": \"\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"./tools/ERC1820Client.sol\\\";\\nimport \\\"./interface/ERC1820Implementer.sol\\\";\\n\\nimport \\\"./roles/MinterRole.sol\\\";\\n\\nimport \\\"./IERC1400.sol\\\";\\n\\n// Extensions\\nimport \\\"./extensions/tokenExtensions/IERC1400TokensValidator.sol\\\";\\nimport \\\"./extensions/userExtensions/IERC1400TokensSender.sol\\\";\\nimport \\\"./extensions/userExtensions/IERC1400TokensRecipient.sol\\\";\\nimport \\\"./tools/DomainAware.sol\\\";\\n\\n\\n/**\\n * The contract and its abstract interfaces are utilised and constructed from UniversalToken implementatation \\n * with modifications done to suit the Wallex ecosystem\\n * See https://github.com/ConsenSys/UniversalToken\\n * @title WallexBankToken\\n * @dev WallexBankToken logic\\n */\\ncontract WallexBankToken is IERC20, IERC1400, Ownable, ERC1820Client, ERC1820Implementer, MinterRole, DomainAware {\\n  using SafeMath for uint256;\\n\\n  // Token\\n  string constant internal ERC1400_INTERFACE_NAME = \\\"WallexBankToken\\\";\\n  string constant internal ERC20_INTERFACE_NAME = \\\"ERC20Token\\\";\\n\\n  // Token extensions\\n  string constant internal ERC1400_TOKENS_VALIDATOR = \\\"WallexBankValidator\\\";\\n\\n  // User extensions\\n  string constant internal ERC1400_TOKENS_SENDER = \\\"WallexBankTokensSender\\\";\\n  string constant internal ERC1400_TOKENS_RECIPIENT = \\\"WallexBankTokensRecipient\\\";\\n\\n  /************************************* Token description ****************************************/\\n  string internal _name;\\n  string internal _symbol;\\n  uint256 internal _granularity;\\n  uint256 internal _totalSupply;\\n  bool internal _migrated;\\n  /************************************************************************************************/\\n\\n\\n  /**************************************** Token behaviours **************************************/\\n  // Indicate whether the token can still be controlled by operators or not anymore.\\n  bool internal _isControllable;\\n\\n  // Indicate whether the token can still be issued by the issuer or not anymore.\\n  bool internal _isIssuable;\\n  /************************************************************************************************/\\n\\n\\n  /********************************** ERC20 Token mappings ****************************************/\\n  // Mapping from tokenHolder to balance.\\n  mapping(address => uint256) internal _balances;\\n\\n  // Mapping from (tokenHolder, spender) to allowed value.\\n  mapping (address => mapping (address => uint256)) internal _allowed;\\n  /************************************************************************************************/\\n\\n\\n  /**************************************** Documents *********************************************/\\n  struct Doc {\\n    string docURI;\\n    bytes32 docHash;\\n    uint256 timestamp;\\n  }\\n  // Mapping for documents.\\n  mapping(bytes32 => Doc) internal _documents;\\n  mapping(bytes32 => uint256) internal _indexOfDocHashes;\\n  bytes32[] internal _docHashes;\\n  /************************************************************************************************/\\n\\n\\n  /*********************************** Partitions  mappings ***************************************/\\n  // List of partitions.\\n  bytes32[] internal _totalPartitions;\\n\\n  // Mapping from partition to their index.\\n  mapping (bytes32 => uint256) internal _indexOfTotalPartitions;\\n\\n  // Mapping from partition to global balance of corresponding partition.\\n  mapping (bytes32 => uint256) internal _totalSupplyByPartition;\\n\\n  // Mapping from tokenHolder to their partitions.\\n  mapping (address => bytes32[]) internal _partitionsOf;\\n\\n  // Mapping from (tokenHolder, partition) to their index.\\n  mapping (address => mapping (bytes32 => uint256)) internal _indexOfPartitionsOf;\\n\\n  // Mapping from (tokenHolder, partition) to balance of corresponding partition.\\n  mapping (address => mapping (bytes32 => uint256)) internal _balanceOfByPartition;\\n\\n  // List of token default partitions (for ERC20 compatibility).\\n  bytes32[] internal _defaultPartitions;\\n  /************************************************************************************************/\\n\\n\\n  /********************************* Global operators mappings ************************************/\\n  // Mapping from (operator, tokenHolder) to authorized status. [TOKEN-HOLDER-SPECIFIC]\\n  mapping(address => mapping(address => bool)) internal _authorizedOperator;\\n\\n  // Array of controllers. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\\n  address[] internal _controllers;\\n\\n  // Mapping from operator to controller status. [GLOBAL - NOT TOKEN-HOLDER-SPECIFIC]\\n  mapping(address => bool) internal _isController;\\n  /************************************************************************************************/\\n\\n\\n  /******************************** Partition operators mappings **********************************/\\n  // Mapping from (partition, tokenHolder, spender) to allowed value. [TOKEN-HOLDER-SPECIFIC]\\n  mapping(bytes32 => mapping (address => mapping (address => uint256))) internal _allowedByPartition;\\n\\n  // Mapping from (tokenHolder, partition, operator) to 'approved for partition' status. [TOKEN-HOLDER-SPECIFIC]\\n  mapping (address => mapping (bytes32 => mapping (address => bool))) internal _authorizedOperatorByPartition;\\n\\n  // Mapping from partition to controllers for the partition. [NOT TOKEN-HOLDER-SPECIFIC]\\n  mapping (bytes32 => address[]) internal _controllersByPartition;\\n\\n  // Mapping from (partition, operator) to PartitionController status. [NOT TOKEN-HOLDER-SPECIFIC]\\n  mapping (bytes32 => mapping (address => bool)) internal _isControllerByPartition;\\n  /************************************************************************************************/\\n\\n\\n  /***************************************** Modifiers ********************************************/\\n  /**\\n   * @dev Modifier to verify if token is issuable.\\n   */\\n  modifier isIssuableToken() {\\n    require(_isIssuable, \\\"55\\\"); // 0x55\\tfunds locked (lockup period)\\n    _;\\n  }\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not migrated.\\n   */\\n  modifier isNotMigratedToken() {\\n      require(!_migrated, \\\"54\\\"); // 0x54\\ttransfers halted (contract paused)\\n      _;\\n  }\\n  /**\\n   * @dev Modifier to verifiy if sender is a minter.\\n   */\\n  modifier onlyMinter() override {\\n      require(isMinter(msg.sender) || owner() == _msgSender(), \\\"56\\\");\\n      _;\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /**************************** Events (additional - not mandatory) *******************************/\\n  event ApprovalByPartition(bytes32 indexed partition, address indexed owner, address indexed spender, uint256 value);\\n  /************************************************************************************************/\\n\\n\\n  /**\\n   * @dev Initialize ERC1400 + register the contract implementation in ERC1820Registry.\\n   * @param granularity Granularity of the token.\\n   * @param controllers Array of initial controllers.\\n   * @param defaultPartitions Partitions chosen by default, when partition is\\n   * not specified, like the case ERC20 tranfers.\\n   */\\n  constructor(\\n    uint256 granularity,\\n    address[] memory controllers,\\n    bytes32[] memory defaultPartitions\\n  )\\n    public\\n  {\\n    _name = 'WALLEXBANK TOKEN';\\n    _symbol = 'WXBST';\\n    _totalSupply = 0;\\n    require(granularity >= 1); // Constructor Blocked - Token granularity can not be lower than 1\\n    _granularity = granularity;\\n\\n    _setControllers(controllers);\\n\\n    _defaultPartitions = defaultPartitions;\\n\\n    _isControllable = true;\\n    _isIssuable = true;\\n\\n    // Register contract in ERC1820 registry\\n    ERC1820Client.setInterfaceImplementation(ERC1400_INTERFACE_NAME, address(this));\\n    ERC1820Client.setInterfaceImplementation(ERC20_INTERFACE_NAME, address(this));\\n\\n    // Indicate token verifies ERC1400 and ERC20 interfaces\\n    ERC1820Implementer._setInterface(ERC1400_INTERFACE_NAME); // For migration\\n    ERC1820Implementer._setInterface(ERC20_INTERFACE_NAME); // For migration\\n  }\\n\\n\\n  /************************************************************************************************/\\n  /****************************** EXTERNAL FUNCTIONS (ERC20 INTERFACE) ****************************/\\n  /************************************************************************************************/\\n\\n\\n  /**\\n   * @dev Get the total number of issued tokens.\\n   * @return Total supply of tokens currently in circulation.\\n   */\\n  function totalSupply() external override view returns (uint256) {\\n    return _totalSupply;\\n  }\\n  /**\\n   * @dev Get the balance of the account with address 'tokenHolder'.\\n   * @param tokenHolder Address for which the balance is returned.\\n   * @return Amount of token held by 'tokenHolder' in the token contract.\\n   */\\n  function balanceOf(address tokenHolder) external override view returns (uint256) {\\n    return _balances[tokenHolder];\\n  }\\n  /**\\n   * @dev Transfer token for a specified address.\\n   * @param to The address to transfer to.\\n   * @param value The value to be transferred.\\n   * @return A boolean that indicates if the operation was successful.\\n   */\\n  function transfer(address to, uint256 value) external override returns (bool) {\\n    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, \\\"\\\");\\n    return true;\\n  }\\n  /**\\n   * @dev Check the value of tokens that an owner allowed to a spender.\\n   * @param owner address The address which owns the funds.\\n   * @param spender address The address which will spend the funds.\\n   * @return A uint256 specifying the value of tokens still available for the spender.\\n   */\\n  function allowance(address owner, address spender) external override view returns (uint256) {\\n    return _allowed[owner][spender];\\n  }\\n  /**\\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of 'msg.sender'.\\n   * @param spender The address which will spend the funds.\\n   * @param value The amount of tokens to be spent.\\n   * @return A boolean that indicates if the operation was successful.\\n   */\\n  function approve(address spender, uint256 value) external override returns (bool) {\\n    require(spender != address(0), \\\"56\\\"); // 0x56\\tinvalid sender\\n    _allowed[msg.sender][spender] = value;\\n    emit Approval(msg.sender, spender, value);\\n    return true;\\n  }\\n  /**\\n   * @dev Transfer tokens from one address to another.\\n   * @param from The address which you want to transfer tokens from.\\n   * @param to The address which you want to transfer to.\\n   * @param value The amount of tokens to be transferred.\\n   * @return A boolean that indicates if the operation was successful.\\n   */\\n  function transferFrom(address from, address to, uint256 value) external override returns (bool) {\\n    require( _isOperator(msg.sender, from)\\n      || (value <= _allowed[from][msg.sender]), \\\"53\\\"); // 0x53\\tinsufficient allowance\\n\\n    if(_allowed[from][msg.sender] >= value) {\\n      _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n    } else {\\n      _allowed[from][msg.sender] = 0;\\n    }\\n\\n    _transferByDefaultPartitions(msg.sender, from, to, value, \\\"\\\");\\n    return true;\\n  }\\n\\n\\n  /************************************************************************************************/\\n  /****************************** EXTERNAL FUNCTIONS (ERC1400 INTERFACE) **************************/\\n  /************************************************************************************************/\\n\\n\\n  /************************************* Document Management **************************************/\\n  /**\\n   * @dev Access a document associated with the token.\\n   * @param name Short name (represented as a bytes32) associated to the document.\\n   * @return Requested document + document hash + document timestamp.\\n   */\\n  function getDocument(bytes32 name) external override view returns (string memory, bytes32, uint256) {\\n    require(bytes(_documents[name].docURI).length != 0); // Action Blocked - Empty document\\n    return (\\n      _documents[name].docURI,\\n      _documents[name].docHash,\\n      _documents[name].timestamp\\n    );\\n  }\\n  /**\\n   * @dev Associate a document with the token.\\n   * @param name Short name (represented as a bytes32) associated to the document.\\n   * @param uri Document content.\\n   * @param documentHash Hash of the document [optional parameter].\\n   */\\n  function setDocument(bytes32 name, string calldata uri, bytes32 documentHash) external override {\\n    require(_isController[msg.sender]);\\n    _documents[name] = Doc({\\n      docURI: uri,\\n      docHash: documentHash,\\n      timestamp: block.timestamp\\n    });\\n\\n    if (_indexOfDocHashes[documentHash] == 0) {\\n      _docHashes.push(documentHash);\\n      _indexOfDocHashes[documentHash] = _docHashes.length;\\n    }\\n\\n    emit DocumentUpdated(name, uri, documentHash);\\n  }\\n\\n  function removeDocument(bytes32 _name) external override {\\n    require(_isController[msg.sender], \\\"Unauthorized\\\");\\n    require(bytes(_documents[_name].docURI).length != 0, \\\"Document doesnt exist\\\"); // Action Blocked - Empty document\\n\\n    Doc memory data = _documents[_name];\\n\\n    uint256 index1 = _indexOfDocHashes[data.docHash];\\n    require(index1 > 0, \\\"Invalid index\\\"); //Indexing starts at 1, 0 is not allowed\\n\\n    // move the last item into the index being vacated\\n    bytes32 lastValue = _docHashes[_docHashes.length - 1];\\n    _docHashes[index1 - 1] = lastValue; // adjust for 1-based indexing\\n    _indexOfDocHashes[lastValue] = index1;\\n\\n    //_totalPartitions.length -= 1;\\n    _docHashes.pop();\\n    _indexOfDocHashes[data.docHash] = 0;\\n\\n    delete _documents[_name];\\n\\n    emit DocumentRemoved(_name, data.docURI, data.docHash);\\n  }\\n\\n  function getAllDocuments() external override view returns (bytes32[] memory) {\\n    return _docHashes;\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /************************************** Token Information ***************************************/\\n  /**\\n   * @dev Get balance of a tokenholder for a specific partition.\\n   * @param partition Name of the partition.\\n   * @param tokenHolder Address for which the balance is returned.\\n   * @return Amount of token of partition 'partition' held by 'tokenHolder' in the token contract.\\n   */\\n  function balanceOfByPartition(bytes32 partition, address tokenHolder) external override view returns (uint256) {\\n    return _balanceOfByPartition[tokenHolder][partition];\\n  }\\n  /**\\n   * @dev Get partitions index of a tokenholder.\\n   * @param tokenHolder Address for which the partitions index are returned.\\n   * @return Array of partitions index of 'tokenHolder'.\\n   */\\n  function partitionsOf(address tokenHolder) external override view returns (bytes32[] memory) {\\n    return _partitionsOf[tokenHolder];\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /****************************************** Transfers *******************************************/\\n  /**\\n   * @dev Transfer the amount of tokens from the address 'msg.sender' to the address 'to'.\\n   * @param to Token recipient.\\n   * @param value Number of tokens to transfer.\\n   * @param data Information attached to the transfer, by the token holder.\\n   */\\n  function transferWithData(address to, uint256 value, bytes calldata data) external override {\\n    _transferByDefaultPartitions(msg.sender, msg.sender, to, value, data);\\n  }\\n  /**\\n   * @dev Transfer the amount of tokens on behalf of the address 'from' to the address 'to'.\\n   * @param from Token holder (or 'address(0)' to set from to 'msg.sender').\\n   * @param to Token recipient.\\n   * @param value Number of tokens to transfer.\\n   * @param data Information attached to the transfer, and intended for the token holder ('from').\\n   */\\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data) external override virtual {\\n    require( _isOperator(msg.sender, from)\\n      || (value <= _allowed[from][msg.sender]), \\\"53\\\"); // 0x53\\tinsufficient allowance\\n\\n    if(_allowed[from][msg.sender] >= value) {\\n      _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n    } else {\\n      _allowed[from][msg.sender] = 0;\\n    }\\n\\n    _transferByDefaultPartitions(msg.sender, from, to, value, data);\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /********************************** Partition Token Transfers ***********************************/\\n  /**\\n   * @dev Transfer tokens from a specific partition.\\n   * @param partition Name of the partition.\\n   * @param to Token recipient.\\n   * @param value Number of tokens to transfer.\\n   * @param data Information attached to the transfer, by the token holder.\\n   * @return Destination partition.\\n   */\\n  function transferByPartition(\\n    bytes32 partition,\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  )\\n    external\\n    override\\n    returns (bytes32)\\n  {\\n    return _transferByPartition(partition, msg.sender, msg.sender, to, value, data, \\\"\\\");\\n  }\\n\\n  /**\\n   * @dev Transfer tokens from a specific partition through an operator.\\n   * @param partition Name of the partition.\\n   * @param from Token holder.\\n   * @param to Token recipient.\\n   * @param value Number of tokens to transfer.\\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\\n   * @param operatorData Information attached to the transfer, by the operator.\\n   * @return Destination partition.\\n   */\\n  function operatorTransferByPartition(\\n    bytes32 partition,\\n    address from,\\n    address to,\\n    uint256 value,\\n    bytes calldata data,\\n    bytes calldata operatorData\\n  )\\n    external\\n    override\\n    returns (bytes32)\\n  {\\n    //We want to check if the msg.sender is an authorized operator for `from`\\n    //(msg.sender == from OR msg.sender is authorized by from OR msg.sender is a controller if this token is controlable)\\n    //OR\\n    //We want to check if msg.sender is an `allowed` operator/spender for `from`\\n    require(_isOperatorForPartition(partition, msg.sender, from)\\n      || (value <= _allowedByPartition[partition][from][msg.sender]), \\\"53\\\"); // 0x53\\tinsufficient allowance\\n\\n    if(_allowedByPartition[partition][from][msg.sender] >= value) {\\n      _allowedByPartition[partition][from][msg.sender] = _allowedByPartition[partition][from][msg.sender].sub(value);\\n    } else {\\n      _allowedByPartition[partition][from][msg.sender] = 0;\\n    }\\n\\n    return _transferByPartition(partition, msg.sender, from, to, value, data, operatorData);\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /************************************* Controller Operation *************************************/\\n  /**\\n   * @dev Know if the token can be controlled by operators.\\n   * If a token returns 'false' for 'isControllable()'' then it MUST always return 'false' in the future.\\n   * @return bool 'true' if the token can still be controlled by operators, 'false' if it can't anymore.\\n   */\\n  function isControllable() external override view returns (bool) {\\n    return _isControllable;\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /************************************* Operator Management **************************************/\\n  /**\\n   * @dev Set a third party operator address as an operator of 'msg.sender' to transfer\\n   * and redeem tokens on its behalf.\\n   * @param operator Address to set as an operator for 'msg.sender'.\\n   */\\n  function authorizeOperator(address operator) external override {\\n    require(operator != msg.sender);\\n    _authorizedOperator[operator][msg.sender] = true;\\n    emit AuthorizedOperator(operator, msg.sender);\\n  }\\n  /**\\n   * @dev Remove the right of the operator address to be an operator for 'msg.sender'\\n   * and to transfer and redeem tokens on its behalf.\\n   * @param operator Address to rescind as an operator for 'msg.sender'.\\n   */\\n  function revokeOperator(address operator) external override {\\n    require(operator != msg.sender);\\n    _authorizedOperator[operator][msg.sender] = false;\\n    emit RevokedOperator(operator, msg.sender);\\n  }\\n  /**\\n   * @dev Set 'operator' as an operator for 'msg.sender' for a given partition.\\n   * @param partition Name of the partition.\\n   * @param operator Address to set as an operator for 'msg.sender'.\\n   */\\n  function authorizeOperatorByPartition(bytes32 partition, address operator) external override {\\n    _authorizedOperatorByPartition[msg.sender][partition][operator] = true;\\n    emit AuthorizedOperatorByPartition(partition, operator, msg.sender);\\n  }\\n  /**\\n   * @dev Remove the right of the operator address to be an operator on a given\\n   * partition for 'msg.sender' and to transfer and redeem tokens on its behalf.\\n   * @param partition Name of the partition.\\n   * @param operator Address to rescind as an operator on given partition for 'msg.sender'.\\n   */\\n  function revokeOperatorByPartition(bytes32 partition, address operator) external override {\\n    _authorizedOperatorByPartition[msg.sender][partition][operator] = false;\\n    emit RevokedOperatorByPartition(partition, operator, msg.sender);\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /************************************* Operator Information *************************************/\\n  /**\\n   * @dev Indicate whether the operator address is an operator of the tokenHolder address.\\n   * @param operator Address which may be an operator of tokenHolder.\\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator.\\n   * @return 'true' if operator is an operator of 'tokenHolder' and 'false' otherwise.\\n   */\\n  function isOperator(address operator, address tokenHolder) external override view returns (bool) {\\n    return _isOperator(operator, tokenHolder);\\n  }\\n  /**\\n   * @dev Indicate whether the operator address is an operator of the tokenHolder\\n   * address for the given partition.\\n   * @param partition Name of the partition.\\n   * @param operator Address which may be an operator of tokenHolder for the given partition.\\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\\n   */\\n  function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external override view returns (bool) {\\n    return _isOperatorForPartition(partition, operator, tokenHolder);\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /**************************************** Token Issuance ****************************************/\\n  /**\\n   * @dev Know if new tokens can be issued in the future.\\n   * @return bool 'true' if tokens can still be issued by the issuer, 'false' if they can't anymore.\\n   */\\n  function isIssuable() external override view returns (bool) {\\n    return _isIssuable;\\n  }\\n  /**\\n   * @dev Issue tokens from default partition.\\n   * @param tokenHolder Address for which we want to issue tokens.\\n   * @param value Number of tokens issued.\\n   * @param data Information attached to the issuance, by the issuer.\\n   */\\n  function issue(address tokenHolder, uint256 value, bytes calldata data)\\n    external\\n    override\\n    onlyMinter\\n    isIssuableToken\\n  {\\n    require(_defaultPartitions.length != 0, \\\"55\\\"); // 0x55\\tfunds locked (lockup period)\\n\\n    _issueByPartition(_defaultPartitions[0], msg.sender, tokenHolder, value, data);\\n  }\\n  /**\\n   * @dev Issue tokens from a specific partition.\\n   * @param partition Name of the partition.\\n   * @param tokenHolder Address for which we want to issue tokens.\\n   * @param value Number of tokens issued.\\n   * @param data Information attached to the issuance, by the issuer.\\n   */\\n  function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data)\\n    external\\n    override\\n    onlyMinter\\n    isIssuableToken\\n  {\\n    _issueByPartition(partition, msg.sender, tokenHolder, value, data);\\n  }\\n  /************************************************************************************************/\\n  \\n\\n  /*************************************** Token Redemption ***************************************/\\n  /**\\n   * @dev Redeem the amount of tokens from the address 'msg.sender'.\\n   * @param value Number of tokens to redeem.\\n   * @param data Information attached to the redemption, by the token holder.\\n   */\\n  function redeem(uint256 value, bytes calldata data)\\n    external\\n    override\\n  {\\n    _redeemByDefaultPartitions(msg.sender, msg.sender, value, data);\\n  }\\n  /**\\n   * @dev Redeem the amount of tokens on behalf of the address from.\\n   * @param from Token holder whose tokens will be redeemed (or address(0) to set from to msg.sender).\\n   * @param value Number of tokens to redeem.\\n   * @param data Information attached to the redemption.\\n   */\\n  function redeemFrom(address from, uint256 value, bytes calldata data)\\n    external\\n    override\\n    virtual\\n  {\\n    require(_isOperator(msg.sender, from)\\n      || (value <= _allowed[from][msg.sender]), \\\"53\\\"); // 0x53\\tinsufficient allowance\\n\\n    if(_allowed[from][msg.sender] >= value) {\\n      _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n    } else {\\n      _allowed[from][msg.sender] = 0;\\n    }\\n\\n    _redeemByDefaultPartitions(msg.sender, from, value, data);\\n  }\\n  /**\\n   * @dev Redeem tokens of a specific partition.\\n   * @param partition Name of the partition.\\n   * @param value Number of tokens redeemed.\\n   * @param data Information attached to the redemption, by the redeemer.\\n   */\\n  function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data)\\n    external\\n    override\\n  {\\n    _redeemByPartition(partition, msg.sender, msg.sender, value, data, \\\"\\\");\\n  }\\n  /**\\n   * @dev Redeem tokens of a specific partition.\\n   * @param partition Name of the partition.\\n   * @param tokenHolder Address for which we want to redeem tokens.\\n   * @param value Number of tokens redeemed\\n   * @param operatorData Information attached to the redemption, by the operator.\\n   */\\n  function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata operatorData)\\n    external\\n    override\\n  {\\n    require(_isOperatorForPartition(partition, msg.sender, tokenHolder) || value <= _allowedByPartition[partition][tokenHolder][msg.sender], \\\"58\\\"); // 0x58\\tinvalid operator (transfer agent)\\n\\n    if(_allowedByPartition[partition][tokenHolder][msg.sender] >= value) {\\n      _allowedByPartition[partition][tokenHolder][msg.sender] = _allowedByPartition[partition][tokenHolder][msg.sender].sub(value);\\n    } else {\\n      _allowedByPartition[partition][tokenHolder][msg.sender] = 0;\\n    }\\n\\n    _redeemByPartition(partition, msg.sender, tokenHolder, value, \\\"\\\", operatorData);\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /************************************************************************************************/\\n  /************************ EXTERNAL FUNCTIONS (ADDITIONAL - NOT MANDATORY) ***********************/\\n  /************************************************************************************************/\\n\\n\\n  /************************************ Token description *****************************************/\\n  /**\\n   * @dev Get the name of the token, e.g., \\\"MyToken\\\".\\n   * @return Name of the token.\\n   */\\n  function name() external view returns(string memory) {\\n    return _name;\\n  }\\n  /**\\n   * @dev Get the symbol of the token, e.g., \\\"MYT\\\".\\n   * @return Symbol of the token.\\n   */\\n  function symbol() external view returns(string memory) {\\n    return _symbol;\\n  }\\n  /**\\n   * @dev Get the number of decimals of the token.\\n   * @return The number of decimals of the token. For retrocompatibility, decimals are forced to 18 in ERC1400.\\n   */\\n  function decimals() external pure returns(uint8) {\\n    return uint8(18);\\n  }\\n  /**\\n   * @dev Get the smallest part of the token that’s not divisible.\\n   * @return The smallest non-divisible part of the token.\\n   */\\n  function granularity() external view returns(uint256) {\\n    return _granularity;\\n  }\\n  /**\\n   * @dev Get list of existing partitions.\\n   * @return Array of all exisiting partitions.\\n   */\\n  function totalPartitions() external view returns (bytes32[] memory) {\\n    return _totalPartitions;\\n  }\\n  /**\\n   * @dev Get the total number of issued tokens for a given partition.\\n   * @param partition Name of the partition.\\n   * @return Total supply of tokens currently in circulation, for a given partition.\\n   */\\n  function totalSupplyByPartition(bytes32 partition) external view returns (uint256) {\\n    return _totalSupplyByPartition[partition];\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /**************************************** Token behaviours **************************************/\\n  /**\\n   * @dev Definitely renounce the possibility to control tokens on behalf of tokenHolders.\\n   * Once set to false, '_isControllable' can never be set to 'true' again.\\n   */\\n  function renounceControl() external onlyOwner {\\n    _isControllable = false;\\n  }\\n  /**\\n   * @dev Definitely renounce the possibility to issue new tokens.\\n   * Once set to false, '_isIssuable' can never be set to 'true' again.\\n   */\\n  function renounceIssuance() external onlyOwner {\\n    _isIssuable = false;\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /************************************ Token controllers *****************************************/\\n  /**\\n   * @dev Get the list of controllers as defined by the token contract.\\n   * @return List of addresses of all the controllers.\\n   */\\n  function controllers() external view returns (address[] memory) {\\n    return _controllers;\\n  }\\n  /**\\n   * @dev Get controllers for a given partition.\\n   * @param partition Name of the partition.\\n   * @return Array of controllers for partition.\\n   */\\n  function controllersByPartition(bytes32 partition) external view returns (address[] memory) {\\n    return _controllersByPartition[partition];\\n  }\\n  /**\\n   * @dev Set list of token controllers.\\n   * @param operators Controller addresses.\\n   */\\n  function setControllers(address[] calldata operators) external onlyOwner {\\n    _setControllers(operators);\\n  }\\n  /**\\n   * @dev Set list of token partition controllers.\\n   * @param partition Name of the partition.\\n   * @param operators Controller addresses.\\n   */\\n   function setPartitionControllers(bytes32 partition, address[] calldata operators) external onlyOwner {\\n     _setPartitionControllers(partition, operators);\\n   }\\n  /************************************************************************************************/\\n\\n\\n  /********************************* Token default partitions *************************************/\\n  /**\\n   * @dev Get default partitions to transfer from.\\n   * Function used for ERC20 retrocompatibility.\\n   * For example, a security token may return the bytes32(\\\"unrestricted\\\").\\n   * @return Array of default partitions.\\n   */\\n  function getDefaultPartitions() external view returns (bytes32[] memory) {\\n    return _defaultPartitions;\\n  }\\n  /**\\n   * @dev Set default partitions to transfer from.\\n   * Function used for ERC20 retrocompatibility.\\n   * @param partitions partitions to use by default when not specified.\\n   */\\n  function setDefaultPartitions(bytes32[] calldata partitions) external onlyOwner {\\n    _defaultPartitions = partitions;\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /******************************** Partition Token Allowances ************************************/\\n  /**\\n   * @dev Check the value of tokens that an owner allowed to a spender.\\n   * @param partition Name of the partition.\\n   * @param owner address The address which owns the funds.\\n   * @param spender address The address which will spend the funds.\\n   * @return A uint256 specifying the value of tokens still available for the spender.\\n   */\\n  function allowanceByPartition(bytes32 partition, address owner, address spender) external view returns (uint256) {\\n    return _allowedByPartition[partition][owner][spender];\\n  }\\n  /**\\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of 'msg.sender'.\\n   * @param partition Name of the partition.\\n   * @param spender The address which will spend the funds.\\n   * @param value The amount of tokens to be spent.\\n   * @return A boolean that indicates if the operation was successful.\\n   */\\n  function approveByPartition(bytes32 partition, address spender, uint256 value) external returns (bool) {\\n    require(spender != address(0), \\\"56\\\"); // 0x56\\tinvalid sender\\n    _allowedByPartition[partition][msg.sender][spender] = value;\\n    emit ApprovalByPartition(partition, msg.sender, spender, value);\\n    return true;\\n  }\\n  /************************************************************************************************/\\n\\n  \\n  /************************************** Token extension *****************************************/\\n  /**\\n   * @dev Set token extension contract address.\\n   * The extension contract can for example verify \\\"ERC1400TokensValidator\\\" or \\\"ERC1400TokensChecker\\\" interfaces.\\n   * If the extension is an \\\"ERC1400TokensValidator\\\", it will be called everytime a transfer is executed.\\n   * @param extension Address of the extension contract.\\n   * @param interfaceLabel Interface label of extension contract.\\n   * @param removeOldExtensionRoles If set to 'true', the roles of the old extension(minter, controller) will be removed extension.\\n   * @param addMinterRoleForExtension If set to 'true', the extension contract will be added as minter.\\n   * @param addControllerRoleForExtension If set to 'true', the extension contract will be added as controller.\\n   */\\n  function setTokenExtension(address extension, string calldata interfaceLabel, bool removeOldExtensionRoles, bool addMinterRoleForExtension, bool addControllerRoleForExtension) external onlyOwner {\\n    _setTokenExtension(extension, interfaceLabel, removeOldExtensionRoles, addMinterRoleForExtension, addControllerRoleForExtension);\\n  }\\n  /************************************************************************************************/\\n\\n  /************************************* Token migration ******************************************/\\n  /**\\n   * @dev Migrate contract.\\n   *\\n   * ===> CAUTION: DEFINITIVE ACTION\\n   * \\n   * This function shall be called once a new version of the smart contract has been created.\\n   * Once this function is called:\\n   *  - The address of the new smart contract is set in ERC1820 registry\\n   *  - If the choice is definitive, the current smart contract is turned off and can never be used again\\n   *\\n   * @param newContractAddress Address of the new version of the smart contract.\\n   * @param definitive If set to 'true' the contract is turned off definitely.\\n   */\\n  function migrate(address newContractAddress, bool definitive) external onlyOwner {\\n    _migrate(newContractAddress, definitive);\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /************************************************************************************************/\\n  /************************************* INTERNAL FUNCTIONS ***************************************/\\n  /************************************************************************************************/\\n\\n\\n  /**************************************** Token Transfers ***************************************/\\n  /**\\n   * @dev Perform the transfer of tokens.\\n   * @param from Token holder.\\n   * @param to Token recipient.\\n   * @param value Number of tokens to transfer.\\n   */\\n  function _transferWithData(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n    internal\\n    isNotMigratedToken\\n  {\\n    require(_isMultiple(value), \\\"50\\\"); // 0x50\\ttransfer failure\\n    require(to != address(0), \\\"57\\\"); // 0x57\\tinvalid receiver\\n    require(_balances[from] >= value, \\\"52\\\"); // 0x52\\tinsufficient balance\\n  \\n    _balances[from] = _balances[from].sub(value);\\n    _balances[to] = _balances[to].add(value);\\n\\n    emit Transfer(from, to, value); // ERC20 retrocompatibility \\n  }\\n  /**\\n   * @dev Transfer tokens from a specific partition.\\n   * @param fromPartition Partition of the tokens to transfer.\\n   * @param operator The address performing the transfer.\\n   * @param from Token holder.\\n   * @param to Token recipient.\\n   * @param value Number of tokens to transfer.\\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\\n   * @param operatorData Information attached to the transfer, by the operator (if any).\\n   * @return Destination partition.\\n   */\\n  function _transferByPartition(\\n    bytes32 fromPartition,\\n    address operator,\\n    address from,\\n    address to,\\n    uint256 value,\\n    bytes memory data,\\n    bytes memory operatorData\\n  )\\n    internal\\n    returns (bytes32)\\n  {\\n    require(_balanceOfByPartition[from][fromPartition] >= value, \\\"52\\\"); // 0x52\\tinsufficient balance\\n\\n    bytes32 toPartition = fromPartition;\\n\\n    if(operatorData.length != 0 && data.length >= 64) {\\n      toPartition = _getDestinationPartition(fromPartition, data);\\n    }\\n\\n    _callSenderExtension(fromPartition, operator, from, to, value, data, operatorData);\\n    _callTokenExtension(fromPartition, operator, from, to, value, data, operatorData);\\n\\n    _removeTokenFromPartition(from, fromPartition, value);\\n    _transferWithData(from, to, value);\\n    _addTokenToPartition(to, toPartition, value);\\n\\n    _callRecipientExtension(toPartition, operator, from, to, value, data, operatorData);\\n\\n    emit TransferByPartition(fromPartition, operator, from, to, value, data, operatorData);\\n\\n    if(toPartition != fromPartition) {\\n      emit ChangedPartition(fromPartition, toPartition, value);\\n    }\\n\\n    return toPartition;\\n  }\\n  /**\\n   * @dev Transfer tokens from default partitions.\\n   * Function used for ERC20 retrocompatibility.\\n   * @param operator The address performing the transfer.\\n   * @param from Token holder.\\n   * @param to Token recipient.\\n   * @param value Number of tokens to transfer.\\n   * @param data Information attached to the transfer, and intended for the token holder ('from') [CAN CONTAIN THE DESTINATION PARTITION].\\n   */\\n  function _transferByDefaultPartitions(\\n    address operator,\\n    address from,\\n    address to,\\n    uint256 value,\\n    bytes memory data\\n  )\\n    internal\\n  {\\n    require(_defaultPartitions.length != 0, \\\"55\\\"); // // 0x55\\tfunds locked (lockup period)\\n\\n    uint256 _remainingValue = value;\\n    uint256 _localBalance;\\n\\n    for (uint i = 0; i < _defaultPartitions.length; i++) {\\n      _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\\n      if(_remainingValue <= _localBalance) {\\n        _transferByPartition(_defaultPartitions[i], operator, from, to, _remainingValue, data, \\\"\\\");\\n        _remainingValue = 0;\\n        break;\\n      } else if (_localBalance != 0) {\\n        _transferByPartition(_defaultPartitions[i], operator, from, to, _localBalance, data, \\\"\\\");\\n        _remainingValue = _remainingValue - _localBalance;\\n      }\\n    }\\n\\n    require(_remainingValue == 0, \\\"52\\\"); // 0x52\\tinsufficient balance\\n  }\\n  /**\\n   * @dev Retrieve the destination partition from the 'data' field.\\n   * By convention, a partition change is requested ONLY when 'data' starts\\n   * with the flag: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\n   * When the flag is detected, the destination tranche is extracted from the\\n   * 32 bytes following the flag.\\n   * @param fromPartition Partition of the tokens to transfer.\\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\\n   * @return toPartition Destination partition.\\n   */\\n  function _getDestinationPartition(bytes32 fromPartition, bytes memory data) internal pure returns(bytes32 toPartition) {\\n    bytes32 changePartitionFlag = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\\n    bytes32 flag;\\n    assembly {\\n      flag := mload(add(data, 32))\\n    }\\n    if(flag == changePartitionFlag) {\\n      assembly {\\n        toPartition := mload(add(data, 64))\\n      }\\n    } else {\\n      toPartition = fromPartition;\\n    }\\n  }\\n  /**\\n   * @dev Remove a token from a specific partition.\\n   * @param from Token holder.\\n   * @param partition Name of the partition.\\n   * @param value Number of tokens to transfer.\\n   */\\n  function _removeTokenFromPartition(address from, bytes32 partition, uint256 value) internal {\\n    _balanceOfByPartition[from][partition] = _balanceOfByPartition[from][partition].sub(value);\\n    _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition].sub(value);\\n\\n    // If the total supply is zero, finds and deletes the partition.\\n    if(_totalSupplyByPartition[partition] == 0) {\\n      uint256 index1 = _indexOfTotalPartitions[partition];\\n      require(index1 > 0, \\\"50\\\"); // 0x50\\ttransfer failure\\n\\n      // move the last item into the index being vacated\\n      bytes32 lastValue = _totalPartitions[_totalPartitions.length - 1];\\n      _totalPartitions[index1 - 1] = lastValue; // adjust for 1-based indexing\\n      _indexOfTotalPartitions[lastValue] = index1;\\n\\n      //_totalPartitions.length -= 1;\\n      _totalPartitions.pop();\\n      _indexOfTotalPartitions[partition] = 0;\\n    }\\n\\n    // If the balance of the TokenHolder's partition is zero, finds and deletes the partition.\\n    if(_balanceOfByPartition[from][partition] == 0) {\\n      uint256 index2 = _indexOfPartitionsOf[from][partition];\\n      require(index2 > 0, \\\"50\\\"); // 0x50\\ttransfer failure\\n\\n      // move the last item into the index being vacated\\n      bytes32 lastValue = _partitionsOf[from][_partitionsOf[from].length - 1];\\n      _partitionsOf[from][index2 - 1] = lastValue;  // adjust for 1-based indexing\\n      _indexOfPartitionsOf[from][lastValue] = index2;\\n\\n      //_partitionsOf[from].length -= 1;\\n      _partitionsOf[from].pop();\\n      _indexOfPartitionsOf[from][partition] = 0;\\n    }\\n  }\\n  /**\\n   * @dev Add a token to a specific partition.\\n   * @param to Token recipient.\\n   * @param partition Name of the partition.\\n   * @param value Number of tokens to transfer.\\n   */\\n  function _addTokenToPartition(address to, bytes32 partition, uint256 value) internal {\\n    if(value != 0) {\\n      if (_indexOfPartitionsOf[to][partition] == 0) {\\n        _partitionsOf[to].push(partition);\\n        _indexOfPartitionsOf[to][partition] = _partitionsOf[to].length;\\n      }\\n      _balanceOfByPartition[to][partition] = _balanceOfByPartition[to][partition].add(value);\\n\\n      if (_indexOfTotalPartitions[partition] == 0) {\\n        _totalPartitions.push(partition);\\n        _indexOfTotalPartitions[partition] = _totalPartitions.length;\\n      }\\n      _totalSupplyByPartition[partition] = _totalSupplyByPartition[partition].add(value);\\n    }\\n  }\\n  /**\\n   * @dev Check if 'value' is multiple of the granularity.\\n   * @param value The quantity that want's to be checked.\\n   * @return 'true' if 'value' is a multiple of the granularity.\\n   */\\n  function _isMultiple(uint256 value) internal view returns(bool) {\\n    return(value.div(_granularity).mul(_granularity) == value);\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /****************************************** Hooks ***********************************************/\\n  /**\\n   * @dev Check for 'ERC1400TokensSender' user extension in ERC1820 registry and call it.\\n   * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\\n   * @param from Token holder.\\n   * @param to Token recipient for a transfer and 0x for a redemption.\\n   * @param value Number of tokens the token holder balance is decreased by.\\n   * @param data Extra information.\\n   * @param operatorData Extra information, attached by the operator (if any).\\n   */\\n  function _callSenderExtension(\\n    bytes32 partition,\\n    address operator,\\n    address from,\\n    address to,\\n    uint256 value,\\n    bytes memory data,\\n    bytes memory operatorData\\n  )\\n    internal\\n  {\\n    address senderImplementation;\\n    senderImplementation = interfaceAddr(from, ERC1400_TOKENS_SENDER);\\n    if (senderImplementation != address(0)) {\\n      IERC1400TokensSender(senderImplementation).tokensToTransfer(msg.data, partition, operator, from, to, value, data, operatorData);\\n    }\\n  }\\n  \\n  /**\\n   * @dev Check for 'ERC1400TokensValidator' token extension in ERC1820 registry and call it.\\n   * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\\n   * @param from Token holder.\\n   * @param to Token recipient for a transfer and 0x for a redemption.\\n   * @param value Number of tokens the token holder balance is decreased by.\\n   * @param data Extra information.\\n   * @param operatorData Extra information, attached by the operator (if any).\\n   */\\n  function _callTokenExtension(\\n    bytes32 partition,\\n    address operator,\\n    address from,\\n    address to,\\n    uint256 value,\\n    bytes memory data,\\n    bytes memory operatorData\\n  )\\n    internal\\n  {\\n    address validatorImplementation;\\n    validatorImplementation = interfaceAddr(address(this), ERC1400_TOKENS_VALIDATOR);\\n    if (validatorImplementation != address(0)) {\\n      IERC1400TokensValidator(validatorImplementation).tokensToValidate(msg.data, partition, operator, from, to, value, data, operatorData);\\n    }\\n  }\\n  /**\\n   * @dev Check for 'ERC1400TokensRecipient' user extension in ERC1820 registry and call it.\\n   * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\\n   * @param operator Address which triggered the balance increase (through transfer or issuance).\\n   * @param from Token holder for a transfer and 0x for an issuance.\\n   * @param to Token recipient.\\n   * @param value Number of tokens the recipient balance is increased by.\\n   * @param data Extra information, intended for the token holder ('from').\\n   * @param operatorData Extra information attached by the operator (if any).\\n   */\\n  function _callRecipientExtension(\\n    bytes32 partition,\\n    address operator,\\n    address from,\\n    address to,\\n    uint256 value,\\n    bytes memory data,\\n    bytes memory operatorData\\n  )\\n    internal\\n    virtual\\n  {\\n    address recipientImplementation;\\n    recipientImplementation = interfaceAddr(to, ERC1400_TOKENS_RECIPIENT);\\n\\n    if (recipientImplementation != address(0)) {\\n      IERC1400TokensRecipient(recipientImplementation).tokensReceived(msg.data, partition, operator, from, to, value, data, operatorData);\\n    }\\n  }\\n  \\n  /**\\n   * @dev Check for 'ERC1400TokensValidator' token extension in ERC1820 registry and call it.\\n   * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\\n   * @param from Token holder.\\n   * @param to Token recipient for a transfer and 0x for a redemption.\\n   * @param value Number of tokens the token holder balance is decreased by.\\n   * @param data Extra information.\\n   * @param operatorData Extra information, attached by the operator (if any).\\n   */\\n  function _callRedeemExtension(\\n    bytes32 partition,\\n    address operator,\\n    address from,\\n    address to,\\n    uint256 value,\\n    bytes memory data,\\n    bytes memory operatorData\\n  )\\n    internal\\n  {\\n    address validatorImplementation;\\n    validatorImplementation = interfaceAddr(address(this), ERC1400_TOKENS_VALIDATOR);\\n    if (validatorImplementation != address(0)) {\\n      IERC1400TokensValidator(validatorImplementation).canBurn(msg.data, partition, operator, from, to, value, data, operatorData);\\n    }\\n  }\\n  \\n  /**\\n   * @dev Check for 'ERC1400TokensValidator' token extension in ERC1820 registry and call it.\\n   * @param partition Name of the partition (bytes32 to be left empty for transfers where partition is not specified).\\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\\n   * @param from Token holder.\\n   * @param to Token recipient for a transfer and 0x for a redemption.\\n   * @param value Number of tokens the token holder balance is decreased by.\\n   * @param data Extra information.\\n   * @param operatorData Extra information, attached by the operator (if any).\\n   */\\n  function _callMintExtension(\\n    bytes32 partition,\\n    address operator,\\n    address from,\\n    address to,\\n    uint256 value,\\n    bytes memory data,\\n    bytes memory operatorData\\n  )\\n    internal\\n  {\\n    address validatorImplementation;\\n    validatorImplementation = interfaceAddr(address(this), ERC1400_TOKENS_VALIDATOR);\\n    if (validatorImplementation != address(0)) {\\n      IERC1400TokensValidator(validatorImplementation).canMint(msg.data, partition, operator, from, to, value, data, operatorData);\\n    }\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /************************************* Operator Information *************************************/\\n  /**\\n   * @dev Indicate whether the operator address is an operator of the tokenHolder address.\\n   * @param operator Address which may be an operator of 'tokenHolder'.\\n   * @param tokenHolder Address of a token holder which may have the 'operator' address as an operator.\\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' and 'false' otherwise.\\n   */\\n  function _isOperator(address operator, address tokenHolder) internal view returns (bool) {\\n    return (operator == tokenHolder\\n      || _authorizedOperator[operator][tokenHolder]\\n      || (_isControllable && _isController[operator])\\n    );\\n  }\\n  /**\\n   * @dev Indicate whether the operator address is an operator of the tokenHolder\\n   * address for the given partition.\\n   * @param partition Name of the partition.\\n   * @param operator Address which may be an operator of tokenHolder for the given partition.\\n   * @param tokenHolder Address of a token holder which may have the operator address as an operator for the given partition.\\n   * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition 'partition' and 'false' otherwise.\\n   */\\n   function _isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) internal view returns (bool) {\\n     return (_isOperator(operator, tokenHolder)\\n       || _authorizedOperatorByPartition[tokenHolder][partition][operator]\\n       || (_isControllable && _isControllerByPartition[partition][operator])\\n     );\\n   }\\n  /************************************************************************************************/\\n\\n\\n  /**************************************** Token Issuance ****************************************/\\n  /**\\n   * @dev Perform the issuance of tokens.\\n   * @param operator Address which triggered the issuance.\\n   * @param to Token recipient.\\n   * @param value Number of tokens issued.\\n   * @param data Information attached to the issuance, and intended for the recipient (to).\\n   */\\n  function _issue(address operator, address to, uint256 value, bytes memory data)\\n    internal\\n    isNotMigratedToken  \\n  {\\n    require(_isMultiple(value), \\\"50\\\"); // 0x50\\ttransfer failure\\n    require(to != address(0), \\\"57\\\"); // 0x57\\tinvalid receiver\\n\\n    _totalSupply = _totalSupply.add(value);\\n    _balances[to] = _balances[to].add(value);\\n\\n    emit Issued(operator, to, value, data);\\n    emit Transfer(address(0), to, value); // ERC20 retrocompatibility\\n  }\\n  /**\\n   * @dev Issue tokens from a specific partition.\\n   * @param toPartition Name of the partition.\\n   * @param operator The address performing the issuance.\\n   * @param to Token recipient.\\n   * @param value Number of tokens to issue.\\n   * @param data Information attached to the issuance.\\n   */\\n  function _issueByPartition(\\n    bytes32 toPartition,\\n    address operator,\\n    address to,\\n    uint256 value,\\n    bytes memory data\\n  )\\n    internal\\n  {\\n    _callMintExtension(toPartition, operator, address(0), to, value, data, \\\"\\\");\\n\\n    _issue(operator, to, value, data);\\n    _addTokenToPartition(to, toPartition, value);\\n\\n    _callRecipientExtension(toPartition, operator, address(0), to, value, data, \\\"\\\");\\n\\n    emit IssuedByPartition(toPartition, operator, to, value, data, \\\"\\\");\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /*************************************** Token Redemption ***************************************/\\n  /**\\n   * @dev Perform the token redemption.\\n   * @param operator The address performing the redemption.\\n   * @param from Token holder whose tokens will be redeemed.\\n   * @param value Number of tokens to redeem.\\n   * @param data Information attached to the redemption.\\n   */\\n  function _redeem(address operator, address from, uint256 value, bytes memory data)\\n    internal\\n    isNotMigratedToken\\n  {\\n    require(_isMultiple(value), \\\"50\\\"); // 0x50\\ttransfer failure\\n    require(from != address(0), \\\"56\\\"); // 0x56\\tinvalid sender\\n    require(_balances[from] >= value, \\\"52\\\"); // 0x52\\tinsufficient balance\\n\\n    _balances[from] = _balances[from].sub(value);\\n    _totalSupply = _totalSupply.sub(value);\\n\\n    emit Redeemed(operator, from, value, data);\\n    emit Transfer(from, address(0), value);  // ERC20 retrocompatibility\\n  }\\n  /**\\n   * @dev Redeem tokens of a specific partition.\\n   * @param fromPartition Name of the partition.\\n   * @param operator The address performing the redemption.\\n   * @param from Token holder whose tokens will be redeemed.\\n   * @param value Number of tokens to redeem.\\n   * @param data Information attached to the redemption.\\n   * @param operatorData Information attached to the redemption, by the operator (if any).\\n   */\\n  function _redeemByPartition(\\n    bytes32 fromPartition,\\n    address operator,\\n    address from,\\n    uint256 value,\\n    bytes memory data,\\n    bytes memory operatorData\\n  )\\n    internal\\n  {\\n    require(_balanceOfByPartition[from][fromPartition] >= value, \\\"52\\\"); // 0x52\\tinsufficient balance\\n\\n    _callSenderExtension(fromPartition, operator, from, address(0), value, data, operatorData);\\n    _callRedeemExtension(fromPartition, operator, from, address(0), value, data, operatorData);\\n\\n    _removeTokenFromPartition(from, fromPartition, value);\\n    _redeem(operator, from, value, data);\\n\\n    emit RedeemedByPartition(fromPartition, operator, from, value, operatorData);\\n  }\\n  /**\\n   * @dev Redeem tokens from a default partitions.\\n   * @param operator The address performing the redeem.\\n   * @param from Token holder.\\n   * @param value Number of tokens to redeem.\\n   * @param data Information attached to the redemption.\\n   */\\n  function _redeemByDefaultPartitions(\\n    address operator,\\n    address from,\\n    uint256 value,\\n    bytes memory data\\n  )\\n    internal\\n  {\\n    require(_defaultPartitions.length != 0, \\\"55\\\"); // 0x55\\tfunds locked (lockup period)\\n\\n    uint256 _remainingValue = value;\\n    uint256 _localBalance;\\n\\n    for (uint i = 0; i < _defaultPartitions.length; i++) {\\n      _localBalance = _balanceOfByPartition[from][_defaultPartitions[i]];\\n      if(_remainingValue <= _localBalance) {\\n        _redeemByPartition(_defaultPartitions[i], operator, from, _remainingValue, data, \\\"\\\");\\n        _remainingValue = 0;\\n        break;\\n      } else {\\n        _redeemByPartition(_defaultPartitions[i], operator, from, _localBalance, data, \\\"\\\");\\n        _remainingValue = _remainingValue - _localBalance;\\n      }\\n    }\\n\\n    require(_remainingValue == 0, \\\"52\\\"); // 0x52\\tinsufficient balance\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /************************************** Transfer Validity ***************************************/\\n  /**\\n   * @dev Know the reason on success or failure based on the EIP-1066 application-specific status codes.\\n   * @param payload Payload of the initial transaction.\\n   * @param partition Name of the partition.\\n   * @param operator The address performing the transfer.\\n   * @param from Token holder.\\n   * @param to Token recipient.\\n   * @param value Number of tokens to transfer.\\n   * @param data Information attached to the transfer. [CAN CONTAIN THE DESTINATION PARTITION]\\n   * @param operatorData Information attached to the transfer, by the operator (if any).\\n   * @return ESC (Ethereum Status Code) following the EIP-1066 standard.\\n   * @return Additional bytes32 parameter that can be used to define\\n   * application specific reason codes with additional details (for example the\\n   * transfer restriction rule responsible for making the transfer operation invalid).\\n   * @return Destination partition.\\n   */\\n  function canTransfer(bytes memory payload, bytes32 partition, address operator, address from, address to, uint256 value, bytes memory data, bytes memory operatorData)\\n    external\\n    returns (bytes1, bytes32, bytes32)\\n  {\\n    if(_balanceOfByPartition[from][partition] < value) {\\n        return(hex\\\"52\\\", \\\"\\\", partition); // 0x52\\tinsufficient balance\\n    }\\n    \\n    address validatorImplementation = interfaceAddr(address(this), ERC1400_TOKENS_VALIDATOR);\\n    if (validatorImplementation != address(0)) {\\n      IERC1400TokensValidator(validatorImplementation).tokensToValidate(msg.data, partition, operator, from, to, value, data, operatorData);\\n    }\\n    \\n    return(hex\\\"00\\\", \\\"\\\", partition);\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /************************************************************************************************/\\n  /************************ INTERNAL FUNCTIONS (ADDITIONAL - NOT MANDATORY) ***********************/\\n  /************************************************************************************************/\\n\\n\\n  /************************************ Token controllers *****************************************/\\n  /**\\n   * @dev Set list of token controllers.\\n   * @param operators Controller addresses.\\n   */\\n  function _setControllers(address[] memory operators) internal {\\n    for (uint i = 0; i<_controllers.length; i++){\\n      _isController[_controllers[i]] = false;\\n    }\\n    for (uint j = 0; j<operators.length; j++){\\n      _isController[operators[j]] = true;\\n    }\\n    _controllers = operators;\\n  }\\n  /**\\n   * @dev Set list of token partition controllers.\\n   * @param partition Name of the partition.\\n   * @param operators Controller addresses.\\n   */\\n   function _setPartitionControllers(bytes32 partition, address[] memory operators) internal {\\n     for (uint i = 0; i<_controllersByPartition[partition].length; i++){\\n       _isControllerByPartition[partition][_controllersByPartition[partition][i]] = false;\\n     }\\n     for (uint j = 0; j<operators.length; j++){\\n       _isControllerByPartition[partition][operators[j]] = true;\\n     }\\n     _controllersByPartition[partition] = operators;\\n   }\\n  /************************************************************************************************/\\n\\n\\n  /************************************** Token extension *****************************************/\\n  /**\\n   * @dev Set token extension contract address.\\n   * The extension contract can for example verify \\\"ERC1400TokensValidator\\\" or \\\"ERC1400TokensChecker\\\" interfaces.\\n   * If the extension is an \\\"ERC1400TokensValidator\\\", it will be called everytime a transfer is executed.\\n   * @param extension Address of the extension contract.\\n   * @param interfaceLabel Interface label of extension contract.\\n   * @param removeOldExtensionRoles If set to 'true', the roles of the old extension(minter, controller) will be removed extension.\\n   * @param addMinterRoleForExtension If set to 'true', the extension contract will be added as minter.\\n   * @param addControllerRoleForExtension If set to 'true', the extension contract will be added as controller.\\n   */\\n  function _setTokenExtension(address extension, string memory interfaceLabel, bool removeOldExtensionRoles, bool addMinterRoleForExtension, bool addControllerRoleForExtension) internal {\\n    address oldExtension = interfaceAddr(address(this), interfaceLabel);\\n\\n    if (oldExtension != address(0) && removeOldExtensionRoles) {\\n      if(isMinter(oldExtension)) {\\n        _removeMinter(oldExtension);\\n      }\\n      _isController[oldExtension] = false;\\n    }\\n\\n    ERC1820Client.setInterfaceImplementation(interfaceLabel, extension);\\n    if(addMinterRoleForExtension && !isMinter(extension)) {\\n      _addMinter(extension);\\n    }\\n    if (addControllerRoleForExtension) {\\n      _isController[extension] = true;\\n    }\\n  }\\n  /************************************************************************************************/\\n\\n\\n  /************************************* Token migration ******************************************/\\n  /**\\n   * @dev Migrate contract.\\n   *\\n   * ===> CAUTION: DEFINITIVE ACTION\\n   * \\n   * This function shall be called once a new version of the smart contract has been created.\\n   * Once this function is called:\\n   *  - The address of the new smart contract is set in ERC1820 registry\\n   *  - If the choice is definitive, the current smart contract is turned off and can never be used again\\n   *\\n   * @param newContractAddress Address of the new version of the smart contract.\\n   * @param definitive If set to 'true' the contract is turned off definitely.\\n   */\\n  function _migrate(address newContractAddress, bool definitive) internal {\\n    ERC1820Client.setInterfaceImplementation(ERC20_INTERFACE_NAME, newContractAddress);\\n    ERC1820Client.setInterfaceImplementation(ERC1400_INTERFACE_NAME, newContractAddress);\\n    if(definitive) {\\n      _migrated = true;\\n    }\\n  }\\n  /************************************************************************************************/\\n\\n  /************************************* Domain Aware ******************************************/\\n  function domainName() public override view returns (string memory) {\\n    return _name;\\n  }\\n\\n  function domainVersion() public override view returns (string memory) {\\n    return \\\"1\\\";\\n  }\\n  /************************************************************************************************/\\n}\\n\"\r\n    },\r\n    \"contracts/tools/DomainAware.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract DomainAware {\\n\\n    // Mapping of ChainID to domain separators. This is a very gas efficient way\\n    // to not recalculate the domain separator on every call, while still\\n    // automatically detecting ChainID changes.\\n    mapping(uint256 => bytes32) private domainSeparators;\\n\\n    constructor() {\\n        _updateDomainSeparator();\\n    }\\n\\n    function domainName() public virtual view returns (string memory);\\n\\n    function domainVersion() public virtual view returns (string memory);\\n\\n    function generateDomainSeparator() public view returns (bytes32) {\\n        uint256 chainID = _chainID();\\n\\n        // no need for assembly, running very rarely\\n        bytes32 domainSeparatorHash = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(domainName())), // ERC-20 Name\\n                keccak256(bytes(domainVersion())), // Version\\n                chainID,\\n                address(this)\\n            )\\n        );\\n\\n        return domainSeparatorHash;\\n    }\\n\\n    function domainSeparator() public returns (bytes32) {\\n        return _domainSeparator();\\n    }\\n\\n    function _updateDomainSeparator() private returns (bytes32) {\\n        uint256 chainID = _chainID();\\n\\n        bytes32 newDomainSeparator = generateDomainSeparator();\\n\\n        domainSeparators[chainID] = newDomainSeparator;\\n\\n        return newDomainSeparator;\\n    }\\n\\n    // Returns the domain separator, updating it if chainID changes\\n    function _domainSeparator() private returns (bytes32) {\\n        bytes32 currentDomainSeparator = domainSeparators[_chainID()];\\n\\n        if (currentDomainSeparator != 0x00) {\\n            return currentDomainSeparator;\\n        }\\n\\n        return _updateDomainSeparator();\\n    }\\n\\n    function _chainID() internal view returns (uint256) {\\n        uint256 chainID;\\n        assembly {\\n            chainID := chainid()\\n        }\\n\\n        return chainID;\\n    }\\n}\"\r\n    },\r\n    \"contracts/extensions/userExtensions/IERC1400TokensRecipient.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n/**\\n * The contract is utilised and constructed from UniversalToken implementatation \\n * with modifications done to suit the Wallex ecosystem\\n * See https://github.com/ConsenSys/UniversalToken\\n * @title IERC1400TokensRecipient\\n * @dev ERC1400TokensRecipient interface\\n */\\ninterface IERC1400TokensRecipient {\\n\\n  function canReceive(\\n    bytes calldata payload,\\n    bytes32 partition,\\n    address operator,\\n    address from,\\n    address to,\\n    uint value,\\n    bytes calldata data,\\n    bytes calldata operatorData\\n  ) external view returns(bool);\\n\\n  function tokensReceived(\\n    bytes calldata payload,\\n    bytes32 partition,\\n    address operator,\\n    address from,\\n    address to,\\n    uint value,\\n    bytes calldata data,\\n    bytes calldata operatorData\\n  ) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/userExtensions/IERC1400TokensSender.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n/**\\n * The contract is utilised and constructed from UniversalToken implementatation \\n * with modifications done to suit the Wallex ecosystem\\n * See https://github.com/ConsenSys/UniversalToken\\n * @title IERC1400TokensSender\\n * @dev ERC1400TokensSender interface\\n */\\ninterface IERC1400TokensSender {\\n\\n  function canTransfer(\\n    bytes calldata payload,\\n    bytes32 partition,\\n    address operator,\\n    address from,\\n    address to,\\n    uint value,\\n    bytes calldata data,\\n    bytes calldata operatorData\\n  ) external view returns(bool);\\n\\n  function tokensToTransfer(\\n    bytes calldata payload,\\n    bytes32 partition,\\n    address operator,\\n    address from,\\n    address to,\\n    uint value,\\n    bytes calldata data,\\n    bytes calldata operatorData\\n  ) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/extensions/tokenExtensions/IERC1400TokensValidator.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n/**\\n * The contract is utilised and constructed from UniversalToken implementatation \\n * with modifications done to suit the Wallex ecosystem\\n * See https://github.com/ConsenSys/UniversalToken\\n * @title IERC1400TokensValidator\\n * @dev ERC1400TokensValidator interface\\n */\\ninterface IERC1400TokensValidator {\\n  \\n  /**\\n   * @dev Verify if a token transfer can be executed or not, on the validator's perspective.\\n   * @param token Token address.\\n   * @param payload Payload of the initial transaction.\\n   * @param partition Name of the partition (left empty for ERC20 transfer).\\n   * @param operator Address which triggered the balance decrease (through transfer or redemption).\\n   * @param from Token holder.\\n   * @param to Token recipient for a transfer and 0x for a redemption.\\n   * @param value Number of tokens the token holder balance is decreased by.\\n   * @param data Extra information.\\n   * @param operatorData Extra information, attached by the operator (if any).\\n   * @return 'true' if the token transfer can be validated, 'false' if not.\\n   */\\n  struct ValidateData {\\n    address token;\\n    bytes payload;\\n    bytes32 partition;\\n    address operator;\\n    address from;\\n    address to;\\n    uint value;\\n    bytes data;\\n    bytes operatorData;\\n  }\\n\\n  function canValidate(ValidateData calldata data) external view returns(bool);\\n\\n  function tokensToValidate(\\n    bytes calldata payload,\\n    bytes32 partition,\\n    address operator,\\n    address from,\\n    address to,\\n    uint value,\\n    bytes calldata data,\\n    bytes calldata operatorData\\n  ) external;\\n  \\n  function canBurn(\\n    bytes calldata payload,\\n    bytes32 partition,\\n    address operator,\\n    address from,\\n    address to,\\n    uint value,\\n    bytes calldata data,\\n    bytes calldata operatorData\\n  ) external;\\n  \\n  function canMint(\\n    bytes calldata payload,\\n    bytes32 partition,\\n    address operator,\\n    address from,\\n    address to,\\n    uint value,\\n    bytes calldata data,\\n    bytes calldata operatorData\\n  ) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/IERC1400.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n// ****************** Document Management *******************\\nimport \\\"./interface/IERC1643.sol\\\";\\n\\n/**\\n * The contract is utilised and constructed from UniversalToken implementatation \\n * See https://github.com/ConsenSys/UniversalToken\\n * @title IERC1400 security token standard\\n * @dev See https://github.com/SecurityTokenStandard/EIP-Spec/blob/master/eip/eip-1400.md\\n */\\ninterface IERC1400 is IERC20, IERC1643 {\\n\\n  // ******************* Token Information ********************\\n  function balanceOfByPartition(bytes32 partition, address tokenHolder) external view returns (uint256);\\n  function partitionsOf(address tokenHolder) external view returns (bytes32[] memory);\\n\\n  // *********************** Transfers ************************\\n  function transferWithData(address to, uint256 value, bytes calldata data) external;\\n  function transferFromWithData(address from, address to, uint256 value, bytes calldata data) external;\\n\\n  // *************** Partition Token Transfers ****************\\n  function transferByPartition(bytes32 partition, address to, uint256 value, bytes calldata data) external returns (bytes32);\\n  function operatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external returns (bytes32);\\n\\n  // ****************** Controller Operation ******************\\n  function isControllable() external view returns (bool);\\n  // function controllerTransfer(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \\\"operatorTransferByPartition\\\"\\n  // function controllerRedeem(address tokenHolder, uint256 value, bytes calldata data, bytes calldata operatorData) external; // removed because same action can be achieved with \\\"operatorRedeemByPartition\\\"\\n\\n  // ****************** Operator Management *******************\\n  function authorizeOperator(address operator) external;\\n  function revokeOperator(address operator) external;\\n  function authorizeOperatorByPartition(bytes32 partition, address operator) external;\\n  function revokeOperatorByPartition(bytes32 partition, address operator) external;\\n\\n  // ****************** Operator Information ******************\\n  function isOperator(address operator, address tokenHolder) external view returns (bool);\\n  function isOperatorForPartition(bytes32 partition, address operator, address tokenHolder) external view returns (bool);\\n\\n  // ********************* Token Issuance *********************\\n  function isIssuable() external view returns (bool);\\n  function issue(address tokenHolder, uint256 value, bytes calldata data) external;\\n  function issueByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata data) external;\\n\\n  // ******************** Token Redemption ********************\\n  function redeem(uint256 value, bytes calldata data) external;\\n  function redeemFrom(address tokenHolder, uint256 value, bytes calldata data) external;\\n  function redeemByPartition(bytes32 partition, uint256 value, bytes calldata data) external;\\n  function operatorRedeemByPartition(bytes32 partition, address tokenHolder, uint256 value, bytes calldata operatorData) external;\\n\\n  // ******************* Transfer Validity ********************\\n  // We use different transfer validity functions because those described in the interface don't follow validity rules for our engagement\\n  //\\n  // function canTransfer(address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\\n  // function canTransferFrom(address from, address to, uint256 value, bytes calldata data) external view returns (byte, bytes32);\\n  // function canTransferByPartition(address from, address to, bytes32 partition, uint256 value, bytes calldata data) external view returns (byte, bytes32, bytes32);    \\n\\n  // ******************* Controller Events ********************\\n  // We don't use this event as we don't use \\\"controllerTransfer\\\"\\n  //   event ControllerTransfer(\\n  //       address controller,\\n  //       address indexed from,\\n  //       address indexed to,\\n  //       uint256 value,\\n  //       bytes data,\\n  //       bytes operatorData\\n  //   );\\n  //\\n  // We don't use this event as we don't use \\\"controllerRedeem\\\"\\n  //   event ControllerRedemption(\\n  //       address controller,\\n  //       address indexed tokenHolder,\\n  //       uint256 value,\\n  //       bytes data,\\n  //       bytes operatorData\\n  //   );\\n\\n  // ******************** Transfer Events *********************\\n  event TransferByPartition(\\n      bytes32 indexed fromPartition,\\n      address operator,\\n      address indexed from,\\n      address indexed to,\\n      uint256 value,\\n      bytes data,\\n      bytes operatorData\\n  );\\n\\n  event ChangedPartition(\\n      bytes32 indexed fromPartition,\\n      bytes32 indexed toPartition,\\n      uint256 value\\n  );\\n\\n  // ******************** Operator Events *********************\\n  event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\\n  event RevokedOperator(address indexed operator, address indexed tokenHolder);\\n  event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\\n  event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);\\n\\n  // ************** Issuance / Redemption Events **************\\n  event Issued(address indexed operator, address indexed to, uint256 value, bytes data);\\n  event Redeemed(address indexed operator, address indexed from, uint256 value, bytes data);\\n  event IssuedByPartition(bytes32 indexed partition, address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);\\n  event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes operatorData);\\n\\n}\\n\\n/**\\n * Reason codes - ERC-1066\\n *\\n * To improve the token holder experience, canTransfer MUST return a reason byte code\\n * on success or failure based on the ERC-1066 application-specific status codes specified below.\\n * An implementation can also return arbitrary data as a bytes32 to provide additional\\n * information not captured by the reason code.\\n * \\n * Code\\tReason\\n * 0x50\\ttransfer failure\\n * 0x51\\ttransfer success\\n * 0x52\\tinsufficient balance\\n * 0x53\\tinsufficient allowance\\n * 0x54\\ttransfers halted (contract paused)\\n * 0x55\\tfunds locked (lockup period)\\n * 0x56\\tinvalid sender\\n * 0x57\\tinvalid receiver\\n * 0x58\\tinvalid operator (transfer agent)\\n * 0x59\\t\\n * 0x5a\\t\\n * 0x5b\\t\\n * 0x5a\\t\\n * 0x5b\\t\\n * 0x5c\\t\\n * 0x5d\\t\\n * 0x5e\\t\\n * 0x5f\\ttoken meta or info\\n *\\n * These codes are being discussed at: https://ethereum-magicians.org/t/erc-1066-ethereum-status-codes-esc/283/24\\n */\"\r\n    },\r\n    \"contracts/roles/MinterRole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Roles.sol\\\";\\n\\n/**\\n * @title MinterRole\\n * @dev Minters are responsible for minting new tokens.\\n */\\nabstract contract MinterRole {\\n    using Roles for Roles.Role;\\n\\n    event MinterAdded(address indexed account);\\n    event MinterRemoved(address indexed account);\\n\\n    Roles.Role private _minters;\\n\\n    constructor() {\\n        _addMinter(msg.sender);\\n    }\\n\\n    modifier onlyMinter() virtual {\\n        require(isMinter(msg.sender));\\n        _;\\n    }\\n\\n    function isMinter(address account) public view returns (bool) {\\n        return _minters.has(account);\\n    }\\n\\n    function addMinter(address account) public onlyMinter {\\n        _addMinter(account);\\n    }\\n\\n    function removeMinter(address account) public onlyMinter {\\n        _removeMinter(account);\\n    }\\n\\n    function renounceMinter() public {\\n        _removeMinter(msg.sender);\\n    }\\n\\n    function _addMinter(address account) internal {\\n        _minters.add(account);\\n        emit MinterAdded(account);\\n    }\\n\\n    function _removeMinter(address account) internal {\\n        _minters.remove(account);\\n        emit MinterRemoved(account);\\n    }\\n}\"\r\n    },\r\n    \"contracts/interface/ERC1820Implementer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n\\ncontract ERC1820Implementer {\\n  bytes32 constant ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\\\"ERC1820_ACCEPT_MAGIC\\\"));\\n\\n  mapping(bytes32 => bool) internal _interfaceHashes;\\n\\n  function canImplementInterfaceForAddress(bytes32 interfaceHash, address /*addr*/) // Comments to avoid compilation warnings for unused variables.\\n    external\\n    view\\n    returns(bytes32)\\n  {\\n    if(_interfaceHashes[interfaceHash]) {\\n      return ERC1820_ACCEPT_MAGIC;\\n    } else {\\n      return \\\"\\\";\\n    }\\n  }\\n\\n  function _setInterface(string memory interfaceLabel) internal {\\n    _interfaceHashes[keccak256(abi.encodePacked(interfaceLabel))] = true;\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/tools/ERC1820Client.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\\\";\\n\\n\\n/// Base client to interact with the registry.\\ncontract ERC1820Client {\\n    IERC1820Registry constant ERC1820REGISTRY = IERC1820Registry(0x5b7aF3FB3f7Fc4a238AFa39d5130B30ed30e0e0C);\\n\\n    function setInterfaceImplementation(string memory _interfaceLabel, address _implementation) internal {\\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\\n        ERC1820REGISTRY.setInterfaceImplementer(address(this), interfaceHash, _implementation);\\n    }\\n\\n    function interfaceAddr(address addr, string memory _interfaceLabel) internal view returns(address) {\\n        bytes32 interfaceHash = keccak256(abi.encodePacked(_interfaceLabel));\\n        return ERC1820REGISTRY.getInterfaceImplementer(addr, interfaceHash);\\n    }\\n\\n    function delegateManagement(address _newManager) internal {\\n        ERC1820REGISTRY.setManager(address(this), _newManager);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the global ERC1820 Registry, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\\n * implementers for interfaces in this registry, as well as query support.\\n *\\n * Implementers may be shared by multiple accounts, and can also implement more\\n * than a single interface for each account. Contracts can implement interfaces\\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\\n * contract.\\n *\\n * {IERC165} interfaces can also be queried via the registry.\\n *\\n * For an in-depth explanation and source code analysis, see the EIP text.\\n */\\ninterface IERC1820Registry {\\n    /**\\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\\n     * account is able to set interface implementers for it.\\n     *\\n     * By default, each account is its own manager. Passing a value of `0x0` in\\n     * `newManager` will reset the manager to this initial state.\\n     *\\n     * Emits a {ManagerChanged} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the current manager for `account`.\\n     */\\n    function setManager(address account, address newManager) external;\\n\\n    /**\\n     * @dev Returns the manager for `account`.\\n     *\\n     * See {setManager}.\\n     */\\n    function getManager(address account) external view returns (address);\\n\\n    /**\\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\\n     * `interfaceHash`.\\n     *\\n     * `account` being the zero address is an alias for the caller's address.\\n     * The zero address can also be used in `implementer` to remove an old one.\\n     *\\n     * See {interfaceHash} to learn how these are created.\\n     *\\n     * Emits an {InterfaceImplementerSet} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the current manager for `account`.\\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\\n     * end in 28 zeroes).\\n     * - `implementer` must implement {IERC1820Implementer} and return true when\\n     * queried for support, unless `implementer` is the caller. See\\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\\n     */\\n    function setInterfaceImplementer(\\n        address account,\\n        bytes32 _interfaceHash,\\n        address implementer\\n    ) external;\\n\\n    /**\\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\\n     * implementer is registered, returns the zero address.\\n     *\\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\\n     * zeroes), `account` will be queried for support of it.\\n     *\\n     * `account` being the zero address is an alias for the caller's address.\\n     */\\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\\n\\n    /**\\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\\n     * corresponding\\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\\n     */\\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\\n\\n    /**\\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\\n     * @param account Address of the contract for which to update the cache.\\n     * @param interfaceId ERC165 interface for which to update the cache.\\n     */\\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\\n\\n    /**\\n     * @notice Checks whether a contract implements an ERC165 interface or not.\\n     * If the result is not cached a direct lookup on the contract address is performed.\\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\\n     * {updateERC165Cache} with the contract address.\\n     * @param account Address of the contract to check.\\n     * @param interfaceId ERC165 interface to check.\\n     * @return True if `account` implements `interfaceId`, false otherwise.\\n     */\\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\\n\\n    /**\\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\\n     * @param account Address of the contract to check.\\n     * @param interfaceId ERC165 interface to check.\\n     * @return True if `account` implements `interfaceId`, false otherwise.\\n     */\\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\\n\\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\\n\\n    event ManagerChanged(address indexed account, address indexed newManager);\\n}\\n\"\r\n    },\r\n    \"contracts/roles/Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address => bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account's access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\"\r\n    },\r\n    \"contracts/interface/IERC1643.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title IERC1643 Document Management (part of the ERC1400 Security Token Standards)\\n/// @dev See https://github.com/SecurityTokenStandard/EIP-Spec\\n\\ninterface IERC1643 {\\n\\n    // Document Management\\n    function getDocument(bytes32 _name) external view returns (string memory, bytes32, uint256);\\n    function setDocument(bytes32 _name, string memory _uri, bytes32 _documentHash) external;\\n    function removeDocument(bytes32 _name) external;\\n    function getAllDocuments() external view returns (bytes32[] memory);\\n\\n    // Document Events\\n    event DocumentRemoved(bytes32 indexed name, string uri, bytes32 documentHash);\\n    event DocumentUpdated(bytes32 indexed name, string uri, bytes32 documentHash);\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"granularity\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"controllers\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"defaultPartitions\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ApprovalByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"AuthorizedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"toPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ChangedPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"DocumentRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"DocumentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Issued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"IssuedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"RedeemedByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"RevokedOperatorByPartition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"fromPartition\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"TransferByPartition\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowanceByPartition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approveByPartition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"authorizeOperatorByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"balanceOfByPartition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"interfaceHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"canImplementInterfaceForAddress\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"canTransfer\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controllers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"controllersByPartition\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generateDomainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllDocuments\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefaultPartitions\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"getDocument\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"granularity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isControllable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isIssuable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"isOperatorForPartition\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"issue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"issueByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newContractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"definitive\",\"type\":\"bool\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorRedeemByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"operatorData\",\"type\":\"bytes\"}],\"name\":\"operatorTransferByPartition\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenHolder\",\"type\":\"address\"}],\"name\":\"partitionsOf\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeemByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeemFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"removeDocument\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceIssuance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"revokeOperatorByPartition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setControllers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"partitions\",\"type\":\"bytes32[]\"}],\"name\":\"setDefaultPartitions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"documentHash\",\"type\":\"bytes32\"}],\"name\":\"setDocument\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"}],\"name\":\"setPartitionControllers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"extension\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"interfaceLabel\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"removeOldExtensionRoles\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"addMinterRoleForExtension\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"addControllerRoleForExtension\",\"type\":\"bool\"}],\"name\":\"setTokenExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPartitions\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"}],\"name\":\"totalSupplyByPartition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"partition\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferByPartition\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferFromWithData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferWithData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"WallexBankToken","CompilerVersion":"v0.8.10+commit.fc410830","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000100000000000000000000000004e97c17bae360b2805163bf9c4b447a858294b20000000000000000000000000000000000000000000000000000000000000003697373756564000000000000000000000000000000000000000000000000000072657365727665640000000000000000000000000000000000000000000000006c6f636b65640000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}