{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.7.6;\r\npragma abicoder v2;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, throws on overflow.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ninterface ChromaticPlotInterface {\r\n    function getOwnedTokenIds(address owner)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function getOwnedTokenIdsSegment(\r\n        address owner,\r\n        uint256 startIndex,\r\n        uint256 count\r\n    ) external view returns (uint256[] memory);\r\n\r\n    function getTransmutingTokenIds(address owner)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    function getTransmutingTokenIdsSegment(\r\n        address owner,\r\n        uint256 startIndex,\r\n        uint256 count\r\n    ) external view returns (uint256[] memory);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function transmutingBalanceOf(address transmuter)\r\n        external\r\n        view\r\n        returns (uint256 balance);\r\n}\r\n\r\ncontract PolygonChromaticPlotTicket is IERC721 {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Event emitted when minting a new NFT. \"createdVia\" is the index of the Cryptopunk/Autoglyph that was used to mint, or 0 if not applicable.\r\n     */\r\n    event Mint(uint256 indexed index, address indexed minter);\r\n\r\n    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    uint256 public networkId;\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n    mapping(uint256 => address) public idToOwner;\r\n    mapping(uint256 => address) internal idToApproval;\r\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\r\n    mapping(address => uint256[]) public ownerToIds;\r\n    mapping(uint256 => uint256) public idToOwnerIndex;\r\n    mapping(uint256 => bool) public redeemed;\r\n\r\n    string internal nftName = \"Polygon Chromatic Plot Ticket\";\r\n    string internal nftSymbol = \"ticket\";\r\n\r\n    uint256 public numTokens = 0;\r\n    uint256 public numSales = 0;\r\n\r\n    address public chromaticPlot;\r\n\r\n    bool private reentrancyLock = false;\r\n\r\n    /* Prevent a contract function from being reentrant-called. */\r\n    modifier reentrancyGuard() {\r\n        if (reentrancyLock) {\r\n            revert();\r\n        }\r\n        reentrancyLock = true;\r\n        _;\r\n        reentrancyLock = false;\r\n    }\r\n\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(\r\n            tokenOwner == msg.sender ||\r\n                idToApproval[_tokenId] == msg.sender ||\r\n                ownerToOperators[tokenOwner][msg.sender],\r\n            \"Cannot transfer.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier canOperate(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(\r\n            tokenOwner == msg.sender ||\r\n                ownerToOperators[tokenOwner][msg.sender],\r\n            \"Cannot operate.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier validNFToken(uint256 _tokenId) {\r\n        require(idToOwner[_tokenId] != address(0), \"Invalid token.\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address payable _adminAddress,\r\n        address _chromaticPlot,\r\n        uint256 _networkId\r\n    ) {\r\n        networkId = _networkId;\r\n        adminAddress = _adminAddress;\r\n        chromaticPlot = _chromaticPlot;\r\n\r\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n        supportedInterfaces[0x780e9d63] = true; // ERC721 Enumerable\r\n        supportedInterfaces[0x5b5e139f] = true; // ERC721 Metadata\r\n    }\r\n\r\n    function getReedamableCount(address _owner)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 count = 0;\r\n        uint256[] memory ownedTokenIds = ChromaticPlotInterface(chromaticPlot)\r\n            .getOwnedTokenIds(_owner);\r\n        for (uint256 i = 0; i < ownedTokenIds.length; i++) {\r\n            uint256 ownedId = ownedTokenIds[i];\r\n            if (!redeemed[ownedId]) {\r\n                count += 1;\r\n            }\r\n        }\r\n\r\n        uint256[] memory transmutingTokenIds = ChromaticPlotInterface(\r\n            chromaticPlot\r\n        ).getTransmutingTokenIds(_owner);\r\n        for (uint256 i = 0; i < transmutingTokenIds.length; i++) {\r\n            uint256 transmutingId = transmutingTokenIds[i];\r\n            if (!redeemed[transmutingId]) {\r\n                count += 1;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n\r\n    function redeemAll() external reentrancyGuard {\r\n        uint256[] memory ownedTokenIds = ChromaticPlotInterface(chromaticPlot)\r\n            .getOwnedTokenIds(msg.sender);\r\n        for (uint256 i = 0; i < ownedTokenIds.length; i++) {\r\n            uint256 ownedId = ownedTokenIds[i];\r\n            if (!redeemed[ownedId]) {\r\n                _mint(msg.sender, ownedId);\r\n                redeemed[ownedId] = true;\r\n            }\r\n        }\r\n\r\n        uint256[] memory transmutingTokenIds = ChromaticPlotInterface(\r\n            chromaticPlot\r\n        ).getTransmutingTokenIds(msg.sender);\r\n        for (uint256 i = 0; i < transmutingTokenIds.length; i++) {\r\n            uint256 transmutingId = transmutingTokenIds[i];\r\n            if (!redeemed[transmutingId]) {\r\n                _mint(msg.sender, transmutingId);\r\n                redeemed[transmutingId] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function redeemOwnedFromIndex(uint256 _startIndex, uint256 _quantity)\r\n        external\r\n        reentrancyGuard\r\n    {\r\n        uint256[] memory ownedTokenIds = ChromaticPlotInterface(chromaticPlot)\r\n            .getOwnedTokenIdsSegment(msg.sender, _startIndex, _quantity);\r\n        for (uint256 i = 0; i < ownedTokenIds.length; i++) {\r\n            uint256 ownedId = ownedTokenIds[i];\r\n            if (!redeemed[ownedId]) {\r\n                _mint(msg.sender, ownedId);\r\n                redeemed[ownedId] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function redeemTransmutingFromIndex(uint256 _startIndex, uint256 _quantity)\r\n        external\r\n        reentrancyGuard\r\n    {\r\n        uint256[] memory transmutingTokenIds = ChromaticPlotInterface(\r\n            chromaticPlot\r\n        ).getTransmutingTokenIdsSegment(msg.sender, _startIndex, _quantity);\r\n        for (uint256 i = 0; i < transmutingTokenIds.length; i++) {\r\n            uint256 transmutingId = transmutingTokenIds[i];\r\n            if (!redeemed[transmutingId]) {\r\n                _mint(msg.sender, transmutingId);\r\n                redeemed[transmutingId] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _mint(address _to, uint256 _id) internal returns (uint256) {\r\n        require(_to != address(0), \"Cannot mint to 0x0.\");\r\n        numTokens = numTokens + 1;\r\n        _addNFToken(_to, _id);\r\n        emit Mint(_id, _to);\r\n        emit Transfer(address(0), _to, _id);\r\n        return _id;\r\n    }\r\n\r\n    function _addNFToken(address _to, uint256 _tokenId) internal {\r\n        idToOwner[_tokenId] = _to;\r\n        ownerToIds[_to].push(_tokenId);\r\n        idToOwnerIndex[_tokenId] = ownerToIds[_to].length.sub(1);\r\n    }\r\n\r\n    function _removeNFToken(address _from, uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == _from, \"Incorrect owner.\");\r\n        delete idToOwner[_tokenId];\r\n\r\n        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownerToIds[_from].length.sub(1);\r\n\r\n        if (lastTokenIndex != tokenToRemoveIndex) {\r\n            uint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n            ownerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n            idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n        }\r\n\r\n        ownerToIds[_from].pop();\r\n    }\r\n\r\n    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\r\n        return ownerToIds[_owner].length;\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes memory _data\r\n    ) private canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from, \"Incorrect owner.\");\r\n        require(_to != address(0));\r\n\r\n        _transfer(_to, _tokenId);\r\n\r\n        if (isContract(_to)) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(\r\n                msg.sender,\r\n                _from,\r\n                _tokenId,\r\n                _data\r\n            );\r\n            require(retval == MAGIC_ON_ERC721_RECEIVED);\r\n        }\r\n    }\r\n\r\n    function _clearApproval(uint256 _tokenId) private {\r\n        if (idToApproval[_tokenId] != address(0)) {\r\n            delete idToApproval[_tokenId];\r\n        }\r\n    }\r\n\r\n    //////////////////////////\r\n    ////    Enumerable    ////\r\n    //////////////////////////\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return numTokens;\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(_index < ownerToIds[_owner].length);\r\n        return ownerToIds[_owner][_index];\r\n    }\r\n\r\n    //////////////////////////\r\n    ////  Administration  ////\r\n    //////////////////////////\r\n    address payable public adminAddress;\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == adminAddress, \"Only admin.\");\r\n        _;\r\n    }\r\n\r\n    function setAdmin(address payable _newAdmin) external onlyAdmin {\r\n        adminAddress = _newAdmin;\r\n    }\r\n\r\n    //////////////////////////\r\n    //// ERC 721 and 165  ////\r\n    //////////////////////////\r\n    function isContract(address _addr)\r\n        internal\r\n        view\r\n        returns (bool addressCheck)\r\n    {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        } // solhint-disable-line\r\n        addressCheck = size > 0;\r\n    }\r\n\r\n    function supportsInterface(bytes4 _interfaceID)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return supportedInterfaces[_interfaceID];\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external override {\r\n        _safeTransferFrom(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external override {\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external override canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from, \"Wrong from address.\");\r\n        require(_to != address(0), \"Cannot send to 0x0.\");\r\n        _transfer(_to, _tokenId);\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId)\r\n        external\r\n        override\r\n        canOperate(_tokenId)\r\n        validNFToken(_tokenId)\r\n    {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(_approved != tokenOwner);\r\n        idToApproval[_tokenId] = _approved;\r\n        emit Approval(tokenOwner, _approved, _tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved)\r\n        external\r\n        override\r\n    {\r\n        ownerToOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function balanceOf(address _owner)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        require(_owner != address(0));\r\n        return _getOwnerNFTCount(_owner);\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId)\r\n        external\r\n        view\r\n        override\r\n        returns (address _owner)\r\n    {\r\n        require(idToOwner[_tokenId] != address(0));\r\n        _owner = idToOwner[_tokenId];\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId)\r\n        external\r\n        view\r\n        override\r\n        validNFToken(_tokenId)\r\n        returns (address)\r\n    {\r\n        return idToApproval[_tokenId];\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return ownerToOperators[_owner][_operator];\r\n    }\r\n\r\n    function _transfer(address _to, uint256 _tokenId) internal {\r\n        address from = idToOwner[_tokenId];\r\n        _clearApproval(_tokenId);\r\n\r\n        _removeNFToken(from, _tokenId);\r\n        _addNFToken(_to, _tokenId);\r\n\r\n        emit Transfer(from, _to, _tokenId);\r\n    }\r\n\r\n    //////////////////////////\r\n    ////     Metadata     ////\r\n    //////////////////////////\r\n\r\n    /**\r\n     * @dev Returns a descriptive name for a collection of NFTokens.\r\n     * @return _name Representing name.\r\n     */\r\n    function name() external view returns (string memory _name) {\r\n        _name = nftName;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an abbreviated name for NFTokens.\r\n     * @return _symbol Representing symbol.\r\n     */\r\n    function symbol() external view returns (string memory _symbol) {\r\n        _symbol = nftSymbol;\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_adminAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_chromaticPlot\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_networkId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chromaticPlot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getReedamableCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToOwnerIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numSales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerToIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"redeemOwnedFromIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quantity\",\"type\":\"uint256\"}],\"name\":\"redeemTransmutingFromIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"redeemed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PolygonChromaticPlotTicket","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000092f3fea51013d04c81f1dcad033e08e802ad435e00000000000000000000000006ccc32df2a23911a1013a8196e55eb986cf16fd0000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":"0","Implementation":"","SwarmSource":"ipfs://911e4b45f61fa2beb8ad18660b9ded0e7f6db88dd5040ce7d4022ec02e14b03a"}]}