{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@eth-optimism/contracts/libraries/bridge/CrossDomainEnabled.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/* Interface Imports */\\nimport { ICrossDomainMessenger } from \\\"./ICrossDomainMessenger.sol\\\";\\n\\n/**\\n * @title CrossDomainEnabled\\n * @dev Helper contract for contracts performing cross-domain communications\\n *\\n * Compiler used: defined by inheriting contract\\n */\\ncontract CrossDomainEnabled {\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    // Messenger contract used to send and recieve messages from the other domain.\\n    address public messenger;\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _messenger Address of the CrossDomainMessenger on the current layer.\\n     */\\n    constructor(address _messenger) {\\n        messenger = _messenger;\\n    }\\n\\n    /**********************\\n     * Function Modifiers *\\n     **********************/\\n\\n    /**\\n     * Enforces that the modified function is only callable by a specific cross-domain account.\\n     * @param _sourceDomainAccount The only account on the originating domain which is\\n     *  authenticated to call this function.\\n     */\\n    modifier onlyFromCrossDomainAccount(address _sourceDomainAccount) {\\n        require(\\n            msg.sender == address(getCrossDomainMessenger()),\\n            \\\"OVM_XCHAIN: messenger contract unauthenticated\\\"\\n        );\\n\\n        require(\\n            getCrossDomainMessenger().xDomainMessageSender() == _sourceDomainAccount,\\n            \\\"OVM_XCHAIN: wrong sender of cross-domain message\\\"\\n        );\\n\\n        _;\\n    }\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Gets the messenger, usually from storage. This function is exposed in case a child contract\\n     * needs to override.\\n     * @return The address of the cross-domain messenger contract which should be used.\\n     */\\n    function getCrossDomainMessenger() internal virtual returns (ICrossDomainMessenger) {\\n        return ICrossDomainMessenger(messenger);\\n    }\\n\\n    /**q\\n     * Sends a message to an account on another domain\\n     * @param _crossDomainTarget The intended recipient on the destination domain\\n     * @param _message The data to send to the target (usually calldata to a function with\\n     *  `onlyFromCrossDomainAccount()`)\\n     * @param _gasLimit The gasLimit for the receipt of the message on the target domain.\\n     */\\n    function sendCrossDomainMessage(\\n        address _crossDomainTarget,\\n        uint32 _gasLimit,\\n        bytes memory _message\\n    ) internal {\\n        // slither-disable-next-line reentrancy-events, reentrancy-benign\\n        getCrossDomainMessenger().sendMessage(_crossDomainTarget, _message, _gasLimit);\\n    }\\n}\\n\"\r\n    },\r\n    \"@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.9.0;\\n\\n/**\\n * @title ICrossDomainMessenger\\n */\\ninterface ICrossDomainMessenger {\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event SentMessage(\\n        address indexed target,\\n        address sender,\\n        bytes message,\\n        uint256 messageNonce,\\n        uint256 gasLimit\\n    );\\n    event RelayedMessage(bytes32 indexed msgHash);\\n    event FailedRelayedMessage(bytes32 indexed msgHash);\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    function xDomainMessageSender() external view returns (address);\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sends a cross domain message to the target messenger.\\n     * @param _target Target contract address.\\n     * @param _message Message to send to the target.\\n     * @param _gasLimit Gas limit for the provided message.\\n     */\\n    function sendMessage(\\n        address _target,\\n        bytes calldata _message,\\n        uint32 _gasLimit\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/implementation/Lockable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\\n */\\ncontract Lockable {\\n    bool private _notEntered;\\n\\n    constructor() {\\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\\n        // refund coming into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant` function is not supported. It is possible to\\n     * prevent this from happening by making the `nonReentrant` function external, and making it call a `private`\\n     * function that does the actual state modification.\\n     */\\n    modifier nonReentrant() {\\n        _preEntranceCheck();\\n        _preEntranceSet();\\n        _;\\n        _postEntranceReset();\\n    }\\n\\n    /**\\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\\n     */\\n    modifier nonReentrantView() {\\n        _preEntranceCheck();\\n        _;\\n    }\\n\\n    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\\n    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being\\n    // re-entered. Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and\\n    // then call `_postEntranceReset()`.\\n    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\\n    function _preEntranceCheck() internal view {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n\\n    function _preEntranceSet() internal {\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n    }\\n\\n    function _postEntranceReset() internal {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cross-chain-oracle/chain-adapters/Optimism_ParentMessenger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n// This should be replaced with a \\\"real\\\" import when Optimism release their new contract versions.\\nimport \\\"@eth-optimism/contracts/libraries/bridge/CrossDomainEnabled.sol\\\";\\nimport \\\"../interfaces/ParentMessengerInterface.sol\\\";\\nimport \\\"../interfaces/ParentMessengerConsumerInterface.sol\\\";\\nimport \\\"./ParentMessengerBase.sol\\\";\\nimport \\\"../../common/implementation/Lockable.sol\\\";\\n\\n/**\\n * @notice Sends cross chain messages from Ethereum L1 to Optimism L2 network.\\n * @dev This contract is ownable and should be owned by the DVM governor.\\n */\\ncontract Optimism_ParentMessenger is CrossDomainEnabled, ParentMessengerInterface, ParentMessengerBase, Lockable {\\n    event SetDefaultGasLimit(uint32 newDefaultGasLimit);\\n    event MessageSentToChild(bytes data, address indexed targetSpoke, uint32 gasLimit, address indexed childMessenger);\\n    event MessageReceivedFromChild(bytes data, address indexed childMessenger, address indexed targetHub);\\n\\n    uint32 public defaultGasLimit = 5_000_000;\\n\\n    /**\\n     * @notice Construct the Optimism_ParentMessenger contract.\\n     * @param _crossDomainMessenger The address of the Optimism cross domain messenger contract.\\n     * @param _childChainId The chain id of the Optimism L2 network this messenger should connect to.\\n     **/\\n    constructor(address _crossDomainMessenger, uint256 _childChainId)\\n        CrossDomainEnabled(_crossDomainMessenger)\\n        ParentMessengerBase(_childChainId)\\n    {}\\n\\n    /**\\n     * @notice Changes the default gas limit that is sent along with transactions to Optimism.\\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\\n     * @param newDefaultGasLimit the new L2 gas limit to be set.\\n     */\\n    function setDefaultGasLimit(uint32 newDefaultGasLimit) public onlyOwner nonReentrant() {\\n        defaultGasLimit = newDefaultGasLimit;\\n        emit SetDefaultGasLimit(newDefaultGasLimit);\\n    }\\n\\n    /**\\n     * @notice Changes the address of the oracle spoke on L2 via the child messenger.\\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\\n     * @param newOracleSpoke the new oracle spoke address set on L2.\\n     */\\n    function setChildOracleSpoke(address newOracleSpoke) public onlyOwner nonReentrant() {\\n        bytes memory dataSentToChild = abi.encodeWithSignature(\\\"setOracleSpoke(address)\\\", newOracleSpoke);\\n        sendCrossDomainMessage(childMessenger, defaultGasLimit, dataSentToChild);\\n        emit MessageSentToChild(dataSentToChild, address(0), defaultGasLimit, childMessenger);\\n    }\\n\\n    /**\\n     * @notice Changes the address of the parent messenger on L2 via the child messenger.\\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\\n     * @param newParentMessenger the new parent messenger contract to be set on L2.\\n     */\\n    function setChildParentMessenger(address newParentMessenger) public onlyOwner nonReentrant() {\\n        bytes memory dataSentToChild = abi.encodeWithSignature(\\\"setParentMessenger(address)\\\", newParentMessenger);\\n        sendCrossDomainMessage(childMessenger, defaultGasLimit, dataSentToChild);\\n        emit MessageSentToChild(dataSentToChild, address(0), defaultGasLimit, childMessenger);\\n    }\\n\\n    /**\\n     * @notice Changes the Optimism_ChildMessenger default gas limit on L2 via the child messenger.\\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\\n     * @param newDefaultGasLimit the new default gas limit set on L2.\\n     */\\n    function setChildDefaultGasLimit(uint32 newDefaultGasLimit) public onlyOwner nonReentrant() {\\n        bytes memory dataSentToChild = abi.encodeWithSignature(\\\"setDefaultGasLimit(uint32)\\\", newDefaultGasLimit);\\n        sendCrossDomainMessage(childMessenger, defaultGasLimit, dataSentToChild);\\n        emit MessageSentToChild(dataSentToChild, address(0), defaultGasLimit, childMessenger);\\n    }\\n\\n    /**\\n     * @notice Sends a message to the child messenger via the canonical message bridge.\\n     * @dev The caller must be the either the OracleHub or the GovernorHub. This is to send either a\\n     * price or initiate a governance action to the OracleSpoke or GovernorSpoke on the child network.\\n     * @dev The recipient of this message is the child messenger. The messenger must implement processMessageFromParent\\n     * which then forwards the data to the target either the OracleSpoke or the governorSpoke depending on the caller.\\n     * @param data data message sent to the child messenger. Should be an encoded function call or packed data.\\n     */\\n    function sendMessageToChild(bytes memory data) public override onlyHubContract() nonReentrant() {\\n        address target = msg.sender == oracleHub ? oracleSpoke : governorSpoke;\\n        bytes memory dataSentToChild =\\n            abi.encodeWithSignature(\\\"processMessageFromCrossChainParent(bytes,address)\\\", data, target);\\n        sendCrossDomainMessage(childMessenger, defaultGasLimit, dataSentToChild);\\n        emit MessageSentToChild(dataSentToChild, target, defaultGasLimit, childMessenger);\\n    }\\n\\n    /**\\n     * @notice Process a received message from the child messenger via the canonical message bridge.\\n     * @dev The caller must be the the child messenger, sent over the canonical message bridge.\\n     * @dev Note that only the OracleHub can receive messages from the child messenger. Therefore we can always forward\\n     * these messages to this contract. The OracleHub must implement processMessageFromChild to handle this message.\\n     * @param data data message sent from the child messenger. Should be an encoded function call or packed data.\\n     */\\n    function processMessageFromCrossChainChild(bytes memory data)\\n        public\\n        onlyFromCrossDomainAccount(childMessenger)\\n        nonReentrant()\\n    {\\n        ParentMessengerConsumerInterface(oracleHub).processMessageFromChild(childChainId, data);\\n        emit MessageReceivedFromChild(data, childMessenger, oracleHub);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cross-chain-oracle/chain-adapters/ParentMessengerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../interfaces/ParentMessengerInterface.sol\\\";\\n\\nabstract contract ParentMessengerBase is Ownable, ParentMessengerInterface {\\n    uint256 public childChainId;\\n\\n    address public childMessenger;\\n\\n    address public oracleHub;\\n    address public governorHub;\\n\\n    address public oracleSpoke;\\n    address public governorSpoke;\\n\\n    event SetChildMessenger(address indexed childMessenger);\\n    event SetOracleHub(address indexed oracleHub);\\n    event SetGovernorHub(address indexed governorHub);\\n    event SetOracleSpoke(address indexed oracleSpoke);\\n    event SetGovernorSpoke(address indexed governorSpoke);\\n\\n    modifier onlyHubContract() {\\n        require(msg.sender == oracleHub || msg.sender == governorHub, \\\"Only privileged caller\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Construct the ParentMessengerBase contract.\\n     * @param _childChainId The chain id of the L2 network this messenger should connect to.\\n     **/\\n    constructor(uint256 _childChainId) {\\n        childChainId = _childChainId;\\n    }\\n\\n    /*******************\\n     *  OWNER METHODS  *\\n     *******************/\\n\\n    /**\\n     * @notice Changes the stored address of the child messenger, deployed on L2.\\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\\n     * @param newChildMessenger address of the new child messenger, deployed on L2.\\n     */\\n    function setChildMessenger(address newChildMessenger) public onlyOwner {\\n        childMessenger = newChildMessenger;\\n        emit SetChildMessenger(childMessenger);\\n    }\\n\\n    /**\\n     * @notice Changes the stored address of the Oracle hub, deployed on L1.\\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\\n     * @param newOracleHub address of the new oracle hub, deployed on L1 Ethereum.\\n     */\\n    function setOracleHub(address newOracleHub) public onlyOwner {\\n        oracleHub = newOracleHub;\\n        emit SetOracleHub(oracleHub);\\n    }\\n\\n    /**\\n     * @notice Changes the stored address of the Governor hub, deployed on L1.\\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\\n     * @param newGovernorHub address of the new governor hub, deployed on L1 Ethereum.\\n     */\\n    function setGovernorHub(address newGovernorHub) public onlyOwner {\\n        governorHub = newGovernorHub;\\n        emit SetGovernorHub(governorHub);\\n    }\\n\\n    /**\\n     * @notice Changes the stored address of the oracle spoke, deployed on L2.\\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\\n     * @param newOracleSpoke address of the new oracle spoke, deployed on L2.\\n     */\\n    function setOracleSpoke(address newOracleSpoke) public onlyOwner {\\n        oracleSpoke = newOracleSpoke;\\n        emit SetOracleSpoke(oracleSpoke);\\n    }\\n\\n    /**\\n     * @notice Changes the stored address of the governor spoke, deployed on L2.\\n     * @dev The caller of this function must be the owner. This should be set to the DVM governor.\\n     * @param newGovernorSpoke address of the new governor spoke, deployed on L2.\\n     */\\n    function setGovernorSpoke(address newGovernorSpoke) public onlyOwner {\\n        governorSpoke = newGovernorSpoke;\\n        emit SetGovernorSpoke(governorSpoke);\\n    }\\n\\n    /**\\n     * @notice Returns the amount of ETH required for a caller to pass as msg.value when calling `sendMessageToChild`.\\n     * @return The amount of ETH required for a caller to pass as msg.value when calling `sendMessageToChild`.\\n     */\\n    function getL1CallValue() external view virtual override returns (uint256) {\\n        return 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cross-chain-oracle/interfaces/ParentMessengerConsumerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\ninterface ParentMessengerConsumerInterface {\\n    // Function called on Oracle hub to pass in data send from L2, with chain ID.\\n    function processMessageFromChild(uint256 chainId, bytes memory data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/cross-chain-oracle/interfaces/ParentMessengerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\ninterface ParentMessengerInterface {\\n    // Should send cross-chain message to Child messenger contract or revert.\\n    function sendMessageToChild(bytes memory data) external;\\n\\n    // Informs Hub how much msg.value they need to include to call `sendMessageToChild`.\\n    function getL1CallValue() external view returns (uint256);\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_crossDomainMessenger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_childChainId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"childMessenger\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"targetHub\",\"type\":\"address\"}],\"name\":\"MessageReceivedFromChild\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"targetSpoke\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"childMessenger\",\"type\":\"address\"}],\"name\":\"MessageSentToChild\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"childMessenger\",\"type\":\"address\"}],\"name\":\"SetChildMessenger\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newDefaultGasLimit\",\"type\":\"uint32\"}],\"name\":\"SetDefaultGasLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"governorHub\",\"type\":\"address\"}],\"name\":\"SetGovernorHub\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"governorSpoke\",\"type\":\"address\"}],\"name\":\"SetGovernorSpoke\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracleHub\",\"type\":\"address\"}],\"name\":\"SetOracleHub\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracleSpoke\",\"type\":\"address\"}],\"name\":\"SetOracleSpoke\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"childChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"childMessenger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultGasLimit\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getL1CallValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governorHub\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governorSpoke\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messenger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleHub\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleSpoke\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"processMessageFromCrossChainChild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendMessageToChild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newDefaultGasLimit\",\"type\":\"uint32\"}],\"name\":\"setChildDefaultGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newChildMessenger\",\"type\":\"address\"}],\"name\":\"setChildMessenger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOracleSpoke\",\"type\":\"address\"}],\"name\":\"setChildOracleSpoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newParentMessenger\",\"type\":\"address\"}],\"name\":\"setChildParentMessenger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newDefaultGasLimit\",\"type\":\"uint32\"}],\"name\":\"setDefaultGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernorHub\",\"type\":\"address\"}],\"name\":\"setGovernorHub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGovernorSpoke\",\"type\":\"address\"}],\"name\":\"setGovernorSpoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOracleHub\",\"type\":\"address\"}],\"name\":\"setOracleHub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOracleSpoke\",\"type\":\"address\"}],\"name\":\"setOracleSpoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Optimism_ParentMessenger","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"0000000000000000000000006d4528d192db72e282265d6092f4b872f9dff69e0000000000000000000000000000000000000000000000000000000000000120","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":"0","Implementation":"","SwarmSource":""}]}