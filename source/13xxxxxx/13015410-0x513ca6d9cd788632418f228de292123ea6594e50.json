{"status":"1","message":"OK","result":[{"SourceCode":"// File: @openzeppelin/contracts/introspection/IERC165.sol\r\n\r\n// spd-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n// spd-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.2;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n      *\r\n      * Requirements:\r\n      *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n      * - `tokenId` token must exist and be owned by `from`.\r\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n      *\r\n      * Emits a {Transfer} event.\r\n      */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\r\n\r\n// spd-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.2;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\r\n\r\n// spd-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.2;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n\r\n    /**\r\n     * @dev Returns the total amount of tokens stored by the contract.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * Use along with {totalSupply} to enumerate all tokens.\r\n     */\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Strings.sol\r\n\r\n// spd-License-Identifier: MIT\r\n\r\npragma solidity ^0.6.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        uint256 index = digits - 1;\r\n        temp = value;\r\n        while (temp != 0) {\r\n            buffer[index--] = byte(uint8(48 + temp % 10));\r\n            temp /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File: contracts/NFTLotteryURI.sol\r\n\r\n// spd-License-Identifier: AGPL-3.0-or-later\r\n\r\npragma solidity ^0.6.8;\r\n\r\n\r\n\r\n\r\n/// @title Base64\r\n/// @notice Provides a function for encoding some bytes in base64\r\n/// @author Brecht Devos <brecht@loopring.org>\r\nlibrary Base64 {\r\n    bytes internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n\r\n    /// @notice Encodes some bytes to the base64 representation\r\n    function encode(bytes memory data) internal pure returns (string memory) {\r\n        uint256 len = data.length;\r\n        if (len == 0) return '';\r\n\r\n        // multiply by 4/3 rounded up\r\n        uint256 encodedLen = 4 * ((len + 2) / 3);\r\n\r\n        // Add some extra buffer at the end\r\n        bytes memory result = new bytes(encodedLen + 32);\r\n\r\n        bytes memory table = TABLE;\r\n\r\n        assembly {\r\n            let tablePtr := add(table, 1)\r\n            let resultPtr := add(result, 32)\r\n\r\n            for {let i := 0} lt(i, len) {} {\r\n                i := add(i, 3)\r\n                let input := and(mload(add(data, i)), 0xffffff)\r\n\r\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\r\n                out := shl(8, out)\r\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\r\n                out := shl(224, out)\r\n\r\n                mstore(resultPtr, out)\r\n\r\n                resultPtr := add(resultPtr, 4)\r\n            }\r\n\r\n            switch mod(len, 3)\r\n            case 1 {\r\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\r\n            }\r\n            case 2 {\r\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\r\n            }\r\n\r\n            mstore(result, encodedLen)\r\n        }\r\n\r\n        return string(result);\r\n    }\r\n}\r\n\r\ninterface ILotteryInfo {\r\n  function prizeAddress() external view returns (address);\r\n  function prizeId() external view returns (uint256);\r\n  function startDate() external view returns (uint64);\r\n  function endDate() external view returns (uint64);\r\n  function minTicketsToSell() external view returns (uint32);\r\n  function maxTickets() external view returns (uint32);\r\n}\r\n\r\ncontract NFTLotteryURI {\r\n\r\n  string[] private hexAlphabet = [\"0\", \"1\",\"2\",\"3\",\"4\",\"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\r\n\r\n  using Strings for uint256;\r\n\r\n  function tokenURI(uint256 id) external view returns (string memory) {\r\n    string memory name = getLotteryName(msg.sender);\r\n    return string(\r\n      abi.encodePacked(\r\n      'data:application/json;base64,',\r\n      Base64.encode(\r\n      bytes(\r\n      abi.encodePacked(\r\n          '{\"name\":\"', name, ' ticket #', id.toString(),\r\n          '\", \"description\":\"', 'A lottery ticket for ', name,\r\n          '\", \"image\": \"',\r\n          'data:image/svg+xml;base64,',\r\n          getSVG(msg.sender, id),\r\n          '\"}'\r\n    )))));\r\n  }\r\n\r\n  function getLotteryName(address a) public view returns (string memory) {\r\n    ILotteryInfo lottery = ILotteryInfo(a);\r\n    return string(abi.encodePacked(IERC721Metadata(lottery.prizeAddress()).name(), \" #\", lottery.prizeId().toString()));\r\n  }\r\n\r\n  function getSVG(address a, uint256 id) public view returns (string memory) {\r\n    uint256 time = block.timestamp;\r\n    if (time > ILotteryInfo(a).endDate()) {\r\n      time = ILotteryInfo(a).endDate();\r\n    }\r\n    uint256 supply = IERC721Enumerable(a).totalSupply();\r\n    if (IERC721Enumerable(a).totalSupply() > ILotteryInfo(a).minTicketsToSell()) {\r\n      supply = ILotteryInfo(a).minTicketsToSell();\r\n    }\r\n    bytes memory svg = createTicket(a, id, time, supply);\r\n    return Base64.encode(svg);\r\n  }\r\n\r\n  function createTicket(address a, uint256 id, uint256 time, uint256 supply) public view returns (bytes memory) {\r\n    return abi.encodePacked('<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1000 1000\"><style>.big {font: bold 3rem monospace; } .small {font: bold 1.5rem monospace}</style><rect width=\"900\" height=\"400\" x=\"50\" y=\"50\" fill=\"#fff\" stroke-width=\"20\" stroke=\"black\"/>',\r\n    createGradient(a, id),\r\n    '<text x=\"80\" y=\"110\" class=\"big\">', getLotteryName(a), '</text>',\r\n    createSaleBlock(a, supply),\r\n    createTimeBlock(a, time),\r\n    '</svg>'\r\n    );\r\n  }\r\n\r\n  function createSaleBlock(address a, uint256 supply) public view returns (string memory) {\r\n    return string(\r\n      abi.encodePacked(\r\n    '<text x=\"80\" y=\"170\" class=\"small\">Tickets sold:', IERC721Enumerable(a).totalSupply().toString(), '</text>',\r\n    '<text x=\"450\" y=\"170\" class=\"small\">Min:', uint256(ILotteryInfo(a).minTicketsToSell()).toString(), '</text>',\r\n    '<text x=\"670\" y=\"170\" class=\"small\">Max:', uint256(ILotteryInfo(a).maxTickets()).toString(), '</text>',\r\n    '<rect width=\"', ((700 * supply) / ILotteryInfo(a).minTicketsToSell()).toString(), '\" height=\"40\" x=\"80\" y=\"190\" fill=\"url(#g)\" />',\r\n    '<text x=\"810\" y=\"220\" class=\"small\">', (supply*100 / ILotteryInfo(a).minTicketsToSell()).toString(),'%</text>'\r\n    ));\r\n  }\r\n\r\n  function createTimeBlock(address a, uint256 time) public view returns (string memory) {\r\n    return string(\r\n      abi.encodePacked(\r\n    '<text x=\"80\" y=\"300\" class=\"small\">Current time:', block.timestamp.toString(), '</text>',\r\n    '<text x=\"500\" y=\"300\" class=\"small\">End time:', uint256(ILotteryInfo(a).endDate()).toString(), '</text>',\r\n    '<rect width=\"', ((700 * (time - ILotteryInfo(a).startDate())) / (ILotteryInfo(a).endDate() - ILotteryInfo(a).startDate())).toString(), '\" height=\"40\" x=\"80\" y=\"320\" fill=\"url(#g2)\" />',\r\n    '<text x=\"810\" y=\"350\" class=\"small\">', ((time - ILotteryInfo(a).startDate())*100 / (ILotteryInfo(a).endDate() - ILotteryInfo(a).startDate())).toString(), '%</text>'\r\n    ));\r\n  }\r\n\r\n  function randHex(uint256 rng) public view returns (string memory) {\r\n    uint256 i1 = rng % 16;\r\n    uint256 i2 = uint256(keccak256(abi.encodePacked(rng, i1))) % 16;\r\n    uint256 i3 = uint256(keccak256(abi.encodePacked(rng, i2))) % 16;\r\n    uint256 i4 = uint256(keccak256(abi.encodePacked(rng, i3))) % 16;\r\n    uint256 i5 = uint256(keccak256(abi.encodePacked(rng, i4))) % 16;\r\n    uint256 i6 = uint256(keccak256(abi.encodePacked(rng, i5))) % 16;\r\n    return string(abi.encodePacked(\r\n      hexAlphabet[i1],\r\n      hexAlphabet[i2],\r\n      hexAlphabet[i3],\r\n      hexAlphabet[i4],\r\n      hexAlphabet[i5],\r\n      hexAlphabet[i6]\r\n    ));\r\n  }\r\n\r\n  function createGradient(address a, uint256 id) public view returns (string memory) {\r\n    uint256 color1 = uint256(keccak256(abi.encodePacked(a, id)));\r\n    uint256 color2 = uint256(keccak256(abi.encodePacked(color1, a, id)));\r\n    uint256 color3 = uint256(keccak256(abi.encodePacked(color2, a, id)));\r\n    uint256 color4 = uint256(keccak256(abi.encodePacked(color3, a, id)));\r\n    string memory svg = string(abi.encodePacked(\r\n      '<defs>',\r\n      gradientDef(randHex(color1), randHex(color2), randHex(color3), randHex(color4), \"g\", 4),\r\n      gradientDef(randHex(color1*color2), randHex(color2*color3), randHex(color3*color4), randHex(color4*color1), \"g2\", 3),\r\n      '</defs>'\r\n    ));\r\n    return svg;\r\n  }\r\n\r\n  function gradientDef(string memory color1, string memory color2, string memory color3, string memory color4, string memory gradientId, uint256 time) public view returns (string memory) {\r\n    return string(abi.encodePacked(\r\n      '<linearGradient id=\"',gradientId,'\"><stop offset=\"0%\" stop-color=\"#',\r\n      color1,\r\n      '\"><animate attributeName=\"stop-color\" values=\"#',color1,';#',color2,';#',color1,'\" dur=\"', time.toString(), 's\" repeatCount=\"indefinite\"/></stop><stop offset=\"100%\" stop-color=\"#',\r\n      color3,\r\n      '\"><animate attributeName=\"stop-color\" values=\"#',color3,';#',color4,';#',color3,'\" dur=\"', time.toString(), 's\" repeatCount=\"indefinite\"/></stop></linearGradient>'\r\n    ));\r\n  }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"createGradient\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"createSaleBlock\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"createTicket\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"createTimeBlock\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"getLotteryName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"color1\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"color2\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"color3\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"color4\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"gradientId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"gradientDef\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rng\",\"type\":\"uint256\"}],\"name\":\"randHex\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"NFTLotteryURI","CompilerVersion":"v0.6.8+commit.0bbfe453","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Unknown","Proxy":"0","Implementation":"","SwarmSource":"ipfs://5cc69daa8fc5cd73dcc2877c28a79ac637401f1c1d4e466eed33b0382678014f"}]}