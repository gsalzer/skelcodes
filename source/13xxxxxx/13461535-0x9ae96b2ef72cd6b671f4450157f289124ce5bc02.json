{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/producers/auction/MirrorDutchAuctionLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\nimport {IMirrorDutchAuctionLogic} from \\\"./interface/IMirrorDutchAuctionLogic.sol\\\";\\nimport {Ownable} from \\\"../../lib/Ownable.sol\\\";\\nimport {Pausable} from \\\"../../lib/Pausable.sol\\\";\\nimport {IERC721, IERC721Events} from \\\"../../external/interface/IERC721.sol\\\";\\nimport {ITreasuryConfig} from \\\"../../interface/ITreasuryConfig.sol\\\";\\nimport {IMirrorTreasury} from \\\"../../interface/IMirrorTreasury.sol\\\";\\nimport {Reentrancy} from \\\"../../lib/Reentrancy.sol\\\";\\n\\n/**\\n * @title MirrorDutchAuctionLogic\\n * @author MirrorXYZ\\n *\\n * This contract implements a simple Dutch Auction system.\\n * The auction works as follows:\\n *  - Generate a list of numbers that represent all the prices at which\\n *    the assets are offered. The first item is the highest price, the last\\n *    item is the lowest price.\\n *  - Set a time interval that represents how much time will elapse between price changes.\\n *  - After the auction starts, every bid pays the price at the time that their transaction\\n *    mines and receives their asset.\\n *\\n * The auction can be paused and unpaused by the owner without affecting the price mechanism.\\n * The auction has a \\\"cancel\\\" functionality that withdraws all funds (paying a fee) and\\n * renounces ownership which ensures that the auction cannot be restarted again.\\n * The auction assumes that tokenIds of the assets transfered are sequential, beginning at\\n * \\\"startTokenId\\\" and ending at \\\"endTokenId\\\".\\n * The auction uses blocks as the unit for the interval.\\n */\\ncontract MirrorDutchAuctionLogic is\\n    IMirrorDutchAuctionLogic,\\n    Ownable,\\n    Pausable,\\n    Reentrancy,\\n    IERC721Events\\n{\\n    /// @notice Set a list of prices\\n    uint256[] public override prices;\\n\\n    /// @notice Set the time interval in blocks\\n    uint256 public override interval;\\n\\n    /// @notice Set the current tokenId\\n    uint256 public override tokenId;\\n\\n    /// @notice Set the last tokenId\\n    uint256 public override endTokenId;\\n\\n    /// @notice Set total time elapsed since auction started\\n    uint256 public override globalTimeElapsed;\\n\\n    /// @notice Set the recipient of the funds for withdrawals\\n    address public override recipient;\\n\\n    /// @notice Set whether an account has purchased\\n    mapping(address => bool) public override purchased;\\n\\n    /// @notice Set the block at which auction started\\n    uint256 public override auctionStartBlock;\\n\\n    /// @notice Set the block at which auction was paused, only set if auction has started\\n    uint256 public override pauseBlock;\\n\\n    /// @notice Set the block at which auction was unpaused\\n    uint256 public override unpauseBlock;\\n\\n    /// @notice Set the contract that holds the NFTs\\n    address public override nft;\\n\\n    /// @notice Set the owner of the nfts transfered\\n    address public override nftOwner;\\n\\n    /// @notice Set the ending price\\n    uint256 public override endingPrice;\\n\\n    /// @notice Set the contract that holds the treasury configuration\\n    address public treasuryConfig;\\n\\n    modifier onlyOnce() {\\n        require(!purchased[msg.sender], \\\"already purchased\\\");\\n        _;\\n    }\\n\\n    constructor(address owner_) Ownable(owner_) Pausable(true) {}\\n\\n    /// @notice Change the withdrawal recipient\\n    function changeRecipient(address newRecipient) external override onlyOwner {\\n        recipient = newRecipient;\\n    }\\n\\n    /// @notice Get a list of all prices\\n    function getAllPrices() external view override returns (uint256[] memory) {\\n        return prices;\\n    }\\n\\n    /**\\n     * @dev This contract is used as the logic for proxies. Hence we include\\n     * the ability to call \\\"initialize\\\" when deploying a proxy to set initial\\n     * variables without having to define them and implement in the proxy's\\n     * constructor. This function reverts if called after deployment.\\n     */\\n    function initialize(\\n        address owner_,\\n        address treasuryConfig_,\\n        IMirrorDutchAuctionLogic.AuctionConfig memory auctionConfig_\\n    ) external override {\\n        // Ensure that this function is only callable during contract construction\\n        assembly {\\n            if extcodesize(address()) {\\n                revert(0, 0)\\n            }\\n        }\\n\\n        // ensure auction is paused\\n        _pause();\\n\\n        // set owner\\n        _setOwner(address(0), owner_);\\n\\n        // set treasury config\\n        treasuryConfig = treasuryConfig_;\\n\\n        // save auction configuration\\n        prices = auctionConfig_.prices;\\n        interval = auctionConfig_.interval;\\n        recipient = auctionConfig_.recipient;\\n        tokenId = auctionConfig_.startTokenId;\\n        endTokenId = auctionConfig_.endTokenId;\\n        nft = auctionConfig_.nft;\\n        nftOwner = auctionConfig_.nftOwner;\\n    }\\n\\n    /// @notice Pause auction\\n    function pause() external override whenNotPaused onlyOwner {\\n        // auction has started\\n        if (auctionStartBlock > 0) {\\n            globalTimeElapsed = _currentTimeElapsed();\\n\\n            pauseBlock = block.number;\\n        }\\n\\n        _pause();\\n    }\\n\\n    /// @notice Unpause auction\\n    function unpause() external override whenPaused onlyOwner {\\n        if (auctionStartBlock == 0) {\\n            auctionStartBlock = block.number;\\n\\n            emit AuctionStarted(auctionStartBlock);\\n        } else {\\n            unpauseBlock = block.number;\\n        }\\n\\n        _unpause();\\n    }\\n\\n    /// @notice Withdraw all funds and renounce contract ownership\\n    function cancel() external override onlyOwner nonReentrant {\\n        _pause();\\n\\n        _renounceOwnership();\\n\\n        _withdraw();\\n    }\\n\\n    /// @notice Current price. Zero if auction has not started.\\n    function price() external view override returns (uint256) {\\n        return _currentPrice();\\n    }\\n\\n    /// @notice Current time elapsed.\\n    function time() external view override returns (uint256) {\\n        if (auctionStartBlock > 0) {\\n            return _currentTimeElapsed();\\n        }\\n\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Bid for an NFT. If the price is met transfer NFT to sender.\\n     * If price drops before the transaction mines, refund value.\\n     */\\n    function bid()\\n        external\\n        payable\\n        override\\n        nonReentrant\\n        whenNotPaused\\n        onlyOnce\\n    {\\n        require(auctionStartBlock > 0, \\\"auction has not started\\\");\\n\\n        require(tokenId <= endTokenId, \\\"auction sold out\\\");\\n\\n        uint256 currentPrice = _currentPrice();\\n\\n        require(msg.value >= currentPrice, \\\"insufficient funds\\\");\\n\\n        // transfer NFT\\n        IERC721(nft).transferFrom(nftOwner, msg.sender, tokenId);\\n\\n        emit Bid(msg.sender, currentPrice, tokenId);\\n\\n        tokenId++;\\n\\n        purchased[msg.sender] = true;\\n\\n        // refund excess eth when price decrease before the transaction mines\\n        if (msg.value > currentPrice) {\\n            _transferEther(payable(msg.sender), msg.value - currentPrice);\\n        }\\n\\n        // snapshot the ending price\\n        if (tokenId > endTokenId) {\\n            endingPrice = currentPrice;\\n        }\\n    }\\n\\n    /// @notice Withdraw all funds, and pay fee\\n    function withdraw() external override nonReentrant {\\n        _withdraw();\\n    }\\n\\n    //======== Internal Methods =========\\n    function _currentPrice() internal view returns (uint256) {\\n        // auction has not started\\n        if (auctionStartBlock == 0) {\\n            return 0;\\n        }\\n\\n        // if ending price has been set i.e. all nfts are sold\\n        if (endingPrice != 0) {\\n            return endingPrice;\\n        }\\n\\n        uint256 timeElapsed = _currentTimeElapsed();\\n\\n        uint256 priceIndex = timeElapsed / interval;\\n\\n        // price becomes the reserve price i.e. last in the list of prices\\n        if (priceIndex >= prices.length) {\\n            return prices[prices.length - 1];\\n        }\\n\\n        return prices[priceIndex];\\n    }\\n\\n    function _currentTimeElapsed() internal view returns (uint256 timeElapsed) {\\n        // if auction has been paused before\\n        // if not return time elapse since the start of the auction\\n        if (pauseBlock > 0) {\\n            // if currently paused return global time elapsed, which is saved when pausing\\n            // if not return global time elapsed, plus time elapsed since it was unpaused\\n            if (paused) {\\n                timeElapsed = globalTimeElapsed;\\n            } else {\\n                timeElapsed = globalTimeElapsed + (block.number - unpauseBlock);\\n            }\\n        } else {\\n            timeElapsed = block.number - auctionStartBlock;\\n        }\\n    }\\n\\n    function _withdraw() internal {\\n        uint256 feePercentage = 250;\\n\\n        uint256 fee = _feeAmount(address(this).balance, feePercentage);\\n\\n        IMirrorTreasury(ITreasuryConfig(treasuryConfig).treasury()).contribute{\\n            value: fee\\n        }(fee);\\n\\n        // transfer the remaining available balance to the recipient\\n        uint256 withdrawalAmount = address(this).balance;\\n\\n        _transferEther(payable(recipient), withdrawalAmount);\\n\\n        emit Withdrawal(recipient, withdrawalAmount, fee);\\n    }\\n\\n    function _feeAmount(uint256 amount, uint256 fee)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return (amount * fee) / 10000;\\n    }\\n\\n    function _transferEther(address payable account, uint256 amount) private {\\n        require(\\n            address(this).balance >= amount,\\n            \\\"insufficient balance for send\\\"\\n        );\\n\\n        (bool success, ) = account.call{value: amount}(\\\"\\\");\\n        require(success, \\\"unable to send value: recipient may have reverted\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/producers/auction/interface/IMirrorDutchAuctionLogic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IMirrorDutchAuctionLogic {\\n    /// @notice Emitted when the auction starts\\n    event AuctionStarted(uint256 blockNumber);\\n\\n    /// @notice Emitted when a withdrawal takes place.\\n    event Withdrawal(address recipient, uint256 amount, uint256 fee);\\n\\n    /// @notice Emitted when a bid takes place.\\n    event Bid(address recipient, uint256 price, uint256 tokenId);\\n\\n    struct AuctionConfig {\\n        uint256[] prices;\\n        uint256 interval;\\n        uint256 startTokenId;\\n        uint256 endTokenId;\\n        address recipient;\\n        address nft;\\n        address nftOwner;\\n    }\\n\\n    /// @notice Get a list of prices\\n    function prices(uint256 index) external returns (uint256);\\n\\n    /// @notice Get the time interval in blocks\\n    function interval() external returns (uint256);\\n\\n    /// @notice Get the current tokenId\\n    function tokenId() external returns (uint256);\\n\\n    /// @notice Get the last tokenId\\n    function endTokenId() external returns (uint256);\\n\\n    /// @notice Get total time elapsed since auction started\\n    function globalTimeElapsed() external returns (uint256);\\n\\n    /// @notice Get the recipient of the funds for withdrawals\\n    function recipient() external returns (address);\\n\\n    /// @notice Get whether an account has purchased\\n    function purchased(address account) external returns (bool);\\n\\n    /// @notice Get the block at which auction started\\n    function auctionStartBlock() external returns (uint256);\\n\\n    /// @notice Get the block at which auction was paused, only set if auction has started\\n    function pauseBlock() external returns (uint256);\\n\\n    /// @notice Get the block at which auction was unpaused\\n    function unpauseBlock() external returns (uint256);\\n\\n    /// @notice Get the contract that holds the NFTs\\n    function nft() external returns (address);\\n\\n    /// @notice Set the owner of the nfts transfered\\n    function nftOwner() external returns (address);\\n\\n    /// @notice Get the ending price\\n    function endingPrice() external returns (uint256);\\n\\n    /// @notice Change the withdrawal recipient\\n    function changeRecipient(address newRecipient) external;\\n\\n    /// @notice Get the contract that holds the treasury configuration\\n    function getAllPrices() external returns (uint256[] memory);\\n\\n    /**\\n     * @dev This contract is used as the logic for proxies. Hence we include\\n     * the ability to call \\\"initialize\\\" when deploying a proxy to set initial\\n     * variables without having to define them and implement in the proxy's\\n     * constructor. This function reverts if called after deployment.\\n     */\\n    function initialize(\\n        address owner_,\\n        address treasuryConfig_,\\n        IMirrorDutchAuctionLogic.AuctionConfig memory auctionConfig_\\n    ) external;\\n\\n    /// @notice Pause auction\\n    function pause() external;\\n\\n    /// @notice Unpause auction\\n    function unpause() external;\\n\\n    /// @notice Withdraw all funds and destroy contract\\n    function cancel() external;\\n\\n    /// @notice Current price. Zero if auction has not started.\\n    function price() external view returns (uint256);\\n\\n    /// @notice Current time elapsed.\\n    function time() external view returns (uint256);\\n\\n    /**\\n     * @notice Bid for an NFT. If the price is met transfer NFT to sender.\\n     * If price drops before the transaction mines, refund value.\\n     */\\n    function bid() external payable;\\n\\n    /// @notice Withdraw all funds, and pay fee\\n    function withdraw() external;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IOwnableEvents {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n}\\n\\ncontract Ownable is IOwnableEvents {\\n    address public owner;\\n    address private nextOwner;\\n\\n    // modifiers\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"caller is not the owner.\\\");\\n        _;\\n    }\\n\\n    modifier onlyNextOwner() {\\n        require(isNextOwner(), \\\"current owner must set caller as next owner.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Initialize contract by setting transaction submitter as initial owner.\\n     */\\n    constructor(address owner_) {\\n        owner = owner_;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    /**\\n     * @dev Initiate ownership transfer by setting nextOwner.\\n     */\\n    function transferOwnership(address nextOwner_) external onlyOwner {\\n        require(nextOwner_ != address(0), \\\"Next owner is the zero address.\\\");\\n\\n        nextOwner = nextOwner_;\\n    }\\n\\n    /**\\n     * @dev Cancel ownership transfer by deleting nextOwner.\\n     */\\n    function cancelOwnershipTransfer() external onlyOwner {\\n        delete nextOwner;\\n    }\\n\\n    /**\\n     * @dev Accepts ownership transfer by setting owner.\\n     */\\n    function acceptOwnership() external onlyNextOwner {\\n        delete nextOwner;\\n\\n        owner = msg.sender;\\n\\n        emit OwnershipTransferred(owner, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Renounce ownership by setting owner to zero address.\\n     */\\n    function renounceOwnership() external onlyOwner {\\n        _renounceOwnership();\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return msg.sender == owner;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the next owner.\\n     */\\n    function isNextOwner() public view returns (bool) {\\n        return msg.sender == nextOwner;\\n    }\\n\\n    function _setOwner(address previousOwner, address newOwner) internal {\\n        owner = newOwner;\\n        emit OwnershipTransferred(previousOwner, owner);\\n    }\\n\\n    function _renounceOwnership() internal {\\n        owner = address(0);\\n\\n        emit OwnershipTransferred(owner, address(0));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IPausableEvents {\\n    /// @notice Emitted when the pause is triggered by `account`.\\n    event Paused(address account);\\n\\n    /// @notice Emitted when the pause is lifted by `account`.\\n    event Unpaused(address account);\\n}\\n\\ninterface IPausable {\\n    function paused() external returns (bool);\\n}\\n\\ncontract Pausable is IPausable, IPausableEvents {\\n    bool public override paused;\\n\\n    // Modifiers\\n\\n    modifier whenNotPaused() {\\n        require(!paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(paused, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /// @notice Initializes the contract in unpaused state.\\n    constructor(bool paused_) {\\n        paused = paused_;\\n    }\\n\\n    // ============ Internal Functions ============\\n\\n    function _pause() internal whenNotPaused {\\n        paused = true;\\n\\n        emit Paused(msg.sender);\\n    }\\n\\n    function _unpause() internal whenPaused {\\n        paused = false;\\n\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/interface/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IERC721 {\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IERC721Events {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n}\\n\\ninterface IERC721Metadata {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\nabstract contract ERC165 is IERC165 {\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\\ninterface IERC721Royalties {\\n    function getFeeRecipients(uint256 id)\\n        external\\n        view\\n        returns (address payable[] memory);\\n\\n    function getFeeBps(uint256 id) external view returns (uint256[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ITreasuryConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface ITreasuryConfig {\\n    function treasury() external returns (address payable);\\n\\n    function distributionModel() external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IMirrorTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ninterface IMirrorTreasury {\\n    function transferFunds(address payable to, uint256 value) external;\\n\\n    function transferERC20(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) external;\\n\\n    function contributeWithTributary(address tributary) external payable;\\n\\n    function contribute(uint256 amount) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Reentrancy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.6;\\n\\ncontract Reentrancy {\\n    // ============ Constants ============\\n\\n    uint256 internal constant REENTRANCY_NOT_ENTERED = 1;\\n    uint256 internal constant REENTRANCY_ENTERED = 2;\\n\\n    // ============ Mutable Storage ============\\n\\n    uint256 internal reentrancyStatus;\\n\\n    // ============ Modifiers ============\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(reentrancyStatus != REENTRANCY_ENTERED, \\\"Reentrant call\\\");\\n        // Any calls to nonReentrant after this point will fail\\n        reentrancyStatus = REENTRANCY_ENTERED;\\n        _;\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip2200)\\n        reentrancyStatus = REENTRANCY_NOT_ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"AuctionStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Bid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auctionStartBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRecipient\",\"type\":\"address\"}],\"name\":\"changeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPrices\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalTimeElapsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasuryConfig_\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"interval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftOwner\",\"type\":\"address\"}],\"internalType\":\"struct IMirrorDutchAuctionLogic.AuctionConfig\",\"name\":\"auctionConfig_\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isNextOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nft\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"prices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"purchased\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nextOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MirrorDutchAuctionLogic","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"2000","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}