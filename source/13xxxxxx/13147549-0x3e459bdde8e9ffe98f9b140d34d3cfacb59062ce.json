{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/adapters/Hegic888/Hegic888.1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//  ______   ______     _____\\n// /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\  __-.\\n// \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\/\\\\ \\\\\\n//    \\\\ \\\\_\\\\  \\\\ \\\\_____\\\\  \\\\ \\\\____-\\n//     \\\\/_/   \\\\/_____/   \\\\/____/\\n//\\npragma solidity 0.8.6;\\n\\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\\n\\nimport '../../Versioned.sol';\\nimport '../../Pausable.sol';\\nimport '../Adapter.sol';\\nimport './interfaces/HegicETHOptions.888.sol';\\nimport './interfaces/HegicWBTCOptions.888.sol';\\nimport './interfaces/OptionType.888.sol';\\n\\n//\\n//   ___ _ __ _ __ ___  _ __ ___\\n//  / _ \\\\ '__| '__/ _ \\\\| '__/ __|\\n// |  __/ |  | | | (_) | |  \\\\__ \\\\\\n//  \\\\___|_|  |_|  \\\\___/|_|  |___/\\n//\\n// Hegic888AdapterV1_1  => Invalid data length received\\n// Hegic888AdapterV1_2  => Invalid currency length received. Should be 1 (only ETH)\\n// Hegic888AdapterV1_3  => Invalid amounts length received. Should be 1 (only ETH)\\n// Hegic888AdapterV1_4  => While process ETH option purchase, invalid currency found, expected address(0) for ETH\\n// Hegic888AdapterV1_5  => While process ETH option purchase, amount received is not enough to perform purchase\\n// Hegic888AdapterV1_6  => While process ETH option purchase, an error occured when trying to send back extra ETH received\\n// Hegic888AdapterV1_7  => While process WBTC option purchase, invalid currency found, expected address(0) for ETH\\n// Hegic888AdapterV1_8  => While process WBTC option purchase, amount received is not enough to perform purchase\\n// Hegic888AdapterV1_9  => While process WBTC option purchase, an error occured when trying to send back extra ETH received\\n// Hegic888AdapterV1_10 => Invalid asset type provided\\n\\n/// @title Hegic888AdapterV1\\n/// @author Iulian Rotaru\\n/// @notice Adapter to purchase Hegic ETH or WBTC options\\ncontract Hegic888AdapterV1 is Versioned, Pausable, Adapter {\\n    //\\n    //      _        _\\n    //  ___| |_ __ _| |_ ___\\n    // / __| __/ _` | __/ _ \\\\\\n    // \\\\__ \\\\ || (_| | ||  __/\\n    // |___/\\\\__\\\\__,_|\\\\__\\\\___|\\n    //\\n\\n    // Address of Hegic ETH options contract\\n    HegicETHOptionsV888 public hegicEthOptions;\\n\\n    // Address of Hegic WBTC options contract\\n    HegicWBTCOptionsV888 public hegicWbtcOptions;\\n\\n    //\\n    //   ___ _ __  _   _ _ __ ___  ___\\n    //  / _ \\\\ '_ \\\\| | | | '_ ` _ \\\\/ __|\\n    // |  __/ | | | |_| | | | | | \\\\__ \\\\\\n    //  \\\\___|_| |_|\\\\__,_|_| |_| |_|___/\\n    //\\n\\n    // Enum of supported asset types\\n    enum AssetType {\\n        Eth,\\n        Wbtc\\n    }\\n\\n    //\\n    //  _       _                        _\\n    // (_)_ __ | |_ ___ _ __ _ __   __ _| |___\\n    // | | '_ \\\\| __/ _ \\\\ '__| '_ \\\\ / _` | / __|\\n    // | | | | | ||  __/ |  | | | | (_| | \\\\__ \\\\\\n    // |_|_| |_|\\\\__\\\\___|_|  |_| |_|\\\\__,_|_|___/\\n    //\\n\\n    /// @dev Perform an option purchase\\n    /// @param caller Address purchasing the option\\n    /// @param currencies List of usable currencies\\n    /// @param amounts List of usable currencies amounts\\n    /// @param data Extra data usable by adapter\\n    /// @return A tuple containing used amounts and output data\\n    function purchase(\\n        address caller,\\n        address[] memory currencies,\\n        uint256[] memory amounts,\\n        bytes calldata data\\n    ) internal override returns (uint256[] memory, bytes memory) {\\n        require(data.length == 160, 'Hegic888AdapterV1_1');\\n        require(currencies.length == 1, 'Hegic888AdapterV1_2');\\n        require(amounts.length == 1, 'Hegic888AdapterV1_3');\\n\\n        AssetType _assetType; // Stack depth optimizations\\n        uint256 total;\\n        uint256[] memory totalETH = new uint256[](1);\\n        uint256 optionID;\\n\\n        {\\n            OptionTypeV888.OptionType _optionType;\\n            uint256 _period;\\n            uint256 _amount;\\n            uint256 _strike;\\n            (_optionType, _assetType, _period, _amount, _strike) = abi.decode(\\n                data,\\n                (OptionTypeV888.OptionType, AssetType, uint256, uint256, uint256)\\n            );\\n\\n            if (_assetType == AssetType.Eth) {\\n                require(currencies[0] == address(0), 'Hegic888AdapterV1_4');\\n                (total, , , ) = hegicEthOptions.fees(_period, _amount, _strike, _optionType);\\n                totalETH[0] = total;\\n                require(msg.value >= totalETH[0], 'Hegic888AdapterV1_5');\\n                optionID = hegicEthOptions.create{value: totalETH[0]}(_period, _amount, _strike, _optionType);\\n\\n                if (address(this).balance > 0) {\\n                    (bool success, ) = payable(caller).call{value: address(this).balance}('');\\n                    require(success, 'Hegic888AdapterV1_6');\\n                }\\n            } else if (AssetType(_assetType) == AssetType.Wbtc) {\\n                require(currencies[0] == address(0), 'Hegic888AdapterV1_7');\\n                (total, totalETH[0], , , ) = hegicWbtcOptions.fees(_period, _amount, _strike, _optionType);\\n                require(msg.value >= totalETH[0], 'Hegic888AdapterV1_8');\\n                optionID = hegicWbtcOptions.create{value: totalETH[0]}(_period, _amount, _strike, _optionType);\\n\\n                if (address(this).balance > 0) {\\n                    (bool success, ) = payable(caller).call{value: address(this).balance}('');\\n                    require(success, 'Hegic888AdapterV1_9');\\n                }\\n            } else {\\n                revert('Hegic888AdapterV1_10');\\n            }\\n        }\\n\\n        if (_assetType == AssetType.Wbtc) {\\n            hegicWbtcOptions.transfer(optionID, payable(caller));\\n        } else {\\n            hegicEthOptions.transfer(optionID, payable(caller));\\n        }\\n\\n        return (totalETH, abi.encode(total, optionID));\\n    }\\n\\n    //\\n    //            _                        _\\n    //   _____  _| |_ ___ _ __ _ __   __ _| |___\\n    //  / _ \\\\ \\\\/ / __/ _ \\\\ '__| '_ \\\\ / _` | / __|\\n    // |  __/>  <| ||  __/ |  | | | | (_| | \\\\__ \\\\\\n    //  \\\\___/_/\\\\_\\\\\\\\__\\\\___|_|  |_| |_|\\\\__,_|_|___/\\n    //\\n\\n    /// @dev Retrieve adapter name\\n    /// @return Adapter name\\n    function name() external pure override returns (string memory) {\\n        return 'Hegic888V1';\\n    }\\n\\n    //\\n    //  _       _ _\\n    // (_)_ __ (_) |_\\n    // | | '_ \\\\| | __|\\n    // | | | | | | |_\\n    // |_|_| |_|_|\\\\__|\\n    //\\n\\n    function __Hegic888AdapterV1__constructor(address _gateway, address _hegicEthOptions, address _hegicWbtcOptions)\\n        public\\n        initVersion(1)\\n    {\\n        hegicEthOptions = HegicETHOptionsV888(_hegicEthOptions);\\n        hegicWbtcOptions = HegicWBTCOptionsV888(_hegicWbtcOptions);\\n        setGateway(_gateway);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Versioned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//  ______   ______     _____\\n// /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\  __-.\\n// \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\/\\\\ \\\\\\n//    \\\\ \\\\_\\\\  \\\\ \\\\_____\\\\  \\\\ \\\\____-\\n//     \\\\/_/   \\\\/_____/   \\\\/____/\\n//\\npragma solidity 0.8.6;\\n\\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\\n\\n//\\n//   ___ _ __ _ __ ___  _ __ ___\\n//  / _ \\\\ '__| '__/ _ \\\\| '__/ __|\\n// |  __/ |  | | | (_) | |  \\\\__ \\\\\\n//  \\\\___|_|  |_|  \\\\___/|_|  |___/\\n//\\n// V1 => Already initializing\\n// V2 => Invalid version received. Expected current\\n\\n/// @title Versioned\\n/// @author Iulian Rotaru\\n/// @notice Initialized for multiple versions\\ncontract Versioned {\\n    //\\n    //      _        _\\n    //  ___| |_ __ _| |_ ___\\n    // / __| __/ _` | __/ _ \\\\\\n    // \\\\__ \\\\ || (_| | ||  __/\\n    // |___/\\\\__\\\\__,_|\\\\__\\\\___|\\n    //\\n\\n    // Stores the current implementation version\\n    uint256 version;\\n\\n    // Stores the initializing state for each version\\n    bool private _initializing;\\n\\n    //\\n    //                      _ _  __ _\\n    //  _ __ ___   ___   __| (_)/ _(_) ___ _ __ ___\\n    // | '_ ` _ \\\\ / _ \\\\ / _` | | |_| |/ _ \\\\ '__/ __|\\n    // | | | | | | (_) | (_| | |  _| |  __/ |  \\\\__ \\\\\\n    // |_| |_| |_|\\\\___/ \\\\__,_|_|_| |_|\\\\___|_|  |___/\\n    //\\n\\n    // Allows to be called only if version number is current version + 1\\n    modifier initVersion(uint256 _version) {\\n        require(!_initializing, 'V1');\\n        require(_version == version + 1, 'V2');\\n        version = _version;\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    //\\n    //            _                        _\\n    //   _____  _| |_ ___ _ __ _ __   __ _| |___\\n    //  / _ \\\\ \\\\/ / __/ _ \\\\ '__| '_ \\\\ / _` | / __|\\n    // |  __/>  <| ||  __/ |  | | | | (_| | \\\\__ \\\\\\n    //  \\\\___/_/\\\\_\\\\\\\\__\\\\___|_|  |_| |_|\\\\__,_|_|___/\\n    //\\n\\n    /// @dev Retrieves current implementation version\\n    /// @return Implementatiomn version\\n    function getVersion() public view returns (uint256) {\\n        return version;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//  ______   ______     _____\\n// /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\  __-.\\n// \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\/\\\\ \\\\\\n//    \\\\ \\\\_\\\\  \\\\ \\\\_____\\\\  \\\\ \\\\____-\\n//     \\\\/_/   \\\\/_____/   \\\\/____/\\n//\\npragma solidity 0.8.6;\\n\\nimport '@openzeppelin/contracts/utils/StorageSlot.sol';\\n\\n//\\n//   ___ _ __ _ __ ___  _ __ ___\\n//  / _ \\\\ '__| '__/ _ \\\\| '__/ __|\\n// |  __/ |  | | | (_) | |  \\\\__ \\\\\\n//  \\\\___|_|  |_|  \\\\___/|_|  |___/\\n//\\n// P1 => Contract is not paused\\n// P2 => Contract is paused\\n\\n/// @title Pausable\\n/// @author Iulian Rotaru\\n/// @notice Pausable logics, reading storage slot to retrieve pause state\\ncontract Pausable {\\n    //\\n    //                      _              _\\n    //   ___ ___  _ __  ___| |_ __ _ _ __ | |_ ___\\n    //  / __/ _ \\\\| '_ \\\\/ __| __/ _` | '_ \\\\| __/ __|\\n    // | (_| (_) | | | \\\\__ \\\\ || (_| | | | | |_\\\\__ \\\\\\n    //  \\\\___\\\\___/|_| |_|___/\\\\__\\\\__,_|_| |_|\\\\__|___/\\n    //\\n\\n    // Storage slot for the Paused state\\n    bytes32 internal constant _PAUSED_SLOT = 0x8dea8703c3cf94703383ce38a9c894669dccd4ca8e65ddb43267aa0248711450;\\n\\n    //\\n    //                      _ _  __ _\\n    //  _ __ ___   ___   __| (_)/ _(_) ___ _ __ ___\\n    // | '_ ` _ \\\\ / _ \\\\ / _` | | |_| |/ _ \\\\ '__/ __|\\n    // | | | | | | (_) | (_| | |  _| |  __/ |  \\\\__ \\\\\\n    // |_| |_| |_|\\\\___/ \\\\__,_|_|_| |_|\\\\___|_|  |___/\\n    //\\n\\n    // Allows methods to be called if paused\\n    modifier whenPaused() {\\n        require(StorageSlot.getBooleanSlot(_PAUSED_SLOT).value == true, 'P1');\\n        _;\\n    }\\n\\n    // Allows methods to be called if not paused\\n    modifier whenNotPaused() {\\n        require(StorageSlot.getBooleanSlot(_PAUSED_SLOT).value == false, 'P1');\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/Adapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//  ______   ______     _____\\n// /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\  __-.\\n// \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\/\\\\ \\\\\\n//    \\\\ \\\\_\\\\  \\\\ \\\\_____\\\\  \\\\ \\\\____-\\n//     \\\\/_/   \\\\/_____/   \\\\/____/\\n//\\npragma solidity 0.8.6;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport '../Owned.sol';\\n\\n//\\n//   ___ _ __ _ __ ___  _ __ ___\\n//  / _ \\\\ '__| '__/ _ \\\\| '__/ __|\\n// |  __/ |  | | | (_) | |  \\\\__ \\\\\\n//  \\\\___|_|  |_|  \\\\___/|_|  |___/\\n//\\n// A1 => Useless call, not changing address\\n// A2 => Invalid currencies and amount length\\n// A3 => Received amount of ETH too low\\n\\n/// @title Adapter\\n/// @author Iulian Rotaru\\n/// @notice Adapter base logics\\nabstract contract Adapter is Owned {\\n\\n    address public gateway;\\n\\n    modifier isGateway() {\\n      require(msg.sender == gateway, 'A1');\\n      _;\\n    }\\n\\n    //\\n    //  _       _                        _\\n    // (_)_ __ | |_ ___ _ __ _ __   __ _| |___\\n    // | | '_ \\\\| __/ _ \\\\ '__| '_ \\\\ / _` | / __|\\n    // | | | | | ||  __/ |  | | | | (_| | \\\\__ \\\\\\n    // |_|_| |_|\\\\__\\\\___|_|  |_| |_|\\\\__,_|_|___/\\n    //\\n\\n    /// @dev Changes gateway address\\n    /// @param newGateway Address of new gateway\\n    function setGateway(address newGateway) internal {\\n      require(gateway != newGateway, 'A1');\\n      gateway = newGateway;\\n    }\\n\\n    /// @dev Perform an internal option purchase\\n    /// @param caller Address purchasing the option\\n    /// @param currencies List of usable currencies\\n    /// @param amounts List of usable currencies amounts\\n    /// @param data Extra data usable by adapter\\n    /// @return A tuple containing used amounts and output data\\n    function purchase(\\n        address caller,\\n        address[] memory currencies,\\n        uint256[] memory amounts,\\n        bytes calldata data\\n    ) internal virtual returns (uint256[] memory, bytes memory);\\n\\n    function _preparePayment(address[] memory currencies, uint256[] memory amounts) internal {\\n        require(currencies.length == amounts.length, 'A2');\\n        for (uint256 currencyIdx = 0; currencyIdx < currencies.length; ++currencyIdx) {\\n            if (currencies[currencyIdx] == address(0)) {\\n                require(msg.value >= amounts[currencyIdx], 'A3');\\n            } else {\\n                IERC20(currencies[currencyIdx]).transferFrom(msg.sender, address(this), amounts[currencyIdx]);\\n            }\\n        }\\n    }\\n\\n    //\\n    //            _                        _\\n    //   _____  _| |_ ___ _ __ _ __   __ _| |___\\n    //  / _ \\\\ \\\\/ / __/ _ \\\\ '__| '_ \\\\ / _` | / __|\\n    // |  __/>  <| ||  __/ |  | | | | (_| | \\\\__ \\\\\\n    //  \\\\___/_/\\\\_\\\\\\\\__\\\\___|_|  |_| |_|\\\\__,_|_|___/\\n    //\\n\\n    /// @dev Perform an option purchase\\n    /// @param caller Address purchasing the option\\n    /// @param currencies List of usable currencies\\n    /// @param amounts List of usable currencies amounts\\n    /// @param data Extra data usable by adapter\\n    /// @return A tuple containing used amounts and output data\\n    function run(\\n        address caller,\\n        address[] memory currencies,\\n        uint256[] memory amounts,\\n        bytes calldata data\\n    ) external payable isGateway returns (uint256[] memory, bytes memory) {\\n        _preparePayment(currencies, amounts);\\n        return purchase(caller, currencies, amounts, data);\\n    }\\n\\n    function name() external view virtual returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/Hegic888/interfaces/HegicETHOptions.888.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//  ______   ______     _____\\n// /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\  __-.\\n// \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\/\\\\ \\\\\\n//    \\\\ \\\\_\\\\  \\\\ \\\\_____\\\\  \\\\ \\\\____-\\n//     \\\\/_/   \\\\/_____/   \\\\/____/\\n//\\npragma solidity 0.8.6;\\n\\nimport './OptionType.888.sol';\\n\\ninterface HegicETHOptionsV888 {\\n    //\\n    //            _                        _\\n    //   _____  _| |_ ___ _ __ _ __   __ _| |___\\n    //  / _ \\\\ \\\\/ / __/ _ \\\\ '__| '_ \\\\ / _` | / __|\\n    // |  __/>  <| ||  __/ |  | | | | (_| | \\\\__ \\\\\\n    //  \\\\___/_/\\\\_\\\\\\\\__\\\\___|_|  |_| |_|\\\\__,_|_|___/\\n    //\\n\\n    function create(\\n        uint256 period,\\n        uint256 amount,\\n        uint256 strike,\\n        OptionTypeV888.OptionType optionType\\n    ) external payable returns (uint256 optionID);\\n\\n    function transfer(uint256 optionID, address payable newHolder) external;\\n\\n    function fees(\\n        uint256 period,\\n        uint256 amount,\\n        uint256 strike,\\n        OptionTypeV888.OptionType optionType\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 total,\\n            uint256 settlementFee,\\n            uint256 strikeFee,\\n            uint256 periodFee\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/Hegic888/interfaces/HegicWBTCOptions.888.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//  ______   ______     _____\\n// /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\  __-.\\n// \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\/\\\\ \\\\\\n//    \\\\ \\\\_\\\\  \\\\ \\\\_____\\\\  \\\\ \\\\____-\\n//     \\\\/_/   \\\\/_____/   \\\\/____/\\n//\\npragma solidity 0.8.6;\\n\\nimport './OptionType.888.sol';\\n\\ninterface HegicWBTCOptionsV888 {\\n    //\\n    //            _                        _\\n    //   _____  _| |_ ___ _ __ _ __   __ _| |___\\n    //  / _ \\\\ \\\\/ / __/ _ \\\\ '__| '_ \\\\ / _` | / __|\\n    // |  __/>  <| ||  __/ |  | | | | (_| | \\\\__ \\\\\\n    //  \\\\___/_/\\\\_\\\\\\\\__\\\\___|_|  |_| |_|\\\\__,_|_|___/\\n    //\\n\\n    function create(\\n        uint256 period,\\n        uint256 amount,\\n        uint256 strike,\\n        OptionTypeV888.OptionType optionType\\n    ) external payable returns (uint256 optionID);\\n\\n    function transfer(uint256 optionID, address payable newHolder) external;\\n\\n    function fees(\\n        uint256 period,\\n        uint256 amount,\\n        uint256 strike,\\n        OptionTypeV888.OptionType optionType\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 total,\\n            uint256 totalETH,\\n            uint256 settlementFee,\\n            uint256 strikeFee,\\n            uint256 periodFee\\n        );\\n\\n    function wbtc() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/adapters/Hegic888/interfaces/OptionType.888.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//  ______   ______     _____\\n// /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\  __-.\\n// \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\/\\\\ \\\\\\n//    \\\\ \\\\_\\\\  \\\\ \\\\_____\\\\  \\\\ \\\\____-\\n//     \\\\/_/   \\\\/_____/   \\\\/____/\\n//\\npragma solidity 0.8.6;\\n\\nlibrary OptionTypeV888 {\\n    //\\n    //   ___ _ __  _   _ _ __ ___  ___\\n    //  / _ \\\\ '_ \\\\| | | | '_ ` _ \\\\/ __|\\n    // |  __/ | | | |_| | | | | | \\\\__ \\\\\\n    //  \\\\___|_| |_|\\\\__,_|_| |_| |_|___/\\n    //\\n\\n    enum OptionType {\\n        Invalid,\\n        Put,\\n        Call\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n//  ______   ______     _____\\n// /\\\\__  _\\\\ /\\\\  == \\\\   /\\\\  __-.\\n// \\\\/_/\\\\ \\\\/ \\\\ \\\\  __<   \\\\ \\\\ \\\\/\\\\ \\\\\\n//    \\\\ \\\\_\\\\  \\\\ \\\\_____\\\\  \\\\ \\\\____-\\n//     \\\\/_/   \\\\/_____/   \\\\/____/\\n//\\npragma solidity 0.8.6;\\n\\nimport '@openzeppelin/contracts/utils/StorageSlot.sol';\\n\\n//\\n//   ___ _ __ _ __ ___  _ __ ___\\n//  / _ \\\\ '__| '__/ _ \\\\| '__/ __|\\n// |  __/ |  | | | (_) | |  \\\\__ \\\\\\n//  \\\\___|_|  |_|  \\\\___/|_|  |___/\\n//\\n// O1 => Caller is not admin\\n\\n/// @title Owned\\n/// @author Iulian Rotaru\\n/// @notice Owner logics, reading storage slot to retrieve admin\\ncontract Owned {\\n    //\\n    //                      _              _\\n    //   ___ ___  _ __  ___| |_ __ _ _ __ | |_ ___\\n    //  / __/ _ \\\\| '_ \\\\/ __| __/ _` | '_ \\\\| __/ __|\\n    // | (_| (_) | | | \\\\__ \\\\ || (_| | | | | |_\\\\__ \\\\\\n    //  \\\\___\\\\___/|_| |_|___/\\\\__\\\\__,_|_| |_|\\\\__|___/\\n    //\\n\\n    // Storage slot for the Admin address\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    //\\n    //                      _ _  __ _\\n    //  _ __ ___   ___   __| (_)/ _(_) ___ _ __ ___\\n    // | '_ ` _ \\\\ / _ \\\\ / _` | | |_| |/ _ \\\\ '__/ __|\\n    // | | | | | | (_) | (_| | |  _| |  __/ |  \\\\__ \\\\\\n    // |_| |_| |_|\\\\___/ \\\\__,_|_|_| |_|\\\\___|_|  |___/\\n    //\\n\\n    // Modifier allowing only admins to call methods\\n    modifier isAdmin() {\\n        require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, 'O1');\\n        _;\\n    }\\n\\n    //\\n    //            _                        _\\n    //   _____  _| |_ ___ _ __ _ __   __ _| |___\\n    //  / _ \\\\ \\\\/ / __/ _ \\\\ '__| '_ \\\\ / _` | / __|\\n    // |  __/>  <| ||  __/ |  | | | | (_| | \\\\__ \\\\\\n    //  \\\\___/_/\\\\_\\\\\\\\__\\\\___|_|  |_| |_|\\\\__,_|_|___/\\n    //\\n\\n    /// @dev Retrieves Admin address\\n    /// @return Admin address\\n    function getAdmin() public view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gateway\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_hegicEthOptions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_hegicWbtcOptions\",\"type\":\"address\"}],\"name\":\"__Hegic888AdapterV1__constructor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateway\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hegicEthOptions\",\"outputs\":[{\"internalType\":\"contract HegicETHOptionsV888\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hegicWbtcOptions\",\"outputs\":[{\"internalType\":\"contract HegicWBTCOptionsV888\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"currencies\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"run\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"Hegic888AdapterV1","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}