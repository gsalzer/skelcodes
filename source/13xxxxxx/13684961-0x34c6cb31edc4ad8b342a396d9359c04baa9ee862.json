{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Registry.sol\": {\r\n      \"content\": \"// Solidity files have to start with this pragma.\\n// It will be used by the Solidity compiler to validate its version.\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\n\\ninterface IERC721 {\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n}\\n\\n// This is the main building block for smart contracts.\\ncontract Registry is Ownable, IERC721Receiver {\\n    // Some string type variables to identify the token.\\n    // The `public` modifier makes a variable readable from outside the contract.\\n    string public name = \\\"NFTRegistry\\\";\\n\\n    struct NFT {\\n        address c;\\n        uint256 tokenId;\\n    }\\n\\n    struct Wishlist {\\n        address owner;\\n        string data;\\n        string name;\\n    }\\n\\n    // Mapping from owner to token\\n    mapping(address => NFT[]) _tokens;\\n    mapping(address => mapping(uint256 => address)) _owners;\\n\\n    // A mapping is a key/value map. Here we store the wishlist for an address\\n    mapping(string => Wishlist) _wishlists; // list name to wishlist\\n    mapping(string => NFT[]) _wishlistCurrent; // current items\\n    mapping(address => string[]) _wishlistsByOwner; // owner to list names\\n    uint256 public createPrice;\\n    uint256 public updatePrice;\\n    bool public disabled;\\n\\n    constructor() Ownable()  {\\n        createPrice = 10000000000000000;\\n        updatePrice = 5000000000000000;\\n    }\\n\\n    function setCreatePrice(uint256 price) onlyOwner external {\\n        createPrice = price;\\n    }\\n\\n    function setUpdatePrice(uint256 price) onlyOwner external {\\n        updatePrice = price;\\n    }\\n\\n    function setDisabled(bool d) onlyOwner public {\\n        disabled = d;\\n    }\\n\\n     function withdraw() onlyOwner public {\\n        payable(msg.sender).transfer(address(this).balance);\\n     }\\n\\n    function onERC721Received(address, address from, uint256 tokenId, bytes calldata) public override returns (bytes4) {\\n        _tokens[from].push(NFT(msg.sender, tokenId));\\n        _owners[msg.sender][tokenId] = from;\\n        return this.onERC721Received.selector;\\n    }\\n\\n    function updateWishlist(string memory listName, string memory displayName, string memory data) payable external {\\n        require (!disabled);\\n        address _currentOwner = _wishlists[listName].owner;\\n        require(_currentOwner == address(0) || _currentOwner == msg.sender);\\n        if (_currentOwner == address(0)) {\\n            require(msg.value >= createPrice);\\n            _wishlistsByOwner[msg.sender].push(listName);\\n        } else {\\n            require(msg.value >= updatePrice);\\n        }\\n        Wishlist memory w;\\n        w.owner = msg.sender;\\n        w.data = data;\\n        w.name = displayName;\\n        _wishlists[listName] = w;\\n    }\\n\\n    // return wishlist data ipfs address\\n    function getWishlistWanted(string memory listName) external view returns (string memory) {\\n        return _wishlists[listName].data;\\n    }\\n\\n    function getWishlistCurrent(string memory listName) external view returns (NFT[] memory) {\\n        return _wishlistCurrent[listName];\\n    }\\n\\n    function transferOut(address account, address tokenContractAddress, uint256 tokenId) external {\\n        require(_owners[tokenContractAddress][tokenId] == msg.sender);\\n        IERC721 tokenContract = IERC721(tokenContractAddress);\\n        delete _owners[tokenContractAddress][tokenId];\\n        removeToken(tokenContractAddress, tokenId);\\n        tokenContract.safeTransferFrom(address(this), account, tokenId);\\n    }\\n\\n    function claimAll() external {\\n        for (uint256 i = 0; i < _tokens[msg.sender].length; i++) {\\n            NFT memory token = _tokens[msg.sender][i];\\n            IERC721 tokenContract = IERC721(token.c);\\n            tokenContract.safeTransferFrom(address(this), msg.sender, token.tokenId);\\n            delete _owners[token.c][token.tokenId];\\n        }\\n        delete _tokens[msg.sender];\\n    }\\n\\n    function transferToWishlist(string memory listName, address tokenContractAddress, uint256 tokenId) external {\\n        require(_owners[tokenContractAddress][tokenId] == msg.sender);\\n        delete _owners[tokenContractAddress][tokenId];\\n        _wishlistCurrent[listName].push(NFT(tokenContractAddress, tokenId));\\n        removeToken(tokenContractAddress, tokenId);\\n    }\\n\\n    function removeToken(address tokenContractAddress, uint256 tokenId) private {\\n        uint256 index = _tokens[msg.sender].length;\\n        for (uint256 i = 0; i<_tokens[msg.sender].length; i++){\\n            if (_tokens[msg.sender][i].c == tokenContractAddress && _tokens[msg.sender][i].tokenId == tokenId) {\\n                index = i;\\n                break;\\n            }\\n        }\\n\\n        if (index >= _tokens[msg.sender].length) {\\n            return;\\n        }\\n        _tokens[msg.sender][index] = _tokens[msg.sender][_tokens[msg.sender].length-1];\\n        _tokens[msg.sender].pop();\\n    }\\n\\n    function claimFromWishlist(string memory listName) external {\\n        require(_wishlists[listName].owner == msg.sender);\\n        for (uint256 i=0; i < _wishlistCurrent[listName].length; i++) {\\n            NFT memory token = _wishlistCurrent[listName][i];\\n            IERC721 tokenContract = IERC721(token.c);\\n            tokenContract.safeTransferFrom(address(this), msg.sender, token.tokenId);\\n        }\\n        delete _wishlistCurrent[listName];\\n    }\\n\\n    function getTokens() external view returns (NFT[] memory) {\\n        return _tokens[msg.sender];\\n    }\\n\\n    function getWishlistOwner(string memory listName) external view returns (address) {\\n        return _wishlists[listName].owner;\\n    }\\n\\n    function getWishlists() external view returns (string[] memory) {\\n        return _wishlistsByOwner[msg.sender];\\n    }\\n\\n    function getWishlistName(string memory listName) external view returns (string memory) {\\n        return _wishlists[listName].name;\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"listName\",\"type\":\"string\"}],\"name\":\"claimFromWishlist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"c\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct Registry.NFT[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"listName\",\"type\":\"string\"}],\"name\":\"getWishlistCurrent\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"c\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct Registry.NFT[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"listName\",\"type\":\"string\"}],\"name\":\"getWishlistName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"listName\",\"type\":\"string\"}],\"name\":\"getWishlistOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"listName\",\"type\":\"string\"}],\"name\":\"getWishlistWanted\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWishlists\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setCreatePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"d\",\"type\":\"bool\"}],\"name\":\"setDisabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setUpdatePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferOut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"listName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferToWishlist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"listName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"displayName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"name\":\"updateWishlist\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Registry","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}