{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PalLoanToken.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n//SPDX-License-Identifier: MIT\\n\\nimport \\\"./IPalLoanToken.sol\\\";\\nimport \\\"./utils/ERC165.sol\\\";\\nimport \\\"./utils/SafeMath.sol\\\";\\nimport \\\"./utils/Strings.sol\\\";\\nimport \\\"./utils/Admin.sol\\\";\\nimport \\\"./IPaladinController.sol\\\";\\nimport \\\"./BurnedPalLoanToken.sol\\\";\\nimport {Errors} from  \\\"./utils/Errors.sol\\\";\\n\\n/** @title palLoanToken contract  */\\n/// @author Paladin\\ncontract PalLoanToken is IPalLoanToken, ERC165, Admin {\\n    using SafeMath for uint;\\n    using Strings for uint;\\n\\n    //Storage\\n\\n    // Token name\\n    string public name;\\n\\n    // Token symbol\\n    string public symbol;\\n\\n    // Token base URI\\n    string public baseURI;\\n\\n    //Incremental index for next token ID\\n    uint256 private index;\\n\\n    uint256 public totalSupply;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private balances;\\n\\n    // Mapping from owner to list of owned token ID\\n    mapping(address => uint256[]) private ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) private ownedTokensIndex;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private approvals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private operatorApprovals;\\n\\n    // Paladin controller\\n    IPaladinController public controller;\\n\\n    // Burned Token contract\\n    BurnedPalLoanToken public burnedToken;\\n\\n    // Mapping from token ID to origin PalPool\\n    mapping(uint256 => address) private pools;\\n\\n    // Mapping from token ID to PalLoan address\\n    mapping(uint256 => address) private loans;\\n\\n\\n\\n\\n    //Modifiers\\n    modifier controllerOnly() {\\n        //allows only the Controller and the admin to call the function\\n        require(msg.sender == admin || msg.sender == address(controller), Errors.CALLER_NOT_CONTROLLER);\\n        _;\\n    }\\n\\n    modifier poolsOnly() {\\n        //allows only a PalPool listed in the Controller\\n        require(controller.isPalPool(msg.sender), Errors.CALLER_NOT_ALLOWED_POOL);\\n        _;\\n    }\\n\\n\\n\\n    //Constructor\\n    constructor(address _controller, string memory _baseURI) {\\n        admin = msg.sender;\\n\\n        // ERC721 parameters + storage data\\n        name = \\\"PalLoan Token\\\";\\n        symbol = \\\"PLT\\\";\\n        controller = IPaladinController(_controller);\\n\\n        baseURI = _baseURI;\\n\\n        //Create the Burned version of this ERC721\\n        burnedToken = new BurnedPalLoanToken(\\\"burnedPalLoan Token\\\", \\\"bPLT\\\");\\n    }\\n\\n\\n    //Functions\\n\\n    //Required ERC165 function\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n\\n    //URI method\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        return string(abi.encodePacked(baseURI, tokenId.toString()));\\n    }\\n\\n\\n    /**\\n    * @notice Return the user balance (total number of token owned)\\n    * @param owner Address of the user\\n    * @return uint256 : number of token owned (in this contract only)\\n    */\\n    function balanceOf(address owner) external view override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return balances[owner];\\n    }\\n\\n\\n    /**\\n    * @notice Return owner of the token\\n    * @param tokenId Id of the token\\n    * @return address : owner address\\n    */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        address owner = owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n\\n    /**\\n    * @notice Return the tokenId for a given owner and index\\n    * @param tokenIndex Index of the token\\n    * @return uint256 : tokenId\\n    */\\n    function tokenOfByIndex(address owner, uint256 tokenIndex) external view override returns (uint256) {\\n        require(tokenIndex < balances[owner], \\\"ERC721: token query out of bonds\\\");\\n        return ownedTokens[owner][tokenIndex];\\n    }\\n\\n\\n    /**\\n    * @notice Return owner of the token, even if the token was burned \\n    * @dev Check if the given id has an owner in this contract, and then if it was burned and has an owner\\n    * @param tokenId Id of the token\\n    * @return address : address of the owner\\n    */\\n    function allOwnerOf(uint256 tokenId) external view override returns (address) {\\n        require(tokenId < index, \\\"ERC721: owner query for nonexistent token\\\");\\n        return owners[tokenId] != address(0) ? owners[tokenId] : burnedToken.ownerOf(tokenId);\\n    }\\n\\n\\n    /**\\n    * @notice Return the address of the palLoan for this token\\n    * @param tokenId Id of the token\\n    * @return address : address of the palLoan\\n    */\\n    function loanOf(uint256 tokenId) external view override returns(address){\\n        return loans[tokenId];\\n    }\\n\\n\\n    /**\\n    * @notice Return the palPool that issued this token\\n    * @param tokenId Id of the token\\n    * @return address : address of the palPool\\n    */\\n    function poolOf(uint256 tokenId) external view override returns(address){\\n        return pools[tokenId];\\n    }\\n\\n    \\n    /**\\n    * @notice Return the list of all active palLoans owned by the user\\n    * @dev Find all the token owned by the user, and return the list of palLoans linked to the found tokens\\n    * @param owner User address\\n    * @return address[] : list of owned active palLoans\\n    */\\n    function loansOf(address owner) external view override returns(address[] memory){\\n        require(index > 0);\\n        uint256 tokenCount = balances[owner];\\n        address[] memory result = new address[](tokenCount);\\n\\n        for(uint256 i = 0; i < tokenCount; i++){\\n            result[i] = loans[ownedTokens[owner][i]];\\n        }\\n\\n        return result;\\n    }\\n\\n\\n    /**\\n    * @notice Return the list of all tokens owned by the user\\n    * @dev Find all the token owned by the user\\n    * @param owner User address\\n    * @return uint256[] : list of owned tokens\\n    */\\n    function tokensOf(address owner) external view override returns(uint256[] memory){\\n        require(index > 0);\\n        return ownedTokens[owner];\\n    }\\n\\n\\n    /**\\n    * @notice Return the list of all active palLoans owned by the user for the given palPool\\n    * @dev Find all the token owned by the user issued by the given Pool, and return the list of palLoans linked to the found tokens\\n    * @param owner User address\\n    * @return address[] : list of owned active palLoans for the given palPool\\n    */\\n    function loansOfForPool(address owner, address palPool) external view override returns(address[] memory){\\n        require(index > 0);\\n        uint j = 0;\\n        uint256 tokenCount = balances[owner];\\n        address[] memory result = new address[](tokenCount);\\n\\n        for(uint256 i = 0; i < tokenCount; i++){\\n            if(pools[ownedTokens[owner][i]] == palPool){\\n                result[j] = loans[ownedTokens[owner][i]];\\n                j++;\\n            }\\n        }\\n\\n        //put the result in a new array with correct size to avoid 0x00 addresses in the return array\\n        address[] memory filteredResult = new address[](j);\\n        for(uint256 k = 0; k < j; k++){\\n            filteredResult[k] = result[k];   \\n        }\\n\\n        return filteredResult;\\n    }\\n\\n\\n    /**\\n    * @notice Return the list of all tokens owned by the user\\n    * @dev Find all the token owned by the user (in this contract and in the Burned contract)\\n    * @param owner User address\\n    * @return uint256[] : list of owned tokens\\n    */\\n    function allTokensOf(address owner) external view override returns(uint256[] memory){\\n        require(index > 0);\\n        uint256 tokenCount = balances[owner];\\n        uint256 totalCount = tokenCount.add(burnedToken.balanceOf(owner));\\n        uint256[] memory result = new uint256[](totalCount);\\n\\n        uint256[] memory ownerTokens = ownedTokens[owner];\\n        for(uint256 i = 0; i < tokenCount; i++){\\n            result[i] = ownerTokens[i];\\n        }\\n\\n        uint256[] memory burned = burnedToken.tokensOf(owner);\\n        for(uint256 j = tokenCount; j < totalCount; j++){\\n            result[j] = burned[j.sub(tokenCount)];\\n        }\\n\\n        return result;\\n    }\\n\\n\\n    /**\\n    * @notice Return the list of all palLoans (active and closed) owned by the user\\n    * @dev Find all the token owned by the user, and all the burned tokens owned by the user,\\n    * and return the list of palLoans linked to the found tokens\\n    * @param owner User address\\n    * @return address[] : list of owned palLoans\\n    */\\n    function allLoansOf(address owner) external view override returns(address[] memory){\\n        require(index > 0);\\n        uint256 tokenCount = balances[owner];\\n        uint256 totalCount = tokenCount.add(burnedToken.balanceOf(owner));\\n        address[] memory result = new address[](totalCount);\\n\\n        uint256[] memory ownerTokens = ownedTokens[owner];\\n        for(uint256 i = 0; i < tokenCount; i++){\\n            result[i] = loans[ownerTokens[i]];\\n        }\\n\\n        uint256[] memory burned = burnedToken.tokensOf(owner);\\n        for(uint256 j = tokenCount; j < totalCount; j++){\\n            result[j] = loans[burned[j.sub(tokenCount)]];\\n        }\\n\\n        return result;\\n    }\\n\\n\\n    /**\\n    * @notice Return the list of all palLoans owned by the user for the given palPool\\n    * @dev Find all the token owned by the user issued by the given Pool, and return the list of palLoans linked to the found tokens\\n    * @param owner User address\\n    * @return address[] : list of owned palLoans (active & closed) for the given palPool\\n    */\\n    function allLoansOfForPool(address owner, address palPool) external view override returns(address[] memory){\\n        require(index > 0);\\n        uint m = 0;\\n        uint256 tokenCount = balances[owner];\\n        uint256 totalCount = tokenCount.add(burnedToken.balanceOf(owner));\\n        address[] memory result = new address[](totalCount);\\n\\n        uint256[] memory ownerTokens = ownedTokens[owner];\\n        for(uint256 i = 0; i < tokenCount; i++){\\n            if(pools[ownerTokens[i]] == palPool){\\n                result[m] = loans[ownerTokens[i]];\\n                m++;\\n            }\\n        }\\n\\n        uint256[] memory burned = burnedToken.tokensOf(owner);\\n        for(uint256 j = tokenCount; j < totalCount; j++){\\n            uint256 burnedId = burned[j.sub(tokenCount)];\\n            if(pools[burnedId] == palPool){\\n                result[m] = loans[burnedId];\\n                m++;\\n            }\\n        }\\n\\n        //put the result in a new array with correct size to avoid 0x00 addresses in the return array\\n        address[] memory filteredResult = new address[](m);\\n        for(uint256 k = 0; k < m; k++){\\n            filteredResult[k] = result[k];   \\n        }\\n\\n        return filteredResult;\\n    }\\n\\n\\n    /**\\n    * @notice Check if the token was burned\\n    * @param tokenId Id of the token\\n    * @return bool : true if burned\\n    */\\n    function isBurned(uint256 tokenId) external view override returns(bool){\\n        return burnedToken.ownerOf(tokenId) != address(0);\\n    }\\n\\n\\n\\n\\n\\n    /**\\n    * @notice Approve the address to spend the token\\n    * @param to Address of the spender\\n    * @param tokenId Id of the token to approve\\n    */\\n    function approve(address to, uint256 tokenId) external virtual override {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n\\n    /**\\n    * @notice Return the approved address for the token\\n    * @param tokenId Id of the token\\n    * @return address : spender's address\\n    */\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return approvals[tokenId];\\n    }\\n\\n\\n    /**\\n    * @notice Give the operator approval on all tokens owned by the user, or remove it by setting it to false\\n    * @param operator Address of the operator to approve\\n    * @param approved Boolean : give or remove approval\\n    */\\n    function setApprovalForAll(address operator, bool approved) external virtual override {\\n        require(operator != msg.sender, \\\"ERC721: approve to caller\\\");\\n\\n        operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n\\n    /**\\n    * @notice Return true if the operator is approved for the given user\\n    * @param owner Amount of the owner\\n    * @param operator Address of the operator\\n    * @return bool :  result\\n    */\\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\\n        return operatorApprovals[owner][operator];\\n    }\\n\\n\\n\\n\\n\\n\\n\\n    /**\\n    * @notice Transfer the token from the owner to the recipient (if allowed)\\n    * @param from Address of the owner\\n    * @param to Address of the recipient\\n    * @param tokenId Id of the token\\n    */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external virtual override {\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n\\n    /**\\n    * @notice Safe transfer the token from the owner to the recipient (if allowed)\\n    * @param from Address of the owner\\n    * @param to Address of the recipient\\n    * @param tokenId Id of the token\\n    */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external virtual override {\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        require(_transfer(from, to, tokenId), \\\"ERC721: transfer failed\\\");\\n    }\\n\\n\\n    /**\\n    * @notice Safe transfer the token from the owner to the recipient (if allowed)\\n    * @param from Address of the owner\\n    * @param to Address of the recipient\\n    * @param tokenId Id of the token\\n    */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) external virtual override {\\n        _data;\\n        require(_isApprovedOrOwner(msg.sender, tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        require(_transfer(from, to, tokenId), \\\"ERC721: transfer failed\\\");\\n    }\\n\\n\\n\\n\\n\\n\\n    /**\\n    * @notice Mint a new token to the given address\\n    * @dev Mint the new token, and list it with the given palLoan and palPool\\n    * @param to Address of the user to mint the token to\\n    * @param palPool Address of the palPool issuing the token\\n    * @param palLoan Address of the palLoan linked to the token\\n    * @return uint256 : new token Id\\n    */\\n    function mint(address to, address palPool, address palLoan) external override poolsOnly returns(uint256){\\n        require(palLoan != address(0), Errors.ZERO_ADDRESS);\\n\\n        //Call the internal mint method, and get the new token Id\\n        uint256 newId = _mint(to);\\n\\n        //Set the correct data in mappings for this token\\n        loans[newId] = palLoan;\\n        pools[newId] = palPool;\\n\\n        //Emit the Mint Event\\n        emit NewLoanToken(palPool, to, palLoan, newId);\\n\\n        //Return the new token Id\\n        return newId;\\n    }\\n\\n\\n    /**\\n    * @notice Burn the given token\\n    * @dev Burn the token, and mint the BurnedToken for this token\\n    * @param tokenId Id of the token to burn\\n    * @return bool : success\\n    */\\n    function burn(uint256 tokenId) external override poolsOnly returns(bool){\\n        address owner = ownerOf(tokenId);\\n\\n        require(owner != address(0), \\\"ERC721: token nonexistant\\\");\\n\\n        //Mint the Burned version of this token\\n        burnedToken.mint(owner, tokenId);\\n\\n        //Emit the correct event\\n        emit BurnLoanToken(pools[tokenId], owner, loans[tokenId], tokenId);\\n\\n        //call the internal burn method\\n        return _burn(owner, tokenId);\\n    }\\n\\n    \\n\\n    \\n\\n\\n\\n    /**\\n    * @notice Check if a token exists\\n    * @param tokenId Id of the token\\n    * @return bool : true if token exists (active or burned)\\n    */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return owners[tokenId] != address(0) || burnedToken.ownerOf(tokenId) != address(0);\\n    }\\n\\n\\n    /**\\n    * @notice Check if the given user is approved for the given token\\n    * @param spender Address of the user to check\\n    * @param tokenId Id of the token\\n    * @return bool : true if approved\\n    */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n\\n    function _addTokenToOwner(address to, uint tokenId) internal {\\n        uint ownerIndex = balances[to];\\n        ownedTokens[to].push(tokenId);\\n        ownedTokensIndex[tokenId] = ownerIndex;\\n        balances[to] = balances[to].add(1);\\n    }\\n\\n\\n    function _removeTokenToOwner(address from, uint tokenId) internal {\\n        // To prevent any gap in the array, we subsitute the last token with the one to remove, \\n        // and pop the last element in the array\\n        uint256 lastTokenIndex = balances[from].sub(1);\\n        uint256 tokenIndex = ownedTokensIndex[tokenId];\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = ownedTokens[from][lastTokenIndex];\\n            ownedTokens[from][tokenIndex] = lastTokenId;\\n            ownedTokensIndex[lastTokenId] = tokenIndex;\\n        }\\n        delete ownedTokensIndex[tokenId];\\n        ownedTokens[from].pop();\\n        balances[from] = balances[from].sub(1);\\n    }\\n\\n\\n    /**\\n    * @notice Mint the new token\\n    * @param to Address of the user to mint the token to\\n    * @return uint : Id of the new token\\n    */\\n    function _mint(address to) internal virtual returns(uint) {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n\\n        //Get the new token Id, and increase the global index\\n        uint tokenId = index;\\n        index = index.add(1);\\n        totalSupply = totalSupply.add(1);\\n\\n        //Write this token in the storage\\n        _addTokenToOwner(to, tokenId);\\n        owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        //Return the new token Id\\n        return tokenId;\\n    }\\n\\n\\n    /**\\n    * @notice Burn the given token\\n    * @param owner Address of the token owner\\n    * @param tokenId Id of the token to burn\\n    * @return bool : success\\n    */\\n    function _burn(address owner, uint256 tokenId) internal virtual returns(bool) {\\n        //Reset the token approval\\n        _approve(address(0), tokenId);\\n\\n        //Update data in storage\\n        totalSupply = totalSupply.sub(1);\\n        _removeTokenToOwner(owner, tokenId);\\n        owners[tokenId] = address(0);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        return true;\\n    }\\n\\n\\n    /**\\n    * @notice Transfer the token from the owner to the recipient\\n    * @dev Deposit underlying, and mints palToken for the user\\n    * @param from Address of the owner\\n    * @param to Address of the recipient\\n    * @param tokenId Id of the token\\n    * @return bool : success\\n    */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual returns(bool) {\\n        require(ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        //Reset token approval\\n        _approve(address(0), tokenId);\\n\\n        //Update storage data\\n        _removeTokenToOwner(from, tokenId);\\n        _addTokenToOwner(to, tokenId);\\n        owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        return true;\\n    }\\n\\n\\n    /**\\n    * @notice Approve the given address to spend the token\\n    * @param to Address to approve\\n    * @param tokenId Id of the token to approve\\n    */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        approvals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n\\n\\n    //Admin functions\\n    /**\\n    * @notice Set a new Controller\\n    * @dev Loads the new Controller for the Pool\\n    * @param  _newController address of the new Controller\\n    */\\n    function setNewController(address _newController) external override controllerOnly {\\n        controller = IPaladinController(_newController);\\n    }\\n\\n\\n    function setNewBaseURI(string memory _newBaseURI) external override adminOnly {\\n        baseURI = _newBaseURI;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/IPalLoanToken.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n//SPDX-License-Identifier: MIT\\n\\nimport \\\"./utils/IERC721.sol\\\";\\n\\n/** @title palLoanToken Interface  */\\n/// @author Paladin\\ninterface IPalLoanToken is IERC721 {\\n\\n    //Events\\n\\n    /** @notice Event when a new Loan Token is minted */\\n    event NewLoanToken(address palPool, address indexed owner, address indexed palLoan, uint256 indexed tokenId);\\n    /** @notice Event when a Loan Token is burned */\\n    event BurnLoanToken(address palPool, address indexed owner, address indexed palLoan, uint256 indexed tokenId);\\n\\n\\n    //Functions\\n    function mint(address to, address palPool, address palLoan) external returns(uint256);\\n    function burn(uint256 tokenId) external returns(bool);\\n\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n\\n    function tokenOfByIndex(address owner, uint256 tokenIdex) external view returns (uint256);\\n    function loanOf(uint256 tokenId) external view returns(address);\\n    function poolOf(uint256 tokenId) external view returns(address);\\n    function loansOf(address owner) external view returns(address[] memory);\\n    function tokensOf(address owner) external view returns(uint256[] memory);\\n    function loansOfForPool(address owner, address palPool) external view returns(address[] memory);\\n    function allTokensOf(address owner) external view returns(uint256[] memory);\\n    function allLoansOf(address owner) external view returns(address[] memory);\\n    function allLoansOfForPool(address owner, address palPool) external view returns(address[] memory);\\n    function allOwnerOf(uint256 tokenId) external view returns(address);\\n\\n    function isBurned(uint256 tokenId) external view returns(bool);\\n\\n    //Admin functions\\n    function setNewController(address _newController) external;\\n    function setNewBaseURI(string memory _newBaseURI) external;\\n\\n}\"\r\n    },\r\n    \"contracts/utils/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\"\r\n    },\r\n    \"contracts/utils/Admin.sol\": {\r\n      \"content\": \"pragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\n\\n/** @title Admin contract  */\\n/// @author Paladin\\ncontract Admin {\\n\\n    /** @notice (Admin) Event when the contract admin is updated */\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    /** @dev Admin address for this contract */\\n    address payable internal admin;\\n    \\n    modifier adminOnly() {\\n        //allows only the admin of this contract to call the function\\n        require(msg.sender == admin, '1');\\n        _;\\n    }\\n\\n        /**\\n    * @notice Set a new Admin\\n    * @dev Changes the address for the admin parameter\\n    * @param _newAdmin address of the new Controller Admin\\n    */\\n    function setNewAdmin(address payable _newAdmin) external adminOnly {\\n        address _oldAdmin = admin;\\n        admin = _newAdmin;\\n\\n        emit NewAdmin(_oldAdmin, _newAdmin);\\n    }\\n}\"\r\n    },\r\n    \"contracts/IPaladinController.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\n/** @title Paladin Controller Interface  */\\n/// @author Paladin\\ninterface IPaladinController {\\n    \\n    //Events\\n\\n    /** @notice Event emitted when a new token & pool are added to the list */\\n    event NewPalPool(address palPool, address palToken);\\n    /** @notice Event emitted when a token & pool are removed from the list */\\n    event RemovePalPool(address palPool, address palToken);\\n\\n\\n    //Functions\\n    function isPalPool(address pool) external view returns(bool);\\n    function getPalTokens() external view returns(address[] memory);\\n    function getPalPools() external view returns(address[] memory);\\n    function setInitialPools(address[] memory palTokens, address[] memory palPools) external returns(bool);\\n    function addNewPool(address palToken, address palPool) external returns(bool);\\n    function removePool(address _palPool) external returns(bool);\\n\\n    function withdrawPossible(address palPool, uint amount) external view returns(bool);\\n    function borrowPossible(address palPool, uint amount) external view returns(bool);\\n\\n    function depositVerify(address palPool, address dest, uint amount) external view returns(bool);\\n    function withdrawVerify(address palPool, address dest, uint amount) external view returns(bool);\\n    function borrowVerify(address palPool, address borrower, address delegatee, uint amount, uint feesAmount, address loanAddress) external view returns(bool);\\n    function expandBorrowVerify(address palPool, address loanAddress, uint newFeesAmount) external view returns(bool);\\n    function closeBorrowVerify(address palPool, address borrower, address loanAddress) external view returns(bool);\\n    function killBorrowVerify(address palPool, address killer, address loanAddress) external view returns(bool);\\n\\n    //Admin functions\\n    function setPoolsNewController(address _newController) external returns(bool);\\n    function withdrawFromPool(address _pool, uint _amount, address _recipient) external returns(bool);\\n\\n}\"\r\n    },\r\n    \"contracts/BurnedPalLoanToken.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\npragma abicoder v2;\\n//SPDX-License-Identifier: MIT\\n\\nimport {Errors} from  \\\"./utils/Errors.sol\\\";\\nimport \\\"./utils/SafeMath.sol\\\";\\nimport \\\"./IPalLoanToken.sol\\\";\\n\\n\\n\\n/** @title BurnedPalLoanToken contract  */\\n/// @author Paladin\\ncontract BurnedPalLoanToken{\\n    using SafeMath for uint;\\n\\n    //Storage\\n\\n    // Token name\\n    string public name;\\n    // Token symbol\\n    string public symbol;\\n\\n    //Token Minter contract : PalLoanToken\\n    address public minter;\\n\\n    uint256 public totalSupply;\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256[]) private balances;\\n\\n\\n    //Modifiers\\n    modifier authorized() {\\n        //allows only the palLoanToken contract to call methds\\n        require(msg.sender == minter, Errors.CALLER_NOT_MINTER);\\n        _;\\n    }\\n\\n\\n    //Events\\n\\n    /** @notice Event when a new token is minted */\\n    event NewBurnedLoanToken(address indexed to, uint256 indexed tokenId);\\n\\n\\n    //Constructor\\n    constructor(string memory _name, string memory _symbol) {\\n        //ERC721 parameters\\n        name = _name;\\n        symbol = _symbol;\\n        minter = msg.sender;\\n        totalSupply = 0;\\n    }\\n\\n\\n\\n    //Functions\\n\\n\\n    //URI method\\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\\n        return IPalLoanToken(minter).tokenURI(tokenId);\\n    }\\n\\n    /**\\n    * @notice Return the user balance (total number of token owned)\\n    * @param owner Address of the user\\n    * @return uint256 : number of token owned (in this contract only)\\n    */\\n    function balanceOf(address owner) external view returns (uint256){\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return balances[owner].length;\\n    }\\n\\n\\n    /**\\n    * @notice Return owner of the token\\n    * @param tokenId Id of the token\\n    * @return address : owner address\\n    */\\n    function ownerOf(uint256 tokenId) external view returns (address){\\n        return owners[tokenId];\\n    }\\n\\n    \\n    /**\\n    * @notice Return the list of all tokens owned by the user\\n    * @dev Return the list of user's tokens\\n    * @param owner User address\\n    * @return uint256[] : list of owned tokens\\n    */\\n    function tokensOf(address owner) external view returns(uint256[] memory){\\n        return balances[owner];\\n    }\\n\\n    \\n\\n    /**\\n    * @notice Mint a new token to the given address with the given Id\\n    * @dev Mint the new token with the correct Id (from the previous burned token)\\n    * @param to Address of the user to mint the token to\\n    * @param tokenId Id of the token to mint\\n    * @return bool : success\\n    */\\n    function mint(address to, uint256 tokenId) external authorized returns(bool){\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n\\n        //Update Supply\\n        totalSupply = totalSupply.add(1);\\n\\n        //Add the new token to storage\\n        balances[to].push(tokenId);\\n        owners[tokenId] = to;\\n\\n        //Emit the correct Event\\n        emit NewBurnedLoanToken(to, tokenId);\\n\\n        return true;\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/utils/Errors.sol\": {\r\n      \"content\": \"//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗\\n//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║\\n//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║\\n//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║\\n//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║\\n//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝\\n                                                     \\n\\npragma solidity ^0.7.6;\\n//SPDX-License-Identifier: MIT\\n\\nlibrary Errors {\\n    // Admin error\\n    string public constant CALLER_NOT_ADMIN = '1'; // 'The caller must be the admin'\\n    string public constant CALLER_NOT_CONTROLLER = '29'; // 'The caller must be the admin or the controller'\\n    string public constant CALLER_NOT_ALLOWED_POOL = '30';  // 'The caller must be a palPool listed in the controller'\\n    string public constant CALLER_NOT_MINTER = '31';\\n\\n    // ERC20 type errors\\n    string public constant FAIL_TRANSFER = '2';\\n    string public constant FAIL_TRANSFER_FROM = '3';\\n    string public constant BALANCE_TOO_LOW = '4';\\n    string public constant ALLOWANCE_TOO_LOW = '5';\\n    string public constant SELF_TRANSFER = '6';\\n\\n    // PalPool errors\\n    string public constant INSUFFICIENT_CASH = '9';\\n    string public constant INSUFFICIENT_BALANCE = '10';\\n    string public constant FAIL_DEPOSIT = '11';\\n    string public constant FAIL_LOAN_INITIATE = '12';\\n    string public constant FAIL_BORROW = '13';\\n    string public constant ZERO_BORROW = '27';\\n    string public constant BORROW_INSUFFICIENT_FEES = '23';\\n    string public constant LOAN_CLOSED = '14';\\n    string public constant NOT_LOAN_OWNER = '15';\\n    string public constant LOAN_OWNER = '16';\\n    string public constant FAIL_LOAN_EXPAND = '17';\\n    string public constant NOT_KILLABLE = '18';\\n    string public constant RESERVE_FUNDS_INSUFFICIENT = '19';\\n    string public constant FAIL_MINT = '20';\\n    string public constant FAIL_BURN = '21';\\n    string public constant FAIL_WITHDRAW = '24';\\n    string public constant FAIL_CLOSE_BORROW = '25';\\n    string public constant FAIL_KILL_BORROW = '26';\\n    string public constant ZERO_ADDRESS = '22';\\n    string public constant INVALID_PARAMETERS = '28'; \\n    string public constant FAIL_LOAN_DELEGATEE_CHANGE = '32';\\n    string public constant FAIL_LOAN_TOKEN_BURN = '33';\\n    string public constant FEES_ACCRUED_INSUFFICIENT = '34';\\n\\n}\"\r\n    },\r\n    \"contracts/utils/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/utils/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 25000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"palPool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"palLoan\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"BurnLoanToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"palPool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"palLoan\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NewLoanToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"allLoansOf\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"palPool\",\"type\":\"address\"}],\"name\":\"allLoansOfForPool\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"allOwnerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"allTokensOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnedToken\",\"outputs\":[{\"internalType\":\"contract BurnedPalLoanToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract IPaladinController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isBurned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"loanOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"loansOf\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"palPool\",\"type\":\"address\"}],\"name\":\"loansOfForPool\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"palPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"palLoan\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"poolOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setNewAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newBaseURI\",\"type\":\"string\"}],\"name\":\"setNewBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"setNewController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenIndex\",\"type\":\"uint256\"}],\"name\":\"tokenOfByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokensOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"PalLoanToken","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"25000","ConstructorArguments":"000000000000000000000000bbfa3b05b2dae65fb4c05ec7f1598793a4bc06230000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000b61626f75743a626c616e6b000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}