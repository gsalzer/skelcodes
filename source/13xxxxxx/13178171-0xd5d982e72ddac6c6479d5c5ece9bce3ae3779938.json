{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\npragma abicoder v2;\n\n/* solium-disable error-reason */\n\nlibrary ECVerify {\n\n    function ecverify(bytes32 hash, bytes memory signature)\n        internal\n        pure\n        returns (address signature_address)\n    {\n        require(signature.length == 65);\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // The signature format is a compact form of:\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n        // Compact means, uint8 is not padded to 32 bytes.\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(signature, 32))\n            s := mload(add(signature, 64))\n\n            // Here we are loading the last 32 bytes, including 31 bytes following the signature.\n            v := byte(0, mload(add(signature, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible\n        if (v < 27) {\n            v += 27;\n        }\n\n        require(v == 27 || v == 28);\n\n        signature_address = ecrecover(hash, v, r, s);\n\n        // ecrecover returns zero on error\n        require(signature_address != address(0x0));\n\n        return signature_address;\n    }\n}\n/* solium-disable error-reason */\n\nlibrary MessageType {\n\n    enum MessageTypeId {\n        None,\n        BalanceProof,\n        BalanceProofUpdate,\n        Withdraw,\n        CooperativeSettle,\n        IOU,\n        MSReward\n    }\n}\n\ninterface Token {\n\n    /// @return supply total amount of tokens\n    function totalSupply() external view returns (uint256 supply);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return balance The balance\n    function balanceOf(address _owner) external view returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) external returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return success Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return success Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) external returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return remaining Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    // Optionally implemented function to show the number of decimals for the token\n    function decimals() external view returns (uint8 decimals);\n}\n\n/// @title Utils\n/// @notice Utils contract for various helpers used by the Raiden Network smart\n/// contracts.\ncontract Utils {\n\n    uint256 constant MAX_SAFE_UINT256 = 2**256 - 1;\n\n    /// @notice Check if a contract exists\n    /// @param contract_address The address to check whether a contract is\n    /// deployed or not\n    /// @return True if a contract exists, false otherwise\n    function contractExists(address contract_address) public view returns (bool) {\n        uint size;\n\n        assembly { // solium-disable-line security/no-inline-assembly\n            size := extcodesize(contract_address)\n        }\n\n        return size > 0;\n    }\n\n    string public constant signature_prefix = \"\\x19Ethereum Signed Message:\\n\";\n\n    function min(uint256 a, uint256 b) public pure returns (uint256)\n    {\n        return a > b ? b : a;\n    }\n\n    function max(uint256 a, uint256 b) public pure returns (uint256)\n    {\n        return a > b ? a : b;\n    }\n\n    /// @dev Special subtraction function that does not fail when underflowing.\n    /// @param a Minuend\n    /// @param b Subtrahend\n    /// @return Minimum between the result of the subtraction and 0, the maximum\n    /// subtrahend for which no underflow occurs\n    function failsafe_subtract(uint256 a, uint256 b)\n        public\n        pure\n        returns (uint256, uint256)\n    {\n        unchecked {\n            return a > b ? (a - b, b) : (0, a);\n        }\n    }\n\n    /// @dev Special addition function that does not fail when overflowing.\n    /// @param a Addend\n    /// @param b Addend\n    /// @return Maximum between the result of the addition or the maximum\n    /// uint256 value\n    function failsafe_addition(uint256 a, uint256 b)\n        public\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            uint256 sum = a + b;\n            return sum >= a ? sum : MAX_SAFE_UINT256;\n        }\n    }\n}\n/* solium-disable indentation */\n\n\n/// @title SecretRegistry\n/// @notice SecretRegistry contract for registering secrets from Raiden Network\n/// clients.\ncontract SecretRegistry {\n    // sha256(secret) => block number at which the secret was revealed\n    mapping(bytes32 => uint256) private secrethash_to_block;\n\n    event SecretRevealed(bytes32 indexed secrethash, bytes32 secret);\n\n    /// @notice Registers a hash time lock secret and saves the block number.\n    /// This allows the lock to be unlocked after the expiration block\n    /// @param secret The secret used to lock the hash time lock\n    /// @return true if secret was registered, false if the secret was already\n    /// registered\n    function registerSecret(bytes32 secret) public returns (bool) {\n        bytes32 secrethash = sha256(abi.encodePacked(secret));\n        if (secrethash_to_block[secrethash] > 0) {\n            return false;\n        }\n        secrethash_to_block[secrethash] = block.number;\n        emit SecretRevealed(secrethash, secret);\n        return true;\n    }\n\n    /// @notice Registers multiple hash time lock secrets and saves the block\n    /// number\n    /// @param secrets The array of secrets to be registered\n    /// @return true if all secrets could be registered, false otherwise\n    function registerSecretBatch(bytes32[] memory secrets) public returns (bool) {\n        bool completeSuccess = true;\n        for(uint i = 0; i < secrets.length; i++) {\n            if(!registerSecret(secrets[i])) {\n                completeSuccess = false;\n            }\n        }\n        return completeSuccess;\n    }\n\n    /// @notice Get the stored block number at which the secret was revealed\n    /// @param secrethash The hash of the registered secret `keccak256(secret)`\n    /// @return The block number at which the secret was revealed\n    function getSecretRevealBlockHeight(bytes32 secrethash) public view returns (uint256) {\n        return secrethash_to_block[secrethash];\n    }\n}\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\ncontract Controllable {\n\n    address public controller;\n\n    modifier onlyController() {\n        require(msg.sender == controller, \"Can only be called by controller\");\n        _;\n    }\n\n    /// @notice Changes the controller who is allowed to deprecate or remove limits.\n    /// Can only be called by the controller.\n    function changeController(address new_controller)\n        external\n        onlyController\n    {\n        controller = new_controller;\n    }\n}\n\n/// @title TokenNetwork\n/// @notice Stores and manages all the Raiden Network channels that use the\n/// token specified in this TokenNetwork contract.\ncontract TokenNetwork is Utils, Controllable {\n    // Instance of the token used by the channels\n    Token public token;\n\n    // Instance of SecretRegistry used for storing secrets revealed in a\n    // mediating transfer.\n    SecretRegistry public secret_registry;\n\n    uint256 public settlement_timeout_min;\n    uint256 public settlement_timeout_max;\n\n    // The deposit limit per channel per participant.\n    uint256 public channel_participant_deposit_limit;\n    // The total combined deposit of all channels across the whole network\n    uint256 public token_network_deposit_limit;\n\n    // Global, monotonically increasing counter that keeps track of all the\n    // opened channels in this contract\n    uint256 public channel_counter;\n\n    // Only for the limited Red Eyes release\n    bool public safety_deprecation_switch = false;\n\n    // channel_identifier => Channel\n    // channel identifier is the channel_counter value at the time of opening\n    // the channel\n    mapping (uint256 => Channel) public channels;\n\n    // This is needed to enforce one channel per pair of participants\n    // The key is keccak256(participant1_address, participant2_address)\n    mapping (bytes32 => uint256) public participants_hash_to_channel_identifier;\n\n    // We keep the unlock data in a separate mapping to allow channel data\n    // structures to be removed when settling uncooperatively. If there are\n    // locked pending transfers, we need to store data needed to unlock them at\n    // a later time.\n    // The key is `keccak256(uint256 channel_identifier, address participant,\n    // address partner)` Where `participant` is the participant that sent the\n    // pending transfers We need `partner` for knowing where to send the\n    // claimable tokens\n    mapping(bytes32 => UnlockData) private unlock_identifier_to_unlock_data;\n\n    struct Participant {\n        // Total amount of tokens transferred to this smart contract through\n        // the `setTotalDeposit` function, for a specific channel, in the\n        // participant's benefit.\n        // This is a strictly monotonic value. Note that direct token transfer\n        // into the contract cannot be tracked and will be stuck.\n        uint256 deposit;\n\n        // Total amount of tokens withdrawn by the participant during the\n        // lifecycle of this channel.\n        // This is a strictly monotonic value.\n        uint256 withdrawn_amount;\n\n        // This is a value set to true after the channel has been closed, only\n        // if this is the participant who closed the channel.\n        bool is_the_closer;\n\n        // keccak256 of the balance data provided after a closeChannel or an\n        // updateNonClosingBalanceProof call\n        bytes32 balance_hash;\n\n        // Monotonically increasing counter of the off-chain transfers,\n        // provided along with the balance_hash\n        uint256 nonce;\n    }\n\n    enum ChannelState {\n        NonExistent, // 0\n        Opened,      // 1\n        Closed,      // 2\n        Settled,     // 3; Note: The channel has at least one pending unlock\n        Removed      // 4; Note: Channel data is removed, there are no pending unlocks\n    }\n\n    struct Channel {\n        // After opening the channel this value represents the settlement\n        // window. This is the number of blocks that need to be mined between\n        // closing the channel uncooperatively and settling the channel.\n        // After the channel has been uncooperatively closed, this value\n        // represents the block number after which settleChannel can be called.\n        uint256 settle_block_number;\n\n        ChannelState state;\n\n        mapping(address => Participant) participants;\n    }\n\n    struct WithdrawInput {\n        address participant;\n        uint256 total_withdraw;\n        uint256 expiration_block;\n        bytes participant_signature;\n        bytes partner_signature;\n    }\n\n    struct SettlementData {\n        uint256 deposit;\n        uint256 withdrawn;\n        uint256 transferred;\n        uint256 locked;\n    }\n\n    struct UnlockData {\n        // keccak256 hash of the pending locks from the Raiden client\n        bytes32 locksroot;\n        // Total amount of tokens locked in the pending locks corresponding\n        // to the `locksroot`\n        uint256 locked_amount;\n    }\n\n    struct SettleInput {\n        address participant;\n        uint256 transferred_amount;\n        uint256 locked_amount;\n        bytes32 locksroot;\n    }\n\n    event ChannelOpened(\n        uint256 indexed channel_identifier,\n        address indexed participant1,\n        address indexed participant2,\n        uint256 settle_timeout\n    );\n\n    event ChannelNewDeposit(\n        uint256 indexed channel_identifier,\n        address indexed participant,\n        uint256 total_deposit\n    );\n\n    // Fires when the deprecation_switch's value changes\n    event DeprecationSwitch(bool new_value);\n\n    // total_withdraw is how much the participant has withdrawn during the\n    // lifetime of the channel. The actual amount which the participant withdrew\n    // is `total_withdraw - total_withdraw_from_previous_event_or_zero`\n    event ChannelWithdraw(\n        uint256 indexed channel_identifier,\n        address indexed participant,\n        uint256 total_withdraw\n    );\n\n    event ChannelClosed(\n        uint256 indexed channel_identifier,\n        address indexed closing_participant,\n        uint256 indexed nonce,\n        bytes32 balance_hash\n    );\n\n    event ChannelUnlocked(\n        uint256 indexed channel_identifier,\n        address indexed receiver,\n        address indexed sender,\n        bytes32 locksroot,\n        uint256 unlocked_amount,\n        uint256 returned_tokens\n    );\n\n    event NonClosingBalanceProofUpdated(\n        uint256 indexed channel_identifier,\n        address indexed closing_participant,\n        uint256 indexed nonce,\n        bytes32 balance_hash\n    );\n\n    event ChannelSettled(\n        uint256 indexed channel_identifier,\n        address participant1,\n        uint256 participant1_amount,\n        bytes32 participant1_locksroot,\n        address participant2,\n        uint256 participant2_amount,\n        bytes32 participant2_locksroot\n    );\n\n    modifier isSafe() {\n        require(safety_deprecation_switch == false, \"TN: network is deprecated\");\n        _;\n    }\n\n    modifier isOpen(uint256 channel_identifier) {\n        require(channels[channel_identifier].state == ChannelState.Opened, \"TN: channel not open\");\n        _;\n    }\n\n    modifier settleTimeoutValid(uint256 timeout) {\n        require(timeout >= settlement_timeout_min, \"TN: settle timeout < min\");\n        require(timeout <= settlement_timeout_max, \"TN: settle timeout > max\");\n        _;\n    }\n\n    /// @param _token_address The address of the ERC20 token contract\n    /// @param _secret_registry The address of SecretRegistry contract that witnesses the onchain secret reveals\n    /// @param _settlement_timeout_min The shortest settlement period (in number of blocks)\n    /// that can be chosen at the channel opening\n    /// @param _settlement_timeout_max The longest settlement period (in number of blocks)\n    /// that can be chosen at the channel opening\n    /// @param _controller The Ethereum address that can disable new deposits and channel creation\n    /// @param _channel_participant_deposit_limit The maximum amount of tokens that can be deposited by each\n    /// participant of each channel. MAX_SAFE_UINT256 means no limits\n    /// @param _token_network_deposit_limit The maximum amount of tokens that this contract can hold\n    /// MAX_SAFE_UINT256 means no limits\n    constructor(\n        address _token_address,\n        address _secret_registry,\n        uint256 _settlement_timeout_min,\n        uint256 _settlement_timeout_max,\n        address _controller,\n        uint256 _channel_participant_deposit_limit,\n        uint256 _token_network_deposit_limit\n    ) {\n        require(_token_address != address(0x0), \"TN: invalid token address\");\n        require(_secret_registry != address(0x0), \"TN: invalid SR address\");\n        require(_controller != address(0x0), \"TN: invalid controller address\");\n        require(_settlement_timeout_min > 0, \"TN: invalid settle timeout min\");\n        require(_settlement_timeout_max > _settlement_timeout_min, \"TN: invalid settle timeouts\");\n        require(contractExists(_token_address), \"TN: invalid token contract\");\n        require(contractExists(_secret_registry), \"TN: invalid SR contract\");\n        require(_channel_participant_deposit_limit > 0, \"TN: invalid participant limit\");\n        require(_token_network_deposit_limit > 0, \"TN: invalid network deposit limit\");\n        require(_token_network_deposit_limit >= _channel_participant_deposit_limit, \"TN: invalid deposit limits\");\n\n        token = Token(_token_address);\n\n        secret_registry = SecretRegistry(_secret_registry);\n        settlement_timeout_min = _settlement_timeout_min;\n        settlement_timeout_max = _settlement_timeout_max;\n\n        // Make sure the contract is indeed a token contract\n        require(token.totalSupply() > 0, \"TN: no supply for token\");\n\n        controller = _controller;\n        channel_participant_deposit_limit = _channel_participant_deposit_limit;\n        token_network_deposit_limit = _token_network_deposit_limit;\n    }\n\n    function deprecate() public isSafe onlyController {\n        safety_deprecation_switch = true;\n        emit DeprecationSwitch(safety_deprecation_switch);\n    }\n\n    /// @notice Opens a new channel between `participant1` and `participant2`.\n    /// Can be called by anyone\n    /// @param participant1 Ethereum address of a channel participant\n    /// @param participant2 Ethereum address of the other channel participant\n    /// @param settle_timeout Number of blocks that need to be mined between a\n    /// call to closeChannel and settleChannel\n    function openChannel(address participant1, address participant2, uint256 settle_timeout)\n        public\n        isSafe\n        settleTimeoutValid(settle_timeout)\n        returns (uint256)\n    {\n        bytes32 pair_hash;\n        uint256 channel_identifier;\n\n        // Red Eyes release token network limit\n        require(token.balanceOf(address(this)) < token_network_deposit_limit, \"TN/open: network deposit limit reached\");\n\n        // First increment the counter\n        // There will never be a channel with channel_identifier == 0\n        channel_counter += 1;\n        channel_identifier = channel_counter;\n\n        pair_hash = getParticipantsHash(participant1, participant2);\n\n        // There must only be one channel opened between two participants at\n        // any moment in time.\n        require(participants_hash_to_channel_identifier[pair_hash] == 0, \"TN/open: channel exists for participants\");\n        participants_hash_to_channel_identifier[pair_hash] = channel_identifier;\n\n        Channel storage channel = channels[channel_identifier];\n\n        // We always increase the channel counter, therefore no channel data can already exist,\n        // corresponding to this channel_identifier. This check must never fail.\n        assert(channel.settle_block_number == 0);\n        assert(channel.state == ChannelState.NonExistent);\n\n        // Store channel information\n        channel.settle_block_number = settle_timeout;\n        channel.state = ChannelState.Opened;\n\n        emit ChannelOpened(\n            channel_identifier,\n            participant1,\n            participant2,\n            settle_timeout\n        );\n\n        return channel_identifier;\n    }\n\n    /// @notice Opens a new channel between `participant1` and `participant2`\n    /// and deposits for `participant1`. Can be called by anyone\n    /// @param participant1 Ethereum address of a channel participant\n    /// @param participant2 Ethereum address of the other channel participant\n    /// @param settle_timeout Number of blocks that need to be mined between a\n    /// call to closeChannel and settleChannel\n    /// @param participant1_total_deposit The total amount of tokens that\n    /// `participant1` will have as deposit\n    function openChannelWithDeposit(\n        address participant1,\n        address participant2,\n        uint256 settle_timeout,\n        uint256 participant1_total_deposit\n    )\n        public\n        isSafe\n        settleTimeoutValid(settle_timeout)\n        returns (uint256)\n    {\n        uint256 channel_identifier;\n\n        channel_identifier = openChannel(participant1, participant2, settle_timeout);\n        setTotalDepositFor(\n            channel_identifier,\n            participant1,\n            participant1_total_deposit,\n            participant2,\n            msg.sender\n        );\n\n        return channel_identifier;\n    }\n\n    /// @notice Sets the channel participant total deposit value.\n    /// Can be called by anyone.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param participant Channel participant whose deposit is being set\n    /// @param total_deposit The total amount of tokens that the participant\n    /// will have as a deposit\n    /// @param partner Channel partner address, needed to compute the total\n    /// channel deposit\n    function setTotalDeposit(\n        uint256 channel_identifier,\n        address participant,\n        uint256 total_deposit,\n        address partner\n    )\n        public\n        isSafe\n        isOpen(channel_identifier)\n    {\n        setTotalDepositFor(\n            channel_identifier,\n            participant,\n            total_deposit,\n            partner,\n            msg.sender\n        );\n    }\n\n    /// @notice Allows `participant` to withdraw tokens from the channel that he\n    /// has with `partner`, without closing it. Can be called by anyone. Can\n    /// only be called once per each signed withdraw message\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param participant Channel participant, who will receive the withdrawn\n    /// amount\n    /// @param total_withdraw Total amount of tokens that are marked as\n    /// withdrawn from the channel during the channel lifecycle\n    /// @param participant_signature Participant's signature on the withdraw\n    /// data\n    /// @param partner_signature Partner's signature on the withdraw data\n    function setTotalWithdraw(\n        uint256 channel_identifier,\n        address participant,\n        uint256 total_withdraw,\n        uint256 expiration_block,\n        bytes calldata participant_signature,\n        bytes calldata partner_signature\n    )\n        external\n        isOpen(channel_identifier)\n    {\n        this.setTotalWithdraw2(\n            channel_identifier,\n            WithdrawInput({\n                participant: participant,\n                total_withdraw: total_withdraw,\n                expiration_block: expiration_block,\n                participant_signature: participant_signature,\n                partner_signature: partner_signature\n            })\n        );\n    }\n\n    function setTotalWithdraw2(\n        uint256 channel_identifier,\n        WithdrawInput memory withdraw_data\n    )\n        external\n        isOpen(channel_identifier)\n    {\n        uint256 total_deposit;\n        uint256 current_withdraw;\n        address partner;\n\n        require(withdraw_data.total_withdraw > 0, \"TN/withdraw: total withdraw is zero\");\n        require(block.number < withdraw_data.expiration_block, \"TN/withdraw: expired\");\n\n        // Authenticate both channel partners via their signatures.\n        // `participant` is a part of the signed message, so given in the calldata.\n        require(withdraw_data.participant == recoverAddressFromWithdrawMessage(\n            channel_identifier,\n            withdraw_data.participant,\n            withdraw_data.total_withdraw,\n            withdraw_data.expiration_block,\n            withdraw_data.participant_signature\n        ), \"TN/withdraw: invalid participant sig\");\n        partner = recoverAddressFromWithdrawMessage(\n            channel_identifier,\n            withdraw_data.participant,\n            withdraw_data.total_withdraw,\n            withdraw_data.expiration_block,\n            withdraw_data.partner_signature\n        );\n\n        // Validate that authenticated partners and the channel identifier match\n        require(\n            channel_identifier == getChannelIdentifier(withdraw_data.participant, partner),\n            \"TN/withdraw: channel id mismatch\"\n        );\n\n        // Read channel state after validating the function input\n        Channel storage channel = channels[channel_identifier];\n        Participant storage participant_state = channel.participants[withdraw_data.participant];\n        Participant storage partner_state = channel.participants[partner];\n\n        total_deposit = participant_state.deposit + partner_state.deposit;\n\n        // Entire withdrawn amount must not be bigger than the current channel deposit\n        require(\n            (withdraw_data.total_withdraw + partner_state.withdrawn_amount) <= total_deposit,\n            \"TN/withdraw: withdraw > deposit\"\n        );\n        require(\n            withdraw_data.total_withdraw <= (withdraw_data.total_withdraw + partner_state.withdrawn_amount),\n            \"TN/withdraw: overflow\"\n        );\n\n        // Using the total_withdraw (monotonically increasing) in the signed\n        // message ensures that we do not allow replay attack to happen, by\n        // using the same withdraw proof twice.\n        // Next two lines enforce the monotonicity of total_withdraw and check for an underflow:\n        // (we use <= because current_withdraw == total_withdraw for the first withdraw)\n        current_withdraw = withdraw_data.total_withdraw - participant_state.withdrawn_amount;\n        require(current_withdraw <= withdraw_data.total_withdraw, \"TN/withdraw: underflow\");\n\n        // The actual amount of tokens that will be transferred must be > 0 to disable the reuse of\n        // withdraw messages completely.\n        require(current_withdraw > 0, \"TN/withdraw: amount is zero\");\n\n        // This should never fail at this point. Added check for security, because we directly set\n        // the participant_state.withdrawn_amount = total_withdraw,\n        // while we transfer `current_withdraw` tokens.\n        assert(participant_state.withdrawn_amount + current_withdraw == withdraw_data.total_withdraw);\n\n        emit ChannelWithdraw(\n            channel_identifier,\n            withdraw_data.participant,\n            withdraw_data.total_withdraw\n        );\n\n        // Do the state change and tokens transfer\n        participant_state.withdrawn_amount = withdraw_data.total_withdraw;\n        require(token.transfer(withdraw_data.participant, current_withdraw), \"TN/withdraw: transfer failed\");\n\n        // This should never happen, as we have an overflow check in setTotalDeposit\n        assert(total_deposit >= participant_state.deposit);\n        assert(total_deposit >= partner_state.deposit);\n\n        // A withdraw should never happen if a participant already has a\n        // balance proof in storage. This should never fail as we use isOpen.\n        assert(participant_state.nonce == 0);\n        assert(partner_state.nonce == 0);\n    }\n\n    /// @notice Cooperatively settles the balances between the two channel\n    /// participants and transfers the agreed upon token amounts to the\n    /// participants. After this the channel lifecycle has ended and no more\n    /// operations can be done on it.\n    /// An important constraint is that this function checks that all tokens\n    /// in this channel are withdrawn. This means that the channel can *not*\n    /// have any outstanding locked transfers.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param data1 Withdraw data of the first participant\n    /// @param data2 Withdraw data of the second participant\n    function cooperativeSettle(\n        uint256 channel_identifier,\n        WithdrawInput memory data1,\n        WithdrawInput memory data2\n    )\n        external\n        isOpen(channel_identifier)\n    {\n        uint256 total_deposit;\n\n        // Validate that authenticated partners and the channel identifier match\n        require(\n            channel_identifier == getChannelIdentifier(data1.participant, data2.participant),\n            \"TN/coopSettle: channel id mismatch\"\n        );\n        Channel storage channel = channels[channel_identifier];\n\n        Participant storage participant1_state = channel.participants[data1.participant];\n        Participant storage participant2_state = channel.participants[data2.participant];\n        total_deposit = participant1_state.deposit + participant2_state.deposit;\n\n        // The sum of the provided balances must be equal to the total\n        // available deposit. This also implies that no locks must exist in the channel\n        // when this is called, as otherwise the withdrawable amount would be smaller\n        // than required.\n        require((data1.total_withdraw + data2.total_withdraw) == total_deposit, \"TN/coopSettle: incomplete amounts\");\n        // Overflow check for the balances addition from the above check.\n        // This overflow should never happen if the token.transfer function is implemented\n        // correctly. We do not control the token implementation, therefore we add this\n        // check for safety.\n        require(data1.total_withdraw <= data1.total_withdraw + data2.total_withdraw, \"TN/coopSettle: overflow\");\n\n        if (data1.total_withdraw > 0) {\n            this.setTotalWithdraw2(\n                channel_identifier,\n                data1\n            );\n        }\n        if (data2.total_withdraw > 0) {\n            this.setTotalWithdraw2(\n                channel_identifier,\n                data2\n            );\n        }\n        removeChannelData(channel, channel_identifier, data1.participant, data2.participant);\n\n        emit ChannelSettled(\n            channel_identifier,\n            data1.participant,\n            data1.total_withdraw,\n            0,\n            data2.participant,\n            data2.total_withdraw,\n            0\n        );\n    }\n\n    /// @notice Close the channel defined by the two participant addresses.\n    /// Anybody can call this function on behalf of a participant (called\n    /// the closing participant), providing a balance proof signed by\n    /// both parties. Callable only once\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param closing_participant Channel participant who closes the channel\n    /// @param non_closing_participant Channel partner of the `closing_participant`,\n    /// who provided the balance proof\n    /// @param balance_hash Hash of (transferred_amount, locked_amount,\n    /// locksroot)\n    /// @param additional_hash Computed from the message. Used for message\n    /// authentication\n    /// @param nonce Strictly monotonic value used to order transfers\n    /// @param non_closing_signature Non-closing participant's signature of the balance proof data\n    /// @param closing_signature Closing participant's signature of the balance\n    /// proof data\n    function closeChannel(\n        uint256 channel_identifier,\n        address non_closing_participant,\n        address closing_participant,\n        // The next four arguments form a balance proof.\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes memory non_closing_signature,\n        bytes memory closing_signature\n    )\n        public\n        isOpen(channel_identifier)\n    {\n        require(\n            channel_identifier == getChannelIdentifier(closing_participant, non_closing_participant),\n            \"TN/close: channel id mismatch\"\n        );\n\n        address recovered_non_closing_participant_address;\n\n        Channel storage channel = channels[channel_identifier];\n\n        channel.state = ChannelState.Closed;\n        channel.participants[closing_participant].is_the_closer = true;\n\n        // This is the block number at which the channel can be settled.\n        channel.settle_block_number += uint256(block.number);\n\n        // The closing participant must have signed the balance proof.\n        address recovered_closing_participant_address = recoverAddressFromBalanceProofCounterSignature(\n            MessageType.MessageTypeId.BalanceProof,\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash,\n            non_closing_signature,\n            closing_signature\n        );\n        require(closing_participant == recovered_closing_participant_address, \"TN/close: invalid closing sig\");\n\n        // Nonce 0 means that the closer never received a transfer, therefore\n        // never received a balance proof, or he is intentionally not providing\n        // the latest transfer, in which case the closing party is going to\n        // lose the tokens that were transferred to him.\n        if (nonce > 0) {\n            recovered_non_closing_participant_address = recoverAddressFromBalanceProof(\n                channel_identifier,\n                balance_hash,\n                nonce,\n                additional_hash,\n                non_closing_signature\n            );\n            // Signature must be from the channel partner\n            require(\n                non_closing_participant == recovered_non_closing_participant_address,\n                \"TN/close: invalid non-closing sig\"\n            );\n\n            updateBalanceProofData(\n                channel,\n                recovered_non_closing_participant_address,\n                nonce,\n                balance_hash\n            );\n        }\n\n        emit ChannelClosed(channel_identifier, closing_participant, nonce, balance_hash);\n    }\n\n    /// @notice Called on a closed channel, the function allows the non-closing\n    /// participant to provide the last balance proof, which modifies the\n    /// closing participant's state. Can be called multiple times by anyone.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param closing_participant Channel participant who closed the channel\n    /// @param non_closing_participant Channel participant who needs to update\n    /// the balance proof\n    /// @param balance_hash Hash of (transferred_amount, locked_amount,\n    /// locksroot)\n    /// @param additional_hash Computed from the message. Used for message\n    /// authentication\n    /// @param nonce Strictly monotonic value used to order transfers\n    /// @param closing_signature Closing participant's signature of the balance\n    /// proof data\n    /// @param non_closing_signature Non-closing participant signature of the\n    /// balance proof data\n    function updateNonClosingBalanceProof(\n        uint256 channel_identifier,\n        address closing_participant,\n        address non_closing_participant,\n        // The next four arguments form a balance proof\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes calldata closing_signature,\n        bytes calldata non_closing_signature\n    )\n        external\n    {\n        require(\n            channel_identifier == getChannelIdentifier(closing_participant,non_closing_participant),\n             \"TN/update: channel id mismatch\"\n        );\n        require(balance_hash != bytes32(0x0), \"TN/update: balance hash is zero\");\n        require(nonce > 0, \"TN/update: nonce is zero\");\n\n        address recovered_non_closing_participant;\n        address recovered_closing_participant;\n\n        Channel storage channel = channels[channel_identifier];\n\n        require(channel.state == ChannelState.Closed, \"TN/update: channel not closed\");\n\n        // We need the signature from the non-closing participant to allow\n        // anyone to make this transaction. E.g. a monitoring service.\n        recovered_non_closing_participant = recoverAddressFromBalanceProofCounterSignature(\n            MessageType.MessageTypeId.BalanceProofUpdate,\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash,\n            closing_signature,\n            non_closing_signature\n        );\n        require(non_closing_participant == recovered_non_closing_participant, \"TN/update: invalid non-closing sig\");\n\n        recovered_closing_participant = recoverAddressFromBalanceProof(\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash,\n            closing_signature\n        );\n        require(closing_participant == recovered_closing_participant, \"TN/update: invalid closing sig\");\n\n        Participant storage closing_participant_state = channel.participants[closing_participant];\n        // Make sure the first signature is from the closing participant\n        require(closing_participant_state.is_the_closer, \"TN/update: incorrect signature order\");\n\n        // Update the balance proof data for the closing_participant\n        updateBalanceProofData(channel, closing_participant, nonce, balance_hash);\n\n        emit NonClosingBalanceProofUpdated(\n            channel_identifier,\n            closing_participant,\n            nonce,\n            balance_hash\n        );\n    }\n\n    /// @notice Settles the balance between the two parties. Note that arguments\n    /// order counts: `participant1_transferred_amount +\n    /// participant1_locked_amount` <= `participant2_transferred_amount +\n    /// participant2_locked_amount`\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param participant1 Channel participant\n    /// @param participant1_transferred_amount The latest known amount of tokens\n    /// transferred from `participant1` to `participant2`\n    /// @param participant1_locked_amount Amount of tokens owed by\n    /// `participant1` to `participant2`, contained in locked transfers that\n    /// will be retrieved by calling `unlock` after the channel is settled\n    /// @param participant1_locksroot The latest known hash of the\n    /// pending hash-time locks of `participant1`, used to validate the unlocked\n    /// proofs. If no balance_hash has been submitted, locksroot is ignored\n    /// @param participant2 Other channel participant\n    /// @param participant2_transferred_amount The latest known amount of tokens\n    /// transferred from `participant2` to `participant1`\n    /// @param participant2_locked_amount Amount of tokens owed by\n    /// `participant2` to `participant1`, contained in locked transfers that\n    /// will be retrieved by calling `unlock` after the channel is settled\n    /// @param participant2_locksroot The latest known hash of the\n    /// pending hash-time locks of `participant2`, used to validate the unlocked\n    /// proofs. If no balance_hash has been submitted, locksroot is ignored\n    function settleChannel(\n        uint256 channel_identifier,\n        address participant1,\n        uint256 participant1_transferred_amount,\n        uint256 participant1_locked_amount,\n        bytes32 participant1_locksroot,\n        address participant2,\n        uint256 participant2_transferred_amount,\n        uint256 participant2_locked_amount,\n        bytes32 participant2_locksroot\n    )\n        public\n    {\n        settleChannel2(\n            channel_identifier,\n            SettleInput({\n                participant: participant1,\n                transferred_amount: participant1_transferred_amount,\n                locked_amount: participant1_locked_amount,\n                locksroot: participant1_locksroot\n            }),\n            SettleInput({\n                participant: participant2,\n                transferred_amount: participant2_transferred_amount,\n                locked_amount: participant2_locked_amount,\n                locksroot: participant2_locksroot\n            })\n        );\n    }\n\n    function settleChannel2(\n        uint256 channel_identifier,\n        SettleInput memory participant1_settlement,\n        SettleInput memory participant2_settlement\n    )\n        public\n    {\n        // There are several requirements that this function MUST enforce:\n        // - it MUST never fail; therefore, any overflows or underflows must be\n        // handled gracefully\n        // - it MUST ensure that if participants use the latest valid balance proofs,\n        // provided by the official Raiden client, the participants will be able\n        // to receive correct final balances at the end of the channel lifecycle\n        // - it MUST ensure that the participants cannot cheat by providing an\n        // old, valid balance proof of their partner; meaning that their partner MUST\n        // receive at least the amount of tokens that he would have received if\n        // the latest valid balance proofs are used.\n        // - the contract cannot determine if a balance proof is invalid (values\n        // are not within the constraints enforced by the official Raiden client),\n        // therefore it cannot ensure correctness. Users MUST use the official\n        // Raiden clients for signing balance proofs.\n\n        address participant1 = participant1_settlement.participant;\n        address participant2 = participant2_settlement.participant;\n        require(\n            channel_identifier == getChannelIdentifier(participant1, participant2),\n            \"TN/settle: channel id mismatch\"\n        );\n\n        Channel storage channel = channels[channel_identifier];\n\n        require(channel.state == ChannelState.Closed, \"TN/settle: channel not closed\");\n\n        // Settlement window must be over\n        require(channel.settle_block_number < block.number, \"TN/settle: settlement timeout\");\n\n        Participant storage participant1_state = channel.participants[participant1];\n        Participant storage participant2_state = channel.participants[participant2];\n\n        require(\n            verifyBalanceHashData(participant1_state, participant1_settlement),\n            \"TN/settle: invalid data for participant 1\"\n        );\n\n        require(\n            verifyBalanceHashData(participant2_state, participant2_settlement),\n            \"TN/settle: invalid data for participant 2\"\n        );\n\n        // We are calculating the final token amounts that need to be\n        // transferred to the participants now and the amount of tokens that\n        // need to remain locked in the contract. These tokens can be unlocked\n        // by calling `unlock`.\n        // participant1_transferred_amount = the amount of tokens that\n        //   participant1 will receive in this transaction.\n        // participant2_transferred_amount = the amount of tokens that\n        //   participant2 will receive in this transaction.\n        // participant1_locked_amount = the amount of tokens remaining in the\n        //   contract, representing pending transfers from participant1 to participant2.\n        // participant2_locked_amount = the amount of tokens remaining in the\n        //   contract, representing pending transfers from participant2 to participant1.\n        // We are reusing variables due to the local variables number limit.\n        // For better readability this can be refactored further.\n        (\n            participant1_settlement.transferred_amount,\n            participant2_settlement.transferred_amount,\n            participant1_settlement.locked_amount,\n            participant2_settlement.locked_amount\n        ) = getSettleTransferAmounts(\n            participant1_state,\n            participant1_settlement.transferred_amount,\n            participant1_settlement.locked_amount,\n            participant2_state,\n            participant2_settlement.transferred_amount,\n            participant2_settlement.locked_amount\n        );\n\n        removeChannelData(channel, channel_identifier, participant1, participant2);\n\n        // Store balance data needed for `unlock`, including the calculated\n        // locked amounts remaining in the contract.\n        storeUnlockData(\n            channel_identifier,\n            participant1_settlement,\n            participant2\n        );\n        storeUnlockData(\n            channel_identifier,\n            participant2_settlement,\n            participant1\n        );\n\n        emit ChannelSettled(\n            channel_identifier,\n            participant1,\n            participant1_settlement.transferred_amount,\n            participant1_settlement.locksroot,\n            participant2,\n            participant2_settlement.transferred_amount,\n            participant2_settlement.locksroot\n        );\n\n        // Do the actual token transfers\n        if (participant1_settlement.transferred_amount > 0) {\n            require(\n                token.transfer(participant1, participant1_settlement.transferred_amount),\n                \"TN/settle: transfer for participant 1 failed\"\n            );\n        }\n\n        if (participant2_settlement.transferred_amount > 0) {\n            require(\n                token.transfer(participant2, participant2_settlement.transferred_amount),\n                \"TN/settle: transfer for participant 2 failed\"\n            );\n        }\n    }\n\n    /// @notice Unlocks all pending off-chain transfers from `sender` to\n    /// `receiver` and sends the locked tokens corresponding to locks with\n    /// secrets registered on-chain to the `receiver`. Locked tokens\n    /// corresponding to locks where the secret was not revealed on-chain will\n    /// return to the `sender`. Anyone can call unlock.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param receiver Address who will receive the claimable unlocked\n    /// tokens\n    /// @param sender Address who sent the pending transfers and will receive\n    /// the unclaimable unlocked tokens\n    /// @param locks All pending locks concatenated in order of creation\n    /// that `sender` sent to `receiver`\n    function unlock(\n        uint256 channel_identifier,\n        address receiver,\n        address sender,\n        bytes memory locks\n    )\n        public\n    {\n        // Channel represented by channel_identifier must be settled and\n        // channel data deleted\n        require(\n            channel_identifier != getChannelIdentifier(receiver, sender),\n            \"TN/unlock: channel id still exists\"\n        );\n\n        // After the channel is settled the storage is cleared, therefore the\n        // value will be NonExistent and not Settled. The value Settled is used\n        // for the external APIs\n        require(\n            channels[channel_identifier].state == ChannelState.NonExistent,\n            \"TN/unlock: channel not settled\"\n        );\n\n        bytes32 unlock_key;\n        bytes32 computed_locksroot;\n        uint256 unlocked_amount;\n        uint256 locked_amount;\n        uint256 returned_tokens;\n\n        // Calculate the locksroot for the pending transfers and the amount of\n        // tokens corresponding to the locked transfers with secrets revealed\n        // on chain.\n        (computed_locksroot, unlocked_amount) = getHashAndUnlockedAmount(\n            locks\n        );\n\n        // The sender must have a non-empty locksroot on-chain that must be\n        // the same as the computed locksroot.\n        // Get the amount of tokens that have been left in the contract, to\n        // account for the pending transfers `sender` -> `receiver`.\n        unlock_key = getUnlockIdentifier(channel_identifier, sender, receiver);\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[unlock_key];\n        locked_amount = unlock_data.locked_amount;\n\n        // Locksroot must be the same as the computed locksroot\n        require(unlock_data.locksroot == computed_locksroot, \"TN/unlock: locksroot mismatch\");\n\n        // There are no pending transfers if the locked_amount is 0.\n        // Transaction must fail\n        require(locked_amount > 0, \"TN/unlock: zero locked amount\");\n\n        // Make sure we don't transfer more tokens than previously reserved in\n        // the smart contract.\n        unlocked_amount = min(unlocked_amount, locked_amount);\n\n        // Transfer the rest of the tokens back to the sender\n        returned_tokens = locked_amount - unlocked_amount;\n\n        // Remove sender's unlock data\n        delete unlock_identifier_to_unlock_data[unlock_key];\n\n        emit ChannelUnlocked(\n            channel_identifier,\n            receiver,\n            sender,\n            computed_locksroot,\n            unlocked_amount,\n            returned_tokens\n        );\n\n        // Transfer the unlocked tokens to the receiver. unlocked_amount can\n        // be 0\n        if (unlocked_amount > 0) {\n            require(token.transfer(receiver, unlocked_amount), \"TN/unlock: unlocked transfer failed\");\n        }\n\n        // Transfer the rest of the tokens back to the sender\n        if (returned_tokens > 0) {\n            require(token.transfer(sender, returned_tokens), \"TN/unlock: returned transfer failed\");\n        }\n\n        // At this point, this should always be true\n        assert(locked_amount >= returned_tokens);\n        assert(locked_amount >= unlocked_amount);\n    }\n\n    /// @notice Returns the unique identifier for the channel given by the\n    /// contract\n    /// @param participant Address of a channel participant\n    /// @param partner Address of the other channel participant\n    /// @return Unique identifier for the channel. It can be 0 if channel does\n    /// not exist\n    function getChannelIdentifier(address participant, address partner)\n        public\n        view\n        returns (uint256)\n    {\n        require(participant != address(0x0), \"TN: participant address zero\");\n        require(partner != address(0x0), \"TN: partner address zero\");\n        require(participant != partner, \"TN: identical addresses\");\n\n        bytes32 pair_hash = getParticipantsHash(participant, partner);\n        return participants_hash_to_channel_identifier[pair_hash];\n    }\n\n    /// @dev Returns the channel specific data.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param participant1 Address of a channel participant\n    /// @param participant2 Address of the other channel participant\n    /// @return Channel settle_block_number and state\n    /// @notice The contract cannot really distinguish Settled and Removed\n    /// states, especially when wrong participants are given as input.\n    /// The contract does not remember the participants of the channel\n    function getChannelInfo(\n        uint256 channel_identifier,\n        address participant1,\n        address participant2\n    )\n        external\n        view\n        returns (uint256, ChannelState)\n    {\n        bytes32 unlock_key1;\n        bytes32 unlock_key2;\n\n        Channel storage channel = channels[channel_identifier];\n        ChannelState state = channel.state;  // This must **not** update the storage\n\n        if (state == ChannelState.NonExistent &&\n            channel_identifier > 0 &&\n            channel_identifier <= channel_counter\n        ) {\n            // The channel has been settled, channel data is removed Therefore,\n            // the channel state in storage is actually `0`, or `NonExistent`\n            // However, for this view function, we return `Settled`, in order\n            // to provide a consistent external API\n            state = ChannelState.Settled;\n\n            // We might still have data stored for future unlock operations\n            // Only if we do not, we can consider the channel as `Removed`\n            unlock_key1 = getUnlockIdentifier(channel_identifier, participant1, participant2);\n            UnlockData storage unlock_data1 = unlock_identifier_to_unlock_data[unlock_key1];\n\n            unlock_key2 = getUnlockIdentifier(channel_identifier, participant2, participant1);\n            UnlockData storage unlock_data2 = unlock_identifier_to_unlock_data[unlock_key2];\n\n            if (unlock_data1.locked_amount == 0 && unlock_data2.locked_amount == 0) {\n                state = ChannelState.Removed;\n            }\n        }\n\n        return (\n            channel.settle_block_number,\n            state\n        );\n    }\n\n    /// @dev Returns the channel specific data.\n    /// @param channel_identifier Identifier for the channel on which this\n    /// operation takes place\n    /// @param participant Address of the channel participant whose data will be\n    /// returned\n    /// @param partner Address of the channel partner\n    /// @return Participant's deposit, withdrawn_amount, whether the participant\n    /// has called `closeChannel` or not, balance_hash, nonce, locksroot,\n    /// locked_amount\n    function getChannelParticipantInfo(\n            uint256 channel_identifier,\n            address participant,\n            address partner\n    )\n        external\n        view\n        returns (uint256, uint256, bool, bytes32, uint256, bytes32, uint256)\n    {\n        bytes32 unlock_key;\n\n        Participant storage participant_state = channels[channel_identifier].participants[\n            participant\n        ];\n        unlock_key = getUnlockIdentifier(channel_identifier, participant, partner);\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[unlock_key];\n\n        return (\n            participant_state.deposit,\n            participant_state.withdrawn_amount,\n            participant_state.is_the_closer,\n            participant_state.balance_hash,\n            participant_state.nonce,\n            unlock_data.locksroot,\n            unlock_data.locked_amount\n        );\n    }\n\n    /// @dev Get the hash of the participant addresses, ordered\n    /// lexicographically\n    /// @param participant Address of a channel participant\n    /// @param partner Address of the other channel participant\n    function getParticipantsHash(address participant, address partner)\n        public\n        pure\n        returns (bytes32)\n    {\n        require(participant != address(0x0), \"TN: participant address zero\");\n        require(partner != address(0x0), \"TN: partner address zero\");\n        require(participant != partner, \"TN: identical addresses\");\n\n        if (participant < partner) {\n            return keccak256(abi.encodePacked(participant, partner));\n        } else {\n            return keccak256(abi.encodePacked(partner, participant));\n        }\n    }\n\n    /// @dev Get the hash of the channel identifier and the participant\n    /// addresses (whose ordering matters). The hash might be useful for\n    /// the receiver to look up the appropriate UnlockData to claim\n    /// @param channel_identifier Identifier for the channel which the\n    /// UnlockData is about\n    /// @param sender Sender of the pending transfers that the UnlockData\n    /// represents\n    /// @param receiver Receiver of the pending transfers that the UnlockData\n    /// represents\n    function getUnlockIdentifier(\n        uint256 channel_identifier,\n        address sender,\n        address receiver\n    )\n        public\n        pure\n        returns (bytes32)\n    {\n        require(sender != receiver, \"TN: sender/receiver mismatch\");\n        return keccak256(abi.encodePacked(channel_identifier, sender, receiver));\n    }\n\n    function setTotalDepositFor(\n        uint256 channel_identifier,\n        address participant,\n        uint256 total_deposit,\n        address partner,\n        address token_owner\n    )\n        internal\n    {\n        require(channel_identifier == getChannelIdentifier(participant, partner), \"TN/deposit: channel id mismatch\");\n        require(total_deposit > 0, \"TN/deposit: total_deposit is zero\");\n        require(total_deposit <= channel_participant_deposit_limit, \"TN/deposit: deposit limit reached\");\n\n        uint256 added_deposit;\n        uint256 channel_deposit;\n\n        Channel storage channel = channels[channel_identifier];\n        Participant storage participant_state = channel.participants[participant];\n        Participant storage partner_state = channel.participants[partner];\n\n        unchecked {\n            // Calculate the actual amount of tokens that will be transferred\n            added_deposit = total_deposit - participant_state.deposit;\n\n            // The actual amount of tokens that will be transferred must be > 0\n            require(added_deposit > 0, \"TN/deposit: no deposit added\");\n\n            // Underflow check; we use <= because added_deposit == total_deposit for the first deposit\n            require(added_deposit <= total_deposit, \"TN/deposit: deposit underflow\");\n\n            // This should never fail at this point. Added check for security, because we directly set\n            // the participant_state.deposit = total_deposit, while we transfer `added_deposit` tokens\n            assert(participant_state.deposit + added_deposit == total_deposit);\n\n            // Red Eyes release token network limit\n            require(\n                token.balanceOf(address(this)) + added_deposit <= token_network_deposit_limit,\n                \"TN/deposit: network limit reached\"\n            );\n\n            // Update the participant's channel deposit\n            participant_state.deposit = total_deposit;\n\n            // Calculate the entire channel deposit, to avoid overflow\n            channel_deposit = participant_state.deposit + partner_state.deposit;\n            // Overflow check\n            require(channel_deposit >= participant_state.deposit, \"TN/deposit: deposit overflow\");\n        }\n\n        emit ChannelNewDeposit(\n            channel_identifier,\n            participant,\n            participant_state.deposit\n        );\n\n        // Do the transfer\n        require(token.transferFrom(token_owner, address(this), added_deposit), \"TN/deposit: transfer failed\");\n    }\n\n    function updateBalanceProofData(\n        Channel storage channel,\n        address participant,\n        uint256 nonce,\n        bytes32 balance_hash\n    )\n        internal\n    {\n        Participant storage participant_state = channel.participants[participant];\n\n        // Multiple calls to updateNonClosingBalanceProof can be made and we\n        // need to store the last known balance proof data.\n        // This line prevents Monitoring Services from getting rewards\n        // again and again using the same reward proof.\n        require(nonce > participant_state.nonce, \"TN: nonce reused\");\n\n        participant_state.nonce = nonce;\n        participant_state.balance_hash = balance_hash;\n    }\n\n    function storeUnlockData(\n        uint256 channel_identifier,\n        SettleInput memory settle_input,\n        address receiver\n    )\n        internal\n    {\n        // If there are transfers to unlock, store the locksroot and total\n        // amount of tokens\n        if (settle_input.locked_amount == 0) {\n            return;\n        }\n\n        bytes32 key = getUnlockIdentifier(channel_identifier, settle_input.participant, receiver);\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[key];\n        unlock_data.locksroot = settle_input.locksroot;\n        unlock_data.locked_amount = settle_input.locked_amount;\n    }\n\n    function getChannelAvailableDeposit(\n        Participant storage participant1_state,\n        Participant storage participant2_state\n    )\n        internal\n        view\n        returns (uint256 total_available_deposit)\n    {\n        total_available_deposit = (\n            participant1_state.deposit +\n            participant2_state.deposit -\n            participant1_state.withdrawn_amount -\n            participant2_state.withdrawn_amount\n        );\n    }\n\n    /// @dev Function that calculates the amount of tokens that the participants\n    /// will receive when calling settleChannel.\n    /// Check https://github.com/raiden-network/raiden-contracts/issues/188 for the settlement\n    /// algorithm analysis and explanations.\n    function getSettleTransferAmounts(\n        Participant storage participant1_state,\n        uint256 participant1_transferred_amount,\n        uint256 participant1_locked_amount,\n        Participant storage participant2_state,\n        uint256 participant2_transferred_amount,\n        uint256 participant2_locked_amount\n    )\n        private\n        view\n        returns (uint256, uint256, uint256, uint256)\n    {\n        // The scope of this function is to compute the settlement amounts that\n        // the two channel participants will receive when calling settleChannel\n        // and the locked amounts that remain in the contract, to account for\n        // the pending, not finalized transfers, that will be received by the\n        // participants when calling `unlock`.\n\n        // The amount of tokens that participant1 MUST receive at the end of\n        // the channel lifecycle (after settleChannel and unlock) is:\n        // B1 = D1 - W1 + T2 - T1 + Lc2 - Lc1\n\n        // The amount of tokens that participant2 MUST receive at the end of\n        // the channel lifecycle (after settleChannel and unlock) is:\n        // B2 = D2 - W2 + T1 - T2 + Lc1 - Lc2\n\n        // B1 + B2 = TAD = D1 + D2 - W1 - W2\n        // TAD = total available deposit at settlement time\n\n        // L1 = Lc1 + Lu1\n        // L2 = Lc2 + Lu2\n\n        // where:\n        // B1 = final balance of participant1 after the channel is removed\n        // D1 = total amount deposited by participant1 into the channel\n        // W1 = total amount withdrawn by participant1 from the channel\n        // T2 = total amount transferred by participant2 to participant1 (finalized transfers)\n        // T1 = total amount transferred by participant1 to participant2 (finalized transfers)\n        // L1 = total amount of tokens locked in pending transfers, sent by\n        //   participant1 to participant2\n        // L2 = total amount of tokens locked in pending transfers, sent by\n        //   participant2 to participant1\n        // Lc2 = the amount that can be claimed by participant1 from the pending\n        //   transfers (that have not been finalized off-chain), sent by\n        //   participant2 to participant1. These are part of the locked amount\n        //   value from participant2's balance proof. They are considered claimed\n        //   if the secret corresponding to these locked transfers was registered\n        //   on-chain, in the SecretRegistry contract, before the lock's expiration.\n        // Lu1 = unclaimable locked amount from L1\n        // Lc1 = the amount that can be claimed by participant2 from the pending\n        //   transfers (that have not been finalized off-chain),\n        //   sent by participant1 to participant2\n        // Lu2 = unclaimable locked amount from L2\n\n        // Notes:\n        // 1) The unclaimble tokens from a locked amount will return to the sender.\n        // At the time of calling settleChannel, the TokenNetwork contract does\n        // not know what locked amounts are claimable or unclaimable.\n        // 2) There are some Solidity constraints that make the calculations\n        // more difficult: attention to overflows and underflows, that MUST be\n        // handled without throwing.\n\n        // Cases that require attention:\n        // case1. If participant1 does NOT provide a balance proof or provides\n        // an old balance proof.  participant2_transferred_amount can be [0,\n        // real_participant2_transferred_amount) We MUST NOT punish\n        // participant2.\n        // case2. If participant2 does NOT provide a balance proof or provides\n        // an old balance proof.  participant1_transferred_amount can be [0,\n        // real_participant1_transferred_amount) We MUST NOT punish\n        // participant1.\n        // case3. If neither participants provide a balance proof, we just\n        // subtract their withdrawn amounts from their deposits.\n\n        // This is why, the algorithm implemented in Solidity is:\n        // (explained at each step, below)\n        // RmaxP1 = (T2 + L2) - (T1 + L1) + D1 - W1\n        // RmaxP1 = min(TAD, RmaxP1)\n        // RmaxP2 = TAD - RmaxP1\n        // SL2 = min(RmaxP1, L2)\n        // S1 = RmaxP1 - SL2\n        // SL1 = min(RmaxP2, L1)\n        // S2 = RmaxP2 - SL1\n\n        // where:\n        // RmaxP1 = due to possible over/underflows that only appear when using\n        //    old balance proofs & the fact that settlement balance calculation\n        //    is symmetric (we can calculate either RmaxP1 and RmaxP2 first,\n        //    order does not affect result), this is a convention used to determine\n        //    the maximum receivable amount of participant1 at settlement time\n        // S1 = amount received by participant1 when calling settleChannel\n        // SL1 = the maximum amount from L1 that can be locked in the\n        //   TokenNetwork contract when calling settleChannel (due to overflows\n        //   that only happen when using old balance proofs)\n        // S2 = amount received by participant2 when calling settleChannel\n        // SL2 = the maximum amount from L2 that can be locked in the\n        //   TokenNetwork contract when calling settleChannel (due to overflows\n        //   that only happen when using old balance proofs)\n\n        uint256 participant1_amount;\n        uint256 participant2_amount;\n        uint256 total_available_deposit;\n\n        SettlementData memory participant1_settlement;\n        SettlementData memory participant2_settlement;\n\n        participant1_settlement.deposit = participant1_state.deposit;\n        participant1_settlement.withdrawn = participant1_state.withdrawn_amount;\n        participant1_settlement.transferred = participant1_transferred_amount;\n        participant1_settlement.locked = participant1_locked_amount;\n\n        participant2_settlement.deposit = participant2_state.deposit;\n        participant2_settlement.withdrawn = participant2_state.withdrawn_amount;\n        participant2_settlement.transferred = participant2_transferred_amount;\n        participant2_settlement.locked = participant2_locked_amount;\n\n        // TAD = D1 + D2 - W1 - W2 = total available deposit at settlement time\n        total_available_deposit = getChannelAvailableDeposit(\n            participant1_state,\n            participant2_state\n        );\n\n        // RmaxP1 = (T2 + L2) - (T1 + L1) + D1 - W1\n        // This amount is the maximum possible amount that participant1 can\n        // receive at settlement time and also contains the entire locked amount\n        //  of the pending transfers from participant2 to participant1.\n        participant1_amount = getMaxPossibleReceivableAmount(\n            participant1_settlement.deposit,\n            participant1_settlement.withdrawn,\n            participant1_settlement.transferred,\n            participant1_settlement.locked,\n            participant2_settlement.transferred,\n            participant2_settlement.locked\n        );\n\n        // RmaxP1 = min(TAD, RmaxP1)\n        // We need to bound this to the available channel deposit in order to\n        // not send tokens from other channels. The only case where TAD is\n        // smaller than RmaxP1 is when at least one balance proof is old.\n        participant1_amount = min(participant1_amount, total_available_deposit);\n\n        // RmaxP2 = TAD - RmaxP1\n        // Now it is safe to subtract without underflow\n        participant2_amount = total_available_deposit - participant1_amount;\n\n        // SL2 = min(RmaxP1, L2)\n        // S1 = RmaxP1 - SL2\n        // Both operations are done by failsafe_subtract\n        // We take out participant2's pending transfers locked amount, bounding\n        // it by the maximum receivable amount of participant1\n        (participant1_amount, participant2_locked_amount) = failsafe_subtract(\n            participant1_amount,\n            participant2_locked_amount\n        );\n\n        // SL1 = min(RmaxP2, L1)\n        // S2 = RmaxP2 - SL1\n        // Both operations are done by failsafe_subtract\n        // We take out participant1's pending transfers locked amount, bounding\n        // it by the maximum receivable amount of participant2\n        (participant2_amount, participant1_locked_amount) = failsafe_subtract(\n            participant2_amount,\n            participant1_locked_amount\n        );\n\n        // This should never throw:\n        // S1 and S2 MUST be smaller than TAD\n        assert(participant1_amount <= total_available_deposit);\n        assert(participant2_amount <= total_available_deposit);\n        // S1 + S2 + SL1 + SL2 == TAD\n        assert(total_available_deposit == (\n            participant1_amount +\n            participant2_amount +\n            participant1_locked_amount +\n            participant2_locked_amount\n        ));\n\n        return (\n            participant1_amount,\n            participant2_amount,\n            participant1_locked_amount,\n            participant2_locked_amount\n        );\n    }\n\n    function verifyBalanceHashData(\n        Participant storage participant,\n        SettleInput memory settle_input\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // When no balance proof has been provided, we need to check this\n        // separately because hashing values of 0 outputs a value != 0\n        if (participant.balance_hash == 0 &&\n            settle_input.transferred_amount == 0 &&\n            settle_input.locked_amount == 0\n            /* locksroot is ignored. */\n        ) {\n            return true;\n        }\n\n        // Make sure the hash of the provided state is the same as the stored\n        // balance_hash\n        return participant.balance_hash == keccak256(abi.encodePacked(\n            settle_input.transferred_amount,\n            settle_input.locked_amount,\n            settle_input.locksroot\n        ));\n    }\n\n    /// @dev Calculates the hash of the pending transfers data and\n    /// calculates the amount of tokens that can be unlocked because the secret\n    /// was registered on-chain.\n    function getHashAndUnlockedAmount(bytes memory locks)\n        internal\n        view\n        returns (bytes32, uint256)\n    {\n        uint256 length = locks.length;\n\n        // each lock has this form:\n        // (locked_amount || expiration_block || secrethash) = 3 * 32 bytes\n        require(length % 96 == 0, \"TN: invalid locks size\");\n\n        uint256 i;\n        uint256 total_unlocked_amount;\n        uint256 unlocked_amount;\n        bytes32 total_hash;\n\n        for (i = 32; i < length; i += 96) {\n            unlocked_amount = getLockedAmountFromLock(locks, i);\n            total_unlocked_amount += unlocked_amount;\n        }\n\n        total_hash = keccak256(locks);\n\n        return (total_hash, total_unlocked_amount);\n    }\n\n    function getLockedAmountFromLock(bytes memory locks, uint256 offset)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 expiration_block;\n        uint256 locked_amount;\n        uint256 reveal_block;\n        bytes32 secrethash;\n\n        if (locks.length <= offset) {\n            return 0;\n        }\n\n        assembly { // solium-disable-line security/no-inline-assembly\n            expiration_block := mload(add(locks, offset))\n            locked_amount := mload(add(locks, add(offset, 32)))\n            secrethash := mload(add(locks, add(offset, 64)))\n        }\n\n        // Check if the lock's secret was revealed in the SecretRegistry The\n        // secret must have been revealed in the SecretRegistry contract before\n        // the lock's expiration_block in order for the hash time lock transfer\n        // to be successful.\n        reveal_block = secret_registry.getSecretRevealBlockHeight(secrethash);\n        if (reveal_block == 0 || expiration_block <= reveal_block) {\n            locked_amount = 0;\n        }\n\n        return locked_amount;\n    }\n\n    function removeChannelData(Channel storage channel, uint256 channel_identifier, address participant1, address participant2)\n        internal\n    {\n        bytes32 pair_hash;\n\n        // Remove channel data from storage\n        delete channel.participants[participant1];\n        delete channel.participants[participant2];\n        delete channels[channel_identifier];\n\n        // Remove the pair's channel counter\n        pair_hash = getParticipantsHash(participant1, participant2);\n        delete participants_hash_to_channel_identifier[pair_hash];\n    }\n\n    function recoverAddressFromBalanceProof(\n        uint256 channel_identifier,\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes memory signature\n    )\n        internal\n        view\n        returns (address signature_address)\n    {\n        // Length of the actual message: 20 + 32 + 32 + 32 + 32 + 32 + 32\n        string memory message_length = \"212\";\n\n        bytes32 message_hash = keccak256(abi.encodePacked(\n            signature_prefix,\n            message_length,\n            address(this),\n            block.chainid,\n            uint256(MessageType.MessageTypeId.BalanceProof),\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash\n        ));\n\n        signature_address = ECVerify.ecverify(message_hash, signature);\n    }\n\n    function recoverAddressFromBalanceProofCounterSignature(\n        MessageType.MessageTypeId message_type_id,\n        uint256 channel_identifier,\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes memory closing_signature,\n        bytes memory non_closing_signature\n    )\n        internal\n        view\n        returns (address signature_address)\n    {\n        // Length of the actual message: 20 + 32 + 32 + 32 + 32 + 32 + 32 + 65\n        string memory message_prefix = \"\\x19Ethereum Signed Message:\\n277\";\n\n        bytes32 message_hash = keccak256(abi.encodePacked(\n            message_prefix,\n            address(this),\n            block.chainid,\n            uint256(message_type_id),\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash,\n            closing_signature\n        ));\n\n        signature_address = ECVerify.ecverify(message_hash, non_closing_signature);\n    }\n\n    function recoverAddressFromWithdrawMessage(\n        uint256 channel_identifier,\n        address participant,\n        uint256 total_withdraw,\n        uint256 expiration_block,\n        bytes memory signature\n    )\n        internal\n        view\n        returns (address signature_address)\n    {\n        // Length of the actual message: 20 + 32 + 32 + 32 + 20 + 32 + 32\n        string memory message_length = \"200\";\n\n        bytes32 message_hash = keccak256(abi.encodePacked(\n            signature_prefix,\n            message_length,\n            address(this),\n            block.chainid,\n            uint256(MessageType.MessageTypeId.Withdraw),\n            channel_identifier,\n            participant,\n            total_withdraw,\n            expiration_block\n        ));\n\n        signature_address = ECVerify.ecverify(message_hash, signature);\n    }\n\n    function getMaxPossibleReceivableAmount(\n        uint256 participant1_deposit,\n        uint256 participant1_withdrawn,\n        uint256 participant1_transferred,\n        uint256 participant1_locked,\n        uint256 participant2_transferred,\n        uint256 participant2_locked\n    )\n        public\n        pure\n        returns (uint256)\n    {\n        uint256 participant1_max_transferred;\n        uint256 participant2_max_transferred;\n        uint256 participant1_net_max_received;\n        uint256 participant1_max_amount;\n\n        // This is the maximum possible amount that participant1 could transfer\n        // to participant2, if all the pending lock secrets have been\n        // registered\n        participant1_max_transferred = failsafe_addition(\n            participant1_transferred,\n            participant1_locked\n        );\n\n        // This is the maximum possible amount that participant2 could transfer\n        // to participant1, if all the pending lock secrets have been\n        // registered\n        participant2_max_transferred = failsafe_addition(\n            participant2_transferred,\n            participant2_locked\n        );\n\n        // We enforce this check artificially, in order to get rid of hard\n        // to deal with over/underflows. Settlement balance calculation is\n        // symmetric (we can calculate either RmaxP1 and RmaxP2 first, order does\n        // not affect result). This means settleChannel must be called with\n        // ordered values.\n        require(participant2_max_transferred >= participant1_max_transferred, \"TN: transfers not ordered\");\n\n        assert(participant1_max_transferred >= participant1_transferred);\n        assert(participant2_max_transferred >= participant2_transferred);\n\n        // This is the maximum amount that participant1 can receive at settlement time\n        participant1_net_max_received = (\n            participant2_max_transferred -\n            participant1_max_transferred\n        );\n\n        // Next, we add the participant1's deposit and subtract the already\n        // withdrawn amount\n        participant1_max_amount = failsafe_addition(\n            participant1_net_max_received,\n            participant1_deposit\n        );\n\n        // Subtract already withdrawn amount\n        (participant1_max_amount, ) = failsafe_subtract(\n            participant1_max_amount,\n            participant1_withdrawn\n        );\n        return participant1_max_amount;\n    }\n\n    /// @notice Removes the balance limits.\n    /// Can only be called by the controller.\n    function removeLimits()\n        external\n        onlyController\n    {\n        channel_participant_deposit_limit = MAX_SAFE_UINT256;\n        token_network_deposit_limit = MAX_SAFE_UINT256;\n    }\n\n    /// @notice For backwards compatibility and testing only\n    /// This can probably be removed once https://github.com/ethereum/web3.py/issues/1677 is fixed.\n    function chain_id()\n        external\n        returns (uint256)\n    {\n        return block.chainid;\n    }\n}\n/* solium-disable error-reason */\n\n\n/// @title TokenNetworkRegistry\n/// @notice The TokenNetwork Registry deploys new TokenNetwork contracts for the\n/// Raiden Network protocol.\ncontract TokenNetworkRegistry is Utils, Controllable {\n    address public secret_registry_address;\n    uint256 public settlement_timeout_min;\n    uint256 public settlement_timeout_max;\n    uint256 public max_token_networks;\n\n    // Only for the limited Red Eyes release\n    uint256 public token_network_created = 0;\n\n    // Token address => TokenNetwork address\n    mapping(address => address) public token_to_token_networks;\n\n    event TokenNetworkCreated(address indexed token_address, address indexed token_network_address);\n\n    modifier canCreateTokenNetwork() {\n        require(token_network_created < max_token_networks, \"TNR: registry full\");\n        _;\n    }\n\n    /// @param _secret_registry_address The address of SecretRegistry that's used by all\n    /// TokenNetworks created by this contract\n    /// @param _settlement_timeout_min The shortest settlement period (in number of blocks)\n    /// that can be chosen at the channel opening\n    /// @param _settlement_timeout_max The longest settlement period (in number of blocks)\n    /// that can be chosen at the channel opening\n    /// @param _max_token_networks the number of tokens that can be registered\n    /// MAX_UINT256 means no limits\n    constructor(\n        address _secret_registry_address,\n        uint256 _settlement_timeout_min,\n        uint256 _settlement_timeout_max,\n        uint256 _max_token_networks\n    ) {\n        require(_settlement_timeout_min > 0, \"TNR: invalid settle timeout min\");\n        require(_settlement_timeout_max > 0, \"TNR: invalid settle timeout max\");\n        require(_settlement_timeout_max > _settlement_timeout_min, \"TNR: invalid settle timeouts\");\n        require(_secret_registry_address != address(0x0), \"TNR: invalid SR address\");\n        require(contractExists(_secret_registry_address), \"TNR: invalid SR\");\n        require(_max_token_networks > 0, \"TNR: invalid TN limit\");\n        secret_registry_address = _secret_registry_address;\n        settlement_timeout_min = _settlement_timeout_min;\n        settlement_timeout_max = _settlement_timeout_max;\n        max_token_networks = _max_token_networks;\n\n        controller = msg.sender;\n    }\n\n    /// @notice Deploy a new TokenNetwork contract for the Token deployed at\n    /// `_token_address`\n    /// @param _token_address Ethereum address of an already deployed token, to\n    /// be used in the new TokenNetwork contract\n    function createERC20TokenNetwork(\n        address _token_address,\n        uint256 _channel_participant_deposit_limit,\n        uint256 _token_network_deposit_limit\n    )\n        public\n        canCreateTokenNetwork\n        returns (address token_network_address)\n    {\n        // After the limits have been removed, new token networks must be created without limits\n        // See https://github.com/raiden-network/raiden-contracts/issues/1416\n        if (max_token_networks == MAX_SAFE_UINT256) {\n            require(_channel_participant_deposit_limit == MAX_SAFE_UINT256, \"TNR: limits must be set to MAX_INT\");\n            require(_token_network_deposit_limit == MAX_SAFE_UINT256, \"TNR: limits must be set to MAX_INT\");\n        }\n\n        require(token_to_token_networks[_token_address] == address(0x0), \"TNR: token already registered\");\n\n        // We limit the number of token networks to 1 for the Bug Bounty release\n        token_network_created = token_network_created + 1;\n\n        TokenNetwork token_network;\n\n        // Token contract checks are in the corresponding TokenNetwork contract\n        token_network = new TokenNetwork(\n            _token_address,\n            secret_registry_address,\n            settlement_timeout_min,\n            settlement_timeout_max,\n            controller,\n            _channel_participant_deposit_limit,\n            _token_network_deposit_limit\n        );\n\n        token_network_address = address(token_network);\n\n        token_to_token_networks[_token_address] = token_network_address;\n        emit TokenNetworkCreated(_token_address, token_network_address);\n\n        return token_network_address;\n    }\n\n    function createERC20TokenNetworkWithoutLimits(\n        address _token_address\n    )\n        external\n        returns (address token_network_address)\n    {\n        return createERC20TokenNetwork(_token_address, MAX_SAFE_UINT256, MAX_SAFE_UINT256);\n    }\n\n    /// @notice Removes the limit on the number of token networks.\n    /// Can only be called by the controller.\n    function removeLimits()\n        external\n        onlyController\n    {\n        max_token_networks = MAX_SAFE_UINT256;\n    }\n}\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n/* solium-disable indentation */\n/* solium-disable security/no-block-members */\n\n\ncontract ServiceRegistryConfigurableParameters is Controllable {\n\n    // After a price is set to set_price at timestamp set_price_at,\n    // the price decays according to decayedPrice().\n    uint256 public set_price;\n    uint256 public set_price_at;\n\n    /// The amount of time (in seconds) till the price decreases to roughly 1/e.\n    uint256 public decay_constant = 200 days;\n\n    // Once the price is at min_price, it can't decay further.\n    uint256 public min_price = 1000;\n\n    // Whenever a deposit comes in, the price is multiplied by numerator / denominator.\n    uint256 public price_bump_numerator = 1;\n    uint256 public price_bump_denominator = 1;\n\n    // The duration of service registration/extension in seconds\n    uint256 public registration_duration = 180 days;\n\n    // If true, new deposits are no longer accepted.\n    bool public deprecated = false;\n\n    function setDeprecationSwitch() public onlyController returns (bool _success) {\n        deprecated = true;\n        return true;\n    }\n\n    function changeParameters(\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator,\n            uint256 _decay_constant,\n            uint256 _min_price,\n            uint256 _registration_duration\n    ) public onlyController returns (bool _success) {\n        changeParametersInternal(\n            _price_bump_numerator,\n            _price_bump_denominator,\n            _decay_constant,\n            _min_price,\n            _registration_duration\n        );\n        return true;\n    }\n\n    function changeParametersInternal(\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator,\n            uint256 _decay_constant,\n            uint256 _min_price,\n            uint256 _registration_duration\n    ) internal {\n        refreshPrice();\n        setPriceBumpParameters(_price_bump_numerator, _price_bump_denominator);\n        setMinPrice(_min_price);\n        setDecayConstant(_decay_constant);\n        setRegistrationDuration(_registration_duration);\n    }\n\n    // Updates set_price to be currentPrice() and set_price_at to be now\n    function refreshPrice() private {\n        set_price = currentPrice();\n        set_price_at = block.timestamp;\n    }\n\n    function setPriceBumpParameters(\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator\n    ) private {\n        require(_price_bump_denominator > 0, \"divide by zero\");\n        require(_price_bump_numerator >= _price_bump_denominator, \"price dump instead of bump\");\n        require(_price_bump_numerator < 2 ** 40, \"price dump numerator is too big\");\n        price_bump_numerator = _price_bump_numerator;\n        price_bump_denominator = _price_bump_denominator;\n    }\n\n    function setMinPrice(uint256 _min_price) private {\n        // No checks.  Even allowing zero.\n        min_price = _min_price;\n        // No checks or modifications on set_price.\n        // Even if set_price is smaller than min_price, currentPrice() function returns min_price.\n    }\n\n    function setDecayConstant(uint256 _decay_constant) private {\n        require(_decay_constant > 0, \"attempt to set zero decay constant\");\n        require(_decay_constant < 2 ** 40, \"too big decay constant\");\n        decay_constant = _decay_constant;\n    }\n\n    function setRegistrationDuration(uint256 _registration_duration) private {\n        // No checks.  Even allowing zero (when no new registrations are possible).\n        registration_duration = _registration_duration;\n    }\n\n\n    /// @notice The amount to deposit for registration or extension\n    /// Note: the price moves quickly depending on what other addresses do.\n    /// The current price might change after you send a `deposit()` transaction\n    /// before the transaction is executed.\n    function currentPrice() public view returns (uint256) {\n        require(block.timestamp >= set_price_at, \"An underflow in price computation\");\n        uint256 seconds_passed = block.timestamp - set_price_at;\n\n        return decayedPrice(set_price, seconds_passed);\n    }\n\n\n    /// @notice Calculates the decreased price after a number of seconds\n    /// @param _set_price The initial price\n    /// @param _seconds_passed The number of seconds passed since the initial\n    /// price was set\n    function decayedPrice(uint256 _set_price, uint256 _seconds_passed) public\n        view returns (uint256) {\n        // We are here trying to approximate some exponential decay.\n        // exp(- X / A) where\n        //   X is the number of seconds since the last price change\n        //   A is the decay constant (A = 200 days corresponds to 0.5% decrease per day)\n\n        // exp(- X / A) ~~ P / Q where\n        //   P = 24 A^4\n        //   Q = 24 A^4 + 24 A^3X + 12 A^2X^2 + 4 AX^3 + X^4\n        // Note: swap P and Q, and then think about the Taylor expansion.\n\n        uint256 X = _seconds_passed;\n\n        if (X >= 2 ** 40) { // The computation below overflows.\n            return min_price;\n        }\n\n        uint256 A = decay_constant;\n\n        uint256 P = 24 * (A ** 4);\n        uint256 Q = P + 24*(A**3)*X + 12*(A**2)*(X**2) + 4*A*(X**3) + X**4;\n\n        // The multiplication below is not supposed to overflow because\n        // _set_price should be at most 2 ** 90 and\n        // P should be at most 24 * (2 ** 40).\n        uint256 price = _set_price * P / Q;\n\n        // Not allowing a price smaller than min_price.\n        // Once it's too low it's too low forever.\n        if (price < min_price) {\n            price = min_price;\n        }\n        return price;\n    }\n}\n\n\ncontract Deposit {\n    // This contract holds ERC20 tokens as deposit until a predetemined point of time.\n\n    // The ERC20 token contract that the deposit is about.\n    Token public token;\n\n    // The address of ServiceRegistry contract that this deposit is associated with.\n    // If the address has no code, service_registry.deprecated() call will fail.\n    ServiceRegistryConfigurableParameters service_registry;\n\n    // The address that can withdraw the deposit after the release time.\n    address public withdrawer;\n\n    // The timestamp after which the withdrawer can withdraw the deposit.\n    uint256 public release_at;\n\n    /// @param _token The address of the ERC20 token contract where the deposit is accounted\n    /// @param _release_at The timestap after which the withdrawer can withdraw the deposit\n    /// @param _withdrawer The address that can withdraw the deposit after the release time\n    /// @param _service_registry The address of ServiceRegistry whose deprecation enables immediate withdrawals\n    constructor(\n        Token _token,\n        uint256 _release_at,\n        address _withdrawer,\n        ServiceRegistryConfigurableParameters _service_registry\n    ) {\n        token = _token;\n        // Don't care even if it's in the past.\n        release_at = _release_at;\n        withdrawer = _withdrawer;\n        service_registry = _service_registry;\n    }\n\n    // In order to make a deposit, transfer the ERC20 token into this contract.\n    // If you transfer a wrong kind of ERC20 token or ETH into this contract,\n    // these tokens will be lost forever.\n\n    /// @notice Withdraws the tokens that have been deposited\n    /// Only `withdrawer` can call this.\n    /// @param _to The address where the withdrawn tokens should go\n    function withdraw(address payable _to) external {\n        uint256 balance = token.balanceOf(address(this));\n        require(msg.sender == withdrawer, \"the caller is not the withdrawer\");\n        require(block.timestamp >= release_at || service_registry.deprecated(), \"deposit not released yet\");\n        require(balance > 0, \"nothing to withdraw\");\n        require(token.transfer(_to, balance), \"token didn't transfer\");\n        selfdestruct(_to); // The contract can disappear.\n    }\n}\n\n\ncontract ServiceRegistry is Utils, ServiceRegistryConfigurableParameters {\n    Token public token;\n\n    mapping(address => uint256) public service_valid_till;\n    mapping(address => string) public urls;  // URLs of services for HTTP access\n\n    // An append-only list of addresses that have ever made a deposit.\n    // Starting from this list, all alive registrations can be figured out.\n    address[] public ever_made_deposits;\n\n    // @param service The address of the registered service provider\n    // @param valid_till The timestamp of the moment when the registration expires\n    // @param deposit_amount The amount of deposit transferred\n    // @param deposit The address of Deposit instance where the deposit is stored\n    event RegisteredService(address indexed service, uint256 valid_till, uint256 deposit_amount, Deposit deposit_contract);\n\n    // @param _token_for_registration The address of the ERC20 token contract that services use for registration fees\n    // @param _controller The address that can change parameters and deprecate the ServiceRegistry\n    // @param _initial_price The amount of tokens needed initially for a slot\n    // @param _price_bump_numerator The ratio of price bump after deposit is made (numerator)\n    // @param _price_bump_denominator The ratio of price bump after deposit is made (denominator)\n    // @param _decay_constant The number of seconds after which the price becomes roughly 1/e\n    // @param _min_price The minimum amount of tokens needed for a slot\n    // @param _registration_duration The number of seconds (roughly, barring block time & miners'\n    // timestamp errors) of a slot gained for a successful deposit\n    constructor(\n            Token _token_for_registration,\n            address _controller,\n            uint256 _initial_price,\n            uint256 _price_bump_numerator,\n            uint256 _price_bump_denominator,\n            uint256 _decay_constant,\n            uint256 _min_price,\n            uint256 _registration_duration\n    ) {\n        require(address(_token_for_registration) != address(0x0), \"token at address zero\");\n        require(contractExists(address(_token_for_registration)), \"token has no code\");\n        require(_initial_price >= min_price, \"initial price too low\");\n        require(_initial_price <= 2 ** 90, \"intiial price too high\");\n\n        token = _token_for_registration;\n        // Check if the contract is indeed a token contract\n        require(token.totalSupply() > 0, \"total supply zero\");\n        controller = _controller;\n\n        // Set up the price and the set price timestamp\n        set_price = _initial_price;\n        set_price_at = block.timestamp;\n\n        // Set the parameters\n        changeParametersInternal(_price_bump_numerator, _price_bump_denominator, _decay_constant, _min_price, _registration_duration);\n    }\n\n    // @notice Locks tokens and registers a service or extends the registration\n    // @param _limit_amount The biggest amount of tokens that the caller is willing to deposit\n    // The call fails if the current price is higher (this is always possible\n    // when other parties have just called `deposit()`)\n    function deposit(uint _limit_amount) public returns (bool _success) {\n        require(! deprecated, \"this contract was deprecated\");\n\n        uint256 amount = currentPrice();\n        require(_limit_amount >= amount, \"not enough limit\");\n\n        // Extend the service position.\n        uint256 valid_till = service_valid_till[msg.sender];\n        if (valid_till == 0) { // a first time joiner\n            ever_made_deposits.push(msg.sender);\n        }\n        if (valid_till < block.timestamp) { // a first time joiner or an expired service.\n            valid_till = block.timestamp;\n        }\n        // Check against overflow.\n        unchecked {\n            require(valid_till < valid_till + registration_duration, \"overflow during extending the registration\");\n        }\n        valid_till = valid_till + registration_duration;\n        assert(valid_till > service_valid_till[msg.sender]);\n        service_valid_till[msg.sender] = valid_till;\n\n        // Record the price\n        set_price = amount * price_bump_numerator / price_bump_denominator;\n        if (set_price > 2 ** 90) {\n            set_price = 2 ** 90; // Preventing overflows.\n        }\n        set_price_at = block.timestamp;\n\n        // Move the deposit in a new Deposit contract.\n        assert(block.timestamp < valid_till);\n        Deposit depo = new Deposit(token, valid_till, msg.sender, this);\n        require(token.transferFrom(msg.sender, address(depo), amount), \"Token transfer for deposit failed\");\n\n        // Fire event\n        emit RegisteredService(msg.sender, valid_till, amount, depo);\n\n        return true;\n    }\n\n    /// @notice Sets the URL used to access a service via HTTP\n    /// Only a currently registered service can call this successfully\n    /// @param new_url The new URL string to be stored\n    function setURL(string memory new_url) public returns (bool _success) {\n        require(hasValidRegistration(msg.sender), \"registration expired\");\n        require(bytes(new_url).length != 0, \"new url is empty string\");\n        urls[msg.sender] = new_url;\n        return true;\n    }\n\n    /// A getter function for seeing the length of ever_made_deposits array\n    function everMadeDepositsLen() public view returns (uint256 _len) {\n        return ever_made_deposits.length;\n    }\n\n    function hasValidRegistration(address _address) public view returns (bool _has_registration) {\n        return block.timestamp < service_valid_till[_address];\n    }\n}\n\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n\ncontract UserDeposit is Utils {\n    uint constant public withdraw_delay = 100;  // time before withdraw is allowed in blocks\n\n    // Token to be used for the deposit\n    Token public token;\n\n    // Trusted contracts (can execute `transfer`)\n    address public msc_address;\n    address public one_to_n_address;\n\n    // Total amount of tokens that have been deposited. This is monotonous and\n    // doing a transfer or withdrawing tokens will not decrease total_deposit!\n    mapping(address => uint256) public total_deposit;\n    // Current user's balance, ignoring planned withdraws\n    mapping(address => uint256) public balances;\n    mapping(address => WithdrawPlan) public withdraw_plans;\n\n    // The sum of all balances\n    uint256 public whole_balance = 0;\n    // Deposit limit for this whole contract\n    uint256 public whole_balance_limit;\n\n    /*\n     *  Structs\n     */\n    struct WithdrawPlan {\n        uint256 amount;\n        uint256 withdraw_block;  // earliest block at which withdraw is allowed\n    }\n\n    /*\n     *  Events\n     */\n\n    event BalanceReduced(address indexed owner, uint newBalance);\n    event WithdrawPlanned(address indexed withdrawer, uint plannedBalance);\n\n    /*\n     *  Modifiers\n     */\n\n    modifier canTransfer() {\n        require(msg.sender == msc_address || msg.sender == one_to_n_address, \"unknown caller\");\n        _;\n    }\n\n    /*\n     *  Constructor\n     */\n\n    /// @notice Set the default values for the smart contract\n    /// @param _token_address The address of the token to use for rewards\n    constructor(address _token_address, uint256 _whole_balance_limit)\n    {\n        // check token contract\n        require(_token_address != address(0x0), \"token at address zero\");\n        require(contractExists(_token_address), \"token has no code\");\n        token = Token(_token_address);\n        require(token.totalSupply() > 0, \"token has no total supply\"); // Check if the contract is indeed a token contract\n        // check and set the whole balance limit\n        require(_whole_balance_limit > 0, \"whole balance limit is zero\");\n        whole_balance_limit = _whole_balance_limit;\n    }\n\n    /// @notice Specify trusted contracts. This has to be done outside of the\n    /// constructor to avoid cyclic dependencies.\n    /// @param _msc_address Address of the MonitoringService contract\n    /// @param _one_to_n_address Address of the OneToN contract\n    function init(address _msc_address, address _one_to_n_address)\n        external\n    {\n        // prevent changes of trusted contracts after initialization\n        require(msc_address == address(0x0) && one_to_n_address == address(0x0), \"already initialized\");\n\n        // check monitoring service contract\n        require(_msc_address != address(0x0), \"MS contract at address zero\");\n        require(contractExists(_msc_address), \"MS contract has no code\");\n        msc_address = _msc_address;\n\n        // check one to n contract\n        require(_one_to_n_address != address(0x0), \"OneToN at address zero\");\n        require(contractExists(_one_to_n_address), \"OneToN has no code\");\n        one_to_n_address = _one_to_n_address;\n    }\n\n    /// @notice Deposit tokens. The amount of transferred tokens will be\n    /// `new_total_deposit - total_deposit[beneficiary]`. This makes the\n    /// function behavior predictable and idempotent. Can be called several\n    /// times and on behalf of other accounts.\n    /// @param beneficiary The account benefiting from the deposit\n    /// @param new_total_deposit The total sum of tokens that have been\n    /// deposited by the user by calling this function.\n    function deposit(address beneficiary, uint256 new_total_deposit)\n        external\n    {\n        require(new_total_deposit > total_deposit[beneficiary], \"deposit not increasing\");\n\n        // Calculate the actual amount of tokens that will be transferred\n        uint256 added_deposit = new_total_deposit - total_deposit[beneficiary];\n\n        balances[beneficiary] += added_deposit;\n        total_deposit[beneficiary] += added_deposit;\n\n        // Update whole_balance, but take care against overflows.\n        require(whole_balance + added_deposit >= whole_balance, \"overflowing deposit\");\n        whole_balance += added_deposit;\n\n        // Decline deposit if the whole balance is bigger than the limit.\n        require(whole_balance <= whole_balance_limit, \"too much deposit\");\n\n        // Actual transfer.\n        require(token.transferFrom(msg.sender, address(this), added_deposit), \"tokens didn't transfer\");\n    }\n\n    /// @notice Internally transfer deposits between two addresses.\n    /// Sender and receiver must be different or the transaction will fail.\n    /// @param sender Account from which the amount will be deducted\n    /// @param receiver Account to which the amount will be credited\n    /// @param amount Amount of tokens to be transferred\n    /// @return success true if transfer has been done successfully, otherwise false\n    function transfer(\n        address sender,\n        address receiver,\n        uint256 amount\n    )\n        external\n        canTransfer()\n        returns (bool success)\n    {\n        require(sender != receiver, \"sender == receiver\");\n        if (balances[sender] >= amount && amount > 0) {\n            balances[sender] -= amount;\n            // This can overflow in theory, but this is checked by solidity since 0.8.0.\n            // In practice, with any reasonable token, where the supply is limited to uint256,\n            // this can never overflow.\n            // See https://github.com/raiden-network/raiden-contracts/pull/448#discussion_r250609178\n            balances[receiver] += amount;\n            emit BalanceReduced(sender, balances[sender]);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /// @notice Announce intention to withdraw tokens.\n    /// Sets the planned withdraw amount and resets the withdraw_block.\n    /// There is only one planned withdrawal at a time, the old one gets overwritten.\n    /// @param amount Maximum amount of tokens to be withdrawn\n    function planWithdraw(uint256 amount)\n        external\n    {\n        require(amount > 0, \"withdrawing zero\");\n        require(balances[msg.sender] >= amount, \"withdrawing too much\");\n\n        withdraw_plans[msg.sender] = WithdrawPlan({\n            amount: amount,\n            withdraw_block: block.number + withdraw_delay\n        });\n        emit WithdrawPlanned(msg.sender, balances[msg.sender] - amount);\n    }\n\n    /// @notice Execute a planned withdrawal\n    /// Will only work after the withdraw_delay has expired.\n    /// An amount lower or equal to the planned amount may be withdrawn.\n    /// Removes the withdraw plan even if not the full amount has been\n    /// withdrawn.\n    /// @param amount Amount of tokens to be withdrawn\n    /// @param beneficiary Address to send withdrawn tokens to\n    function withdrawToBeneficiary(uint256 amount, address beneficiary)\n        external\n    {\n        withdrawHelper(amount, msg.sender, beneficiary);\n    }\n\n    /// @notice Execute a planned withdrawal\n    /// Will only work after the withdraw_delay has expired.\n    /// An amount lower or equal to the planned amount may be withdrawn.\n    /// Removes the withdraw plan even if not the full amount has been\n    /// withdrawn.\n    /// @param amount Amount of tokens to be withdrawn\n    function withdraw(uint256 amount)\n        external\n    {\n        withdrawHelper(amount, msg.sender, msg.sender);\n    }\n\n    /// @notice The owner's balance with planned withdrawals deducted\n    /// @param owner Address for which the balance should be returned\n    /// @return remaining_balance The remaining balance after planned withdrawals\n    function effectiveBalance(address owner)\n        external\n        view\n        returns (uint256 remaining_balance)\n    {\n        WithdrawPlan storage withdraw_plan = withdraw_plans[owner];\n        if (withdraw_plan.amount > balances[owner]) {\n            return 0;\n        }\n        return balances[owner] - withdraw_plan.amount;\n    }\n\n    function withdrawHelper(uint256 amount, address deposit_holder, address beneficiary)\n        internal\n    {\n        require(beneficiary != address(0x0), \"beneficiary is zero\");\n        WithdrawPlan storage withdraw_plan = withdraw_plans[deposit_holder];\n        require(amount <= withdraw_plan.amount, \"withdrawing more than planned\");\n        require(withdraw_plan.withdraw_block <= block.number, \"withdrawing too early\");\n        uint256 withdrawable = min(amount, balances[deposit_holder]);\n        balances[deposit_holder] -= withdrawable;\n\n        // Update whole_balance, but take care against underflows.\n        require(whole_balance - withdrawable <= whole_balance, \"underflow in whole_balance\");\n        whole_balance -= withdrawable;\n\n        emit BalanceReduced(deposit_holder, balances[deposit_holder]);\n        delete withdraw_plans[deposit_holder];\n\n        require(token.transfer(beneficiary, withdrawable), \"tokens didn't transfer\");\n    }\n}\n\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\ncontract MonitoringService is Utils {\n    // Token to be used for paying the rewards\n    Token public token;\n\n    // Raiden Service Bundle contract to use for checking if MS has deposits\n    ServiceRegistry public service_registry;\n    UserDeposit public user_deposit;\n    TokenNetworkRegistry public token_network_registry;\n\n    // keccak256(channel_identifier, token_network_address) => Struct\n    // Keep track of the rewards per channel\n    mapping(bytes32 => Reward) internal rewards;\n\n    /*\n     *  Structs\n     */\n    struct Reward{\n        // The amount of tokens to be rewarded\n        uint256 reward_amount;\n\n        // Nonce of the most recently provided BP\n        uint256 nonce;\n\n        // Address of the Raiden Node that was monitored\n        // This is also the address that has the reward deducted from its deposit\n        address reward_sender_address;\n\n        // Address of the Monitoring Service who is currently eligible to claim the reward\n        address monitoring_service_address;\n    }\n\n    /*\n     *  Events\n     */\n\n    event NewBalanceProofReceived(\n        address token_network_address,\n        uint256 channel_identifier,\n        uint256 reward_amount,\n        uint256 indexed nonce,\n        address indexed ms_address,\n        address indexed raiden_node_address\n    );\n    event RewardClaimed(address indexed ms_address, uint amount, bytes32 indexed reward_identifier);\n\n    /*\n     *  Constructor\n     */\n\n    /// @notice Set the default values for the smart contract\n    /// @param _token_address The address of the token to use for rewards\n    /// @param _service_registry_address The address of the ServiceRegistry contract\n    /// @param _token_network_registry_address The address of the TokenNetworkRegistry for authenticating TokenNetworks\n    constructor(\n        address _token_address,\n        address _service_registry_address,\n        address _udc_address,\n        address _token_network_registry_address\n    ) {\n        require(_token_address != address(0x0), \"Token at address zero\");\n        require(_service_registry_address != address(0x0), \"ServiceRegistry at address zero\");\n        require(_udc_address != address(0x0), \"UDC at address zero\");\n        require(contractExists(_token_address), \"token has no code\");\n        require(contractExists(_service_registry_address), \"ServiceRegistry has no code\");\n        require(contractExists(_udc_address), \"UDC has no code\");\n        require(contractExists(_token_network_registry_address), \"TokenNetworkRegistry has no code\");\n\n        token = Token(_token_address);\n        service_registry = ServiceRegistry(_service_registry_address);\n        user_deposit = UserDeposit(_udc_address);\n        token_network_registry = TokenNetworkRegistry(_token_network_registry_address);\n        // Check if the contract is indeed a token contract\n        require(token.totalSupply() > 0, \"Token with zero total supply\");\n        // Check if the contract is indeed a service_registry contract\n        // TODO: Check that some function exists in the contract\n    }\n\n    /// @notice Internal function that updates the Reward struct if a newer balance proof\n    /// is provided in the monitor() function\n    /// @param token_network_address Address of the TokenNetwork being monitored\n    /// @param closing_participant The address of the participant who closed the channel\n    /// @param non_closing_participant Address of the other channel participant. This is\n    /// the participant on whose behalf the MS acts.\n    /// @param reward_amount The amount of tokens to be rewarded\n    /// @param nonce The nonce of the newly provided balance_proof\n    /// @param monitoring_service_address The address of the MS calling monitor()\n    /// @param non_closing_signature Non-closing participant signature of the\n    /// balance proof data.\n    /// @param reward_proof_signature The signature of the signed reward proof\n    function updateReward(\n        address token_network_address,\n        address closing_participant,\n        address non_closing_participant,\n        uint256 reward_amount,\n        uint256 nonce,\n        address monitoring_service_address,\n        bytes memory non_closing_signature,\n        bytes memory reward_proof_signature\n    )\n        internal\n    {\n        TokenNetwork token_network = TokenNetwork(token_network_address);\n        address token_network_token = address(token_network.token());\n        require(\n            token_network_registry.token_to_token_networks(token_network_token) ==\n            address(token_network),\n            \"Unknown TokenNetwork\"\n        );\n        uint256 channel_identifier = token_network.getChannelIdentifier(\n            closing_participant, non_closing_participant\n        );\n\n        // Make sure that the reward proof is signed by the non_closing_participant\n        address raiden_node_address = recoverAddressFromRewardProof(\n            token_network_address,\n            non_closing_participant,\n            non_closing_signature,\n            reward_amount,\n            reward_proof_signature\n        );\n        require(raiden_node_address == non_closing_participant, \"Bad reward proof\");\n\n        bytes32 reward_identifier = keccak256(\n            abi.encodePacked(\n                channel_identifier,\n                token_network_address\n            )\n        );\n\n        // Get the Reward struct for the correct channel\n        Reward storage reward = rewards[reward_identifier];\n\n        // Only allow BPs with higher nonce to be submitted\n        require(reward.nonce < nonce, \"stale nonce\");\n\n        // MSC stores channel_identifier, MS_address, reward_amount, nonce\n        // of the MS that provided the balance_proof with highest nonce\n        rewards[reward_identifier] = Reward({\n            reward_amount: reward_amount,\n            nonce: nonce,\n            reward_sender_address: non_closing_participant,\n            monitoring_service_address: monitoring_service_address\n        });\n    }\n\n    /// @notice Called by a registered MS, when providing a new balance proof\n    /// to a monitored channel.\n    /// Can be called multiple times by different registered MSs as long as the BP provided\n    /// is newer than the current newest registered BP.\n    /// @param nonce Strictly monotonic value used to order BPs\n    /// omitting PB specific params, since these will not be provided in the future\n    /// @param reward_amount Amount of tokens to be rewarded\n    /// @param token_network_address Address of the Token Network in which the channel\n    /// being monitored exists.\n    /// @param reward_proof_signature The signature of the signed reward proof\n    function monitor(\n        address closing_participant,\n        address non_closing_participant,\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes memory closing_signature,\n        bytes memory non_closing_signature,\n        uint256 reward_amount,\n        address token_network_address,\n        bytes memory reward_proof_signature\n    )\n        public\n    {\n        // Here we're trying to do bookkeeping first, but updateReward() first calls\n        // token_network_address.  So reentrancy is possible.\n        // In that case, the outer frame fails and reverts the state\n        // because token_network_address is not registered in the token_network_registry.\n        //\n        // Maybe it's simpler and safer to take the token address as an argument instead,\n        // and ask the TokenNetworkRegistry for the token_network_address.\n        updateReward(\n            token_network_address,\n            closing_participant,\n            non_closing_participant,\n            reward_amount,\n            nonce,\n            msg.sender,\n            non_closing_signature,\n            reward_proof_signature\n        );\n\n        TokenNetwork token_network = TokenNetwork(token_network_address);\n        uint256 channel_identifier = token_network.getChannelIdentifier(\n            closing_participant, non_closing_participant\n        );\n        require(\n            block.number >= firstBlockAllowedToMonitorChannel(\n                token_network,\n                channel_identifier,\n                closing_participant,\n                non_closing_participant,\n                msg.sender\n            ),\n            \"not allowed to monitor\"\n        );\n\n        // Call updateTransfer in the corresponding TokenNetwork\n        token_network.updateNonClosingBalanceProof(\n            channel_identifier,\n            closing_participant,\n            non_closing_participant,\n            balance_hash,\n            nonce,\n            additional_hash,\n            closing_signature,\n            non_closing_signature\n        );\n\n        emit NewBalanceProofReceived(\n            token_network_address,\n            channel_identifier,\n            reward_amount,\n            nonce,\n            msg.sender,\n            non_closing_participant\n        );\n    }\n\n    function firstBlockAllowedToMonitorChannel(\n        TokenNetwork token_network,\n        uint256 channel_identifier,\n        address closing_participant,\n        address non_closing_participant,\n        address monitoring_service_address\n    )\n        public view\n        returns (uint256)\n    {\n        require(service_registry.hasValidRegistration(monitoring_service_address), \"service not registered\");\n\n        TokenNetwork.ChannelState channel_state;\n        uint256 settle_block_number;\n        (settle_block_number, channel_state) = token_network.getChannelInfo(\n            channel_identifier, closing_participant, non_closing_participant\n        );\n        require(channel_state == TokenNetwork.ChannelState.Closed, \"channel not closed\");\n\n        // We don't actually know when the channel has been closed. So we'll\n        // make a guess so that assumed_close_block >= real_close_block.\n        uint256 assumed_settle_timeout = token_network.settlement_timeout_min();\n        require(settle_block_number >= assumed_settle_timeout, \"too low settle block number\");\n        uint256 assumed_close_block = settle_block_number - assumed_settle_timeout;\n\n        return firstBlockAllowedToMonitor(\n            assumed_close_block,\n            assumed_settle_timeout,\n            closing_participant,\n            non_closing_participant,\n            monitoring_service_address\n        );\n    }\n\n    function firstBlockAllowedToMonitor(\n        uint256 closed_at_block,\n        uint256 settle_timeout,\n        address participant1,\n        address participant2,\n        address monitoring_service_address\n    )\n        public pure\n        returns (uint256)\n    {\n        // avoid overflows when multiplying with percentages\n        require(settle_timeout < MAX_SAFE_UINT256 / 100, \"maliciously big settle timeout\");\n        require(closed_at_block < MAX_SAFE_UINT256 / 100, \"maliciously big closed_at_block\");\n\n        // First allowed block as percentage of settle_timeout. We're using\n        // integers here to avoid accuracy loss during calculations.\n        uint256 BEST_CASE = 30;\n        uint256 WORST_CASE = 80;\n\n        // When is the first block that any MS might be allowed to monitor\n        uint256 best_case_block = closed_at_block + BEST_CASE * settle_timeout / 100;\n        // Length of the range into which the first allowed block will fall\n        uint256 range_length = (WORST_CASE - BEST_CASE) * settle_timeout / 100;\n\n        // Offset for this specific MS within the range\n        uint256 ms_offset = (\n            uint256(uint160(participant1)) +\n            uint256(uint160(participant2)) +\n            uint256(uint160(monitoring_service_address))\n        ) % range_length;\n\n        return best_case_block + ms_offset;\n    }\n\n    /// @notice Called after a monitored channel is settled in order for MS to claim the reward\n    /// Can be called once per settled channel by everyone on behalf of MS\n    /// @param token_network_address Address of the Token Network in which the channel exists\n    /// @param closing_participant Address of the participant of the channel that called close\n    /// @param non_closing_participant The other participant of the channel\n    function claimReward(\n        uint256 channel_identifier,\n        address token_network_address,\n        address closing_participant,\n        address non_closing_participant\n    )\n        public\n        returns (bool)\n    {\n        TokenNetwork token_network = TokenNetwork(token_network_address);\n        bytes32 reward_identifier = keccak256(\n            abi.encodePacked(\n                channel_identifier,\n                token_network_address\n            )\n        );\n\n        // Only allowed to claim, if channel is settled\n        // Channel is settled if it's data has been deleted\n        TokenNetwork.ChannelState channel_state;\n        uint256 settle_block_number;\n        (settle_block_number, channel_state) = token_network.getChannelInfo(\n            channel_identifier,\n            closing_participant,\n            non_closing_participant\n        );\n        // We are trying to figure out when the settlement period ends.\n        // The meaning of settle_block_number is totally different depending on channel_state.\n        // When channel_state is NonExistent, settle_block_number is zero so it's not useful.\n        // When channel_state is Open, settle_block_number is the length of the settlement period.\n        // In these cases, we don't want to proceed anyway because the settlement period has not even started.\n        // We can only proceed with these other channel states.\n        require(\n            channel_state == TokenNetwork.ChannelState.Closed ||\n            channel_state == TokenNetwork.ChannelState.Settled ||\n            channel_state == TokenNetwork.ChannelState.Removed, \"too early channel state\"\n        );\n        require(settle_block_number < block.number, \"channel not settled yet\");\n\n        Reward storage reward = rewards[reward_identifier];\n\n        // Make sure that the Reward exists\n        require(reward.reward_sender_address != address(0x0), \"reward_sender is zero\");\n\n        // Add reward to the monitoring service's balance\n        require(\n            user_deposit.transfer(\n                reward.reward_sender_address,\n                reward.monitoring_service_address,\n                reward.reward_amount\n            ),\n            \"UDC did not transfer\"\n        );\n\n        emit RewardClaimed(\n            reward.monitoring_service_address,\n            reward.reward_amount,\n            reward_identifier\n        );\n\n        // delete storage\n        delete rewards[reward_identifier];\n\n        return true;\n    }\n\n    function recoverAddressFromRewardProof(\n        address token_network_address,\n        address non_closing_participant,\n        bytes memory non_closing_signature,\n        uint256 reward_amount,\n        bytes memory signature\n    )\n        internal\n        view\n        returns (address signature_address)\n    {\n        // This message shows the intention of the signer to pay\n        // a reward to a Monitoring Service, provided that the\n        // call of updateNonClosingBalanceProof() succeeds.\n        // The triple (non_closing_participant, non_closing_signature, token_network_address)\n        // uniquely identifies the call that's supposed to be made.\n        // (Just checking non_closing_signature is not enough because\n        // when an attacker tampers with the payload, the signature\n        // verification doesn't fail but emits a different address.)\n        // (Without a token_network, there will be some ambiguity\n        // what the payload means.)\n        bytes32 message_hash = keccak256(\n            abi.encodePacked(\n                signature_prefix,\n                \"221\",  // 20 + 32 + 32 + 20 + 20 + 65 + 32\n                address(this),\n                block.chainid,\n                uint256(MessageType.MessageTypeId.MSReward),\n                token_network_address,\n                non_closing_participant,\n                non_closing_signature,\n                reward_amount\n            )\n        );\n\n        signature_address = ECVerify.ecverify(message_hash, signature);\n        require(signature_address == non_closing_participant, \"Reward proof with wrong non_closing_participant\");\n    }\n}\n\n\n// MIT License\n\n// Copyright (c) 2018\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_service_registry_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_udc_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token_network_registry_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token_network_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ms_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"raiden_node_address\",\"type\":\"address\"}],\"name\":\"NewBalanceProofReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ms_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"reward_identifier\",\"type\":\"bytes32\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token_network_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"closing_participant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"non_closing_participant\",\"type\":\"address\"}],\"name\":\"claimReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contract_address\",\"type\":\"address\"}],\"name\":\"contractExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"failsafe_addition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"failsafe_subtract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"closed_at_block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settle_timeout\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"participant1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"participant2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"monitoring_service_address\",\"type\":\"address\"}],\"name\":\"firstBlockAllowedToMonitor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract TokenNetwork\",\"name\":\"token_network\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"channel_identifier\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"closing_participant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"non_closing_participant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"monitoring_service_address\",\"type\":\"address\"}],\"name\":\"firstBlockAllowedToMonitorChannel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"max\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"min\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"closing_participant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"non_closing_participant\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"balance_hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"additional_hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"closing_signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"non_closing_signature\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"reward_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token_network_address\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"reward_proof_signature\",\"type\":\"bytes\"}],\"name\":\"monitor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"service_registry\",\"outputs\":[{\"internalType\":\"contract ServiceRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signature_prefix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token_network_registry\",\"outputs\":[{\"internalType\":\"contract TokenNetworkRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"user_deposit\",\"outputs\":[{\"internalType\":\"contract UserDeposit\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MonitoringService","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000255aa6df07540cb5d3d297f0d0d4d84cb52bc8e6000000000000000000000000bdfdce3baafabb18ba1ec4337ef3b0144060eb8e0000000000000000000000005c0f3d9deb6ce4e5109ea0f51f81254bd276cf28000000000000000000000000bd39116da80bf840d9702834e3f306bdca5f0dd4","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}