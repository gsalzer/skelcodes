{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/token/ERC721/presets/UniftyGovernanceSimpleConsumer.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./IUniftyGovernanceConsumer.sol\\\";\\r\\nimport \\\"./IUniftyGovernance.sol\\\";\\r\\nimport \\\"./IERC20Simple.sol\\\";\\r\\n\\r\\ncontract LaunchVault is IUniftyGovernanceConsumer{\\r\\n\\r\\n    // the governance this consumer is assigned to\\r\\n    IUniftyGovernance public gov;\\r\\n\\r\\n    // unt address\\r\\n    address public untAddress;\\r\\n\\r\\n    // duration in seconds an allocation in the governance - for peers of this consumer - should freeze\\r\\n    uint256 public minAllocationDuration; // default: 86400 * 10 should be 10 days after acceptance\\r\\n    uint256 public allocationExpirationTime; // will be set upon adding this as peer based on minAllocationDuration\\r\\n    \\r\\n    // check if the peer is registered with this consumer\\r\\n    // since this consumer has only one peer (itself) we don't need a mapping or array of peers\\r\\n    bool public isPeer;\\r\\n\\r\\n    // reward rate for UNT\\r\\n    uint256 public untRate;\\r\\n\\r\\n    uint256 public graceTime;\\r\\n\\r\\n    string public uriPeer;\\r\\n\\r\\n    string public consumerName;\\r\\n\\r\\n    string public consumerDscription;\\r\\n\\r\\n    address public owner;\\r\\n\\r\\n    uint256 public collectedUnt;\\r\\n\\r\\n    uint256 public lastCollectionTime;\\r\\n\\r\\n    uint256 public nifCap;\\r\\n\\r\\n    uint256[] public priceProviders;\\r\\n\\r\\n    uint256 public lastCollectionBlock;\\r\\n    \\r\\n    bool public pausing;\\r\\n    \\r\\n    bool public withdrawOnPause;\\r\\n\\r\\n    mapping(address => uint256) public accountDebt;\\r\\n    mapping(address => uint256) public accountCredit;\\r\\n    mapping(address => uint256) public accountPrevAmount;\\r\\n    \\r\\n    event Credited(address indexed user, uint256 untCredited);\\r\\n    event CreditPaid(address indexed user, uint256 untPaid);\\r\\n\\r\\n    // re-entrancy protection\\r\\n    uint256 private unlocked = 1;\\r\\n\\r\\n    modifier lock() {\\r\\n        require(unlocked == 1, 'LaunchVault: LOCKED');\\r\\n        unlocked = 0;\\r\\n        _;\\r\\n        unlocked = 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Consumers must hold a reference to the governance.\\r\\n     * The constructor is the best place to set it up.\\r\\n     *\\r\\n     * */\\r\\n    constructor(\\r\\n        IUniftyGovernance _gov,\\r\\n        string memory _name,\\r\\n        string memory _description,\\r\\n        string memory _peerUri,\\r\\n        uint256 _graceTime,\\r\\n        uint256 _minAllocationDuration,\\r\\n        uint256 _nifCap,\\r\\n        uint256 _untRate,\\r\\n        uint256[] memory _priceProviders\\r\\n    ){\\r\\n\\r\\n        gov = _gov;\\r\\n        owner = msg.sender;\\r\\n        consumerName = _name;\\r\\n        consumerDscription = _description;\\r\\n        uriPeer = _peerUri;\\r\\n        graceTime = _graceTime;\\r\\n        minAllocationDuration = _minAllocationDuration;\\r\\n        nifCap = _nifCap;\\r\\n        untRate = _untRate;\\r\\n        priceProviders = _priceProviders;\\r\\n        untAddress = 0xF8fCC10506ae0734dfd2029959b93E6ACe5b2a70;\\r\\n        // untrate: 3858024690000000000\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * In case we want to move to a new governance\\r\\n     *\\r\\n     * */\\r\\n    function setGovernance(IUniftyGovernance _gov) external lock{\\r\\n\\r\\n        require(owner == msg.sender, \\\"setGovernance: not the owner.\\\");\\r\\n        require(address(_gov) != address(0), \\\"setGovernance: cannot move to the null address.\\\");\\r\\n\\r\\n        // we need to reset the peer status as this is a new governance\\r\\n        isPeer = false;\\r\\n\\r\\n        gov = _gov;\\r\\n    }\\r\\n\\r\\n    function setPeerUri(string calldata _uri) external lock{\\r\\n\\r\\n        require(owner == msg.sender, \\\"setPeerUri: not the owner.\\\");\\r\\n\\r\\n        uriPeer = _uri;\\r\\n\\r\\n    }\\r\\n\\r\\n    function setGraceTime(uint256 _graceTime) external lock{\\r\\n\\r\\n        require(owner == msg.sender, \\\"setGraceTime: not the owner.\\\");\\r\\n\\r\\n        graceTime = _graceTime;\\r\\n\\r\\n    }\\r\\n\\r\\n    function setNifCap(uint256 _nifCap) external lock{\\r\\n\\r\\n        require(owner == msg.sender, \\\"setNifCap: not the owner.\\\");\\r\\n\\r\\n        nifCap = _nifCap;\\r\\n\\r\\n    }\\r\\n    \\r\\n    function setPausing(bool _pausing, bool _withdrawOnPause) external lock{\\r\\n\\r\\n        require(owner == msg.sender, \\\"setPausing: not the owner.\\\");\\r\\n\\r\\n        pausing = _pausing;\\r\\n        withdrawOnPause = _withdrawOnPause;\\r\\n\\r\\n    }\\r\\n\\r\\n    function setUntRateAndPriceProviders(uint256 _untRate, uint256[] calldata _priceProviders) external lock{\\r\\n\\r\\n        require(owner == msg.sender, \\\"setUntRateAndPriceProviders: not the owner.\\\");\\r\\n\\r\\n        untRate = _untRate;\\r\\n        priceProviders = _priceProviders;\\r\\n\\r\\n    }\\r\\n\\r\\n    function setMinAllocationDuration(uint256 _minAllocationDuration) external lock{\\r\\n\\r\\n        require(owner == msg.sender, \\\"setMinAllocationDuration: not the owner.\\\");\\r\\n\\r\\n        minAllocationDuration = _minAllocationDuration;\\r\\n        \\r\\n        if(allocationExpirationTime != 0){\\r\\n            \\r\\n            allocationExpirationTime = block.timestamp + _minAllocationDuration;\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    function setNameAndDescription(string calldata _name, string calldata _description) external lock{\\r\\n\\r\\n        require(owner == msg.sender, \\\"setNameAndDescription: not the owner.\\\");\\r\\n\\r\\n        consumerName = _name;\\r\\n        consumerDscription = _description;\\r\\n\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address _newOwner) external lock{\\r\\n\\r\\n        require(owner == msg.sender, \\\"transferOwnership: not the owner.\\\");\\r\\n\\r\\n        owner = _newOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * ############################\\r\\n     * #\\r\\n     * # INTERFACE IMPLEMENTATIONS\\r\\n     * #\\r\\n     * ########################################\\r\\n     * */\\r\\n\\r\\n    /**\\r\\n    * Withdraws UNT rewards for accounts that stake in the governance and allocated their funds to this consumer and peer.\\r\\n    *\\r\\n    * Must return the amount of withdrawn UNT.\\r\\n    *\\r\\n    * */\\r\\n    function withdraw() override external lock returns(uint256){\\r\\n\\r\\n        require(!pausing || ( pausing && withdrawOnPause ), \\\"withdraw: pausing, sorry.\\\");\\r\\n\\r\\n        (IUniftyGovernanceConsumer con,address peer,,,) = gov.accountInfo(msg.sender);\\r\\n        \\r\\n        require(con == this && peer == address(this) && isPeer, \\\"withdraw: access denied.\\\");\\r\\n        \\r\\n        // must be the same as in frozen() since a witdraw is equivalent to dellocate() and allocationUpdate() as they may perform payouts\\r\\n        require(!frozen(msg.sender), \\\"withdraw: you are withdrawing too early.\\\");\\r\\n\\r\\n        collectUnt();\\r\\n        uint256 _earned = ( ( collectedUnt * accountPrevAmount[msg.sender] ) / 10**18 ) - accountDebt[msg.sender];\\r\\n        accountDebt[msg.sender] = ( collectedUnt * accountPrevAmount[msg.sender] ) / 10**18;\\r\\n\\r\\n        uint256 paid = payout(msg.sender, _earned);\\r\\n\\r\\n        return paid;\\r\\n    }\\r\\n\\r\\n    function payout(address _to, uint256 _amount) internal returns(uint256) {\\r\\n        \\r\\n        // adding the credited unt from allocationUpdate() if payouts were frozen at that time\\r\\n        \\r\\n        uint256 credit = accountCredit[_to];\\r\\n        accountCredit[_to] = 0;\\r\\n        _amount += credit;\\r\\n        \\r\\n        // if the earned exceeds the available grant left, we just take the rest.\\r\\n        // we won't be able to take more than that anyway but prevent errors and \\r\\n        // allow the last one withdrawing to take what is left from the overall grant.\\r\\n        \\r\\n        uint256 grantLeft = gov.earnedUnt(this);\\r\\n        \\r\\n        if(_amount > grantLeft){\\r\\n            \\r\\n            _amount = grantLeft;\\r\\n        }\\r\\n        \\r\\n        require(_amount != 0, \\\"payout: nothing to pay out.\\\");\\r\\n\\r\\n        gov.mintUnt(_amount);\\r\\n\\r\\n        IERC20Simple(untAddress).transfer(_to, _amount);\\r\\n        \\r\\n        emit Withdrawn(_to, _amount);\\r\\n        \\r\\n        if(credit != 0 && _amount <= grantLeft){\\r\\n\\r\\n            emit CreditPaid(_to, credit);\\r\\n        }\\r\\n        \\r\\n        return _amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * Must return the account's _current_ UNT earnings (as of current blockchain state).\\r\\n    *\\r\\n    * Used in the frontend.\\r\\n    * */\\r\\n    function earned(address _account) override external view returns(uint256){\\r\\n\\r\\n        (IUniftyGovernanceConsumer con,address peer,,,) = gov.accountInfo(_account);\\r\\n\\r\\n        if(con != this || peer != address(this) || !isPeer){\\r\\n\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        return ( ( collectedUnt * accountPrevAmount[_account] ) / 10**18 ) - accountDebt[_account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Same as earned() except adding a live component that may be inaccurate due to not yet occurred state-changes.\\r\\n     *\\r\\n     * If unsure how to implement, call and return earned() inside.\\r\\n     *\\r\\n     * Used in the frontend.\\r\\n     * */\\r\\n    function earnedLive(address _account) override external view returns(uint256){\\r\\n\\r\\n        (IUniftyGovernanceConsumer con,address peer,,,) = gov.accountInfo(_account);\\r\\n\\r\\n        if(con != this || peer != address(this) || !isPeer){\\r\\n\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 coll = collectedUnt;\\r\\n\\r\\n        uint256 alloc = gov.consumerPeerNifAllocation(this, address(this));\\r\\n\\r\\n        if (block.number > lastCollectionBlock && alloc != 0) {\\r\\n\\r\\n            coll += ( accumulatedUnt() * 10**18 ) / alloc;\\r\\n        }\\r\\n\\r\\n        return ( ( coll * accountPrevAmount[_account] ) / 10**18 ) - accountDebt[_account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * _peer parameter to apply the AP info for.\\r\\n     * \\r\\n     * Frontend function to help displaying apr/apy and similar strategies.\\r\\n     *\\r\\n     * The first index of the returned tuple should return \\\"r\\\" if APR or \\\"y\\\" if APY.\\r\\n     * \\r\\n     * The second index of the returned tuple should return the actual APR/Y value for the consumer.\\r\\n     * 18 decimals precision required.\\r\\n     *\\r\\n     * The 2nd uint256[] array should return a list of proposed services for price discovery on the client-side.\\r\\n     *\\r\\n     * 0 = uni-v2 unt/eth\\r\\n     * 1 = uni-v2 unt/usdt\\r\\n     * 2 = uni-v2 unt/usdc\\r\\n     * 3 = uni-v3 unt/eth\\r\\n     * 4 = uni-v3 unt/usdt\\r\\n     * 5 = uni-v3 unt/usdc\\r\\n     * 6 = kucoin unt/usdt\\r\\n     * 7 = binance unt/usdt\\r\\n     *\\r\\n     * The rate and list should be udpatable/extendible through an admin function due to possible updates on the client-side.\\r\\n     * (e.g. adding more exchanges)\\r\\n     *\\r\\n     * */\\r\\n    function apInfo(address _peer) override external view returns(string memory, uint256, uint256[] memory){\\r\\n\\r\\n        if( _peer != address(this) || !isPeer){\\r\\n\\r\\n            uint256[] memory n;\\r\\n            return (\\\"\\\",0,n);\\r\\n        }\\r\\n\\r\\n        return (\\\"r\\\", untRate * 86400 * 365, priceProviders);\\r\\n    }\\r\\n\\r\\n    function accumulatedUnt() internal view returns(uint256){\\r\\n\\r\\n        if(lastCollectionTime == 0){\\r\\n\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        return ( block.timestamp - lastCollectionTime ) * untRate;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Collect the current UNT based on real-time nif allocations\\r\\n     * \\r\\n     * */\\r\\n    function collectUnt() internal{\\r\\n\\r\\n        uint256 alloc = gov.consumerPeerNifAllocation(this, address(this));\\r\\n\\r\\n        if(alloc != 0){\\r\\n\\r\\n            collectedUnt += ( accumulatedUnt() * 10**18 ) / alloc;\\r\\n        }\\r\\n\\r\\n        lastCollectionTime = block.timestamp;\\r\\n        lastCollectionBlock = block.number;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * Override of collectUnt() being used to allow calculations based on previous allocations\\r\\n     */\\r\\n    function collectUnt(uint256 nifAllocation) internal{\\r\\n\\r\\n        if(nifAllocation != 0){\\r\\n\\r\\n            collectedUnt += ( accumulatedUnt() * 10**18 ) / nifAllocation;\\r\\n        }\\r\\n\\r\\n        lastCollectionTime = block.timestamp;\\r\\n        lastCollectionBlock = block.number;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Peer whitelist required to be implemented.\\r\\n     * If no peers should be used, this can have an empty implementation.\\r\\n     *\\r\\n     * Example would be to vote for farms in the governance being included.\\r\\n     * Accepted peers can then be added to the consumer's internal whitelist and get further benefits like UNT.\\r\\n     *\\r\\n     * Must contain a check if the caller has been the governance.\\r\\n     *\\r\\n     * Must return a string holding the name of the peer (being used for client display).\\r\\n     * */\\r\\n    function whitelistPeer(address _peer) override external lock{\\r\\n\\r\\n        require(IUniftyGovernance(msg.sender) == gov, \\\"whitelistPeer: access denied.\\\");\\r\\n        require(_peer == address(this), \\\"whitelistPeer: this consumer only allows itself as peer.\\\");\\r\\n        require(!isPeer, \\\"whitelistPeer: peer exists already.\\\");\\r\\n\\r\\n        isPeer = true;\\r\\n        \\r\\n        allocationExpirationTime = block.timestamp + minAllocationDuration;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Peer whitelist removal required to be implemented.\\r\\n     * If no peers should be used, this can have an empty implementation.\\r\\n     *\\r\\n     * Example would be to vote for farms in the governance being removed and exluded.\\r\\n     *\\r\\n     * Must contain a check if the caller has been the governance.\\r\\n     *\\r\\n     * */\\r\\n    function removePeerFromWhitelist(address _peer) override external lock{\\r\\n\\r\\n        require(IUniftyGovernance(msg.sender) == gov, \\\"removePeerFromWhitelist: access denied.\\\");\\r\\n        require(_peer == address(this), \\\"removePeerFromWhitelist: this consumer only allows itself as peer.\\\");\\r\\n        require(isPeer, \\\"removePeerFromWhitelist: peer not whitelisted.\\\");\\r\\n\\r\\n        isPeer = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Called by the governance to signal an allocation event.\\r\\n     *\\r\\n     * The implementation must limit calls to the governance and should\\r\\n     * give the consumer a chance to handle allocations (like timestamp updates)\\r\\n     *\\r\\n     * Returns true if the allocation has been accepted, false if not.\\r\\n     * */\\r\\n    function allocate(address _account, uint256 prevAllocation, address _peer) override external lock returns(bool){\\r\\n\\r\\n        require(IUniftyGovernance(msg.sender) == gov, \\\"allocate: access denied.\\\");\\r\\n        require(_peer == address(this) && isPeer, \\\"allocate: invalid peer.\\\");\\r\\n\\r\\n        (,,,,uint256 amount) = gov.accountInfo(_account);\\r\\n\\r\\n        uint256 alloc = gov.consumerPeerNifAllocation(this, address(this));\\r\\n\\r\\n        if(alloc > nifCap || pausing){\\r\\n\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        accountPrevAmount[_account] = amount;\\r\\n\\r\\n        collectUnt();\\r\\n        accountDebt[_account] = ( collectedUnt * amount ) / 10**18;\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Called by the governance upon staking if the allocation for a user and a peer changes.\\r\\n     * The consumer has then the ability to check what has been changed and act accordingly.\\r\\n     *\\r\\n     * Must contain a check if the caller has been the governance.\\r\\n     * */\\r\\n    function allocationUpdate(address _account, uint256 prevAmount, uint256 prevAllocation, address _peer) override external lock returns(bool, uint256){\\r\\n\\r\\n        require(IUniftyGovernance(msg.sender) == gov, \\\"allocationUpdate: access denied.\\\");\\r\\n        require(_peer == address(this) && isPeer, \\\"allocationUpdate: invalid peer.\\\");\\r\\n\\r\\n        if(accountPrevAmount[_account] == 0){\\r\\n\\r\\n            return (true, 0);\\r\\n        }\\r\\n\\r\\n        (,,,,uint256 amount) = gov.accountInfo(_account);\\r\\n\\r\\n        uint256 alloc = gov.consumerPeerNifAllocation(this, address(this));\\r\\n\\r\\n        if(alloc > nifCap){\\r\\n            \\r\\n            return (false, 0);\\r\\n        }\\r\\n        \\r\\n        collectUnt(prevAllocation);\\r\\n        \\r\\n        uint256 _earned = ( ( collectedUnt * accountPrevAmount[_account] ) / 10**18 ) - accountDebt[_account];\\r\\n\\r\\n        accountDebt[_account] = ( collectedUnt * amount ) / 10**18;\\r\\n        \\r\\n        accountPrevAmount[_account] = amount;\\r\\n        \\r\\n        uint256 actual = _earned;\\r\\n        \\r\\n        if(!frozen(_account) && !pausing){\\r\\n\\r\\n            actual = payout(_account, _earned);\\r\\n\\r\\n        }else{\\r\\n\\r\\n            accountCredit[_account] += _earned;\\r\\n\\r\\n            emit Credited(_account, _earned);\\r\\n        }\\r\\n\\r\\n        return (true, actual);\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Called by the governance to signal an dellocation event.\\r\\n     *\\r\\n     * The implementation must limit calls to the governance and should\\r\\n     * give the consumer a chance to handle allocations (like timestamp updates)\\r\\n     *\\r\\n     * */\\r\\n    function dellocate(address _account, uint256 prevAllocation, address _peer) override external lock returns(uint256){\\r\\n\\r\\n        require(IUniftyGovernance(msg.sender) == gov, \\\"dellocate: access denied.\\\");\\r\\n        require(_peer == address(this) && isPeer, \\\"dellocate: invalid peer.\\\");\\r\\n\\r\\n        if(accountPrevAmount[_account] == 0){\\r\\n\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        collectUnt(prevAllocation);\\r\\n        \\r\\n        uint256 _earned = ( ( collectedUnt * accountPrevAmount[_account] ) / 10**18 ) - accountDebt[_account];\\r\\n        accountDebt[_account] = 0;\\r\\n        accountPrevAmount[_account] = 0;\\r\\n        \\r\\n        uint256 actual = _earned;\\r\\n        \\r\\n        if(pausing){\\r\\n            \\r\\n            accountCredit[_account] += _earned;\\r\\n\\r\\n            emit Credited(_account, _earned);\\r\\n            \\r\\n        }else{\\r\\n            \\r\\n            actual = payout(_account, _earned);\\r\\n        }\\r\\n        \\r\\n        return actual;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Must return the time in seconds that is left until the allocation\\r\\n     * of a user to the peer he is allocating to expires.\\r\\n     *\\r\\n     * */\\r\\n    function timeToUnfreeze(address _account) override external view returns(uint256){\\r\\n\\r\\n        (IUniftyGovernanceConsumer con, address peer,,,) = gov.accountInfo(_account);\\r\\n\\r\\n        if(con != this || peer != address(this) || !isPeer || pausing){\\r\\n\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 _target = allocationExpirationTime + graceTime;\\r\\n        return _target >= block.timestamp ? _target - block.timestamp : 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Called by the governance to determine if allocated stakes of an account in the governance should stay frozen.\\r\\n     * If this returns true, the governance won't release NIF upon unstaking.\\r\\n     *\\r\\n     * */\\r\\n    function frozen(address _account) override public view returns(bool){\\r\\n\\r\\n        (IUniftyGovernanceConsumer con, address peer,,,) = gov.accountInfo(_account);\\r\\n\\r\\n        // since this consumer is also the only peer, we can return false if the account is not allocating to it.\\r\\n        // in more complex implementation, this consumer would need to check for the actual existence of the peer given.\\r\\n        // nevertheless we check if this consumer is being whitelisted to respect governance decisions.\\r\\n        if(con != this || peer != address(this) || !isPeer || pausing){\\r\\n\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        if( block.timestamp > allocationExpirationTime + graceTime ){\\r\\n\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * The name of this consumer must be requestable.\\r\\n     *\\r\\n     * This information is supposed to be used in clients.\\r\\n     *\\r\\n     * */\\r\\n    function name() override view external returns(string memory){\\r\\n\\r\\n        return consumerName;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * The description for this consumer must be requestable.\\r\\n     *\\r\\n     * This information is supposed to be used in clients.\\r\\n     *\\r\\n     * */\\r\\n    function description() override view external returns(string memory){\\r\\n\\r\\n        return consumerDscription;\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * Returns true if the peer is whitelisted, otherwise false.\\r\\n     *\\r\\n     * */\\r\\n    function peerWhitelisted(address _peer) override view external returns(bool){\\r\\n\\r\\n        return _peer == address(this) && isPeer;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Should return a URI, pointing to a json file in the format:\\r\\n     *\\r\\n     * {\\r\\n     *   name : '',\\r\\n     *   description : '',\\r\\n     *   external_link : '',\\r\\n     * }\\r\\n     *\\r\\n     * Can throw an error if the peer is not whitelisted or return an empty string if there is no further information.\\r\\n     * Since this is supposed to be called by clients, those have to catch errors and handle empty return values themselves.\\r\\n     *\\r\\n     * */\\r\\n    function peerUri(address _peer) override external view returns(string memory){\\r\\n\\r\\n        return _peer == address(this) && isPeer ? uriPeer : \\\"\\\";\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * If there are any nif caps per peer, this function should return those.\\r\\n     * \\r\\n     * */\\r\\n    function peerNifCap(address _peer) override external view returns(uint256){\\r\\n        \\r\\n        if(_peer != address(this) || !isPeer){\\r\\n\\r\\n            return 0;\\r\\n        }\\r\\n        \\r\\n        return nifCap;\\r\\n        \\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/token/ERC721/presets/IERC20Simple.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev Simple Interface with a subset of the ERC20 standard as defined in the EIP needed by the DAO (and not more).\\r\\n */\\r\\ninterface IERC20Simple {\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\"\r\n    },\r\n    \"contracts/token/ERC721/presets/IUniftyGovernance.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./IUniftyGovernanceConsumer.sol\\\";\\r\\n\\r\\ninterface IUniftyGovernance{\\r\\n\\r\\n    /**\\r\\n     * Returns the current epoch number.\\r\\n     * */\\r\\n    function epoch() external returns(uint256);\\r\\n    \\r\\n    /**\\r\\n     * Returns the overall grantable $UNT left in the governance contract.\\r\\n     * */\\r\\n    function grantableUnt() external returns(uint256);\\r\\n    \\r\\n    /**\\r\\n     * Can only be called by a registered consumer and _amount cannot exceed the granted $UNT\\r\\n     * as per current emission rate.\\r\\n     * */\\r\\n    function mintUnt(uint256 _amount) external;\\r\\n    \\r\\n    /**\\r\\n     * Returns the account info for the given \\r\\n     * _account parameters:\\r\\n     * \\r\\n     * ( \\r\\n     *  IUniftyGovernanceConsumer consumer,\\r\\n     *  address peer,  \\r\\n     *  uint256 allocationTime,\\r\\n     *  uint256 unstakableFrom,\\r\\n     *  uint256 amount\\r\\n     * )\\r\\n     * */\\r\\n    function accountInfo(address _account) external view returns(IUniftyGovernanceConsumer, address, uint256, uint256, uint256);\\r\\n    \\r\\n    /**\\r\\n     * Returns the consumer info for the given _consumer.\\r\\n     * \\r\\n     * (\\r\\n     *  uint256 grantStartTime,\\r\\n     *  uint256 grantRateSeconds,\\r\\n     *  uint256 grantSizeUnt,\\r\\n     *  address[] peers\\r\\n     * )\\r\\n     * \\r\\n     * */\\r\\n    function consumerInfo(IUniftyGovernanceConsumer _consumer) external view returns(uint256, uint256, uint256, address[] calldata, string[] calldata);\\r\\n    \\r\\n    /**\\r\\n     * Returns the amount of accounts allocating to the given _peer of _consumer.\\r\\n     * */\\r\\n    function nifAllocationLength(IUniftyGovernanceConsumer _consumer, address _peer) external view returns(uint256);\\r\\n    \\r\\n    /**\\r\\n     * Returns the currently available $UNT for the given _consumer.\\r\\n     * */\\r\\n    function earnedUnt(IUniftyGovernanceConsumer _consumer) external view returns(uint256);\\r\\n    \\r\\n    /**\\r\\n     * Returns true if the governance is pausing. And fals if not.\\r\\n     * It is recommended but not mandatory to take this into account in your own implemenation.\\r\\n     * */\\r\\n    function isPausing() external view returns(bool);\\r\\n    \\r\\n    /**\\r\\n     * The amount of $NIF being allocated to the given _peer of _consumer.\\r\\n     * */\\r\\n    function consumerPeerNifAllocation(IUniftyGovernanceConsumer _consumer, address _peer) external view returns(uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/token/ERC721/presets/IUniftyGovernanceConsumer.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\r\\n\\r\\n/**\\r\\n * Mandatory interface for a UniftyGovernanceConsumer.\\r\\n * \\r\\n * */\\r\\ninterface IUniftyGovernanceConsumer{\\r\\n    \\r\\n    /**\\r\\n     * Must be emitted in withdraw() function.\\r\\n     * \\r\\n     * */\\r\\n    event Withdrawn(address indexed user, uint256 untEarned);\\r\\n\\r\\n    /**\\r\\n     * The name of this consumer must be requestable.\\r\\n     * \\r\\n     * This information is supposed to be used in clients.\\r\\n     * \\r\\n     * */\\r\\n    function name() external view returns(string calldata);\\r\\n    \\r\\n    /**\\r\\n     * The description for this consumer must be requestable.\\r\\n     * \\r\\n     * This information is supposed to be used in clients.\\r\\n     * \\r\\n     * */\\r\\n    function description() external view returns(string calldata);\\r\\n    \\r\\n    /**\\r\\n     * Peer whitelist required to be implemented.\\r\\n     * If no peers should be used, this can have an empty implementation.\\r\\n     * \\r\\n     * Example would be to vote for farms in the governance being included.\\r\\n     * Accepted peers can then be added to the consumer's internal whitelist and get further benefits like UNT.\\r\\n     * \\r\\n     * Must contain a check if the caller has been the governance.\\r\\n     * \\r\\n     * */\\r\\n    function whitelistPeer(address _peer) external;\\r\\n    \\r\\n    /**\\r\\n     * Peer whitelist removal required to be implemented.\\r\\n     * If no peers should be used, this can have an empty implementation.\\r\\n     * \\r\\n     * Example would be to vote for farms in the governance being removed and exluded.\\r\\n     * \\r\\n     * Must contain a check if the caller has been the governance.\\r\\n     * \\r\\n     * */\\r\\n    function removePeerFromWhitelist(address _peer) external;\\r\\n    \\r\\n    /**\\r\\n     * Called by the governance to signal an allocation event.\\r\\n     * \\r\\n     * The implementation must limit calls to the governance and should\\r\\n     * give the consumer a chance to handle allocations (like timestamp updates)\\r\\n     * \\r\\n     * Returns true if the allocation has been accepted, false if not.\\r\\n     * \\r\\n     * Must contain a check if the caller has been the governance.\\r\\n     * */\\r\\n    function allocate(address _account, uint256 prevAllocation, address _peer) external returns(bool);\\r\\n    \\r\\n    /**\\r\\n     * Called by the governance upon staking if the allocation for a user and a peer changes.\\r\\n     * The consumer has then the ability to check what has been changed and act accordingly.\\r\\n     *\\r\\n     * Must contain a check if the caller has been the governance.\\r\\n     * */\\r\\n    function allocationUpdate(address _account, uint256 prevAmount, uint256 prevAllocation, address _peer) external returns(bool, uint256);\\r\\n    \\r\\n    /**\\r\\n     * Called by the governance to signal an dellocation event.\\r\\n     * \\r\\n     * The implementation must limit calls to the governance and should\\r\\n     * give the consumer a chance to handle allocations (like timestamp updates)\\r\\n     * \\r\\n     * This functions is also called by the governance before it calls allocate.\\r\\n     * This must be akten into account to avoid side-effects.\\r\\n     * */\\r\\n    function dellocate(address _account, uint256 prevAllocation, address _peer) external returns(uint256);\\r\\n    \\r\\n    /**\\r\\n     * Called by the governance to determine if allocated stakes of an account in the governance should stay frozen.\\r\\n     * If this returns true, the governance won't release NIF upon unstaking.\\r\\n     * \\r\\n     * */\\r\\n    function frozen(address _account) external view returns(bool);\\r\\n    \\r\\n    /**\\r\\n     * Returns true if the peer is whitelisted, otherwise false.\\r\\n     * \\r\\n     * */\\r\\n    function peerWhitelisted(address _peer) external view returns(bool);\\r\\n    \\r\\n    /**\\r\\n     * Should return a URI, pointing to a json file in the format:\\r\\n     * \\r\\n     * {\\r\\n     *   name : '',\\r\\n     *   description : '',\\r\\n     *   external_link : '',\\r\\n     * }\\r\\n     * \\r\\n     * Can throw an error if the peer is not whitelisted or return an empty string if there is no further information.\\r\\n     * Since this is supposed to be called by clients, those have to catch errors and handle empty return values themselves.\\r\\n     * \\r\\n     * */\\r\\n    function peerUri(address _peer) external view returns(string calldata);\\r\\n    \\r\\n    /**\\r\\n     * Must return the time in seconds that is left until the allocation \\r\\n     * of a user to the peer he is allocating to expires.\\r\\n     * \\r\\n     * */\\r\\n    function timeToUnfreeze(address _account) external view returns(uint256);\\r\\n    \\r\\n    /**\\r\\n     * _peer parameter to apply the AP info for.\\r\\n     * \\r\\n     * Frontend function to help displaying apr/apy and similar strategies.\\r\\n     *\\r\\n     * The first index of the returned tuple should return \\\"r\\\" if APR or \\\"y\\\" if APY.\\r\\n     * \\r\\n     * The second index of the returned tuple should return the actual APR/Y value for the consumer.\\r\\n     * 18 decimals precision required.\\r\\n     *\\r\\n     * The 2nd uint256[] array should return a list of proposed services for price discovery on the client-side.\\r\\n     *\\r\\n     * 0 = uni-v2 unt/eth\\r\\n     * 1 = uni-v2 unt/usdt\\r\\n     * 2 = uni-v2 unt/usdc\\r\\n     * 3 = uni-v3 unt/eth\\r\\n     * 4 = uni-v3 unt/usdt\\r\\n     * 5 = uni-v3 unt/usdc\\r\\n     * 6 = kucoin unt/usdt\\r\\n     * 7 = binance unt/usdt\\r\\n     *\\r\\n     * The rate and list should be udpatable/extendible through an admin function due to possible updates on the client-side.\\r\\n     * (e.g. adding more exchanges)\\r\\n     *\\r\\n     * */\\r\\n    function apInfo(address _peer) external view returns(string memory, uint256, uint256[] memory);\\r\\n    \\r\\n    /**\\r\\n     * Withdraws UNT rewards for accounts that stake in the governance and allocated their funds to this consumer and peer.\\r\\n     * \\r\\n     * Must return the amount of withdrawn UNT.\\r\\n     * \\r\\n     * */\\r\\n    function withdraw() external returns(uint256);\\r\\n    \\r\\n    /**\\r\\n     * Must return the account's _current_ UNT earnings (as of current blockchain state).\\r\\n     * \\r\\n     * Used in the frontend.\\r\\n     * */\\r\\n    function earned(address _account) external view returns(uint256);\\r\\n    \\r\\n    /**\\r\\n     * Same as earned() except adding a live component that may be inaccurate due to not yet occurred state-changes.\\r\\n     * \\r\\n     * If unsure how to implement, call and return earned() inside.\\r\\n     * \\r\\n     * Used in the frontend.\\r\\n     * */\\r\\n    function earnedLive(address _account) external view returns(uint256);\\r\\n    \\r\\n    /**\\r\\n     * If there are any nif caps per peer, this function should return those.\\r\\n     * \\r\\n     * */\\r\\n    function peerNifCap(address _peer) external view returns(uint256);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract IUniftyGovernance\",\"name\":\"_gov\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_peerUri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_graceTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAllocationDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nifCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_untRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_priceProviders\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"untPaid\",\"type\":\"uint256\"}],\"name\":\"CreditPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"untCredited\",\"type\":\"uint256\"}],\"name\":\"Credited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"untEarned\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountCredit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountPrevAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevAllocation\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_peer\",\"type\":\"address\"}],\"name\":\"allocate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocationExpirationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevAllocation\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_peer\",\"type\":\"address\"}],\"name\":\"allocationUpdate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_peer\",\"type\":\"address\"}],\"name\":\"apInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectedUnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"consumerDscription\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"consumerName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevAllocation\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_peer\",\"type\":\"address\"}],\"name\":\"dellocate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"earnedLive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"frozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"internalType\":\"contract IUniftyGovernance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"graceTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPeer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastCollectionBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastCollectionTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAllocationDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nifCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_peer\",\"type\":\"address\"}],\"name\":\"peerNifCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_peer\",\"type\":\"address\"}],\"name\":\"peerUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_peer\",\"type\":\"address\"}],\"name\":\"peerWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceProviders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_peer\",\"type\":\"address\"}],\"name\":\"removePeerFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IUniftyGovernance\",\"name\":\"_gov\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_graceTime\",\"type\":\"uint256\"}],\"name\":\"setGraceTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minAllocationDuration\",\"type\":\"uint256\"}],\"name\":\"setMinAllocationDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"setNameAndDescription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nifCap\",\"type\":\"uint256\"}],\"name\":\"setNifCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_pausing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_withdrawOnPause\",\"type\":\"bool\"}],\"name\":\"setPausing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setPeerUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_untRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_priceProviders\",\"type\":\"uint256[]\"}],\"name\":\"setUntRateAndPriceProviders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"timeToUnfreeze\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"untAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"untRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uriPeer\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_peer\",\"type\":\"address\"}],\"name\":\"whitelistPeer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawOnPause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LaunchVault","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000cf532428021bed194f3ab8d4c003cc2e2cd8628a0000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000025800000000000000000000000000000000000000000000000000000000000d2f000000000000000000000000000000000000000000000034f086f3b33b68400000000000000000000000000000000000000000000000000000358a7503ce22f4000000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000000c4c61756e6368205661756c74000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000165374616b65204e494620616e64206561726e20554e5400000000000000000000000000000000000000000000000000000000000000000000000000000000004b68747470733a2f2f676174657761792e697066732e696f2f697066732f516d66326d4756615071376f775834616d4b516e69574a6b586558463265717a53554b6a4435636d36354851523800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}