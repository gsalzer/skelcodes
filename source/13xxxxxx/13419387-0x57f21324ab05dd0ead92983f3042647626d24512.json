{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ManualRedeemer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport {IBounty, IBountyRedeemer} from \\\"./Bounty.sol\\\";\\n\\ncontract ManualRedeemer is IBountyRedeemer, ReentrancyGuard {\\n    address bounty;\\n\\n    function manuallyRedeem(\\n        address _bounty,\\n        address _nftContract,\\n        uint256 _tokenID,\\n        uint256 _amount\\n    ) external {\\n        require(\\n            bounty == address(0),\\n            \\\"ManualRedeemer::manuallyRedeem: bounty already set\\\"\\n        );\\n        bounty = _bounty;\\n        bytes memory _callData = abi.encode(msg.sender, _nftContract, _tokenID);\\n        IBounty(_bounty).redeemBounty(this, _amount, _callData);\\n        delete bounty;\\n    }\\n\\n    function onRedeemBounty(address _initiator, bytes calldata _data)\\n        external\\n        payable\\n        override\\n        nonReentrant\\n        returns (bytes32)\\n    {\\n        require(\\n            msg.sender == bounty,\\n            \\\"ManualRedeemer::onRedeemBounty: received call from untrusted bounty\\\"\\n        );\\n        require(\\n            _initiator == address(this),\\n            \\\"ManualRedeemer::onRedeemBounty: only ManualRedeem can originate a redemption\\\"\\n        );\\n\\n        address _nftOwner;\\n        address _nftContract;\\n        uint256 _tokenID;\\n        (_nftOwner, _nftContract, _tokenID) = abi.decode(\\n            _data,\\n            (address, address, uint256)\\n        );\\n\\n        IERC721(_nftContract).safeTransferFrom(_nftOwner, msg.sender, _tokenID);\\n        payable(_nftOwner).transfer(msg.value);\\n\\n        return keccak256(\\\"IBountyRedeemer.onRedeemBounty\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Bounty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"./external/interfaces/IERC721VaultFactory.sol\\\";\\nimport \\\"./external/interfaces/ITokenVault.sol\\\";\\n\\ninterface IBounty {\\n    function redeemBounty(\\n        IBountyRedeemer redeemer,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IBountyRedeemer {\\n    function onRedeemBounty(address initiator, bytes calldata data)\\n        external\\n        payable\\n        returns (bytes32);\\n}\\n\\n// @notice Bounty isn't upgradeable, but because it is deploys as a\\n// static proxy, needs to extend upgradeable contracts.\\ncontract Bounty is\\n    ReentrancyGuardUpgradeable,\\n    ERC721HolderUpgradeable,\\n    IBounty\\n{\\n    using Counters for Counters.Counter;\\n\\n    enum BountyStatus {\\n        ACTIVE,\\n        ACQUIRED,\\n        EXPIRED\\n    }\\n\\n    struct Contribution {\\n        uint256 priorTotalContributed;\\n        uint256 amount;\\n    }\\n\\n    // tokens are minted at a rate of 1 ETH : 1000 tokens\\n    uint16 internal constant TOKEN_SCALE = 1000;\\n    uint8 internal constant RESALE_MULTIPLIER = 2;\\n\\n    // immutable (across clones)\\n    address public immutable gov;\\n    IERC721VaultFactory public immutable tokenVaultFactory;\\n\\n    // immutable (at clone level)\\n    IERC721 public nftContract;\\n    uint256 public nftTokenID;\\n    string public name;\\n    string public symbol;\\n    uint256 public contributionCap;\\n    uint256 public expiryTimestamp;\\n\\n    // mutables\\n    mapping(address => Contribution[]) public contributions;\\n    mapping(address => uint256) public totalContributedByAddress;\\n    mapping(address => bool) public claimed;\\n    uint256 public totalContributed;\\n    uint256 public totalSpent;\\n    ITokenVault public tokenVault;\\n    Counters.Counter public contributors;\\n\\n    event Contributed(address indexed contributor, uint256 amount);\\n\\n    event Acquired(uint256 amount);\\n\\n    event Claimed(\\n        address indexed contributor,\\n        uint256 tokenAmount,\\n        uint256 ethAmount\\n    );\\n\\n    modifier onlyGov() {\\n        require(msg.sender == gov, \\\"Bounty:: only callable by gov\\\");\\n        _;\\n    }\\n\\n    constructor(address _gov, IERC721VaultFactory _tokenVaultFactory) {\\n        gov = _gov;\\n        tokenVaultFactory = _tokenVaultFactory;\\n    }\\n\\n    function initialize(\\n        IERC721 _nftContract,\\n        uint256 _nftTokenID,\\n        string memory _name,\\n        string memory _symbol,\\n        uint256 _contributionCap,\\n        uint256 _duration\\n    ) external initializer {\\n        __ReentrancyGuard_init();\\n        __ERC721Holder_init();\\n\\n        nftContract = _nftContract;\\n        nftTokenID = _nftTokenID;\\n        name = _name;\\n        symbol = _symbol;\\n        contributionCap = _contributionCap;\\n        expiryTimestamp = block.timestamp + _duration;\\n\\n        require(\\n            IERC721(nftContract).ownerOf(nftTokenID) != address(0),\\n            \\\"Bounty::initialize: Token does not exist\\\"\\n        );\\n    }\\n\\n    // @notice contribute (via msg.value) to active bounty as long as the contribution cap has not been reached\\n    function contribute() external payable nonReentrant {\\n        require(\\n            status() == BountyStatus.ACTIVE,\\n            \\\"Bounty::contribute: bounty not active\\\"\\n        );\\n        address _contributor = msg.sender;\\n        uint256 _amount = msg.value;\\n        require(_amount > 0, \\\"Bounty::contribute: must contribute more than 0\\\");\\n        require(\\n            contributionCap == 0 || totalContributed < contributionCap,\\n            \\\"Bounty::contribute: at max contributions\\\"\\n        );\\n\\n        if (contributions[_contributor].length == 0) {\\n            contributors.increment();\\n        }\\n\\n        Contribution memory _contribution = Contribution({\\n            amount: _amount,\\n            priorTotalContributed: totalContributed\\n        });\\n        contributions[_contributor].push(_contribution);\\n        totalContributedByAddress[_contributor] =\\n            totalContributedByAddress[_contributor] +\\n            _amount;\\n        totalContributed = totalContributed + _amount;\\n        emit Contributed(_contributor, _amount);\\n    }\\n\\n    // @notice uses the redeemer to swap `_amount` ETH for the NFT\\n    // @param _redeemer The callback to acquire the NFT\\n    // @param _amount The amount of the bounty to redeem. Must be <= MIN(totalContributed, contributionCap)\\n    // @param _data Arbitrary calldata for the callback\\n    function redeemBounty(\\n        IBountyRedeemer _redeemer,\\n        uint256 _amount,\\n        bytes calldata _data\\n    ) external override nonReentrant {\\n        require(\\n            status() == BountyStatus.ACTIVE,\\n            \\\"Bounty::redeemBounty: bounty isn't active\\\"\\n        );\\n        require(totalSpent == 0, \\\"Bounty::redeemBounty: already acquired\\\");\\n        require(_amount > 0, \\\"Bounty::redeemBounty: cannot redeem for free\\\");\\n        require(\\n            _amount <= totalContributed && _amount <= contributionCap,\\n            \\\"Bounty::redeemBounty: not enough funds\\\"\\n        );\\n        totalSpent = _amount;\\n        require(\\n            _redeemer.onRedeemBounty{value: _amount}(msg.sender, _data) ==\\n                keccak256(\\\"IBountyRedeemer.onRedeemBounty\\\"),\\n            \\\"Bounty::redeemBounty: callback failed\\\"\\n        );\\n        require(\\n            IERC721(nftContract).ownerOf(nftTokenID) == address(this),\\n            \\\"Bounty::redeemBounty: NFT not delivered\\\"\\n        );\\n        emit Acquired(_amount);\\n    }\\n\\n    // @notice Kicks off fractionalization once the NFT is acquired\\n    // @dev Also triggered by the first claim()\\n    function fractionalize() external nonReentrant {\\n        require(\\n            status() == BountyStatus.ACQUIRED,\\n            \\\"Bounty::fractionalize: NFT not yet acquired\\\"\\n        );\\n        _fractionalizeNFTIfNeeded();\\n    }\\n\\n    // @notice Claims any tokens or eth for `_contributor` from active or expired bounties\\n    // @dev msg.sender does not necessarily match `_contributor`\\n    // @dev O(N) where N = number of contributions by `_contributor`\\n    // @param _contributor The address of the contributor to claim tokens for\\n    function claim(address _contributor) external nonReentrant {\\n        BountyStatus _status = status();\\n        require(\\n            _status != BountyStatus.ACTIVE,\\n            \\\"Bounty::claim: bounty still active\\\"\\n        );\\n        require(\\n            totalContributedByAddress[_contributor] != 0,\\n            \\\"Bounty::claim: not a contributor\\\"\\n        );\\n        require(\\n            !claimed[_contributor],\\n            \\\"Bounty::claim: bounty already claimed\\\"\\n        );\\n        claimed[_contributor] = true;\\n\\n        if (_status == BountyStatus.ACQUIRED) {\\n            _fractionalizeNFTIfNeeded();\\n        }\\n\\n        (uint256 _tokenAmount, uint256 _ethAmount) = claimAmounts(_contributor);\\n\\n        if (_ethAmount > 0) {\\n            _transferETH(_contributor, _ethAmount);\\n        }\\n        if (_tokenAmount > 0) {\\n            _transferTokens(_contributor, _tokenAmount);\\n        }\\n        emit Claimed(_contributor, _tokenAmount, _ethAmount);\\n    }\\n\\n    // @notice (GOV ONLY) emergency: withdraw stuck ETH\\n    function emergencyWithdrawETH(uint256 _value) external onlyGov {\\n        _transferETH(gov, _value);\\n    }\\n\\n    // @notice (GOV ONLY) emergency: execute arbitrary calls from contract\\n    function emergencyCall(address _contract, bytes memory _calldata)\\n        external\\n        onlyGov\\n        returns (bool _success, bytes memory _returnData)\\n    {\\n        (_success, _returnData) = _contract.call(_calldata);\\n        require(_success, string(_returnData));\\n    }\\n\\n    // @notice (GOV ONLY) emergency: immediately expires bounty\\n    function emergencyExpire() external onlyGov {\\n        expiryTimestamp = block.timestamp;\\n    }\\n\\n    // @notice The amount of tokens and ETH that can or have been claimed by `_contributor`\\n    // @dev Check `claimed(address)` to see if already claimed\\n    // @param _contributor The address of the contributor to compute amounts for.\\n    function claimAmounts(address _contributor)\\n        public\\n        view\\n        returns (uint256 _tokenAmount, uint256 _ethAmount)\\n    {\\n        require(\\n            status() != BountyStatus.ACTIVE,\\n            \\\"Bounty::claimAmounts: bounty still active\\\"\\n        );\\n        if (totalSpent > 0) {\\n            uint256 _ethUsed = ethUsedForAcquisition(_contributor);\\n            if (_ethUsed > 0) {\\n                _tokenAmount = valueToTokens(_ethUsed);\\n            }\\n            _ethAmount = totalContributedByAddress[_contributor] - _ethUsed;\\n        } else {\\n            _ethAmount = totalContributedByAddress[_contributor];\\n        }\\n    }\\n\\n    // @notice The amount of the contributor's ETH used to acquire the NFT\\n    // @notice Tokens owed will be proportional to eth used.\\n    // @notice ETH contributed = ETH used in acq + ETH left to be claimed\\n    // @param _contributor The address of the contributor to compute eth usd\\n    function ethUsedForAcquisition(address _contributor)\\n        public\\n        view\\n        returns (uint256 _total)\\n    {\\n        require(\\n            totalSpent > 0,\\n            \\\"Bounty::ethUsedForAcquisition: NFT not acquired yet\\\"\\n        );\\n        // load from storage once and reuse\\n        uint256 _totalSpent = totalSpent;\\n        Contribution[] memory _contributions = contributions[_contributor];\\n        for (uint256 _i = 0; _i < _contributions.length; _i++) {\\n            Contribution memory _contribution = _contributions[_i];\\n            if (\\n                _contribution.priorTotalContributed + _contribution.amount <=\\n                _totalSpent\\n            ) {\\n                _total = _total + _contribution.amount;\\n            } else if (_contribution.priorTotalContributed < _totalSpent) {\\n                uint256 _amountUsed = _totalSpent -\\n                    _contribution.priorTotalContributed;\\n                _total = _total + _amountUsed;\\n                break;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    // @notice Computes the status of the bounty\\n    // Valid state transitions:\\n    // EXPIRED\\n    // ACTIVE -> EXPIRED\\n    // ACTIVE -> ACQUIRED\\n    function status() public view returns (BountyStatus) {\\n        if (totalSpent > 0) {\\n            return BountyStatus.ACQUIRED;\\n        } else if (block.timestamp >= expiryTimestamp) {\\n            return BountyStatus.EXPIRED;\\n        } else {\\n            return BountyStatus.ACTIVE;\\n        }\\n    }\\n\\n    // @dev Helper function for translating ETH contributions into token amounts\\n    function valueToTokens(uint256 _value)\\n        public\\n        pure\\n        returns (uint256 _tokens)\\n    {\\n        _tokens = _value * TOKEN_SCALE;\\n    }\\n\\n    function _transferETH(address _to, uint256 _value) internal {\\n        // guard against rounding errors\\n        uint256 _balance = address(this).balance;\\n        if (_value > _balance) {\\n            _value = _balance;\\n        }\\n        payable(_to).transfer(_value);\\n    }\\n\\n    function _transferTokens(address _to, uint256 _value) internal {\\n        // guard against rounding errors\\n        uint256 _balance = tokenVault.balanceOf(address(this));\\n        if (_value > _balance) {\\n            _value = _balance;\\n        }\\n        tokenVault.transfer(_to, _value);\\n    }\\n\\n    function _fractionalizeNFTIfNeeded() internal {\\n        if (address(tokenVault) != address(0)) {\\n            return;\\n        }\\n        IERC721(nftContract).approve(address(tokenVaultFactory), nftTokenID);\\n        uint256 _vaultNumber = tokenVaultFactory.mint(\\n            name,\\n            symbol,\\n            address(nftContract),\\n            nftTokenID,\\n            valueToTokens(totalSpent),\\n            totalSpent * RESALE_MULTIPLIER,\\n            0 // fees\\n        );\\n        tokenVault = ITokenVault(tokenVaultFactory.vaults(_vaultNumber));\\n        tokenVault.updateCurator(address(0));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\\n    function __ERC721Holder_init() internal initializer {\\n        __ERC721Holder_init_unchained();\\n    }\\n\\n    function __ERC721Holder_init_unchained() internal initializer {\\n    }\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes memory\\n    ) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal initializer {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal initializer {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/interfaces/IERC721VaultFactory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\ninterface IERC721VaultFactory {\\n    /// @notice the mapping of vault number to vault address\\n    function vaults(uint256) external returns (address);\\n\\n    /// @notice the function to mint a new vault\\n    /// @param _name the desired name of the vault\\n    /// @param _symbol the desired sumbol of the vault\\n    /// @param _token the ERC721 token address fo the NFT\\n    /// @param _id the uint256 ID of the token\\n    /// @param _listPrice the initial price of the NFT\\n    /// @return the ID of the vault\\n    function mint(\\n        string memory _name,\\n        string memory _symbol,\\n        address _token,\\n        uint256 _id,\\n        uint256 _supply,\\n        uint256 _listPrice,\\n        uint256 _fee\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/external/interfaces/ITokenVault.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.3;\\n\\ninterface ITokenVault {\\n    /// @notice allow curator to update the curator address\\n    /// @param _curator the new curator\\n    function updateCurator(address _curator) external;\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bounty\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"manuallyRedeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initiator\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onRedeemBounty\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"ManualRedeemer","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"1000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}