{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/token/MagicMintFix.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '@solidstate/contracts/token/ERC20/base/ERC20BaseInternal.sol';\\nimport '@solidstate/contracts/utils/ReentrancyGuard.sol';\\n\\nimport './MagicWhitelistStorage.sol';\\n\\ncontract MagicMintFix is ERC20BaseInternal, ReentrancyGuard {\\n    event MintSignal(address minter, address account, uint256 amount);\\n\\n    function mint(address account, uint256 amount) external nonReentrant {\\n        require(\\n            MagicWhitelistStorage.layout().whitelist[msg.sender],\\n            'Magic: sender must be whitelisted'\\n        );\\n\\n        emit MintSignal(msg.sender, account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/base/ERC20BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC20Internal} from '../IERC20Internal.sol';\\nimport {ERC20BaseStorage} from './ERC20BaseStorage.sol';\\n\\n/**\\n * @title Base ERC20 implementation, excluding optional extensions\\n */\\nabstract contract ERC20BaseInternal is IERC20Internal {\\n  /**\\n   * @notice query the total minted token supply\\n   * @return token supply\\n   */\\n  function _totalSupply () virtual internal view returns (uint) {\\n    return ERC20BaseStorage.layout().totalSupply;\\n  }\\n\\n  /**\\n   * @notice query the token balance of given account\\n   * @param account address to query\\n   * @return token balance\\n   */\\n  function _balanceOf (\\n    address account\\n  ) virtual internal view returns (uint) {\\n    return ERC20BaseStorage.layout().balances[account];\\n  }\\n\\n  /**\\n   * @notice enable spender to spend tokens on behalf of holder\\n   * @param holder address on whose behalf tokens may be spent\\n   * @param spender recipient of allowance\\n   * @param amount quantity of tokens approved for spending\\n   */\\n  function _approve (\\n    address holder,\\n    address spender,\\n    uint amount\\n  ) virtual internal {\\n    require(holder != address(0), 'ERC20: approve from the zero address');\\n    require(spender != address(0), 'ERC20: approve to the zero address');\\n\\n    ERC20BaseStorage.layout().allowances[holder][spender] = amount;\\n\\n    emit Approval(holder, spender, amount);\\n  }\\n\\n  /**\\n   * @notice mint tokens for given account\\n   * @param account recipient of minted tokens\\n   * @param amount quantity of tokens minted\\n   */\\n  function _mint (\\n    address account,\\n    uint amount\\n  ) virtual internal {\\n    require(account != address(0), 'ERC20: mint to the zero address');\\n\\n    _beforeTokenTransfer(address(0), account, amount);\\n\\n    ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\n    l.totalSupply += amount;\\n    l.balances[account] += amount;\\n\\n    emit Transfer(address(0), account, amount);\\n  }\\n\\n  /**\\n   * @notice burn tokens held by given account\\n   * @param account holder of burned tokens\\n   * @param amount quantity of tokens burned\\n   */\\n  function _burn (\\n    address account,\\n    uint amount\\n  ) virtual internal {\\n    require(account != address(0), 'ERC20: burn from the zero address');\\n\\n    _beforeTokenTransfer(account, address(0), amount);\\n\\n    ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\n    uint256 balance = l.balances[account];\\n    require(balance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n    unchecked {\\n      l.balances[account] = balance - amount;\\n    }\\n    l.totalSupply -= amount;\\n\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @notice transfer tokens from holder to recipient\\n   * @param holder owner of tokens to be transferred\\n   * @param recipient beneficiary of transfer\\n   * @param amount quantity of tokens transferred\\n   */\\n  function _transfer (\\n    address holder,\\n    address recipient,\\n    uint amount\\n  ) virtual internal {\\n    require(holder != address(0), 'ERC20: transfer from the zero address');\\n    require(recipient != address(0), 'ERC20: transfer to the zero address');\\n\\n    _beforeTokenTransfer(holder, recipient, amount);\\n\\n    ERC20BaseStorage.Layout storage l = ERC20BaseStorage.layout();\\n    uint256 holderBalance = l.balances[holder];\\n    require(holderBalance >= amount, 'ERC20: transfer amount exceeds balance');\\n    unchecked {\\n      l.balances[holder] = holderBalance - amount;\\n    }\\n    l.balances[recipient] += amount;\\n\\n    emit Transfer(holder, recipient, amount);\\n  }\\n\\n  /**\\n   * @notice ERC20 hook, called before all transfers including mint and burn\\n   * @dev function should be overridden and new implementation must call super\\n   * @param from sender of tokens\\n   * @param to receiver of tokens\\n   * @param amount quantity of tokens transferred\\n   */\\n  function _beforeTokenTransfer (\\n    address from,\\n    address to,\\n    uint amount\\n  ) virtual internal {}\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {ReentrancyGuardStorage} from './ReentrancyGuardStorage.sol';\\n\\n/**\\n * @title Utility contract for preventing reentrancy attacks\\n */\\nabstract contract ReentrancyGuard {\\n  modifier nonReentrant () {\\n    ReentrancyGuardStorage.Layout storage l = ReentrancyGuardStorage.layout();\\n    require(l.status != 2, 'ReentrancyGuard: reentrant call');\\n    l.status = 2;\\n    _;\\n    l.status = 1;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/token/MagicWhitelistStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nlibrary MagicWhitelistStorage {\\n    struct Layout {\\n        mapping(address => bool) whitelist;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('treasure.contracts.storage.MagicWhitelist');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/IERC20Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial ERC20 interface needed by internal functions\\n */\\ninterface IERC20Internal {\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC20/base/ERC20BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ERC20BaseStorage {\\n  struct Layout {\\n    mapping (address => uint) balances;\\n    mapping (address => mapping (address => uint)) allowances;\\n    uint totalSupply;\\n  }\\n\\n  bytes32 internal constant STORAGE_SLOT = keccak256(\\n    'solidstate.contracts.storage.ERC20Base'\\n  );\\n\\n  function layout () internal pure returns (Layout storage l) {\\n    bytes32 slot = STORAGE_SLOT;\\n    assembly { l.slot := slot }\\n  }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/ReentrancyGuardStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ReentrancyGuardStorage {\\n  struct Layout {\\n    uint status;\\n  }\\n\\n  bytes32 internal constant STORAGE_SLOT = keccak256(\\n    'solidstate.contracts.storage.ReentrancyGuard'\\n  );\\n\\n  function layout () internal pure returns (Layout storage l) {\\n    bytes32 slot = STORAGE_SLOT;\\n    assembly { l.slot := slot }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MintSignal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MagicMintFix","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}