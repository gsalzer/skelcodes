{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/VestingRouter.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./Vesting.sol\\\";\\n\\ncontract VestingRouter is Ownable, ReentrancyGuard {\\n    event VestingCreated(address indexed beneficiary, address indexed vestingAddress, uint256 tokenAmount);\\n    event VestingReleased(address indexed vestingAddress, uint256 amount);\\n    event VestingRevoked(address indexed vestingAddress);\\n\\n    struct UserInfo {\\n        address activeVesting;\\n        address[] vestingHistory;\\n    }\\n   \\n    IERC20 immutable mxsToken;\\n\\n    mapping(address => UserInfo) userVesting;\\n   \\n    constructor(address _token) {\\n        mxsToken = IERC20(_token);\\n    }\\n   \\n    function createVesting(address _beneficiary, uint256 _tokenAmount, uint256 _duration, uint256 _cliff, bool _revokable) external onlyOwner nonReentrant {\\n        require(userVesting[_beneficiary].activeVesting == address(0), \\\"Address already has an active vesting contract\\\");\\n        Vesting vestingContract = new Vesting(_beneficiary, block.timestamp, _cliff, _duration, _revokable, _tokenAmount, address(mxsToken));\\n        bool transferred = mxsToken.transfer(address(vestingContract), _tokenAmount);\\n        require(transferred, \\\"Token transfer failed\\\");\\n        userVesting[_beneficiary].activeVesting = address(vestingContract);\\n        userVesting[_beneficiary].vestingHistory.push(address(vestingContract));\\n\\n        emit VestingCreated(_beneficiary, address(vestingContract), _tokenAmount);\\n    }\\n   \\n    function userInfo(address account) external view returns(address activeVesting, address[] memory vestingHistory) {\\n        UserInfo memory _userInfo = userVesting[account];\\n        return(_userInfo.activeVesting, _userInfo.vestingHistory);\\n    }\\n   \\n    function userVestingInfo(address _account) external view returns(\\n        address vestingAddress,\\n        uint256 releasedAmount,\\n        uint256 releasableAmount,\\n        uint256 vestedAmount,\\n        uint256 allocation,\\n        uint256 reflectionsReceived,\\n        uint256 timeRemaining,\\n        bool complete\\n    ) {\\n        return vestingInfo(userVesting[_account].activeVesting);\\n    }\\n   \\n    function vestingInfo(address _vestingAddress) public view returns (\\n        address vestingAddress,\\n        uint256 releasedAmount,\\n        uint256 releasableAmount,\\n        uint256 vestedAmount,\\n        uint256 allocation,\\n        uint256 reflectionsReceived,\\n        uint256 timeRemaining,\\n        bool complete\\n    ) {\\n        Vesting vestingContract = Vesting(_vestingAddress);\\n        vestingAddress = _vestingAddress;\\n        releasedAmount = vestingContract.released();\\n        releasableAmount = vestingContract.releasableAmount();\\n        vestedAmount = vestingContract.vestedAmount();\\n        allocation = vestingContract.initialAllocation();\\n        reflectionsReceived = vestingContract.reflections();\\n        timeRemaining = vestingContract.timeRemaining();\\n        complete = vestingContract.complete();\\n    }\\n   \\n    function revoke(address _vestingAddress) external onlyOwner {\\n        Vesting vestingContract = Vesting(_vestingAddress);\\n        require(address(vestingContract) != address(0), \\\"Cannot release an invalid address\\\");\\n        require(!vestingContract.complete(), \\\"Vesting is already complete\\\");\\n       \\n        vestingContract.revoke();\\n        userVesting[vestingContract.beneficiary()].activeVesting = address(0);\\n        emit VestingRevoked(_vestingAddress);\\n    }\\n   \\n    function release(address _vestingAddress) external {\\n        Vesting vestingContract = Vesting(_vestingAddress);\\n        require(address(vestingContract) != address(0), \\\"Cannot release an invalid address\\\");\\n        require(!vestingContract.complete(), \\\"Vesting is already complete\\\");\\n        require(vestingContract.beneficiary() == msg.sender, \\\"Sender must be beneficiary\\\");\\n\\n        uint256 tokenAmount = vestingContract.release();\\n       \\n        if (vestingContract.complete()) {\\n            userVesting[vestingContract.beneficiary()].activeVesting = address(0);\\n        }\\n        emit VestingReleased(_vestingAddress, tokenAmount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Vesting.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\n/**\\n* @title TokenVesting\\n* @dev A token holder contract that can release its token balance gradually like a\\n* typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\\n* owner.\\n*/\\ncontract Vesting is Ownable, ReentrancyGuard {\\n\\n  event Released(uint256 amount);\\n  event Revoked();\\n\\n  // beneficiary of tokens after they are released\\n  address public immutable beneficiary;\\n\\n  uint256 public immutable cliff;\\n  uint256 public immutable start;\\n  uint256 public immutable duration;\\n  uint256 public immutable initialAllocation;\\n \\n  bool public immutable revokable;\\n  bool public revoked;\\n  bool public complete;\\n\\n  uint256 public released;\\n  IERC20 public mxsToken;\\n\\n  /**\\n   * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\\n   * of the balance will have vested.\\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\\n   * @param _duration duration in seconds of the period in which the tokens will vest\\n   * @param _revokable whether the vesting is revocable or not\\n   ** @param _initialAllocation the initial allocation of tokens, used to find reflections\\n   */\\n  constructor(\\n    address _beneficiary,\\n    uint256 _start,\\n    uint256 _cliff,\\n    uint256 _duration,\\n    bool    _revokable,\\n    uint256 _initialAllocation,\\n    address _mxsToken\\n  ) {\\n    require(_beneficiary != address(0), \\\"The beneficiary address is zero address\\\");\\n    require(_cliff <= _duration, \\\"The cliff is larger than duration\\\");\\n   \\n    beneficiary = _beneficiary;\\n    start       = _start;\\n    cliff       = _start + _cliff;\\n    duration    = _duration;\\n    revokable   = _revokable;\\n    initialAllocation = _initialAllocation;\\n    mxsToken = IERC20(_mxsToken);\\n\\n    bool approved = mxsToken.approve( owner(), type(uint256).max);\\n    require(approved, \\\"Transfer token failed\\\");\\n  }\\n\\n  /**\\n   * @notice Transfers vested tokens to beneficiary.\\n   */\\n  function release() onlyOwner external returns(uint256 tokenAmount) {\\n    require(block.timestamp >= cliff, \\\"Cliff has not been reached yet\\\");\\n    tokenAmount = _releaseTo(beneficiary);\\n  }\\n\\n  /**\\n   * @notice Transfers vested tokens to beneficiary.\\n   */\\n  function _releaseTo(address target) internal nonReentrant returns(uint256) {\\n    uint256 unreleased = releasableAmount();\\n    released = released + unreleased;\\n    \\n    bool transferred = mxsToken.transfer(target, unreleased);\\n    require(transferred, \\\"Transfer token failed\\\");\\n\\n    if (mxsToken.balanceOf(address(this)) == 0) {\\n        complete = true;\\n    }\\n    emit Released(released);\\n    return(unreleased);\\n  }\\n\\n  /**\\n   * @notice Allows the owner to revoke the vesting. Tokens already vested are sent to the beneficiary.\\n   */\\n  function revoke() onlyOwner external {\\n    require(revokable, \\\"It's not revokable\\\");\\n    require(!revoked, \\\"It's already revoked\\\");\\n\\n    // Release all vested tokens\\n    _releaseTo(beneficiary);\\n\\n    // Send the remainder to the owner\\n    bool transferred = mxsToken.transfer(owner(), mxsToken.balanceOf(address(this)));\\n    require(transferred, \\\"Transfer token failed\\\");\\n\\n    revoked = true;\\n    complete = true;\\n    emit Revoked();\\n  }\\n\\n\\n  /**\\n   * @dev Calculates the amount that has already vested but hasn't been released yet.\\n   */\\n  function releasableAmount() public view returns (uint256) {\\n    return vestedAmount() - released;\\n  }\\n\\n  /**\\n   * @dev Calculates the amount that has already vested.\\n   */\\n  function vestedAmount() public view returns (uint256) {\\n    if (block.timestamp < cliff) {\\n      return 0;\\n    } else if (block.timestamp >= start + duration || revoked) {\\n      uint256 vested = mxsToken.balanceOf(address(this)) + released;\\n      // vesting is complete, allocate all tokens\\n      return vested;\\n    } else {\\n      uint256 vested = initialAllocation * (block.timestamp - start) / duration;\\n      return vested;\\n    }\\n  }\\n \\n    /**\\n   * @dev Calculates the amount of reflections the vesting contract has received.\\n   */\\n  function reflections() external view returns (uint256) {\\n    return mxsToken.balanceOf(address(this)) + released - initialAllocation;\\n  }\\n\\n    /**\\n   * @dev Calculates the amount of time remaining in seconds.\\n   */\\n  function timeRemaining() external view returns (uint256) {\\n      return start + duration - block.timestamp;\\n  }\\n \\n  /**\\n   * @notice Allow withdrawing any token other than the relevant one\\n   */\\n  function releaseForeignToken(IERC20 _token, uint256 amount) external onlyOwner {\\n    require(_token != mxsToken, \\\"The token is mxsToken\\\");\\n    bool transferred = _token.transfer(owner(), amount);\\n    require(transferred, \\\"Transfer token failed\\\");\\n  }\\n}\\n\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vestingAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"VestingCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vestingAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VestingReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vestingAddress\",\"type\":\"address\"}],\"name\":\"VestingRevoked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cliff\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_revokable\",\"type\":\"bool\"}],\"name\":\"createVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vestingAddress\",\"type\":\"address\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vestingAddress\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"activeVesting\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"vestingHistory\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"userVestingInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vestingAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"releasedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasableAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reflectionsReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeRemaining\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"complete\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vestingAddress\",\"type\":\"address\"}],\"name\":\"vestingInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vestingAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"releasedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releasableAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reflectionsReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeRemaining\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"complete\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VestingRouter","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006b50e1b14c20a1a749a2eaaabf7b38f8f6e19cff","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}