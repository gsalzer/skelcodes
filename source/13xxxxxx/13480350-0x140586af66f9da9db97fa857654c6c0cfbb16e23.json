{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n  Copyright 2019-2022 StarkWare Industries Ltd.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\").\r\n  You may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n  https://www.starkware.co/open-source-license/\r\n\r\n  Unless required by applicable law or agreed to in writing,\r\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions\r\n  and limitations under the License.\r\n*/\r\n// ---------- The following code was auto-generated. PLEASE DO NOT EDIT. ----------\r\n// SPDX-License-Identifier: Apache-2.0.\r\npragma solidity ^0.6.12;\r\n\r\ncontract CpuConstraintPoly {\r\n    // The Memory map during the execution of this contract is as follows:\r\n    // [0x0, 0x20) - periodic_column/pedersen/points/x.\r\n    // [0x20, 0x40) - periodic_column/pedersen/points/y.\r\n    // [0x40, 0x60) - periodic_column/ecdsa/generator_points/x.\r\n    // [0x60, 0x80) - periodic_column/ecdsa/generator_points/y.\r\n    // [0x80, 0xa0) - trace_length.\r\n    // [0xa0, 0xc0) - offset_size.\r\n    // [0xc0, 0xe0) - half_offset_size.\r\n    // [0xe0, 0x100) - initial_ap.\r\n    // [0x100, 0x120) - initial_pc.\r\n    // [0x120, 0x140) - final_ap.\r\n    // [0x140, 0x160) - final_pc.\r\n    // [0x160, 0x180) - memory/multi_column_perm/perm/interaction_elm.\r\n    // [0x180, 0x1a0) - memory/multi_column_perm/hash_interaction_elm0.\r\n    // [0x1a0, 0x1c0) - memory/multi_column_perm/perm/public_memory_prod.\r\n    // [0x1c0, 0x1e0) - rc16/perm/interaction_elm.\r\n    // [0x1e0, 0x200) - rc16/perm/public_memory_prod.\r\n    // [0x200, 0x220) - rc_min.\r\n    // [0x220, 0x240) - rc_max.\r\n    // [0x240, 0x260) - diluted_check/permutation/interaction_elm.\r\n    // [0x260, 0x280) - diluted_check/permutation/public_memory_prod.\r\n    // [0x280, 0x2a0) - diluted_check/first_elm.\r\n    // [0x2a0, 0x2c0) - diluted_check/interaction_z.\r\n    // [0x2c0, 0x2e0) - diluted_check/interaction_alpha.\r\n    // [0x2e0, 0x300) - diluted_check/final_cum_val.\r\n    // [0x300, 0x320) - pedersen/shift_point.x.\r\n    // [0x320, 0x340) - pedersen/shift_point.y.\r\n    // [0x340, 0x360) - initial_pedersen_addr.\r\n    // [0x360, 0x380) - initial_rc_addr.\r\n    // [0x380, 0x3a0) - ecdsa/sig_config.alpha.\r\n    // [0x3a0, 0x3c0) - ecdsa/sig_config.shift_point.x.\r\n    // [0x3c0, 0x3e0) - ecdsa/sig_config.shift_point.y.\r\n    // [0x3e0, 0x400) - ecdsa/sig_config.beta.\r\n    // [0x400, 0x420) - initial_ecdsa_addr.\r\n    // [0x420, 0x440) - initial_bitwise_addr.\r\n    // [0x440, 0x460) - trace_generator.\r\n    // [0x460, 0x480) - oods_point.\r\n    // [0x480, 0x540) - interaction_elements.\r\n    // [0x540, 0x1de0) - coefficients.\r\n    // [0x1de0, 0x3ca0) - oods_values.\r\n    // ----------------------- end of input data - -------------------------\r\n    // [0x3ca0, 0x3cc0) - intermediate_value/cpu/decode/opcode_rc/bit_0.\r\n    // [0x3cc0, 0x3ce0) - intermediate_value/cpu/decode/opcode_rc/bit_2.\r\n    // [0x3ce0, 0x3d00) - intermediate_value/cpu/decode/opcode_rc/bit_4.\r\n    // [0x3d00, 0x3d20) - intermediate_value/cpu/decode/opcode_rc/bit_3.\r\n    // [0x3d20, 0x3d40) - intermediate_value/cpu/decode/flag_op1_base_op0_0.\r\n    // [0x3d40, 0x3d60) - intermediate_value/cpu/decode/opcode_rc/bit_5.\r\n    // [0x3d60, 0x3d80) - intermediate_value/cpu/decode/opcode_rc/bit_6.\r\n    // [0x3d80, 0x3da0) - intermediate_value/cpu/decode/opcode_rc/bit_9.\r\n    // [0x3da0, 0x3dc0) - intermediate_value/cpu/decode/flag_res_op1_0.\r\n    // [0x3dc0, 0x3de0) - intermediate_value/cpu/decode/opcode_rc/bit_7.\r\n    // [0x3de0, 0x3e00) - intermediate_value/cpu/decode/opcode_rc/bit_8.\r\n    // [0x3e00, 0x3e20) - intermediate_value/cpu/decode/flag_pc_update_regular_0.\r\n    // [0x3e20, 0x3e40) - intermediate_value/cpu/decode/opcode_rc/bit_12.\r\n    // [0x3e40, 0x3e60) - intermediate_value/cpu/decode/opcode_rc/bit_13.\r\n    // [0x3e60, 0x3e80) - intermediate_value/cpu/decode/fp_update_regular_0.\r\n    // [0x3e80, 0x3ea0) - intermediate_value/cpu/decode/opcode_rc/bit_1.\r\n    // [0x3ea0, 0x3ec0) - intermediate_value/npc_reg_0.\r\n    // [0x3ec0, 0x3ee0) - intermediate_value/cpu/decode/opcode_rc/bit_10.\r\n    // [0x3ee0, 0x3f00) - intermediate_value/cpu/decode/opcode_rc/bit_11.\r\n    // [0x3f00, 0x3f20) - intermediate_value/cpu/decode/opcode_rc/bit_14.\r\n    // [0x3f20, 0x3f40) - intermediate_value/memory/address_diff_0.\r\n    // [0x3f40, 0x3f60) - intermediate_value/rc16/diff_0.\r\n    // [0x3f60, 0x3f80) - intermediate_value/pedersen/hash0/ec_subset_sum/bit_0.\r\n    // [0x3f80, 0x3fa0) - intermediate_value/pedersen/hash0/ec_subset_sum/bit_neg_0.\r\n    // [0x3fa0, 0x3fc0) - intermediate_value/pedersen/hash1/ec_subset_sum/bit_0.\r\n    // [0x3fc0, 0x3fe0) - intermediate_value/pedersen/hash1/ec_subset_sum/bit_neg_0.\r\n    // [0x3fe0, 0x4000) - intermediate_value/pedersen/hash2/ec_subset_sum/bit_0.\r\n    // [0x4000, 0x4020) - intermediate_value/pedersen/hash2/ec_subset_sum/bit_neg_0.\r\n    // [0x4020, 0x4040) - intermediate_value/pedersen/hash3/ec_subset_sum/bit_0.\r\n    // [0x4040, 0x4060) - intermediate_value/pedersen/hash3/ec_subset_sum/bit_neg_0.\r\n    // [0x4060, 0x4080) - intermediate_value/rc_builtin/value0_0.\r\n    // [0x4080, 0x40a0) - intermediate_value/rc_builtin/value1_0.\r\n    // [0x40a0, 0x40c0) - intermediate_value/rc_builtin/value2_0.\r\n    // [0x40c0, 0x40e0) - intermediate_value/rc_builtin/value3_0.\r\n    // [0x40e0, 0x4100) - intermediate_value/rc_builtin/value4_0.\r\n    // [0x4100, 0x4120) - intermediate_value/rc_builtin/value5_0.\r\n    // [0x4120, 0x4140) - intermediate_value/rc_builtin/value6_0.\r\n    // [0x4140, 0x4160) - intermediate_value/rc_builtin/value7_0.\r\n    // [0x4160, 0x4180) - intermediate_value/ecdsa/signature0/doubling_key/x_squared.\r\n    // [0x4180, 0x41a0) - intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0.\r\n    // [0x41a0, 0x41c0) - intermediate_value/ecdsa/signature0/exponentiate_generator/bit_neg_0.\r\n    // [0x41c0, 0x41e0) - intermediate_value/ecdsa/signature0/exponentiate_key/bit_0.\r\n    // [0x41e0, 0x4200) - intermediate_value/ecdsa/signature0/exponentiate_key/bit_neg_0.\r\n    // [0x4200, 0x4220) - intermediate_value/bitwise/sum_var_0_0.\r\n    // [0x4220, 0x4240) - intermediate_value/bitwise/sum_var_8_0.\r\n    // [0x4240, 0x4740) - expmods.\r\n    // [0x4740, 0x4a60) - denominator_invs.\r\n    // [0x4a60, 0x4d80) - denominators.\r\n    // [0x4d80, 0x4f20) - numerators.\r\n    // [0x4f20, 0x4fe0) - expmod_context.\r\n\r\n    fallback() external {\r\n        uint256 res;\r\n        assembly {\r\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\r\n            // Copy input from calldata to memory.\r\n            calldatacopy(0x0, 0x0, /*Input data size*/ 0x3ca0)\r\n            let point := /*oods_point*/ mload(0x460)\r\n            function expmod(base, exponent, modulus) -> result {\r\n              let p := /*expmod_context*/ 0x4f20\r\n              mstore(p, 0x20)                 // Length of Base.\r\n              mstore(add(p, 0x20), 0x20)      // Length of Exponent.\r\n              mstore(add(p, 0x40), 0x20)      // Length of Modulus.\r\n              mstore(add(p, 0x60), base)      // Base.\r\n              mstore(add(p, 0x80), exponent)  // Exponent.\r\n              mstore(add(p, 0xa0), modulus)   // Modulus.\r\n              // Call modexp precompile.\r\n              if iszero(staticcall(not(0), 0x05, p, 0xc0, p, 0x20)) {\r\n                revert(0, 0)\r\n              }\r\n              result := mload(p)\r\n            }\r\n            {\r\n              // Prepare expmods for denominators and numerators.\r\n\r\n              // expmods[0] = point^trace_length.\r\n              mstore(0x4240, expmod(point, /*trace_length*/ mload(0x80), PRIME))\r\n\r\n              // expmods[1] = point^(trace_length / 16).\r\n              mstore(0x4260, expmod(point, div(/*trace_length*/ mload(0x80), 16), PRIME))\r\n\r\n              // expmods[2] = point^(trace_length / 2).\r\n              mstore(0x4280, expmod(point, div(/*trace_length*/ mload(0x80), 2), PRIME))\r\n\r\n              // expmods[3] = point^(trace_length / 8).\r\n              mstore(0x42a0, expmod(point, div(/*trace_length*/ mload(0x80), 8), PRIME))\r\n\r\n              // expmods[4] = point^(trace_length / 4).\r\n              mstore(0x42c0, expmod(point, div(/*trace_length*/ mload(0x80), 4), PRIME))\r\n\r\n              // expmods[5] = point^(trace_length / 256).\r\n              mstore(0x42e0, expmod(point, div(/*trace_length*/ mload(0x80), 256), PRIME))\r\n\r\n              // expmods[6] = point^(trace_length / 512).\r\n              mstore(0x4300, expmod(point, div(/*trace_length*/ mload(0x80), 512), PRIME))\r\n\r\n              // expmods[7] = point^(trace_length / 128).\r\n              mstore(0x4320, expmod(point, div(/*trace_length*/ mload(0x80), 128), PRIME))\r\n\r\n              // expmods[8] = point^(trace_length / 4096).\r\n              mstore(0x4340, expmod(point, div(/*trace_length*/ mload(0x80), 4096), PRIME))\r\n\r\n              // expmods[9] = point^(trace_length / 32).\r\n              mstore(0x4360, expmod(point, div(/*trace_length*/ mload(0x80), 32), PRIME))\r\n\r\n              // expmods[10] = point^(trace_length / 8192).\r\n              mstore(0x4380, expmod(point, div(/*trace_length*/ mload(0x80), 8192), PRIME))\r\n\r\n              // expmods[11] = point^(trace_length / 1024).\r\n              mstore(0x43a0, expmod(point, div(/*trace_length*/ mload(0x80), 1024), PRIME))\r\n\r\n              // expmods[12] = trace_generator^(15 * trace_length / 16).\r\n              mstore(0x43c0, expmod(/*trace_generator*/ mload(0x440), div(mul(15, /*trace_length*/ mload(0x80)), 16), PRIME))\r\n\r\n              // expmods[13] = trace_generator^(16 * (trace_length / 16 - 1)).\r\n              mstore(0x43e0, expmod(/*trace_generator*/ mload(0x440), mul(16, sub(div(/*trace_length*/ mload(0x80), 16), 1)), PRIME))\r\n\r\n              // expmods[14] = trace_generator^(2 * (trace_length / 2 - 1)).\r\n              mstore(0x4400, expmod(/*trace_generator*/ mload(0x440), mul(2, sub(div(/*trace_length*/ mload(0x80), 2), 1)), PRIME))\r\n\r\n              // expmods[15] = trace_generator^(4 * (trace_length / 4 - 1)).\r\n              mstore(0x4420, expmod(/*trace_generator*/ mload(0x440), mul(4, sub(div(/*trace_length*/ mload(0x80), 4), 1)), PRIME))\r\n\r\n              // expmods[16] = trace_generator^(8 * (trace_length / 8 - 1)).\r\n              mstore(0x4440, expmod(/*trace_generator*/ mload(0x440), mul(8, sub(div(/*trace_length*/ mload(0x80), 8), 1)), PRIME))\r\n\r\n              // expmods[17] = trace_generator^(255 * trace_length / 256).\r\n              mstore(0x4460, expmod(/*trace_generator*/ mload(0x440), div(mul(255, /*trace_length*/ mload(0x80)), 256), PRIME))\r\n\r\n              // expmods[18] = trace_generator^(63 * trace_length / 64).\r\n              mstore(0x4480, expmod(/*trace_generator*/ mload(0x440), div(mul(63, /*trace_length*/ mload(0x80)), 64), PRIME))\r\n\r\n              // expmods[19] = trace_generator^(trace_length / 2).\r\n              mstore(0x44a0, expmod(/*trace_generator*/ mload(0x440), div(/*trace_length*/ mload(0x80), 2), PRIME))\r\n\r\n              // expmods[20] = trace_generator^(128 * (trace_length / 128 - 1)).\r\n              mstore(0x44c0, expmod(/*trace_generator*/ mload(0x440), mul(128, sub(div(/*trace_length*/ mload(0x80), 128), 1)), PRIME))\r\n\r\n              // expmods[21] = trace_generator^(251 * trace_length / 256).\r\n              mstore(0x44e0, expmod(/*trace_generator*/ mload(0x440), div(mul(251, /*trace_length*/ mload(0x80)), 256), PRIME))\r\n\r\n              // expmods[22] = trace_generator^(8192 * (trace_length / 8192 - 1)).\r\n              mstore(0x4500, expmod(/*trace_generator*/ mload(0x440), mul(8192, sub(div(/*trace_length*/ mload(0x80), 8192), 1)), PRIME))\r\n\r\n              // expmods[23] = trace_generator^(3 * trace_length / 4).\r\n              mstore(0x4520, expmod(/*trace_generator*/ mload(0x440), div(mul(3, /*trace_length*/ mload(0x80)), 4), PRIME))\r\n\r\n              // expmods[24] = trace_generator^(1024 * (trace_length / 1024 - 1)).\r\n              mstore(0x4540, expmod(/*trace_generator*/ mload(0x440), mul(1024, sub(div(/*trace_length*/ mload(0x80), 1024), 1)), PRIME))\r\n\r\n              // expmods[25] = trace_generator^(trace_length / 64).\r\n              mstore(0x4560, expmod(/*trace_generator*/ mload(0x440), div(/*trace_length*/ mload(0x80), 64), PRIME))\r\n\r\n              // expmods[26] = trace_generator^(trace_length / 32).\r\n              mstore(0x4580, expmod(/*trace_generator*/ mload(0x440), div(/*trace_length*/ mload(0x80), 32), PRIME))\r\n\r\n              // expmods[27] = trace_generator^(3 * trace_length / 64).\r\n              mstore(0x45a0, expmod(/*trace_generator*/ mload(0x440), div(mul(3, /*trace_length*/ mload(0x80)), 64), PRIME))\r\n\r\n              // expmods[28] = trace_generator^(trace_length / 16).\r\n              mstore(0x45c0, expmod(/*trace_generator*/ mload(0x440), div(/*trace_length*/ mload(0x80), 16), PRIME))\r\n\r\n              // expmods[29] = trace_generator^(5 * trace_length / 64).\r\n              mstore(0x45e0, expmod(/*trace_generator*/ mload(0x440), div(mul(5, /*trace_length*/ mload(0x80)), 64), PRIME))\r\n\r\n              // expmods[30] = trace_generator^(3 * trace_length / 32).\r\n              mstore(0x4600, expmod(/*trace_generator*/ mload(0x440), div(mul(3, /*trace_length*/ mload(0x80)), 32), PRIME))\r\n\r\n              // expmods[31] = trace_generator^(7 * trace_length / 64).\r\n              mstore(0x4620, expmod(/*trace_generator*/ mload(0x440), div(mul(7, /*trace_length*/ mload(0x80)), 64), PRIME))\r\n\r\n              // expmods[32] = trace_generator^(trace_length / 8).\r\n              mstore(0x4640, expmod(/*trace_generator*/ mload(0x440), div(/*trace_length*/ mload(0x80), 8), PRIME))\r\n\r\n              // expmods[33] = trace_generator^(9 * trace_length / 64).\r\n              mstore(0x4660, expmod(/*trace_generator*/ mload(0x440), div(mul(9, /*trace_length*/ mload(0x80)), 64), PRIME))\r\n\r\n              // expmods[34] = trace_generator^(5 * trace_length / 32).\r\n              mstore(0x4680, expmod(/*trace_generator*/ mload(0x440), div(mul(5, /*trace_length*/ mload(0x80)), 32), PRIME))\r\n\r\n              // expmods[35] = trace_generator^(11 * trace_length / 64).\r\n              mstore(0x46a0, expmod(/*trace_generator*/ mload(0x440), div(mul(11, /*trace_length*/ mload(0x80)), 64), PRIME))\r\n\r\n              // expmods[36] = trace_generator^(3 * trace_length / 16).\r\n              mstore(0x46c0, expmod(/*trace_generator*/ mload(0x440), div(mul(3, /*trace_length*/ mload(0x80)), 16), PRIME))\r\n\r\n              // expmods[37] = trace_generator^(13 * trace_length / 64).\r\n              mstore(0x46e0, expmod(/*trace_generator*/ mload(0x440), div(mul(13, /*trace_length*/ mload(0x80)), 64), PRIME))\r\n\r\n              // expmods[38] = trace_generator^(7 * trace_length / 32).\r\n              mstore(0x4700, expmod(/*trace_generator*/ mload(0x440), div(mul(7, /*trace_length*/ mload(0x80)), 32), PRIME))\r\n\r\n              // expmods[39] = trace_generator^(15 * trace_length / 64).\r\n              mstore(0x4720, expmod(/*trace_generator*/ mload(0x440), div(mul(15, /*trace_length*/ mload(0x80)), 64), PRIME))\r\n\r\n            }\r\n\r\n            {\r\n              // Prepare denominators for batch inverse.\r\n\r\n              // Denominator for constraints: 'cpu/decode/opcode_rc/bit', 'pedersen/hash0/ec_subset_sum/booleanity_test', 'pedersen/hash0/ec_subset_sum/add_points/slope', 'pedersen/hash0/ec_subset_sum/add_points/x', 'pedersen/hash0/ec_subset_sum/add_points/y', 'pedersen/hash0/ec_subset_sum/copy_point/x', 'pedersen/hash0/ec_subset_sum/copy_point/y', 'pedersen/hash1/ec_subset_sum/booleanity_test', 'pedersen/hash1/ec_subset_sum/add_points/slope', 'pedersen/hash1/ec_subset_sum/add_points/x', 'pedersen/hash1/ec_subset_sum/add_points/y', 'pedersen/hash1/ec_subset_sum/copy_point/x', 'pedersen/hash1/ec_subset_sum/copy_point/y', 'pedersen/hash2/ec_subset_sum/booleanity_test', 'pedersen/hash2/ec_subset_sum/add_points/slope', 'pedersen/hash2/ec_subset_sum/add_points/x', 'pedersen/hash2/ec_subset_sum/add_points/y', 'pedersen/hash2/ec_subset_sum/copy_point/x', 'pedersen/hash2/ec_subset_sum/copy_point/y', 'pedersen/hash3/ec_subset_sum/booleanity_test', 'pedersen/hash3/ec_subset_sum/add_points/slope', 'pedersen/hash3/ec_subset_sum/add_points/x', 'pedersen/hash3/ec_subset_sum/add_points/y', 'pedersen/hash3/ec_subset_sum/copy_point/x', 'pedersen/hash3/ec_subset_sum/copy_point/y'.\r\n              // denominators[0] = point^trace_length - 1.\r\n              mstore(0x4a60,\r\n                     addmod(/*point^trace_length*/ mload(0x4240), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'cpu/decode/opcode_rc/zero'.\r\n              // denominators[1] = point^(trace_length / 16) - trace_generator^(15 * trace_length / 16).\r\n              mstore(0x4a80,\r\n                     addmod(\r\n                       /*point^(trace_length / 16)*/ mload(0x4260),\r\n                       sub(PRIME, /*trace_generator^(15 * trace_length / 16)*/ mload(0x43c0)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'cpu/decode/opcode_rc_input', 'cpu/decode/flag_op1_base_op0_bit', 'cpu/decode/flag_res_op1_bit', 'cpu/decode/flag_pc_update_regular_bit', 'cpu/decode/fp_update_regular_bit', 'cpu/operands/mem_dst_addr', 'cpu/operands/mem0_addr', 'cpu/operands/mem1_addr', 'cpu/operands/ops_mul', 'cpu/operands/res', 'cpu/update_registers/update_pc/tmp0', 'cpu/update_registers/update_pc/tmp1', 'cpu/update_registers/update_pc/pc_cond_negative', 'cpu/update_registers/update_pc/pc_cond_positive', 'cpu/update_registers/update_ap/ap_update', 'cpu/update_registers/update_fp/fp_update', 'cpu/opcodes/call/push_fp', 'cpu/opcodes/call/push_pc', 'cpu/opcodes/call/off0', 'cpu/opcodes/call/off1', 'cpu/opcodes/call/flags', 'cpu/opcodes/ret/off0', 'cpu/opcodes/ret/off2', 'cpu/opcodes/ret/flags', 'cpu/opcodes/assert_eq/assert_eq', 'ecdsa/signature0/doubling_key/slope', 'ecdsa/signature0/doubling_key/x', 'ecdsa/signature0/doubling_key/y', 'ecdsa/signature0/exponentiate_key/booleanity_test', 'ecdsa/signature0/exponentiate_key/add_points/slope', 'ecdsa/signature0/exponentiate_key/add_points/x', 'ecdsa/signature0/exponentiate_key/add_points/y', 'ecdsa/signature0/exponentiate_key/add_points/x_diff_inv', 'ecdsa/signature0/exponentiate_key/copy_point/x', 'ecdsa/signature0/exponentiate_key/copy_point/y'.\r\n              // denominators[2] = point^(trace_length / 16) - 1.\r\n              mstore(0x4aa0,\r\n                     addmod(/*point^(trace_length / 16)*/ mload(0x4260), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'initial_ap', 'initial_fp', 'initial_pc', 'memory/multi_column_perm/perm/init0', 'memory/initial_addr', 'rc16/perm/init0', 'rc16/minimum', 'diluted_check/permutation/init0', 'diluted_check/init', 'diluted_check/first_element', 'pedersen/init_addr', 'rc_builtin/init_addr', 'ecdsa/init_addr', 'bitwise/init_var_pool_addr'.\r\n              // denominators[3] = point - 1.\r\n              mstore(0x4ac0,\r\n                     addmod(point, sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'final_ap', 'final_fp', 'final_pc'.\r\n              // denominators[4] = point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              mstore(0x4ae0,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(16 * (trace_length / 16 - 1))*/ mload(0x43e0)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'memory/multi_column_perm/perm/step0', 'memory/diff_is_bit', 'memory/is_func'.\r\n              // denominators[5] = point^(trace_length / 2) - 1.\r\n              mstore(0x4b00,\r\n                     addmod(/*point^(trace_length / 2)*/ mload(0x4280), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'memory/multi_column_perm/perm/last'.\r\n              // denominators[6] = point - trace_generator^(2 * (trace_length / 2 - 1)).\r\n              mstore(0x4b20,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(2 * (trace_length / 2 - 1))*/ mload(0x4400)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'public_memory_addr_zero', 'public_memory_value_zero', 'diluted_check/permutation/step0', 'diluted_check/step'.\r\n              // denominators[7] = point^(trace_length / 8) - 1.\r\n              mstore(0x4b40,\r\n                     addmod(/*point^(trace_length / 8)*/ mload(0x42a0), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'rc16/perm/step0', 'rc16/diff_is_bit'.\r\n              // denominators[8] = point^(trace_length / 4) - 1.\r\n              mstore(0x4b60,\r\n                     addmod(/*point^(trace_length / 4)*/ mload(0x42c0), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'rc16/perm/last', 'rc16/maximum'.\r\n              // denominators[9] = point - trace_generator^(4 * (trace_length / 4 - 1)).\r\n              mstore(0x4b80,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(4 * (trace_length / 4 - 1))*/ mload(0x4420)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'diluted_check/permutation/last', 'diluted_check/last'.\r\n              // denominators[10] = point - trace_generator^(8 * (trace_length / 8 - 1)).\r\n              mstore(0x4ba0,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(8 * (trace_length / 8 - 1))*/ mload(0x4440)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'pedersen/hash0/ec_subset_sum/bit_unpacking/last_one_is_zero', 'pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones0', 'pedersen/hash0/ec_subset_sum/bit_unpacking/cumulative_bit192', 'pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones192', 'pedersen/hash0/ec_subset_sum/bit_unpacking/cumulative_bit196', 'pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones196', 'pedersen/hash0/copy_point/x', 'pedersen/hash0/copy_point/y', 'pedersen/hash1/ec_subset_sum/bit_unpacking/last_one_is_zero', 'pedersen/hash1/ec_subset_sum/bit_unpacking/zeroes_between_ones0', 'pedersen/hash1/ec_subset_sum/bit_unpacking/cumulative_bit192', 'pedersen/hash1/ec_subset_sum/bit_unpacking/zeroes_between_ones192', 'pedersen/hash1/ec_subset_sum/bit_unpacking/cumulative_bit196', 'pedersen/hash1/ec_subset_sum/bit_unpacking/zeroes_between_ones196', 'pedersen/hash1/copy_point/x', 'pedersen/hash1/copy_point/y', 'pedersen/hash2/ec_subset_sum/bit_unpacking/last_one_is_zero', 'pedersen/hash2/ec_subset_sum/bit_unpacking/zeroes_between_ones0', 'pedersen/hash2/ec_subset_sum/bit_unpacking/cumulative_bit192', 'pedersen/hash2/ec_subset_sum/bit_unpacking/zeroes_between_ones192', 'pedersen/hash2/ec_subset_sum/bit_unpacking/cumulative_bit196', 'pedersen/hash2/ec_subset_sum/bit_unpacking/zeroes_between_ones196', 'pedersen/hash2/copy_point/x', 'pedersen/hash2/copy_point/y', 'pedersen/hash3/ec_subset_sum/bit_unpacking/last_one_is_zero', 'pedersen/hash3/ec_subset_sum/bit_unpacking/zeroes_between_ones0', 'pedersen/hash3/ec_subset_sum/bit_unpacking/cumulative_bit192', 'pedersen/hash3/ec_subset_sum/bit_unpacking/zeroes_between_ones192', 'pedersen/hash3/ec_subset_sum/bit_unpacking/cumulative_bit196', 'pedersen/hash3/ec_subset_sum/bit_unpacking/zeroes_between_ones196', 'pedersen/hash3/copy_point/x', 'pedersen/hash3/copy_point/y', 'bitwise/step_var_pool_addr', 'bitwise/partition'.\r\n              // denominators[11] = point^(trace_length / 256) - 1.\r\n              mstore(0x4bc0,\r\n                     addmod(/*point^(trace_length / 256)*/ mload(0x42e0), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'pedersen/hash0/ec_subset_sum/bit_extraction_end', 'pedersen/hash1/ec_subset_sum/bit_extraction_end', 'pedersen/hash2/ec_subset_sum/bit_extraction_end', 'pedersen/hash3/ec_subset_sum/bit_extraction_end'.\r\n              // denominators[12] = point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\r\n              mstore(0x4be0,\r\n                     addmod(\r\n                       /*point^(trace_length / 256)*/ mload(0x42e0),\r\n                       sub(PRIME, /*trace_generator^(63 * trace_length / 64)*/ mload(0x4480)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'pedersen/hash0/ec_subset_sum/zeros_tail', 'pedersen/hash1/ec_subset_sum/zeros_tail', 'pedersen/hash2/ec_subset_sum/zeros_tail', 'pedersen/hash3/ec_subset_sum/zeros_tail'.\r\n              // denominators[13] = point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              mstore(0x4c00,\r\n                     addmod(\r\n                       /*point^(trace_length / 256)*/ mload(0x42e0),\r\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4460)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'pedersen/hash0/init/x', 'pedersen/hash0/init/y', 'pedersen/hash1/init/x', 'pedersen/hash1/init/y', 'pedersen/hash2/init/x', 'pedersen/hash2/init/y', 'pedersen/hash3/init/x', 'pedersen/hash3/init/y', 'pedersen/input0_value0', 'pedersen/input0_value1', 'pedersen/input0_value2', 'pedersen/input0_value3', 'pedersen/input1_value0', 'pedersen/input1_value1', 'pedersen/input1_value2', 'pedersen/input1_value3', 'pedersen/output_value0', 'pedersen/output_value1', 'pedersen/output_value2', 'pedersen/output_value3'.\r\n              // denominators[14] = point^(trace_length / 512) - 1.\r\n              mstore(0x4c20,\r\n                     addmod(/*point^(trace_length / 512)*/ mload(0x4300), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'pedersen/input0_addr', 'pedersen/input1_addr', 'pedersen/output_addr', 'rc_builtin/value', 'rc_builtin/addr_step'.\r\n              // denominators[15] = point^(trace_length / 128) - 1.\r\n              mstore(0x4c40,\r\n                     addmod(/*point^(trace_length / 128)*/ mload(0x4320), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'ecdsa/signature0/exponentiate_generator/booleanity_test', 'ecdsa/signature0/exponentiate_generator/add_points/slope', 'ecdsa/signature0/exponentiate_generator/add_points/x', 'ecdsa/signature0/exponentiate_generator/add_points/y', 'ecdsa/signature0/exponentiate_generator/add_points/x_diff_inv', 'ecdsa/signature0/exponentiate_generator/copy_point/x', 'ecdsa/signature0/exponentiate_generator/copy_point/y'.\r\n              // denominators[16] = point^(trace_length / 32) - 1.\r\n              mstore(0x4c60,\r\n                     addmod(/*point^(trace_length / 32)*/ mload(0x4360), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'ecdsa/signature0/exponentiate_generator/bit_extraction_end'.\r\n              // denominators[17] = point^(trace_length / 8192) - trace_generator^(251 * trace_length / 256).\r\n              mstore(0x4c80,\r\n                     addmod(\r\n                       /*point^(trace_length / 8192)*/ mload(0x4380),\r\n                       sub(PRIME, /*trace_generator^(251 * trace_length / 256)*/ mload(0x44e0)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'ecdsa/signature0/exponentiate_generator/zeros_tail'.\r\n              // denominators[18] = point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\r\n              mstore(0x4ca0,\r\n                     addmod(\r\n                       /*point^(trace_length / 8192)*/ mload(0x4380),\r\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4460)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'ecdsa/signature0/exponentiate_key/bit_extraction_end'.\r\n              // denominators[19] = point^(trace_length / 4096) - trace_generator^(251 * trace_length / 256).\r\n              mstore(0x4cc0,\r\n                     addmod(\r\n                       /*point^(trace_length / 4096)*/ mload(0x4340),\r\n                       sub(PRIME, /*trace_generator^(251 * trace_length / 256)*/ mload(0x44e0)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'ecdsa/signature0/exponentiate_key/zeros_tail'.\r\n              // denominators[20] = point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\r\n              mstore(0x4ce0,\r\n                     addmod(\r\n                       /*point^(trace_length / 4096)*/ mload(0x4340),\r\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4460)),\r\n                       PRIME))\r\n\r\n              // Denominator for constraints: 'ecdsa/signature0/init_gen/x', 'ecdsa/signature0/init_gen/y', 'ecdsa/signature0/add_results/slope', 'ecdsa/signature0/add_results/x', 'ecdsa/signature0/add_results/y', 'ecdsa/signature0/add_results/x_diff_inv', 'ecdsa/signature0/extract_r/slope', 'ecdsa/signature0/extract_r/x', 'ecdsa/signature0/extract_r/x_diff_inv', 'ecdsa/signature0/z_nonzero', 'ecdsa/signature0/q_on_curve/x_squared', 'ecdsa/signature0/q_on_curve/on_curve', 'ecdsa/message_addr', 'ecdsa/pubkey_addr', 'ecdsa/message_value0', 'ecdsa/pubkey_value0'.\r\n              // denominators[21] = point^(trace_length / 8192) - 1.\r\n              mstore(0x4d00,\r\n                     addmod(/*point^(trace_length / 8192)*/ mload(0x4380), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'ecdsa/signature0/init_key/x', 'ecdsa/signature0/init_key/y', 'ecdsa/signature0/r_and_w_nonzero'.\r\n              // denominators[22] = point^(trace_length / 4096) - 1.\r\n              mstore(0x4d20,\r\n                     addmod(/*point^(trace_length / 4096)*/ mload(0x4340), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'bitwise/x_or_y_addr', 'bitwise/next_var_pool_addr', 'bitwise/or_is_and_plus_xor', 'bitwise/unique_unpacking192', 'bitwise/unique_unpacking193', 'bitwise/unique_unpacking194', 'bitwise/unique_unpacking195'.\r\n              // denominators[23] = point^(trace_length / 1024) - 1.\r\n              mstore(0x4d40,\r\n                     addmod(/*point^(trace_length / 1024)*/ mload(0x43a0), sub(PRIME, 1), PRIME))\r\n\r\n              // Denominator for constraints: 'bitwise/addition_is_xor_with_and'.\r\n              // denominators[24] = (point^(trace_length / 1024) - 1) * (point^(trace_length / 1024) - trace_generator^(trace_length / 64)) * (point^(trace_length / 1024) - trace_generator^(trace_length / 32)) * (point^(trace_length / 1024) - trace_generator^(3 * trace_length / 64)) * (point^(trace_length / 1024) - trace_generator^(trace_length / 16)) * (point^(trace_length / 1024) - trace_generator^(5 * trace_length / 64)) * (point^(trace_length / 1024) - trace_generator^(3 * trace_length / 32)) * (point^(trace_length / 1024) - trace_generator^(7 * trace_length / 64)) * (point^(trace_length / 1024) - trace_generator^(trace_length / 8)) * (point^(trace_length / 1024) - trace_generator^(9 * trace_length / 64)) * (point^(trace_length / 1024) - trace_generator^(5 * trace_length / 32)) * (point^(trace_length / 1024) - trace_generator^(11 * trace_length / 64)) * (point^(trace_length / 1024) - trace_generator^(3 * trace_length / 16)) * (point^(trace_length / 1024) - trace_generator^(13 * trace_length / 64)) * (point^(trace_length / 1024) - trace_generator^(7 * trace_length / 32)) * (point^(trace_length / 1024) - trace_generator^(15 * trace_length / 64)).\r\n              {\r\n                let denominator := mulmod(\r\n                    mulmod(\r\n                      mulmod(\r\n                        addmod(/*point^(trace_length / 1024)*/ mload(0x43a0), sub(PRIME, 1), PRIME),\r\n                        addmod(\r\n                          /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                          sub(PRIME, /*trace_generator^(trace_length / 64)*/ mload(0x4560)),\r\n                          PRIME),\r\n                        PRIME),\r\n                      addmod(\r\n                        /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                        sub(PRIME, /*trace_generator^(trace_length / 32)*/ mload(0x4580)),\r\n                        PRIME),\r\n                      PRIME),\r\n                    addmod(\r\n                      /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                      sub(PRIME, /*trace_generator^(3 * trace_length / 64)*/ mload(0x45a0)),\r\n                      PRIME),\r\n                    PRIME)\r\n                denominator := mulmod(\r\n                  denominator,\r\n                  mulmod(\r\n                    mulmod(\r\n                      mulmod(\r\n                        addmod(\r\n                          /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                          sub(PRIME, /*trace_generator^(trace_length / 16)*/ mload(0x45c0)),\r\n                          PRIME),\r\n                        addmod(\r\n                          /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                          sub(PRIME, /*trace_generator^(5 * trace_length / 64)*/ mload(0x45e0)),\r\n                          PRIME),\r\n                        PRIME),\r\n                      addmod(\r\n                        /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                        sub(PRIME, /*trace_generator^(3 * trace_length / 32)*/ mload(0x4600)),\r\n                        PRIME),\r\n                      PRIME),\r\n                    addmod(\r\n                      /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                      sub(PRIME, /*trace_generator^(7 * trace_length / 64)*/ mload(0x4620)),\r\n                      PRIME),\r\n                    PRIME),\r\n                  PRIME)\r\n                denominator := mulmod(\r\n                  denominator,\r\n                  mulmod(\r\n                    mulmod(\r\n                      mulmod(\r\n                        addmod(\r\n                          /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                          sub(PRIME, /*trace_generator^(trace_length / 8)*/ mload(0x4640)),\r\n                          PRIME),\r\n                        addmod(\r\n                          /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                          sub(PRIME, /*trace_generator^(9 * trace_length / 64)*/ mload(0x4660)),\r\n                          PRIME),\r\n                        PRIME),\r\n                      addmod(\r\n                        /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                        sub(PRIME, /*trace_generator^(5 * trace_length / 32)*/ mload(0x4680)),\r\n                        PRIME),\r\n                      PRIME),\r\n                    addmod(\r\n                      /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                      sub(PRIME, /*trace_generator^(11 * trace_length / 64)*/ mload(0x46a0)),\r\n                      PRIME),\r\n                    PRIME),\r\n                  PRIME)\r\n                denominator := mulmod(\r\n                  denominator,\r\n                  mulmod(\r\n                    mulmod(\r\n                      mulmod(\r\n                        addmod(\r\n                          /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                          sub(PRIME, /*trace_generator^(3 * trace_length / 16)*/ mload(0x46c0)),\r\n                          PRIME),\r\n                        addmod(\r\n                          /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                          sub(PRIME, /*trace_generator^(13 * trace_length / 64)*/ mload(0x46e0)),\r\n                          PRIME),\r\n                        PRIME),\r\n                      addmod(\r\n                        /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                        sub(PRIME, /*trace_generator^(7 * trace_length / 32)*/ mload(0x4700)),\r\n                        PRIME),\r\n                      PRIME),\r\n                    addmod(\r\n                      /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                      sub(PRIME, /*trace_generator^(15 * trace_length / 64)*/ mload(0x4720)),\r\n                      PRIME),\r\n                    PRIME),\r\n                  PRIME)\r\n                mstore(0x4d60, denominator)\r\n              }\r\n\r\n            }\r\n\r\n            {\r\n              // Compute the inverses of the denominators into denominatorInvs using batch inverse.\r\n\r\n              // Start by computing the cumulative product.\r\n              // Let (d_0, d_1, d_2, ..., d_{n-1}) be the values in denominators. After this loop\r\n              // denominatorInvs will be (1, d_0, d_0 * d_1, ...) and prod will contain the value of\r\n              // d_0 * ... * d_{n-1}.\r\n              // Compute the offset between the partialProducts array and the input values array.\r\n              let productsToValuesOffset := 0x320\r\n              let prod := 1\r\n              let partialProductEndPtr := 0x4a60\r\n              for { let partialProductPtr := 0x4740 }\r\n                  lt(partialProductPtr, partialProductEndPtr)\r\n                  { partialProductPtr := add(partialProductPtr, 0x20) } {\r\n                  mstore(partialProductPtr, prod)\r\n                  // prod *= d_{i}.\r\n                  prod := mulmod(prod,\r\n                                 mload(add(partialProductPtr, productsToValuesOffset)),\r\n                                 PRIME)\r\n              }\r\n\r\n              let firstPartialProductPtr := 0x4740\r\n              // Compute the inverse of the product.\r\n              let prodInv := expmod(prod, sub(PRIME, 2), PRIME)\r\n\r\n              if eq(prodInv, 0) {\r\n                  // Solidity generates reverts with reason that look as follows:\r\n                  // 1. 4 bytes with the constant 0x08c379a0 (== Keccak256(b'Error(string)')[:4]).\r\n                  // 2. 32 bytes offset bytes (always 0x20 as far as i can tell).\r\n                  // 3. 32 bytes with the length of the revert reason.\r\n                  // 4. Revert reason string.\r\n\r\n                  mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n                  mstore(0x4, 0x20)\r\n                  mstore(0x24, 0x1e)\r\n                  mstore(0x44, \"Batch inverse product is zero.\")\r\n                  revert(0, 0x62)\r\n              }\r\n\r\n              // Compute the inverses.\r\n              // Loop over denominator_invs in reverse order.\r\n              // currentPartialProductPtr is initialized to one past the end.\r\n              let currentPartialProductPtr := 0x4a60\r\n              for { } gt(currentPartialProductPtr, firstPartialProductPtr) { } {\r\n                  currentPartialProductPtr := sub(currentPartialProductPtr, 0x20)\r\n                  // Store 1/d_{i} = (d_0 * ... * d_{i-1}) * 1/(d_0 * ... * d_{i}).\r\n                  mstore(currentPartialProductPtr,\r\n                         mulmod(mload(currentPartialProductPtr), prodInv, PRIME))\r\n                  // Update prodInv to be 1/(d_0 * ... * d_{i-1}) by multiplying by d_i.\r\n                  prodInv := mulmod(prodInv,\r\n                                     mload(add(currentPartialProductPtr, productsToValuesOffset)),\r\n                                     PRIME)\r\n              }\r\n            }\r\n\r\n            {\r\n              // Compute numerators.\r\n\r\n              // Numerator for constraints 'cpu/decode/opcode_rc/bit'.\r\n              // numerators[0] = point^(trace_length / 16) - trace_generator^(15 * trace_length / 16).\r\n              mstore(0x4d80,\r\n                     addmod(\r\n                       /*point^(trace_length / 16)*/ mload(0x4260),\r\n                       sub(PRIME, /*trace_generator^(15 * trace_length / 16)*/ mload(0x43c0)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'cpu/update_registers/update_pc/tmp0', 'cpu/update_registers/update_pc/tmp1', 'cpu/update_registers/update_pc/pc_cond_negative', 'cpu/update_registers/update_pc/pc_cond_positive', 'cpu/update_registers/update_ap/ap_update', 'cpu/update_registers/update_fp/fp_update'.\r\n              // numerators[1] = point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              mstore(0x4da0,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(16 * (trace_length / 16 - 1))*/ mload(0x43e0)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'memory/multi_column_perm/perm/step0', 'memory/diff_is_bit', 'memory/is_func'.\r\n              // numerators[2] = point - trace_generator^(2 * (trace_length / 2 - 1)).\r\n              mstore(0x4dc0,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(2 * (trace_length / 2 - 1))*/ mload(0x4400)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'rc16/perm/step0', 'rc16/diff_is_bit'.\r\n              // numerators[3] = point - trace_generator^(4 * (trace_length / 4 - 1)).\r\n              mstore(0x4de0,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(4 * (trace_length / 4 - 1))*/ mload(0x4420)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'diluted_check/permutation/step0', 'diluted_check/step'.\r\n              // numerators[4] = point - trace_generator^(8 * (trace_length / 8 - 1)).\r\n              mstore(0x4e00,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(8 * (trace_length / 8 - 1))*/ mload(0x4440)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'pedersen/hash0/ec_subset_sum/booleanity_test', 'pedersen/hash0/ec_subset_sum/add_points/slope', 'pedersen/hash0/ec_subset_sum/add_points/x', 'pedersen/hash0/ec_subset_sum/add_points/y', 'pedersen/hash0/ec_subset_sum/copy_point/x', 'pedersen/hash0/ec_subset_sum/copy_point/y', 'pedersen/hash1/ec_subset_sum/booleanity_test', 'pedersen/hash1/ec_subset_sum/add_points/slope', 'pedersen/hash1/ec_subset_sum/add_points/x', 'pedersen/hash1/ec_subset_sum/add_points/y', 'pedersen/hash1/ec_subset_sum/copy_point/x', 'pedersen/hash1/ec_subset_sum/copy_point/y', 'pedersen/hash2/ec_subset_sum/booleanity_test', 'pedersen/hash2/ec_subset_sum/add_points/slope', 'pedersen/hash2/ec_subset_sum/add_points/x', 'pedersen/hash2/ec_subset_sum/add_points/y', 'pedersen/hash2/ec_subset_sum/copy_point/x', 'pedersen/hash2/ec_subset_sum/copy_point/y', 'pedersen/hash3/ec_subset_sum/booleanity_test', 'pedersen/hash3/ec_subset_sum/add_points/slope', 'pedersen/hash3/ec_subset_sum/add_points/x', 'pedersen/hash3/ec_subset_sum/add_points/y', 'pedersen/hash3/ec_subset_sum/copy_point/x', 'pedersen/hash3/ec_subset_sum/copy_point/y'.\r\n              // numerators[5] = point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              mstore(0x4e20,\r\n                     addmod(\r\n                       /*point^(trace_length / 256)*/ mload(0x42e0),\r\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4460)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'pedersen/hash0/copy_point/x', 'pedersen/hash0/copy_point/y', 'pedersen/hash1/copy_point/x', 'pedersen/hash1/copy_point/y', 'pedersen/hash2/copy_point/x', 'pedersen/hash2/copy_point/y', 'pedersen/hash3/copy_point/x', 'pedersen/hash3/copy_point/y'.\r\n              // numerators[6] = point^(trace_length / 512) - trace_generator^(trace_length / 2).\r\n              mstore(0x4e40,\r\n                     addmod(\r\n                       /*point^(trace_length / 512)*/ mload(0x4300),\r\n                       sub(PRIME, /*trace_generator^(trace_length / 2)*/ mload(0x44a0)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'pedersen/input0_addr', 'rc_builtin/addr_step'.\r\n              // numerators[7] = point - trace_generator^(128 * (trace_length / 128 - 1)).\r\n              mstore(0x4e60,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(128 * (trace_length / 128 - 1))*/ mload(0x44c0)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'ecdsa/signature0/doubling_key/slope', 'ecdsa/signature0/doubling_key/x', 'ecdsa/signature0/doubling_key/y', 'ecdsa/signature0/exponentiate_key/booleanity_test', 'ecdsa/signature0/exponentiate_key/add_points/slope', 'ecdsa/signature0/exponentiate_key/add_points/x', 'ecdsa/signature0/exponentiate_key/add_points/y', 'ecdsa/signature0/exponentiate_key/add_points/x_diff_inv', 'ecdsa/signature0/exponentiate_key/copy_point/x', 'ecdsa/signature0/exponentiate_key/copy_point/y'.\r\n              // numerators[8] = point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\r\n              mstore(0x4e80,\r\n                     addmod(\r\n                       /*point^(trace_length / 4096)*/ mload(0x4340),\r\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4460)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'ecdsa/signature0/exponentiate_generator/booleanity_test', 'ecdsa/signature0/exponentiate_generator/add_points/slope', 'ecdsa/signature0/exponentiate_generator/add_points/x', 'ecdsa/signature0/exponentiate_generator/add_points/y', 'ecdsa/signature0/exponentiate_generator/add_points/x_diff_inv', 'ecdsa/signature0/exponentiate_generator/copy_point/x', 'ecdsa/signature0/exponentiate_generator/copy_point/y'.\r\n              // numerators[9] = point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\r\n              mstore(0x4ea0,\r\n                     addmod(\r\n                       /*point^(trace_length / 8192)*/ mload(0x4380),\r\n                       sub(PRIME, /*trace_generator^(255 * trace_length / 256)*/ mload(0x4460)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'ecdsa/pubkey_addr'.\r\n              // numerators[10] = point - trace_generator^(8192 * (trace_length / 8192 - 1)).\r\n              mstore(0x4ec0,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(8192 * (trace_length / 8192 - 1))*/ mload(0x4500)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'bitwise/step_var_pool_addr'.\r\n              // numerators[11] = point^(trace_length / 1024) - trace_generator^(3 * trace_length / 4).\r\n              mstore(0x4ee0,\r\n                     addmod(\r\n                       /*point^(trace_length / 1024)*/ mload(0x43a0),\r\n                       sub(PRIME, /*trace_generator^(3 * trace_length / 4)*/ mload(0x4520)),\r\n                       PRIME))\r\n\r\n              // Numerator for constraints 'bitwise/next_var_pool_addr'.\r\n              // numerators[12] = point - trace_generator^(1024 * (trace_length / 1024 - 1)).\r\n              mstore(0x4f00,\r\n                     addmod(\r\n                       point,\r\n                       sub(PRIME, /*trace_generator^(1024 * (trace_length / 1024 - 1))*/ mload(0x4540)),\r\n                       PRIME))\r\n\r\n            }\r\n\r\n            {\r\n              // Compute the result of the composition polynomial.\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_0 = column0_row0 - (column0_row1 + column0_row1).\r\n              let val := addmod(\r\n                /*column0_row0*/ mload(0x1de0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row1*/ mload(0x1e00), /*column0_row1*/ mload(0x1e00), PRIME)),\r\n                PRIME)\r\n              mstore(0x3ca0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_2 = column0_row2 - (column0_row3 + column0_row3).\r\n              let val := addmod(\r\n                /*column0_row2*/ mload(0x1e20),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row3*/ mload(0x1e40), /*column0_row3*/ mload(0x1e40), PRIME)),\r\n                PRIME)\r\n              mstore(0x3cc0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_4 = column0_row4 - (column0_row5 + column0_row5).\r\n              let val := addmod(\r\n                /*column0_row4*/ mload(0x1e60),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row5*/ mload(0x1e80), /*column0_row5*/ mload(0x1e80), PRIME)),\r\n                PRIME)\r\n              mstore(0x3ce0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_3 = column0_row3 - (column0_row4 + column0_row4).\r\n              let val := addmod(\r\n                /*column0_row3*/ mload(0x1e40),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row4*/ mload(0x1e60), /*column0_row4*/ mload(0x1e60), PRIME)),\r\n                PRIME)\r\n              mstore(0x3d00, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/flag_op1_base_op0_0 = 1 - (cpu__decode__opcode_rc__bit_2 + cpu__decode__opcode_rc__bit_4 + cpu__decode__opcode_rc__bit_3).\r\n              let val := addmod(\r\n                1,\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x3cc0),\r\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_4*/ mload(0x3ce0),\r\n                      PRIME),\r\n                    /*intermediate_value/cpu/decode/opcode_rc/bit_3*/ mload(0x3d00),\r\n                    PRIME)),\r\n                PRIME)\r\n              mstore(0x3d20, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_5 = column0_row5 - (column0_row6 + column0_row6).\r\n              let val := addmod(\r\n                /*column0_row5*/ mload(0x1e80),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row6*/ mload(0x1ea0), /*column0_row6*/ mload(0x1ea0), PRIME)),\r\n                PRIME)\r\n              mstore(0x3d40, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_6 = column0_row6 - (column0_row7 + column0_row7).\r\n              let val := addmod(\r\n                /*column0_row6*/ mload(0x1ea0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row7*/ mload(0x1ec0), /*column0_row7*/ mload(0x1ec0), PRIME)),\r\n                PRIME)\r\n              mstore(0x3d60, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_9 = column0_row9 - (column0_row10 + column0_row10).\r\n              let val := addmod(\r\n                /*column0_row9*/ mload(0x1f00),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row10*/ mload(0x1f20), /*column0_row10*/ mload(0x1f20), PRIME)),\r\n                PRIME)\r\n              mstore(0x3d80, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/flag_res_op1_0 = 1 - (cpu__decode__opcode_rc__bit_5 + cpu__decode__opcode_rc__bit_6 + cpu__decode__opcode_rc__bit_9).\r\n              let val := addmod(\r\n                1,\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_5*/ mload(0x3d40),\r\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_6*/ mload(0x3d60),\r\n                      PRIME),\r\n                    /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3d80),\r\n                    PRIME)),\r\n                PRIME)\r\n              mstore(0x3da0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_7 = column0_row7 - (column0_row8 + column0_row8).\r\n              let val := addmod(\r\n                /*column0_row7*/ mload(0x1ec0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row8*/ mload(0x1ee0), /*column0_row8*/ mload(0x1ee0), PRIME)),\r\n                PRIME)\r\n              mstore(0x3dc0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_8 = column0_row8 - (column0_row9 + column0_row9).\r\n              let val := addmod(\r\n                /*column0_row8*/ mload(0x1ee0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row9*/ mload(0x1f00), /*column0_row9*/ mload(0x1f00), PRIME)),\r\n                PRIME)\r\n              mstore(0x3de0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/flag_pc_update_regular_0 = 1 - (cpu__decode__opcode_rc__bit_7 + cpu__decode__opcode_rc__bit_8 + cpu__decode__opcode_rc__bit_9).\r\n              let val := addmod(\r\n                1,\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_7*/ mload(0x3dc0),\r\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_8*/ mload(0x3de0),\r\n                      PRIME),\r\n                    /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3d80),\r\n                    PRIME)),\r\n                PRIME)\r\n              mstore(0x3e00, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_12 = column0_row12 - (column0_row13 + column0_row13).\r\n              let val := addmod(\r\n                /*column0_row12*/ mload(0x1f60),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row13*/ mload(0x1f80), /*column0_row13*/ mload(0x1f80), PRIME)),\r\n                PRIME)\r\n              mstore(0x3e20, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_13 = column0_row13 - (column0_row14 + column0_row14).\r\n              let val := addmod(\r\n                /*column0_row13*/ mload(0x1f80),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row14*/ mload(0x1fa0), /*column0_row14*/ mload(0x1fa0), PRIME)),\r\n                PRIME)\r\n              mstore(0x3e40, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/fp_update_regular_0 = 1 - (cpu__decode__opcode_rc__bit_12 + cpu__decode__opcode_rc__bit_13).\r\n              let val := addmod(\r\n                1,\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3e20),\r\n                    /*intermediate_value/cpu/decode/opcode_rc/bit_13*/ mload(0x3e40),\r\n                    PRIME)),\r\n                PRIME)\r\n              mstore(0x3e60, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_1 = column0_row1 - (column0_row2 + column0_row2).\r\n              let val := addmod(\r\n                /*column0_row1*/ mload(0x1e00),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row2*/ mload(0x1e20), /*column0_row2*/ mload(0x1e20), PRIME)),\r\n                PRIME)\r\n              mstore(0x3e80, val)\r\n              }\r\n\r\n\r\n              {\r\n              // npc_reg_0 = column17_row0 + cpu__decode__opcode_rc__bit_2 + 1.\r\n              let val := addmod(\r\n                addmod(\r\n                  /*column17_row0*/ mload(0x29e0),\r\n                  /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x3cc0),\r\n                  PRIME),\r\n                1,\r\n                PRIME)\r\n              mstore(0x3ea0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_10 = column0_row10 - (column0_row11 + column0_row11).\r\n              let val := addmod(\r\n                /*column0_row10*/ mload(0x1f20),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row11*/ mload(0x1f40), /*column0_row11*/ mload(0x1f40), PRIME)),\r\n                PRIME)\r\n              mstore(0x3ec0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_11 = column0_row11 - (column0_row12 + column0_row12).\r\n              let val := addmod(\r\n                /*column0_row11*/ mload(0x1f40),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row12*/ mload(0x1f60), /*column0_row12*/ mload(0x1f60), PRIME)),\r\n                PRIME)\r\n              mstore(0x3ee0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // cpu/decode/opcode_rc/bit_14 = column0_row14 - (column0_row15 + column0_row15).\r\n              let val := addmod(\r\n                /*column0_row14*/ mload(0x1fa0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column0_row15*/ mload(0x1fc0), /*column0_row15*/ mload(0x1fc0), PRIME)),\r\n                PRIME)\r\n              mstore(0x3f00, val)\r\n              }\r\n\r\n\r\n              {\r\n              // memory/address_diff_0 = column18_row2 - column18_row0.\r\n              let val := addmod(/*column18_row2*/ mload(0x2fa0), sub(PRIME, /*column18_row0*/ mload(0x2f60)), PRIME)\r\n              mstore(0x3f20, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc16/diff_0 = column19_row6 - column19_row2.\r\n              let val := addmod(/*column19_row6*/ mload(0x30a0), sub(PRIME, /*column19_row2*/ mload(0x3020)), PRIME)\r\n              mstore(0x3f40, val)\r\n              }\r\n\r\n\r\n              {\r\n              // pedersen/hash0/ec_subset_sum/bit_0 = column4_row0 - (column4_row1 + column4_row1).\r\n              let val := addmod(\r\n                /*column4_row0*/ mload(0x2140),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column4_row1*/ mload(0x2160), /*column4_row1*/ mload(0x2160), PRIME)),\r\n                PRIME)\r\n              mstore(0x3f60, val)\r\n              }\r\n\r\n\r\n              {\r\n              // pedersen/hash0/ec_subset_sum/bit_neg_0 = 1 - pedersen__hash0__ec_subset_sum__bit_0.\r\n              let val := addmod(\r\n                1,\r\n                sub(PRIME, /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3f60)),\r\n                PRIME)\r\n              mstore(0x3f80, val)\r\n              }\r\n\r\n\r\n              {\r\n              // pedersen/hash1/ec_subset_sum/bit_0 = column8_row0 - (column8_row1 + column8_row1).\r\n              let val := addmod(\r\n                /*column8_row0*/ mload(0x23c0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column8_row1*/ mload(0x23e0), /*column8_row1*/ mload(0x23e0), PRIME)),\r\n                PRIME)\r\n              mstore(0x3fa0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // pedersen/hash1/ec_subset_sum/bit_neg_0 = 1 - pedersen__hash1__ec_subset_sum__bit_0.\r\n              let val := addmod(\r\n                1,\r\n                sub(PRIME, /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x3fa0)),\r\n                PRIME)\r\n              mstore(0x3fc0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // pedersen/hash2/ec_subset_sum/bit_0 = column12_row0 - (column12_row1 + column12_row1).\r\n              let val := addmod(\r\n                /*column12_row0*/ mload(0x2640),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column12_row1*/ mload(0x2660), /*column12_row1*/ mload(0x2660), PRIME)),\r\n                PRIME)\r\n              mstore(0x3fe0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // pedersen/hash2/ec_subset_sum/bit_neg_0 = 1 - pedersen__hash2__ec_subset_sum__bit_0.\r\n              let val := addmod(\r\n                1,\r\n                sub(PRIME, /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x3fe0)),\r\n                PRIME)\r\n              mstore(0x4000, val)\r\n              }\r\n\r\n\r\n              {\r\n              // pedersen/hash3/ec_subset_sum/bit_0 = column16_row0 - (column16_row1 + column16_row1).\r\n              let val := addmod(\r\n                /*column16_row0*/ mload(0x28c0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column16_row1*/ mload(0x28e0), /*column16_row1*/ mload(0x28e0), PRIME)),\r\n                PRIME)\r\n              mstore(0x4020, val)\r\n              }\r\n\r\n\r\n              {\r\n              // pedersen/hash3/ec_subset_sum/bit_neg_0 = 1 - pedersen__hash3__ec_subset_sum__bit_0.\r\n              let val := addmod(\r\n                1,\r\n                sub(PRIME, /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x4020)),\r\n                PRIME)\r\n              mstore(0x4040, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value0_0 = column19_row12.\r\n              let val := /*column19_row12*/ mload(0x3140)\r\n              mstore(0x4060, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value1_0 = rc_builtin__value0_0 * offset_size + column19_row28.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc_builtin/value0_0*/ mload(0x4060),\r\n                  /*offset_size*/ mload(0xa0),\r\n                  PRIME),\r\n                /*column19_row28*/ mload(0x3200),\r\n                PRIME)\r\n              mstore(0x4080, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value2_0 = rc_builtin__value1_0 * offset_size + column19_row44.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc_builtin/value1_0*/ mload(0x4080),\r\n                  /*offset_size*/ mload(0xa0),\r\n                  PRIME),\r\n                /*column19_row44*/ mload(0x3240),\r\n                PRIME)\r\n              mstore(0x40a0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value3_0 = rc_builtin__value2_0 * offset_size + column19_row60.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc_builtin/value2_0*/ mload(0x40a0),\r\n                  /*offset_size*/ mload(0xa0),\r\n                  PRIME),\r\n                /*column19_row60*/ mload(0x3280),\r\n                PRIME)\r\n              mstore(0x40c0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value4_0 = rc_builtin__value3_0 * offset_size + column19_row76.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc_builtin/value3_0*/ mload(0x40c0),\r\n                  /*offset_size*/ mload(0xa0),\r\n                  PRIME),\r\n                /*column19_row76*/ mload(0x32c0),\r\n                PRIME)\r\n              mstore(0x40e0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value5_0 = rc_builtin__value4_0 * offset_size + column19_row92.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc_builtin/value4_0*/ mload(0x40e0),\r\n                  /*offset_size*/ mload(0xa0),\r\n                  PRIME),\r\n                /*column19_row92*/ mload(0x3300),\r\n                PRIME)\r\n              mstore(0x4100, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value6_0 = rc_builtin__value5_0 * offset_size + column19_row108.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc_builtin/value5_0*/ mload(0x4100),\r\n                  /*offset_size*/ mload(0xa0),\r\n                  PRIME),\r\n                /*column19_row108*/ mload(0x3340),\r\n                PRIME)\r\n              mstore(0x4120, val)\r\n              }\r\n\r\n\r\n              {\r\n              // rc_builtin/value7_0 = rc_builtin__value6_0 * offset_size + column19_row124.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc_builtin/value6_0*/ mload(0x4120),\r\n                  /*offset_size*/ mload(0xa0),\r\n                  PRIME),\r\n                /*column19_row124*/ mload(0x3380),\r\n                PRIME)\r\n              mstore(0x4140, val)\r\n              }\r\n\r\n\r\n              {\r\n              // ecdsa/signature0/doubling_key/x_squared = column20_row4 * column20_row4.\r\n              let val := mulmod(/*column20_row4*/ mload(0x36e0), /*column20_row4*/ mload(0x36e0), PRIME)\r\n              mstore(0x4160, val)\r\n              }\r\n\r\n\r\n              {\r\n              // ecdsa/signature0/exponentiate_generator/bit_0 = column20_row29 - (column20_row61 + column20_row61).\r\n              let val := addmod(\r\n                /*column20_row29*/ mload(0x38e0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column20_row61*/ mload(0x3940), /*column20_row61*/ mload(0x3940), PRIME)),\r\n                PRIME)\r\n              mstore(0x4180, val)\r\n              }\r\n\r\n\r\n              {\r\n              // ecdsa/signature0/exponentiate_generator/bit_neg_0 = 1 - ecdsa__signature0__exponentiate_generator__bit_0.\r\n              let val := addmod(\r\n                1,\r\n                sub(\r\n                  PRIME,\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x4180)),\r\n                PRIME)\r\n              mstore(0x41a0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // ecdsa/signature0/exponentiate_key/bit_0 = column20_row1 - (column20_row17 + column20_row17).\r\n              let val := addmod(\r\n                /*column20_row1*/ mload(0x3680),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column20_row17*/ mload(0x3800), /*column20_row17*/ mload(0x3800), PRIME)),\r\n                PRIME)\r\n              mstore(0x41c0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // ecdsa/signature0/exponentiate_key/bit_neg_0 = 1 - ecdsa__signature0__exponentiate_key__bit_0.\r\n              let val := addmod(\r\n                1,\r\n                sub(\r\n                  PRIME,\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x41c0)),\r\n                PRIME)\r\n              mstore(0x41e0, val)\r\n              }\r\n\r\n\r\n              {\r\n              // bitwise/sum_var_0_0 = column19_row1 + column19_row17 * 2 + column19_row33 * 4 + column19_row49 * 8 + column19_row65 * 18446744073709551616 + column19_row81 * 36893488147419103232 + column19_row97 * 73786976294838206464 + column19_row113 * 147573952589676412928.\r\n              let val := addmod(\r\n                addmod(\r\n                  addmod(\r\n                    addmod(\r\n                      addmod(\r\n                        addmod(\r\n                          addmod(\r\n                            /*column19_row1*/ mload(0x3000),\r\n                            mulmod(/*column19_row17*/ mload(0x31a0), 2, PRIME),\r\n                            PRIME),\r\n                          mulmod(/*column19_row33*/ mload(0x3220), 4, PRIME),\r\n                          PRIME),\r\n                        mulmod(/*column19_row49*/ mload(0x3260), 8, PRIME),\r\n                        PRIME),\r\n                      mulmod(/*column19_row65*/ mload(0x32a0), 18446744073709551616, PRIME),\r\n                      PRIME),\r\n                    mulmod(/*column19_row81*/ mload(0x32e0), 36893488147419103232, PRIME),\r\n                    PRIME),\r\n                  mulmod(/*column19_row97*/ mload(0x3320), 73786976294838206464, PRIME),\r\n                  PRIME),\r\n                mulmod(/*column19_row113*/ mload(0x3360), 147573952589676412928, PRIME),\r\n                PRIME)\r\n              mstore(0x4200, val)\r\n              }\r\n\r\n\r\n              {\r\n              // bitwise/sum_var_8_0 = column19_row129 * 340282366920938463463374607431768211456 + column19_row145 * 680564733841876926926749214863536422912 + column19_row161 * 1361129467683753853853498429727072845824 + column19_row177 * 2722258935367507707706996859454145691648 + column19_row193 * 6277101735386680763835789423207666416102355444464034512896 + column19_row209 * 12554203470773361527671578846415332832204710888928069025792 + column19_row225 * 25108406941546723055343157692830665664409421777856138051584 + column19_row241 * 50216813883093446110686315385661331328818843555712276103168.\r\n              let val := addmod(\r\n                addmod(\r\n                  addmod(\r\n                    addmod(\r\n                      addmod(\r\n                        addmod(\r\n                          addmod(\r\n                            mulmod(/*column19_row129*/ mload(0x33a0), 340282366920938463463374607431768211456, PRIME),\r\n                            mulmod(/*column19_row145*/ mload(0x33c0), 680564733841876926926749214863536422912, PRIME),\r\n                            PRIME),\r\n                          mulmod(/*column19_row161*/ mload(0x33e0), 1361129467683753853853498429727072845824, PRIME),\r\n                          PRIME),\r\n                        mulmod(/*column19_row177*/ mload(0x3400), 2722258935367507707706996859454145691648, PRIME),\r\n                        PRIME),\r\n                      mulmod(\r\n                        /*column19_row193*/ mload(0x3420),\r\n                        6277101735386680763835789423207666416102355444464034512896,\r\n                        PRIME),\r\n                      PRIME),\r\n                    mulmod(\r\n                      /*column19_row209*/ mload(0x3440),\r\n                      12554203470773361527671578846415332832204710888928069025792,\r\n                      PRIME),\r\n                    PRIME),\r\n                  mulmod(\r\n                    /*column19_row225*/ mload(0x3460),\r\n                    25108406941546723055343157692830665664409421777856138051584,\r\n                    PRIME),\r\n                  PRIME),\r\n                mulmod(\r\n                  /*column19_row241*/ mload(0x3480),\r\n                  50216813883093446110686315385661331328818843555712276103168,\r\n                  PRIME),\r\n                PRIME)\r\n              mstore(0x4220, val)\r\n              }\r\n\r\n\r\n              {\r\n              // Constraint expression for cpu/decode/opcode_rc/bit: cpu__decode__opcode_rc__bit_0 * cpu__decode__opcode_rc__bit_0 - cpu__decode__opcode_rc__bit_0.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3ca0),\r\n                  /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3ca0),\r\n                  PRIME),\r\n                sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3ca0)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 16) - trace_generator^(15 * trace_length / 16).\r\n              // val *= numerators[0].\r\n              val := mulmod(val, mload(0x4d80), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[0].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[0]*/ mload(0x540), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/decode/opcode_rc/zero: column0_row0.\r\n              let val := /*column0_row0*/ mload(0x1de0)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - trace_generator^(15 * trace_length / 16).\r\n              // val *= denominator_invs[1].\r\n              val := mulmod(val, mload(0x4760), PRIME)\r\n\r\n              // res += val * coefficients[1].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[1]*/ mload(0x560), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/decode/opcode_rc_input: column17_row1 - (((column0_row0 * offset_size + column19_row4) * offset_size + column19_row8) * offset_size + column19_row0).\r\n              let val := addmod(\r\n                /*column17_row1*/ mload(0x2a00),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    mulmod(\r\n                      addmod(\r\n                        mulmod(\r\n                          addmod(\r\n                            mulmod(/*column0_row0*/ mload(0x1de0), /*offset_size*/ mload(0xa0), PRIME),\r\n                            /*column19_row4*/ mload(0x3060),\r\n                            PRIME),\r\n                          /*offset_size*/ mload(0xa0),\r\n                          PRIME),\r\n                        /*column19_row8*/ mload(0x30e0),\r\n                        PRIME),\r\n                      /*offset_size*/ mload(0xa0),\r\n                      PRIME),\r\n                    /*column19_row0*/ mload(0x2fe0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[2].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[2]*/ mload(0x580), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/decode/flag_op1_base_op0_bit: cpu__decode__flag_op1_base_op0_0 * cpu__decode__flag_op1_base_op0_0 - cpu__decode__flag_op1_base_op0_0.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/cpu/decode/flag_op1_base_op0_0*/ mload(0x3d20),\r\n                  /*intermediate_value/cpu/decode/flag_op1_base_op0_0*/ mload(0x3d20),\r\n                  PRIME),\r\n                sub(PRIME, /*intermediate_value/cpu/decode/flag_op1_base_op0_0*/ mload(0x3d20)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[3].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[3]*/ mload(0x5a0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/decode/flag_res_op1_bit: cpu__decode__flag_res_op1_0 * cpu__decode__flag_res_op1_0 - cpu__decode__flag_res_op1_0.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/cpu/decode/flag_res_op1_0*/ mload(0x3da0),\r\n                  /*intermediate_value/cpu/decode/flag_res_op1_0*/ mload(0x3da0),\r\n                  PRIME),\r\n                sub(PRIME, /*intermediate_value/cpu/decode/flag_res_op1_0*/ mload(0x3da0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[4].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[4]*/ mload(0x5c0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/decode/flag_pc_update_regular_bit: cpu__decode__flag_pc_update_regular_0 * cpu__decode__flag_pc_update_regular_0 - cpu__decode__flag_pc_update_regular_0.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/cpu/decode/flag_pc_update_regular_0*/ mload(0x3e00),\r\n                  /*intermediate_value/cpu/decode/flag_pc_update_regular_0*/ mload(0x3e00),\r\n                  PRIME),\r\n                sub(PRIME, /*intermediate_value/cpu/decode/flag_pc_update_regular_0*/ mload(0x3e00)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[5].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[5]*/ mload(0x5e0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/decode/fp_update_regular_bit: cpu__decode__fp_update_regular_0 * cpu__decode__fp_update_regular_0 - cpu__decode__fp_update_regular_0.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/cpu/decode/fp_update_regular_0*/ mload(0x3e60),\r\n                  /*intermediate_value/cpu/decode/fp_update_regular_0*/ mload(0x3e60),\r\n                  PRIME),\r\n                sub(PRIME, /*intermediate_value/cpu/decode/fp_update_regular_0*/ mload(0x3e60)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[6].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[6]*/ mload(0x600), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/operands/mem_dst_addr: column17_row8 + half_offset_size - (cpu__decode__opcode_rc__bit_0 * column19_row11 + (1 - cpu__decode__opcode_rc__bit_0) * column19_row3 + column19_row0).\r\n              let val := addmod(\r\n                addmod(/*column17_row8*/ mload(0x2ae0), /*half_offset_size*/ mload(0xc0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      mulmod(\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3ca0),\r\n                        /*column19_row11*/ mload(0x3120),\r\n                        PRIME),\r\n                      mulmod(\r\n                        addmod(\r\n                          1,\r\n                          sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3ca0)),\r\n                          PRIME),\r\n                        /*column19_row3*/ mload(0x3040),\r\n                        PRIME),\r\n                      PRIME),\r\n                    /*column19_row0*/ mload(0x2fe0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[7].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[7]*/ mload(0x620), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/operands/mem0_addr: column17_row4 + half_offset_size - (cpu__decode__opcode_rc__bit_1 * column19_row11 + (1 - cpu__decode__opcode_rc__bit_1) * column19_row3 + column19_row8).\r\n              let val := addmod(\r\n                addmod(/*column17_row4*/ mload(0x2a60), /*half_offset_size*/ mload(0xc0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      mulmod(\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_1*/ mload(0x3e80),\r\n                        /*column19_row11*/ mload(0x3120),\r\n                        PRIME),\r\n                      mulmod(\r\n                        addmod(\r\n                          1,\r\n                          sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_1*/ mload(0x3e80)),\r\n                          PRIME),\r\n                        /*column19_row3*/ mload(0x3040),\r\n                        PRIME),\r\n                      PRIME),\r\n                    /*column19_row8*/ mload(0x30e0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[8].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[8]*/ mload(0x640), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/operands/mem1_addr: column17_row12 + half_offset_size - (cpu__decode__opcode_rc__bit_2 * column17_row0 + cpu__decode__opcode_rc__bit_4 * column19_row3 + cpu__decode__opcode_rc__bit_3 * column19_row11 + cpu__decode__flag_op1_base_op0_0 * column17_row5 + column19_row4).\r\n              let val := addmod(\r\n                addmod(/*column17_row12*/ mload(0x2b20), /*half_offset_size*/ mload(0xc0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      addmod(\r\n                        addmod(\r\n                          mulmod(\r\n                            /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x3cc0),\r\n                            /*column17_row0*/ mload(0x29e0),\r\n                            PRIME),\r\n                          mulmod(\r\n                            /*intermediate_value/cpu/decode/opcode_rc/bit_4*/ mload(0x3ce0),\r\n                            /*column19_row3*/ mload(0x3040),\r\n                            PRIME),\r\n                          PRIME),\r\n                        mulmod(\r\n                          /*intermediate_value/cpu/decode/opcode_rc/bit_3*/ mload(0x3d00),\r\n                          /*column19_row11*/ mload(0x3120),\r\n                          PRIME),\r\n                        PRIME),\r\n                      mulmod(\r\n                        /*intermediate_value/cpu/decode/flag_op1_base_op0_0*/ mload(0x3d20),\r\n                        /*column17_row5*/ mload(0x2a80),\r\n                        PRIME),\r\n                      PRIME),\r\n                    /*column19_row4*/ mload(0x3060),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[9].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[9]*/ mload(0x660), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/operands/ops_mul: column19_row7 - column17_row5 * column17_row13.\r\n              let val := addmod(\r\n                /*column19_row7*/ mload(0x30c0),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(/*column17_row5*/ mload(0x2a80), /*column17_row13*/ mload(0x2b40), PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[10].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[10]*/ mload(0x680), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/operands/res: (1 - cpu__decode__opcode_rc__bit_9) * column19_row15 - (cpu__decode__opcode_rc__bit_5 * (column17_row5 + column17_row13) + cpu__decode__opcode_rc__bit_6 * column19_row7 + cpu__decode__flag_res_op1_0 * column17_row13).\r\n              let val := addmod(\r\n                mulmod(\r\n                  addmod(\r\n                    1,\r\n                    sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3d80)),\r\n                    PRIME),\r\n                  /*column19_row15*/ mload(0x3180),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      mulmod(\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_5*/ mload(0x3d40),\r\n                        addmod(/*column17_row5*/ mload(0x2a80), /*column17_row13*/ mload(0x2b40), PRIME),\r\n                        PRIME),\r\n                      mulmod(\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_6*/ mload(0x3d60),\r\n                        /*column19_row7*/ mload(0x30c0),\r\n                        PRIME),\r\n                      PRIME),\r\n                    mulmod(\r\n                      /*intermediate_value/cpu/decode/flag_res_op1_0*/ mload(0x3da0),\r\n                      /*column17_row13*/ mload(0x2b40),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[11].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[11]*/ mload(0x6a0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/update_registers/update_pc/tmp0: column20_row0 - cpu__decode__opcode_rc__bit_9 * column17_row9.\r\n              let val := addmod(\r\n                /*column20_row0*/ mload(0x3660),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3d80),\r\n                    /*column17_row9*/ mload(0x2b00),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= numerators[1].\r\n              val := mulmod(val, mload(0x4da0), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[12].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[12]*/ mload(0x6c0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/update_registers/update_pc/tmp1: column20_row8 - column20_row0 * column19_row15.\r\n              let val := addmod(\r\n                /*column20_row8*/ mload(0x3740),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(/*column20_row0*/ mload(0x3660), /*column19_row15*/ mload(0x3180), PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= numerators[1].\r\n              val := mulmod(val, mload(0x4da0), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[13].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[13]*/ mload(0x6e0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/update_registers/update_pc/pc_cond_negative: (1 - cpu__decode__opcode_rc__bit_9) * column17_row16 + column20_row0 * (column17_row16 - (column17_row0 + column17_row13)) - (cpu__decode__flag_pc_update_regular_0 * npc_reg_0 + cpu__decode__opcode_rc__bit_7 * column19_row15 + cpu__decode__opcode_rc__bit_8 * (column17_row0 + column19_row15)).\r\n              let val := addmod(\r\n                addmod(\r\n                  mulmod(\r\n                    addmod(\r\n                      1,\r\n                      sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3d80)),\r\n                      PRIME),\r\n                    /*column17_row16*/ mload(0x2b60),\r\n                    PRIME),\r\n                  mulmod(\r\n                    /*column20_row0*/ mload(0x3660),\r\n                    addmod(\r\n                      /*column17_row16*/ mload(0x2b60),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column17_row0*/ mload(0x29e0), /*column17_row13*/ mload(0x2b40), PRIME)),\r\n                      PRIME),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      mulmod(\r\n                        /*intermediate_value/cpu/decode/flag_pc_update_regular_0*/ mload(0x3e00),\r\n                        /*intermediate_value/npc_reg_0*/ mload(0x3ea0),\r\n                        PRIME),\r\n                      mulmod(\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_7*/ mload(0x3dc0),\r\n                        /*column19_row15*/ mload(0x3180),\r\n                        PRIME),\r\n                      PRIME),\r\n                    mulmod(\r\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_8*/ mload(0x3de0),\r\n                      addmod(/*column17_row0*/ mload(0x29e0), /*column19_row15*/ mload(0x3180), PRIME),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= numerators[1].\r\n              val := mulmod(val, mload(0x4da0), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[14].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[14]*/ mload(0x700), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/update_registers/update_pc/pc_cond_positive: (column20_row8 - cpu__decode__opcode_rc__bit_9) * (column17_row16 - npc_reg_0).\r\n              let val := mulmod(\r\n                addmod(\r\n                  /*column20_row8*/ mload(0x3740),\r\n                  sub(PRIME, /*intermediate_value/cpu/decode/opcode_rc/bit_9*/ mload(0x3d80)),\r\n                  PRIME),\r\n                addmod(\r\n                  /*column17_row16*/ mload(0x2b60),\r\n                  sub(PRIME, /*intermediate_value/npc_reg_0*/ mload(0x3ea0)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= numerators[1].\r\n              val := mulmod(val, mload(0x4da0), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[15].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[15]*/ mload(0x720), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/update_registers/update_ap/ap_update: column19_row19 - (column19_row3 + cpu__decode__opcode_rc__bit_10 * column19_row15 + cpu__decode__opcode_rc__bit_11 + cpu__decode__opcode_rc__bit_12 * 2).\r\n              let val := addmod(\r\n                /*column19_row19*/ mload(0x31c0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      addmod(\r\n                        /*column19_row3*/ mload(0x3040),\r\n                        mulmod(\r\n                          /*intermediate_value/cpu/decode/opcode_rc/bit_10*/ mload(0x3ec0),\r\n                          /*column19_row15*/ mload(0x3180),\r\n                          PRIME),\r\n                        PRIME),\r\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_11*/ mload(0x3ee0),\r\n                      PRIME),\r\n                    mulmod(/*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3e20), 2, PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= numerators[1].\r\n              val := mulmod(val, mload(0x4da0), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[16].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[16]*/ mload(0x740), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/update_registers/update_fp/fp_update: column19_row27 - (cpu__decode__fp_update_regular_0 * column19_row11 + cpu__decode__opcode_rc__bit_13 * column17_row9 + cpu__decode__opcode_rc__bit_12 * (column19_row3 + 2)).\r\n              let val := addmod(\r\n                /*column19_row27*/ mload(0x31e0),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      mulmod(\r\n                        /*intermediate_value/cpu/decode/fp_update_regular_0*/ mload(0x3e60),\r\n                        /*column19_row11*/ mload(0x3120),\r\n                        PRIME),\r\n                      mulmod(\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_13*/ mload(0x3e40),\r\n                        /*column17_row9*/ mload(0x2b00),\r\n                        PRIME),\r\n                      PRIME),\r\n                    mulmod(\r\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3e20),\r\n                      addmod(/*column19_row3*/ mload(0x3040), 2, PRIME),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= numerators[1].\r\n              val := mulmod(val, mload(0x4da0), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[17].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[17]*/ mload(0x760), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/opcodes/call/push_fp: cpu__decode__opcode_rc__bit_12 * (column17_row9 - column19_row11).\r\n              let val := mulmod(\r\n                /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3e20),\r\n                addmod(\r\n                  /*column17_row9*/ mload(0x2b00),\r\n                  sub(PRIME, /*column19_row11*/ mload(0x3120)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[18].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[18]*/ mload(0x780), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/opcodes/call/push_pc: cpu__decode__opcode_rc__bit_12 * (column17_row5 - (column17_row0 + cpu__decode__opcode_rc__bit_2 + 1)).\r\n              let val := mulmod(\r\n                /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3e20),\r\n                addmod(\r\n                  /*column17_row5*/ mload(0x2a80),\r\n                  sub(\r\n                    PRIME,\r\n                    addmod(\r\n                      addmod(\r\n                        /*column17_row0*/ mload(0x29e0),\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_2*/ mload(0x3cc0),\r\n                        PRIME),\r\n                      1,\r\n                      PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[19].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[19]*/ mload(0x7a0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/opcodes/call/off0: cpu__decode__opcode_rc__bit_12 * (column19_row0 - half_offset_size).\r\n              let val := mulmod(\r\n                /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3e20),\r\n                addmod(\r\n                  /*column19_row0*/ mload(0x2fe0),\r\n                  sub(PRIME, /*half_offset_size*/ mload(0xc0)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[20].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[20]*/ mload(0x7c0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/opcodes/call/off1: cpu__decode__opcode_rc__bit_12 * (column19_row8 - (half_offset_size + 1)).\r\n              let val := mulmod(\r\n                /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3e20),\r\n                addmod(\r\n                  /*column19_row8*/ mload(0x30e0),\r\n                  sub(PRIME, addmod(/*half_offset_size*/ mload(0xc0), 1, PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[21].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[21]*/ mload(0x7e0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/opcodes/call/flags: cpu__decode__opcode_rc__bit_12 * (cpu__decode__opcode_rc__bit_12 + cpu__decode__opcode_rc__bit_12 + 1 + 1 - (cpu__decode__opcode_rc__bit_0 + cpu__decode__opcode_rc__bit_1 + 4)).\r\n              let val := mulmod(\r\n                /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3e20),\r\n                addmod(\r\n                  addmod(\r\n                    addmod(\r\n                      addmod(\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3e20),\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_12*/ mload(0x3e20),\r\n                        PRIME),\r\n                      1,\r\n                      PRIME),\r\n                    1,\r\n                    PRIME),\r\n                  sub(\r\n                    PRIME,\r\n                    addmod(\r\n                      addmod(\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3ca0),\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_1*/ mload(0x3e80),\r\n                        PRIME),\r\n                      4,\r\n                      PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[22].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[22]*/ mload(0x800), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/opcodes/ret/off0: cpu__decode__opcode_rc__bit_13 * (column19_row0 + 2 - half_offset_size).\r\n              let val := mulmod(\r\n                /*intermediate_value/cpu/decode/opcode_rc/bit_13*/ mload(0x3e40),\r\n                addmod(\r\n                  addmod(/*column19_row0*/ mload(0x2fe0), 2, PRIME),\r\n                  sub(PRIME, /*half_offset_size*/ mload(0xc0)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[23].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[23]*/ mload(0x820), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/opcodes/ret/off2: cpu__decode__opcode_rc__bit_13 * (column19_row4 + 1 - half_offset_size).\r\n              let val := mulmod(\r\n                /*intermediate_value/cpu/decode/opcode_rc/bit_13*/ mload(0x3e40),\r\n                addmod(\r\n                  addmod(/*column19_row4*/ mload(0x3060), 1, PRIME),\r\n                  sub(PRIME, /*half_offset_size*/ mload(0xc0)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[24].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[24]*/ mload(0x840), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/opcodes/ret/flags: cpu__decode__opcode_rc__bit_13 * (cpu__decode__opcode_rc__bit_7 + cpu__decode__opcode_rc__bit_0 + cpu__decode__opcode_rc__bit_3 + cpu__decode__flag_res_op1_0 - 4).\r\n              let val := mulmod(\r\n                /*intermediate_value/cpu/decode/opcode_rc/bit_13*/ mload(0x3e40),\r\n                addmod(\r\n                  addmod(\r\n                    addmod(\r\n                      addmod(\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_7*/ mload(0x3dc0),\r\n                        /*intermediate_value/cpu/decode/opcode_rc/bit_0*/ mload(0x3ca0),\r\n                        PRIME),\r\n                      /*intermediate_value/cpu/decode/opcode_rc/bit_3*/ mload(0x3d00),\r\n                      PRIME),\r\n                    /*intermediate_value/cpu/decode/flag_res_op1_0*/ mload(0x3da0),\r\n                    PRIME),\r\n                  sub(PRIME, 4),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[25].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[25]*/ mload(0x860), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for cpu/opcodes/assert_eq/assert_eq: cpu__decode__opcode_rc__bit_14 * (column17_row9 - column19_row15).\r\n              let val := mulmod(\r\n                /*intermediate_value/cpu/decode/opcode_rc/bit_14*/ mload(0x3f00),\r\n                addmod(\r\n                  /*column17_row9*/ mload(0x2b00),\r\n                  sub(PRIME, /*column19_row15*/ mload(0x3180)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[26].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[26]*/ mload(0x880), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for initial_ap: column19_row3 - initial_ap.\r\n              let val := addmod(/*column19_row3*/ mload(0x3040), sub(PRIME, /*initial_ap*/ mload(0xe0)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x47a0), PRIME)\r\n\r\n              // res += val * coefficients[27].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[27]*/ mload(0x8a0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for initial_fp: column19_row11 - initial_ap.\r\n              let val := addmod(/*column19_row11*/ mload(0x3120), sub(PRIME, /*initial_ap*/ mload(0xe0)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x47a0), PRIME)\r\n\r\n              // res += val * coefficients[28].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[28]*/ mload(0x8c0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for initial_pc: column17_row0 - initial_pc.\r\n              let val := addmod(/*column17_row0*/ mload(0x29e0), sub(PRIME, /*initial_pc*/ mload(0x100)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x47a0), PRIME)\r\n\r\n              // res += val * coefficients[29].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[29]*/ mload(0x8e0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for final_ap: column19_row3 - final_ap.\r\n              let val := addmod(/*column19_row3*/ mload(0x3040), sub(PRIME, /*final_ap*/ mload(0x120)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= denominator_invs[4].\r\n              val := mulmod(val, mload(0x47c0), PRIME)\r\n\r\n              // res += val * coefficients[30].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[30]*/ mload(0x900), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for final_fp: column19_row11 - initial_ap.\r\n              let val := addmod(/*column19_row11*/ mload(0x3120), sub(PRIME, /*initial_ap*/ mload(0xe0)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= denominator_invs[4].\r\n              val := mulmod(val, mload(0x47c0), PRIME)\r\n\r\n              // res += val * coefficients[31].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[31]*/ mload(0x920), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for final_pc: column17_row0 - final_pc.\r\n              let val := addmod(/*column17_row0*/ mload(0x29e0), sub(PRIME, /*final_pc*/ mload(0x140)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(16 * (trace_length / 16 - 1)).\r\n              // val *= denominator_invs[4].\r\n              val := mulmod(val, mload(0x47c0), PRIME)\r\n\r\n              // res += val * coefficients[32].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[32]*/ mload(0x940), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for memory/multi_column_perm/perm/init0: (memory/multi_column_perm/perm/interaction_elm - (column18_row0 + memory/multi_column_perm/hash_interaction_elm0 * column18_row1)) * column21_inter1_row0 + column17_row0 + memory/multi_column_perm/hash_interaction_elm0 * column17_row1 - memory/multi_column_perm/perm/interaction_elm.\r\n              let val := addmod(\r\n                addmod(\r\n                  addmod(\r\n                    mulmod(\r\n                      addmod(\r\n                        /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160),\r\n                        sub(\r\n                          PRIME,\r\n                          addmod(\r\n                            /*column18_row0*/ mload(0x2f60),\r\n                            mulmod(\r\n                              /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180),\r\n                              /*column18_row1*/ mload(0x2f80),\r\n                              PRIME),\r\n                            PRIME)),\r\n                        PRIME),\r\n                      /*column21_inter1_row0*/ mload(0x3ba0),\r\n                      PRIME),\r\n                    /*column17_row0*/ mload(0x29e0),\r\n                    PRIME),\r\n                  mulmod(\r\n                    /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180),\r\n                    /*column17_row1*/ mload(0x2a00),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(PRIME, /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x47a0), PRIME)\r\n\r\n              // res += val * coefficients[33].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[33]*/ mload(0x960), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for memory/multi_column_perm/perm/step0: (memory/multi_column_perm/perm/interaction_elm - (column18_row2 + memory/multi_column_perm/hash_interaction_elm0 * column18_row3)) * column21_inter1_row2 - (memory/multi_column_perm/perm/interaction_elm - (column17_row2 + memory/multi_column_perm/hash_interaction_elm0 * column17_row3)) * column21_inter1_row0.\r\n              let val := addmod(\r\n                mulmod(\r\n                  addmod(\r\n                    /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160),\r\n                    sub(\r\n                      PRIME,\r\n                      addmod(\r\n                        /*column18_row2*/ mload(0x2fa0),\r\n                        mulmod(\r\n                          /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180),\r\n                          /*column18_row3*/ mload(0x2fc0),\r\n                          PRIME),\r\n                        PRIME)),\r\n                    PRIME),\r\n                  /*column21_inter1_row2*/ mload(0x3be0),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    addmod(\r\n                      /*memory/multi_column_perm/perm/interaction_elm*/ mload(0x160),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(\r\n                          /*column17_row2*/ mload(0x2a20),\r\n                          mulmod(\r\n                            /*memory/multi_column_perm/hash_interaction_elm0*/ mload(0x180),\r\n                            /*column17_row3*/ mload(0x2a40),\r\n                            PRIME),\r\n                          PRIME)),\r\n                      PRIME),\r\n                    /*column21_inter1_row0*/ mload(0x3ba0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(2 * (trace_length / 2 - 1)).\r\n              // val *= numerators[2].\r\n              val := mulmod(val, mload(0x4dc0), PRIME)\r\n              // Denominator: point^(trace_length / 2) - 1.\r\n              // val *= denominator_invs[5].\r\n              val := mulmod(val, mload(0x47e0), PRIME)\r\n\r\n              // res += val * coefficients[34].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[34]*/ mload(0x980), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for memory/multi_column_perm/perm/last: column21_inter1_row0 - memory/multi_column_perm/perm/public_memory_prod.\r\n              let val := addmod(\r\n                /*column21_inter1_row0*/ mload(0x3ba0),\r\n                sub(PRIME, /*memory/multi_column_perm/perm/public_memory_prod*/ mload(0x1a0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(2 * (trace_length / 2 - 1)).\r\n              // val *= denominator_invs[6].\r\n              val := mulmod(val, mload(0x4800), PRIME)\r\n\r\n              // res += val * coefficients[35].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[35]*/ mload(0x9a0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for memory/diff_is_bit: memory__address_diff_0 * memory__address_diff_0 - memory__address_diff_0.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/memory/address_diff_0*/ mload(0x3f20),\r\n                  /*intermediate_value/memory/address_diff_0*/ mload(0x3f20),\r\n                  PRIME),\r\n                sub(PRIME, /*intermediate_value/memory/address_diff_0*/ mload(0x3f20)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(2 * (trace_length / 2 - 1)).\r\n              // val *= numerators[2].\r\n              val := mulmod(val, mload(0x4dc0), PRIME)\r\n              // Denominator: point^(trace_length / 2) - 1.\r\n              // val *= denominator_invs[5].\r\n              val := mulmod(val, mload(0x47e0), PRIME)\r\n\r\n              // res += val * coefficients[36].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[36]*/ mload(0x9c0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for memory/is_func: (memory__address_diff_0 - 1) * (column18_row1 - column18_row3).\r\n              let val := mulmod(\r\n                addmod(/*intermediate_value/memory/address_diff_0*/ mload(0x3f20), sub(PRIME, 1), PRIME),\r\n                addmod(/*column18_row1*/ mload(0x2f80), sub(PRIME, /*column18_row3*/ mload(0x2fc0)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(2 * (trace_length / 2 - 1)).\r\n              // val *= numerators[2].\r\n              val := mulmod(val, mload(0x4dc0), PRIME)\r\n              // Denominator: point^(trace_length / 2) - 1.\r\n              // val *= denominator_invs[5].\r\n              val := mulmod(val, mload(0x47e0), PRIME)\r\n\r\n              // res += val * coefficients[37].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[37]*/ mload(0x9e0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for memory/initial_addr: column18_row0 - 1.\r\n              let val := addmod(/*column18_row0*/ mload(0x2f60), sub(PRIME, 1), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x47a0), PRIME)\r\n\r\n              // res += val * coefficients[38].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[38]*/ mload(0xa00), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for public_memory_addr_zero: column17_row2.\r\n              let val := /*column17_row2*/ mload(0x2a20)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8) - 1.\r\n              // val *= denominator_invs[7].\r\n              val := mulmod(val, mload(0x4820), PRIME)\r\n\r\n              // res += val * coefficients[39].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[39]*/ mload(0xa20), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for public_memory_value_zero: column17_row3.\r\n              let val := /*column17_row3*/ mload(0x2a40)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8) - 1.\r\n              // val *= denominator_invs[7].\r\n              val := mulmod(val, mload(0x4820), PRIME)\r\n\r\n              // res += val * coefficients[40].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[40]*/ mload(0xa40), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc16/perm/init0: (rc16/perm/interaction_elm - column19_row2) * column21_inter1_row1 + column19_row0 - rc16/perm/interaction_elm.\r\n              let val := addmod(\r\n                addmod(\r\n                  mulmod(\r\n                    addmod(\r\n                      /*rc16/perm/interaction_elm*/ mload(0x1c0),\r\n                      sub(PRIME, /*column19_row2*/ mload(0x3020)),\r\n                      PRIME),\r\n                    /*column21_inter1_row1*/ mload(0x3bc0),\r\n                    PRIME),\r\n                  /*column19_row0*/ mload(0x2fe0),\r\n                  PRIME),\r\n                sub(PRIME, /*rc16/perm/interaction_elm*/ mload(0x1c0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x47a0), PRIME)\r\n\r\n              // res += val * coefficients[41].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[41]*/ mload(0xa60), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc16/perm/step0: (rc16/perm/interaction_elm - column19_row6) * column21_inter1_row5 - (rc16/perm/interaction_elm - column19_row4) * column21_inter1_row1.\r\n              let val := addmod(\r\n                mulmod(\r\n                  addmod(\r\n                    /*rc16/perm/interaction_elm*/ mload(0x1c0),\r\n                    sub(PRIME, /*column19_row6*/ mload(0x30a0)),\r\n                    PRIME),\r\n                  /*column21_inter1_row5*/ mload(0x3c20),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    addmod(\r\n                      /*rc16/perm/interaction_elm*/ mload(0x1c0),\r\n                      sub(PRIME, /*column19_row4*/ mload(0x3060)),\r\n                      PRIME),\r\n                    /*column21_inter1_row1*/ mload(0x3bc0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(4 * (trace_length / 4 - 1)).\r\n              // val *= numerators[3].\r\n              val := mulmod(val, mload(0x4de0), PRIME)\r\n              // Denominator: point^(trace_length / 4) - 1.\r\n              // val *= denominator_invs[8].\r\n              val := mulmod(val, mload(0x4840), PRIME)\r\n\r\n              // res += val * coefficients[42].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[42]*/ mload(0xa80), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc16/perm/last: column21_inter1_row1 - rc16/perm/public_memory_prod.\r\n              let val := addmod(\r\n                /*column21_inter1_row1*/ mload(0x3bc0),\r\n                sub(PRIME, /*rc16/perm/public_memory_prod*/ mload(0x1e0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(4 * (trace_length / 4 - 1)).\r\n              // val *= denominator_invs[9].\r\n              val := mulmod(val, mload(0x4860), PRIME)\r\n\r\n              // res += val * coefficients[43].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[43]*/ mload(0xaa0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc16/diff_is_bit: rc16__diff_0 * rc16__diff_0 - rc16__diff_0.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/rc16/diff_0*/ mload(0x3f40),\r\n                  /*intermediate_value/rc16/diff_0*/ mload(0x3f40),\r\n                  PRIME),\r\n                sub(PRIME, /*intermediate_value/rc16/diff_0*/ mload(0x3f40)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(4 * (trace_length / 4 - 1)).\r\n              // val *= numerators[3].\r\n              val := mulmod(val, mload(0x4de0), PRIME)\r\n              // Denominator: point^(trace_length / 4) - 1.\r\n              // val *= denominator_invs[8].\r\n              val := mulmod(val, mload(0x4840), PRIME)\r\n\r\n              // res += val * coefficients[44].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[44]*/ mload(0xac0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc16/minimum: column19_row2 - rc_min.\r\n              let val := addmod(/*column19_row2*/ mload(0x3020), sub(PRIME, /*rc_min*/ mload(0x200)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x47a0), PRIME)\r\n\r\n              // res += val * coefficients[45].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[45]*/ mload(0xae0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc16/maximum: column19_row2 - rc_max.\r\n              let val := addmod(/*column19_row2*/ mload(0x3020), sub(PRIME, /*rc_max*/ mload(0x220)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(4 * (trace_length / 4 - 1)).\r\n              // val *= denominator_invs[9].\r\n              val := mulmod(val, mload(0x4860), PRIME)\r\n\r\n              // res += val * coefficients[46].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[46]*/ mload(0xb00), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for diluted_check/permutation/init0: (diluted_check/permutation/interaction_elm - column19_row5) * column21_inter1_row7 + column19_row1 - diluted_check/permutation/interaction_elm.\r\n              let val := addmod(\r\n                addmod(\r\n                  mulmod(\r\n                    addmod(\r\n                      /*diluted_check/permutation/interaction_elm*/ mload(0x240),\r\n                      sub(PRIME, /*column19_row5*/ mload(0x3080)),\r\n                      PRIME),\r\n                    /*column21_inter1_row7*/ mload(0x3c40),\r\n                    PRIME),\r\n                  /*column19_row1*/ mload(0x3000),\r\n                  PRIME),\r\n                sub(PRIME, /*diluted_check/permutation/interaction_elm*/ mload(0x240)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x47a0), PRIME)\r\n\r\n              // res += val * coefficients[47].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[47]*/ mload(0xb20), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for diluted_check/permutation/step0: (diluted_check/permutation/interaction_elm - column19_row13) * column21_inter1_row15 - (diluted_check/permutation/interaction_elm - column19_row9) * column21_inter1_row7.\r\n              let val := addmod(\r\n                mulmod(\r\n                  addmod(\r\n                    /*diluted_check/permutation/interaction_elm*/ mload(0x240),\r\n                    sub(PRIME, /*column19_row13*/ mload(0x3160)),\r\n                    PRIME),\r\n                  /*column21_inter1_row15*/ mload(0x3c80),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    addmod(\r\n                      /*diluted_check/permutation/interaction_elm*/ mload(0x240),\r\n                      sub(PRIME, /*column19_row9*/ mload(0x3100)),\r\n                      PRIME),\r\n                    /*column21_inter1_row7*/ mload(0x3c40),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(8 * (trace_length / 8 - 1)).\r\n              // val *= numerators[4].\r\n              val := mulmod(val, mload(0x4e00), PRIME)\r\n              // Denominator: point^(trace_length / 8) - 1.\r\n              // val *= denominator_invs[7].\r\n              val := mulmod(val, mload(0x4820), PRIME)\r\n\r\n              // res += val * coefficients[48].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[48]*/ mload(0xb40), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for diluted_check/permutation/last: column21_inter1_row7 - diluted_check/permutation/public_memory_prod.\r\n              let val := addmod(\r\n                /*column21_inter1_row7*/ mload(0x3c40),\r\n                sub(PRIME, /*diluted_check/permutation/public_memory_prod*/ mload(0x260)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(8 * (trace_length / 8 - 1)).\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x4880), PRIME)\r\n\r\n              // res += val * coefficients[49].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[49]*/ mload(0xb60), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for diluted_check/init: column21_inter1_row3 - 1.\r\n              let val := addmod(/*column21_inter1_row3*/ mload(0x3c00), sub(PRIME, 1), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x47a0), PRIME)\r\n\r\n              // res += val * coefficients[50].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[50]*/ mload(0xb80), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for diluted_check/first_element: column19_row5 - diluted_check/first_elm.\r\n              let val := addmod(\r\n                /*column19_row5*/ mload(0x3080),\r\n                sub(PRIME, /*diluted_check/first_elm*/ mload(0x280)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x47a0), PRIME)\r\n\r\n              // res += val * coefficients[51].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[51]*/ mload(0xba0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for diluted_check/step: column21_inter1_row11 - (column21_inter1_row3 * (1 + diluted_check/interaction_z * (column19_row13 - column19_row5)) + diluted_check/interaction_alpha * (column19_row13 - column19_row5) * (column19_row13 - column19_row5)).\r\n              let val := addmod(\r\n                /*column21_inter1_row11*/ mload(0x3c60),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    mulmod(\r\n                      /*column21_inter1_row3*/ mload(0x3c00),\r\n                      addmod(\r\n                        1,\r\n                        mulmod(\r\n                          /*diluted_check/interaction_z*/ mload(0x2a0),\r\n                          addmod(\r\n                            /*column19_row13*/ mload(0x3160),\r\n                            sub(PRIME, /*column19_row5*/ mload(0x3080)),\r\n                            PRIME),\r\n                          PRIME),\r\n                        PRIME),\r\n                      PRIME),\r\n                    mulmod(\r\n                      mulmod(\r\n                        /*diluted_check/interaction_alpha*/ mload(0x2c0),\r\n                        addmod(\r\n                          /*column19_row13*/ mload(0x3160),\r\n                          sub(PRIME, /*column19_row5*/ mload(0x3080)),\r\n                          PRIME),\r\n                        PRIME),\r\n                      addmod(\r\n                        /*column19_row13*/ mload(0x3160),\r\n                        sub(PRIME, /*column19_row5*/ mload(0x3080)),\r\n                        PRIME),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(8 * (trace_length / 8 - 1)).\r\n              // val *= numerators[4].\r\n              val := mulmod(val, mload(0x4e00), PRIME)\r\n              // Denominator: point^(trace_length / 8) - 1.\r\n              // val *= denominator_invs[7].\r\n              val := mulmod(val, mload(0x4820), PRIME)\r\n\r\n              // res += val * coefficients[52].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[52]*/ mload(0xbc0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for diluted_check/last: column21_inter1_row3 - diluted_check/final_cum_val.\r\n              let val := addmod(\r\n                /*column21_inter1_row3*/ mload(0x3c00),\r\n                sub(PRIME, /*diluted_check/final_cum_val*/ mload(0x2e0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - trace_generator^(8 * (trace_length / 8 - 1)).\r\n              // val *= denominator_invs[10].\r\n              val := mulmod(val, mload(0x4880), PRIME)\r\n\r\n              // res += val * coefficients[53].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[53]*/ mload(0xbe0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/last_one_is_zero: column7_row255 * (column4_row0 - (column4_row1 + column4_row1)).\r\n              let val := mulmod(\r\n                /*column7_row255*/ mload(0x23a0),\r\n                addmod(\r\n                  /*column4_row0*/ mload(0x2140),\r\n                  sub(\r\n                    PRIME,\r\n                    addmod(/*column4_row1*/ mload(0x2160), /*column4_row1*/ mload(0x2160), PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[54].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[54]*/ mload(0xc00), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones0: column7_row255 * (column4_row1 - 3138550867693340381917894711603833208051177722232017256448 * column4_row192).\r\n              let val := mulmod(\r\n                /*column7_row255*/ mload(0x23a0),\r\n                addmod(\r\n                  /*column4_row1*/ mload(0x2160),\r\n                  sub(\r\n                    PRIME,\r\n                    mulmod(\r\n                      3138550867693340381917894711603833208051177722232017256448,\r\n                      /*column4_row192*/ mload(0x2180),\r\n                      PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[55].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[55]*/ mload(0xc20), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/cumulative_bit192: column7_row255 - column3_row255 * (column4_row192 - (column4_row193 + column4_row193)).\r\n              let val := addmod(\r\n                /*column7_row255*/ mload(0x23a0),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column3_row255*/ mload(0x2120),\r\n                    addmod(\r\n                      /*column4_row192*/ mload(0x2180),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column4_row193*/ mload(0x21a0), /*column4_row193*/ mload(0x21a0), PRIME)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[56].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[56]*/ mload(0xc40), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones192: column3_row255 * (column4_row193 - 8 * column4_row196).\r\n              let val := mulmod(\r\n                /*column3_row255*/ mload(0x2120),\r\n                addmod(\r\n                  /*column4_row193*/ mload(0x21a0),\r\n                  sub(PRIME, mulmod(8, /*column4_row196*/ mload(0x21c0), PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[57].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[57]*/ mload(0xc60), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/cumulative_bit196: column3_row255 - (column4_row251 - (column4_row252 + column4_row252)) * (column4_row196 - (column4_row197 + column4_row197)).\r\n              let val := addmod(\r\n                /*column3_row255*/ mload(0x2120),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    addmod(\r\n                      /*column4_row251*/ mload(0x2200),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column4_row252*/ mload(0x2220), /*column4_row252*/ mload(0x2220), PRIME)),\r\n                      PRIME),\r\n                    addmod(\r\n                      /*column4_row196*/ mload(0x21c0),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column4_row197*/ mload(0x21e0), /*column4_row197*/ mload(0x21e0), PRIME)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[58].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[58]*/ mload(0xc80), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_unpacking/zeroes_between_ones196: (column4_row251 - (column4_row252 + column4_row252)) * (column4_row197 - 18014398509481984 * column4_row251).\r\n              let val := mulmod(\r\n                addmod(\r\n                  /*column4_row251*/ mload(0x2200),\r\n                  sub(\r\n                    PRIME,\r\n                    addmod(/*column4_row252*/ mload(0x2220), /*column4_row252*/ mload(0x2220), PRIME)),\r\n                  PRIME),\r\n                addmod(\r\n                  /*column4_row197*/ mload(0x21e0),\r\n                  sub(PRIME, mulmod(18014398509481984, /*column4_row251*/ mload(0x2200), PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[59].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[59]*/ mload(0xca0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/booleanity_test: pedersen__hash0__ec_subset_sum__bit_0 * (pedersen__hash0__ec_subset_sum__bit_0 - 1).\r\n              let val := mulmod(\r\n                /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3f60),\r\n                addmod(\r\n                  /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3f60),\r\n                  sub(PRIME, 1),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[60].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[60]*/ mload(0xcc0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/bit_extraction_end: column4_row0.\r\n              let val := /*column4_row0*/ mload(0x2140)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\r\n              // val *= denominator_invs[12].\r\n              val := mulmod(val, mload(0x48c0), PRIME)\r\n\r\n              // res += val * coefficients[61].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[61]*/ mload(0xce0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/zeros_tail: column4_row0.\r\n              let val := /*column4_row0*/ mload(0x2140)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= denominator_invs[13].\r\n              val := mulmod(val, mload(0x48e0), PRIME)\r\n\r\n              // res += val * coefficients[62].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[62]*/ mload(0xd00), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/add_points/slope: pedersen__hash0__ec_subset_sum__bit_0 * (column2_row0 - pedersen__points__y) - column3_row0 * (column1_row0 - pedersen__points__x).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3f60),\r\n                  addmod(\r\n                    /*column2_row0*/ mload(0x2080),\r\n                    sub(PRIME, /*periodic_column/pedersen/points/y*/ mload(0x20)),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column3_row0*/ mload(0x2100),\r\n                    addmod(\r\n                      /*column1_row0*/ mload(0x1fe0),\r\n                      sub(PRIME, /*periodic_column/pedersen/points/x*/ mload(0x0)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[63].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[63]*/ mload(0xd20), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/add_points/x: column3_row0 * column3_row0 - pedersen__hash0__ec_subset_sum__bit_0 * (column1_row0 + pedersen__points__x + column1_row1).\r\n              let val := addmod(\r\n                mulmod(/*column3_row0*/ mload(0x2100), /*column3_row0*/ mload(0x2100), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3f60),\r\n                    addmod(\r\n                      addmod(\r\n                        /*column1_row0*/ mload(0x1fe0),\r\n                        /*periodic_column/pedersen/points/x*/ mload(0x0),\r\n                        PRIME),\r\n                      /*column1_row1*/ mload(0x2000),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[64].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[64]*/ mload(0xd40), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/add_points/y: pedersen__hash0__ec_subset_sum__bit_0 * (column2_row0 + column2_row1) - column3_row0 * (column1_row0 - column1_row1).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_0*/ mload(0x3f60),\r\n                  addmod(/*column2_row0*/ mload(0x2080), /*column2_row1*/ mload(0x20a0), PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column3_row0*/ mload(0x2100),\r\n                    addmod(/*column1_row0*/ mload(0x1fe0), sub(PRIME, /*column1_row1*/ mload(0x2000)), PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[65].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[65]*/ mload(0xd60), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/copy_point/x: pedersen__hash0__ec_subset_sum__bit_neg_0 * (column1_row1 - column1_row0).\r\n              let val := mulmod(\r\n                /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_neg_0*/ mload(0x3f80),\r\n                addmod(/*column1_row1*/ mload(0x2000), sub(PRIME, /*column1_row0*/ mload(0x1fe0)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[66].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[66]*/ mload(0xd80), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/ec_subset_sum/copy_point/y: pedersen__hash0__ec_subset_sum__bit_neg_0 * (column2_row1 - column2_row0).\r\n              let val := mulmod(\r\n                /*intermediate_value/pedersen/hash0/ec_subset_sum/bit_neg_0*/ mload(0x3f80),\r\n                addmod(/*column2_row1*/ mload(0x20a0), sub(PRIME, /*column2_row0*/ mload(0x2080)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[67].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[67]*/ mload(0xda0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/copy_point/x: column1_row256 - column1_row255.\r\n              let val := addmod(\r\n                /*column1_row256*/ mload(0x2040),\r\n                sub(PRIME, /*column1_row255*/ mload(0x2020)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\r\n              // val *= numerators[6].\r\n              val := mulmod(val, mload(0x4e40), PRIME)\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[68].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[68]*/ mload(0xdc0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/copy_point/y: column2_row256 - column2_row255.\r\n              let val := addmod(\r\n                /*column2_row256*/ mload(0x20e0),\r\n                sub(PRIME, /*column2_row255*/ mload(0x20c0)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\r\n              // val *= numerators[6].\r\n              val := mulmod(val, mload(0x4e40), PRIME)\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[69].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[69]*/ mload(0xde0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/init/x: column1_row0 - pedersen/shift_point.x.\r\n              let val := addmod(\r\n                /*column1_row0*/ mload(0x1fe0),\r\n                sub(PRIME, /*pedersen/shift_point.x*/ mload(0x300)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[70].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[70]*/ mload(0xe00), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash0/init/y: column2_row0 - pedersen/shift_point.y.\r\n              let val := addmod(\r\n                /*column2_row0*/ mload(0x2080),\r\n                sub(PRIME, /*pedersen/shift_point.y*/ mload(0x320)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[71].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[71]*/ mload(0xe20), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/ec_subset_sum/bit_unpacking/last_one_is_zero: column15_row255 * (column8_row0 - (column8_row1 + column8_row1)).\r\n              let val := mulmod(\r\n                /*column15_row255*/ mload(0x28a0),\r\n                addmod(\r\n                  /*column8_row0*/ mload(0x23c0),\r\n                  sub(\r\n                    PRIME,\r\n                    addmod(/*column8_row1*/ mload(0x23e0), /*column8_row1*/ mload(0x23e0), PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[72].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[72]*/ mload(0xe40), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/ec_subset_sum/bit_unpacking/zeroes_between_ones0: column15_row255 * (column8_row1 - 3138550867693340381917894711603833208051177722232017256448 * column8_row192).\r\n              let val := mulmod(\r\n                /*column15_row255*/ mload(0x28a0),\r\n                addmod(\r\n                  /*column8_row1*/ mload(0x23e0),\r\n                  sub(\r\n                    PRIME,\r\n                    mulmod(\r\n                      3138550867693340381917894711603833208051177722232017256448,\r\n                      /*column8_row192*/ mload(0x2400),\r\n                      PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[73].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[73]*/ mload(0xe60), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/ec_subset_sum/bit_unpacking/cumulative_bit192: column15_row255 - column11_row255 * (column8_row192 - (column8_row193 + column8_row193)).\r\n              let val := addmod(\r\n                /*column15_row255*/ mload(0x28a0),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column11_row255*/ mload(0x2620),\r\n                    addmod(\r\n                      /*column8_row192*/ mload(0x2400),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column8_row193*/ mload(0x2420), /*column8_row193*/ mload(0x2420), PRIME)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[74].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[74]*/ mload(0xe80), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/ec_subset_sum/bit_unpacking/zeroes_between_ones192: column11_row255 * (column8_row193 - 8 * column8_row196).\r\n              let val := mulmod(\r\n                /*column11_row255*/ mload(0x2620),\r\n                addmod(\r\n                  /*column8_row193*/ mload(0x2420),\r\n                  sub(PRIME, mulmod(8, /*column8_row196*/ mload(0x2440), PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[75].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[75]*/ mload(0xea0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/ec_subset_sum/bit_unpacking/cumulative_bit196: column11_row255 - (column8_row251 - (column8_row252 + column8_row252)) * (column8_row196 - (column8_row197 + column8_row197)).\r\n              let val := addmod(\r\n                /*column11_row255*/ mload(0x2620),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    addmod(\r\n                      /*column8_row251*/ mload(0x2480),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column8_row252*/ mload(0x24a0), /*column8_row252*/ mload(0x24a0), PRIME)),\r\n                      PRIME),\r\n                    addmod(\r\n                      /*column8_row196*/ mload(0x2440),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column8_row197*/ mload(0x2460), /*column8_row197*/ mload(0x2460), PRIME)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[76].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[76]*/ mload(0xec0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/ec_subset_sum/bit_unpacking/zeroes_between_ones196: (column8_row251 - (column8_row252 + column8_row252)) * (column8_row197 - 18014398509481984 * column8_row251).\r\n              let val := mulmod(\r\n                addmod(\r\n                  /*column8_row251*/ mload(0x2480),\r\n                  sub(\r\n                    PRIME,\r\n                    addmod(/*column8_row252*/ mload(0x24a0), /*column8_row252*/ mload(0x24a0), PRIME)),\r\n                  PRIME),\r\n                addmod(\r\n                  /*column8_row197*/ mload(0x2460),\r\n                  sub(PRIME, mulmod(18014398509481984, /*column8_row251*/ mload(0x2480), PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[77].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[77]*/ mload(0xee0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/ec_subset_sum/booleanity_test: pedersen__hash1__ec_subset_sum__bit_0 * (pedersen__hash1__ec_subset_sum__bit_0 - 1).\r\n              let val := mulmod(\r\n                /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x3fa0),\r\n                addmod(\r\n                  /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x3fa0),\r\n                  sub(PRIME, 1),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[78].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[78]*/ mload(0xf00), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/ec_subset_sum/bit_extraction_end: column8_row0.\r\n              let val := /*column8_row0*/ mload(0x23c0)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\r\n              // val *= denominator_invs[12].\r\n              val := mulmod(val, mload(0x48c0), PRIME)\r\n\r\n              // res += val * coefficients[79].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[79]*/ mload(0xf20), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/ec_subset_sum/zeros_tail: column8_row0.\r\n              let val := /*column8_row0*/ mload(0x23c0)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= denominator_invs[13].\r\n              val := mulmod(val, mload(0x48e0), PRIME)\r\n\r\n              // res += val * coefficients[80].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[80]*/ mload(0xf40), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/ec_subset_sum/add_points/slope: pedersen__hash1__ec_subset_sum__bit_0 * (column6_row0 - pedersen__points__y) - column7_row0 * (column5_row0 - pedersen__points__x).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x3fa0),\r\n                  addmod(\r\n                    /*column6_row0*/ mload(0x2300),\r\n                    sub(PRIME, /*periodic_column/pedersen/points/y*/ mload(0x20)),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column7_row0*/ mload(0x2380),\r\n                    addmod(\r\n                      /*column5_row0*/ mload(0x2260),\r\n                      sub(PRIME, /*periodic_column/pedersen/points/x*/ mload(0x0)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[81].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[81]*/ mload(0xf60), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/ec_subset_sum/add_points/x: column7_row0 * column7_row0 - pedersen__hash1__ec_subset_sum__bit_0 * (column5_row0 + pedersen__points__x + column5_row1).\r\n              let val := addmod(\r\n                mulmod(/*column7_row0*/ mload(0x2380), /*column7_row0*/ mload(0x2380), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x3fa0),\r\n                    addmod(\r\n                      addmod(\r\n                        /*column5_row0*/ mload(0x2260),\r\n                        /*periodic_column/pedersen/points/x*/ mload(0x0),\r\n                        PRIME),\r\n                      /*column5_row1*/ mload(0x2280),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[82].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[82]*/ mload(0xf80), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/ec_subset_sum/add_points/y: pedersen__hash1__ec_subset_sum__bit_0 * (column6_row0 + column6_row1) - column7_row0 * (column5_row0 - column5_row1).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_0*/ mload(0x3fa0),\r\n                  addmod(/*column6_row0*/ mload(0x2300), /*column6_row1*/ mload(0x2320), PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column7_row0*/ mload(0x2380),\r\n                    addmod(/*column5_row0*/ mload(0x2260), sub(PRIME, /*column5_row1*/ mload(0x2280)), PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[83].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[83]*/ mload(0xfa0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/ec_subset_sum/copy_point/x: pedersen__hash1__ec_subset_sum__bit_neg_0 * (column5_row1 - column5_row0).\r\n              let val := mulmod(\r\n                /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_neg_0*/ mload(0x3fc0),\r\n                addmod(/*column5_row1*/ mload(0x2280), sub(PRIME, /*column5_row0*/ mload(0x2260)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[84].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[84]*/ mload(0xfc0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/ec_subset_sum/copy_point/y: pedersen__hash1__ec_subset_sum__bit_neg_0 * (column6_row1 - column6_row0).\r\n              let val := mulmod(\r\n                /*intermediate_value/pedersen/hash1/ec_subset_sum/bit_neg_0*/ mload(0x3fc0),\r\n                addmod(/*column6_row1*/ mload(0x2320), sub(PRIME, /*column6_row0*/ mload(0x2300)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[85].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[85]*/ mload(0xfe0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/copy_point/x: column5_row256 - column5_row255.\r\n              let val := addmod(\r\n                /*column5_row256*/ mload(0x22c0),\r\n                sub(PRIME, /*column5_row255*/ mload(0x22a0)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\r\n              // val *= numerators[6].\r\n              val := mulmod(val, mload(0x4e40), PRIME)\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[86].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[86]*/ mload(0x1000), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/copy_point/y: column6_row256 - column6_row255.\r\n              let val := addmod(\r\n                /*column6_row256*/ mload(0x2360),\r\n                sub(PRIME, /*column6_row255*/ mload(0x2340)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\r\n              // val *= numerators[6].\r\n              val := mulmod(val, mload(0x4e40), PRIME)\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[87].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[87]*/ mload(0x1020), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/init/x: column5_row0 - pedersen/shift_point.x.\r\n              let val := addmod(\r\n                /*column5_row0*/ mload(0x2260),\r\n                sub(PRIME, /*pedersen/shift_point.x*/ mload(0x300)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[88].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[88]*/ mload(0x1040), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash1/init/y: column6_row0 - pedersen/shift_point.y.\r\n              let val := addmod(\r\n                /*column6_row0*/ mload(0x2300),\r\n                sub(PRIME, /*pedersen/shift_point.y*/ mload(0x320)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[89].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[89]*/ mload(0x1060), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/ec_subset_sum/bit_unpacking/last_one_is_zero: column20_row147 * (column12_row0 - (column12_row1 + column12_row1)).\r\n              let val := mulmod(\r\n                /*column20_row147*/ mload(0x3980),\r\n                addmod(\r\n                  /*column12_row0*/ mload(0x2640),\r\n                  sub(\r\n                    PRIME,\r\n                    addmod(/*column12_row1*/ mload(0x2660), /*column12_row1*/ mload(0x2660), PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[90].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[90]*/ mload(0x1080), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/ec_subset_sum/bit_unpacking/zeroes_between_ones0: column20_row147 * (column12_row1 - 3138550867693340381917894711603833208051177722232017256448 * column12_row192).\r\n              let val := mulmod(\r\n                /*column20_row147*/ mload(0x3980),\r\n                addmod(\r\n                  /*column12_row1*/ mload(0x2660),\r\n                  sub(\r\n                    PRIME,\r\n                    mulmod(\r\n                      3138550867693340381917894711603833208051177722232017256448,\r\n                      /*column12_row192*/ mload(0x2680),\r\n                      PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[91].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[91]*/ mload(0x10a0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/ec_subset_sum/bit_unpacking/cumulative_bit192: column20_row147 - column20_row19 * (column12_row192 - (column12_row193 + column12_row193)).\r\n              let val := addmod(\r\n                /*column20_row147*/ mload(0x3980),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column20_row19*/ mload(0x3820),\r\n                    addmod(\r\n                      /*column12_row192*/ mload(0x2680),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column12_row193*/ mload(0x26a0), /*column12_row193*/ mload(0x26a0), PRIME)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[92].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[92]*/ mload(0x10c0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/ec_subset_sum/bit_unpacking/zeroes_between_ones192: column20_row19 * (column12_row193 - 8 * column12_row196).\r\n              let val := mulmod(\r\n                /*column20_row19*/ mload(0x3820),\r\n                addmod(\r\n                  /*column12_row193*/ mload(0x26a0),\r\n                  sub(PRIME, mulmod(8, /*column12_row196*/ mload(0x26c0), PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[93].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[93]*/ mload(0x10e0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/ec_subset_sum/bit_unpacking/cumulative_bit196: column20_row19 - (column12_row251 - (column12_row252 + column12_row252)) * (column12_row196 - (column12_row197 + column12_row197)).\r\n              let val := addmod(\r\n                /*column20_row19*/ mload(0x3820),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    addmod(\r\n                      /*column12_row251*/ mload(0x2700),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column12_row252*/ mload(0x2720), /*column12_row252*/ mload(0x2720), PRIME)),\r\n                      PRIME),\r\n                    addmod(\r\n                      /*column12_row196*/ mload(0x26c0),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column12_row197*/ mload(0x26e0), /*column12_row197*/ mload(0x26e0), PRIME)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[94].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[94]*/ mload(0x1100), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/ec_subset_sum/bit_unpacking/zeroes_between_ones196: (column12_row251 - (column12_row252 + column12_row252)) * (column12_row197 - 18014398509481984 * column12_row251).\r\n              let val := mulmod(\r\n                addmod(\r\n                  /*column12_row251*/ mload(0x2700),\r\n                  sub(\r\n                    PRIME,\r\n                    addmod(/*column12_row252*/ mload(0x2720), /*column12_row252*/ mload(0x2720), PRIME)),\r\n                  PRIME),\r\n                addmod(\r\n                  /*column12_row197*/ mload(0x26e0),\r\n                  sub(PRIME, mulmod(18014398509481984, /*column12_row251*/ mload(0x2700), PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[95].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[95]*/ mload(0x1120), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/ec_subset_sum/booleanity_test: pedersen__hash2__ec_subset_sum__bit_0 * (pedersen__hash2__ec_subset_sum__bit_0 - 1).\r\n              let val := mulmod(\r\n                /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x3fe0),\r\n                addmod(\r\n                  /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x3fe0),\r\n                  sub(PRIME, 1),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[96].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[96]*/ mload(0x1140), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/ec_subset_sum/bit_extraction_end: column12_row0.\r\n              let val := /*column12_row0*/ mload(0x2640)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\r\n              // val *= denominator_invs[12].\r\n              val := mulmod(val, mload(0x48c0), PRIME)\r\n\r\n              // res += val * coefficients[97].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[97]*/ mload(0x1160), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/ec_subset_sum/zeros_tail: column12_row0.\r\n              let val := /*column12_row0*/ mload(0x2640)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= denominator_invs[13].\r\n              val := mulmod(val, mload(0x48e0), PRIME)\r\n\r\n              // res += val * coefficients[98].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[98]*/ mload(0x1180), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/ec_subset_sum/add_points/slope: pedersen__hash2__ec_subset_sum__bit_0 * (column10_row0 - pedersen__points__y) - column11_row0 * (column9_row0 - pedersen__points__x).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x3fe0),\r\n                  addmod(\r\n                    /*column10_row0*/ mload(0x2580),\r\n                    sub(PRIME, /*periodic_column/pedersen/points/y*/ mload(0x20)),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column11_row0*/ mload(0x2600),\r\n                    addmod(\r\n                      /*column9_row0*/ mload(0x24e0),\r\n                      sub(PRIME, /*periodic_column/pedersen/points/x*/ mload(0x0)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[99].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[99]*/ mload(0x11a0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/ec_subset_sum/add_points/x: column11_row0 * column11_row0 - pedersen__hash2__ec_subset_sum__bit_0 * (column9_row0 + pedersen__points__x + column9_row1).\r\n              let val := addmod(\r\n                mulmod(/*column11_row0*/ mload(0x2600), /*column11_row0*/ mload(0x2600), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x3fe0),\r\n                    addmod(\r\n                      addmod(\r\n                        /*column9_row0*/ mload(0x24e0),\r\n                        /*periodic_column/pedersen/points/x*/ mload(0x0),\r\n                        PRIME),\r\n                      /*column9_row1*/ mload(0x2500),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[100].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[100]*/ mload(0x11c0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/ec_subset_sum/add_points/y: pedersen__hash2__ec_subset_sum__bit_0 * (column10_row0 + column10_row1) - column11_row0 * (column9_row0 - column9_row1).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_0*/ mload(0x3fe0),\r\n                  addmod(/*column10_row0*/ mload(0x2580), /*column10_row1*/ mload(0x25a0), PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column11_row0*/ mload(0x2600),\r\n                    addmod(/*column9_row0*/ mload(0x24e0), sub(PRIME, /*column9_row1*/ mload(0x2500)), PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[101].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[101]*/ mload(0x11e0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/ec_subset_sum/copy_point/x: pedersen__hash2__ec_subset_sum__bit_neg_0 * (column9_row1 - column9_row0).\r\n              let val := mulmod(\r\n                /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_neg_0*/ mload(0x4000),\r\n                addmod(/*column9_row1*/ mload(0x2500), sub(PRIME, /*column9_row0*/ mload(0x24e0)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[102].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[102]*/ mload(0x1200), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/ec_subset_sum/copy_point/y: pedersen__hash2__ec_subset_sum__bit_neg_0 * (column10_row1 - column10_row0).\r\n              let val := mulmod(\r\n                /*intermediate_value/pedersen/hash2/ec_subset_sum/bit_neg_0*/ mload(0x4000),\r\n                addmod(/*column10_row1*/ mload(0x25a0), sub(PRIME, /*column10_row0*/ mload(0x2580)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[103].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[103]*/ mload(0x1220), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/copy_point/x: column9_row256 - column9_row255.\r\n              let val := addmod(\r\n                /*column9_row256*/ mload(0x2540),\r\n                sub(PRIME, /*column9_row255*/ mload(0x2520)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\r\n              // val *= numerators[6].\r\n              val := mulmod(val, mload(0x4e40), PRIME)\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[104].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[104]*/ mload(0x1240), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/copy_point/y: column10_row256 - column10_row255.\r\n              let val := addmod(\r\n                /*column10_row256*/ mload(0x25e0),\r\n                sub(PRIME, /*column10_row255*/ mload(0x25c0)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\r\n              // val *= numerators[6].\r\n              val := mulmod(val, mload(0x4e40), PRIME)\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[105].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[105]*/ mload(0x1260), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/init/x: column9_row0 - pedersen/shift_point.x.\r\n              let val := addmod(\r\n                /*column9_row0*/ mload(0x24e0),\r\n                sub(PRIME, /*pedersen/shift_point.x*/ mload(0x300)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[106].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[106]*/ mload(0x1280), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash2/init/y: column10_row0 - pedersen/shift_point.y.\r\n              let val := addmod(\r\n                /*column10_row0*/ mload(0x2580),\r\n                sub(PRIME, /*pedersen/shift_point.y*/ mload(0x320)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[107].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[107]*/ mload(0x12a0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/ec_subset_sum/bit_unpacking/last_one_is_zero: column20_row211 * (column16_row0 - (column16_row1 + column16_row1)).\r\n              let val := mulmod(\r\n                /*column20_row211*/ mload(0x39a0),\r\n                addmod(\r\n                  /*column16_row0*/ mload(0x28c0),\r\n                  sub(\r\n                    PRIME,\r\n                    addmod(/*column16_row1*/ mload(0x28e0), /*column16_row1*/ mload(0x28e0), PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[108].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[108]*/ mload(0x12c0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/ec_subset_sum/bit_unpacking/zeroes_between_ones0: column20_row211 * (column16_row1 - 3138550867693340381917894711603833208051177722232017256448 * column16_row192).\r\n              let val := mulmod(\r\n                /*column20_row211*/ mload(0x39a0),\r\n                addmod(\r\n                  /*column16_row1*/ mload(0x28e0),\r\n                  sub(\r\n                    PRIME,\r\n                    mulmod(\r\n                      3138550867693340381917894711603833208051177722232017256448,\r\n                      /*column16_row192*/ mload(0x2900),\r\n                      PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[109].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[109]*/ mload(0x12e0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/ec_subset_sum/bit_unpacking/cumulative_bit192: column20_row211 - column20_row83 * (column16_row192 - (column16_row193 + column16_row193)).\r\n              let val := addmod(\r\n                /*column20_row211*/ mload(0x39a0),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column20_row83*/ mload(0x3960),\r\n                    addmod(\r\n                      /*column16_row192*/ mload(0x2900),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column16_row193*/ mload(0x2920), /*column16_row193*/ mload(0x2920), PRIME)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[110].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[110]*/ mload(0x1300), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/ec_subset_sum/bit_unpacking/zeroes_between_ones192: column20_row83 * (column16_row193 - 8 * column16_row196).\r\n              let val := mulmod(\r\n                /*column20_row83*/ mload(0x3960),\r\n                addmod(\r\n                  /*column16_row193*/ mload(0x2920),\r\n                  sub(PRIME, mulmod(8, /*column16_row196*/ mload(0x2940), PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[111].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[111]*/ mload(0x1320), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/ec_subset_sum/bit_unpacking/cumulative_bit196: column20_row83 - (column16_row251 - (column16_row252 + column16_row252)) * (column16_row196 - (column16_row197 + column16_row197)).\r\n              let val := addmod(\r\n                /*column20_row83*/ mload(0x3960),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    addmod(\r\n                      /*column16_row251*/ mload(0x2980),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column16_row252*/ mload(0x29a0), /*column16_row252*/ mload(0x29a0), PRIME)),\r\n                      PRIME),\r\n                    addmod(\r\n                      /*column16_row196*/ mload(0x2940),\r\n                      sub(\r\n                        PRIME,\r\n                        addmod(/*column16_row197*/ mload(0x2960), /*column16_row197*/ mload(0x2960), PRIME)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[112].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[112]*/ mload(0x1340), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/ec_subset_sum/bit_unpacking/zeroes_between_ones196: (column16_row251 - (column16_row252 + column16_row252)) * (column16_row197 - 18014398509481984 * column16_row251).\r\n              let val := mulmod(\r\n                addmod(\r\n                  /*column16_row251*/ mload(0x2980),\r\n                  sub(\r\n                    PRIME,\r\n                    addmod(/*column16_row252*/ mload(0x29a0), /*column16_row252*/ mload(0x29a0), PRIME)),\r\n                  PRIME),\r\n                addmod(\r\n                  /*column16_row197*/ mload(0x2960),\r\n                  sub(PRIME, mulmod(18014398509481984, /*column16_row251*/ mload(0x2980), PRIME)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[113].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[113]*/ mload(0x1360), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/ec_subset_sum/booleanity_test: pedersen__hash3__ec_subset_sum__bit_0 * (pedersen__hash3__ec_subset_sum__bit_0 - 1).\r\n              let val := mulmod(\r\n                /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x4020),\r\n                addmod(\r\n                  /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x4020),\r\n                  sub(PRIME, 1),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[114].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[114]*/ mload(0x1380), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/ec_subset_sum/bit_extraction_end: column16_row0.\r\n              let val := /*column16_row0*/ mload(0x28c0)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - trace_generator^(63 * trace_length / 64).\r\n              // val *= denominator_invs[12].\r\n              val := mulmod(val, mload(0x48c0), PRIME)\r\n\r\n              // res += val * coefficients[115].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[115]*/ mload(0x13a0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/ec_subset_sum/zeros_tail: column16_row0.\r\n              let val := /*column16_row0*/ mload(0x28c0)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= denominator_invs[13].\r\n              val := mulmod(val, mload(0x48e0), PRIME)\r\n\r\n              // res += val * coefficients[116].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[116]*/ mload(0x13c0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/ec_subset_sum/add_points/slope: pedersen__hash3__ec_subset_sum__bit_0 * (column14_row0 - pedersen__points__y) - column15_row0 * (column13_row0 - pedersen__points__x).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x4020),\r\n                  addmod(\r\n                    /*column14_row0*/ mload(0x2800),\r\n                    sub(PRIME, /*periodic_column/pedersen/points/y*/ mload(0x20)),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column15_row0*/ mload(0x2880),\r\n                    addmod(\r\n                      /*column13_row0*/ mload(0x2760),\r\n                      sub(PRIME, /*periodic_column/pedersen/points/x*/ mload(0x0)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[117].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[117]*/ mload(0x13e0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/ec_subset_sum/add_points/x: column15_row0 * column15_row0 - pedersen__hash3__ec_subset_sum__bit_0 * (column13_row0 + pedersen__points__x + column13_row1).\r\n              let val := addmod(\r\n                mulmod(/*column15_row0*/ mload(0x2880), /*column15_row0*/ mload(0x2880), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x4020),\r\n                    addmod(\r\n                      addmod(\r\n                        /*column13_row0*/ mload(0x2760),\r\n                        /*periodic_column/pedersen/points/x*/ mload(0x0),\r\n                        PRIME),\r\n                      /*column13_row1*/ mload(0x2780),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[118].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[118]*/ mload(0x1400), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/ec_subset_sum/add_points/y: pedersen__hash3__ec_subset_sum__bit_0 * (column14_row0 + column14_row1) - column15_row0 * (column13_row0 - column13_row1).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_0*/ mload(0x4020),\r\n                  addmod(/*column14_row0*/ mload(0x2800), /*column14_row1*/ mload(0x2820), PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column15_row0*/ mload(0x2880),\r\n                    addmod(/*column13_row0*/ mload(0x2760), sub(PRIME, /*column13_row1*/ mload(0x2780)), PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[119].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[119]*/ mload(0x1420), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/ec_subset_sum/copy_point/x: pedersen__hash3__ec_subset_sum__bit_neg_0 * (column13_row1 - column13_row0).\r\n              let val := mulmod(\r\n                /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_neg_0*/ mload(0x4040),\r\n                addmod(/*column13_row1*/ mload(0x2780), sub(PRIME, /*column13_row0*/ mload(0x2760)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[120].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[120]*/ mload(0x1440), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/ec_subset_sum/copy_point/y: pedersen__hash3__ec_subset_sum__bit_neg_0 * (column14_row1 - column14_row0).\r\n              let val := mulmod(\r\n                /*intermediate_value/pedersen/hash3/ec_subset_sum/bit_neg_0*/ mload(0x4040),\r\n                addmod(/*column14_row1*/ mload(0x2820), sub(PRIME, /*column14_row0*/ mload(0x2800)), PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 256) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[5].\r\n              val := mulmod(val, mload(0x4e20), PRIME)\r\n              // Denominator: point^trace_length - 1.\r\n              // val *= denominator_invs[0].\r\n              val := mulmod(val, mload(0x4740), PRIME)\r\n\r\n              // res += val * coefficients[121].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[121]*/ mload(0x1460), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/copy_point/x: column13_row256 - column13_row255.\r\n              let val := addmod(\r\n                /*column13_row256*/ mload(0x27c0),\r\n                sub(PRIME, /*column13_row255*/ mload(0x27a0)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\r\n              // val *= numerators[6].\r\n              val := mulmod(val, mload(0x4e40), PRIME)\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[122].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[122]*/ mload(0x1480), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/copy_point/y: column14_row256 - column14_row255.\r\n              let val := addmod(\r\n                /*column14_row256*/ mload(0x2860),\r\n                sub(PRIME, /*column14_row255*/ mload(0x2840)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 512) - trace_generator^(trace_length / 2).\r\n              // val *= numerators[6].\r\n              val := mulmod(val, mload(0x4e40), PRIME)\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[123].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[123]*/ mload(0x14a0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/init/x: column13_row0 - pedersen/shift_point.x.\r\n              let val := addmod(\r\n                /*column13_row0*/ mload(0x2760),\r\n                sub(PRIME, /*pedersen/shift_point.x*/ mload(0x300)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[124].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[124]*/ mload(0x14c0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/hash3/init/y: column14_row0 - pedersen/shift_point.y.\r\n              let val := addmod(\r\n                /*column14_row0*/ mload(0x2800),\r\n                sub(PRIME, /*pedersen/shift_point.y*/ mload(0x320)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[125].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[125]*/ mload(0x14e0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/input0_value0: column17_row7 - column4_row0.\r\n              let val := addmod(/*column17_row7*/ mload(0x2ac0), sub(PRIME, /*column4_row0*/ mload(0x2140)), PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[126].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[126]*/ mload(0x1500), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/input0_value1: column17_row135 - column8_row0.\r\n              let val := addmod(\r\n                /*column17_row135*/ mload(0x2ca0),\r\n                sub(PRIME, /*column8_row0*/ mload(0x23c0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[127].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[127]*/ mload(0x1520), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/input0_value2: column17_row263 - column12_row0.\r\n              let val := addmod(\r\n                /*column17_row263*/ mload(0x2d60),\r\n                sub(PRIME, /*column12_row0*/ mload(0x2640)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[128].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[128]*/ mload(0x1540), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/input0_value3: column17_row391 - column16_row0.\r\n              let val := addmod(\r\n                /*column17_row391*/ mload(0x2dc0),\r\n                sub(PRIME, /*column16_row0*/ mload(0x28c0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[129].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[129]*/ mload(0x1560), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/input0_addr: column17_row134 - (column17_row38 + 1).\r\n              let val := addmod(\r\n                /*column17_row134*/ mload(0x2c80),\r\n                sub(PRIME, addmod(/*column17_row38*/ mload(0x2bc0), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(128 * (trace_length / 128 - 1)).\r\n              // val *= numerators[7].\r\n              val := mulmod(val, mload(0x4e60), PRIME)\r\n              // Denominator: point^(trace_length / 128) - 1.\r\n              // val *= denominator_invs[15].\r\n              val := mulmod(val, mload(0x4920), PRIME)\r\n\r\n              // res += val * coefficients[130].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[130]*/ mload(0x1580), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/init_addr: column17_row6 - initial_pedersen_addr.\r\n              let val := addmod(\r\n                /*column17_row6*/ mload(0x2aa0),\r\n                sub(PRIME, /*initial_pedersen_addr*/ mload(0x340)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x47a0), PRIME)\r\n\r\n              // res += val * coefficients[131].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[131]*/ mload(0x15a0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/input1_value0: column17_row71 - column4_row256.\r\n              let val := addmod(\r\n                /*column17_row71*/ mload(0x2c20),\r\n                sub(PRIME, /*column4_row256*/ mload(0x2240)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[132].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[132]*/ mload(0x15c0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/input1_value1: column17_row199 - column8_row256.\r\n              let val := addmod(\r\n                /*column17_row199*/ mload(0x2d20),\r\n                sub(PRIME, /*column8_row256*/ mload(0x24c0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[133].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[133]*/ mload(0x15e0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/input1_value2: column17_row327 - column12_row256.\r\n              let val := addmod(\r\n                /*column17_row327*/ mload(0x2da0),\r\n                sub(PRIME, /*column12_row256*/ mload(0x2740)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[134].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[134]*/ mload(0x1600), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/input1_value3: column17_row455 - column16_row256.\r\n              let val := addmod(\r\n                /*column17_row455*/ mload(0x2e20),\r\n                sub(PRIME, /*column16_row256*/ mload(0x29c0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[135].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[135]*/ mload(0x1620), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/input1_addr: column17_row70 - (column17_row6 + 1).\r\n              let val := addmod(\r\n                /*column17_row70*/ mload(0x2c00),\r\n                sub(PRIME, addmod(/*column17_row6*/ mload(0x2aa0), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 128) - 1.\r\n              // val *= denominator_invs[15].\r\n              val := mulmod(val, mload(0x4920), PRIME)\r\n\r\n              // res += val * coefficients[136].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[136]*/ mload(0x1640), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/output_value0: column17_row39 - column1_row511.\r\n              let val := addmod(\r\n                /*column17_row39*/ mload(0x2be0),\r\n                sub(PRIME, /*column1_row511*/ mload(0x2060)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[137].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[137]*/ mload(0x1660), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/output_value1: column17_row167 - column5_row511.\r\n              let val := addmod(\r\n                /*column17_row167*/ mload(0x2d00),\r\n                sub(PRIME, /*column5_row511*/ mload(0x22e0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[138].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[138]*/ mload(0x1680), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/output_value2: column17_row295 - column9_row511.\r\n              let val := addmod(\r\n                /*column17_row295*/ mload(0x2d80),\r\n                sub(PRIME, /*column9_row511*/ mload(0x2560)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[139].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[139]*/ mload(0x16a0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/output_value3: column17_row423 - column13_row511.\r\n              let val := addmod(\r\n                /*column17_row423*/ mload(0x2e00),\r\n                sub(PRIME, /*column13_row511*/ mload(0x27e0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 512) - 1.\r\n              // val *= denominator_invs[14].\r\n              val := mulmod(val, mload(0x4900), PRIME)\r\n\r\n              // res += val * coefficients[140].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[140]*/ mload(0x16c0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for pedersen/output_addr: column17_row38 - (column17_row70 + 1).\r\n              let val := addmod(\r\n                /*column17_row38*/ mload(0x2bc0),\r\n                sub(PRIME, addmod(/*column17_row70*/ mload(0x2c00), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 128) - 1.\r\n              // val *= denominator_invs[15].\r\n              val := mulmod(val, mload(0x4920), PRIME)\r\n\r\n              // res += val * coefficients[141].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[141]*/ mload(0x16e0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc_builtin/value: rc_builtin__value7_0 - column17_row103.\r\n              let val := addmod(\r\n                /*intermediate_value/rc_builtin/value7_0*/ mload(0x4140),\r\n                sub(PRIME, /*column17_row103*/ mload(0x2c60)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 128) - 1.\r\n              // val *= denominator_invs[15].\r\n              val := mulmod(val, mload(0x4920), PRIME)\r\n\r\n              // res += val * coefficients[142].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[142]*/ mload(0x1700), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc_builtin/addr_step: column17_row230 - (column17_row102 + 1).\r\n              let val := addmod(\r\n                /*column17_row230*/ mload(0x2d40),\r\n                sub(PRIME, addmod(/*column17_row102*/ mload(0x2c40), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(128 * (trace_length / 128 - 1)).\r\n              // val *= numerators[7].\r\n              val := mulmod(val, mload(0x4e60), PRIME)\r\n              // Denominator: point^(trace_length / 128) - 1.\r\n              // val *= denominator_invs[15].\r\n              val := mulmod(val, mload(0x4920), PRIME)\r\n\r\n              // res += val * coefficients[143].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[143]*/ mload(0x1720), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for rc_builtin/init_addr: column17_row102 - initial_rc_addr.\r\n              let val := addmod(\r\n                /*column17_row102*/ mload(0x2c40),\r\n                sub(PRIME, /*initial_rc_addr*/ mload(0x360)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x47a0), PRIME)\r\n\r\n              // res += val * coefficients[144].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[144]*/ mload(0x1740), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/doubling_key/slope: ecdsa__signature0__doubling_key__x_squared + ecdsa__signature0__doubling_key__x_squared + ecdsa__signature0__doubling_key__x_squared + ecdsa/sig_config.alpha - (column20_row12 + column20_row12) * column20_row2.\r\n              let val := addmod(\r\n                addmod(\r\n                  addmod(\r\n                    addmod(\r\n                      /*intermediate_value/ecdsa/signature0/doubling_key/x_squared*/ mload(0x4160),\r\n                      /*intermediate_value/ecdsa/signature0/doubling_key/x_squared*/ mload(0x4160),\r\n                      PRIME),\r\n                    /*intermediate_value/ecdsa/signature0/doubling_key/x_squared*/ mload(0x4160),\r\n                    PRIME),\r\n                  /*ecdsa/sig_config.alpha*/ mload(0x380),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    addmod(/*column20_row12*/ mload(0x37a0), /*column20_row12*/ mload(0x37a0), PRIME),\r\n                    /*column20_row2*/ mload(0x36a0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x4e80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[145].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[145]*/ mload(0x1760), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/doubling_key/x: column20_row2 * column20_row2 - (column20_row4 + column20_row4 + column20_row20).\r\n              let val := addmod(\r\n                mulmod(/*column20_row2*/ mload(0x36a0), /*column20_row2*/ mload(0x36a0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(/*column20_row4*/ mload(0x36e0), /*column20_row4*/ mload(0x36e0), PRIME),\r\n                    /*column20_row20*/ mload(0x3840),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x4e80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[146].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[146]*/ mload(0x1780), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/doubling_key/y: column20_row12 + column20_row28 - column20_row2 * (column20_row4 - column20_row20).\r\n              let val := addmod(\r\n                addmod(/*column20_row12*/ mload(0x37a0), /*column20_row28*/ mload(0x38c0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column20_row2*/ mload(0x36a0),\r\n                    addmod(\r\n                      /*column20_row4*/ mload(0x36e0),\r\n                      sub(PRIME, /*column20_row20*/ mload(0x3840)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x4e80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[147].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[147]*/ mload(0x17a0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/booleanity_test: ecdsa__signature0__exponentiate_generator__bit_0 * (ecdsa__signature0__exponentiate_generator__bit_0 - 1).\r\n              let val := mulmod(\r\n                /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x4180),\r\n                addmod(\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x4180),\r\n                  sub(PRIME, 1),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[9].\r\n              val := mulmod(val, mload(0x4ea0), PRIME)\r\n              // Denominator: point^(trace_length / 32) - 1.\r\n              // val *= denominator_invs[16].\r\n              val := mulmod(val, mload(0x4940), PRIME)\r\n\r\n              // res += val * coefficients[148].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[148]*/ mload(0x17c0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/bit_extraction_end: column20_row29.\r\n              let val := /*column20_row29*/ mload(0x38e0)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - trace_generator^(251 * trace_length / 256).\r\n              // val *= denominator_invs[17].\r\n              val := mulmod(val, mload(0x4960), PRIME)\r\n\r\n              // res += val * coefficients[149].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[149]*/ mload(0x17e0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/zeros_tail: column20_row29.\r\n              let val := /*column20_row29*/ mload(0x38e0)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\r\n              // val *= denominator_invs[18].\r\n              val := mulmod(val, mload(0x4980), PRIME)\r\n\r\n              // res += val * coefficients[150].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[150]*/ mload(0x1800), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/add_points/slope: ecdsa__signature0__exponentiate_generator__bit_0 * (column20_row21 - ecdsa__generator_points__y) - column20_row13 * (column20_row5 - ecdsa__generator_points__x).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x4180),\r\n                  addmod(\r\n                    /*column20_row21*/ mload(0x3860),\r\n                    sub(PRIME, /*periodic_column/ecdsa/generator_points/y*/ mload(0x60)),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column20_row13*/ mload(0x37c0),\r\n                    addmod(\r\n                      /*column20_row5*/ mload(0x3700),\r\n                      sub(PRIME, /*periodic_column/ecdsa/generator_points/x*/ mload(0x40)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[9].\r\n              val := mulmod(val, mload(0x4ea0), PRIME)\r\n              // Denominator: point^(trace_length / 32) - 1.\r\n              // val *= denominator_invs[16].\r\n              val := mulmod(val, mload(0x4940), PRIME)\r\n\r\n              // res += val * coefficients[151].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[151]*/ mload(0x1820), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/add_points/x: column20_row13 * column20_row13 - ecdsa__signature0__exponentiate_generator__bit_0 * (column20_row5 + ecdsa__generator_points__x + column20_row37).\r\n              let val := addmod(\r\n                mulmod(/*column20_row13*/ mload(0x37c0), /*column20_row13*/ mload(0x37c0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x4180),\r\n                    addmod(\r\n                      addmod(\r\n                        /*column20_row5*/ mload(0x3700),\r\n                        /*periodic_column/ecdsa/generator_points/x*/ mload(0x40),\r\n                        PRIME),\r\n                      /*column20_row37*/ mload(0x3900),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[9].\r\n              val := mulmod(val, mload(0x4ea0), PRIME)\r\n              // Denominator: point^(trace_length / 32) - 1.\r\n              // val *= denominator_invs[16].\r\n              val := mulmod(val, mload(0x4940), PRIME)\r\n\r\n              // res += val * coefficients[152].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[152]*/ mload(0x1840), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/add_points/y: ecdsa__signature0__exponentiate_generator__bit_0 * (column20_row21 + column20_row53) - column20_row13 * (column20_row5 - column20_row37).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_0*/ mload(0x4180),\r\n                  addmod(/*column20_row21*/ mload(0x3860), /*column20_row53*/ mload(0x3920), PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column20_row13*/ mload(0x37c0),\r\n                    addmod(\r\n                      /*column20_row5*/ mload(0x3700),\r\n                      sub(PRIME, /*column20_row37*/ mload(0x3900)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[9].\r\n              val := mulmod(val, mload(0x4ea0), PRIME)\r\n              // Denominator: point^(trace_length / 32) - 1.\r\n              // val *= denominator_invs[16].\r\n              val := mulmod(val, mload(0x4940), PRIME)\r\n\r\n              // res += val * coefficients[153].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[153]*/ mload(0x1860), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/add_points/x_diff_inv: column20_row3 * (column20_row5 - ecdsa__generator_points__x) - 1.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*column20_row3*/ mload(0x36c0),\r\n                  addmod(\r\n                    /*column20_row5*/ mload(0x3700),\r\n                    sub(PRIME, /*periodic_column/ecdsa/generator_points/x*/ mload(0x40)),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(PRIME, 1),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[9].\r\n              val := mulmod(val, mload(0x4ea0), PRIME)\r\n              // Denominator: point^(trace_length / 32) - 1.\r\n              // val *= denominator_invs[16].\r\n              val := mulmod(val, mload(0x4940), PRIME)\r\n\r\n              // res += val * coefficients[154].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[154]*/ mload(0x1880), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/copy_point/x: ecdsa__signature0__exponentiate_generator__bit_neg_0 * (column20_row37 - column20_row5).\r\n              let val := mulmod(\r\n                /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_neg_0*/ mload(0x41a0),\r\n                addmod(\r\n                  /*column20_row37*/ mload(0x3900),\r\n                  sub(PRIME, /*column20_row5*/ mload(0x3700)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[9].\r\n              val := mulmod(val, mload(0x4ea0), PRIME)\r\n              // Denominator: point^(trace_length / 32) - 1.\r\n              // val *= denominator_invs[16].\r\n              val := mulmod(val, mload(0x4940), PRIME)\r\n\r\n              // res += val * coefficients[155].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[155]*/ mload(0x18a0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_generator/copy_point/y: ecdsa__signature0__exponentiate_generator__bit_neg_0 * (column20_row53 - column20_row21).\r\n              let val := mulmod(\r\n                /*intermediate_value/ecdsa/signature0/exponentiate_generator/bit_neg_0*/ mload(0x41a0),\r\n                addmod(\r\n                  /*column20_row53*/ mload(0x3920),\r\n                  sub(PRIME, /*column20_row21*/ mload(0x3860)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 8192) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[9].\r\n              val := mulmod(val, mload(0x4ea0), PRIME)\r\n              // Denominator: point^(trace_length / 32) - 1.\r\n              // val *= denominator_invs[16].\r\n              val := mulmod(val, mload(0x4940), PRIME)\r\n\r\n              // res += val * coefficients[156].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[156]*/ mload(0x18c0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/booleanity_test: ecdsa__signature0__exponentiate_key__bit_0 * (ecdsa__signature0__exponentiate_key__bit_0 - 1).\r\n              let val := mulmod(\r\n                /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x41c0),\r\n                addmod(\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x41c0),\r\n                  sub(PRIME, 1),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x4e80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[157].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[157]*/ mload(0x18e0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/bit_extraction_end: column20_row1.\r\n              let val := /*column20_row1*/ mload(0x3680)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 4096) - trace_generator^(251 * trace_length / 256).\r\n              // val *= denominator_invs[19].\r\n              val := mulmod(val, mload(0x49a0), PRIME)\r\n\r\n              // res += val * coefficients[158].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[158]*/ mload(0x1900), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/zeros_tail: column20_row1.\r\n              let val := /*column20_row1*/ mload(0x3680)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\r\n              // val *= denominator_invs[20].\r\n              val := mulmod(val, mload(0x49c0), PRIME)\r\n\r\n              // res += val * coefficients[159].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[159]*/ mload(0x1920), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/add_points/slope: ecdsa__signature0__exponentiate_key__bit_0 * (column20_row6 - column20_row12) - column20_row14 * (column20_row10 - column20_row4).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x41c0),\r\n                  addmod(\r\n                    /*column20_row6*/ mload(0x3720),\r\n                    sub(PRIME, /*column20_row12*/ mload(0x37a0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column20_row14*/ mload(0x37e0),\r\n                    addmod(\r\n                      /*column20_row10*/ mload(0x3780),\r\n                      sub(PRIME, /*column20_row4*/ mload(0x36e0)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x4e80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[160].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[160]*/ mload(0x1940), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/add_points/x: column20_row14 * column20_row14 - ecdsa__signature0__exponentiate_key__bit_0 * (column20_row10 + column20_row4 + column20_row26).\r\n              let val := addmod(\r\n                mulmod(/*column20_row14*/ mload(0x37e0), /*column20_row14*/ mload(0x37e0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x41c0),\r\n                    addmod(\r\n                      addmod(/*column20_row10*/ mload(0x3780), /*column20_row4*/ mload(0x36e0), PRIME),\r\n                      /*column20_row26*/ mload(0x38a0),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x4e80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[161].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[161]*/ mload(0x1960), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/add_points/y: ecdsa__signature0__exponentiate_key__bit_0 * (column20_row6 + column20_row22) - column20_row14 * (column20_row10 - column20_row26).\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_0*/ mload(0x41c0),\r\n                  addmod(/*column20_row6*/ mload(0x3720), /*column20_row22*/ mload(0x3880), PRIME),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column20_row14*/ mload(0x37e0),\r\n                    addmod(\r\n                      /*column20_row10*/ mload(0x3780),\r\n                      sub(PRIME, /*column20_row26*/ mload(0x38a0)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x4e80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[162].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[162]*/ mload(0x1980), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/add_points/x_diff_inv: column20_row9 * (column20_row10 - column20_row4) - 1.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*column20_row9*/ mload(0x3760),\r\n                  addmod(\r\n                    /*column20_row10*/ mload(0x3780),\r\n                    sub(PRIME, /*column20_row4*/ mload(0x36e0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(PRIME, 1),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x4e80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[163].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[163]*/ mload(0x19a0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/copy_point/x: ecdsa__signature0__exponentiate_key__bit_neg_0 * (column20_row26 - column20_row10).\r\n              let val := mulmod(\r\n                /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_neg_0*/ mload(0x41e0),\r\n                addmod(\r\n                  /*column20_row26*/ mload(0x38a0),\r\n                  sub(PRIME, /*column20_row10*/ mload(0x3780)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x4e80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[164].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[164]*/ mload(0x19c0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/exponentiate_key/copy_point/y: ecdsa__signature0__exponentiate_key__bit_neg_0 * (column20_row22 - column20_row6).\r\n              let val := mulmod(\r\n                /*intermediate_value/ecdsa/signature0/exponentiate_key/bit_neg_0*/ mload(0x41e0),\r\n                addmod(\r\n                  /*column20_row22*/ mload(0x3880),\r\n                  sub(PRIME, /*column20_row6*/ mload(0x3720)),\r\n                  PRIME),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 4096) - trace_generator^(255 * trace_length / 256).\r\n              // val *= numerators[8].\r\n              val := mulmod(val, mload(0x4e80), PRIME)\r\n              // Denominator: point^(trace_length / 16) - 1.\r\n              // val *= denominator_invs[2].\r\n              val := mulmod(val, mload(0x4780), PRIME)\r\n\r\n              // res += val * coefficients[165].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[165]*/ mload(0x19e0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/init_gen/x: column20_row5 - ecdsa/sig_config.shift_point.x.\r\n              let val := addmod(\r\n                /*column20_row5*/ mload(0x3700),\r\n                sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x3a0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[166].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[166]*/ mload(0x1a00), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/init_gen/y: column20_row21 + ecdsa/sig_config.shift_point.y.\r\n              let val := addmod(\r\n                /*column20_row21*/ mload(0x3860),\r\n                /*ecdsa/sig_config.shift_point.y*/ mload(0x3c0),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[167].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[167]*/ mload(0x1a20), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/init_key/x: column20_row10 - ecdsa/sig_config.shift_point.x.\r\n              let val := addmod(\r\n                /*column20_row10*/ mload(0x3780),\r\n                sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x3a0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 4096) - 1.\r\n              // val *= denominator_invs[22].\r\n              val := mulmod(val, mload(0x4a00), PRIME)\r\n\r\n              // res += val * coefficients[168].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[168]*/ mload(0x1a40), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/init_key/y: column20_row6 - ecdsa/sig_config.shift_point.y.\r\n              let val := addmod(\r\n                /*column20_row6*/ mload(0x3720),\r\n                sub(PRIME, /*ecdsa/sig_config.shift_point.y*/ mload(0x3c0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 4096) - 1.\r\n              // val *= denominator_invs[22].\r\n              val := mulmod(val, mload(0x4a00), PRIME)\r\n\r\n              // res += val * coefficients[169].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[169]*/ mload(0x1a60), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/add_results/slope: column20_row8181 - (column20_row4086 + column20_row8173 * (column20_row8165 - column20_row4090)).\r\n              let val := addmod(\r\n                /*column20_row8181*/ mload(0x3b00),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    /*column20_row4086*/ mload(0x39e0),\r\n                    mulmod(\r\n                      /*column20_row8173*/ mload(0x3ae0),\r\n                      addmod(\r\n                        /*column20_row8165*/ mload(0x3ac0),\r\n                        sub(PRIME, /*column20_row4090*/ mload(0x3a20)),\r\n                        PRIME),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[170].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[170]*/ mload(0x1a80), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/add_results/x: column20_row8173 * column20_row8173 - (column20_row8165 + column20_row4090 + column20_row4100).\r\n              let val := addmod(\r\n                mulmod(/*column20_row8173*/ mload(0x3ae0), /*column20_row8173*/ mload(0x3ae0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(/*column20_row8165*/ mload(0x3ac0), /*column20_row4090*/ mload(0x3a20), PRIME),\r\n                    /*column20_row4100*/ mload(0x3a60),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[171].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[171]*/ mload(0x1aa0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/add_results/y: column20_row8181 + column20_row4108 - column20_row8173 * (column20_row8165 - column20_row4100).\r\n              let val := addmod(\r\n                addmod(/*column20_row8181*/ mload(0x3b00), /*column20_row4108*/ mload(0x3a80), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column20_row8173*/ mload(0x3ae0),\r\n                    addmod(\r\n                      /*column20_row8165*/ mload(0x3ac0),\r\n                      sub(PRIME, /*column20_row4100*/ mload(0x3a60)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[172].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[172]*/ mload(0x1ac0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/add_results/x_diff_inv: column20_row8163 * (column20_row8165 - column20_row4090) - 1.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*column20_row8163*/ mload(0x3aa0),\r\n                  addmod(\r\n                    /*column20_row8165*/ mload(0x3ac0),\r\n                    sub(PRIME, /*column20_row4090*/ mload(0x3a20)),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(PRIME, 1),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[173].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[173]*/ mload(0x1ae0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/extract_r/slope: column20_row8182 + ecdsa/sig_config.shift_point.y - column20_row4094 * (column20_row8186 - ecdsa/sig_config.shift_point.x).\r\n              let val := addmod(\r\n                addmod(\r\n                  /*column20_row8182*/ mload(0x3b20),\r\n                  /*ecdsa/sig_config.shift_point.y*/ mload(0x3c0),\r\n                  PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(\r\n                    /*column20_row4094*/ mload(0x3a40),\r\n                    addmod(\r\n                      /*column20_row8186*/ mload(0x3b60),\r\n                      sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x3a0)),\r\n                      PRIME),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[174].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[174]*/ mload(0x1b00), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/extract_r/x: column20_row4094 * column20_row4094 - (column20_row8186 + ecdsa/sig_config.shift_point.x + column20_row1).\r\n              let val := addmod(\r\n                mulmod(/*column20_row4094*/ mload(0x3a40), /*column20_row4094*/ mload(0x3a40), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      /*column20_row8186*/ mload(0x3b60),\r\n                      /*ecdsa/sig_config.shift_point.x*/ mload(0x3a0),\r\n                      PRIME),\r\n                    /*column20_row1*/ mload(0x3680),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[175].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[175]*/ mload(0x1b20), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/extract_r/x_diff_inv: column20_row8190 * (column20_row8186 - ecdsa/sig_config.shift_point.x) - 1.\r\n              let val := addmod(\r\n                mulmod(\r\n                  /*column20_row8190*/ mload(0x3b80),\r\n                  addmod(\r\n                    /*column20_row8186*/ mload(0x3b60),\r\n                    sub(PRIME, /*ecdsa/sig_config.shift_point.x*/ mload(0x3a0)),\r\n                    PRIME),\r\n                  PRIME),\r\n                sub(PRIME, 1),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[176].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[176]*/ mload(0x1b40), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/z_nonzero: column20_row29 * column20_row4089 - 1.\r\n              let val := addmod(\r\n                mulmod(/*column20_row29*/ mload(0x38e0), /*column20_row4089*/ mload(0x3a00), PRIME),\r\n                sub(PRIME, 1),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[177].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[177]*/ mload(0x1b60), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/r_and_w_nonzero: column20_row1 * column20_row4082 - 1.\r\n              let val := addmod(\r\n                mulmod(/*column20_row1*/ mload(0x3680), /*column20_row4082*/ mload(0x39c0), PRIME),\r\n                sub(PRIME, 1),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 4096) - 1.\r\n              // val *= denominator_invs[22].\r\n              val := mulmod(val, mload(0x4a00), PRIME)\r\n\r\n              // res += val * coefficients[178].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[178]*/ mload(0x1b80), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/q_on_curve/x_squared: column20_row8185 - column20_row4 * column20_row4.\r\n              let val := addmod(\r\n                /*column20_row8185*/ mload(0x3b40),\r\n                sub(\r\n                  PRIME,\r\n                  mulmod(/*column20_row4*/ mload(0x36e0), /*column20_row4*/ mload(0x36e0), PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[179].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[179]*/ mload(0x1ba0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/signature0/q_on_curve/on_curve: column20_row12 * column20_row12 - (column20_row4 * column20_row8185 + ecdsa/sig_config.alpha * column20_row4 + ecdsa/sig_config.beta).\r\n              let val := addmod(\r\n                mulmod(/*column20_row12*/ mload(0x37a0), /*column20_row12*/ mload(0x37a0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(\r\n                      mulmod(/*column20_row4*/ mload(0x36e0), /*column20_row8185*/ mload(0x3b40), PRIME),\r\n                      mulmod(/*ecdsa/sig_config.alpha*/ mload(0x380), /*column20_row4*/ mload(0x36e0), PRIME),\r\n                      PRIME),\r\n                    /*ecdsa/sig_config.beta*/ mload(0x3e0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[180].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[180]*/ mload(0x1bc0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/init_addr: column17_row22 - initial_ecdsa_addr.\r\n              let val := addmod(\r\n                /*column17_row22*/ mload(0x2b80),\r\n                sub(PRIME, /*initial_ecdsa_addr*/ mload(0x400)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x47a0), PRIME)\r\n\r\n              // res += val * coefficients[181].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[181]*/ mload(0x1be0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/message_addr: column17_row4118 - (column17_row22 + 1).\r\n              let val := addmod(\r\n                /*column17_row4118*/ mload(0x2f00),\r\n                sub(PRIME, addmod(/*column17_row22*/ mload(0x2b80), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[182].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[182]*/ mload(0x1c00), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/pubkey_addr: column17_row8214 - (column17_row4118 + 1).\r\n              let val := addmod(\r\n                /*column17_row8214*/ mload(0x2f40),\r\n                sub(PRIME, addmod(/*column17_row4118*/ mload(0x2f00), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(8192 * (trace_length / 8192 - 1)).\r\n              // val *= numerators[10].\r\n              val := mulmod(val, mload(0x4ec0), PRIME)\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[183].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[183]*/ mload(0x1c20), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/message_value0: column17_row4119 - column20_row29.\r\n              let val := addmod(\r\n                /*column17_row4119*/ mload(0x2f20),\r\n                sub(PRIME, /*column20_row29*/ mload(0x38e0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[184].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[184]*/ mload(0x1c40), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for ecdsa/pubkey_value0: column17_row23 - column20_row4.\r\n              let val := addmod(\r\n                /*column17_row23*/ mload(0x2ba0),\r\n                sub(PRIME, /*column20_row4*/ mload(0x36e0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 8192) - 1.\r\n              // val *= denominator_invs[21].\r\n              val := mulmod(val, mload(0x49e0), PRIME)\r\n\r\n              // res += val * coefficients[185].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[185]*/ mload(0x1c60), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for bitwise/init_var_pool_addr: column17_row150 - initial_bitwise_addr.\r\n              let val := addmod(\r\n                /*column17_row150*/ mload(0x2cc0),\r\n                sub(PRIME, /*initial_bitwise_addr*/ mload(0x420)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point - 1.\r\n              // val *= denominator_invs[3].\r\n              val := mulmod(val, mload(0x47a0), PRIME)\r\n\r\n              // res += val * coefficients[186].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[186]*/ mload(0x1c80), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for bitwise/step_var_pool_addr: column17_row406 - (column17_row150 + 1).\r\n              let val := addmod(\r\n                /*column17_row406*/ mload(0x2de0),\r\n                sub(PRIME, addmod(/*column17_row150*/ mload(0x2cc0), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point^(trace_length / 1024) - trace_generator^(3 * trace_length / 4).\r\n              // val *= numerators[11].\r\n              val := mulmod(val, mload(0x4ee0), PRIME)\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[187].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[187]*/ mload(0x1ca0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for bitwise/x_or_y_addr: column17_row534 - (column17_row918 + 1).\r\n              let val := addmod(\r\n                /*column17_row534*/ mload(0x2e40),\r\n                sub(PRIME, addmod(/*column17_row918*/ mload(0x2ea0), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 1024) - 1.\r\n              // val *= denominator_invs[23].\r\n              val := mulmod(val, mload(0x4a20), PRIME)\r\n\r\n              // res += val * coefficients[188].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[188]*/ mload(0x1cc0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for bitwise/next_var_pool_addr: column17_row1174 - (column17_row534 + 1).\r\n              let val := addmod(\r\n                /*column17_row1174*/ mload(0x2ee0),\r\n                sub(PRIME, addmod(/*column17_row534*/ mload(0x2e40), 1, PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: point - trace_generator^(1024 * (trace_length / 1024 - 1)).\r\n              // val *= numerators[12].\r\n              val := mulmod(val, mload(0x4f00), PRIME)\r\n              // Denominator: point^(trace_length / 1024) - 1.\r\n              // val *= denominator_invs[23].\r\n              val := mulmod(val, mload(0x4a20), PRIME)\r\n\r\n              // res += val * coefficients[189].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[189]*/ mload(0x1ce0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for bitwise/partition: bitwise__sum_var_0_0 + bitwise__sum_var_8_0 - column17_row151.\r\n              let val := addmod(\r\n                addmod(\r\n                  /*intermediate_value/bitwise/sum_var_0_0*/ mload(0x4200),\r\n                  /*intermediate_value/bitwise/sum_var_8_0*/ mload(0x4220),\r\n                  PRIME),\r\n                sub(PRIME, /*column17_row151*/ mload(0x2ce0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 256) - 1.\r\n              // val *= denominator_invs[11].\r\n              val := mulmod(val, mload(0x48a0), PRIME)\r\n\r\n              // res += val * coefficients[190].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[190]*/ mload(0x1d00), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for bitwise/or_is_and_plus_xor: column17_row535 - (column17_row663 + column17_row919).\r\n              let val := addmod(\r\n                /*column17_row535*/ mload(0x2e60),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(/*column17_row663*/ mload(0x2e80), /*column17_row919*/ mload(0x2ec0), PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 1024) - 1.\r\n              // val *= denominator_invs[23].\r\n              val := mulmod(val, mload(0x4a20), PRIME)\r\n\r\n              // res += val * coefficients[191].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[191]*/ mload(0x1d20), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for bitwise/addition_is_xor_with_and: column19_row1 + column19_row257 - (column19_row769 + column19_row513 + column19_row513).\r\n              let val := addmod(\r\n                addmod(/*column19_row1*/ mload(0x3000), /*column19_row257*/ mload(0x34a0), PRIME),\r\n                sub(\r\n                  PRIME,\r\n                  addmod(\r\n                    addmod(/*column19_row769*/ mload(0x35a0), /*column19_row513*/ mload(0x34e0), PRIME),\r\n                    /*column19_row513*/ mload(0x34e0),\r\n                    PRIME)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: (point^(trace_length / 1024) - 1) * (point^(trace_length / 1024) - trace_generator^(trace_length / 64)) * (point^(trace_length / 1024) - trace_generator^(trace_length / 32)) * (point^(trace_length / 1024) - trace_generator^(3 * trace_length / 64)) * (point^(trace_length / 1024) - trace_generator^(trace_length / 16)) * (point^(trace_length / 1024) - trace_generator^(5 * trace_length / 64)) * (point^(trace_length / 1024) - trace_generator^(3 * trace_length / 32)) * (point^(trace_length / 1024) - trace_generator^(7 * trace_length / 64)) * (point^(trace_length / 1024) - trace_generator^(trace_length / 8)) * (point^(trace_length / 1024) - trace_generator^(9 * trace_length / 64)) * (point^(trace_length / 1024) - trace_generator^(5 * trace_length / 32)) * (point^(trace_length / 1024) - trace_generator^(11 * trace_length / 64)) * (point^(trace_length / 1024) - trace_generator^(3 * trace_length / 16)) * (point^(trace_length / 1024) - trace_generator^(13 * trace_length / 64)) * (point^(trace_length / 1024) - trace_generator^(7 * trace_length / 32)) * (point^(trace_length / 1024) - trace_generator^(15 * trace_length / 64)).\r\n              // val *= denominator_invs[24].\r\n              val := mulmod(val, mload(0x4a40), PRIME)\r\n\r\n              // res += val * coefficients[192].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[192]*/ mload(0x1d40), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for bitwise/unique_unpacking192: (column19_row705 + column19_row961) * 16 - column19_row9.\r\n              let val := addmod(\r\n                mulmod(\r\n                  addmod(/*column19_row705*/ mload(0x3520), /*column19_row961*/ mload(0x35e0), PRIME),\r\n                  16,\r\n                  PRIME),\r\n                sub(PRIME, /*column19_row9*/ mload(0x3100)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 1024) - 1.\r\n              // val *= denominator_invs[23].\r\n              val := mulmod(val, mload(0x4a20), PRIME)\r\n\r\n              // res += val * coefficients[193].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[193]*/ mload(0x1d60), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for bitwise/unique_unpacking193: (column19_row721 + column19_row977) * 16 - column19_row521.\r\n              let val := addmod(\r\n                mulmod(\r\n                  addmod(/*column19_row721*/ mload(0x3540), /*column19_row977*/ mload(0x3600), PRIME),\r\n                  16,\r\n                  PRIME),\r\n                sub(PRIME, /*column19_row521*/ mload(0x3500)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 1024) - 1.\r\n              // val *= denominator_invs[23].\r\n              val := mulmod(val, mload(0x4a20), PRIME)\r\n\r\n              // res += val * coefficients[194].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[194]*/ mload(0x1d80), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for bitwise/unique_unpacking194: (column19_row737 + column19_row993) * 16 - column19_row265.\r\n              let val := addmod(\r\n                mulmod(\r\n                  addmod(/*column19_row737*/ mload(0x3560), /*column19_row993*/ mload(0x3620), PRIME),\r\n                  16,\r\n                  PRIME),\r\n                sub(PRIME, /*column19_row265*/ mload(0x34c0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 1024) - 1.\r\n              // val *= denominator_invs[23].\r\n              val := mulmod(val, mload(0x4a20), PRIME)\r\n\r\n              // res += val * coefficients[195].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[195]*/ mload(0x1da0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n              {\r\n              // Constraint expression for bitwise/unique_unpacking195: (column19_row753 + column19_row1009) * 256 - column19_row777.\r\n              let val := addmod(\r\n                mulmod(\r\n                  addmod(/*column19_row753*/ mload(0x3580), /*column19_row1009*/ mload(0x3640), PRIME),\r\n                  256,\r\n                  PRIME),\r\n                sub(PRIME, /*column19_row777*/ mload(0x35c0)),\r\n                PRIME)\r\n\r\n              // Numerator: 1.\r\n              // val *= 1.\r\n              // val := mulmod(val, 1, PRIME).\r\n              // Denominator: point^(trace_length / 1024) - 1.\r\n              // val *= denominator_invs[23].\r\n              val := mulmod(val, mload(0x4a20), PRIME)\r\n\r\n              // res += val * coefficients[196].\r\n              res := addmod(res,\r\n                            mulmod(val, /*coefficients[196]*/ mload(0x1dc0), PRIME),\r\n                            PRIME)\r\n              }\r\n\r\n            mstore(0, res)\r\n            return(0, 0x20)\r\n            }\r\n        }\r\n    }\r\n}\r\n// ---------- End of auto-generated code. ----------","ABI":"[{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"}]","ContractName":"CpuConstraintPoly","CompilerVersion":"v0.6.12+commit.27d51765","OptimizationUsed":"1","Runs":"1000000","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://f39b9e12f792decfb8de709d0af056e4d3fba9f0e9956aea7a147c498a8279ee"}]}