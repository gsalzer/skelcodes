{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/core/MiningCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\ncontract Context {\\n\\n\\n    constructor () { }\\n\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this;\\n        return msg.data;\\n    }\\n}\\n\\ncontract Ownable is Context {\\n\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\\ninterface MiningMachine is IERC721 {\\n    function machines(uint256 tokenId) external view returns(uint model, uint load,uint exploit);\\n    function burn(uint256 tokenId) external;\\n    function mint(address to,uint _power) external;\\n}\\n\\n\\ninterface MiningPool{\\n\\n    function users(address userAddress) external view returns(uint256 id,uint256 investment,uint256 freezeTime);\\n\\n    function balanceOf(address userAddress) external view returns (address[2] memory,uint256[2] memory balances);\\n\\n    function duration() external view returns (uint256);\\n\\n    function deposit(uint256[2] calldata amounts) external returns(bool);\\n\\n    function allot(address userAddress,uint256[2] calldata amounts) external returns(bool);\\n\\n    function lock(address holder, address locker, uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    function lockStatus(address userAddress) external view returns(bool);\\n\\n    function asset(address userAddress) external view returns(uint256);\\n}\\n\\ninterface IUniswapPair {\\n\\n    function setFeeOwner(address _feeOwner) external;\\n}\\n\\ninterface IUniswapFactory {\\n\\n    function getPair(address token0,address token1) external returns(address);\\n}\\n\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\nabstract contract ERC721TokenReceiver is IERC721Receiver{\\n\\n     function onERC721Received(address operator, address from, uint256 tokenId,  bytes calldata data) external override returns(bytes4) {\\n        mining(msg.sender,operator,from,tokenId,data);\\n        return IERC721Receiver.onERC721Received.selector;\\n    }\\n\\n    function mining(address msgSender, address operator, address from, uint256 tokenId, bytes calldata data) internal virtual;\\n}\\n\\ncontract WhiteList is Ownable {\\n\\n    function getWhiteListStatus(address _maker) external view returns (bool) {\\n        return isWhiteListed[_maker];\\n    }\\n\\n    mapping (address => bool) public isWhiteListed;\\n\\n    function addWhiteList (address _user) public onlyOwner {\\n        isWhiteListed[_user] = true;\\n        emit AddedWhiteList(_user);\\n    }\\n\\n    function removeWhiteList (address _clearedUser) public onlyOwner {\\n        isWhiteListed[_clearedUser] = false;\\n        emit RemovedWhiteList(_clearedUser);\\n    }\\n\\n    event AddedWhiteList(address indexed _user);\\n\\n    event RemovedWhiteList(address indexed _user);\\n\\n}\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function nonces(address account) external view returns (uint256);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function permit(address holder, address spender, uint256 nonce, uint256 expiry, uint256 amount, uint8 v, bytes32 r, bytes32 s) external;\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\\ncontract Config{\\n\\n    uint256 public constant ONE_DAY = 1 days;\\n\\n    uint256[10] public  RANKING_AWARD_PERCENT = [10,5,3,1,1,1,1,1,1,1];\\n\\n    uint256 public constant LAST_STRAW_PERCNET = 5;\\n\\n    uint256[2] public  OUT_RATE = [1,1];\\n\\n}\\n\\n\\ncontract MiningCore is Config, WhiteList, ERC721TokenReceiver {\\n\\n    using SafeMath for uint256;\\n\\n    constructor(MiningPool _pool,MiningMachine _machine,address payable _developer) {\\n        pool = _pool;\\n        machine = _machine;\\n        developer = _developer;\\n    }\\n\\n    MiningPool public pool;\\n\\n    uint256 public ORE_AMOUNT = 1500000000;\\n\\n    struct Record{\\n        //提现状态\\n        bool drawStatus;\\n        //挖矿总量\\n        uint256 digGross;\\n        //最后一击\\n        bool lastStraw;\\n\\n    }\\n\\n    struct Pair {\\n        uint256[2] amounts;\\n        //挖矿总量\\n        uint256 complete;\\n        //实际挖矿量\\n        uint256 actual;\\n\\n        uint256 oracleAmount;\\n\\n        address lastStraw;\\n    }\\n\\n\\n    address payable developer;\\n\\n    uint256 public version;\\n\\n    MiningMachine public machine;\\n\\n    mapping(uint256=>mapping(address=>Record)) public records;\\n\\n    //Record of each mining period\\n    mapping(uint256=>Pair) public history;\\n\\n    //Daily output\\n    mapping(uint256=>uint256) public dailyOutput;\\n\\n    mapping(uint256=> address[10]) public rank;\\n\\n    event ObtainCar(address indexed userAddress,uint256 indexed _version,uint256 amount );\\n\\n    event Mining(address indexed userAddress,uint256 indexed _version,uint256 , uint256 amount);\\n\\n    event WithdrawAward(address indexed userAddress,uint256 indexed _version,uint256[2] amounts);\\n\\n    event UpdateRank(address indexed operator);\\n\\n    event DeveloperFee(uint256 fee1,uint256 fee2);\\n\\n    event SetCarIndex(uint256 sn,uint256 id,uint256 fertility,uint256 carry);\\n\\n    event LastStraw(address indexed userAddress,uint256 _version,uint256,uint256,uint256);\\n\\n\\n    //----------------------test--------------------------------------------\\n//    function takeOf(IERC20 token) public onlyOwner {\\n//        uint balance = token.balanceOf(address(this));\\n//        token.transfer(developer, balance);\\n//    }\\n\\n    function setFeeOwner(address _feeOwner,address factory) external  onlyOwner {\\n        (address[2] memory tokens,) = pool.balanceOf(address(0));\\n        address pair = IUniswapFactory(factory).getPair(tokens[0],tokens[1]);\\n        IUniswapPair(pair).setFeeOwner(_feeOwner);\\n    }\\n\\n\\n    function setOracle(uint256 _ORE_AMOUNT) public onlyOwner {\\n        ORE_AMOUNT = _ORE_AMOUNT;\\n    }\\n\\n\\n    function mining(address msgSender, address operator, address from, uint256 tokenId, bytes calldata) internal override virtual{\\n        require(address(machine)==msgSender,\\\"not allowed\\\");\\n        if(Address.isContract(operator)){\\n            require(isWhiteListed[operator],\\\"not in whiteList\\\");\\n        }\\n        if(from!=address(0)){\\n            burn(from,tokenId);\\n        }\\n    }\\n\\n\\n    function obtainCar(uint256 nonce, uint256 expiry, bool allowed, uint8 v, bytes32 r, bytes32 s) public {\\n        require(!pool.lockStatus(msg.sender),\\\"Have been received\\\");\\n        pool.lock(msg.sender,address(this),nonce,expiry,allowed,v,r,s);\\n        uint256 asset = pool.asset(msg.sender);\\n        machine.mint(msg.sender,asset);\\n    }\\n\\n    function withdrawAward(uint256 _version) public {\\n\\n       require(!records[_version][msg.sender].drawStatus,\\\"have withdrawal\\\");\\n\\t   require(_version<version,\\\"Event not over\\\");\\n\\n       (uint256[2] memory amounts) =  getVersionAward(_version,msg.sender);\\n\\n       records[_version][msg.sender].drawStatus = true;\\n\\n       pool.allot(msg.sender,amounts);\\n\\n       emit WithdrawAward(msg.sender,_version,amounts);\\n\\n    }\\n\\n\\n    function getVersionAward(uint256 _version,address userAddress) public view returns(uint256[2] memory amounts){\\n        Pair memory pair = history[_version];\\n        return getPredictAward(_version,userAddress,pair);\\n    }\\n\\n    function getPredictAward(uint256 _version,address userAddress,Pair memory pair) internal view returns(uint256[2] memory amounts){\\n        Record storage record = records[_version][userAddress];\\n\\n        uint256 ranking = getRanking(userAddress,_version);\\n\\n        for(uint8 i = 0;i<2;i++){\\n            uint256 baseAmount = pair.amounts[i].mul(70).div(100);\\n            uint256 awardAmount = pair.amounts[i].mul(30).div(100);\\n\\n            amounts[i] = amounts[i].add(baseAmount.mul(record.digGross).div(pair.oracleAmount==0?ORE_AMOUNT:pair.oracleAmount));\\n\\n            if(ranking<10){\\n                amounts[i] = amounts[i].add(awardAmount.mul(RANKING_AWARD_PERCENT[ranking]).div(30));\\n            }\\n\\n            if(record.lastStraw){\\n                amounts[i] = amounts[i].add(awardAmount.mul(LAST_STRAW_PERCNET).div(30));\\n            }\\n        }\\n    }\\n\\n    function getGlobalStats(uint256 _version) external view returns (uint256[5] memory stats,address lastStrawUser) {\\n\\n        Pair memory pair = history[_version];\\n        if(_version==version){\\n            (,uint256[2] memory balances) = pool.balanceOf(address(this));\\n            pair.amounts = balances;\\n        }\\n\\n        stats[0] = pair.amounts[0];\\n        stats[1] = pair.amounts[1];\\n        stats[2] = pair.complete;\\n        stats[3] = pair.actual;\\n        stats[4] = (pool.duration()+1)*ONE_DAY;\\n        lastStrawUser = pair.lastStraw;\\n\\n    }\\n\\n\\n    function crown(uint256 _version) external view returns (address[10] memory ranking,uint256[10] memory digGross){\\n        ranking = sortRank(_version);\\n        for(uint8 i =0;i<ranking.length;i++){\\n            digGross[i] = getDigGross(ranking[i],_version);\\n        }\\n    }\\n\\n\\n    function getPersonalStats(uint256 _version,address userAddress) external view returns (uint256[7] memory stats,bool[3] memory stats2){\\n        Record storage record = records[_version][userAddress];\\n\\n        (uint256 id,uint256 investment,uint256 freezeTime) = pool.users(userAddress);\\n        stats[0] = investment;\\n        stats[1] = record.digGross;\\n\\n        Pair memory pair = history[_version];\\n\\n        if(_version==version){\\n            (,uint256[2] memory balances) = pool.balanceOf(address(this));\\n            pair.amounts = balances;\\n        }\\n\\n        uint256[2] memory amounts = getPredictAward(_version,userAddress,pair);\\n\\n        stats[2] = amounts[1];\\n        stats[3] = amounts[0];\\n        stats[4] = id;\\n        stats[5] = freezeTime;\\n        stats[6] = getRanking(userAddress,_version)+1;\\n\\n        stats2[0] = record.drawStatus;\\n        stats2[1] = record.lastStraw;\\n        stats2[2] = pool.lockStatus(userAddress);\\n\\n\\n     }\\n\\n    function burn(address _from,uint256 tokenId) internal returns(uint256){\\n        Pair storage pair = history[version];\\n\\n        Record storage record = records[version][_from];\\n\\n        (, uint load,uint exploit) = machine.machines(tokenId);\\n        uint256 output;\\n        if(exploit>load){\\n            output = load;\\n        }else{\\n            output = exploit;\\n        }\\n\\n        uint256 miningQuantity = pair.complete.add(exploit);\\n\\n        if(pair.complete.add(output)>ORE_AMOUNT){\\n            output = ORE_AMOUNT>pair.complete?ORE_AMOUNT-pair.complete:0;\\n        }\\n\\n        record.digGross = record.digGross.add(output);\\n        pair.complete = pair.complete.add(exploit);\\n        pair.actual = pair.actual.add(output);\\n        updateRank(_from);\\n\\n        if(miningQuantity>=ORE_AMOUNT){\\n            emit LastStraw(_from,version,exploit,load,output);\\n            lastStraw(_from,pair);\\n        }\\n        machine.burn(tokenId);\\n\\n        emit Mining(_from,version,tokenId,output);\\n        return output;\\n    }\\n\\n    function getRanking(address userAddress,uint256 _version) public view returns(uint256){\\n        address[10] memory rankingList = sortRank(_version);\\n        uint256 ranking = 10;\\n        for(uint8 i =0;i<rankingList.length;i++){\\n            if(userAddress == rankingList[i]){\\n                ranking = i;\\n                break;\\n            }\\n        }\\n        return ranking;\\n    }\\n\\n    function pickUp(address[10] memory rankingList,address userAddress) internal view returns (uint256 sn,uint256 minDig){\\n\\n        minDig = getDigGross(rankingList[0]);\\n        for(uint8 i =0;i<rankingList.length;i++){\\n            if(rankingList[i]==userAddress){\\n                return (rankingList.length,0);\\n            }\\n            if(getDigGross(rankingList[i])<minDig){\\n                minDig = getDigGross(rankingList[i]);\\n                sn = i;\\n            }\\n        }\\n\\n        return (sn,minDig);\\n    }\\n\\n    function updateRank(address userAddress) internal {\\n        address[10] memory rankingList = rank[version];\\n\\n        (uint256 sn,uint256 minDig) = pickUp(rankingList,userAddress);\\n        if(sn!=rankingList.length){\\n            if(minDig< getDigGross(userAddress)){\\n                rankingList[sn] = userAddress;\\n            }\\n            rank[version] = rankingList;\\n            emit UpdateRank(userAddress);\\n        }\\n    }\\n\\n    function sortRank(uint256 _version) public view returns(address[10] memory ranking){\\n        ranking = rank[_version];\\n\\n        address tmp;\\n        for(uint8 i = 1;i<10;i++){\\n            for(uint8 j = 0;j<10-i;j++){\\n                if(getDigGross(ranking[j],_version)<getDigGross(ranking[j+1],_version)){\\n                    tmp = ranking[j];\\n                    ranking[j] = ranking[j+1];\\n                    ranking[j+1] = tmp;\\n                }\\n            }\\n        }\\n        return ranking;\\n    }\\n\\n    function getDigGross(address userAddress) internal view returns(uint256){\\n        return getDigGross(userAddress,version);\\n    }\\n\\n    function getDigGross(address userAddress,uint256 _version) internal view returns(uint256){\\n        return records[_version][userAddress].digGross;\\n    }\\n\\n    function lastStraw(address userAddress,Pair storage pair) internal{\\n\\n        (address[2] memory tokens,uint256[2] memory amounts) = pool.balanceOf(address(this));\\n\\n        for(uint8 i;i<amounts.length;i++){\\n            TransferHelper.safeApprove(tokens[i],address(pool),amounts[i]);\\n        }\\n        pool.deposit(amounts);\\n        pair.amounts = amounts;\\n\\n        pair.lastStraw = userAddress;\\n        pair.oracleAmount = ORE_AMOUNT;\\n        records[version][userAddress].lastStraw = true;\\n\\n        developerFee(pair);\\n\\n        version++;\\n\\n    }\\n\\n     //项目方收款\\n    function developerFee(Pair storage pair) internal{\\n\\n        uint256[2] memory amounts;\\n        address[10] memory rankingList = rank[version];\\n        uint count;\\n        for(uint i = 0;i<rankingList.length;i++) {\\n            if(rankingList[i]==address(0)) {\\n                count++;\\n            }\\n        }\\n\\n        uint unused;\\n        for(uint j = 0;j<count;j++){\\n            if(j<10) unused+=RANKING_AWARD_PERCENT[9-j];\\n        }\\n\\n        for(uint256 i = 0;i<amounts.length;i++){\\n            uint waste = pair.amounts[i].mul(70).mul(pair.oracleAmount.sub(pair.actual)).div(ORE_AMOUNT).div(100);\\n            uint rest = pair.amounts[i].mul(unused).div(100);\\n            amounts[i] = waste+rest;\\n        }\\n\\n        pool.allot(developer,amounts);\\n\\n        emit DeveloperFee(amounts[0],amounts[1]);\\n    }\\n\\n\\n}\\n\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\\n\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * This test is non-exhaustive, and there may be false-negatives: during the\\n     * execution of a contract's constructor, its address will be reported as\\n     * not containing a contract.\\n     *\\n     * IMPORTANT: It is unsafe to assume that an address for which this\\n     * function returns false is an externally-owned account (EOA) and not a\\n     * contract.\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != 0x0 && codehash != accountHash);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call{value:amount}(new bytes(0));\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n\\n\\n\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n\\n\\n        return c;\\n    }\\n\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract MiningPool\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"contract MiningMachine\",\"name\":\"_machine\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_developer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"AddedWhiteList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee2\",\"type\":\"uint256\"}],\"name\":\"DeveloperFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LastStraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mining\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ObtainCar\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"RemovedWhiteList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fertility\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"carry\",\"type\":\"uint256\"}],\"name\":\"SetCarIndex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"UpdateRank\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"}],\"name\":\"WithdrawAward\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LAST_STRAW_PERCNET\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ORE_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"OUT_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RANKING_AWARD_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"addWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"crown\",\"outputs\":[{\"internalType\":\"address[10]\",\"name\":\"ranking\",\"type\":\"address[10]\"},{\"internalType\":\"uint256[10]\",\"name\":\"digGross\",\"type\":\"uint256[10]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dailyOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"getGlobalStats\",\"outputs\":[{\"internalType\":\"uint256[5]\",\"name\":\"stats\",\"type\":\"uint256[5]\"},{\"internalType\":\"address\",\"name\":\"lastStrawUser\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getPersonalStats\",\"outputs\":[{\"internalType\":\"uint256[7]\",\"name\":\"stats\",\"type\":\"uint256[7]\"},{\"internalType\":\"bool[3]\",\"name\":\"stats2\",\"type\":\"bool[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"getRanking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getVersionAward\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"amounts\",\"type\":\"uint256[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_maker\",\"type\":\"address\"}],\"name\":\"getWhiteListStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"history\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"complete\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oracleAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lastStraw\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhiteListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"machine\",\"outputs\":[{\"internalType\":\"contract MiningMachine\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"obtainCar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract MiningPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rank\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"drawStatus\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"digGross\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"lastStraw\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clearedUser\",\"type\":\"address\"}],\"name\":\"removeWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"setFeeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ORE_AMOUNT\",\"type\":\"uint256\"}],\"name\":\"setOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"sortRank\",\"outputs\":[{\"internalType\":\"address[10]\",\"name\":\"ranking\",\"type\":\"address[10]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"withdrawAward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MiningCore","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000072f6ba3efd457af0c9757354bd83f357260dc5cd00000000000000000000000075120a1b50cfa3ff34f8419749f6d0a0190d77990000000000000000000000001bd9a3280896b99c7696ff32aeb84d94dc370808","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":""}]}