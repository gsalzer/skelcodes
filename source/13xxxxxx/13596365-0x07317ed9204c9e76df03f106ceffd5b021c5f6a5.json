{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/demo/AdminTimeLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/SecuredAddressLock.sol\\\";\\nimport \\\"../interfaces/IAddressRegistry.sol\\\";\\nimport \\\"../interfaces/IRevest.sol\\\";\\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\\n\\n/**\\n * @title\\n * @dev\\n */\\ncontract AdminTimeLock is SecuredAddressLock, ERC165  {\\n\\n    string public metadataURI = \\\"https://revest.mypinata.cloud/ipfs/QmR9uFVk9fqKwzQHe6dvD4MNDMisJxv16PikxxJNuR6US5\\\";\\n\\n    mapping (uint => AdminLock) public locks;\\n\\n    struct AdminLock {\\n        uint endTime;\\n        address admin;\\n        bool unlocked;\\n    }\\n\\n    constructor(address reg_) SecuredAddressLock(reg_) {}\\n\\n    function supportsInterface(bytes4 interfaceId) public view override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IAddressLock).interfaceId\\n            || interfaceId == type(IRegistryProvider).interfaceId\\n            || super.supportsInterface(interfaceId);\\n    }\\n\\n    function isUnlockable(uint, uint lockId) public view override returns (bool) {\\n        return locks[lockId].unlocked || block.timestamp > locks[lockId].endTime;\\n    }\\n\\n\\n    // Create the lock within that contract DURING minting\\n    function createLock(uint, uint lockId, bytes memory arguments) external override onlyRevestController {\\n        uint endTime;\\n        address admin;\\n        (endTime, admin) = abi.decode(arguments, (uint, address));\\n\\n        // Check that we aren't creating a lock in the past\\n        require(block.timestamp < endTime, 'E002');\\n\\n        AdminLock memory adminLock = AdminLock(endTime, admin, false);\\n        locks[lockId] = adminLock;\\n    }\\n\\n    function updateLock(uint, uint lockId, bytes memory) external override {\\n        // For an admin lock, there are no arguments\\n        if(_msgSender() == locks[lockId].admin) {\\n           locks[lockId].unlocked = true;\\n        }\\n    }\\n\\n    function needsUpdate() external pure override returns (bool) {\\n        return true;\\n    }\\n\\n    // TODO: Now that we have changed this from being broken for splittable locks, how do we communicate the two-steps\\n    // That are now needed to unlock this lock?\\n    function getDisplayValues(uint, uint lockId) external view override returns (bytes memory) {\\n        uint endTime = locks[lockId].endTime;\\n        address admin = locks[lockId].admin;\\n        bool canUnlock = admin == _msgSender();\\n        return abi.encode(endTime, admin, canUnlock);\\n    }\\n\\n    function setMetadata(string memory _metadataURI) external onlyOwner {\\n        metadataURI = _metadataURI;\\n    }\\n\\n    function getMetadata() external view override returns (string memory) {\\n        return metadataURI;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SecuredAddressLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IAddressLock.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nabstract contract SecuredAddressLock is IAddressLock, Ownable {\\n\\n    IAddressRegistry public addressesProvider;\\n\\n    constructor(address provider) Ownable() {\\n        addressesProvider = IAddressRegistry(provider);\\n    }\\n\\n    function setAddressRegistry(address registry) external override onlyOwner {\\n        addressesProvider = IAddressRegistry(registry);\\n    }\\n\\n    function getAddressRegistry() external view override returns (address) {\\n        return address(addressesProvider);\\n    }\\n\\n\\n    modifier onlyLockManager() {\\n        require(_msgSender() != address(0), \\\"E004\\\");\\n        require(_msgSender() == addressesProvider.getLockManager(), 'E074');\\n        _;\\n    }\\n\\n    modifier onlyRevestController() {\\n        require(_msgSender() != address(0), \\\"E004\\\");\\n        require(_msgSender() == addressesProvider.getRevest(), \\\"E017\\\");\\n        _;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAddressRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title Provider interface for Revest FNFTs\\n * @dev\\n *\\n */\\ninterface IAddressRegistry {\\n\\n    function initialize(\\n        address lock_manager_,\\n        address liquidity_,\\n        address revest_token_,\\n        address token_vault_,\\n        address revest_,\\n        address fnft_,\\n        address metadata_,\\n        address admin_,\\n        address rewards_\\n    ) external;\\n\\n    function getAdmin() external view returns (address);\\n\\n    function setAdmin(address admin) external;\\n\\n    function getLockManager() external view returns (address);\\n\\n    function setLockManager(address manager) external;\\n\\n    function getTokenVault() external view returns (address);\\n\\n    function setTokenVault(address vault) external;\\n\\n    function getRevestFNFT() external view returns (address);\\n\\n    function setRevestFNFT(address fnft) external;\\n\\n    function getMetadataHandler() external view returns (address);\\n\\n    function setMetadataHandler(address metadata) external;\\n\\n    function getRevest() external view returns (address);\\n\\n    function setRevest(address revest) external;\\n\\n    function getDEX(uint index) external view returns (address);\\n\\n    function setDex(address dex) external;\\n\\n    function getRevestToken() external view returns (address);\\n\\n    function setRevestToken(address token) external;\\n\\n    function getRewardsHandler() external view returns(address);\\n\\n    function setRewardsHandler(address esc) external;\\n\\n    function getAddress(bytes32 id) external view returns (address);\\n\\n    function getLPs() external view returns (address);\\n\\n    function setLPs(address liquidToken) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRevest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity >=0.8.0;\\n\\ninterface IRevest {\\n    event FNFTTimeLockMinted(\\n        address indexed asset,\\n        address indexed from,\\n        uint indexed fnftId,\\n        uint endTime,\\n        uint[] quantities,\\n        FNFTConfig fnftConfig\\n    );\\n\\n    event FNFTValueLockMinted(\\n        address indexed primaryAsset,\\n        address indexed from,\\n        uint indexed fnftId,\\n        address compareTo,\\n        address oracleDispatch,\\n        uint[] quantities,\\n        FNFTConfig fnftConfig\\n    );\\n\\n    event FNFTAddressLockMinted(\\n        address indexed asset,\\n        address indexed from,\\n        uint indexed fnftId,\\n        address trigger,\\n        uint[] quantities,\\n        FNFTConfig fnftConfig\\n    );\\n\\n    event FNFTWithdrawn(\\n        address indexed from,\\n        uint indexed fnftId,\\n        uint indexed quantity\\n    );\\n\\n    event FNFTSplit(\\n        address indexed from,\\n        uint[] indexed newFNFTId,\\n        uint[] indexed proportions,\\n        uint quantity\\n    );\\n\\n    event FNFTUnlocked(\\n        address indexed from,\\n        uint indexed fnftId\\n    );\\n\\n    event FNFTMaturityExtended(\\n        address indexed from,\\n        uint indexed fnftId,\\n        uint indexed newExtendedTime\\n    );\\n\\n    event FNFTAddionalDeposited(\\n        address indexed from,\\n        uint indexed newFNFTId,\\n        uint indexed quantity,\\n        uint amount\\n    );\\n\\n    struct FNFTConfig {\\n        address asset; // The token being stored\\n        address pipeToContract; // Indicates if FNFT will pipe to another contract\\n        uint depositAmount; // How many tokens\\n        uint depositMul; // Deposit multiplier\\n        uint split; // Number of splits remaining\\n        uint depositStopTime; //\\n        bool maturityExtension; // Maturity extensions remaining\\n        bool isMulti; //\\n        bool nontransferrable; // False by default (transferrable) //\\n    }\\n\\n    // Refers to the global balance for an ERC20, encompassing possibly many FNFTs\\n    struct TokenTracker {\\n        uint lastBalance;\\n        uint lastMul;\\n    }\\n\\n    enum LockType {\\n        DoesNotExist,\\n        TimeLock,\\n        ValueLock,\\n        AddressLock\\n    }\\n\\n    struct LockParam {\\n        address addressLock;\\n        uint timeLockExpiry;\\n        LockType lockType;\\n        ValueLock valueLock;\\n    }\\n\\n    struct Lock {\\n        address addressLock;\\n        LockType lockType;\\n        ValueLock valueLock;\\n        uint timeLockExpiry;\\n        uint creationTime;\\n        bool unlocked;\\n    }\\n\\n    struct ValueLock {\\n        address asset;\\n        address compareTo;\\n        address oracle;\\n        uint unlockValue;\\n        bool unlockRisingEdge;\\n    }\\n\\n    function mintTimeLock(\\n        uint endTime,\\n        address[] memory recipients,\\n        uint[] memory quantities,\\n        IRevest.FNFTConfig memory fnftConfig\\n    ) external payable returns (uint);\\n\\n    function mintValueLock(\\n        address primaryAsset,\\n        address compareTo,\\n        uint unlockValue,\\n        bool unlockRisingEdge,\\n        address oracleDispatch,\\n        address[] memory recipients,\\n        uint[] memory quantities,\\n        IRevest.FNFTConfig memory fnftConfig\\n    ) external payable returns (uint);\\n\\n    function mintAddressLock(\\n        address trigger,\\n        bytes memory arguments,\\n        address[] memory recipients,\\n        uint[] memory quantities,\\n        IRevest.FNFTConfig memory fnftConfig\\n    ) external payable returns (uint);\\n\\n    function withdrawFNFT(uint tokenUID, uint quantity) external;\\n\\n    function unlockFNFT(uint tokenUID) external;\\n\\n    function splitFNFT(\\n        uint fnftId,\\n        uint[] memory proportions,\\n        uint quantity\\n    ) external returns (uint[] memory newFNFTIds);\\n\\n    function depositAdditionalToFNFT(\\n        uint fnftId,\\n        uint amount,\\n        uint quantity\\n    ) external returns (uint);\\n\\n    function setFlatWeiFee(uint wethFee) external;\\n\\n    function setERC20Fee(uint erc20) external;\\n\\n    function getFlatWeiFee() external returns (uint);\\n\\n    function getERC20Fee() external returns (uint);\\n\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAddressLock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IRegistryProvider.sol\\\";\\nimport '@openzeppelin/contracts/utils/introspection/IERC165.sol';\\n\\n/**\\n * @title Provider interface for Revest FNFTs\\n * @dev Address locks MUST be non-upgradeable to be considered for trusted status\\n * @author Revest\\n */\\ninterface IAddressLock is IRegistryProvider, IERC165{\\n\\n    /// Creates a lock to the specified lockID\\n    /// @param fnftId the fnftId to map this lock to. Not recommended for typical locks, as it will break on splitting\\n    /// @param lockId the lockId to map this lock to. Recommended uint for storing references to lock configurations\\n    /// @param arguments an abi.encode() bytes array. Allows frontend to encode and pass in an arbitrary set of parameters\\n    /// @dev creates a lock for the specified lockId. Will be called during the creation process for address locks when the address\\n    ///      of a contract implementing this interface is passed in as the \\\"trigger\\\" address for minting an address lock. The bytes\\n    ///      representing any parameters this lock requires are passed through to this method, where abi.decode must be call on them\\n    function createLock(uint fnftId, uint lockId, bytes memory arguments) external;\\n\\n    /// Updates a lock at the specified lockId\\n    /// @param fnftId the fnftId that can map to a lock config stored in implementing contracts. Not recommended, as it will break on splitting\\n    /// @param lockId the lockId that maps to the lock config which should be updated. Recommended for retrieving references to lock configurations\\n    /// @param arguments an abi.encode() bytes array. Allows frontend to encode and pass in an arbitrary set of parameters\\n    /// @dev updates a lock for the specified lockId. Will be called by the frontend from the information section if an update is requested\\n    ///      can further accept and decode parameters to use in modifying the lock's config or triggering other actions\\n    ///      such as triggering an on-chain oracle to update\\n    function updateLock(uint fnftId, uint lockId, bytes memory arguments) external;\\n\\n    /// Whether or not the lock can be unlocked\\n    /// @param fnftId the fnftId that can map to a lock config stored in implementing contracts. Not recommended, as it will break on splitting\\n    /// @param lockId the lockId that maps to the lock config which should be updated. Recommended for retrieving references to lock configurations\\n    /// @dev this method is called during the unlocking and withdrawal processes by the Revest contract - it is also used by the frontend\\n    ///      if this method is returning true and someone attempts to unlock or withdraw from an FNFT attached to the requested lock, the request will succeed\\n    /// @return whether or not this lock may be unlocked\\n    function isUnlockable(uint fnftId, uint lockId) external view returns (bool);\\n\\n    /// Provides an encoded bytes arary that represents values this lock wants to display on the info screen\\n    /// Info to decode these values is provided in the metadata file\\n    /// @param fnftId the fnftId that can map to a lock config stored in implementing contracts. Not recommended, as it will break on splitting\\n    /// @param lockId the lockId that maps to the lock config which should be updated. Recommended for retrieving references to lock configurations\\n    /// @dev used by the frontend to fetch on-chain data on the state of any given lock\\n    /// @return a bytes array that represents the result of calling abi.encode on values which the developer wants to appear on the frontend\\n    function getDisplayValues(uint fnftId, uint lockId) external view returns (bytes memory);\\n\\n    /// Maps to a URL, typically IPFS-based, that contains information on how to encode and decode paramters sent to and from this lock\\n    /// Please see additional documentation for JSON config info\\n    /// @dev this method will be called by the frontend only but is crucial to properly implement for proper minting and information workflows\\n    /// @return a URL to the JSON file containing this lock's metadata schema\\n    function getMetadata() external view returns (string memory);\\n\\n    /// Whether or not this lock will need updates and should display the option for them\\n    /// @dev this will be called by the frontend to determine if update inputs and buttons should be displayed\\n    /// @return whether or not the locks created by this contract will need updates\\n    function needsUpdate() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRegistryProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IAddressRegistry.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../interfaces/ILockManager.sol\\\";\\nimport \\\"../interfaces/ITokenVault.sol\\\";\\nimport \\\"../lib/uniswap/IUniswapV2Factory.sol\\\";\\n\\ninterface IRegistryProvider {\\n    function setAddressRegistry(address revest) external;\\n\\n    function getAddressRegistry() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILockManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IRevest.sol\\\";\\n\\ninterface ILockManager {\\n\\n    function createLock(uint fnftId, IRevest.LockParam memory lock) external returns (uint);\\n\\n    function getLock(uint lockId) external view returns (IRevest.Lock memory);\\n\\n    function fnftIdToLockId(uint fnftId) external view returns (uint);\\n\\n    function fnftIdToLock(uint fnftId) external view returns (IRevest.Lock memory);\\n\\n    function pointFNFTToLock(uint fnftId, uint lockId) external;\\n\\n    function lockTypes(uint tokenId) external view returns (IRevest.LockType);\\n\\n    function unlockFNFT(uint fnftId, address sender) external returns (bool);\\n\\n    function getLockMaturity(uint fnftId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU-GPL v3.0 or later\\n\\npragma solidity >=0.8.0;\\n\\nimport \\\"./IRevest.sol\\\";\\n\\ninterface ITokenVault {\\n\\n    function createFNFT(\\n        uint fnftId,\\n        IRevest.FNFTConfig memory fnftConfig,\\n        uint quantity,\\n        address from\\n    ) external;\\n\\n    function withdrawToken(\\n        uint fnftId,\\n        uint quantity,\\n        address user\\n    ) external;\\n\\n    function depositToken(\\n        uint fnftId,\\n        uint amount,\\n        uint quantity\\n    ) external;\\n\\n    function cloneFNFTConfig(IRevest.FNFTConfig memory old) external returns (IRevest.FNFTConfig memory);\\n\\n    function mapFNFTToToken(\\n        uint fnftId,\\n        IRevest.FNFTConfig memory fnftConfig\\n    ) external;\\n\\n    function handleMultipleDeposits(\\n        uint fnftId,\\n        uint newFNFTId,\\n        uint amount\\n    ) external;\\n\\n    function splitFNFT(\\n        uint fnftId,\\n        uint[] memory newFNFTIds,\\n        uint[] memory proportions,\\n        uint quantity\\n    ) external;\\n\\n    function getFNFT(uint fnftId) external view returns (IRevest.FNFTConfig memory);\\n    function getFNFTCurrentValue(uint fnftId) external view returns (uint);\\n    function getNontransferable(uint fnftId) external view returns (bool);\\n    function getSplitsRemaining(uint fnftId) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/uniswap/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reg_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addressesProvider\",\"outputs\":[{\"internalType\":\"contract IAddressRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"arguments\",\"type\":\"bytes\"}],\"name\":\"createLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddressRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockId\",\"type\":\"uint256\"}],\"name\":\"getDisplayValues\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMetadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockId\",\"type\":\"uint256\"}],\"name\":\"isUnlockable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"locks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"unlocked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadataURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"needsUpdate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"}],\"name\":\"setAddressRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_metadataURI\",\"type\":\"string\"}],\"name\":\"setMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"updateLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AdminTimeLock","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000d721a90dd7e010c8c5e022cc0100c55ac78e0fc4","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}