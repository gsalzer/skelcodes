{"status":"1","message":"OK","result":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n\r\n/*\r\n\r\n   _____ __  ______  ______     ___________   _____    _   ______________\r\n  / ___// / / / __ \\/ ____/    / ____/  _/ | / /   |  / | / / ____/ ____/\r\n  \\__ \\/ / / / /_/ / /_       / /_   / //  |/ / /| | /  |/ / /   / __/   \r\n ___/ / /_/ / _, _/ __/  _   / __/ _/ // /|  / ___ |/ /|  / /___/ /___   \r\n/____/\\____/_/ |_/_/    (_) /_/   /___/_/ |_/_/  |_/_/ |_/\\____/_____/  \r\n\r\nWebsite: https://surf.finance\r\nContract: WhirlpoolDistributor.sol\r\nDescription: The Whirlpool Distributor sends SURF to The Whirlpool daily\r\nCreated by Proof\r\n\r\n*/\r\n\r\npragma solidity 0.8.6;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract WhirlpoolDistributor is Ownable {\r\n\r\n    // The SURF token contract\r\n    IERC20 public surf;\r\n    // The Whirlpool contract\r\n    address public whirlpool;\r\n\r\n    // The base amount of SURF sent to The Whirlpool daily\r\n    uint256 public baseSurfReward = 1000e18;\r\n    // The extra amount of SURF sent to The Whirlpool daily per 100,000 SURF in this contract\r\n    uint256 public extraSurfReward = 1000e18;\r\n    // The amount of SURF rewarded to the \"distribute\" function caller\r\n    uint256 public distributorSurfReward = 50e18;\r\n    // How often SURF can be distributed to the Whirlpool\r\n    uint256 public constant DISTRIBUTION_INTERVAL = 24 hours;\r\n    // When the last SURF distribution was processed (timestamp)\r\n    uint256 public lastDistribution;\r\n\r\n    event Distribute(address indexed distributor, uint256 reward, uint256 distributed);\r\n\r\n    constructor(uint256 _firstDistribution) {\r\n        surf = IERC20(0xEa319e87Cf06203DAe107Dd8E5672175e3Ee976c);\r\n        whirlpool = 0x999b1e6EDCb412b59ECF0C5e14c20948Ce81F40b;\r\n        lastDistribution = _firstDistribution - DISTRIBUTION_INTERVAL;\r\n\t}\r\n\r\n\tfunction distribute() external {\r\n        uint256 distributionAmount = getDistributionAmount();\r\n        require(distributionAmount > 0, \"Nothing to distribute\");\r\n\r\n        uint256 daysSinceLastDistribution = getDaysSinceLastDistribution();\r\n        lastDistribution += (daysSinceLastDistribution * DISTRIBUTION_INTERVAL);\r\n\r\n        uint256 rewardAmount = distributionAmount > (distributorSurfReward * 2) ? distributorSurfReward : 0;\r\n        if (rewardAmount > 0) {\r\n            distributionAmount = distributionAmount - rewardAmount;\r\n            surf.transfer(msg.sender, rewardAmount);\r\n        }\r\n\r\n        surf.transfer(whirlpool, distributionAmount);\r\n\r\n        emit Distribute(msg.sender, rewardAmount, distributionAmount);\r\n\t}\r\n\r\n    // Sets the baseSurfReward. Must be between 1 and 10,000\r\n    function setBaseSurfReward(uint256 _baseSurfReward) external onlyOwner {\r\n        require(_baseSurfReward >= 1e18 && _baseSurfReward <= 10000e18, \"Out of range\");\r\n        baseSurfReward = _baseSurfReward;\r\n    }\r\n\r\n    // Sets the extraSurfReward. Must be between 0 and 10,000\r\n    function setExtraSurfReward(uint256 _extraSurfReward) external onlyOwner {\r\n        require(_extraSurfReward >= 0 && _extraSurfReward <= 10000e18, \"Out of range\");\r\n        extraSurfReward = _extraSurfReward;\r\n    }\r\n\r\n    // Sets the distributorSurfReward. Must be between 0 and 100\r\n    function setDistributorSurfReward(uint256 _distributorSurfReward) external onlyOwner {\r\n        require(_distributorSurfReward >= 0 && _distributorSurfReward <= 100e18, \"Out of range\");\r\n        distributorSurfReward = _distributorSurfReward;\r\n    }\r\n\r\n    // Sets the address of The Whirlpool contract\r\n    function setWhirlpoolAddress(address _whirlpool) external onlyOwner {\r\n        whirlpool = _whirlpool;\r\n    }\r\n\r\n    // Function to recover ERC20 tokens accidentally sent to the contract.\r\n    // SURF tokens (the only token that should be in this contract) can't be withdrawn this way.\r\n    function recoverToken(IERC20 _token, address _receiver) external onlyOwner {\r\n        require(address(_token) != address(surf), \"Cannot recover SURF\");\r\n        uint256 tokenBalance = _token.balanceOf(address(this));\r\n        require(tokenBalance > 0, \"No balance\");\r\n        _token.transfer(_receiver, tokenBalance);\r\n    }\r\n\r\n    function timeUntilNextDistribution() external view returns (uint256) {\r\n        if (block.timestamp > lastDistribution + DISTRIBUTION_INTERVAL) {\r\n            return 0;\r\n        }\r\n        return (lastDistribution + DISTRIBUTION_INTERVAL) - block.timestamp;\r\n    }\r\n\r\n    function getDaysSinceLastDistribution() public view returns (uint256) {\r\n        return (block.timestamp - lastDistribution) / DISTRIBUTION_INTERVAL;\r\n    }\r\n\r\n    function getDistributionAmount() public view returns (uint256) {\r\n        uint256 surfBalance = surf.balanceOf(address(this));\r\n        if (surfBalance == 0) return 0;\r\n        \r\n        // How many days since the last distribution?\r\n        uint256 daysSinceLastDistribution = getDaysSinceLastDistribution();\r\n\r\n        // If less than 1, don't do anything\r\n        if (daysSinceLastDistribution == 0) return 0;\r\n\r\n        uint256 total = 0;\r\n\r\n        for (uint256 i = 0; i < daysSinceLastDistribution; i++) {\r\n            total += baseSurfReward + (extraSurfReward * ((surfBalance-total) / 100000e18));\r\n        }\r\n\r\n        // Cap total at contract balance\r\n        total = total > surfBalance ? surfBalance : total;\r\n        return total;\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_firstDistribution\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"distributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"distributed\",\"type\":\"uint256\"}],\"name\":\"Distribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DISTRIBUTION_INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseSurfReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributorSurfReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extraSurfReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDaysSinceLastDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDistributionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"recoverToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_baseSurfReward\",\"type\":\"uint256\"}],\"name\":\"setBaseSurfReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_distributorSurfReward\",\"type\":\"uint256\"}],\"name\":\"setDistributorSurfReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_extraSurfReward\",\"type\":\"uint256\"}],\"name\":\"setExtraSurfReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_whirlpool\",\"type\":\"address\"}],\"name\":\"setWhirlpoolAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"surf\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeUntilNextDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whirlpool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"WhirlpoolDistributor","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000006164d000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://80cb827978e1cc9782cb619629c022ea5902f12d73574e1da8667ee44a3a7893"}]}