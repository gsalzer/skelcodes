{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8\\n    );\\n\\n  function description()\\n    external\\n    view\\n    returns (\\n      string memory\\n    );\\n\\n  function version()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/ICO/XifraICO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../Token/ERC20/IERC20.sol\\\";\\n\\n// TODO. MaÃ±ana comentar todas las funciones...\\n\\ncontract XifraICO {\\n\\n    address immutable private xifraWallet;                      // Xifra wallet\\n    address immutable private xifraToken;                       // Xifra token address\\n    address immutable private usdtToken;                        // USDT token address\\n    address immutable private usdcToken;                        // USDC token address\\n    uint256 immutable private minTokensBuyAllowed;              // Minimum tokens allowed\\n    uint256 immutable private maxICOTokens;                     // Max ICO tokens to sell\\n    uint256 immutable private icoStartDate;                     // ICO start date\\n    uint256 immutable private icoEndDate;                       // ICO end date\\n    AggregatorV3Interface internal priceFeed;                   // Chainlink price feeder ETH/USD\\n\\n    uint256 public icoTokensBought;                             // Tokens sold\\n    uint256 public tokenListingDate;                            // Token listing date\\n    mapping(address => uint256) private userBoughtTokens;       // Mapping to store all the buys\\n    mapping(address => uint256) private userWithdrawTokens;     // Mapping to store the user tokens withdraw\\n\\n    bool private icoFinished;\\n    uint32 internal constant _1_MONTH_IN_SECONDS = 2592000;\\n    uint32 internal constant _3_MONTHS_IN_SECONDS = 3 * _1_MONTH_IN_SECONDS;\\n    uint32 internal constant _6_MONTHS_IN_SECONDS = 6 * _1_MONTH_IN_SECONDS;\\n    uint32 internal constant _9_MONTHS_IN_SECONDS = 9 * _1_MONTH_IN_SECONDS;\\n\\n    uint256 internal constant _MIN_COINS_FOR_VESTING = 26667 * 10 ** 18;\\n\\n    event onTokensBought(address _buyer, uint256 _tokens, uint256 _paymentAmount, address _tokenPayment);\\n    event onWithdrawICOFunds(uint256 _usdtBalance, uint256 _usdcBalance, uint256 _ethbalance);\\n    event onWithdrawBoughtTokens(address _user, uint256 _maxTokensAllowed);\\n    event onICOFinished(uint256 _date);\\n\\n    /**\\n     * @notice Constructor\\n     * @param _wallet               --> Xifra master wallet\\n     * @param _token                --> Xifra token address\\n     * @param _icoStartDate         --> ICO start date\\n     * @param _icoEndDate           --> ICO end date\\n     * @param _usdtToken            --> USDT token address\\n     * @param _usdcToken            --> USDC token address\\n     * @param _minTokensBuyAllowed  --> Minimal amount of tokens allowed to buy\\n     * @param _maxICOTokens         --> Number of tokens selling in this ICO\\n     * @param _tokenListingDate     --> Token listing date for the ICO vesting\\n     */\\n    constructor(address _wallet, address _token, uint256 _icoStartDate, uint256 _icoEndDate, address _usdtToken, address _usdcToken, uint256 _minTokensBuyAllowed, uint256 _maxICOTokens, uint256 _tokenListingDate) {\\n        xifraWallet = _wallet;\\n        xifraToken = _token;\\n        icoStartDate = _icoStartDate;\\n        icoEndDate = _icoEndDate;\\n        usdtToken = _usdtToken;\\n        usdcToken = _usdcToken;\\n        minTokensBuyAllowed = _minTokensBuyAllowed;\\n        maxICOTokens = _maxICOTokens;\\n        tokenListingDate = _tokenListingDate;\\n        if (_getChainId() == 1) priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\\n        else if (_getChainId() == 4) priceFeed = AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);\\n    }\\n\\n    /**\\n     * @notice Buy function. Used to buy tokens using ETH, USDT or USDC\\n     * @param _paymentAmount    --> Result of multiply number of tokens to buy per price per token. Must be always multiplied per 1000 to avoid decimals \\n     * @param _tokenPayment     --> Address of the payment token (or 0x0 if payment is ETH)\\n     */\\n    function buy(uint256 _paymentAmount, address _tokenPayment) external payable {\\n        require(_isICOActive() == true, \\\"ICONotActive\\\");\\n               \\n        uint256 paidTokens = 0;\\n\\n        if (msg.value == 0) {\\n            // Stable coin payment\\n            require(_paymentAmount > 0, \\\"BadPayment\\\");\\n            require(_tokenPayment == usdtToken || _tokenPayment == usdcToken, \\\"TokenNotSupported\\\");\\n            require(IERC20(_tokenPayment).transferFrom(msg.sender, address(this), _paymentAmount));\\n            paidTokens = _paymentAmount * 2666666666666666667 / 1000000000000000000;   // 0.375$ per token in the ICO\\n        } else {\\n            // ETH Payment\\n            uint256 usdETH = _getUSDETHPrice();\\n            uint256 paidUSD = msg.value * usdETH / 10**18;\\n            paidTokens = paidUSD * 2666666666666666666 / 1000000000000000000;   // 0.375$ per token in the ICO\\n        }\\n\\n        require((paidTokens + 1*10**18) >= minTokensBuyAllowed, \\\"BadTokensQuantity\\\");    // One extra token as threshold rounding decimals\\n        require(maxICOTokens - icoTokensBought >= paidTokens, \\\"NoEnoughTokensInICO\\\");\\n        userBoughtTokens[msg.sender] += paidTokens;\\n        icoTokensBought += paidTokens;\\n        if (maxICOTokens - icoTokensBought < minTokensBuyAllowed) {\\n            // We finish the ICO\\n            icoFinished = true;\\n            emit onICOFinished(block.timestamp);\\n        }\\n\\n        emit onTokensBought(msg.sender, paidTokens, _paymentAmount, _tokenPayment);\\n    }\\n\\n    /**\\n     * @notice Withdraw user tokens when the vesting rules allow it\\n     */\\n    function withdrawBoughtTokens() external {\\n        require(_isICOActive() == false, \\\"ICONotActive\\\");\\n        require(userBoughtTokens[msg.sender] > 0, \\\"NoBalance\\\");\\n        require(block.timestamp >= tokenListingDate, \\\"TokenNoListedYet\\\");\\n\\n        uint256 boughtBalance = userBoughtTokens[msg.sender];\\n        uint256 maxTokensAllowed = 0;\\n        if ((block.timestamp >= tokenListingDate) && (block.timestamp < tokenListingDate + _3_MONTHS_IN_SECONDS)) {\\n            if (boughtBalance <= _MIN_COINS_FOR_VESTING) {\\n                maxTokensAllowed = boughtBalance - userWithdrawTokens[msg.sender];\\n            } else {\\n                uint maxTokens = boughtBalance * 25 / 100;\\n                if (userWithdrawTokens[msg.sender] < maxTokens) {\\n                    maxTokensAllowed = maxTokens - userWithdrawTokens[msg.sender];\\n                }\\n            }\\n        } else if ((block.timestamp >= tokenListingDate + _3_MONTHS_IN_SECONDS) && (block.timestamp < tokenListingDate + _6_MONTHS_IN_SECONDS)) {\\n            uint256 maxTokens = boughtBalance * 50 / 100;\\n            if (userWithdrawTokens[msg.sender] < maxTokens) {\\n                maxTokensAllowed = maxTokens - userWithdrawTokens[msg.sender];\\n            }\\n        } else if ((block.timestamp >= tokenListingDate + _6_MONTHS_IN_SECONDS) && (block.timestamp < tokenListingDate + _9_MONTHS_IN_SECONDS)) {\\n            uint256 maxTokens = boughtBalance * 75 / 100;\\n            if (userWithdrawTokens[msg.sender] < maxTokens) {\\n                maxTokensAllowed = maxTokens - userWithdrawTokens[msg.sender];\\n            }\\n        } else {\\n            uint256 maxTokens = boughtBalance;\\n            if (userWithdrawTokens[msg.sender] < maxTokens) {\\n                maxTokensAllowed = maxTokens - userWithdrawTokens[msg.sender];\\n            }\\n        }\\n\\n        require(maxTokensAllowed > 0, \\\"NoTokensToWithdraw\\\");\\n\\n        userWithdrawTokens[msg.sender] += maxTokensAllowed;\\n        require(IERC20(xifraToken).transfer(msg.sender, maxTokensAllowed));\\n\\n        emit onWithdrawBoughtTokens(msg.sender, maxTokensAllowed);\\n    }\\n\\n    /**\\n     * @notice Returns the crypto numbers and balance in the ICO contract\\n     */\\n    function withdrawICOFunds() external {\\n        require(_isICOActive() == false, \\\"ICONotActive\\\");\\n        \\n        uint256 usdtBalance = IERC20(usdtToken).balanceOf(address(this));\\n        require(IERC20(usdtToken).transfer(xifraWallet, usdtBalance));\\n\\n        uint256 usdcBalance = IERC20(usdcToken).balanceOf(address(this));\\n        require(IERC20(usdcToken).transfer(xifraWallet, usdcBalance));\\n\\n        uint256 ethbalance = address(this).balance;\\n        payable(xifraWallet).transfer(ethbalance);\\n\\n        emit onWithdrawICOFunds(usdtBalance, usdcBalance, ethbalance);\\n    }\\n\\n    /**\\n     * @notice Withdraw the unsold Xifra tokens to the Xifra wallet when the ICO is finished\\n     */\\n    function withdrawICOTokens() external {\\n        require(_isICOActive() == false, \\\"ICONotActive\\\");\\n        require(msg.sender == xifraWallet, \\\"OnlyXifra\\\");\\n\\n        uint256 balance = maxICOTokens - icoTokensBought;\\n        require(IERC20(xifraToken).transfer(xifraWallet, balance));\\n    }\\n\\n    /**\\n     * @notice OnlyOwner function. Change the listing date to start the vesting\\n     * @param _tokenListDate --> New listing date in UnixDateTime UTC format\\n     */\\n    function setTokenListDate(uint256 _tokenListDate) external {\\n        require(msg.sender == xifraWallet, \\\"BadOwner\\\");\\n        require(block.timestamp <= tokenListingDate, \\\"TokenListedYet\\\");\\n\\n        tokenListingDate = _tokenListDate;\\n    }\\n\\n    /**\\n     * @notice Returns the number of tokens and user has bought\\n     * @param _user --> User account\\n     * @return Returns the user token balance in wei units\\n     */\\n    function getUserBoughtTokens(address _user) external view returns(uint256) {\\n        return userBoughtTokens[_user];\\n    }\\n\\n    /**\\n     * @notice Returns the number of tokens and user has withdrawn\\n     * @param _user --> User account\\n     * @return Returns the user token withdrawns in wei units\\n     */\\n    function getUserWithdrawnTokens(address _user) external view returns(uint256) {\\n        return userWithdrawTokens[_user];\\n    }\\n\\n    /**\\n     * @notice Returns the crypto numbers in the ICO\\n     * @return xifra Returns the Xifra tokens balance in the contract\\n     * @return eth Returns the ETHs balance in the contract\\n     * @return usdt Returns the USDTs balance in the contract\\n     * @return usdc Returns the USDCs balance in the contract\\n     */\\n    function getICOData() external view returns(uint256 xifra, uint256 eth, uint256 usdt, uint256 usdc) {\\n        xifra = IERC20(xifraToken).balanceOf(address(this));\\n        usdt = IERC20(usdtToken).balanceOf(address(this));\\n        usdc = IERC20(usdcToken).balanceOf(address(this));\\n        eth = address(this).balance;\\n    }\\n\\n    /**\\n     * @notice Traslate a payment in USD to ETHs\\n     * @param _paymentAmount --> Payment amount in USD\\n     * @return Returns the ETH amount in weis\\n     */\\n    function calculateETHPayment(uint256 _paymentAmount) external view returns(uint256) {\\n        uint256 usdETH = _getUSDETHPrice();\\n        return (_paymentAmount * 10 ** 18) / usdETH;\\n    }\\n\\n    /**\\n     * @notice Get the vesting unlock dates\\n     * @param _period --> There are 4 periods (0,1,2,3)\\n     * @return _date Returns the date in UnixDateTime UTC format\\n     */\\n    function getVestingDate(uint256 _period) external view returns(uint256 _date) {\\n        if (_period == 0) {\\n            _date = tokenListingDate;\\n        } else if (_period == 1) {\\n            _date = tokenListingDate + _3_MONTHS_IN_SECONDS;\\n        } else if (_period == 2) {\\n            _date = tokenListingDate + _6_MONTHS_IN_SECONDS;\\n        } else if (_period == 3) {\\n            _date = tokenListingDate + _9_MONTHS_IN_SECONDS;\\n        }\\n    }\\n\\n    /**\\n     * @notice Public function that returns ETHUSD par\\n     * @return Returns the how much USDs are in 1 ETH in weis\\n     */\\n    function getUSDETHPrice() external view returns(uint256) {\\n        return _getUSDETHPrice();\\n    }\\n\\n    /**\\n     * @notice Uses Chainlink to query the USDETH price\\n     * @return Returns the ETH amount in weis (Fixed value of 3932.4 USDs in localhost development environments)\\n     */\\n    function _getUSDETHPrice() internal view returns(uint256) {\\n        int price = 0;\\n\\n        if (address(priceFeed) != address(0)) {\\n            (, price, , , ) = priceFeed.latestRoundData();\\n        } else {\\n            // For local testing\\n            price = 393240000000;\\n        }\\n\\n        return uint256(price * 10**10);\\n    }\\n\\n    /**\\n     * @notice Internal function that queries the chainId\\n     * @return Returns the chainId (1 - Mainnet, 4 - Rinkeby testnet)\\n     */\\n    function _getChainId() internal view returns (uint256) {\\n        uint256 chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n\\n    /**\\n     * @notice Internal - Is ICO active?\\n     * @return Returns true or false\\n     */\\n    function _isICOActive() internal view returns(bool) {\\n        if ((block.timestamp < icoStartDate) || (block.timestamp > icoEndDate) || (icoFinished == true)) return false;\\n        else return true;\\n    }\\n\\n    /**\\n     * @notice External - Is ICO active?\\n     * @return Returns true or false\\n     */\\n    function isICOActive() external view returns(bool) {\\n        return _isICOActive();\\n    }\\n}\"\r\n    },\r\n    \"/contracts/Token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_icoStartDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_icoEndDate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_usdtToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdcToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minTokensBuyAllowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxICOTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenListingDate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"onICOFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_paymentAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenPayment\",\"type\":\"address\"}],\"name\":\"onTokensBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_maxTokensAllowed\",\"type\":\"uint256\"}],\"name\":\"onWithdrawBoughtTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_usdtBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_usdcBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ethbalance\",\"type\":\"uint256\"}],\"name\":\"onWithdrawICOFunds\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_paymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_tokenPayment\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_paymentAmount\",\"type\":\"uint256\"}],\"name\":\"calculateETHPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getICOData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"xifra\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdc\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUSDETHPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserBoughtTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserWithdrawnTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"getVestingDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_date\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"icoTokensBought\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isICOActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenListDate\",\"type\":\"uint256\"}],\"name\":\"setTokenListDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenListingDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBoughtTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawICOFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawICOTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"XifraICO","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001ef7f06bb20a8ebf23da0e8d6e5589c1e726eb18000000000000000000000000c987b821048edcb9f5aa126125b95e44e2532a6a0000000000000000000000000000000000000000000000000000000061413780000000000000000000000000000000000000000000000000000000006175f37f000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec7000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000000000000000000000000001b1ae4d6e2ef500000000000000000000000000000000000000000000000295be96e640669720000000000000000000000000000000000000000000000000000000000000061d78280","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}