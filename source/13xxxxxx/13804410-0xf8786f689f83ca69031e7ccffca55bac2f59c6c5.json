{"status":"1","message":"OK","result":[{"SourceCode":"{\"LiquidityProtectionSingleLimitStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport \\\"./StrategyBase.sol\\\";\\n\\ncontract LiquidityProtectionSingleLimitStrategy is StrategyBase {\\n    mapping(address =\\u003e Protection) private protection;\\n\\n    struct Limit {\\n        uint256 periodInSeconds;  \\n        uint256 lastCheckpointTime; \\n        uint256 amountPerPeriod;\\n        uint256 amountLeftInCurrentPeriod;\\n    }\\n\\n    struct Protection {\\n        mapping(address =\\u003e Limit) limits;\\n    }\\n\\n    constructor(Guardian _guardian, LosslessController _controller) StrategyBase(_guardian, _controller) {}\\n\\n    // --- VIEWS ---\\n\\n    function getLimit(address token, address protectedAddress) external view returns(Limit memory) {\\n        return protection[token].limits[protectedAddress];\\n    }\\n\\n    // --- METHODS ---\\n\\n    // @param token Project token, the protection will be scoped inside of this token\\u0027s transfers.\\n    // @param protectedAddress Address to apply the limits to.\\n    // @param periodInSeconds Limit period in seconds.\\n    // @param amountPerPeriod Max amount that can be transfered in period.\\n    // @param startTimestamp Shows when limit should be activated.\\n    // @dev This method allows setting 1 limit to 0...N addresses.\\n    function setLimitBatched(\\n        address token,\\n        address[] calldata protectedAddresses,\\n        uint256 periodInSeconds,\\n        uint256 amountPerPeriod,\\n        uint256 startTimestamp\\n    ) external onlyProtectionAdmin(token) {\\n        for(uint8 i = 0; i \\u003c protectedAddresses.length; i++) {\\n            saveLimit(token, protectedAddresses[i], periodInSeconds, amountPerPeriod, startTimestamp);\\n            guardian.setProtectedAddress(token, protectedAddresses[i]);\\n        }\\n    }\\n\\n    // @dev params pretty much the same as in batched\\n    // @dev This method allows setting 1 limit 1 address.\\n    function setLimit(\\n        address token,\\n        address protectedAddress,\\n        uint256 periodInSeconds,\\n        uint256 amountPerPeriod,\\n        uint256 startTimestamp\\n    ) external onlyProtectionAdmin(token) {\\n        \\n        saveLimit(token, protectedAddress, periodInSeconds, amountPerPeriod, startTimestamp);\\n        guardian.setProtectedAddress(token, protectedAddress);\\n    }\\n\\n    function removeLimits(address token, address[] calldata protectedAddresses) external onlyProtectionAdmin(token) {\\n        for(uint8 i = 0; i \\u003c protectedAddresses.length; i++) {\\n            delete protection[token].limits[protectedAddresses[i]];\\n            guardian.removeProtectedAddresses(token, protectedAddresses[i]);\\n        }\\n    }\\n\\n    // @dev Pausing is just adding a limit with amount 0.\\n    // @dev amountLeftInCurrentPeriod never resets because of the lastCheckpointTime\\n    // @dev This approach uses less gas than having a separate isPaused flag.\\n    function pause(address token, address protectedAddress) external onlyProtectionAdmin(token) {\\n        require(controller.isAddressProtected(token, protectedAddress), \\\"LOSSLESS: Address not protected\\\");\\n        Limit storage limit = protection[token].limits[protectedAddress];\\n        limit.amountLeftInCurrentPeriod = 0;\\n        limit.lastCheckpointTime = type(uint256).max - limit.periodInSeconds;\\n        emit Paused(token, protectedAddress);\\n    }\\n\\n    // @dev Limit is reset every period.\\n    // @dev Every period has it\\u0027s own amountLeft which gets decreased on every transfer.\\n    // @dev This method modifies state so should be callable only by the trusted address!\\n    function isTransferAllowed(address token, address sender, address recipient, uint256 amount) external {\\n        require(msg.sender == address(controller), \\\"LOSSLESS: LSS Controller only\\\");\\n        Limit storage limit = protection[token].limits[sender];\\n\\n        // Is transfer is in the same period ?\\n        if (limit.lastCheckpointTime + limit.periodInSeconds \\u003e block.timestamp) { \\n            limit.amountLeftInCurrentPeriod = calculateAmountLeft(amount, limit.amountLeftInCurrentPeriod);\\n        }\\n        // New period started, update checkpoint and reset amount\\n        else {\\n            limit.lastCheckpointTime = calculateUpdatedCheckpoint(limit.lastCheckpointTime, limit.periodInSeconds);\\n            limit.amountLeftInCurrentPeriod = calculateAmountLeft(amount, limit.amountPerPeriod);\\n        }\\n        \\n        require(limit.amountLeftInCurrentPeriod \\u003e 0, \\\"LOSSLESS: Strategy Limit reached\\\");\\n    }\\n\\n    // --- INTERNAL METHODS ---\\n\\n    function saveLimit(\\n        address token,\\n        address protectedAddress,\\n        uint256 periodInSeconds,\\n        uint256 amountPerPeriod,\\n        uint256 startTimestamp\\n    ) internal {\\n        Limit storage limit = protection[token].limits[protectedAddress];\\n        limit.periodInSeconds = periodInSeconds;\\n        limit.amountPerPeriod = amountPerPeriod;\\n        limit.lastCheckpointTime = startTimestamp;\\n        limit.amountLeftInCurrentPeriod = amountPerPeriod;\\n    }\\n\\n    function calculateAmountLeft(uint256 amount, uint256 amountLeft) internal pure returns (uint256)  {\\n        if (amount \\u003e= amountLeft) {\\n            return 0;\\n        } else {\\n            return amountLeft - amount;\\n        }\\n    }\\n\\n    function calculateUpdatedCheckpoint(uint256 lastCheckpoint, uint256 periodInSeconds) internal view returns(uint256) {\\n        return lastCheckpoint + (periodInSeconds * ((block.timestamp - lastCheckpoint) / periodInSeconds));\\n    }\\n}\"},\"StrategyBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\ninterface LosslessController {\\n    function admin() external returns(address);\\n\\n    function isAddressProtected(address token, address protectedAddress) external view returns (bool);\\n}\\n\\ninterface Guardian {\\n    function protectionAdmin(address token) external returns (address);\\n\\n    function setProtectedAddress(address token, address guardedAddress) external;\\n\\n    function removeProtectedAddresses(address token, address protectedAddress) external;\\n}\\n\\nabstract contract StrategyBase {\\n    Guardian public guardian;\\n    LosslessController public controller;\\n\\n    // --- EVENTS ---\\n\\n    event GuardianSet(address indexed newGuardian);\\n    event Paused(address indexed token, address indexed protectedAddress);\\n    event Unpaused(address indexed token, address indexed protectedAddress);\\n\\n    constructor(Guardian _guardian, LosslessController _controller) {\\n        guardian = _guardian;\\n        controller = _controller;\\n    }\\n\\n    // --- MODIFIERS ---\\n\\n    modifier onlyProtectionAdmin(address token) {\\n        require(msg.sender == guardian.protectionAdmin(token), \\\"LOSSLESS: Not protection admin\\\");\\n        _;\\n    }\\n\\n    // --- METHODS ---\\n\\n    // @dev In case guardian is changed, this allows not to redeploy strategy and just update it.\\n    function setGuardian(Guardian newGuardian) external {\\n        require(msg.sender == controller.admin(), \\\"LOSSLESS: Not lossless admin\\\");\\n        guardian = newGuardian;\\n        emit GuardianSet(address(newGuardian));\\n    }\\n}\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"contract Guardian\",\"name\":\"_guardian\",\"type\":\"address\"},{\"internalType\":\"contract LosslessController\",\"name\":\"_controller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGuardian\",\"type\":\"address\"}],\"name\":\"GuardianSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protectedAddress\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"protectedAddress\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract LosslessController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"protectedAddress\",\"type\":\"address\"}],\"name\":\"getLimit\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"periodInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastCheckpointTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountLeftInCurrentPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct LiquidityProtectionSingleLimitStrategy.Limit\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"contract Guardian\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"isTransferAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"protectedAddress\",\"type\":\"address\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"protectedAddresses\",\"type\":\"address[]\"}],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Guardian\",\"name\":\"newGuardian\",\"type\":\"address\"}],\"name\":\"setGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"protectedAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"periodInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"protectedAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"periodInSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"}],\"name\":\"setLimitBatched\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"LiquidityProtectionSingleLimitStrategy","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000077736d218d05cb3d122107e12def22d5e69e2908000000000000000000000000e91d7cebce484070fc70777cb04f7e2efae31db4","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://eb0d1792aff0145582c61b193b70207e330f31c397171b48a8dbe586c1afc855"}]}