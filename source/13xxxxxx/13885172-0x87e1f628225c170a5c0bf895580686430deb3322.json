{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SingleSidedReinsurancePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"./interfaces/IMigration.sol\\\";\\nimport \\\"./interfaces/IRiskPoolFactory.sol\\\";\\nimport \\\"./interfaces/IRewarderFactory.sol\\\";\\nimport \\\"./interfaces/ISingleSidedReinsurancePool.sol\\\";\\nimport \\\"./interfaces/ISyntheticSSRPFactory.sol\\\";\\nimport \\\"./interfaces/IRewarder.sol\\\";\\nimport \\\"./interfaces/IRiskPool.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\n\\ncontract SingleSidedReinsurancePool is ISingleSidedReinsurancePool, ReentrancyGuard {\\n    address public owner;\\n    address public claimAssessor;\\n    address public migrateTo;\\n    address public syntheticSSRP;\\n\\n    uint256 public LOCK_TIME = 1 days;\\n    uint256 public constant ACC_UNO_PRECISION = 1e18;\\n    uint256 public STAKING_START_TIME;\\n\\n    address public rewarder;\\n    address public override riskPool;\\n    struct PoolInfo {\\n        uint128 lastRewardBlock;\\n        uint128 accUnoPerShare;\\n        uint256 unoMultiplierPerBlock;\\n    }\\n\\n    struct UserInfo {\\n        uint256 lastWithdrawTime;\\n        uint256 rewardDebt;\\n        uint256 amount;\\n    }\\n\\n    mapping(address => UserInfo) public userInfo;\\n\\n    PoolInfo public poolInfo;\\n\\n    event RiskPoolCreated(address indexed _SSRP, address indexed _pool);\\n    event StakedInPool(address indexed _staker, address indexed _pool, uint256 _amount);\\n    event LeftPool(address indexed _staker, address indexed _pool, uint256 _requestAmount);\\n    event LogUpdatePool(uint128 _lastRewardBlock, uint256 _lpSupply, uint256 _accUnoPerShare);\\n    event Harvest(address indexed _user, address indexed _receiver, uint256 _amount);\\n    event LogLeaveFromPendingSSRP(address indexed _user, uint256 _withdrawLpAmount, uint256 _withdrawUnoAmount);\\n    event PolicyClaim(address indexed _user, uint256 _claimAmount);\\n    event LogLpTransferInSSRP(address indexed _from, address indexed _to, uint256 _amount);\\n    event LogCreateRewarder(address indexed _SSRP, address indexed _rewarder, address _currency);\\n    event LogCreateSyntheticSSRP(address indexed _SSRP, address indexed _syntheticSSRP, address indexed _lpToken);\\n    event LogCancelWithdrawRequest(address indexed _user, uint256 _cancelAmount, uint256 _cancelAmountInUno);\\n    event LogMigrate(address indexed _user, address indexed _migrateTo, uint256 _migratedAmount);\\n\\n    constructor(address _owner, address _claimAssessor) {\\n        owner = _owner;\\n        claimAssessor = _claimAssessor;\\n        STAKING_START_TIME = block.timestamp + 3 days;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"UnoRe: Forbidden\\\");\\n        _;\\n    }\\n\\n    modifier onlyClaimAssessor() {\\n        require(msg.sender == claimAssessor, \\\"UnoRe: Forbidden\\\");\\n        _;\\n    }\\n\\n    modifier isStartTime() {\\n        require(block.timestamp >= STAKING_START_TIME, \\\"UnoRe: not available time\\\");\\n        _;\\n    }\\n\\n    function setRewardMultiplier(uint256 _rewardMultiplier) external onlyOwner {\\n        require(_rewardMultiplier > 0, \\\"UnoRe: zero value\\\");\\n        poolInfo.unoMultiplierPerBlock = _rewardMultiplier;\\n    }\\n\\n    function setClaimAssessor(address _claimAssessor) external onlyOwner {\\n        require(_claimAssessor != address(0), \\\"UnoRe: zero address\\\");\\n        claimAssessor = _claimAssessor;\\n    }\\n\\n    function setMigrateTo(address _migrateTo) external onlyOwner {\\n        require(_migrateTo != address(0), \\\"UnoRe: zero address\\\");\\n        migrateTo = _migrateTo;\\n    }\\n\\n    function setMinLPCapital(uint256 _minLPCapital) external onlyOwner {\\n        require(_minLPCapital > 0, \\\"UnoRe: not allow zero value\\\");\\n        IRiskPool(riskPool).setMinLPCapital(_minLPCapital);\\n    }\\n\\n    function setLockTime(uint256 _lockTime) external onlyOwner {\\n        require(_lockTime > 0, \\\"UnoRe: not allow zero lock time\\\");\\n        LOCK_TIME = _lockTime;\\n    }\\n\\n    function setStakingStartTime(uint256 _startTime) external onlyOwner {\\n        require(_startTime > 0, \\\"UnoRe: not allow zero start time\\\");\\n        STAKING_START_TIME = _startTime;\\n    }\\n\\n    /**\\n     * @dev create Risk pool with UNO from SSRP owner\\n     */\\n    function createRiskPool(\\n        string calldata _name,\\n        string calldata _symbol,\\n        address _factory,\\n        address _currency,\\n        uint256 _rewardMultiplier\\n    ) external onlyOwner nonReentrant {\\n        require(riskPool == address(0), \\\"UnoRe: risk pool created already\\\");\\n        riskPool = IRiskPoolFactory(_factory).newRiskPool(_name, _symbol, address(this), _currency);\\n        poolInfo.lastRewardBlock = uint128(block.number);\\n        poolInfo.accUnoPerShare = 0;\\n        poolInfo.unoMultiplierPerBlock = _rewardMultiplier;\\n        emit RiskPoolCreated(address(this), riskPool);\\n    }\\n\\n    function createRewarder(\\n        address _operator,\\n        address _factory,\\n        address _currency\\n    ) external onlyOwner nonReentrant {\\n        require(_factory != address(0), \\\"UnoRe: rewarder factory no exist\\\");\\n        rewarder = IRewarderFactory(_factory).newRewarder(_operator, _currency, address(this));\\n        emit LogCreateRewarder(address(this), rewarder, _currency);\\n    }\\n\\n    function createSyntheticSSRP(address _owner, address _factory) external onlyOwner nonReentrant {\\n        require(_owner != address(0), \\\"UnoRe: zero owner address\\\");\\n        require(_factory != address(0), \\\"UnoRe:zero factory address\\\");\\n        require(riskPool != address(0), \\\"UnoRe:zero LP token address\\\");\\n        syntheticSSRP = ISyntheticSSRPFactory(_factory).newSyntheticSSRP(_owner, riskPool);\\n        emit LogCreateSyntheticSSRP(address(this), syntheticSSRP, riskPool);\\n    }\\n\\n    function migrate() external nonReentrant {\\n        require(migrateTo != address(0), \\\"UnoRe: zero address\\\");\\n        _harvest(msg.sender);\\n        uint256 amount = userInfo[msg.sender].amount;\\n        bool isUnLocked = block.timestamp - userInfo[msg.sender].lastWithdrawTime > LOCK_TIME;\\n        uint256 migratedAmount = IRiskPool(riskPool).migrateLP(msg.sender, migrateTo, isUnLocked);\\n        IMigration(migrateTo).onMigration(msg.sender, amount, \\\"\\\");\\n        userInfo[msg.sender].amount = 0;\\n        userInfo[msg.sender].rewardDebt = 0;\\n        emit LogMigrate(msg.sender, migrateTo, migratedAmount);\\n    }\\n\\n    function pendingUno(address _to) external view returns (uint256 pending) {\\n        uint256 tokenSupply = IERC20(riskPool).totalSupply();\\n        uint128 accUnoPerShare = poolInfo.accUnoPerShare;\\n        if (block.number > poolInfo.lastRewardBlock && tokenSupply != 0) {\\n            uint256 blocks = block.number - uint256(poolInfo.lastRewardBlock);\\n            uint256 unoReward = blocks * poolInfo.unoMultiplierPerBlock;\\n            accUnoPerShare = accUnoPerShare + uint128((unoReward * ACC_UNO_PRECISION) / tokenSupply);\\n        }\\n        uint256 userBalance = userInfo[_to].amount;\\n        pending = (userBalance * uint256(accUnoPerShare)) / ACC_UNO_PRECISION - userInfo[_to].rewardDebt;\\n    }\\n\\n    function updatePool() public override {\\n        if (block.number > poolInfo.lastRewardBlock) {\\n            uint256 tokenSupply = IERC20(riskPool).totalSupply();\\n            if (tokenSupply > 0) {\\n                uint256 blocks = block.number - uint256(poolInfo.lastRewardBlock);\\n                uint256 unoReward = blocks * poolInfo.unoMultiplierPerBlock;\\n                poolInfo.accUnoPerShare = poolInfo.accUnoPerShare + uint128(((unoReward * ACC_UNO_PRECISION) / tokenSupply));\\n            }\\n            poolInfo.lastRewardBlock = uint128(block.number);\\n            emit LogUpdatePool(poolInfo.lastRewardBlock, tokenSupply, poolInfo.accUnoPerShare);\\n        }\\n    }\\n\\n    function enterInPool(uint256 _amount) external override isStartTime nonReentrant {\\n        require(_amount != 0, \\\"UnoRe: ZERO Value\\\");\\n        updatePool();\\n        address token = IRiskPool(riskPool).currency();\\n        uint256 lpPriceUno = IRiskPool(riskPool).lpPriceUno();\\n        TransferHelper.safeTransferFrom(token, msg.sender, riskPool, _amount);\\n        IRiskPool(riskPool).enter(msg.sender, _amount);\\n        userInfo[msg.sender].rewardDebt =\\n            userInfo[msg.sender].rewardDebt +\\n            ((_amount * 1e18 * uint256(poolInfo.accUnoPerShare)) / lpPriceUno) /\\n            ACC_UNO_PRECISION;\\n        userInfo[msg.sender].amount = userInfo[msg.sender].amount + ((_amount * 1e18) / lpPriceUno);\\n        emit StakedInPool(msg.sender, riskPool, _amount);\\n    }\\n\\n    /**\\n     * @dev WR will be in pending for 10 days at least\\n     */\\n    function leaveFromPoolInPending(uint256 _amount) external override isStartTime nonReentrant {\\n        _harvest(msg.sender);\\n        // Withdraw desired amount from pool\\n        uint256 amount = userInfo[msg.sender].amount;\\n        uint256 lpPriceUno = IRiskPool(riskPool).lpPriceUno();\\n        (uint256 pendingAmount, , ) = IRiskPool(riskPool).getWithdrawRequest(msg.sender);\\n        require(((amount - pendingAmount) * lpPriceUno) / 1e18 >= _amount, \\\"UnoRe: withdraw amount overflow\\\");\\n        IRiskPool(riskPool).leaveFromPoolInPending(msg.sender, _amount);\\n\\n        userInfo[msg.sender].lastWithdrawTime = block.timestamp;\\n        emit LeftPool(msg.sender, riskPool, _amount);\\n    }\\n\\n    /**\\n     * @dev user can submit claim again and receive his funds into his wallet after 10 days since last WR.\\n     */\\n    function leaveFromPending() external override isStartTime nonReentrant {\\n        require(block.timestamp - userInfo[msg.sender].lastWithdrawTime >= LOCK_TIME, \\\"UnoRe: Locked time\\\");\\n        _harvest(msg.sender);\\n        uint256 amount = userInfo[msg.sender].amount;\\n        (uint256 pendingAmount, , ) = IRiskPool(riskPool).getWithdrawRequest(msg.sender);\\n        uint256 accumulatedUno = (amount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION;\\n        userInfo[msg.sender].rewardDebt =\\n            accumulatedUno -\\n            ((pendingAmount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION);\\n        (uint256 withdrawAmount, uint256 withdrawAmountInUNO) = IRiskPool(riskPool).leaveFromPending(msg.sender);\\n        userInfo[msg.sender].amount = amount - withdrawAmount;\\n        emit LogLeaveFromPendingSSRP(msg.sender, withdrawAmount, withdrawAmountInUNO);\\n    }\\n\\n    function lpTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) external override nonReentrant {\\n        require(msg.sender == address(riskPool), \\\"UnoRe: not allow others transfer\\\");\\n        if (_from != syntheticSSRP && _to != syntheticSSRP) {\\n            _harvest(_from);\\n            uint256 amount = userInfo[_from].amount;\\n            (uint256 pendingAmount, , ) = IRiskPool(riskPool).getWithdrawRequest(_from);\\n            require(amount - pendingAmount >= _amount, \\\"UnoRe: balance overflow\\\");\\n            uint256 accumulatedUno = (amount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION;\\n            userInfo[_from].rewardDebt = accumulatedUno - ((_amount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION);\\n            userInfo[_from].amount = amount - _amount;\\n\\n            userInfo[_to].rewardDebt =\\n                userInfo[_to].rewardDebt +\\n                ((_amount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION);\\n            userInfo[_to].amount = userInfo[_to].amount + _amount;\\n\\n            emit LogLpTransferInSSRP(_from, _to, _amount);\\n        }\\n    }\\n\\n    function harvest(address _to) external override isStartTime nonReentrant {\\n        _harvest(_to);\\n    }\\n\\n    function _harvest(address _to) private {\\n        updatePool();\\n        uint256 amount = userInfo[_to].amount;\\n        uint256 accumulatedUno = (amount * uint256(poolInfo.accUnoPerShare)) / ACC_UNO_PRECISION;\\n        uint256 _pendingUno = accumulatedUno - userInfo[_to].rewardDebt;\\n\\n        // Effects\\n        userInfo[msg.sender].rewardDebt = accumulatedUno;\\n        uint256 rewardAmount = 0;\\n\\n        if (rewarder != address(0) && _pendingUno != 0) {\\n            rewardAmount = IRewarder(rewarder).onReward(_to, _pendingUno);\\n        }\\n\\n        emit Harvest(msg.sender, _to, rewardAmount);\\n    }\\n\\n    function cancelWithdrawRequest() external nonReentrant {\\n        (uint256 cancelAmount, uint256 cancelAmountInUno) = IRiskPool(riskPool).cancelWithrawRequest(msg.sender);\\n        emit LogCancelWithdrawRequest(msg.sender, cancelAmount, cancelAmountInUno);\\n    }\\n\\n    function policyClaim(address _to, uint256 _amount) external onlyClaimAssessor isStartTime nonReentrant {\\n        require(_to != address(0), \\\"UnoRe: zero address\\\");\\n        require(_amount > 0, \\\"UnoRe: zero amount\\\");\\n        uint256 realClaimAmount = IRiskPool(riskPool).policyClaim(_to, _amount);\\n        emit PolicyClaim(_to, realClaimAmount);\\n    }\\n\\n    function getStakedAmountPerUser(address _to) external view returns (uint256 unoAmount, uint256 lpAmount) {\\n        lpAmount = userInfo[_to].amount;\\n        uint256 lpPriceUno = IRiskPool(riskPool).lpPriceUno();\\n        unoAmount = (lpAmount * lpPriceUno) / 1e18;\\n    }\\n\\n    /**\\n     * @dev get withdraw request amount in pending per user in UNO\\n     */\\n    function getWithdrawRequestPerUser(address _user)\\n        external\\n        view\\n        returns (\\n            uint256 pendingAmount,\\n            uint256 pendingAmountInUno,\\n            uint256 originUnoAmount,\\n            uint256 requestTime\\n        )\\n    {\\n        uint256 lpPriceUno = IRiskPool(riskPool).lpPriceUno();\\n        (pendingAmount, requestTime, originUnoAmount) = IRiskPool(riskPool).getWithdrawRequest(_user);\\n        pendingAmountInUno = (pendingAmount * lpPriceUno) / 1e18;\\n    }\\n\\n    /**\\n     * @dev get total withdraw request amount in pending for the risk pool in UNO\\n     */\\n    function getTotalWithdrawPendingAmount() external view returns (uint256) {\\n        return IRiskPool(riskPool).getTotalWithdrawRequestAmount();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMigration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\ninterface IMigration {\\n    function onMigration(\\n        address who_,\\n        uint256 amount_,\\n        bytes memory data_\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRiskPoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.0;\\n\\ninterface IRiskPoolFactory {\\n    function newRiskPool(\\n        string calldata _name,\\n        string calldata _symbol,\\n        address _pool,\\n        address _currency\\n    ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRewarderFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.0;\\n\\ninterface IRewarderFactory {\\n    function newRewarder(\\n        address _operator,\\n        address _currency,\\n        address _pool\\n    ) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISingleSidedReinsurancePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.0;\\n\\ninterface ISingleSidedReinsurancePool {\\n    function updatePool() external;\\n\\n    function enterInPool(uint256 _amount) external;\\n\\n    function leaveFromPoolInPending(uint256 _amount) external;\\n\\n    function leaveFromPending() external;\\n\\n    function harvest(address _to) external;\\n\\n    function lpTransfer(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) external;\\n\\n    function riskPool() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISyntheticSSRPFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.0;\\n\\ninterface ISyntheticSSRPFactory {\\n    function newSyntheticSSRP(address _owner, address _lpToken) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRewarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\ninterface IRewarder {\\n    function currency() external view returns (address);\\n\\n    function onReward(address to, uint256 unoAmount) external payable returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRiskPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.0;\\n\\ninterface IRiskPool {\\n    function enter(address _from, uint256 _amount) external;\\n\\n    function leaveFromPoolInPending(address _to, uint256 _amount) external;\\n\\n    function leaveFromPending(address _to) external returns (uint256, uint256);\\n\\n    function cancelWithrawRequest(address _to) external returns (uint256, uint256);\\n\\n    function policyClaim(address _to, uint256 _amount) external returns (uint256 realClaimAmount);\\n\\n    function migrateLP(\\n        address _to,\\n        address _migrateTo,\\n        bool _isUnLocked\\n    ) external returns (uint256);\\n\\n    function setMinLPCapital(uint256 _minLPCapital) external;\\n\\n    function currency() external view returns (address);\\n\\n    function getTotalWithdrawRequestAmount() external view returns (uint256);\\n\\n    function getWithdrawRequest(address _to)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function lpPriceUno() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.0;\\n\\n// from Uniswap TransferHelper library\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper::safeApprove: approve failed\\\");\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper::safeTransfer: transfer failed\\\");\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TransferHelper::transferFrom: transferFrom failed\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\\"TransferHelper::safeTransferETH: ETH transfer failed\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_claimAssessor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_requestAmount\",\"type\":\"uint256\"}],\"name\":\"LeftPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cancelAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cancelAmountInUno\",\"type\":\"uint256\"}],\"name\":\"LogCancelWithdrawRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_SSRP\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_rewarder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"}],\"name\":\"LogCreateRewarder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_SSRP\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_syntheticSSRP\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"}],\"name\":\"LogCreateSyntheticSSRP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_withdrawLpAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_withdrawUnoAmount\",\"type\":\"uint256\"}],\"name\":\"LogLeaveFromPendingSSRP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"LogLpTransferInSSRP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_migrateTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_migratedAmount\",\"type\":\"uint256\"}],\"name\":\"LogMigrate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"_lastRewardBlock\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_lpSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_accUnoPerShare\",\"type\":\"uint256\"}],\"name\":\"LogUpdatePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_claimAmount\",\"type\":\"uint256\"}],\"name\":\"PolicyClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_SSRP\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"RiskPoolCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"StakedInPool\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ACC_UNO_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOCK_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKING_START_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelWithdrawRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAssessor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"}],\"name\":\"createRewarder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardMultiplier\",\"type\":\"uint256\"}],\"name\":\"createRiskPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"createSyntheticSSRP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"enterInPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"getStakedAmountPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unoAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalWithdrawPendingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getWithdrawRequestPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pendingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pendingAmountInUno\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originUnoAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leaveFromPending\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"leaveFromPoolInPending\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"lpTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrateTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"pendingUno\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"policyClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"lastRewardBlock\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"accUnoPerShare\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"unoMultiplierPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"riskPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_claimAssessor\",\"type\":\"address\"}],\"name\":\"setClaimAssessor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockTime\",\"type\":\"uint256\"}],\"name\":\"setLockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_migrateTo\",\"type\":\"address\"}],\"name\":\"setMigrateTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minLPCapital\",\"type\":\"uint256\"}],\"name\":\"setMinLPCapital\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardMultiplier\",\"type\":\"uint256\"}],\"name\":\"setRewardMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"setStakingStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"syntheticSSRP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastWithdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SingleSidedReinsurancePool","CompilerVersion":"v0.8.0+commit.c7dfd78e","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"0000000000000000000000008c3d5c9538256dab8eb4b197370574340fe3254f0000000000000000000000008c3d5c9538256dab8eb4b197370574340fe3254f","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}