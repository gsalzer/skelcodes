{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/v1/Converter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"../../interfaces/punks/ICryptoPunks.sol\\\";\\nimport \\\"../../interfaces/punks/IWrappedPunk.sol\\\";\\nimport \\\"../../interfaces/mooncats/IMoonCatsWrapped.sol\\\";\\nimport \\\"../../interfaces/mooncats/IMoonCatsRescue.sol\\\";\\nimport \\\"../../interfaces/mooncats/IMoonCatAcclimator.sol\\\";\\nimport \\\"../../interfaces/markets/tokens/IERC721.sol\\\";\\nimport \\\"../../interfaces/markets/tokens/IERC20.sol\\\";\\nimport \\\"../../interfaces/weth/IWETH.sol\\\";\\n\\nlibrary Converter {\\n\\n    struct MoonCatDetails {\\n        bytes5[] catIds;\\n        uint256[] oldTokenIds;\\n        uint256[] rescueOrders;\\n    }\\n\\n    /**\\n    * @dev converts uint256 to a bytes(32) object\\n    */\\n    function _uintToBytes(uint256 x) internal pure returns (bytes memory b) {\\n        b = new bytes(32);\\n        assembly {\\n            mstore(add(b, 32), x)\\n        }\\n    }\\n\\n    /**\\n    * @dev converts address to a bytes(32) object\\n    */\\n    function _addressToBytes(address a) internal pure returns (bytes memory) {\\n        return abi.encodePacked(a);\\n    }\\n\\n    function mooncatToAcclimated(MoonCatDetails memory moonCatDetails) external {\\n        for (uint256 i = 0; i < moonCatDetails.catIds.length; i++) {\\n            // make an adoption offer to the Acclimated​MoonCats contract\\n            IMoonCatsRescue(0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6).makeAdoptionOfferToAddress(\\n                moonCatDetails.catIds[i], \\n                0, \\n                0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69\\n            );\\n        }\\n        // mint Acclimated​MoonCats\\n        IMoonCatAcclimator(0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69).batchWrap(moonCatDetails.rescueOrders);\\n    }\\n\\n    function wrappedToAcclimated(MoonCatDetails memory moonCatDetails) external {\\n        for (uint256 i = 0; i < moonCatDetails.oldTokenIds.length; i++) {\\n            // transfer the token to Acclimated​MoonCats to mint\\n            IERC721(0x7C40c393DC0f283F318791d746d894DdD3693572).safeTransferFrom(\\n                address(this),\\n                0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69,\\n                moonCatDetails.oldTokenIds[i],\\n                abi.encodePacked(\\n                    _uintToBytes(moonCatDetails.rescueOrders[i]),\\n                    _addressToBytes(address(this))\\n                )\\n            );\\n        }\\n    }\\n\\n    function mooncatToWrapped(MoonCatDetails memory moonCatDetails) external {\\n        for (uint256 i = 0; i < moonCatDetails.catIds.length; i++) {\\n            // make an adoption offer to the Acclimated​MoonCats contract               \\n            IMoonCatsRescue(0x60cd862c9C687A9dE49aecdC3A99b74A4fc54aB6).makeAdoptionOfferToAddress(\\n                moonCatDetails.catIds[i], \\n                0, \\n                0x7C40c393DC0f283F318791d746d894DdD3693572\\n            );\\n            // mint Wrapped Mooncat\\n            IMoonCatsWrapped(0x7C40c393DC0f283F318791d746d894DdD3693572).wrap(moonCatDetails.catIds[i]);\\n        }\\n    }\\n\\n    function acclimatedToWrapped(MoonCatDetails memory moonCatDetails) external {\\n        // unwrap Acclimated​MoonCats to get Mooncats\\n        IMoonCatAcclimator(0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69).batchUnwrap(moonCatDetails.rescueOrders);\\n        // Convert Mooncats to Wrapped Mooncats\\n        for (uint256 i = 0; i < moonCatDetails.rescueOrders.length; i++) {\\n            // make an adoption offer to the Acclimated​MoonCats contract               \\n            IMoonCatsRescue(0xc3f733ca98E0daD0386979Eb96fb1722A1A05E69).makeAdoptionOfferToAddress(\\n                moonCatDetails.catIds[i], \\n                0, \\n                0x7C40c393DC0f283F318791d746d894DdD3693572\\n            );\\n            // mint Wrapped Mooncat\\n            IMoonCatsWrapped(0x7C40c393DC0f283F318791d746d894DdD3693572).wrap(moonCatDetails.catIds[i]);\\n        }\\n    }\\n\\n    function cryptopunkToWrapped(address punkProxy, uint256[] memory tokenIds) external {\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            // transfer the CryptoPunk to the userProxy\\n            ICryptoPunks(0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB).transferPunk(punkProxy, tokenIds[i]);\\n            // mint Wrapped CryptoPunk\\n            IWrappedPunk(0xb7F7F6C52F2e2fdb1963Eab30438024864c313F6).mint(tokenIds[i]);\\n        }\\n    }\\n\\n    function wrappedToCryptopunk(uint256[] memory tokenIds) external {\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            IWrappedPunk(0xb7F7F6C52F2e2fdb1963Eab30438024864c313F6).burn(tokenIds[i]);\\n        }\\n    }\\n\\n    function ethToWeth(uint256 amount) external {\\n        bytes memory _data = abi.encodeWithSelector(IWETH.deposit.selector);\\n        (bool success, ) = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).call{value:amount}(_data);\\n        if (!success) {\\n            // Copy revert reason from call\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    function wethToEth(uint256 amount) external {\\n        IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2).withdraw(amount);\\n    }\\n}\"\r\n    },\r\n    \"interfaces/punks/ICryptoPunks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface ICryptoPunks {\\n    function punkIndexToAddress(uint index) external view returns(address owner);\\n    function offerPunkForSaleToAddress(uint punkIndex, uint minSalePriceInWei, address toAddress) external;\\n    function buyPunk(uint punkIndex) external payable;\\n    function transferPunk(address to, uint punkIndex) external;\\n}\"\r\n    },\r\n    \"interfaces/punks/IWrappedPunk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface IWrappedPunk {\\n    /**\\n     * @dev Mints a wrapped punk\\n     */\\n    function mint(uint256 punkIndex) external;\\n\\n    /**\\n     * @dev Burns a specific wrapped punk\\n     */\\n    function burn(uint256 punkIndex) external;\\n    \\n    /**\\n     * @dev Registers proxy\\n     */\\n    function registerProxy() external;\\n\\n    /**\\n     * @dev Gets proxy address\\n     */\\n    function proxyInfo(address user) external view returns (address);\\n}\"\r\n    },\r\n    \"interfaces/mooncats/IMoonCatsWrapped.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface IMoonCatsWrapped {\\n    function wrap(bytes5 catId) external;\\n    function _catIDToTokenID(bytes5 catId) external view returns(uint256);\\n}\"\r\n    },\r\n    \"interfaces/mooncats/IMoonCatsRescue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface IMoonCatsRescue {\\n    function acceptAdoptionOffer(bytes5 catId) payable external;\\n    function makeAdoptionOfferToAddress(bytes5 catId, uint price, address to) external;\\n    function giveCat(bytes5 catId, address to) external;\\n    function catOwners(bytes5 catId) external view returns(address);\\n    function rescueOrder(uint256 rescueIndex) external view returns(bytes5 catId);\\n}\"\r\n    },\r\n    \"interfaces/mooncats/IMoonCatAcclimator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface IMoonCatAcclimator {\\n    /**\\n     * @dev rewrap several MoonCats from the old wrapper at once\\n     * Owner needs to call setApprovalForAll in old wrapper first.\\n     * @param _rescueOrders an array of MoonCats, identified by rescue order, to rewrap\\n     * @param _oldTokenIds an array holding the corresponding token ID\\n     *        in the old wrapper for each MoonCat to be rewrapped\\n     */\\n    function batchReWrap(\\n        uint256[] memory _rescueOrders,\\n        uint256[] memory _oldTokenIds\\n    ) external;\\n\\n    /**\\n     * @dev Take a list of unwrapped MoonCat rescue orders and wrap them.\\n     * @param _rescueOrders an array of MoonCats, identified by rescue order, to rewrap\\n     */\\n    function batchWrap(uint256[] memory _rescueOrders) external;\\n\\n    /**\\n     * @dev Take a list of MoonCats wrapped in this contract and unwrap them.\\n     * @param _rescueOrders an array of MoonCats, identified by rescue order, to unwrap\\n     */\\n    function batchUnwrap(uint256[] memory _rescueOrders) external;\\n}\\n\\n\"\r\n    },\r\n    \"interfaces/markets/tokens/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface IERC721 {\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n    ///  THEY MAY BE PERMANENTLY LOST\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\n    ///  `_tokenId` is not a valid NFT.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;\\n    \\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n    \\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\"\r\n    },\r\n    \"interfaces/markets/tokens/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface IERC20 {\\n    /**\\n        * @dev Returns the amount of tokens owned by `account`.\\n        */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n        * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n        *\\n        * Returns a boolean value indicating whether the operation succeeded.\\n        *\\n        * Emits a {Transfer} event.\\n        */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n}\"\r\n    },\r\n    \"interfaces/weth/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.4;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function withdraw(uint wad) external;\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[]","ContractName":"Converter","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}