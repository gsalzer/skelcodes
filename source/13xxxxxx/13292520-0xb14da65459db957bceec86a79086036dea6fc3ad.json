{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/lib/SafeMath.sol\r\n\r\n/*\r\n\r\n    Copyright 2020 DODO ZOO.\r\n    SPDX-License-Identifier: Apache-2.0\r\n\r\n*/\r\n\r\npragma solidity 0.6.9;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"MUL_ERROR\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"DIVIDING_ERROR\");\r\n        return a / b;\r\n    }\r\n\r\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 quotient = div(a, b);\r\n        uint256 remainder = a - quotient * b;\r\n        if (remainder > 0) {\r\n            return quotient + 1;\r\n        } else {\r\n            return quotient;\r\n        }\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SUB_ERROR\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"ADD_ERROR\");\r\n        return c;\r\n    }\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        uint256 z = x / 2 + 1;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/intf/IERC20.sol\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/lib/SafeERC20.sol\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/lib/DecimalMath.sol\r\n\r\n\r\n\r\n/**\r\n * @title DecimalMath\r\n * @author DODO Breeder\r\n *\r\n * @notice Functions for fixed point number with 18 decimals\r\n */\r\nlibrary DecimalMath {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 internal constant ONE = 10**18;\r\n    uint256 internal constant ONE2 = 10**36;\r\n\r\n    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d) / (10**18);\r\n    }\r\n\r\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(d).divCeil(10**18);\r\n    }\r\n\r\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).div(d);\r\n    }\r\n\r\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\r\n        return target.mul(10**18).divCeil(d);\r\n    }\r\n\r\n    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).div(target);\r\n    }\r\n\r\n    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\r\n        return uint256(10**36).divCeil(target);\r\n    }\r\n}\r\n\r\n// File: contracts/DODOVendingMachine/intf/IDVM.sol\r\n\r\n\r\ninterface IDVM {\r\n    function init(\r\n        address maintainer,\r\n        address baseTokenAddress,\r\n        address quoteTokenAddress,\r\n        uint256 lpFeeRate,\r\n        address mtFeeRateModel,\r\n        uint256 i,\r\n        uint256 k,\r\n        bool isOpenTWAP\r\n    ) external;\r\n\r\n    function _BASE_TOKEN_() external returns (address);\r\n\r\n    function _QUOTE_TOKEN_() external returns (address);\r\n\r\n    function _MT_FEE_RATE_MODEL_() external returns (address);\r\n\r\n    function getVaultReserve() external returns (uint256 baseReserve, uint256 quoteReserve);\r\n\r\n    function sellBase(address to) external returns (uint256);\r\n\r\n    function sellQuote(address to) external returns (uint256);\r\n\r\n    function buyShares(address to) external returns (uint256,uint256,uint256);\r\n\r\n    function addressToShortString(address _addr) external pure returns (string memory);\r\n\r\n    function getMidPrice() external view returns (uint256 midPrice);\r\n\r\n    function sellShares(\r\n        uint256 shareAmount,\r\n        address to,\r\n        uint256 baseMinAmount,\r\n        uint256 quoteMinAmount,\r\n        bytes calldata data,\r\n        uint256 deadline\r\n    ) external  returns (uint256 baseAmount, uint256 quoteAmount);\r\n\r\n}\r\n\r\n// File: contracts/intf/IDODOCallee.sol\r\n\r\n\r\ninterface IDODOCallee {\r\n    function DVMSellShareCall(\r\n        address sender,\r\n        uint256 burnShareAmount,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function DVMFlashLoanCall(\r\n        address sender,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function DPPFlashLoanCall(\r\n        address sender,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function DSPFlashLoanCall(\r\n        address sender,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function CPCancelCall(\r\n        address sender,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n\tfunction CPClaimBidCall(\r\n        address sender,\r\n        uint256 baseAmount,\r\n        uint256 quoteAmount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function NFTRedeemCall(\r\n        address payable assetTo,\r\n        uint256 quoteAmount,\r\n        bytes calldata\r\n    ) external;\r\n}\r\n\r\n// File: contracts/external/ERC20/InitializableFragERC20.sol\r\n\r\n\r\ncontract InitializableFragERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint256 public totalSupply;\r\n\r\n    bool public initialized;\r\n\r\n    mapping(address => uint256) internal balances;\r\n    mapping(address => mapping(address => uint256)) internal allowed;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    function init(\r\n        address _creator,\r\n        uint256 _totalSupply,\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) public {\r\n        require(!initialized, \"TOKEN_INITIALIZED\");\r\n        initialized = true;\r\n        totalSupply = _totalSupply;\r\n        balances[_creator] = _totalSupply;\r\n        name = _name;\r\n        symbol = _symbol;\r\n        emit Transfer(address(0), _creator, _totalSupply);\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address owner) public view returns (uint256 balance) {\r\n        return balances[owner];\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public returns (bool) {\r\n        require(to != address(0), \"TO_ADDRESS_IS_EMPTY\");\r\n        require(amount <= balances[from], \"BALANCE_NOT_ENOUGH\");\r\n        require(amount <= allowed[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\r\n\r\n        balances[from] = balances[from].sub(amount);\r\n        balances[to] = balances[to].add(amount);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\r\n        emit Transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        allowed[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return allowed[owner][spender];\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"FROM_ADDRESS_IS_EMPTY\");\r\n        require(recipient != address(0), \"TO_ADDRESS_IS_EMPTY\");\r\n        require(amount <= balances[sender], \"BALANCE_NOT_ENOUGH\");\r\n\r\n        balances[sender] = balances[sender].sub(amount);\r\n        balances[recipient] = balances[recipient].add(amount);\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/CollateralVault/intf/ICollateralVault.sol\r\n\r\n\r\n\r\ninterface ICollateralVault {\r\n    function _OWNER_() external returns (address);\r\n\r\n    function init(address owner, string memory name, string memory baseURI) external;\r\n\r\n    function directTransferOwnership(address newOwner) external;\r\n}\r\n\r\n// File: contracts/GeneralizedFragment/impl/Fragment.sol\r\n\r\n\r\n\r\ninterface IBuyoutModel {\r\n  function getBuyoutStatus(address fragAddr, address user) external view returns (int);\r\n}\r\n\r\ncontract Fragment is InitializableFragERC20 {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    // ============ Storage ============\r\n    \r\n    bool public _IS_BUYOUT_;\r\n    uint256 public _BUYOUT_TIMESTAMP_;\r\n    uint256 public _BUYOUT_PRICE_;\r\n    uint256 public _DISTRIBUTION_RATIO_;\r\n\r\n    address public _COLLATERAL_VAULT_;\r\n    address public _VAULT_PRE_OWNER_;\r\n    address public _QUOTE_;\r\n    address public _DVM_;\r\n    address public _DEFAULT_MAINTAINER_;\r\n    address public _BUYOUT_MODEL_;\r\n\r\n    bool internal _FRAG_INITIALIZED_;\r\n\r\n    // ============ Event ============\r\n    event RemoveNftToken(address nftContract, uint256 tokenId, uint256 amount);\r\n    event AddNftToken(address nftContract, uint256 tokenId, uint256 amount);\r\n    event InitInfo(address vault, string name, string baseURI);\r\n    event CreateFragment();\r\n    event Buyout(address newOwner);\r\n    event Redeem(address sender, uint256 baseAmount, uint256 quoteAmount);\r\n\r\n\r\n    function init(\r\n      address dvm, \r\n      address vaultPreOwner,\r\n      address collateralVault,\r\n      uint256 _totalSupply, \r\n      uint256 ownerRatio,\r\n      uint256 buyoutTimestamp,\r\n      address defaultMaintainer,\r\n      address buyoutModel,\r\n      uint256 distributionRatio,\r\n      string memory _symbol\r\n    ) external {\r\n        require(!_FRAG_INITIALIZED_, \"DODOFragment: ALREADY_INITIALIZED\");\r\n        _FRAG_INITIALIZED_ = true;\r\n\r\n        // init local variables\r\n        _DVM_ = dvm;\r\n        _QUOTE_ = IDVM(_DVM_)._QUOTE_TOKEN_();\r\n        _VAULT_PRE_OWNER_ = vaultPreOwner;\r\n        _COLLATERAL_VAULT_ = collateralVault;\r\n        _BUYOUT_TIMESTAMP_ = buyoutTimestamp;\r\n        _DEFAULT_MAINTAINER_ = defaultMaintainer;\r\n        _BUYOUT_MODEL_ = buyoutModel;\r\n        _DISTRIBUTION_RATIO_ = distributionRatio;\r\n\r\n        // init FRAG meta data\r\n        name = string(abi.encodePacked(\"DODO_FRAG_\", _symbol));\r\n        // symbol = string(abi.encodePacked(\"d_\", _symbol));\r\n        symbol = _symbol;\r\n        super.init(address(this), _totalSupply, name, symbol);\r\n\r\n        // init FRAG distribution\r\n        uint256 vaultPreOwnerBalance = DecimalMath.mulFloor(_totalSupply, ownerRatio);\r\n        uint256 distributionBalance = DecimalMath.mulFloor(vaultPreOwnerBalance, distributionRatio);\r\n        \r\n        if(distributionBalance > 0) _transfer(address(this), _DEFAULT_MAINTAINER_, distributionBalance);\r\n        _transfer(address(this), _VAULT_PRE_OWNER_, vaultPreOwnerBalance.sub(distributionBalance));\r\n        _transfer(address(this), _DVM_, _totalSupply.sub(vaultPreOwnerBalance));\r\n\r\n        // init DVM liquidity\r\n        IDVM(_DVM_).buyShares(address(this));\r\n    }\r\n\r\n\r\n    function buyout(address newVaultOwner) external {\r\n        require(_BUYOUT_TIMESTAMP_ != 0, \"DODOFragment: NOT_SUPPORT_BUYOUT\");\r\n        require(block.timestamp > _BUYOUT_TIMESTAMP_, \"DODOFragment: BUYOUT_NOT_START\");\r\n        require(!_IS_BUYOUT_, \"DODOFragment: ALREADY_BUYOUT\");\r\n\r\n        int buyoutFee = IBuyoutModel(_BUYOUT_MODEL_).getBuyoutStatus(address(this), newVaultOwner);\r\n        require(buyoutFee != -1, \"DODOFragment: USER_UNABLE_BUYOUT\");\r\n\r\n        _IS_BUYOUT_ = true;\r\n      \r\n        _BUYOUT_PRICE_ = IDVM(_DVM_).getMidPrice();\r\n        uint256 requireQuote = DecimalMath.mulCeil(_BUYOUT_PRICE_, totalSupply);\r\n        uint256 payQuote = IERC20(_QUOTE_).balanceOf(address(this));\r\n        require(payQuote >= requireQuote, \"DODOFragment: QUOTE_NOT_ENOUGH\");\r\n\r\n        IDVM(_DVM_).sellShares(\r\n          IERC20(_DVM_).balanceOf(address(this)),\r\n          address(this),\r\n          0,\r\n          0,\r\n          \"\",\r\n          uint256(-1)\r\n        ); \r\n\r\n        uint256 redeemFrag = totalSupply.sub(balances[address(this)]).sub(balances[_VAULT_PRE_OWNER_]);\r\n        uint256 ownerQuoteWithoutFee = IERC20(_QUOTE_).balanceOf(address(this)).sub(DecimalMath.mulCeil(_BUYOUT_PRICE_, redeemFrag));\r\n        _clearBalance(address(this));\r\n        _clearBalance(_VAULT_PRE_OWNER_);\r\n\r\n        uint256 buyoutFeeAmount =  DecimalMath.mulFloor(ownerQuoteWithoutFee, uint256(buyoutFee));\r\n      \r\n        IERC20(_QUOTE_).safeTransfer(_DEFAULT_MAINTAINER_, buyoutFeeAmount);\r\n        IERC20(_QUOTE_).safeTransfer(_VAULT_PRE_OWNER_, ownerQuoteWithoutFee.sub(buyoutFeeAmount));\r\n\r\n        ICollateralVault(_COLLATERAL_VAULT_).directTransferOwnership(newVaultOwner);\r\n\r\n        emit Buyout(newVaultOwner);\r\n    }\r\n\r\n\r\n    function redeem(address to, bytes calldata data) external {\r\n        require(_IS_BUYOUT_, \"DODOFragment: NEED_BUYOUT\");\r\n\r\n        uint256 baseAmount = balances[msg.sender];\r\n        uint256 quoteAmount = DecimalMath.mulFloor(_BUYOUT_PRICE_, baseAmount);\r\n        _clearBalance(msg.sender);\r\n        IERC20(_QUOTE_).safeTransfer(to, quoteAmount);\r\n\r\n        if (data.length > 0) {\r\n          IDODOCallee(to).NFTRedeemCall(\r\n            msg.sender,\r\n            quoteAmount,\r\n            data\r\n          );\r\n        }\r\n\r\n        emit Redeem(msg.sender, baseAmount, quoteAmount);\r\n    }\r\n\r\n    function getBuyoutRequirement() external view returns (uint256 requireQuote){\r\n        require(_BUYOUT_TIMESTAMP_ != 0, \"NOT SUPPORT BUYOUT\");\r\n        require(!_IS_BUYOUT_, \"ALREADY BUYOUT\");\r\n        uint256 price = IDVM(_DVM_).getMidPrice();\r\n        requireQuote = DecimalMath.mulCeil(price, totalSupply);\r\n    }\r\n\r\n    function _clearBalance(address account) internal {\r\n        uint256 clearBalance = balances[account];\r\n        balances[account] = 0;\r\n        balances[address(0)] = balances[address(0)].add(clearBalance);\r\n        emit Transfer(account, address(0), clearBalance);\r\n    }\r\n}","ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddNftToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"Buyout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CreateFragment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"InitInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteAmount\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RemoveNftToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_BUYOUT_MODEL_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_BUYOUT_PRICE_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_BUYOUT_TIMESTAMP_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_COLLATERAL_VAULT_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DEFAULT_MAINTAINER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DISTRIBUTION_RATIO_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_DVM_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_IS_BUYOUT_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_QUOTE_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_VAULT_PRE_OWNER_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newVaultOwner\",\"type\":\"address\"}],\"name\":\"buyout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBuyoutRequirement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"requireQuote\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dvm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultPreOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralVault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ownerRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyoutTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"defaultMaintainer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyoutModel\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"distributionRatio\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Fragment","CompilerVersion":"v0.6.9+commit.3e3065ac","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"Apache-2.0","Proxy":"0","Implementation":"","SwarmSource":"ipfs://3ad3618af4c271baf733ddcdcf89812b90f71f40b59912af10693e1b6089f88c"}]}