{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PartyBuy.sol\": {\r\n      \"content\": \"/*\\n                   ___                    _       _  _    ___     ___     ___\\n                  | _ \\\\  __ _      _ _   | |_    | || |  |   \\\\   /   \\\\   / _ \\\\\\n   ~~~~ ____      |  _/ / _` |    | '_|  |  _|    \\\\_, |  | |) |  | - |  | (_) |\\n  Y_,___|[]|     _|_|_  \\\\__,_|   _|_|_   _\\\\__|   _|__/   |___/   |_|_|   \\\\___/\\n {|_|_|_|[]|_,__| \\\"\\\"\\\" |_|\\\"\\\"\\\"\\\"\\\"|_|\\\"\\\"\\\"\\\"\\\"|_|\\\"\\\"\\\"\\\"\\\"|_| \\\"\\\"\\\"\\\"|_|\\\"\\\"\\\"\\\"\\\"|_|\\\"\\\"\\\"\\\"\\\"|_|\\\"\\\"\\\"\\\"\\\"|\\n//oo---OO=OO\\\".  `-0-0-'\\\"`-0-0-'\\\"`-0-0-'\\\"`-0-0-'\\\"`-0-0-'\\\"`-0-0-'\\\"`-0-0-'\\\"`-0-0-'\\n\\nAnna Carroll for PartyDAO\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\n// ============ External Imports: External Contracts & Contract Interfaces ============\\nimport {Party} from \\\"./Party.sol\\\";\\nimport {Structs} from \\\"./Structs.sol\\\";\\nimport {IAllowList} from \\\"./IAllowList.sol\\\";\\n\\ncontract PartyBuy is Party {\\n    // partyStatus Transitions:\\n    //   (1) PartyStatus.ACTIVE on deploy\\n    //   (2) PartyStatus.WON after successful buy()\\n    //   (3) PartyStatus.LOST after successful expire()\\n\\n    // ============ Internal Constants ============\\n\\n    // PartyBuy version 1\\n    uint16 public constant VERSION = 1;\\n\\n    // ============ Immutables ============\\n\\n    IAllowList public immutable allowList;\\n\\n    // ============ Public Not-Mutated Storage ============\\n\\n    // the timestamp at which the Party is no longer active\\n    uint256 public expiresAt;\\n    // the maximum price that the party is willing to\\n    // spend on the token\\n    // NOTE: the party can accept *UP TO* 102.5% of maxPrice in total,\\n    // and will not accept more contributions after this\\n    uint256 public maxPrice;\\n\\n    // ============ Events ============\\n\\n    // emitted when the token is successfully bought\\n    event Bought(address triggeredBy, address targetAddress, uint256 ethSpent, uint256 ethFeePaid, uint256 totalContributed);\\n\\n    // emitted if the Party fails to buy the token before expiresAt\\n    // and someone expires the Party so folks can reclaim ETH\\n    event Expired(address triggeredBy);\\n\\n    // ======== Constructor =========\\n\\n    constructor(\\n        address _partyDAOMultisig,\\n        address _tokenVaultFactory,\\n        address _weth,\\n        address _allowList\\n    ) Party(_partyDAOMultisig, _tokenVaultFactory, _weth) {\\n        allowList = IAllowList(_allowList);\\n    }\\n\\n    // ======== Initializer =========\\n\\n    function initialize(\\n        address _nftContract,\\n        uint256 _tokenId,\\n        uint256 _maxPrice,\\n        uint256 _secondsToTimeout,\\n        Structs.AddressAndAmount calldata _split,\\n        Structs.AddressAndAmount calldata _tokenGate,\\n        string memory _name,\\n        string memory _symbol\\n    ) external initializer {\\n        // validate maxPrice\\n        require(_maxPrice > 0, \\\"PartyBuy::initialize: must set price higher than 0\\\");\\n        // initialize & validate shared Party variables\\n        __Party_init(_nftContract, _tokenId, _split, _tokenGate, _name, _symbol);\\n        // set PartyBuy-specific state variables\\n        expiresAt = block.timestamp + _secondsToTimeout;\\n        maxPrice = _maxPrice;\\n    }\\n\\n    // ======== External: Contribute =========\\n\\n    /**\\n     * @notice Contribute to the Party's treasury\\n     * while the Party is still active\\n     * @dev Emits a Contributed event upon success; callable by anyone\\n     */\\n    function contribute() external payable nonReentrant {\\n        // require that the new total contributed is not greater than\\n        // the maximum amount the Party is willing to spend\\n        require(totalContributedToParty + msg.value <= getMaximumContributions(), \\\"PartyBuy::contribute: cannot contribute more than max\\\");\\n        // continue with shared _contribute flow\\n        _contribute();\\n    }\\n\\n    // ======== External: Buy =========\\n\\n    /**\\n     * @notice Buy the token by calling targetContract with calldata supplying value\\n     * @dev Emits a Bought event upon success; reverts otherwise. callable by anyone\\n     */\\n    function buy(uint256 _value, address _targetContract, bytes calldata _calldata) external nonReentrant {\\n        require(\\n            partyStatus == PartyStatus.ACTIVE,\\n            \\\"PartyBuy::buy: party not active\\\"\\n        );\\n        // ensure the target contract is on allow list\\n        require(allowList.allowed(_targetContract), \\\"PartyBuy::buy: targetContract not on AllowList\\\");\\n        // check that value is not zero (else, token will be burned in TokenVault)\\n        require(_value > 0, \\\"PartyBuy::buy: can't spend zero\\\");\\n        // check that value is not more than the maximum price set at deploy time\\n        require(_value <= maxPrice, \\\"PartyBuy::buy: can't spend over max price\\\");\\n        // check that value is not more than\\n        // the maximum amount the party can spend while paying ETH fee\\n        require(_value <= getMaximumSpend(), \\\"PartyBuy::buy: insuffucient funds to buy token plus fee\\\");\\n        // require that the NFT is NOT owned by the Party\\n        require(_getOwner() != address(this), \\\"PartyBuy::buy: own token before call\\\");\\n        // execute the calldata on the target contract\\n        (bool _success, bytes memory _returnData) = address(_targetContract).call{value: _value}(_calldata);\\n        // require that the external call succeeded\\n        require(_success, string(_returnData));\\n        // require that the NFT is owned by the Party\\n        require(_getOwner() == address(this), \\\"PartyBuy::buy: failed to buy token\\\");\\n        // set partyStatus to WON\\n        partyStatus = PartyStatus.WON;\\n        // record totalSpent,\\n        // send ETH fees to PartyDAO,\\n        // fractionalize the Token\\n        // send Token fees to PartyDAO & split proceeds to split recipient\\n        uint256 _ethFee = _closeSuccessfulParty(_value);\\n        // emit Bought event\\n        emit Bought(msg.sender, _targetContract, _value, _ethFee, totalContributedToParty);\\n    }\\n\\n    // ======== External: Fail =========\\n\\n    /**\\n     * @notice If the token couldn't be successfully bought\\n      * within the specified period of time, move to FAILED state\\n      * so users can reclaim their funds.\\n     * @dev Emits a Expired event upon finishing; reverts otherwise.\\n     * callable by anyone after expiresAt\\n     */\\n    function expire() external nonReentrant {\\n        require(\\n            partyStatus == PartyStatus.ACTIVE,\\n            \\\"PartyBuy::expire: party not active\\\"\\n        );\\n        require(expiresAt <= block.timestamp, \\\"PartyBuy::expire: party has not timed out\\\");\\n        // set partyStatus to LOST\\n        partyStatus = PartyStatus.LOST;\\n        // emit Expired event\\n        emit Expired(msg.sender);\\n    }\\n\\n    // ============ Internal ============\\n\\n    /**\\n    * @notice Get the maximum amount that can be contributed to the Party\\n    * @return _maxContributions the maximum amount that can be contributed to the party\\n    */\\n    function getMaximumContributions() public view returns (uint256 _maxContributions) {\\n        uint256 _price = maxPrice;\\n        _maxContributions = _price + _getEthFee(_price);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Party.sol\": {\r\n      \"content\": \"/*\\n__/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____________________________________________________________/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\________/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__________/\\\\\\\\\\\\\\\\\\\\______\\n _\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\__________________________________________________________\\\\/\\\\\\\\\\\\////////\\\\\\\\\\\\____/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\______/\\\\\\\\\\\\///\\\\\\\\\\\\____\\n  _\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\__________________________________/\\\\\\\\\\\\_________/\\\\\\\\\\\\__/\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\______\\\\//\\\\\\\\\\\\__/\\\\\\\\\\\\/////////\\\\\\\\\\\\___/\\\\\\\\\\\\/__\\\\///\\\\\\\\\\\\__\\n   _\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/___/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_____/\\\\\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\___/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\___\\\\//\\\\\\\\\\\\/\\\\\\\\\\\\__\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\__/\\\\\\\\\\\\______\\\\//\\\\\\\\\\\\_\\n    _\\\\/\\\\\\\\\\\\/////////____\\\\////////\\\\\\\\\\\\___\\\\/\\\\\\\\\\\\/////\\\\\\\\\\\\_\\\\////\\\\\\\\\\\\////_____\\\\//\\\\\\\\\\\\\\\\\\\\___\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\n     _\\\\/\\\\\\\\\\\\_______________/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\__\\\\/\\\\\\\\\\\\___\\\\///_____\\\\/\\\\\\\\\\\\__________\\\\//\\\\\\\\\\\\____\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\_\\\\/\\\\\\\\\\\\/////////\\\\\\\\\\\\_\\\\//\\\\\\\\\\\\______/\\\\\\\\\\\\__\\n      _\\\\/\\\\\\\\\\\\______________/\\\\\\\\\\\\/////\\\\\\\\\\\\__\\\\/\\\\\\\\\\\\____________\\\\/\\\\\\\\\\\\_/\\\\\\\\___/\\\\\\\\_/\\\\\\\\\\\\_____\\\\/\\\\\\\\\\\\_______/\\\\\\\\\\\\__\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\__\\\\///\\\\\\\\\\\\__/\\\\\\\\\\\\____\\n       _\\\\/\\\\\\\\\\\\_____________\\\\//\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/\\\\\\\\_\\\\/\\\\\\\\\\\\____________\\\\//\\\\\\\\\\\\\\\\\\\\___\\\\//\\\\\\\\\\\\\\\\/______\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\/___\\\\/\\\\\\\\\\\\_______\\\\/\\\\\\\\\\\\____\\\\///\\\\\\\\\\\\\\\\\\\\/_____\\n        _\\\\///_______________\\\\////////\\\\//__\\\\///______________\\\\/////_____\\\\////________\\\\////////////_____\\\\///________\\\\///_______\\\\/////_______\\n\\nAnna Carroll for PartyDAO\\n*/\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\n// ============ External Imports: Inherited Contracts ============\\n// NOTE: we inherit from OpenZeppelin upgradeable contracts\\n// because of the proxy structure used for cheaper deploys\\n// (the proxies are NOT actually upgradeable)\\nimport {\\nReentrancyGuardUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport {\\nERC721HolderUpgradeable\\n} from \\\"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\\\";\\n// ============ External Imports: External Contracts & Contract Interfaces ============\\nimport {\\nIERC721VaultFactory\\n} from \\\"./external/interfaces/IERC721VaultFactory.sol\\\";\\nimport {ITokenVault} from \\\"./external/interfaces/ITokenVault.sol\\\";\\nimport {IWETH} from \\\"./external/interfaces/IWETH.sol\\\";\\nimport {\\nIERC721Metadata\\n} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport {\\nIERC20\\n} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n// ============ Internal Imports ============\\nimport {Structs} from \\\"./Structs.sol\\\";\\n\\ncontract Party is ReentrancyGuardUpgradeable, ERC721HolderUpgradeable {\\n    // ============ Enums ============\\n\\n    // State Transitions:\\n    //   (0) ACTIVE on deploy\\n    //   (1) WON if the Party has won the token\\n    //   (2) LOST if the Party is over & did not win the token\\n    enum PartyStatus {ACTIVE, WON, LOST}\\n\\n    // ============ Structs ============\\n\\n    struct Contribution {\\n        uint256 amount;\\n        uint256 previousTotalContributedToParty;\\n    }\\n\\n    // ============ Internal Constants ============\\n\\n    // tokens are minted at a rate of 1 ETH : 1000 tokens\\n    uint16 internal constant TOKEN_SCALE = 1000;\\n    // PartyDAO receives an ETH fee equal to 2.5% of the amount spent\\n    uint16 internal constant ETH_FEE_BASIS_POINTS = 250;\\n    // PartyDAO receives a token fee equal to 2.5% of the total token supply\\n    uint16 internal constant TOKEN_FEE_BASIS_POINTS = 250;\\n    // token is relisted on Fractional with an\\n    // initial reserve price equal to 2x the price of the token\\n    uint8 internal constant RESALE_MULTIPLIER = 2;\\n\\n    // ============ Immutables ============\\n\\n    address public immutable partyFactory;\\n    address public immutable partyDAOMultisig;\\n    IERC721VaultFactory public immutable tokenVaultFactory;\\n    IWETH public immutable weth;\\n\\n    // ============ Public Not-Mutated Storage ============\\n\\n    // NFT contract\\n    IERC721Metadata public nftContract;\\n    // ID of token within NFT contract\\n    uint256 public tokenId;\\n    // Fractionalized NFT vault responsible for post-purchase experience\\n    ITokenVault public tokenVault;\\n    // the address that will receive a portion of the tokens\\n    // if the Party successfully buys the token\\n    address public splitRecipient;\\n    // percent of the total token supply\\n    // taken by the splitRecipient\\n    uint256 public splitBasisPoints;\\n    // address of token that users need to hold to contribute\\n    // address(0) if party is not token gated\\n    IERC20 public gatedToken;\\n    // amount of token that users need to hold to contribute\\n    // 0 if party is not token gated\\n    uint256 public gatedTokenAmount;\\n    // ERC-20 name and symbol for fractional tokens\\n    string public name;\\n    string public symbol;\\n\\n    // ============ Public Mutable Storage ============\\n\\n    // state of the contract\\n    PartyStatus public partyStatus;\\n    // total ETH deposited by all contributors\\n    uint256 public totalContributedToParty;\\n    // the total spent buying the token;\\n    // 0 if the NFT is not won; price of token + 2.5% PartyDAO fee if NFT is won\\n    uint256 public totalSpent;\\n    // contributor => array of Contributions\\n    mapping(address => Contribution[]) public contributions;\\n    // contributor => total amount contributed\\n    mapping(address => uint256) public totalContributed;\\n    // contributor => true if contribution has been claimed\\n    mapping(address => bool) public claimed;\\n\\n    // ============ Events ============\\n\\n    event Contributed(\\n        address indexed contributor,\\n        uint256 amount,\\n        uint256 previousTotalContributedToParty,\\n        uint256 totalFromContributor\\n    );\\n\\n    event Claimed(\\n        address indexed contributor,\\n        uint256 totalContributed,\\n        uint256 excessContribution,\\n        uint256 tokenAmount\\n    );\\n\\n    // ======== Modifiers =========\\n\\n    modifier onlyPartyDAO() {\\n        require(\\n            msg.sender == partyDAOMultisig,\\n            \\\"Party:: only PartyDAO multisig\\\"\\n        );\\n        _;\\n    }\\n\\n    // ======== Constructor =========\\n\\n    constructor(\\n        address _partyDAOMultisig,\\n        address _tokenVaultFactory,\\n        address _weth\\n    ) {\\n        partyFactory = msg.sender;\\n        partyDAOMultisig = _partyDAOMultisig;\\n        tokenVaultFactory = IERC721VaultFactory(_tokenVaultFactory);\\n        weth = IWETH(_weth);\\n    }\\n\\n    // ======== Internal: Initialize =========\\n\\n    function __Party_init(\\n        address _nftContract,\\n        uint256 _tokenId,\\n        Structs.AddressAndAmount calldata _split,\\n        Structs.AddressAndAmount calldata _tokenGate,\\n        string memory _name,\\n        string memory _symbol\\n    ) internal {\\n        require(msg.sender == partyFactory, \\\"Party::__Party_init: only factory can init\\\");\\n        // validate token exists (must set nftContract & tokenId before _getOwner)\\n        nftContract = IERC721Metadata(_nftContract);\\n        tokenId = _tokenId;\\n        require(_getOwner() != address(0), \\\"Party::__Party_init: NFT getOwner failed\\\");\\n        // if split is non-zero,\\n        if (_split.addr != address(0) && _split.amount != 0) {\\n            // validate that party split won't retain the total token supply\\n            uint256 _remainingBasisPoints = 10000 - TOKEN_FEE_BASIS_POINTS;\\n            require(_split.amount < _remainingBasisPoints, \\\"Party::__Party_init: basis points can't take 100%\\\");\\n            splitBasisPoints = _split.amount;\\n            splitRecipient = _split.addr;\\n        }\\n        // if token gating is non-zero\\n        if (_tokenGate.addr != address(0) && _tokenGate.amount != 0) {\\n            // call totalSupply to verify that address is ERC-20 token contract\\n            IERC20(_tokenGate.addr).totalSupply();\\n            gatedToken = IERC20(_tokenGate.addr);\\n            gatedTokenAmount = _tokenGate.amount;\\n        }\\n        // initialize ReentrancyGuard and ERC721Holder\\n        __ReentrancyGuard_init();\\n        __ERC721Holder_init();\\n        // set storage variables\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    // ======== Internal: Contribute =========\\n\\n    /**\\n     * @notice Contribute to the Party's treasury\\n     * while the Party is still active\\n     * @dev Emits a Contributed event upon success; callable by anyone\\n     */\\n    function _contribute() internal {\\n        require(\\n            partyStatus == PartyStatus.ACTIVE,\\n            \\\"Party::contribute: party not active\\\"\\n        );\\n        address _contributor = msg.sender;\\n        uint256 _amount = msg.value;\\n        // if token gated, require that contributor has balance of gated tokens\\n        if (address(gatedToken) != address(0)) {\\n            require(gatedToken.balanceOf(_contributor) >= gatedTokenAmount, \\\"Party::contribute: must hold tokens to contribute\\\");\\n        }\\n        require(_amount > 0, \\\"Party::contribute: must contribute more than 0\\\");\\n        // get the current contract balance\\n        uint256 _previousTotalContributedToParty = totalContributedToParty;\\n        // add contribution to contributor's array of contributions\\n        Contribution memory _contribution =\\n            Contribution({\\n                amount: _amount,\\n                previousTotalContributedToParty: _previousTotalContributedToParty\\n            });\\n        contributions[_contributor].push(_contribution);\\n        // add to contributor's total contribution\\n        totalContributed[_contributor] = totalContributed[_contributor] + _amount;\\n        // add to party's total contribution & emit event\\n        totalContributedToParty = _previousTotalContributedToParty + _amount;\\n        emit Contributed(\\n            _contributor,\\n            _amount,\\n            _previousTotalContributedToParty,\\n            totalContributed[_contributor]\\n        );\\n    }\\n\\n    // ======== External: Claim =========\\n\\n    /**\\n     * @notice Claim the tokens and excess ETH owed\\n     * to a single contributor after the party has ended\\n     * @dev Emits a Claimed event upon success\\n     * callable by anyone (doesn't have to be the contributor)\\n     * @param _contributor the address of the contributor\\n     */\\n    function claim(address _contributor) external nonReentrant {\\n        // ensure party has finalized\\n        require(\\n            partyStatus != PartyStatus.ACTIVE,\\n            \\\"Party::claim: party not finalized\\\"\\n        );\\n        // ensure contributor submitted some ETH\\n        require(\\n            totalContributed[_contributor] != 0,\\n            \\\"Party::claim: not a contributor\\\"\\n        );\\n        // ensure the contributor hasn't already claimed\\n        require(\\n            !claimed[_contributor],\\n            \\\"Party::claim: contribution already claimed\\\"\\n        );\\n        // mark the contribution as claimed\\n        claimed[_contributor] = true;\\n        // calculate the amount of fractional NFT tokens owed to the user\\n        // based on how much ETH they contributed towards the party,\\n        // and the amount of excess ETH owed to the user\\n        (uint256 _tokenAmount, uint256 _ethAmount) =\\n        getClaimAmounts(_contributor);\\n        // transfer tokens to contributor for their portion of ETH used\\n        _transferTokens(_contributor, _tokenAmount);\\n        // if there is excess ETH, send it back to the contributor\\n        _transferETHOrWETH(_contributor, _ethAmount);\\n        emit Claimed(\\n            _contributor,\\n            totalContributed[_contributor],\\n            _ethAmount,\\n            _tokenAmount\\n        );\\n    }\\n\\n    // ======== External: Emergency Escape Hatches (PartyDAO Multisig Only) =========\\n\\n    /**\\n     * @notice Escape hatch: in case of emergency,\\n     * PartyDAO can use emergencyWithdrawEth to withdraw\\n     * ETH stuck in the contract\\n     */\\n    function emergencyWithdrawEth(uint256 _value)\\n        external\\n        onlyPartyDAO\\n    {\\n        _transferETHOrWETH(partyDAOMultisig, _value);\\n    }\\n\\n    /**\\n     * @notice Escape hatch: in case of emergency,\\n     * PartyDAO can use emergencyCall to call an external contract\\n     * (e.g. to withdraw a stuck NFT or stuck ERC-20s)\\n     */\\n    function emergencyCall(address _contract, bytes memory _calldata)\\n        external\\n        onlyPartyDAO\\n        returns (bool _success, bytes memory _returnData)\\n    {\\n        (_success, _returnData) = _contract.call(_calldata);\\n        require(_success, string(_returnData));\\n    }\\n\\n    /**\\n     * @notice Escape hatch: in case of emergency,\\n     * PartyDAO can force the Party to finalize with status LOST\\n     * (e.g. if finalize is not callable)\\n     */\\n    function emergencyForceLost()\\n        external\\n        onlyPartyDAO\\n    {\\n        // set partyStatus to LOST\\n        partyStatus = PartyStatus.LOST;\\n    }\\n\\n    // ======== Public: Utility Calculations =========\\n\\n    /**\\n     * @notice Convert ETH value to equivalent token amount\\n     */\\n    function valueToTokens(uint256 _value)\\n        public\\n        pure\\n        returns (uint256 _tokens)\\n    {\\n        _tokens = _value * TOKEN_SCALE;\\n    }\\n\\n    /**\\n     * @notice The maximum amount that can be spent by the Party\\n     * while paying the ETH fee to PartyDAO\\n     * @return _maxSpend the maximum spend\\n     */\\n    function getMaximumSpend() public view returns (uint256 _maxSpend) {\\n        _maxSpend = (totalContributedToParty * 10000) / (10000 + ETH_FEE_BASIS_POINTS);\\n    }\\n\\n    /**\\n     * @notice Calculate the amount of fractional NFT tokens owed to the contributor\\n     * based on how much ETH they contributed towards buying the token,\\n     * and the amount of excess ETH owed to the contributor\\n     * based on how much ETH they contributed *not* used towards buying the token\\n     * @param _contributor the address of the contributor\\n     * @return _tokenAmount the amount of fractional NFT tokens owed to the contributor\\n     * @return _ethAmount the amount of excess ETH owed to the contributor\\n     */\\n    function getClaimAmounts(address _contributor)\\n        public\\n        view\\n        returns (uint256 _tokenAmount, uint256 _ethAmount)\\n    {\\n        require(partyStatus != PartyStatus.ACTIVE, \\\"Party::getClaimAmounts: party still active; amounts undetermined\\\");\\n        uint256 _totalContributed = totalContributed[_contributor];\\n        if (partyStatus == PartyStatus.WON) {\\n            // calculate the amount of this contributor's ETH\\n            // that was used to buy the token\\n            uint256 _totalEthUsed = totalEthUsed(_contributor);\\n            if (_totalEthUsed > 0) {\\n                _tokenAmount = valueToTokens(_totalEthUsed);\\n            }\\n            // the rest of the contributor's ETH should be returned\\n            _ethAmount = _totalContributed - _totalEthUsed;\\n        } else {\\n            // if the token wasn't bought, no ETH was spent;\\n            // all of the contributor's ETH should be returned\\n            _ethAmount = _totalContributed;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate the total amount of a contributor's funds\\n     * that were used towards the buying the token\\n     * @dev always returns 0 until the party has been finalized\\n     * @param _contributor the address of the contributor\\n     * @return _total the sum of the contributor's funds that were\\n     * used towards buying the token\\n     */\\n    function totalEthUsed(address _contributor)\\n        public\\n        view\\n        returns (uint256 _total)\\n    {\\n        require(partyStatus != PartyStatus.ACTIVE, \\\"Party::totalEthUsed: party still active; amounts undetermined\\\");\\n        // load total amount spent once from storage\\n        uint256 _totalSpent = totalSpent;\\n        // get all of the contributor's contributions\\n        Contribution[] memory _contributions = contributions[_contributor];\\n        for (uint256 i = 0; i < _contributions.length; i++) {\\n            // calculate how much was used from this individual contribution\\n            uint256 _amount = _ethUsed(_totalSpent, _contributions[i]);\\n            // if we reach a contribution that was not used,\\n            // no subsequent contributions will have been used either,\\n            // so we can stop calculating to save some gas\\n            if (_amount == 0) break;\\n            _total = _total + _amount;\\n        }\\n    }\\n\\n    // ============ Internal ============\\n\\n    function _closeSuccessfulParty(uint256 _nftCost) internal returns (uint256 _ethFee) {\\n        // calculate PartyDAO fee & record total spent\\n        _ethFee = _getEthFee(_nftCost);\\n        totalSpent = _nftCost + _ethFee;\\n        // transfer ETH fee to PartyDAO\\n        _transferETHOrWETH(partyDAOMultisig, _ethFee);\\n        // deploy fractionalized NFT vault\\n        // and mint fractional ERC-20 tokens\\n        _fractionalizeNFT(_nftCost);\\n    }\\n\\n    /**\\n     * @notice Calculate ETH fee for PartyDAO\\n     * NOTE: Remove this fee causes a critical vulnerability\\n     * allowing anyone to exploit a Party via price manipulation.\\n     * See Security Review in README for more info.\\n     * @return _fee the portion of _amount represented by scaling to ETH_FEE_BASIS_POINTS\\n     */\\n    function _getEthFee(uint256 _amount) internal pure returns (uint256 _fee) {\\n        _fee = (_amount * ETH_FEE_BASIS_POINTS) / 10000;\\n    }\\n\\n    /**\\n     * @notice Calculate token amount for specified token recipient\\n     * @return _totalSupply the total token supply\\n     * @return _partyDAOAmount the amount of tokens for partyDAO fee,\\n     * which is equivalent to TOKEN_FEE_BASIS_POINTS of total supply\\n     * @return _splitRecipientAmount the amount of tokens for the token recipient,\\n     * which is equivalent to splitBasisPoints of total supply\\n     */\\n    function _getTokenInflationAmounts(uint256 _amountSpent)\\n        internal\\n        view\\n        returns (uint256 _totalSupply, uint256 _partyDAOAmount, uint256 _splitRecipientAmount)\\n    {\\n        // the token supply will be inflated to provide a portion of the\\n        // total supply for PartyDAO, and a portion for the splitRecipient\\n        uint256 inflationBasisPoints = TOKEN_FEE_BASIS_POINTS + splitBasisPoints;\\n        _totalSupply = valueToTokens((_amountSpent * 10000) / (10000 - inflationBasisPoints));\\n        // PartyDAO receives TOKEN_FEE_BASIS_POINTS of the total supply\\n        _partyDAOAmount = (_totalSupply * TOKEN_FEE_BASIS_POINTS) / 10000;\\n        // splitRecipient receives splitBasisPoints of the total supply\\n        _splitRecipientAmount = (_totalSupply * splitBasisPoints) / 10000;\\n    }\\n\\n    /**\\n    * @notice Query the NFT contract to get the token owner\\n    * @dev nftContract must implement the ERC-721 token standard exactly:\\n    * function ownerOf(uint256 _tokenId) external view returns (address);\\n    * See https://eips.ethereum.org/EIPS/eip-721\\n    * @dev Returns address(0) if NFT token or NFT contract\\n    * no longer exists (token burned or contract self-destructed)\\n    * @return _owner the owner of the NFT\\n    */\\n    function _getOwner() internal view returns (address _owner) {\\n        (bool _success, bytes memory _returnData) =\\n            address(nftContract).staticcall(\\n                abi.encodeWithSignature(\\n                    \\\"ownerOf(uint256)\\\",\\n                    tokenId\\n                )\\n        );\\n        if (_success && _returnData.length > 0) {\\n            _owner = abi.decode(_returnData, (address));\\n        }\\n    }\\n\\n    /**\\n     * @notice Upon winning the token, transfer the NFT\\n     * to fractional.art vault & mint fractional ERC-20 tokens\\n     */\\n    function _fractionalizeNFT(uint256 _amountSpent) internal {\\n        // approve fractionalized NFT Factory to withdraw NFT\\n        nftContract.approve(address(tokenVaultFactory), tokenId);\\n        // Party \\\"votes\\\" for a reserve price on Fractional\\n        // equal to 2x the price of the token\\n        uint256 _listPrice = RESALE_MULTIPLIER * _amountSpent;\\n        // users receive tokens at a rate of 1:TOKEN_SCALE for each ETH they contributed that was ultimately spent\\n        // partyDAO receives a percentage of the total token supply equivalent to TOKEN_FEE_BASIS_POINTS\\n        // splitRecipient receives a percentage of the total token supply equivalent to splitBasisPoints\\n        (uint256 _tokenSupply, uint256 _partyDAOAmount, uint256 _splitRecipientAmount) = _getTokenInflationAmounts(totalSpent);\\n        // deploy fractionalized NFT vault\\n        uint256 vaultNumber =\\n            tokenVaultFactory.mint(\\n                name,\\n                symbol,\\n                address(nftContract),\\n                tokenId,\\n                _tokenSupply,\\n                _listPrice,\\n                0\\n            );\\n        // store token vault address to storage\\n        tokenVault = ITokenVault(tokenVaultFactory.vaults(vaultNumber));\\n        // transfer curator to null address (burn the curator role)\\n        tokenVault.updateCurator(address(0));\\n        // transfer tokens to PartyDAO multisig\\n        _transferTokens(partyDAOMultisig, _partyDAOAmount);\\n        // transfer tokens to token recipient\\n        if (splitRecipient != address(0)) {\\n            _transferTokens(splitRecipient, _splitRecipientAmount);\\n        }\\n    }\\n\\n    // ============ Internal: Claim ============\\n\\n    /**\\n     * @notice Calculate the amount of a single Contribution\\n     * that was used towards buying the token\\n     * @param _contribution the Contribution struct\\n     * @return the amount of funds from this contribution\\n     * that were used towards buying the token\\n     */\\n    function _ethUsed(uint256 _totalSpent, Contribution memory _contribution)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        if (\\n            _contribution.previousTotalContributedToParty +\\n            _contribution.amount <=\\n            _totalSpent\\n        ) {\\n            // contribution was fully used\\n            return _contribution.amount;\\n        } else if (\\n            _contribution.previousTotalContributedToParty < _totalSpent\\n        ) {\\n            // contribution was partially used\\n            return _totalSpent - _contribution.previousTotalContributedToParty;\\n        }\\n        // contribution was not used\\n        return 0;\\n    }\\n\\n    // ============ Internal: TransferTokens ============\\n\\n    /**\\n    * @notice Transfer tokens to a recipient\\n    * @param _to recipient of tokens\\n    * @param _value amount of tokens\\n    */\\n    function _transferTokens(address _to, uint256 _value) internal {\\n        // skip if attempting to send 0 tokens\\n        if (_value == 0) {\\n            return;\\n        }\\n        // guard against rounding errors;\\n        // if token amount to send is greater than contract balance,\\n        // send full contract balance\\n        uint256 _partyBalance = tokenVault.balanceOf(address(this));\\n        if (_value > _partyBalance) {\\n            _value = _partyBalance;\\n        }\\n        tokenVault.transfer(_to, _value);\\n    }\\n\\n    // ============ Internal: TransferEthOrWeth ============\\n\\n    /**\\n     * @notice Attempt to transfer ETH to a recipient;\\n     * if transferring ETH fails, transfer WETH insteads\\n     * @param _to recipient of ETH or WETH\\n     * @param _value amount of ETH or WETH\\n     */\\n    function _transferETHOrWETH(address _to, uint256 _value) internal {\\n        // skip if attempting to send 0 ETH\\n        if (_value == 0) {\\n            return;\\n        }\\n        // guard against rounding errors;\\n        // if ETH amount to send is greater than contract balance,\\n        // send full contract balance\\n        if (_value > address(this).balance) {\\n            _value = address(this).balance;\\n        }\\n        // Try to transfer ETH to the given recipient.\\n        if (!_attemptETHTransfer(_to, _value)) {\\n            // If the transfer fails, wrap and send as WETH\\n            weth.deposit{value: _value}();\\n            weth.transfer(_to, _value);\\n            // At this point, the recipient can unwrap WETH.\\n        }\\n    }\\n\\n    /**\\n     * @notice Attempt to transfer ETH to a recipient\\n     * @dev Sending ETH is not guaranteed to succeed\\n     * this method will return false if it fails.\\n     * We will limit the gas used in transfers, and handle failure cases.\\n     * @param _to recipient of ETH\\n     * @param _value amount of ETH\\n     */\\n    function _attemptETHTransfer(address _to, uint256 _value)\\n        internal\\n        returns (bool)\\n    {\\n        // Here increase the gas limit a reasonable amount above the default, and try\\n        // to send ETH to the recipient.\\n        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\\n        (bool success, ) = _to.call{value: _value, gas: 30000}(\\\"\\\");\\n        return success;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\ninterface Structs {\\n    struct AddressAndAmount {\\n        address addr;\\n        uint256 amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IAllowList.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\n/**\\n * @title IAllowList\\n * @author Anna Carroll\\n */\\ninterface IAllowList {\\n    function allowed(address _addr) external view returns (bool _bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal initializer {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal initializer {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n  /**\\n   * @dev Implementation of the {IERC721Receiver} interface.\\n   *\\n   * Accepts all token transfers.\\n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n   */\\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\\n    function __ERC721Holder_init() internal initializer {\\n        __ERC721Holder_init_unchained();\\n    }\\n\\n    function __ERC721Holder_init_unchained() internal initializer {\\n    }\\n\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/external/interfaces/IERC721VaultFactory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\ninterface IERC721VaultFactory {\\n    /// @notice the mapping of vault number to vault address\\n    function vaults(uint256) external returns (address);\\n\\n    /// @notice the function to mint a new vault\\n    /// @param _name the desired name of the vault\\n    /// @param _symbol the desired sumbol of the vault\\n    /// @param _token the ERC721 token address fo the NFT\\n    /// @param _id the uint256 ID of the token\\n    /// @param _listPrice the initial price of the NFT\\n    /// @return the ID of the vault\\n    function mint(string memory _name, string memory _symbol, address _token, uint256 _id, uint256 _supply, uint256 _listPrice, uint256 _fee) external returns(uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/external/interfaces/ITokenVault.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\ninterface ITokenVault {\\n    /// @notice allow curator to update the curator address\\n    /// @param _curator the new curator\\n    function updateCurator(address _curator) external;\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/external/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.5;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partyDAOMultisig\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenVaultFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_allowList\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"triggeredBy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"targetAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethSpent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethFeePaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalContributed\",\"type\":\"uint256\"}],\"name\":\"Bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalContributed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"excessContribution\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousTotalContributedToParty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalFromContributor\",\"type\":\"uint256\"}],\"name\":\"Contributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"triggeredBy\",\"type\":\"address\"}],\"name\":\"Expired\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowList\",\"outputs\":[{\"internalType\":\"contract IAllowList\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_targetContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contribute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"previousTotalContributedToParty\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"emergencyCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyForceLost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expire\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gatedToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gatedTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"getClaimAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ethAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaximumContributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxContributions\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaximumSpend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSpend\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_secondsToTimeout\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.AddressAndAmount\",\"name\":\"_split\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Structs.AddressAndAmount\",\"name\":\"_tokenGate\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftContract\",\"outputs\":[{\"internalType\":\"contract IERC721Metadata\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partyDAOMultisig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partyFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partyStatus\",\"outputs\":[{\"internalType\":\"enum Party.PartyStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"splitBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"splitRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenVault\",\"outputs\":[{\"internalType\":\"contract ITokenVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenVaultFactory\",\"outputs\":[{\"internalType\":\"contract IERC721VaultFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalContributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalContributedToParty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"totalEthUsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSpent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"valueToTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"PartyBuy","CompilerVersion":"v0.8.5+commit.a4f2e591","OptimizationUsed":"1","Runs":"999999","ConstructorArguments":"000000000000000000000000f7f52dd34bc21eda08c0b804c7c1dbc48375820f00000000000000000000000085aa7f78bdb2de8f3e0c0010d99ad5853ffcfc63000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000f3380293ef7f7b71c7c2656a5bee926fa71338ed","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}