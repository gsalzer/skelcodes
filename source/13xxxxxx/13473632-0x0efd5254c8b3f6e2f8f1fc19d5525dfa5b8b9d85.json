{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *Submitted for verification at Etherscan.io on 2021-10-11\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\ninterface IERC165 {\r\n\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\npragma solidity ^0.8.0;\r\ninterface IERC721 is IERC165 {\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\r\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) external;\r\n\tfunction approve(address to, uint256 tokenId) external;\r\n\tfunction getApproved(uint256 tokenId) external view returns (address operator);\r\n\tfunction setApprovalForAll(address operator, bool _approved) external;\r\n\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\npragma solidity ^0.8.0;\r\ninterface IERC721Receiver {\r\n\tfunction onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\npragma solidity ^0.8.0;\r\ninterface IERC721Metadata is IERC721 {\r\n\tfunction name() external view returns (string memory);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\npragma solidity ^0.8.0;\r\nlibrary Address {\r\n\tfunction isContract(address account) internal view returns (bool) {\r\n\t\tuint256 size;\r\n\t\tassembly {\r\n\t\t\tsize := extcodesize(account)\r\n\t\t}\r\n\t\treturn size > 0;\r\n\t}\r\n\r\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n\t\trequire(address(this).balance >= amount, \"Insufficient balance\");\r\n\t\t(bool success, ) = recipient.call{value: amount}(\"\");\r\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n\t}\r\n\r\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\r\n\t}\r\n\r\n\tfunction functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\r\n\t}\r\n\r\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n\t}\r\n\r\n\tfunction functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n\t\trequire(address(this).balance >= value, \"Insufficient balance!\");\r\n\t\trequire(isContract(target), \"Address: call to non-contract\");\r\n\t\t(bool success, bytes memory returndata) = target.call{value: value}(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\tfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n\t\treturn functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n\t}\r\n\r\n\tfunction functionStaticCall( address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n\t\trequire(isContract(target), \"Address: static call to non-contract\");\r\n\t\t(bool success, bytes memory returndata) = target.staticcall(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\tfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n\t}\r\n\r\n\tfunction functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n\t\trequire(isContract(target), \"Address: delegate call to non-contract\");\r\n\t\t(bool success, bytes memory returndata) = target.delegatecall(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\tfunction verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) internal pure returns (bytes memory) {\r\n\t\tif(success) {\r\n\t\t\treturn returndata;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif(returndata.length > 0) {\r\n\t\t\t\tassembly {\r\n\t\t\t\t\tlet returndata_size := mload(returndata)\r\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\trevert(errorMessage);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\npragma solidity ^0.8.0;\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns (bytes calldata) {\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\npragma solidity ^0.8.0;\r\nlibrary Strings {\r\n\tbytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n\tfunction toString(uint256 value) internal pure returns (string memory) {\r\n\t\tif(value == 0) {\r\n\t\t\treturn \"0\";\r\n\t\t}\r\n\t\tuint256 temp = value;\r\n\t\tuint256 digits;\r\n\t\twhile (temp != 0) {\r\n\t\t\tdigits++;\r\n\t\t\ttemp /= 10;\r\n\t\t}\r\n\t\tbytes memory buffer = new bytes(digits);\r\n\t\twhile (value != 0) {\r\n\t\t\tdigits -= 1;\r\n\t\t\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n\t\t\tvalue /= 10;\r\n\t\t}\r\n\t\treturn string(buffer);\r\n\t}\r\n\r\n\tfunction toHexString(uint256 value) internal pure returns (string memory) {\r\n\t\tif(value == 0) {\r\n\t\t\treturn \"0x00\";\r\n\t\t}\r\n\t\tuint256 temp = value;\r\n\t\tuint256 length = 0;\r\n\t\twhile (temp != 0) {\r\n\t\t\tlength++;\r\n\t\t\ttemp >>= 8;\r\n\t\t}\r\n\t\treturn toHexString(value, length);\r\n\t}\r\n\r\n\tfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n\t\tbytes memory buffer = new bytes(2 * length + 2);\r\n\t\tbuffer[0] = \"0\";\r\n\t\tbuffer[1] = \"x\";\r\n\t\tfor (uint256 i = 2 * length + 1; i > 1; --i) {\r\n\t\t\tbuffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n\t\t\tvalue >>= 4;\r\n\t\t}\r\n\t\trequire(value == 0, \"Strings: hex length insufficient\");\r\n\t\treturn string(buffer);\r\n\t}\r\n}\r\n\r\npragma solidity ^0.8.0;\r\nabstract contract ERC165 is IERC165 {\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n\t\treturn interfaceId == type(IERC165).interfaceId;\r\n\t}\r\n}\r\n\r\npragma solidity ^0.8.0;\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\n\tusing Address for address;\r\n\tusing Strings for uint256;\r\n\r\n\tstring private _name = \"Clockchains v1.0\";\r\n\tstring private _symbol = \"CHCLOCKS\";\r\n\taddress[365] private _owners;\r\n\tbool private _postBigBang = false;\r\n\tmapping(address => uint256) private _balances;\r\n\tmapping(uint256 => address) private _tokenApprovals;\r\n\tmapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n\tconstructor(string memory name_, string memory symbol_) {}\r\n\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n\t\treturn\r\n\t\t\tinterfaceId == type(IERC721).interfaceId ||\r\n\t\t\tinterfaceId == type(IERC721Metadata).interfaceId ||\r\n\t\t\tsuper.supportsInterface(interfaceId);\r\n\t}\r\n\r\n\tfunction balanceOf(address owner) public view virtual override returns (uint256) {\r\n\t\trequire(owner != address(0), \"ERC721: balance query for the zero address\");\r\n\t\treturn _balances[owner];\r\n\t}\r\n\r\n\tfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n\t\trequire(_postBigBang == true, \"Attempted to peek before Big Bang.\");\r\n\t\taddress owner = _owners[tokenId];\r\n\t\treturn owner;\r\n\t}\r\n\r\n\tfunction name() public view virtual override returns (string memory) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\tfunction symbol() public view virtual override returns (string memory) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\tfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n\t\trequire(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\t\tstring memory baseURI = _baseURI();\r\n\t\treturn bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n\t}\r\n\r\n\tfunction _baseURI() internal view virtual returns (string memory) {\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\tfunction approve(address to, uint256 tokenId) public virtual override {\r\n\t\taddress owner = ERC721.ownerOf(tokenId);\r\n\t\trequire(to != owner, \"Not authorized!\");\r\n\t\trequire(\r\n\t\t\t_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n\t\t\t\"Not authorized!\"\r\n\t\t);\r\n\t\t_approve(to, tokenId);\r\n\t}\r\n\r\n\tfunction getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n\t\trequire(_exists(tokenId), \"Nonexistent token!\");\r\n\t\treturn _tokenApprovals[tokenId];\r\n\t}\r\n\r\n\tfunction setApprovalForAll(address operator, bool approved) public virtual override {\r\n\t\trequire(operator != _msgSender(), \"ERC721: approve to caller\");\r\n\t\t_operatorApprovals[_msgSender()][operator] = approved;\r\n\t\temit ApprovalForAll(_msgSender(), operator, approved);\r\n\t}\r\n\r\n\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n\t\treturn _operatorApprovals[owner][operator];\r\n\t}\r\n\r\n\tfunction transferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"Not authorized!\");\r\n\t\t_transfer(from, to, tokenId);\r\n\t}\r\n\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\r\n\t\tsafeTransferFrom(from, to, tokenId, \"\");\r\n\t}\r\n\r\n\tfunction safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\r\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"Not authorized!\");\r\n\t\t_safeTransfer(from, to, tokenId, _data);\r\n\t}\r\n\r\n\tfunction _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\r\n\t\t_transfer(from, to, tokenId);\r\n\t\trequire(_checkOnERC721Received(from, to, tokenId, _data), \"Attempted transfer to non ERC721Receiver implementer!\");\r\n\t}\r\n\r\n\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n\t\treturn _owners[tokenId] != address(0);\r\n\t}\r\n\r\n\tfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n\t\trequire(_exists(tokenId), \"Token does not exist!\");\r\n\t\taddress owner = ERC721.ownerOf(tokenId);\r\n\t\treturn (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n\t}\r\n\r\n\tfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n\t\trequire(1 == 2, \"Disabled function!\");\r\n\t}\r\n\r\n\tfunction _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\r\n\t\trequire(1 == 2, \"Disabled function!\");\r\n\t}\r\n\r\n\tfunction _mint(address to, uint256 tokenId) internal virtual {\r\n\t\trequire(1 == 2, \"Disabled function!\");\r\n\t}\r\n\r\n\tfunction _bigbang() internal virtual {\r\n\t\taddress[365] memory _tempMem;\r\n\t\tfor(uint256 i = 0; i < 365; i++) {\r\n\t\t\t_tempMem[i] = 0xC12Df5F402A8B8BEaea49ed9baD9c95fCcbfE907;\r\n\t\t}\r\n\t\t_owners = _tempMem;\r\n\t\t_balances[_msgSender()] = 365;\r\n\t\t_postBigBang = true;\r\n\t}\r\n\r\n\tfunction _burn(uint256 tokenId) internal virtual {\r\n\t\t// Instead of messing everything by removing the index, we just transfer the asset to the burn addy.\r\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"Not authorized!\");\r\n\t\taddress from = ERC721.ownerOf(tokenId);\r\n\t\taddress to = address(0);\r\n\t\t_transfer(from, to, tokenId);\r\n\t}\r\n\r\n\tfunction _transfer(address from, address to, uint256 tokenId) internal virtual {\r\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"Not authorized!\");\r\n\t\trequire(to != address(0), \"Cannot transfer to zero addy!\");\r\n\r\n\t\t_beforeTokenTransfer(from, to, tokenId);\r\n\t\t_approve(address(0), tokenId);\r\n\t\t_balances[from] -= 1;\r\n\t\t_balances[to] += 1;\r\n\t\t_owners[tokenId] = to;\r\n\t\temit Transfer(from, to, tokenId);\r\n\t}\r\n\r\n\tfunction _approve(address to, uint256 tokenId) internal virtual {\r\n\t\t_tokenApprovals[tokenId] = to;\r\n\t\temit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n\t}\r\n\r\n\tfunction _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {\r\n\t\tif(to.isContract()) {\r\n\t\t\ttry IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n\t\t\t\treturn retval == IERC721Receiver.onERC721Received.selector;\r\n\t\t\t} catch (bytes memory reason) {\r\n\t\t\t\tif(reason.length == 0) {\r\n\t\t\t\t\trevert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tassembly {\r\n\t\t\t\t\t\trevert(add(32, reason), mload(reason))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {}\r\n}\r\n\r\npragma solidity ^0.8.0;\r\ninterface IERC721Enumerable is IERC721 {\r\n\tfunction totalSupply() external view returns (uint256);\r\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n\tfunction tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\npragma solidity ^0.8.0;\r\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\r\n\tmapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n\tmapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\r\n\t\treturn interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\r\n\t}\r\n\r\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\r\n\t\trequire(index < ERC721.balanceOf(owner), \"Owner index out of bounds\");\r\n\t\treturn _ownedTokens[owner][index];\r\n\t}\r\n\r\n\tfunction totalSupply() public view virtual override returns (uint256) {\r\n\t\treturn 365;\r\n\t}\r\n\r\n\tfunction tokenByIndex(uint256 index) public view virtual override returns (uint256) {\r\n\t\trequire(index < ERC721Enumerable.totalSupply(), \"Global index out of bounds!\");\r\n\t\treturn index;\r\n\t}\r\n\r\n\tfunction _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {\r\n\t\tsuper._beforeTokenTransfer(from, to, tokenId);\r\n\t}\r\n\r\n\tfunction _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n\t\tuint256 length = ERC721.balanceOf(to);\r\n\t\t_ownedTokens[to][length] = tokenId;\r\n\t\t_ownedTokensIndex[tokenId] = length;\r\n\t}\r\n\r\n\tfunction _addTokenToAllTokensEnumeration(uint256 tokenId) public {}\r\n\r\n\tfunction _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n\t\tuint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\r\n\t\tuint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n\t\tif(tokenIndex != lastTokenIndex) {\r\n\t\t\tuint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n\t\t\t_ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n\t\t\t_ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\t\t}\r\n\r\n\t\tdelete _ownedTokensIndex[tokenId];\r\n\t\tdelete _ownedTokens[from][lastTokenIndex];\r\n\t}\r\n\r\n\tfunction _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {}\r\n}\r\n\r\npragma solidity ^0.8.0;\r\nabstract contract ERC721Burnable is Context, ERC721 {\r\n\tfunction burn(uint256 tokenId) public virtual {\r\n\t\t//solhint-disable-next-line max-line-length\r\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"Not authorized!\");\r\n\t\t_burn(tokenId);\r\n\t}\r\n}\r\n\r\npragma solidity ^0.8.0;\r\ninterface IAccessControl {\r\n\tfunction hasRole(bytes32 role, address account) external view returns (bool);\r\n\tfunction getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\tfunction grantRole(bytes32 role, address account) external;\r\n\tfunction revokeRole(bytes32 role, address account) external;\r\n\tfunction renounceRole(bytes32 role, address account) external;\r\n}\r\n\r\npragma solidity ^0.8.0;\r\nlibrary EnumerableSet {\r\n\tstruct Set {\r\n\t\tbytes32[] _values;\r\n\t\tmapping(bytes32 => uint256) _indexes;\r\n\t}\r\n\r\n\tfunction _add(Set storage set, bytes32 value) private returns (bool) {\r\n\t\tif(!_contains(set, value)) {\r\n\t\t\tset._values.push(value);\r\n\t\t\tset._indexes[value] = set._values.length;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _remove(Set storage set, bytes32 value) private returns (bool) {\r\n\t\tuint256 valueIndex = set._indexes[value];\r\n\r\n\t\tif(valueIndex != 0) {\r\n\t\t\tuint256 toDeleteIndex = valueIndex - 1;\r\n\t\t\tuint256 lastIndex = set._values.length - 1;\r\n\r\n\t\t\tif(lastIndex != toDeleteIndex) {\r\n\t\t\t\tbytes32 lastvalue = set._values[lastIndex];\r\n\t\t\t\tset._values[toDeleteIndex] = lastvalue;\r\n\t\t\t\tset._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n\t\t\t}\r\n\r\n\t\t\tset._values.pop();\r\n\t\t\tdelete set._indexes[value];\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n\t\treturn set._indexes[value] != 0;\r\n\t}\r\n\r\n\tfunction _length(Set storage set) private view returns (uint256) {\r\n\t\treturn set._values.length;\r\n\t}\r\n\r\n\tfunction _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n\t\treturn set._values[index];\r\n\t}\r\n\r\n\tfunction _values(Set storage set) private view returns (bytes32[] memory) {\r\n\t\treturn set._values;\r\n\t}\r\n\r\n\tstruct Bytes32Set {\r\n\t\tSet _inner;\r\n\t}\r\n\r\n\tfunction add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n\t\treturn _add(set._inner, value);\r\n\t}\r\n\r\n\tfunction remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n\t\treturn _remove(set._inner, value);\r\n\t}\r\n\r\n\tfunction contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n\t\treturn _contains(set._inner, value);\r\n\t}\r\n\r\n\tfunction length(Bytes32Set storage set) internal view returns (uint256) {\r\n\t\treturn _length(set._inner);\r\n\t}\r\n\r\n\tfunction at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n\t\treturn _at(set._inner, index);\r\n\t}\r\n\r\n\tfunction values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n\t\treturn _values(set._inner);\r\n\t}\r\n\r\n\tstruct AddressSet {\r\n\t\tSet _inner;\r\n\t}\r\n\r\n\tfunction add(AddressSet storage set, address value) internal returns (bool) {\r\n\t\treturn _add(set._inner, bytes32(uint256(uint160(value))));\r\n\t}\r\n\r\n\tfunction remove(AddressSet storage set, address value) internal returns (bool) {\r\n\t\treturn _remove(set._inner, bytes32(uint256(uint160(value))));\r\n\t}\r\n\r\n\tfunction contains(AddressSet storage set, address value) internal view returns (bool) {\r\n\t\treturn _contains(set._inner, bytes32(uint256(uint160(value))));\r\n\t}\r\n\r\n\tfunction length(AddressSet storage set) internal view returns (uint256) {\r\n\t\treturn _length(set._inner);\r\n\t}\r\n\r\n\tfunction at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n\t\treturn address(uint160(uint256(_at(set._inner, index))));\r\n\t}\r\n\r\n\tfunction values(AddressSet storage set) internal view returns (address[] memory) {\r\n\t\tbytes32[] memory store = _values(set._inner);\r\n\t\taddress[] memory result;\r\n\r\n\t\tassembly {\r\n\t\t\tresult := store\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tstruct UintSet {\r\n\t\tSet _inner;\r\n\t}\r\n\r\n\tfunction add(UintSet storage set, uint256 value) internal returns (bool) {\r\n\t\treturn _add(set._inner, bytes32(value));\r\n\t}\r\n\r\n\tfunction remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n\t\treturn _remove(set._inner, bytes32(value));\r\n\t}\r\n\r\n\tfunction contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n\t\treturn _contains(set._inner, bytes32(value));\r\n\t}\r\n\r\n\tfunction length(UintSet storage set) internal view returns (uint256) {\r\n\t\treturn _length(set._inner);\r\n\t}\r\n\r\n\tfunction at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n\t\treturn uint256(_at(set._inner, index));\r\n\t}\r\n\r\n\tfunction values(UintSet storage set) internal view returns (uint256[] memory) {\r\n\t\tbytes32[] memory store = _values(set._inner);\r\n\t\tuint256[] memory result;\r\n\t\tassembly {\r\n\t\t\tresult := store\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n}\r\n\r\npragma solidity ^0.8.0;\r\nlibrary Counters {\r\n\tstruct Counter {\r\n\t\tuint256 _value;\r\n\t}\r\n\r\n\tfunction current(Counter storage counter) internal view returns (uint256) {\r\n\t\treturn counter._value;\r\n\t}\r\n\r\n\tfunction increment(Counter storage counter) internal {\r\n\t\tunchecked {\r\n\t\t\tcounter._value += 1;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction decrement(Counter storage counter) internal {\r\n\t\tuint256 value = counter._value;\r\n\t\trequire(value > 0, \"Decrement overflow!\");\r\n\t\tunchecked {\r\n\t\t\tcounter._value = value - 1;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction reset(Counter storage counter) internal {\r\n\t\tcounter._value = 0;\r\n\t}\r\n}\r\n\r\npragma solidity ^0.8.0;\r\nlibrary SafeMath {\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a, \"Addition overflow!\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b <= a, \"Subtraction overflow!\");\r\n\t\tuint256 c = a - b;\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\t\tif(a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a * b;\r\n\t\trequire(c / a == b, \"Multiplication overflow!\");\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\t// Solidity only automatically asserts when dividing by 0\r\n\t\trequire(b > 0, \"Division by zero!\");\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\trequire(b != 0, \"Modulo by zero!\");\r\n\t\treturn a % b;\r\n\t}\r\n}\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract IERC2309  {\r\n\tevent ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\r\n}\r\n\r\npragma solidity ^0.8.0;\r\ncontract Clockchains is Context, ERC721Enumerable, ERC721Burnable, IERC2309 {\r\n\r\n\tevent ReceivedRoyalties(address indexed creator, address indexed buyer, uint256 indexed amount);\r\n\r\n\tusing Counters for Counters.Counter;\r\n\tusing SafeMath for uint256;\r\n\r\n\tbytes4 public constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n\r\n\t// Default URIs\r\n\tstring private _baseTokenURI = \"https://arielbecker.com/Clockchains/token.php\";\r\n\tstring private _contractURI = \"https://arielbecker.com/Clockchains/contract.php\";\r\n\tstring private _contractJSON = '{\"name\": \"Clockchains v1.0\",\"description\": \"Clockchains are 365 onchain-stored clocks that display the date, time, and lunar phase, according to the tier.\",\"image\": \"https://arielbecker.com/Clockchains/assets/img/chclocks.png\",\"external_link\": \"https://arielbecker.com/Clockchains\",\"seller_fee_basis_points\": 1000,\"fee_recipient\": \"0xC12Df5F402A8B8BEaea49ed9baD9c95fCcbfE907\"}';\r\n\r\n\tstring private _htmlTemplate = '';\r\n\r\n\t// Royalties\r\n\tuint256 private royalties_percentage = 10;\r\n\r\n\t// Other internal values\r\n\taddress private smart_contract_owner;\r\n\tCounters.Counter private _tokenIdTracker;\r\n\tbool private _preBigBang = true;\r\n\tbool private _frozen = false;\r\n\r\n\tconstructor(string memory name, string memory symbol, string memory baseTokenURI) ERC721(name, symbol) {\r\n\t\tsmart_contract_owner = _msgSender();\r\n\t}\r\n\r\n\tfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n\t\taddress temp = super.ownerOf(tokenId);\r\n\t\tif(temp == address(0)) {\r\n\t\t\treturn smart_contract_owner;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn temp;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _baseURI() internal view virtual override returns (string memory) {\r\n\t\treturn _baseTokenURI;\r\n\t}\r\n\r\n\tfunction tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\r\n\t\trequire(_tokenId >= 0, \"Token ID cannot be less than zero!\");\r\n\t\trequire(_tokenId < totalSupply(), \"Token ID out of bounds!\");\r\n\t\tstring memory baseURI = _baseURI();\r\n\t\treturn bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, \"?id=\", Strings.toString(_tokenId))) : \"\";\r\n\t}\r\n\r\n\tfunction contractURI() public view returns (string memory) {\r\n\t\treturn _contractURI;\r\n\t}\r\n\r\n\tfunction setContractURI(string memory _uri) public {\r\n\t\trequire(_msgSender() == smart_contract_owner, \"Not authorized!\");\r\n\t\trequire(_frozen == false, \"Contract is frozen!\");\r\n\t\t_contractURI = _uri;\r\n\t}\r\n\r\n\tfunction setContractJSON(string memory _json) public {\r\n\t\trequire(_msgSender() == smart_contract_owner, \"Not authorized!\");\r\n\t\trequire(_frozen == false, \"Contract is frozen!\");\r\n\t\t_contractJSON = _json;\r\n\t}\r\n\r\n\tfunction setBaseTokenURI(string memory _uri) public {\r\n\t\trequire(_msgSender() == smart_contract_owner, \"Not authorized!\");\r\n\t\trequire(_frozen == false, \"Contract is frozen!\");\r\n\t\t_baseTokenURI = _uri;\r\n\t}\r\n\r\n\tfunction setHTMLTemplate(string memory _html) public {\r\n\t\trequire(_msgSender() == smart_contract_owner, \"Not authorized!\");\r\n\t\trequire(_frozen == false, \"Contract is frozen!\");\r\n\t\t_htmlTemplate = _html;\r\n\t}\r\n\r\n\tfunction Freeze() public {\r\n\t\trequire(_msgSender() == smart_contract_owner, \"Not authorized!\");\r\n\t\trequire(_frozen == false, \"Contract is already frozen!\");\r\n\t\t_frozen = true;\r\n\t}\r\n\r\n\tfunction MassMint() public virtual {\r\n\t\trequire(_msgSender() == smart_contract_owner, \"Not authorized!\");\r\n\t\trequire(_preBigBang == true, \"Big Bang already happened!\");\r\n\t\trequire(_frozen == false, \"Contract is frozen!\");\r\n\r\n\t\t_bigbang();\r\n\t\t_preBigBang = false;\r\n\r\n\t\temit ConsecutiveTransfer(0, 364, address(0), 0xC12Df5F402A8B8BEaea49ed9baD9c95fCcbfE907);\r\n\t}\r\n\r\n\tfunction retrieveContractMetadata() public view returns (string memory) {\r\n\t\treturn _contractJSON;\r\n\t}\r\n\r\n\tfunction retrieveData(uint256 _tokenId) public view returns (string memory, string memory) {\r\n\t\trequire(_tokenId >= 0, \"Token ID out of bounds!\");\r\n\t\trequire(_tokenId < totalSupply(), \"Token ID out of bounds!\");\r\n\r\n\t\tstring memory data = _htmlTemplate;\r\n\t\tstring memory metadata = '';\r\n\r\n\t\tif(_tokenId >= 0 && _tokenId < 5) {\r\n\t\t\tmetadata = '{\"attributes\":[{\"trait_type\":\"Tier\",\"value\":\"Stygian Chronosphere\"},{\"trait_type\":\"Textcolor\",\"value\":\"#FF1A03\"},{\"trait_type\":\"Foreground\",\"value\":\"#FF1A03\"},{\"trait_type\":\"Background\",\"value\":\"#000000\"}]}';\r\n\t\t}\r\n\t\telse if(_tokenId > 4 && _tokenId < 25) {\r\n\t\t\tmetadata = '{\"attributes\":[{\"trait_type\":\"Tier\",\"value\":\"Taskukello\"},{\"trait_type\":\"Textcolor\",\"value\":\"#FFFFFF\"},{\"trait_type\":\"Foreground\",\"value\":\"#FFDB51\"},{\"trait_type\":\"Background\",\"value\":\"#000000\"}]}';\r\n\t\t}\r\n\t\telse if(_tokenId > 24 && _tokenId < 54) {\r\n\t\t\tmetadata = '{\"attributes\":[{\"trait_type\":\"Tier\",\"value\":\"Clepsydra\"},{\"trait_type\":\"Textcolor\",\"value\":\"#4639E5\"},{\"trait_type\":\"Foreground\",\"value\":\"#FFFFFF\"},{\"trait_type\":\"Background\",\"value\":\"#BAA86F\"}]}';\r\n\t\t}\r\n\t\telse if(_tokenId > 53 && _tokenId < 209) {\r\n\t\t\tmetadata = '{\"attributes\":[{\"trait_type\":\"Tier\",\"value\":\"Shizhong\"},{\"trait_type\":\"Textcolor\",\"value\":\"#FBF5E0\"},{\"trait_type\":\"Foreground\",\"value\":\"#FBF5E0\"},{\"trait_type\":\"Background\",\"value\":\"#1F456E\"}]}';\r\n\t\t}\r\n\t\telse if(_tokenId > 208 && _tokenId < 365) {\r\n\t\t\tmetadata = '{\"attributes\":[{\"trait_type\":\"Tier\",\"value\":\"Horologium\"},{\"trait_type\":\"Textcolor\",\"value\":\"#FFFFFF\"},{\"trait_type\":\"Foreground\",\"value\":\"#FFFFFF\"},{\"trait_type\":\"Background\",\"value\":\"#0C0033\"}]}';\r\n\t\t}\r\n\r\n\t\treturn(data, metadata);\r\n\t}\r\n\r\n\tfunction _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721, ERC721Enumerable) {\r\n\t\tsuper._beforeTokenTransfer(from, to, tokenId);\r\n\t}\r\n\r\n\tfunction hasRoyalties() public pure returns (bool) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction royaltyAmount() public view returns (uint256) {\r\n\t\treturn royalties_percentage;\r\n\t}\r\n\r\n\tfunction setRoyaltyAmount(uint256 newpercentage) public {\r\n\t\trequire(_frozen == false, \"Contract is frozen!\");\r\n\t\troyalties_percentage = newpercentage;\r\n\t}\r\n\r\n\tfunction royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view returns (address receiver, uint256 royaltiesAmount) {\r\n\t\trequire(_tokenId >= 0, \"Token ID cannot be less than zero!\");\r\n\t\trequire(_tokenId < totalSupply(), \"Token ID out of bounds!\");\r\n\t\tif(_salePrice > 99) { // Only makes sense to pay royalties if the sell value is more than 100 wei; otherwise, who cares?\r\n\t\t\tuint256 valorRoyalties = _salePrice.div(100).mul(royalties_percentage);\r\n\t\t\treturn(smart_contract_owner, valorRoyalties);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn(smart_contract_owner, 0);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction royaltiesReceived(address _creator, address _buyer, uint256 _amount) external {\r\n\t\temit ReceivedRoyalties(_creator, _buyer, _amount);\r\n\t}\r\n\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {\r\n\t\treturn interfaceId == 0x2a55205a || super.supportsInterface(interfaceId);\r\n\t}\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseTokenURI\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReceivedRoyalties\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Freeze\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MassMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_INTERFACE_ID_ERC2981\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"_addTokenToAllTokensEnumeration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasRoyalties\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retrieveContractMetadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"retrieveData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"royaltiesReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltiesAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setBaseTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_json\",\"type\":\"string\"}],\"name\":\"setContractJSON\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_html\",\"type\":\"string\"}],\"name\":\"setHTMLTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newpercentage\",\"type\":\"uint256\"}],\"name\":\"setRoyaltyAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Clockchains","CompilerVersion":"v0.8.6+commit.11564f7e","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"ipfs://c33f1902f8c011421e9838a4989e58c9818428521519abdc1f5c8407f0c3c56a"}]}