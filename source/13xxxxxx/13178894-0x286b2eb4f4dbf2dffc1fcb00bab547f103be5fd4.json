{"status":"1","message":"OK","result":[{"SourceCode":"{\"interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\npragma solidity ^0.8.7;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\n// Reflection\\ninterface IReflect {\\n    function tokenFromReflection(uint256 rAmount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getRate() external view returns (uint256);\\n}\\n\\n/// ChainLink ETH/USD oracle\\ninterface IChainLink {\\n    // chainlink ETH/USD oracle\\n    // answer|int256 :  216182781556 - 8 decimals\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\\n/// USDT is not ERC-20 compliant, not returning true on transfers\\ninterface IUsdt {\\n    function transfer(address, uint256) external;\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\\n// Check ETH send to first presale\\n// Yes, there is a typo\\ninterface IPresale1 {\\n    function blanceOf(address user) external view returns (uint256 amt);\\n}\\n\\n// Check tokens bought in second presale\\n// There is bug in ETH deposits, we need handle it\\n// Also \\\"tokensBoughtOf\\\" calculation is broken, so we do all math\\ninterface IPresale2 {\\n    function ethDepositOf(address user) external view returns (uint256 amt);\\n\\n    function usdDepositOf(address user) external view returns (uint256 amt);\\n}\\n\\n// Check final sale tokens bought\\ninterface ISale {\\n    function tokensBoughtOf(address user) external view returns (uint256 amt);\\n}\\n\\ninterface IClaimSale {\\n    function addLock(\\n        address user,\\n        uint256 reflection,\\n        uint256 locktime\\n    ) external;\\n}\\n\"},\"owned.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\npragma solidity ^0.8.7;\\n\\ncontract Owned {\\n    address public owner;\\n    address public newOwner;\\n\\n    event OwnershipChanged(address from, address to);\\n\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnershipChanged(address(0), msg.sender);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only owner\\\");\\n        _;\\n    }\\n\\n    // owner can give super-rights to someone\\n    function giveOwnership(address user) external onlyOwner {\\n        require(user != address(0), \\\"User renounceOwnership\\\");\\n        newOwner = user;\\n    }\\n\\n    // new owner need to accept\\n    function acceptOwnership() external {\\n        require(msg.sender == newOwner, \\\"Only NewOwner\\\");\\n        emit OwnershipChanged(owner, newOwner);\\n        owner = msg.sender;\\n        delete newOwner;\\n    }\\n}\\n\"},\"public-sale.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\n/**\\nApes Together Strong!\\n\\nAbout BigShortBets DeFi project:\\n\\nWe are creating a social\\u0026trading p2p platform that guarantees encrypted interaction between investors.\\nLogging in is possible via a cryptocurrency wallet (e.g. Metamask).\\nThe security level is one comparable to the Tor network.\\n\\nhttps://bigsb.io/ - Our Tool\\nhttps://bigshortbets.com - Project\\u0026Team info\\n\\nVideo explainer:\\nhttps://youtu.be/wbhUo5IvKdk\\n\\nZaorski, You Son of a bitch I’m in …\\n*/\\n\\npragma solidity 0.8.7;\\nimport \\\"./owned.sol\\\";\\nimport \\\"./reentryGuard.sol\\\";\\nimport \\\"./interfaces.sol\\\";\\n\\ncontract BigSBPublicSale is Owned, Guarded {\\n    constructor(\\n        address usdc,\\n        address usdt,\\n        address dai,\\n        address token,\\n        address oracle,\\n        uint256 amlLimit,\\n        Step[] memory steps\\n    ) {\\n        DAI = dai;\\n        USDT = usdt;\\n        USDC = usdc;\\n        BigSBaddress = token;\\n        ChainLinkOracle = oracle;\\n        uint256 i;\\n        for (i; i \\u003c steps.length; i++) {\\n            saleSteps.push(steps[i]);\\n        }\\n        // sale ends in 2 years\\n        saleEnd = block.timestamp + 730 days;\\n        maxDollarsPerUser = amlLimit;\\n    }\\n\\n    // Claim contract that earn from fees\\n    address public claimContract;\\n\\n    /// Struct decribing sale steps\\n    struct Step {\\n        uint256 lockLength; // how long tokens will be locked in contract (time in seconds)\\n        uint256 maxTokensPerUSD; // initial, maximum tokens per USD (min price)\\n        uint256 tokensPerUSD; // price in for given step\\n        uint256 tokenAmount; // how much tokens left on sale in this step (18 decimals)\\n    }\\n\\n    /// Array of sale steps\\n    Step[] public saleSteps;\\n\\n    /// last used step to not iterate full array every time\\n    uint256 public currentSaleStep;\\n\\n    /// token address\\n    address public immutable BigSBaddress;\\n\\n    /// Contract to get current ETH price\\n    address public immutable ChainLinkOracle;\\n\\n    // stablecoins addresses\\n    address public immutable DAI;\\n    address public immutable USDT;\\n    address public immutable USDC;\\n\\n    /// dollars per user\\n    mapping(address =\\u003e uint256) public dollarsIn;\\n\\n    /// aml limit (6 decimals)\\n    uint256 public maxDollarsPerUser;\\n\\n    /// timestamp when owner can take all not sold tokens\\n    uint256 public immutable saleEnd;\\n\\n    // ETH buy functions need 200k gas limit\\n    receive() external payable {\\n        _buyEth();\\n    }\\n\\n    /// buy for ETH using DApp\\n    function buyEth() external payable {\\n        _buyEth();\\n    }\\n\\n    // Calculate USD value and make transaction if possible\\n    function _buyEth() internal guarded {\\n        uint256 price = EthPrice();\\n        uint256 dollars = (msg.value * price) / 1 ether;\\n        uint256 refund = _buy(dollars);\\n        if (refund \\u003e 0) {\\n            require(\\n                payable(msg.sender).send((refund * 1 ether) / price),\\n                \\\"Refund failed\\\"\\n            );\\n        }\\n    }\\n\\n    // Stablecoins buy need 300k gas limit\\n\\n    /// buy for USDT using DApp, need approve first!\\n    function buyUsdt(uint256 amt) external guarded {\\n        // accept USDT token, it is not proper ERC20\\n        IUsdt(USDT).transferFrom(msg.sender, address(this), amt);\\n        uint256 refund = _buy(amt);\\n        if (refund \\u003e 0) {\\n            IUsdt(USDT).transfer(msg.sender, refund);\\n        }\\n    }\\n\\n    /// buy for DAI using DApp, need approve first!\\n    function buyDai(uint256 amt) external guarded {\\n        // accept DAI token\\n        require(\\n            IERC20(DAI).transferFrom(msg.sender, address(this), amt),\\n            \\\"DAI transfer failed\\\"\\n        );\\n        // dai uses 18 decimals, we need only 6\\n        uint256 refund = _buy(amt / (10**12));\\n        if (refund \\u003e 0) {\\n            require(\\n                IERC20(DAI).transfer(msg.sender, refund * 10**12),\\n                \\\"Refund failed\\\"\\n            );\\n        }\\n    }\\n\\n    /// buy for USDC using DApp, need approve first!\\n    function buyUsdc(uint256 amt) external guarded {\\n        // accept USDC token\\n        require(\\n            IERC20(USDC).transferFrom(msg.sender, address(this), amt),\\n            \\\"USDC transfer failed\\\"\\n        );\\n        uint256 refund = _buy(amt);\\n        if (refund \\u003e 0) {\\n            require(IERC20(USDC).transfer(msg.sender, refund), \\\"Refund failed\\\");\\n        }\\n    }\\n\\n    // buy tokens for current step price\\n    // dollars with 6 decimals\\n    // move to next step if needed\\n    // make separate locks if passing threshold\\n    function _buy(uint256 dollars) internal returns (uint256 refund) {\\n        require(currentSaleStep \\u003c saleSteps.length, \\\"Sale is over\\\");\\n        require(claimContract != address(0), \\\"Claim not configured\\\");\\n        uint256 sum = dollarsIn[msg.sender] + dollars;\\n        require(sum \\u003c maxDollarsPerUser, \\\"Over AML limit\\\");\\n        dollarsIn[msg.sender] = sum;\\n\\n        uint256 numLocks;\\n\\n        Step memory s = saleSteps[currentSaleStep];\\n        uint256 tokens = (dollars * s.tokensPerUSD) / 1000000;\\n        uint256 timeNow = block.timestamp;\\n        uint256 toSale = s.tokenAmount;\\n\\n        uint256 toSend;\\n\\n        // check for step change\\n        if (tokens \\u003e toSale) {\\n            // set user lock at this step\\n            uint256 reflection = IReflect(BigSBaddress).reflectionFromToken(\\n                toSale,\\n                false\\n            );\\n            IClaimSale(claimContract).addLock(\\n                msg.sender,\\n                reflection,\\n                timeNow + s.lockLength\\n            );\\n\\n            numLocks++;\\n            toSend = toSale;\\n            // no more for this price\\n            saleSteps[currentSaleStep].tokenAmount = 0;\\n\\n            // calculate remaning USD\\n            dollars = ((tokens - toSale) * 1000000) / s.tokensPerUSD;\\n            // advance to next sale step\\n            currentSaleStep++;\\n            if (currentSaleStep == saleSteps.length) {\\n                // send tokens to claim contract\\n                require(\\n                    IERC20(BigSBaddress).transfer(claimContract, toSend),\\n                    \\\"Transfer failed\\\"\\n                );\\n                // no more steps, refund whats left\\n                return dollars;\\n            }\\n            // recalculate tokens\\n            tokens =\\n                (dollars * saleSteps[currentSaleStep].tokensPerUSD) /\\n                1000000;\\n        }\\n\\n        // do not add empty lock\\n        if (tokens \\u003e 0) {\\n            uint256 amt = IReflect(BigSBaddress).reflectionFromToken(\\n                tokens,\\n                false\\n            );\\n\\n            saleSteps[currentSaleStep].tokenAmount -= tokens;\\n            // make user lock\\n            IClaimSale(claimContract).addLock(\\n                msg.sender,\\n                amt,\\n                saleSteps[currentSaleStep].lockLength + timeNow\\n            );\\n            numLocks++;\\n            toSend += tokens;\\n        }\\n        // ensure any lock is added\\n        require(numLocks \\u003e 0, \\\"Nothing sold\\\");\\n        require(\\n            IERC20(BigSBaddress).transfer(claimContract, toSend),\\n            \\\"Transfer failed\\\"\\n        );\\n        return 0;\\n    }\\n\\n    //\\n    // Viewers\\n    //\\n\\n    /**\\n        What is current token price?\\n     */\\n    function currentPrice() external view returns (uint256) {\\n        return saleSteps[currentSaleStep].tokensPerUSD;\\n    }\\n\\n    /**\\n        How many tokens left on current price?\\n    */\\n    function tokensLeftInStep() external view returns (uint256) {\\n        if (currentSaleStep \\u003c saleSteps.length) {\\n            return saleSteps[currentSaleStep].tokenAmount;\\n        } else return 0;\\n    }\\n\\n    /**\\n    Get ETH price from Chainlink.\\n    @return ETH price in USD with 6 decimals\\n    */\\n    function EthPrice() public view returns (uint256) {\\n        int256 answer;\\n        (, answer, , , ) = IChainLink(ChainLinkOracle).latestRoundData();\\n        // answer is 8 decimals, we need 6 as in stablecoins\\n        return uint256(answer / 100);\\n    }\\n\\n    //\\n    // Rick mode\\n    //\\n\\n    // Set claim contract address (once)\\n    function setClaimContract(address claimAddress) external onlyOwner {\\n        require(claimContract == address(0), \\\"Already set\\\");\\n        claimContract = claimAddress;\\n    }\\n\\n    /**\\n        Update sale ratio of next sale step when needed\\n        Can be only lower than configured on deploy\\n        @param tokensPerUSD updated ratio\\n    */\\n    function updatePrice(uint256 tokensPerUSD) external onlyOwner {\\n        require(\\n            tokensPerUSD \\u003c= saleSteps[currentSaleStep + 1].maxTokensPerUSD,\\n            \\\"Too high ratio\\\"\\n        );\\n        saleSteps[currentSaleStep + 1].tokensPerUSD = tokensPerUSD;\\n    }\\n\\n    /**\\n        Set AML limit in USD with 6 decimals\\n    */\\n    function updateUsdLimit(uint256 limit) external onlyOwner {\\n        maxDollarsPerUser = limit;\\n    }\\n\\n    /**\\n        Take ETH from contract\\n    */\\n    function withdrawEth() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n\\n    /**\\n        Take any ERC20 from contract (excl BigSB)\\n    */\\n    function withdrawErc20(address token) external onlyOwner {\\n        require(token != BigSBaddress, \\\"Lol, no\\\");\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        require(balance \\u003e 0, \\\"Nothing to withdraw\\\");\\n        // use broken IERC20\\n        IUsdt(token).transfer(owner, balance);\\n    }\\n\\n    /// emergency token withdraw possible after 2 years\\n    function withdrawBigSB(uint256 amt) external onlyOwner {\\n        require(block.timestamp \\u003e saleEnd, \\\"Too soon\\\");\\n        uint256 balance = IERC20(BigSBaddress).balanceOf(address(this));\\n        require(amt \\u003c= balance, \\\"Too much\\\");\\n        require(IERC20(BigSBaddress).transfer(owner, amt), \\\"Transfer failed\\\");\\n    }\\n}\\n\\n//This is fine!\\n\"},\"reentryGuard.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\npragma solidity ^0.8.7;\\n\\ncontract Guarded {\\n    uint256 constant NOT_ENTERED = 1;\\n    uint256 constant ENTERED = 2;\\n    uint256 entryState = NOT_ENTERED;\\n\\n    modifier guarded() {\\n        require(entryState == NOT_ENTERED, \\\"Reentry\\\");\\n        entryState = ENTERED;\\n        _;\\n        entryState = NOT_ENTERED;\\n    }\\n}\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usdc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dai\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amlLimit\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lockLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokensPerUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensPerUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct BigSBPublicSale.Step[]\",\"name\":\"steps\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BigSBaddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ChainLinkOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EthPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"buyDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"buyUsdc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"buyUsdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentSaleStep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dollarsIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"giveOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDollarsPerUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"saleSteps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTokensPerUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensPerUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimAddress\",\"type\":\"address\"}],\"name\":\"setClaimContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensLeftInStep\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensPerUSD\",\"type\":\"uint256\"}],\"name\":\"updatePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"updateUsdLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"withdrawBigSB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"BigSBPublicSale","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000dac17f958d2ee523a2206206994597c13d831ec70000000000000000000000006b175474e89094c44da98b954eedeac495271d0f000000000000000000000000131157c6760f78f7ddf877c0019eba175ba4b6f60000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b841900000000000000000000000000000000000000000000000000000003f5476a0000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000000000000ed4e0000000000000000000000000000000000000000000000000006f05b59d3b2000000000000000000000000000000000000000000000000000006f05b59d3b20000000000000000000000000000000000000000000000084595161401484a000000000000000000000000000000000000000000000000000000000000000114db00000000000000000000000000000000000000000000000000069bc4b712c1e6e0000000000000000000000000000000000000000000000000069bc4b712c1e6e0000000000000000000000000000000000000000000084595161401484a00000000000000000000000000000000000000000000000000000000000000013c6800000000000000000000000000000000000000000000000000064edeaec0734798000000000000000000000000000000000000000000000000064edeaec0734798000000000000000000000000000000000000000000084595161401484a000000000000000000000000000000000000000000000000000000000000000163f5000000000000000000000000000000000000000000000000000608a87aa1d26ea00000000000000000000000000000000000000000000000000608a87aa1d26ea0000000000000000000000000000000000000000000084595161401484a00000000000000000000000000000000000000000000000000000000000000018b820000000000000000000000000000000000000000000000000005c84c203069abf800000000000000000000000000000000000000000000000005c84c203069abf8000000000000000000000000000000000000000000084595161401484a0000000000000000000000000000000000000000000000000000000000000001b30f0000000000000000000000000000000000000000000000000005566da78f2677a800000000000000000000000000000000000000000000000005566da78f2677a8000000000000000000000000000000000000000000084595161401484a0000000000000000000000000000000000000000000000000000000000000001da9c0000000000000000000000000000000000000000000000000004a03ce68d21540800000000000000000000000000000000000000000000000004a03ce68d215408000000000000000000000000000000000000000000084595161401484a000000","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://7f90842c58c454ee20bb2041dfc1596eef63933f8c05d5e826918197a13bdb0d"}]}