{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ButtonTokenWethRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"./interfaces/IButtonWrapper.sol\\\";\\nimport \\\"./interfaces/IRebasingERC20.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\n\\n/**\\n * @dev Router to automatically wrap ETH into WETH for ButtonToken actions\\n */\\ncontract ButtonTokenWethRouter is ReentrancyGuard {\\n    IWETH9 public weth;\\n\\n    constructor(address _weth) {\\n        weth = IWETH9(_weth);\\n    }\\n\\n    receive() external payable {\\n        require(msg.sender == address(weth), \\\"ButtonTokenWethRouter: unexpected receive\\\");\\n    }\\n\\n    /**\\n     * @dev Deposit the given amount of ETH into the given ButtonToken\\n     *  Returns the output buttonTokens to the user.\\n     *\\n     * @param buttonToken the button token to deposit into\\n     * @return The amount of ButtonTokens created\\n     */\\n    function deposit(address buttonToken) external payable nonReentrant returns (uint256) {\\n        uint256 value = msg.value;\\n        require(value > 0, \\\"ButtonTokenWethRouter: No ETH supplied\\\");\\n        weth.deposit{value: msg.value}();\\n        weth.approve(buttonToken, value);\\n        return IButtonWrapper(buttonToken).depositFor(msg.sender, value);\\n    }\\n\\n    /**\\n     * @dev Withdraw the given amount of button tokens from the given ButtonToken\\n     *  Returns the output ETH to the user\\n     *\\n     * @param buttonToken the button token to burn from\\n     * @param amount The amount of ButtonTokens to burn\\n     * @return The amount of ButtonTokens burned\\n     */\\n    function burn(address buttonToken, uint256 amount) external nonReentrant returns (uint256) {\\n        IRebasingERC20(buttonToken).transferFrom(msg.sender, address(this), amount);\\n        IButtonWrapper(buttonToken).burn(amount);\\n        weth.withdraw(weth.balanceOf(address(this)));\\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\\\"\\\");\\n        require(success, \\\"Failed to send ETH\\\");\\n        return amount;\\n    }\\n\\n    /**\\n     * @dev Withdraw all button tokens from the given ButtonToken\\n     *  Returns the output ETH to the user\\n     *\\n     * @param buttonToken the button token to burn from\\n     * @return The amount of ButtonTokens burned\\n     */\\n    function burnAll(address buttonToken) external nonReentrant returns (uint256) {\\n        IRebasingERC20(buttonToken).transferAllFrom(msg.sender, address(this));\\n        uint256 amount = IButtonWrapper(buttonToken).burnAll();\\n        weth.withdraw(weth.balanceOf(address(this)));\\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\\\"\\\");\\n        require(success, \\\"Failed to send ETH\\\");\\n        return amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IButtonWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\n// Interface definition for ButtonWrapper contract, which wraps an\\n// underlying ERC20 token into a new ERC20 with different characteristics.\\n// NOTE: \\\"uAmount\\\" => underlying token (wrapped) amount and\\n//       \\\"amount\\\" => wrapper token amount\\ninterface IButtonWrapper {\\n    //--------------------------------------------------------------------------\\n    // ButtonWrapper write methods\\n\\n    /// @notice Transfers underlying tokens from {msg.sender} to the contract and\\n    ///         mints wrapper tokens.\\n    /// @param amount The amount of wrapper tokens to mint.\\n    /// @return The amount of underlying tokens deposited.\\n    function mint(uint256 amount) external returns (uint256);\\n\\n    /// @notice Transfers underlying tokens from {msg.sender} to the contract and\\n    ///         mints wrapper tokens to the specified beneficiary.\\n    /// @param to The beneficiary account.\\n    /// @param amount The amount of wrapper tokens to mint.\\n    /// @return The amount of underlying tokens deposited.\\n    function mintFor(address to, uint256 amount) external returns (uint256);\\n\\n    /// @notice Burns wrapper tokens from {msg.sender} and transfers\\n    ///         the underlying tokens back.\\n    /// @param amount The amount of wrapper tokens to burn.\\n    /// @return The amount of underlying tokens withdrawn.\\n    function burn(uint256 amount) external returns (uint256);\\n\\n    /// @notice Burns wrapper tokens from {msg.sender} and transfers\\n    ///         the underlying tokens to the specified beneficiary.\\n    /// @param to The beneficiary account.\\n    /// @param amount The amount of wrapper tokens to burn.\\n    /// @return The amount of underlying tokens withdrawn.\\n    function burnTo(address to, uint256 amount) external returns (uint256);\\n\\n    /// @notice Burns all wrapper tokens from {msg.sender} and transfers\\n    ///         the underlying tokens back.\\n    /// @return The amount of underlying tokens withdrawn.\\n    function burnAll() external returns (uint256);\\n\\n    /// @notice Burns all wrapper tokens from {msg.sender} and transfers\\n    ///         the underlying tokens back.\\n    /// @param to The beneficiary account.\\n    /// @return The amount of underlying tokens withdrawn.\\n    function burnAllTo(address to) external returns (uint256);\\n\\n    /// @notice Transfers underlying tokens from {msg.sender} to the contract and\\n    ///         mints wrapper tokens to the specified beneficiary.\\n    /// @param uAmount The amount of underlying tokens to deposit.\\n    /// @return The amount of wrapper tokens mint.\\n    function deposit(uint256 uAmount) external returns (uint256);\\n\\n    /// @notice Transfers underlying tokens from {msg.sender} to the contract and\\n    ///         mints wrapper tokens to the specified beneficiary.\\n    /// @param to The beneficiary account.\\n    /// @param uAmount The amount of underlying tokens to deposit.\\n    /// @return The amount of wrapper tokens mint.\\n    function depositFor(address to, uint256 uAmount) external returns (uint256);\\n\\n    /// @notice Burns wrapper tokens from {msg.sender} and transfers\\n    ///         the underlying tokens back.\\n    /// @param uAmount The amount of underlying tokens to withdraw.\\n    /// @return The amount of wrapper tokens burnt.\\n    function withdraw(uint256 uAmount) external returns (uint256);\\n\\n    /// @notice Burns wrapper tokens from {msg.sender} and transfers\\n    ///         the underlying tokens back to the specified beneficiary.\\n    /// @param to The beneficiary account.\\n    /// @param uAmount The amount of underlying tokens to withdraw.\\n    /// @return The amount of wrapper tokens burnt.\\n    function withdrawTo(address to, uint256 uAmount) external returns (uint256);\\n\\n    /// @notice Burns all wrapper tokens from {msg.sender} and transfers\\n    ///         the underlying tokens back.\\n    /// @return The amount of wrapper tokens burnt.\\n    function withdrawAll() external returns (uint256);\\n\\n    /// @notice Burns all wrapper tokens from {msg.sender} and transfers\\n    ///         the underlying tokens back.\\n    /// @param to The beneficiary account.\\n    /// @return The amount of wrapper tokens burnt.\\n    function withdrawAllTo(address to) external returns (uint256);\\n\\n    //--------------------------------------------------------------------------\\n    // ButtonWrapper view methods\\n\\n    /// @return The address of the underlying token.\\n    function underlying() external view returns (address);\\n\\n    /// @return The total underlying tokens held by the wrapper contract.\\n    function totalUnderlying() external view returns (uint256);\\n\\n    /// @param who The account address.\\n    /// @return The underlying token balance of the account.\\n    function balanceOfUnderlying(address who) external view returns (uint256);\\n\\n    /// @param uAmount The amount of underlying tokens.\\n    /// @return The amount of wrapper tokens exchangeable.\\n    function underlyingToWrapper(uint256 uAmount) external view returns (uint256);\\n\\n    /// @param amount The amount of wrapper tokens.\\n    /// @return The amount of underlying tokens exchangeable.\\n    function wrapperToUnderlying(uint256 amount) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRebasingERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\n// Interface definition for Rebasing ERC20 tokens which have a \\\"elastic\\\" external\\n// balance and \\\"fixed\\\" internal balance. Each user's external balance is\\n// represented as a product of a \\\"scalar\\\" and the user's internal balance.\\n//\\n// From time to time the \\\"Rebase\\\" event updates scaler,\\n// which increases/decreases all user balances proportionally.\\n//\\n// The standard ERC-20 methods are denominated in the elastic balance\\n//\\ninterface IRebasingERC20 is IERC20, IERC20Metadata {\\n    /// @notice Returns the fixed balance of the specified address.\\n    /// @param who The address to query.\\n    function scaledBalanceOf(address who) external view returns (uint256);\\n\\n    /// @notice Returns the total fixed supply.\\n    function scaledTotalSupply() external view returns (uint256);\\n\\n    /// @notice Transfer all of the sender's balance to a specified address.\\n    /// @param to The address to transfer to.\\n    /// @return True on success, false otherwise.\\n    function transferAll(address to) external returns (bool);\\n\\n    /// @notice Transfer all balance tokens from one address to another.\\n    /// @param from The address to send tokens from.\\n    /// @param to The address to transfer to.\\n    function transferAllFrom(address from, address to) external returns (bool);\\n\\n    /// @notice Triggers the next rebase, if applicable.\\n    function rebase() external;\\n\\n    /// @notice Event emitted when the balance scalar is updated.\\n    /// @param epoch The number of rebases since inception.\\n    /// @param newScalar The new scalar.\\n    event Rebase(uint256 indexed epoch, uint256 newScalar);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"interface IWETH9 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function approve(address guy, uint256 wad) external returns (bool);\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 wad\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buttonToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buttonToken\",\"type\":\"address\"}],\"name\":\"burnAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buttonToken\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH9\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ButtonTokenWethRouter","CompilerVersion":"v0.8.4+commit.c7e474f2","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}