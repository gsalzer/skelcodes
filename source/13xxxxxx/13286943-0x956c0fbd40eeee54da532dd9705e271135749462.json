{"status":"1","message":"OK","result":[{"SourceCode":"{\"interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSE\\n\\npragma solidity ^0.8.7;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\n// Interfaces for contract interaction\\ninterface INterfaces {\\n    function balanceOf(address) external returns (uint256);\\n\\n    function transfer(address, uint256) external returns (bool);\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n}\\n\\n// For tokens that do not return true on transfers eg. USDT\\ninterface INterfacesNoR {\\n    function transfer(address, uint256) external;\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\"},\"TattooMoneyV1toV2SWAP.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.7;\\n\\n// TattooMoney.io TattooMoney Token SWAP Contract\\n//\\n// USE ONLY OWN WALLET (Metamask, TrustWallet, Trezor, Ledger...)\\n// DO NOT DO DIRECT SEND OR FROM EXCHANGES OR ANY SERVICES\\n//\\n// Use ONLY ETH network, ERC20 TAT2 tokens (Not Binance/Tron/whatever!)\\n//\\n// Set approval to contract address before using swap!\\n//\\n// DO NOT SEND ANY TOKENS DIRECTLY - THEY WILL BE GONE FOREVER!\\n//\\n// Use swap function!\\n\\nimport \\\"./interfaces.sol\\\";\\n\\ncontract TattooMoneyV1toV2SWAP {\\n\\n    // addresses of tokens\\n    address public immutable newtat2;\\n    uint8 public constant newtat2decimals = 18;\\n    address public immutable oldtat2;\\n    uint8 public constant oldtat2decimals = 6;\\n\\n    address public owner;\\n    address public newOwner;\\n\\n    string constant ERR_TRANSFER = \\\"Token transfer failed\\\";\\n\\n    event Swapped(address indexed sender, uint256 indexed amount, uint256 indexed newamount);\\n    event Tokens(uint256 indexed amount);\\n    event Burned(uint256 indexed amount);\\n\\n    /**\\n    Contract constructor\\n    @param _owner adddress of contract owner\\n    @param _oldtat2 adddress of old contract\\n    @param _newtat2 adddress of new contract\\n     */\\n\\n    constructor(\\n        address _owner,\\n        address _oldtat2,\\n        address _newtat2\\n    ) {\\n        owner = _owner;\\n        oldtat2 = _oldtat2;\\n        newtat2 = _newtat2;\\n\\n        /**\\n        mainnet:\\n        oldTAT2=0x960773318c1aeab5da6605c49266165af56435fa; // Old Token SmartContract\\n        newTAT2=0xb487d0328b109e302b9d817b6f46Cbd738eA08C2;  // new Token SmartContract\\n        */\\n    }\\n\\n    /**\\n    Get NEW TAT2, use approve/transferFrom\\n    @param amount number of old TAT2\\n    */\\n    function swap(uint256 amount) external {\\n        uint8 decimals = newtat2decimals - oldtat2decimals;\\n        uint256 newamount = amount * (10 ** decimals);\\n        require(\\n            INterfaces(oldtat2).transferFrom(msg.sender, address(this), amount),\\n            ERR_TRANSFER\\n        );\\n        require(\\n            INterfaces(newtat2).transfer(msg.sender, newamount),\\n            ERR_TRANSFER\\n        );\\n        emit Swapped(msg.sender, amount, newamount);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"Only for contract Owner\\\");\\n        _;\\n    }\\n\\n    /// Let\\u0027s burn OLD tokens\\n    function burn() external onlyOwner {\\n      uint256 amt = INterfaces(oldtat2).balanceOf(address(this));\\n      emit Tokens(amt);\\n      require(\\n          INterfaces(oldtat2).transfer(address(0), amt),\\n          ERR_TRANSFER\\n      );\\n      emit Burned(amt);\\n    }\\n\\n    /// we can recover any ERC20\\n    function recoverErc20(address token) external onlyOwner {\\n        uint256 amt = INterfaces(token).balanceOf(address(this));\\n        if (amt \\u003e 0) {\\n            INterfacesNoR(token).transfer(owner, amt); // use broken ERC20 to ignore return value\\n        }\\n    }\\n\\n    /// be preapared for everything, ETH recovery\\n    function recoverEth() external onlyOwner {\\n        payable(owner).transfer(address(this).balance);\\n    }\\n\\n    function changeOwner(address _newOwner) external onlyOwner {\\n        newOwner = _newOwner;\\n    }\\n\\n    function acceptOwnership() external {\\n        require(\\n            msg.sender != address(0) \\u0026\\u0026 msg.sender == newOwner,\\n            \\\"Only NewOwner\\\"\\n        );\\n        newOwner = address(0);\\n        owner = msg.sender;\\n    }\\n}\\n\\n// by Patrick\\n\"}}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oldtat2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newtat2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newamount\",\"type\":\"uint256\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Tokens\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newtat2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newtat2decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldtat2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldtat2decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"recoverErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TattooMoneyV1toV2SWAP","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009f8e0bdada7ba929509ce92cbbbed0fb129c8832000000000000000000000000960773318c1aeab5da6605c49266165af56435fa000000000000000000000000b487d0328b109e302b9d817b6f46cbd738ea08c2","EVMVersion":"Default","Library":"","LicenseType":"Unlicense","Proxy":"0","Implementation":"","SwarmSource":"ipfs://6a79922d2e8889c1f46485ada6e2252dfb7e450959b80055e6f189cd5bdb41e3"}]}