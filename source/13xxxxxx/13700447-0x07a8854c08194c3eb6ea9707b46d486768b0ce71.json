{"status":"1","message":"OK","result":[{"SourceCode":"{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/traits/Traits.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"../IVampireGame.sol\\\";\\nimport \\\"./TraitMetadata.sol\\\";\\nimport \\\"./TraitDraw.sol\\\";\\nimport \\\"./TokenTraits.sol\\\";\\nimport \\\"./Base64.sol\\\";\\nimport \\\"./ITraits.sol\\\";\\n\\ncontract Traits is Ownable, ITraits {\\n    using Strings for uint256;\\n\\n    /// ==== Structs\\n\\n    /// @dev struct to store each trait name and base64 encoded image\\n    struct Trait {\\n        string name;\\n        string png;\\n    }\\n\\n    /// ==== Immutable\\n\\n    /// @notice traits mapping\\n    /// 0~8 Vampire; 9~17 Humans.\\n    mapping(uint8 => mapping(uint8 => Trait)) public traitData;\\n\\n    /// @dev mapping from predator index to predator score\\n    string[4] private predatorScores = [\\\"8\\\", \\\"7\\\", \\\"6\\\", \\\"5\\\"];\\n\\n    IVampireGame public vgame;\\n\\n    string unrevealedImage;\\n\\n    // ==== Mutable\\n\\n    constructor() {}\\n\\n    /// ==== Internal\\n\\n    /// @dev return the SVG of a Vampire\\n    /// make sure the token is actually a Vampire by checking tt.isVampire before calling this function\\n    /// @param tt the token traits\\n    /// @return the svg string of the vampire\\n    function makeVampireSVG(TokenTraits memory tt)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        string[] memory images = new string[](5);\\n        images[3] = TraitDraw.drawImageTag(traitData[16][tt.cape].png);\\n        images[0] = TraitDraw.drawImageTag(traitData[9][tt.skin].png);\\n        images[2] = TraitDraw.drawImageTag(traitData[11][tt.clothes].png);\\n        images[1] = TraitDraw.drawImageTag(traitData[10][tt.face].png);\\n        images[4] = TraitDraw.drawImageTag(traitData[17][tt.predatorIndex].png);\\n        return TraitDraw.drawSVG(images);\\n    }\\n\\n    /// @dev return the SVG of a Human\\n    /// make sure the token is actually a Human by checking tt.isVampire before calling this function\\n    /// @param tt the token traits\\n    /// @return the svg string of the human\\n    function makeHumanSVG(TokenTraits memory tt)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        string[] memory images = new string[](7);\\n        images[0] = TraitDraw.drawImageTag(traitData[0][tt.skin].png);\\n        images[4] = TraitDraw.drawImageTag(traitData[4][tt.boots].png);\\n        images[3] = TraitDraw.drawImageTag(traitData[3][tt.pants].png);\\n        images[1] = TraitDraw.drawImageTag(traitData[1][tt.face].png);\\n        images[6] = TraitDraw.drawImageTag(traitData[6][tt.hair].png);\\n        images[2] = TraitDraw.drawImageTag(traitData[2][tt.clothes].png);\\n        images[5] = TraitDraw.drawImageTag(traitData[5][tt.accessory].png);\\n        return TraitDraw.drawSVG(images);\\n    }\\n\\n    /// @dev return the metadata attributes of a Vampire\\n    /// make sure the token is actually a Vampire by checking tt.isVampire before calling this function\\n    /// @param tt the token traits\\n    /// @param genZero if the token is part of the first 20% tokens\\n    /// @return the JSON metadata string of the Vampire\\n    function makeVampireMetadata(TokenTraits memory tt, bool genZero)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        string[] memory attributes = new string[](7);\\n        attributes[0] = TraitMetadata.makeAttributeJSON(\\\"Type\\\", \\\"Vampire\\\");\\n        attributes[1] = TraitMetadata.makeAttributeJSON(\\n            \\\"Generation\\\",\\n            genZero ? \\\"Gen 0\\\" : \\\"Gen 1\\\"\\n        );\\n        attributes[2] = TraitMetadata.makeAttributeJSON(\\n            \\\"Skin\\\",\\n            traitData[0][tt.skin].name\\n        );\\n        attributes[3] = TraitMetadata.makeAttributeJSON(\\n            \\\"Face\\\",\\n            traitData[1][tt.face].name\\n        );\\n        attributes[4] = TraitMetadata.makeAttributeJSON(\\n            \\\"Clothes\\\",\\n            traitData[2][tt.clothes].name\\n        );\\n        attributes[5] = TraitMetadata.makeAttributeJSON(\\n            \\\"Cape\\\",\\n            traitData[7][tt.cape].name\\n        );\\n        attributes[6] = TraitMetadata.makeAttributeJSON(\\n            \\\"Predator Score\\\",\\n            predatorScores[tt.predatorIndex]\\n        );\\n        return TraitMetadata.makeAttributeListJSON(attributes);\\n    }\\n\\n    /// @dev return the metadata attributes of a Human\\n    /// make sure the token is actually a Human by checking tt.isVampire before calling this function\\n    /// @param tt the token traits\\n    /// @param genZero if the token is part of the first 20% tokens\\n    /// @return the JSON metadata string of the Human\\n    function makeHumanMetadata(TokenTraits memory tt, bool genZero)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        string[] memory attributes = new string[](9);\\n        attributes[0] = TraitMetadata.makeAttributeJSON(\\\"Type\\\", \\\"Human\\\");\\n        attributes[1] = TraitMetadata.makeAttributeJSON(\\n            \\\"Generation\\\",\\n            genZero ? \\\"Gen 0\\\" : \\\"Gen 1\\\"\\n        );\\n        attributes[2] = TraitMetadata.makeAttributeJSON(\\n            \\\"Skin\\\",\\n            traitData[0][tt.skin].name\\n        );\\n        attributes[3] = TraitMetadata.makeAttributeJSON(\\n            \\\"Face\\\",\\n            traitData[1][tt.face].name\\n        );\\n        attributes[4] = TraitMetadata.makeAttributeJSON(\\n            \\\"T-Shirt\\\",\\n            traitData[2][tt.clothes].name\\n        );\\n        attributes[5] = TraitMetadata.makeAttributeJSON(\\n            \\\"Pants\\\",\\n            traitData[3][tt.pants].name\\n        );\\n        attributes[6] = TraitMetadata.makeAttributeJSON(\\n            \\\"Boots\\\",\\n            traitData[4][tt.boots].name\\n        );\\n        attributes[7] = TraitMetadata.makeAttributeJSON(\\n            \\\"Accessory\\\",\\n            traitData[5][tt.accessory].name\\n        );\\n        attributes[8] = TraitMetadata.makeAttributeJSON(\\n            \\\"Hair\\\",\\n            traitData[6][tt.hair].name\\n        );\\n        return TraitMetadata.makeAttributeListJSON(attributes);\\n    }\\n\\n    /// ==== Public / View\\n\\n    /// @notice return the svg for a specific tokenId\\n    /// using to help with testing and debugging\\n    /// @param tokenId the id of the token to draw the SVG\\n    /// @return string with the svg tag with all the token layers assembled\\n    function tokenSVG(uint256 tokenId) public view returns (string memory) {\\n        TokenTraits memory tt = vgame.getTokenTraits(tokenId);\\n        return tt.isVampire ? makeVampireSVG(tt) : makeHumanSVG(tt);\\n    }\\n\\n    /// @notice generates the metadata for a token\\n    /// @param tokenId the token id\\n    /// @return a string with a JSON array containing the traits\\n    function tokenMetadata(uint256 tokenId)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        if (vgame.isTokenRevealed(tokenId)) {\\n            TokenTraits memory tt = vgame.getTokenTraits(tokenId);\\n            bool genZero = tokenId <= vgame.getGenZeroSupply();\\n\\n            return\\n                TraitMetadata.makeMetadata(\\n                    abi.encodePacked(\\n                        tt.isVampire ? \\\"Vampire #\\\" : \\\"Human #\\\",\\n                        tokenId.toString()\\n                    ),\\n                    \\\"The world has ended and humanity lost. Vampires rule over mankind with no mercy, locking Humans away in Blood Farms. This does not means that Vampires are safe, Farms can lose all Blood Bags or Coffins when other Vampires attack. All metadata and images are generated and stored on-chain.\\\",\\n                    // create the svg > base64 encode > prefix with data:image/svg...\\n                    abi.encodePacked(\\n                        \\\"data:image/svg+xml;base64,\\\",\\n                        Base64.encode(\\n                            bytes(\\n                                tt.isVampire\\n                                    ? makeVampireSVG(tt)\\n                                    : makeHumanSVG(tt)\\n                            )\\n                        )\\n                    ),\\n                    tt.isVampire\\n                        ? makeVampireMetadata(tt, genZero)\\n                        : makeHumanMetadata(tt, genZero)\\n                );\\n        }\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '{\\\"name\\\":\\\"Coffin #',\\n                    tokenId.toString(),\\n                    '\\\",\\\"description\\\":\\\"A coffin from The Vampire Game. Whats inside? A Human or a Vampire?\\\",\\\"image\\\":\\\"',\\n                    unrevealedImage,\\n                    '\\\"}'\\n                )\\n            );\\n    }\\n\\n    /// @notice generate the on-chain token metadata\\n    /// @param tokenId the token id to be generated\\n    /// @return the metadata string using data:application/json;base64\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (string memory)\\n    {\\n        string memory metadata = tokenMetadata(tokenId);\\n\\n        // create metadata |> base64 encode |> prefix with data:application/json...\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:application/json;base64,\\\",\\n                    Base64.encode(bytes(metadata))\\n                )\\n            );\\n    }\\n\\n    /// ==== Only Owner\\n\\n    /// @notice sets the image that will be shown when nft is not yet revealed\\n    /// @param _unrevealedImage the image, could be a link or base64 encoded img\\n    function setUnrevealedImage(string calldata _unrevealedImage)\\n        external\\n        onlyOwner\\n    {\\n        unrevealedImage = _unrevealedImage;\\n    }\\n\\n    /// @notice set the address of the VampireGame contract\\n    /// @param vgameAddress the VampireGame contract address\\n    function setVampireGame(address vgameAddress) external onlyOwner {\\n        vgame = IVampireGame(vgameAddress);\\n    }\\n\\n    /// @notice Upload trait variants for each trait type\\n    /// list of trait types:\\n    /// 0  - Human - Skin\\n    /// 1  - Human - Face\\n    /// 2  - Human - T-Shirt\\n    /// 3  - Human - Pants\\n    /// 4  - Human - Boots\\n    /// 5  - Human - Accessory\\n    /// 6  - Human - Hair\\n    /// 7  - NONE\\n    /// 8  - NONE\\n    /// 9  - Vampire - Skin\\n    /// 10 - Vampire - Face\\n    /// 11 - Vampire - Clothes\\n    /// 12 - NONE\\n    /// 13 - NONE\\n    /// 14 - NONE\\n    /// 15 - NONE\\n    /// 16 - Vampire - Cape\\n    /// 17 - Vampire - Predator Index\\n    /// @param traitType the index of the traitType.\\n    /// @param traitIds the list of ids of each trait\\n    /// @param traits the list of traits with name and base64 encoded png. Should match the length of traitIds.\\n    function setTraits(\\n        uint8 traitType,\\n        uint8[] calldata traitIds,\\n        Trait[] calldata traits\\n    ) external onlyOwner {\\n        require(traitIds.length == traits.length, \\\"INPUTS_DIFFERENT_LENGTH\\\");\\n        for (uint256 i = 0; i < traits.length; i++) {\\n            traitData[traitType][traitIds[i]] = Trait(\\n                traits[i].name,\\n                traits[i].png\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IVampireGame.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.6;\\n\\nimport \\\"./traits/TokenTraits.sol\\\";\\n\\n/// @notice Interface to interact with the VampireGame contract\\ninterface IVampireGame {\\n    /// @notice get the total supply of gen-0\\n    function getGenZeroSupply() external view returns (uint256);\\n\\n    /// @notice get the total supply of tokens\\n    function getMaxSupply() external view returns (uint256);\\n\\n    /// @notice get the TokenTraits for a given tokenId\\n    function getTokenTraits(uint256 tokenId) external view returns (TokenTraits memory);\\n\\n    /// @notice returns true if a token is aleady revealed\\n    function isTokenRevealed(uint256 tokenId) external view returns (bool);\\n}\\n\\n/// @notice Interface to control parts of the VampireGame ERC 721\\ninterface IVampireGameControls {\\n    /// @notice mint any amount of nft to any address\\n    /// Requirements:\\n    /// - message sender should be an allowed address (game contract)\\n    /// - amount + totalSupply() has to be smaller than MAX_SUPPLY\\n    function mintFromController(address receiver, uint256 amount) external;\\n\\n    /// @notice reveal a list of tokens using specific seeds for each\\n    function controllerRevealTokens(uint256[] calldata tokenIds, uint256[] calldata _seeds) external;\\n}\\n\"\r\n    },\r\n    \"contracts/traits/TraitMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\n/// @notice A library with functions to generate VampireGame NFT metadata\\nlibrary TraitMetadata {\\n    /// @notice Generate an NFT metadata\\n    /// @param name a string with the NFT name\\n    /// @param description a string with the NFT description,\\n    /// @param image a string with the NFT encoded image\\n    /// @param attributes a JSON string with the NFT attributes\\n    /// @return a JSON string with the NFT metadata\\n    function makeMetadata(\\n        bytes memory name,\\n        string memory description,\\n        bytes memory image,\\n        string memory attributes\\n    ) internal pure returns (string memory) {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '{\\\"name\\\":\\\"',\\n                    name,\\n                    '\\\",\\\"description\\\":\\\"',\\n                    description,\\n                    '\\\",\\\"image\\\":\\\"',\\n                    image,\\n                    '\\\",\\\"attributes\\\":',\\n                    attributes,\\n                    \\\"}\\\"\\n                )\\n            );\\n    }\\n\\n    /// @notice Generates a JSON string for an NFT metadata attribute\\n    /// @param traitType the attribute trait type\\n    /// @param value the attribute value\\n    /// @return a JSON string for the attribute\\n    function makeAttributeJSON(string memory traitType, string memory value)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '{\\\"trait_type\\\":\\\"',\\n                    traitType,\\n                    '\\\",\\\"value\\\":\\\"',\\n                    value,\\n                    '\\\"}'\\n                )\\n            );\\n    }\\n\\n    /// @notice Generates a string with a JSON array containing all the attributes\\n    /// @param attributes a list of JSON strings of each attribute\\n    /// @return the JSON string with the attribute list\\n    function makeAttributeListJSON(string[] memory attributes)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes memory attributeListBytes = \\\"[\\\";\\n\\n        for (uint256 i = 0; i < attributes.length; i++) {\\n            attributeListBytes = abi.encodePacked(\\n                attributeListBytes,\\n                attributes[i],\\n                i != attributes.length - 1 ? \\\",\\\" : \\\"]\\\"\\n            );\\n        }\\n\\n        return string(attributeListBytes);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/traits/TraitDraw.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.6;\\n\\n/// @notice A library with functions to draw VampireGame SVGs\\nlibrary TraitDraw {\\n    /// @notice generates an <image> element using base64 encoded PNGs\\n    /// @param png the base64 encoded PNG data\\n    /// @return a string with the <image> element\\n    function drawImageTag(string memory png)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<image x=\\\"4\\\" y=\\\"4\\\" width=\\\"32\\\" height=\\\"32\\\" image-rendering=\\\"pixelated\\\" preserveAspectRatio=\\\"xMidYMid\\\" xlink:href=\\\"data:image/png;base64,',\\n                    png,\\n                    '\\\"/>'\\n                )\\n            );\\n    }\\n\\n    /// @notice draw an SVG using png image data\\n    /// @param images a list of images generated with drawImageTag\\n    /// @return the SVG tag with all png images\\n    function drawSVG(string[] memory images)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes memory imagesBytes;\\n\\n        for (uint256 i = 0; i < images.length; i++) {\\n            imagesBytes = abi.encodePacked(imagesBytes, images[i]);\\n        }\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<svg id=\\\"vampiregame\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 40 40\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">',\\n                    string(imagesBytes),\\n                    \\\"</svg>\\\"\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/traits/TokenTraits.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.6;\\n\\nstruct TokenTraits {\\n    /// @dev every initialised token should have this as true\\n    /// this is just used to check agains a non-initialized struct\\n    bool exists;\\n    bool isVampire;\\n    // Shared Traits\\n    uint8 skin;\\n    uint8 face;\\n    uint8 clothes;\\n    // Human-only Traits\\n    uint8 pants;\\n    uint8 boots;\\n    uint8 accessory;\\n    uint8 hair;\\n    // Vampire-only Traits\\n    uint8 cape;\\n    uint8 predatorIndex;\\n}\"\r\n    },\r\n    \"contracts/traits/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Source: https://github.com/Brechtpd/base64/blob/4d85607b18d981acff392d2e99ba654305552a97/base64.sol\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\n/// @notice removed decoding function from original code\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n}\"\r\n    },\r\n    \"contracts/traits/ITraits.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.6;\\n\\ninterface ITraits {\\n  function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"traitType\",\"type\":\"uint8\"},{\"internalType\":\"uint8[]\",\"name\":\"traitIds\",\"type\":\"uint8[]\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"png\",\"type\":\"string\"}],\"internalType\":\"struct Traits.Trait[]\",\"name\":\"traits\",\"type\":\"tuple[]\"}],\"name\":\"setTraits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_unrevealedImage\",\"type\":\"string\"}],\"name\":\"setUnrevealedImage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vgameAddress\",\"type\":\"address\"}],\"name\":\"setVampireGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"traitData\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"png\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vgame\",\"outputs\":[{\"internalType\":\"contract IVampireGame\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Traits","CompilerVersion":"v0.8.7+commit.e28d00a7","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":"0","Implementation":"","SwarmSource":""}]}